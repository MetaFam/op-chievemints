{"version":3,"file":"ccip-543a808d.js","sources":["../../node_modules/viem/_esm/errors/ccip.js","../../node_modules/viem/_esm/utils/address/isAddressEqual.js","../../node_modules/viem/_esm/utils/ccip.js"],"sourcesContent":["import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {\n        super(cause.shortMessage ||\n            'An error occurred while fetching for an offchain result.', {\n            cause,\n            metaMessages: [\n                ...(cause.metaMessages || []),\n                cause.metaMessages?.length ? '' : [],\n                'Offchain Gateway Call:',\n                urls && [\n                    '  Gateway URL(s):',\n                    ...urls.map((url) => `    ${getUrl(url)}`),\n                ],\n                `  Sender: ${sender}`,\n                `  Data: ${data}`,\n                `  Callback selector: ${callbackSelector}`,\n                `  Extra data: ${extraData}`,\n            ].flat(),\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupError'\n        });\n    }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n    constructor({ result, url }) {\n        super('Offchain gateway response is malformed. Response data must be a hex value.', {\n            metaMessages: [\n                `Gateway URL: ${getUrl(url)}`,\n                `Response: ${stringify(result)}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupResponseMalformedError'\n        });\n    }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n    constructor({ sender, to }) {\n        super('Reverted sender address does not match target contract address (`to`).', {\n            metaMessages: [\n                `Contract address: ${to}`,\n                `OffchainLookup sender address: ${sender}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupSenderMismatchError'\n        });\n    }\n}\n//# sourceMappingURL=ccip.js.map","import { InvalidAddressError, } from '../../errors/address.js';\nimport { isAddress } from './isAddress.js';\nexport function isAddressEqual(a, b) {\n    if (!isAddress(a))\n        throw new InvalidAddressError({ address: a });\n    if (!isAddress(b))\n        throw new InvalidAddressError({ address: b });\n    return a.toLowerCase() === b.toLowerCase();\n}\n//# sourceMappingURL=isAddressEqual.js.map","import { call } from '../actions/public/call.js';\nimport {} from '../errors/base.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError, } from '../errors/ccip.js';\nimport { HttpRequestError } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n    name: 'OffchainLookup',\n    type: 'error',\n    inputs: [\n        {\n            name: 'sender',\n            type: 'address',\n        },\n        {\n            name: 'urls',\n            type: 'string[]',\n        },\n        {\n            name: 'callData',\n            type: 'bytes',\n        },\n        {\n            name: 'callbackFunction',\n            type: 'bytes4',\n        },\n        {\n            name: 'extraData',\n            type: 'bytes',\n        },\n    ],\n};\nexport async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {\n    const { args } = decodeErrorResult({\n        data,\n        abi: [offchainLookupAbiItem],\n    });\n    const [sender, urls, callData, callbackSelector, extraData] = args;\n    try {\n        if (!isAddressEqual(to, sender))\n            throw new OffchainLookupSenderMismatchError({ sender, to });\n        const result = await ccipFetch({ data: callData, sender, urls });\n        const { data: data_ } = await call(client, {\n            blockNumber,\n            blockTag,\n            data: concat([\n                callbackSelector,\n                encodeAbiParameters([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),\n            ]),\n            to,\n        });\n        return data_;\n    }\n    catch (err) {\n        throw new OffchainLookupError({\n            callbackSelector,\n            cause: err,\n            data,\n            extraData,\n            sender,\n            urls,\n        });\n    }\n}\nexport async function ccipFetch({ data, sender, urls, }) {\n    let error = new Error('An unknown error occurred.');\n    for (let i = 0; i < urls.length; i++) {\n        const url = urls[i];\n        const method = url.includes('{data}') ? 'GET' : 'POST';\n        const body = method === 'POST' ? { data, sender } : undefined;\n        try {\n            const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n                body: JSON.stringify(body),\n                method,\n            });\n            let result;\n            if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n                result = (await response.json()).data;\n            }\n            else {\n                result = (await response.text());\n            }\n            if (!response.ok) {\n                error = new HttpRequestError({\n                    body,\n                    details: result?.error\n                        ? stringify(result.error)\n                        : response.statusText,\n                    headers: response.headers,\n                    status: response.status,\n                    url,\n                });\n                continue;\n            }\n            if (!isHex(result)) {\n                error = new OffchainLookupResponseMalformedError({\n                    result,\n                    url,\n                });\n                continue;\n            }\n            return result;\n        }\n        catch (err) {\n            error = new HttpRequestError({\n                body,\n                details: err.message,\n                url,\n            });\n        }\n    }\n    throw error;\n}\n//# sourceMappingURL=ccip.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0,1,2]}