function _mergeNamespaces(n4, m2) {
  for (var i3 = 0; i3 < m2.length; i3++) {
    const e2 = m2[i3];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k3 in e2) {
        if (k3 !== "default" && !(k3 in n4)) {
          const d3 = Object.getOwnPropertyDescriptor(e2, k3);
          if (d3) {
            Object.defineProperty(n4, k3, d3.get ? d3 : {
              enumerable: true,
              get: () => e2[k3]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n4, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n4) {
  if (n4.__esModule)
    return n4;
  var f4 = n4.default;
  if (typeof f4 == "function") {
    var a3 = function a4() {
      if (this instanceof a4) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f4, args);
        return new Ctor();
      }
      return f4.apply(this, arguments);
    };
    a3.prototype = f4.prototype;
  } else
    a3 = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  Object.keys(n4).forEach(function(k3) {
    var d3 = Object.getOwnPropertyDescriptor(n4, k3);
    Object.defineProperty(a3, k3, d3.get ? d3 : {
      enumerable: true,
      get: function() {
        return n4[k3];
      }
    });
  });
  return a3;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min$1 = {};
var react = { exports: {} };
var react_production_min$1 = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$7 = Symbol.for("react.element"), n$9 = Symbol.for("react.portal"), p$a = Symbol.for("react.fragment"), q$5 = Symbol.for("react.strict_mode"), r$c = Symbol.for("react.profiler"), t$8 = Symbol.for("react.provider"), u$7 = Symbol.for("react.context"), v$8 = Symbol.for("react.forward_ref"), w$7 = Symbol.for("react.suspense"), x$5 = Symbol.for("react.memo"), y$9 = Symbol.for("react.lazy"), z$8 = Symbol.iterator;
function A$7(a3) {
  if (null === a3 || "object" !== typeof a3)
    return null;
  a3 = z$8 && a3[z$8] || a3["@@iterator"];
  return "function" === typeof a3 ? a3 : null;
}
var B$7 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$5 = Object.assign, D$7 = {};
function E$7(a3, b4, e2) {
  this.props = a3;
  this.context = b4;
  this.refs = D$7;
  this.updater = e2 || B$7;
}
E$7.prototype.isReactComponent = {};
E$7.prototype.setState = function(a3, b4) {
  if ("object" !== typeof a3 && "function" !== typeof a3 && null != a3)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a3, b4, "setState");
};
E$7.prototype.forceUpdate = function(a3) {
  this.updater.enqueueForceUpdate(this, a3, "forceUpdate");
};
function F$6() {
}
F$6.prototype = E$7.prototype;
function G$3(a3, b4, e2) {
  this.props = a3;
  this.context = b4;
  this.refs = D$7;
  this.updater = e2 || B$7;
}
var H$6 = G$3.prototype = new F$6();
H$6.constructor = G$3;
C$5(H$6, E$7.prototype);
H$6.isPureReactComponent = true;
var I$5 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$8 = { current: null }, L$6 = { key: true, ref: true, __self: true, __source: true };
function M$6(a3, b4, e2) {
  var d3, c2 = {}, k3 = null, h5 = null;
  if (null != b4)
    for (d3 in void 0 !== b4.ref && (h5 = b4.ref), void 0 !== b4.key && (k3 = "" + b4.key), b4)
      J$1.call(b4, d3) && !L$6.hasOwnProperty(d3) && (c2[d3] = b4[d3]);
  var g3 = arguments.length - 2;
  if (1 === g3)
    c2.children = e2;
  else if (1 < g3) {
    for (var f4 = Array(g3), m2 = 0; m2 < g3; m2++)
      f4[m2] = arguments[m2 + 2];
    c2.children = f4;
  }
  if (a3 && a3.defaultProps)
    for (d3 in g3 = a3.defaultProps, g3)
      void 0 === c2[d3] && (c2[d3] = g3[d3]);
  return { $$typeof: l$7, type: a3, key: k3, ref: h5, props: c2, _owner: K$8.current };
}
function N$7(a3, b4) {
  return { $$typeof: l$7, type: a3.type, key: b4, ref: a3.ref, props: a3.props, _owner: a3._owner };
}
function O$7(a3) {
  return "object" === typeof a3 && null !== a3 && a3.$$typeof === l$7;
}
function escape$1(a3) {
  var b4 = { "=": "=0", ":": "=2" };
  return "$" + a3.replace(/[=:]/g, function(a4) {
    return b4[a4];
  });
}
var P$7 = /\/+/g;
function Q$6(a3, b4) {
  return "object" === typeof a3 && null !== a3 && null != a3.key ? escape$1("" + a3.key) : b4.toString(36);
}
function R$5(a3, b4, e2, d3, c2) {
  var k3 = typeof a3;
  if ("undefined" === k3 || "boolean" === k3)
    a3 = null;
  var h5 = false;
  if (null === a3)
    h5 = true;
  else
    switch (k3) {
      case "string":
      case "number":
        h5 = true;
        break;
      case "object":
        switch (a3.$$typeof) {
          case l$7:
          case n$9:
            h5 = true;
        }
    }
  if (h5)
    return h5 = a3, c2 = c2(h5), a3 = "" === d3 ? "." + Q$6(h5, 0) : d3, I$5(c2) ? (e2 = "", null != a3 && (e2 = a3.replace(P$7, "$&/") + "/"), R$5(c2, b4, e2, "", function(a4) {
      return a4;
    })) : null != c2 && (O$7(c2) && (c2 = N$7(c2, e2 + (!c2.key || h5 && h5.key === c2.key ? "" : ("" + c2.key).replace(P$7, "$&/") + "/") + a3)), b4.push(c2)), 1;
  h5 = 0;
  d3 = "" === d3 ? "." : d3 + ":";
  if (I$5(a3))
    for (var g3 = 0; g3 < a3.length; g3++) {
      k3 = a3[g3];
      var f4 = d3 + Q$6(k3, g3);
      h5 += R$5(k3, b4, e2, f4, c2);
    }
  else if (f4 = A$7(a3), "function" === typeof f4)
    for (a3 = f4.call(a3), g3 = 0; !(k3 = a3.next()).done; )
      k3 = k3.value, f4 = d3 + Q$6(k3, g3++), h5 += R$5(k3, b4, e2, f4, c2);
  else if ("object" === k3)
    throw b4 = String(a3), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b4 ? "object with keys {" + Object.keys(a3).join(", ") + "}" : b4) + "). If you meant to render a collection of children, use an array instead.");
  return h5;
}
function S$8(a3, b4, e2) {
  if (null == a3)
    return a3;
  var d3 = [], c2 = 0;
  R$5(a3, d3, "", "", function(a4) {
    return b4.call(e2, a4, c2++);
  });
  return d3;
}
function T$6(a3) {
  if (-1 === a3._status) {
    var b4 = a3._result;
    b4 = b4();
    b4.then(function(b5) {
      if (0 === a3._status || -1 === a3._status)
        a3._status = 1, a3._result = b5;
    }, function(b5) {
      if (0 === a3._status || -1 === a3._status)
        a3._status = 2, a3._result = b5;
    });
    -1 === a3._status && (a3._status = 0, a3._result = b4);
  }
  if (1 === a3._status)
    return a3._result.default;
  throw a3._result;
}
var U$6 = { current: null }, V$6 = { transition: null }, W$9 = { ReactCurrentDispatcher: U$6, ReactCurrentBatchConfig: V$6, ReactCurrentOwner: K$8 };
var Children = react_production_min$1.Children = { map: S$8, forEach: function(a3, b4, e2) {
  S$8(a3, function() {
    b4.apply(this, arguments);
  }, e2);
}, count: function(a3) {
  var b4 = 0;
  S$8(a3, function() {
    b4++;
  });
  return b4;
}, toArray: function(a3) {
  return S$8(a3, function(a4) {
    return a4;
  }) || [];
}, only: function(a3) {
  if (!O$7(a3))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a3;
} };
var Component = react_production_min$1.Component = E$7;
var Fragment$3 = react_production_min$1.Fragment = p$a;
var Profiler = react_production_min$1.Profiler = r$c;
var PureComponent = react_production_min$1.PureComponent = G$3;
var StrictMode = react_production_min$1.StrictMode = q$5;
var Suspense = react_production_min$1.Suspense = w$7;
var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED$1 = react_production_min$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$9;
var cloneElement = react_production_min$1.cloneElement = function(a3, b4, e2) {
  if (null === a3 || void 0 === a3)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a3 + ".");
  var d3 = C$5({}, a3.props), c2 = a3.key, k3 = a3.ref, h5 = a3._owner;
  if (null != b4) {
    void 0 !== b4.ref && (k3 = b4.ref, h5 = K$8.current);
    void 0 !== b4.key && (c2 = "" + b4.key);
    if (a3.type && a3.type.defaultProps)
      var g3 = a3.type.defaultProps;
    for (f4 in b4)
      J$1.call(b4, f4) && !L$6.hasOwnProperty(f4) && (d3[f4] = void 0 === b4[f4] && void 0 !== g3 ? g3[f4] : b4[f4]);
  }
  var f4 = arguments.length - 2;
  if (1 === f4)
    d3.children = e2;
  else if (1 < f4) {
    g3 = Array(f4);
    for (var m2 = 0; m2 < f4; m2++)
      g3[m2] = arguments[m2 + 2];
    d3.children = g3;
  }
  return { $$typeof: l$7, type: a3.type, key: c2, ref: k3, props: d3, _owner: h5 };
};
var createContext = react_production_min$1.createContext = function(a3) {
  a3 = { $$typeof: u$7, _currentValue: a3, _currentValue2: a3, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a3.Provider = { $$typeof: t$8, _context: a3 };
  return a3.Consumer = a3;
};
var createElement = react_production_min$1.createElement = M$6;
var createFactory = react_production_min$1.createFactory = function(a3) {
  var b4 = M$6.bind(null, a3);
  b4.type = a3;
  return b4;
};
var createRef = react_production_min$1.createRef = function() {
  return { current: null };
};
var forwardRef = react_production_min$1.forwardRef = function(a3) {
  return { $$typeof: v$8, render: a3 };
};
var isValidElement = react_production_min$1.isValidElement = O$7;
var lazy$1 = react_production_min$1.lazy = function(a3) {
  return { $$typeof: y$9, _payload: { _status: -1, _result: a3 }, _init: T$6 };
};
var memo = react_production_min$1.memo = function(a3, b4) {
  return { $$typeof: x$5, type: a3, compare: void 0 === b4 ? null : b4 };
};
var startTransition = react_production_min$1.startTransition = function(a3) {
  var b4 = V$6.transition;
  V$6.transition = {};
  try {
    a3();
  } finally {
    V$6.transition = b4;
  }
};
var unstable_act = react_production_min$1.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
var useCallback = react_production_min$1.useCallback = function(a3, b4) {
  return U$6.current.useCallback(a3, b4);
};
var useContext = react_production_min$1.useContext = function(a3) {
  return U$6.current.useContext(a3);
};
var useDebugValue = react_production_min$1.useDebugValue = function() {
};
var useDeferredValue = react_production_min$1.useDeferredValue = function(a3) {
  return U$6.current.useDeferredValue(a3);
};
var useEffect = react_production_min$1.useEffect = function(a3, b4) {
  return U$6.current.useEffect(a3, b4);
};
var useId = react_production_min$1.useId = function() {
  return U$6.current.useId();
};
var useImperativeHandle = react_production_min$1.useImperativeHandle = function(a3, b4, e2) {
  return U$6.current.useImperativeHandle(a3, b4, e2);
};
var useInsertionEffect = react_production_min$1.useInsertionEffect = function(a3, b4) {
  return U$6.current.useInsertionEffect(a3, b4);
};
var useLayoutEffect = react_production_min$1.useLayoutEffect = function(a3, b4) {
  return U$6.current.useLayoutEffect(a3, b4);
};
var useMemo = react_production_min$1.useMemo = function(a3, b4) {
  return U$6.current.useMemo(a3, b4);
};
var useReducer = react_production_min$1.useReducer = function(a3, b4, e2) {
  return U$6.current.useReducer(a3, b4, e2);
};
var useRef = react_production_min$1.useRef = function(a3) {
  return U$6.current.useRef(a3);
};
var useState = react_production_min$1.useState = function(a3) {
  return U$6.current.useState(a3);
};
var useSyncExternalStore = react_production_min$1.useSyncExternalStore = function(a3, b4, e2) {
  return U$6.current.useSyncExternalStore(a3, b4, e2);
};
var useTransition = react_production_min$1.useTransition = function() {
  return U$6.current.useTransition();
};
var version$r = react_production_min$1.version = "18.2.0";
const react_production_min = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  Children,
  Component,
  Fragment: Fragment$3,
  Profiler,
  PureComponent,
  StrictMode,
  Suspense,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED$1,
  cloneElement,
  createContext,
  createElement,
  createFactory,
  createRef,
  default: react_production_min$1,
  forwardRef,
  isValidElement,
  lazy: lazy$1,
  memo,
  startTransition,
  unstable_act,
  useCallback,
  useContext,
  useDebugValue,
  useDeferredValue,
  useEffect,
  useId,
  useImperativeHandle,
  useInsertionEffect,
  useLayoutEffect,
  useMemo,
  useReducer,
  useRef,
  useState,
  useSyncExternalStore,
  useTransition,
  version: version$r
}, [react_production_min$1]);
const require$$0$1A = /* @__PURE__ */ getAugmentedNamespace(react_production_min);
{
  react.exports = require$$0$1A;
}
var reactExports = react.exports;
const React$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React$1
}, [reactExports]);
const require$$0$1z = /* @__PURE__ */ getAugmentedNamespace(React$2);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$a = require$$0$1z, k$8 = Symbol.for("react.element"), l$6 = Symbol.for("react.fragment"), m$7 = Object.prototype.hasOwnProperty, n$8 = f$a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$9 = { key: true, ref: true, __self: true, __source: true };
function q$4(c2, a3, g3) {
  var b4, d3 = {}, e2 = null, h5 = null;
  void 0 !== g3 && (e2 = "" + g3);
  void 0 !== a3.key && (e2 = "" + a3.key);
  void 0 !== a3.ref && (h5 = a3.ref);
  for (b4 in a3)
    m$7.call(a3, b4) && !p$9.hasOwnProperty(b4) && (d3[b4] = a3[b4]);
  if (c2 && c2.defaultProps)
    for (b4 in a3 = c2.defaultProps, a3)
      void 0 === d3[b4] && (d3[b4] = a3[b4]);
  return { $$typeof: k$8, type: c2, key: e2, ref: h5, props: d3, _owner: n$8.current };
}
var Fragment$2 = reactJsxRuntime_production_min$1.Fragment = l$6;
var jsx$1 = reactJsxRuntime_production_min$1.jsx = q$4;
var jsxs$1 = reactJsxRuntime_production_min$1.jsxs = q$4;
const reactJsxRuntime_production_min = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  Fragment: Fragment$2,
  default: reactJsxRuntime_production_min$1,
  jsx: jsx$1,
  jsxs: jsxs$1
}, [reactJsxRuntime_production_min$1]);
const require$$0$1y = /* @__PURE__ */ getAugmentedNamespace(reactJsxRuntime_production_min);
{
  jsxRuntime.exports = require$$0$1y;
}
var jsxRuntimeExports = jsxRuntime.exports;
const Fragment$1 = jsxRuntimeExports.Fragment;
const jsx = jsxRuntimeExports.jsx;
const jsxs = jsxRuntimeExports.jsxs;
const scriptRel = function detectScriptRel() {
  const relList = document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep2) {
  return "/" + dep2;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links2 = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep2) => {
    dep2 = assetsURL(dep2);
    if (dep2 in seen)
      return;
    seen[dep2] = true;
    const isCss = dep2.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i3 = links2.length - 1; i3 >= 0; i3--) {
        const link2 = links2[i3];
        if (link2.href === dep2 && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep2}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep2;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep2}`)));
      });
    }
  })).then(() => baseModule());
};
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
const ReactPropTypesSecret$2 = /* @__PURE__ */ getDefaultExportFromCjs(ReactPropTypesSecret_1);
const ReactPropTypesSecret$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ReactPropTypesSecret$2
}, [ReactPropTypesSecret_1]);
const require$$0$1x = /* @__PURE__ */ getAugmentedNamespace(ReactPropTypesSecret$3);
var ReactPropTypesSecret = require$$0$1x;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location2, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
const factoryWithThrowingShims$1 = /* @__PURE__ */ getDefaultExportFromCjs(factoryWithThrowingShims);
const factoryWithThrowingShims$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: factoryWithThrowingShims$1
}, [factoryWithThrowingShims]);
const require$$0$1w = /* @__PURE__ */ getAugmentedNamespace(factoryWithThrowingShims$2);
{
  propTypes.exports = require$$0$1w();
}
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
function _interopDefault(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var React = require$$0$1z;
var React__default = _interopDefault(React);
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var canUseDOM$1 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function withSideEffect(reducePropsToState3, handleStateChangeOnClient, mapStateOnServer3) {
  if (typeof reducePropsToState3 !== "function") {
    throw new Error("Expected reducePropsToState to be a function.");
  }
  if (typeof handleStateChangeOnClient !== "function") {
    throw new Error("Expected handleStateChangeOnClient to be a function.");
  }
  if (typeof mapStateOnServer3 !== "undefined" && typeof mapStateOnServer3 !== "function") {
    throw new Error("Expected mapStateOnServer to either be undefined or a function.");
  }
  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || "Component";
  }
  return function wrap2(WrappedComponent) {
    if (typeof WrappedComponent !== "function") {
      throw new Error("Expected WrappedComponent to be a React component.");
    }
    var mountedInstances = [];
    var state2;
    function emitChange() {
      state2 = reducePropsToState3(mountedInstances.map(function(instance2) {
        return instance2.props;
      }));
      if (SideEffect.canUseDOM) {
        handleStateChangeOnClient(state2);
      } else if (mapStateOnServer3) {
        state2 = mapStateOnServer3(state2);
      }
    }
    var SideEffect = /* @__PURE__ */ function(_PureComponent) {
      _inheritsLoose$1(SideEffect2, _PureComponent);
      function SideEffect2() {
        return _PureComponent.apply(this, arguments) || this;
      }
      SideEffect2.peek = function peek() {
        return state2;
      };
      SideEffect2.rewind = function rewind() {
        if (SideEffect2.canUseDOM) {
          throw new Error("You may only call rewind() on the server. Call peek() to read the current state.");
        }
        var recordedState = state2;
        state2 = void 0;
        mountedInstances = [];
        return recordedState;
      };
      var _proto = SideEffect2.prototype;
      _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {
        mountedInstances.push(this);
        emitChange();
      };
      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        var index2 = mountedInstances.indexOf(this);
        mountedInstances.splice(index2, 1);
        emitChange();
      };
      _proto.render = function render3() {
        return React__default.createElement(WrappedComponent, this.props);
      };
      return SideEffect2;
    }(React.PureComponent);
    _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");
    _defineProperty(SideEffect, "canUseDOM", canUseDOM$1);
    return SideEffect;
  };
}
var lib$4 = withSideEffect;
const withSideEffect$1 = /* @__PURE__ */ getDefaultExportFromCjs(lib$4);
var hasElementType = typeof Element !== "undefined";
var hasMap$1 = typeof Map === "function";
var hasSet$1 = typeof Set === "function";
var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
function equal$3(a3, b4) {
  if (a3 === b4)
    return true;
  if (a3 && b4 && typeof a3 == "object" && typeof b4 == "object") {
    if (a3.constructor !== b4.constructor)
      return false;
    var length2, i3, keys2;
    if (Array.isArray(a3)) {
      length2 = a3.length;
      if (length2 != b4.length)
        return false;
      for (i3 = length2; i3-- !== 0; )
        if (!equal$3(a3[i3], b4[i3]))
          return false;
      return true;
    }
    var it2;
    if (hasMap$1 && a3 instanceof Map && b4 instanceof Map) {
      if (a3.size !== b4.size)
        return false;
      it2 = a3.entries();
      while (!(i3 = it2.next()).done)
        if (!b4.has(i3.value[0]))
          return false;
      it2 = a3.entries();
      while (!(i3 = it2.next()).done)
        if (!equal$3(i3.value[1], b4.get(i3.value[0])))
          return false;
      return true;
    }
    if (hasSet$1 && a3 instanceof Set && b4 instanceof Set) {
      if (a3.size !== b4.size)
        return false;
      it2 = a3.entries();
      while (!(i3 = it2.next()).done)
        if (!b4.has(i3.value[0]))
          return false;
      return true;
    }
    if (hasArrayBuffer && ArrayBuffer.isView(a3) && ArrayBuffer.isView(b4)) {
      length2 = a3.length;
      if (length2 != b4.length)
        return false;
      for (i3 = length2; i3-- !== 0; )
        if (a3[i3] !== b4[i3])
          return false;
      return true;
    }
    if (a3.constructor === RegExp)
      return a3.source === b4.source && a3.flags === b4.flags;
    if (a3.valueOf !== Object.prototype.valueOf)
      return a3.valueOf() === b4.valueOf();
    if (a3.toString !== Object.prototype.toString)
      return a3.toString() === b4.toString();
    keys2 = Object.keys(a3);
    length2 = keys2.length;
    if (length2 !== Object.keys(b4).length)
      return false;
    for (i3 = length2; i3-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b4, keys2[i3]))
        return false;
    if (hasElementType && a3 instanceof Element)
      return false;
    for (i3 = length2; i3-- !== 0; ) {
      if ((keys2[i3] === "_owner" || keys2[i3] === "__v" || keys2[i3] === "__o") && a3.$$typeof) {
        continue;
      }
      if (!equal$3(a3[keys2[i3]], b4[keys2[i3]]))
        return false;
    }
    return true;
  }
  return a3 !== a3 && b4 !== b4;
}
var reactFastCompare = function isEqual2(a3, b4) {
  try {
    return equal$3(a3, b4);
  } catch (error) {
    if ((error.message || "").match(/stack|recursion/i)) {
      console.warn("react-fast-compare cannot handle circular refs");
      return false;
    }
    throw error;
  }
};
const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$8 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i3 = 0; i3 < 10; i3++) {
      test2["_" + String.fromCharCode(i3)] = i3;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n4) {
      return test2[n4];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from2;
  var to = toObject(target);
  var symbols;
  for (var s3 = 1; s3 < arguments.length; s3++) {
    from2 = Object(arguments[s3]);
    for (var key2 in from2) {
      if (hasOwnProperty$8.call(from2, key2)) {
        to[key2] = from2[key2];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from2);
      for (var i3 = 0; i3 < symbols.length; i3++) {
        if (propIsEnumerable.call(from2, symbols[i3])) {
          to[symbols[i3]] = from2[symbols[i3]];
        }
      }
    }
  }
  return to;
};
const objectAssign$1 = /* @__PURE__ */ getDefaultExportFromCjs(objectAssign);
var ATTRIBUTE_NAMES = {
  BODY: "bodyAttributes",
  HTML: "htmlAttributes",
  TITLE: "titleAttributes"
};
var TAG_NAMES = {
  BASE: "base",
  BODY: "body",
  HEAD: "head",
  HTML: "html",
  LINK: "link",
  META: "meta",
  NOSCRIPT: "noscript",
  SCRIPT: "script",
  STYLE: "style",
  TITLE: "title"
};
Object.keys(TAG_NAMES).map(function(name2) {
  return TAG_NAMES[name2];
});
var TAG_PROPERTIES = {
  CHARSET: "charset",
  CSS_TEXT: "cssText",
  HREF: "href",
  HTTPEQUIV: "http-equiv",
  INNER_HTML: "innerHTML",
  ITEM_PROP: "itemprop",
  NAME: "name",
  PROPERTY: "property",
  REL: "rel",
  SRC: "src",
  TARGET: "target"
};
var REACT_TAG_MAP = {
  accesskey: "accessKey",
  charset: "charSet",
  class: "className",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  "http-equiv": "httpEquiv",
  itemprop: "itemProp",
  tabindex: "tabIndex"
};
var HELMET_PROPS = {
  DEFAULT_TITLE: "defaultTitle",
  DEFER: "defer",
  ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
  ON_CHANGE_CLIENT_STATE: "onChangeClientState",
  TITLE_TEMPLATE: "titleTemplate"
};
var HTML_TAG_MAP = Object.keys(REACT_TAG_MAP).reduce(function(obj, key2) {
  obj[REACT_TAG_MAP[key2]] = key2;
  return obj;
}, {});
var SELF_CLOSING_TAGS = [TAG_NAMES.NOSCRIPT, TAG_NAMES.SCRIPT, TAG_NAMES.STYLE];
var HELMET_ATTRIBUTE = "data-react-helmet";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var classCallCheck = function(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var _extends$2 = Object.assign || function(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = arguments[i3];
    for (var key2 in source) {
      if (Object.prototype.hasOwnProperty.call(source, key2)) {
        target[key2] = source[key2];
      }
    }
  }
  return target;
};
var inherits$7 = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var objectWithoutProperties = function(obj, keys2) {
  var target = {};
  for (var i3 in obj) {
    if (keys2.indexOf(i3) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i3))
      continue;
    target[i3] = obj[i3];
  }
  return target;
};
var possibleConstructorReturn = function(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
};
var encodeSpecialCharacters = function encodeSpecialCharacters2(str) {
  var encode5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (encode5 === false) {
    return String(str);
  }
  return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
};
var getTitleFromPropsList = function getTitleFromPropsList2(propsList) {
  var innermostTitle = getInnermostProperty(propsList, TAG_NAMES.TITLE);
  var innermostTemplate = getInnermostProperty(propsList, HELMET_PROPS.TITLE_TEMPLATE);
  if (innermostTemplate && innermostTitle) {
    return innermostTemplate.replace(/%s/g, function() {
      return Array.isArray(innermostTitle) ? innermostTitle.join("") : innermostTitle;
    });
  }
  var innermostDefaultTitle = getInnermostProperty(propsList, HELMET_PROPS.DEFAULT_TITLE);
  return innermostTitle || innermostDefaultTitle || void 0;
};
var getOnChangeClientState = function getOnChangeClientState2(propsList) {
  return getInnermostProperty(propsList, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || function() {
  };
};
var getAttributesFromPropsList = function getAttributesFromPropsList2(tagType, propsList) {
  return propsList.filter(function(props) {
    return typeof props[tagType] !== "undefined";
  }).map(function(props) {
    return props[tagType];
  }).reduce(function(tagAttrs, current) {
    return _extends$2({}, tagAttrs, current);
  }, {});
};
var getBaseTagFromPropsList = function getBaseTagFromPropsList2(primaryAttributes, propsList) {
  return propsList.filter(function(props) {
    return typeof props[TAG_NAMES.BASE] !== "undefined";
  }).map(function(props) {
    return props[TAG_NAMES.BASE];
  }).reverse().reduce(function(innermostBaseTag, tag) {
    if (!innermostBaseTag.length) {
      var keys2 = Object.keys(tag);
      for (var i3 = 0; i3 < keys2.length; i3++) {
        var attributeKey = keys2[i3];
        var lowerCaseAttributeKey = attributeKey.toLowerCase();
        if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
          return innermostBaseTag.concat(tag);
        }
      }
    }
    return innermostBaseTag;
  }, []);
};
var getTagsFromPropsList = function getTagsFromPropsList2(tagName, primaryAttributes, propsList) {
  var approvedSeenTags = {};
  return propsList.filter(function(props) {
    if (Array.isArray(props[tagName])) {
      return true;
    }
    if (typeof props[tagName] !== "undefined") {
      warn("Helmet: " + tagName + ' should be of type "Array". Instead found type "' + _typeof(props[tagName]) + '"');
    }
    return false;
  }).map(function(props) {
    return props[tagName];
  }).reverse().reduce(function(approvedTags, instanceTags) {
    var instanceSeenTags = {};
    instanceTags.filter(function(tag) {
      var primaryAttributeKey = void 0;
      var keys3 = Object.keys(tag);
      for (var i4 = 0; i4 < keys3.length; i4++) {
        var attributeKey2 = keys3[i4];
        var lowerCaseAttributeKey = attributeKey2.toLowerCase();
        if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === TAG_PROPERTIES.REL && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === TAG_PROPERTIES.REL && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
          primaryAttributeKey = lowerCaseAttributeKey;
        }
        if (primaryAttributes.indexOf(attributeKey2) !== -1 && (attributeKey2 === TAG_PROPERTIES.INNER_HTML || attributeKey2 === TAG_PROPERTIES.CSS_TEXT || attributeKey2 === TAG_PROPERTIES.ITEM_PROP)) {
          primaryAttributeKey = attributeKey2;
        }
      }
      if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
        return false;
      }
      var value = tag[primaryAttributeKey].toLowerCase();
      if (!approvedSeenTags[primaryAttributeKey]) {
        approvedSeenTags[primaryAttributeKey] = {};
      }
      if (!instanceSeenTags[primaryAttributeKey]) {
        instanceSeenTags[primaryAttributeKey] = {};
      }
      if (!approvedSeenTags[primaryAttributeKey][value]) {
        instanceSeenTags[primaryAttributeKey][value] = true;
        return true;
      }
      return false;
    }).reverse().forEach(function(tag) {
      return approvedTags.push(tag);
    });
    var keys2 = Object.keys(instanceSeenTags);
    for (var i3 = 0; i3 < keys2.length; i3++) {
      var attributeKey = keys2[i3];
      var tagUnion = objectAssign$1({}, approvedSeenTags[attributeKey], instanceSeenTags[attributeKey]);
      approvedSeenTags[attributeKey] = tagUnion;
    }
    return approvedTags;
  }, []).reverse();
};
var getInnermostProperty = function getInnermostProperty2(propsList, property) {
  for (var i3 = propsList.length - 1; i3 >= 0; i3--) {
    var props = propsList[i3];
    if (props.hasOwnProperty(property)) {
      return props[property];
    }
  }
  return null;
};
var reducePropsToState = function reducePropsToState2(propsList) {
  return {
    baseTag: getBaseTagFromPropsList([TAG_PROPERTIES.HREF, TAG_PROPERTIES.TARGET], propsList),
    bodyAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.BODY, propsList),
    defer: getInnermostProperty(propsList, HELMET_PROPS.DEFER),
    encode: getInnermostProperty(propsList, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
    htmlAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.HTML, propsList),
    linkTags: getTagsFromPropsList(TAG_NAMES.LINK, [TAG_PROPERTIES.REL, TAG_PROPERTIES.HREF], propsList),
    metaTags: getTagsFromPropsList(TAG_NAMES.META, [TAG_PROPERTIES.NAME, TAG_PROPERTIES.CHARSET, TAG_PROPERTIES.HTTPEQUIV, TAG_PROPERTIES.PROPERTY, TAG_PROPERTIES.ITEM_PROP], propsList),
    noscriptTags: getTagsFromPropsList(TAG_NAMES.NOSCRIPT, [TAG_PROPERTIES.INNER_HTML], propsList),
    onChangeClientState: getOnChangeClientState(propsList),
    scriptTags: getTagsFromPropsList(TAG_NAMES.SCRIPT, [TAG_PROPERTIES.SRC, TAG_PROPERTIES.INNER_HTML], propsList),
    styleTags: getTagsFromPropsList(TAG_NAMES.STYLE, [TAG_PROPERTIES.CSS_TEXT], propsList),
    title: getTitleFromPropsList(propsList),
    titleAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.TITLE, propsList)
  };
};
var rafPolyfill = function() {
  var clock = Date.now();
  return function(callback) {
    var currentTime = Date.now();
    if (currentTime - clock > 16) {
      clock = currentTime;
      callback(currentTime);
    } else {
      setTimeout(function() {
        rafPolyfill(callback);
      }, 0);
    }
  };
}();
var cafPolyfill = function cafPolyfill2(id2) {
  return clearTimeout(id2);
};
var requestAnimationFrame$1 = typeof window !== "undefined" ? window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || rafPolyfill : global.requestAnimationFrame || rafPolyfill;
var cancelAnimationFrame$1 = typeof window !== "undefined" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || cafPolyfill : global.cancelAnimationFrame || cafPolyfill;
var warn = function warn2(msg) {
  return console && typeof console.warn === "function" && console.warn(msg);
};
var _helmetCallback = null;
var handleClientStateChange = function handleClientStateChange2(newState) {
  if (_helmetCallback) {
    cancelAnimationFrame$1(_helmetCallback);
  }
  if (newState.defer) {
    _helmetCallback = requestAnimationFrame$1(function() {
      commitTagChanges(newState, function() {
        _helmetCallback = null;
      });
    });
  } else {
    commitTagChanges(newState);
    _helmetCallback = null;
  }
};
var commitTagChanges = function commitTagChanges2(newState, cb2) {
  var baseTag = newState.baseTag, bodyAttributes = newState.bodyAttributes, htmlAttributes = newState.htmlAttributes, linkTags = newState.linkTags, metaTags = newState.metaTags, noscriptTags = newState.noscriptTags, onChangeClientState = newState.onChangeClientState, scriptTags = newState.scriptTags, styleTags = newState.styleTags, title = newState.title, titleAttributes = newState.titleAttributes;
  updateAttributes(TAG_NAMES.BODY, bodyAttributes);
  updateAttributes(TAG_NAMES.HTML, htmlAttributes);
  updateTitle(title, titleAttributes);
  var tagUpdates = {
    baseTag: updateTags(TAG_NAMES.BASE, baseTag),
    linkTags: updateTags(TAG_NAMES.LINK, linkTags),
    metaTags: updateTags(TAG_NAMES.META, metaTags),
    noscriptTags: updateTags(TAG_NAMES.NOSCRIPT, noscriptTags),
    scriptTags: updateTags(TAG_NAMES.SCRIPT, scriptTags),
    styleTags: updateTags(TAG_NAMES.STYLE, styleTags)
  };
  var addedTags = {};
  var removedTags = {};
  Object.keys(tagUpdates).forEach(function(tagType) {
    var _tagUpdates$tagType = tagUpdates[tagType], newTags = _tagUpdates$tagType.newTags, oldTags = _tagUpdates$tagType.oldTags;
    if (newTags.length) {
      addedTags[tagType] = newTags;
    }
    if (oldTags.length) {
      removedTags[tagType] = tagUpdates[tagType].oldTags;
    }
  });
  cb2 && cb2();
  onChangeClientState(newState, addedTags, removedTags);
};
var flattenArray = function flattenArray2(possibleArray) {
  return Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
};
var updateTitle = function updateTitle2(title, attributes) {
  if (typeof title !== "undefined" && document.title !== title) {
    document.title = flattenArray(title);
  }
  updateAttributes(TAG_NAMES.TITLE, attributes);
};
var updateAttributes = function updateAttributes2(tagName, attributes) {
  var elementTag = document.getElementsByTagName(tagName)[0];
  if (!elementTag) {
    return;
  }
  var helmetAttributeString = elementTag.getAttribute(HELMET_ATTRIBUTE);
  var helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
  var attributesToRemove = [].concat(helmetAttributes);
  var attributeKeys = Object.keys(attributes);
  for (var i3 = 0; i3 < attributeKeys.length; i3++) {
    var attribute = attributeKeys[i3];
    var value = attributes[attribute] || "";
    if (elementTag.getAttribute(attribute) !== value) {
      elementTag.setAttribute(attribute, value);
    }
    if (helmetAttributes.indexOf(attribute) === -1) {
      helmetAttributes.push(attribute);
    }
    var indexToSave = attributesToRemove.indexOf(attribute);
    if (indexToSave !== -1) {
      attributesToRemove.splice(indexToSave, 1);
    }
  }
  for (var _i = attributesToRemove.length - 1; _i >= 0; _i--) {
    elementTag.removeAttribute(attributesToRemove[_i]);
  }
  if (helmetAttributes.length === attributesToRemove.length) {
    elementTag.removeAttribute(HELMET_ATTRIBUTE);
  } else if (elementTag.getAttribute(HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
    elementTag.setAttribute(HELMET_ATTRIBUTE, attributeKeys.join(","));
  }
};
var updateTags = function updateTags2(type2, tags) {
  var headElement = document.head || document.querySelector(TAG_NAMES.HEAD);
  var tagNodes = headElement.querySelectorAll(type2 + "[" + HELMET_ATTRIBUTE + "]");
  var oldTags = Array.prototype.slice.call(tagNodes);
  var newTags = [];
  var indexToDelete = void 0;
  if (tags && tags.length) {
    tags.forEach(function(tag) {
      var newElement = document.createElement(type2);
      for (var attribute in tag) {
        if (tag.hasOwnProperty(attribute)) {
          if (attribute === TAG_PROPERTIES.INNER_HTML) {
            newElement.innerHTML = tag.innerHTML;
          } else if (attribute === TAG_PROPERTIES.CSS_TEXT) {
            if (newElement.styleSheet) {
              newElement.styleSheet.cssText = tag.cssText;
            } else {
              newElement.appendChild(document.createTextNode(tag.cssText));
            }
          } else {
            var value = typeof tag[attribute] === "undefined" ? "" : tag[attribute];
            newElement.setAttribute(attribute, value);
          }
        }
      }
      newElement.setAttribute(HELMET_ATTRIBUTE, "true");
      if (oldTags.some(function(existingTag, index2) {
        indexToDelete = index2;
        return newElement.isEqualNode(existingTag);
      })) {
        oldTags.splice(indexToDelete, 1);
      } else {
        newTags.push(newElement);
      }
    });
  }
  oldTags.forEach(function(tag) {
    return tag.parentNode.removeChild(tag);
  });
  newTags.forEach(function(tag) {
    return headElement.appendChild(tag);
  });
  return {
    oldTags,
    newTags
  };
};
var generateElementAttributesAsString = function generateElementAttributesAsString2(attributes) {
  return Object.keys(attributes).reduce(function(str, key2) {
    var attr = typeof attributes[key2] !== "undefined" ? key2 + '="' + attributes[key2] + '"' : "" + key2;
    return str ? str + " " + attr : attr;
  }, "");
};
var generateTitleAsString = function generateTitleAsString2(type2, title, attributes, encode5) {
  var attributeString = generateElementAttributesAsString(attributes);
  var flattenedTitle = flattenArray(title);
  return attributeString ? "<" + type2 + " " + HELMET_ATTRIBUTE + '="true" ' + attributeString + ">" + encodeSpecialCharacters(flattenedTitle, encode5) + "</" + type2 + ">" : "<" + type2 + " " + HELMET_ATTRIBUTE + '="true">' + encodeSpecialCharacters(flattenedTitle, encode5) + "</" + type2 + ">";
};
var generateTagsAsString = function generateTagsAsString2(type2, tags, encode5) {
  return tags.reduce(function(str, tag) {
    var attributeHtml = Object.keys(tag).filter(function(attribute) {
      return !(attribute === TAG_PROPERTIES.INNER_HTML || attribute === TAG_PROPERTIES.CSS_TEXT);
    }).reduce(function(string2, attribute) {
      var attr = typeof tag[attribute] === "undefined" ? attribute : attribute + '="' + encodeSpecialCharacters(tag[attribute], encode5) + '"';
      return string2 ? string2 + " " + attr : attr;
    }, "");
    var tagContent = tag.innerHTML || tag.cssText || "";
    var isSelfClosing = SELF_CLOSING_TAGS.indexOf(type2) === -1;
    return str + "<" + type2 + " " + HELMET_ATTRIBUTE + '="true" ' + attributeHtml + (isSelfClosing ? "/>" : ">" + tagContent + "</" + type2 + ">");
  }, "");
};
var convertElementAttributestoReactProps = function convertElementAttributestoReactProps2(attributes) {
  var initProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Object.keys(attributes).reduce(function(obj, key2) {
    obj[REACT_TAG_MAP[key2] || key2] = attributes[key2];
    return obj;
  }, initProps);
};
var convertReactPropstoHtmlAttributes = function convertReactPropstoHtmlAttributes2(props) {
  var initAttributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Object.keys(props).reduce(function(obj, key2) {
    obj[HTML_TAG_MAP[key2] || key2] = props[key2];
    return obj;
  }, initAttributes);
};
var generateTitleAsReactComponent = function generateTitleAsReactComponent2(type2, title, attributes) {
  var _initProps;
  var initProps = (_initProps = {
    key: title
  }, _initProps[HELMET_ATTRIBUTE] = true, _initProps);
  var props = convertElementAttributestoReactProps(attributes, initProps);
  return [React$1.createElement(TAG_NAMES.TITLE, props, title)];
};
var generateTagsAsReactComponent = function generateTagsAsReactComponent2(type2, tags) {
  return tags.map(function(tag, i3) {
    var _mappedTag;
    var mappedTag = (_mappedTag = {
      key: i3
    }, _mappedTag[HELMET_ATTRIBUTE] = true, _mappedTag);
    Object.keys(tag).forEach(function(attribute) {
      var mappedAttribute = REACT_TAG_MAP[attribute] || attribute;
      if (mappedAttribute === TAG_PROPERTIES.INNER_HTML || mappedAttribute === TAG_PROPERTIES.CSS_TEXT) {
        var content = tag.innerHTML || tag.cssText;
        mappedTag.dangerouslySetInnerHTML = { __html: content };
      } else {
        mappedTag[mappedAttribute] = tag[attribute];
      }
    });
    return React$1.createElement(type2, mappedTag);
  });
};
var getMethodsForTag = function getMethodsForTag2(type2, tags, encode5) {
  switch (type2) {
    case TAG_NAMES.TITLE:
      return {
        toComponent: function toComponent() {
          return generateTitleAsReactComponent(type2, tags.title, tags.titleAttributes);
        },
        toString: function toString3() {
          return generateTitleAsString(type2, tags.title, tags.titleAttributes, encode5);
        }
      };
    case ATTRIBUTE_NAMES.BODY:
    case ATTRIBUTE_NAMES.HTML:
      return {
        toComponent: function toComponent() {
          return convertElementAttributestoReactProps(tags);
        },
        toString: function toString3() {
          return generateElementAttributesAsString(tags);
        }
      };
    default:
      return {
        toComponent: function toComponent() {
          return generateTagsAsReactComponent(type2, tags);
        },
        toString: function toString3() {
          return generateTagsAsString(type2, tags, encode5);
        }
      };
  }
};
var mapStateOnServer = function mapStateOnServer2(_ref) {
  var baseTag = _ref.baseTag, bodyAttributes = _ref.bodyAttributes, encode5 = _ref.encode, htmlAttributes = _ref.htmlAttributes, linkTags = _ref.linkTags, metaTags = _ref.metaTags, noscriptTags = _ref.noscriptTags, scriptTags = _ref.scriptTags, styleTags = _ref.styleTags, _ref$title = _ref.title, title = _ref$title === void 0 ? "" : _ref$title, titleAttributes = _ref.titleAttributes;
  return {
    base: getMethodsForTag(TAG_NAMES.BASE, baseTag, encode5),
    bodyAttributes: getMethodsForTag(ATTRIBUTE_NAMES.BODY, bodyAttributes, encode5),
    htmlAttributes: getMethodsForTag(ATTRIBUTE_NAMES.HTML, htmlAttributes, encode5),
    link: getMethodsForTag(TAG_NAMES.LINK, linkTags, encode5),
    meta: getMethodsForTag(TAG_NAMES.META, metaTags, encode5),
    noscript: getMethodsForTag(TAG_NAMES.NOSCRIPT, noscriptTags, encode5),
    script: getMethodsForTag(TAG_NAMES.SCRIPT, scriptTags, encode5),
    style: getMethodsForTag(TAG_NAMES.STYLE, styleTags, encode5),
    title: getMethodsForTag(TAG_NAMES.TITLE, { title, titleAttributes }, encode5)
  };
};
var Helmet = function Helmet2(Component2) {
  var _class, _temp;
  return _temp = _class = function(_React$Component) {
    inherits$7(HelmetWrapper, _React$Component);
    function HelmetWrapper() {
      classCallCheck(this, HelmetWrapper);
      return possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }
    HelmetWrapper.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return !isEqual(this.props, nextProps);
    };
    HelmetWrapper.prototype.mapNestedChildrenToProps = function mapNestedChildrenToProps(child, nestedChildren) {
      if (!nestedChildren) {
        return null;
      }
      switch (child.type) {
        case TAG_NAMES.SCRIPT:
        case TAG_NAMES.NOSCRIPT:
          return {
            innerHTML: nestedChildren
          };
        case TAG_NAMES.STYLE:
          return {
            cssText: nestedChildren
          };
      }
      throw new Error("<" + child.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.");
    };
    HelmetWrapper.prototype.flattenArrayTypeChildren = function flattenArrayTypeChildren(_ref) {
      var _babelHelpers$extends;
      var child = _ref.child, arrayTypeChildren = _ref.arrayTypeChildren, newChildProps = _ref.newChildProps, nestedChildren = _ref.nestedChildren;
      return _extends$2({}, arrayTypeChildren, (_babelHelpers$extends = {}, _babelHelpers$extends[child.type] = [].concat(arrayTypeChildren[child.type] || [], [_extends$2({}, newChildProps, this.mapNestedChildrenToProps(child, nestedChildren))]), _babelHelpers$extends));
    };
    HelmetWrapper.prototype.mapObjectTypeChildren = function mapObjectTypeChildren(_ref2) {
      var _babelHelpers$extends2, _babelHelpers$extends3;
      var child = _ref2.child, newProps = _ref2.newProps, newChildProps = _ref2.newChildProps, nestedChildren = _ref2.nestedChildren;
      switch (child.type) {
        case TAG_NAMES.TITLE:
          return _extends$2({}, newProps, (_babelHelpers$extends2 = {}, _babelHelpers$extends2[child.type] = nestedChildren, _babelHelpers$extends2.titleAttributes = _extends$2({}, newChildProps), _babelHelpers$extends2));
        case TAG_NAMES.BODY:
          return _extends$2({}, newProps, {
            bodyAttributes: _extends$2({}, newChildProps)
          });
        case TAG_NAMES.HTML:
          return _extends$2({}, newProps, {
            htmlAttributes: _extends$2({}, newChildProps)
          });
      }
      return _extends$2({}, newProps, (_babelHelpers$extends3 = {}, _babelHelpers$extends3[child.type] = _extends$2({}, newChildProps), _babelHelpers$extends3));
    };
    HelmetWrapper.prototype.mapArrayTypeChildrenToProps = function mapArrayTypeChildrenToProps(arrayTypeChildren, newProps) {
      var newFlattenedProps = _extends$2({}, newProps);
      Object.keys(arrayTypeChildren).forEach(function(arrayChildName) {
        var _babelHelpers$extends4;
        newFlattenedProps = _extends$2({}, newFlattenedProps, (_babelHelpers$extends4 = {}, _babelHelpers$extends4[arrayChildName] = arrayTypeChildren[arrayChildName], _babelHelpers$extends4));
      });
      return newFlattenedProps;
    };
    HelmetWrapper.prototype.warnOnInvalidChildren = function warnOnInvalidChildren(child, nestedChildren) {
      return true;
    };
    HelmetWrapper.prototype.mapChildrenToProps = function mapChildrenToProps(children, newProps) {
      var _this2 = this;
      var arrayTypeChildren = {};
      React$1.Children.forEach(children, function(child) {
        if (!child || !child.props) {
          return;
        }
        var _child$props = child.props, nestedChildren = _child$props.children, childProps = objectWithoutProperties(_child$props, ["children"]);
        var newChildProps = convertReactPropstoHtmlAttributes(childProps);
        _this2.warnOnInvalidChildren(child, nestedChildren);
        switch (child.type) {
          case TAG_NAMES.LINK:
          case TAG_NAMES.META:
          case TAG_NAMES.NOSCRIPT:
          case TAG_NAMES.SCRIPT:
          case TAG_NAMES.STYLE:
            arrayTypeChildren = _this2.flattenArrayTypeChildren({
              child,
              arrayTypeChildren,
              newChildProps,
              nestedChildren
            });
            break;
          default:
            newProps = _this2.mapObjectTypeChildren({
              child,
              newProps,
              newChildProps,
              nestedChildren
            });
            break;
        }
      });
      newProps = this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);
      return newProps;
    };
    HelmetWrapper.prototype.render = function render3() {
      var _props = this.props, children = _props.children, props = objectWithoutProperties(_props, ["children"]);
      var newProps = _extends$2({}, props);
      if (children) {
        newProps = this.mapChildrenToProps(children, newProps);
      }
      return React$1.createElement(Component2, newProps);
    };
    createClass(HelmetWrapper, null, [{
      key: "canUseDOM",
      // Component.peek comes from react-side-effect:
      // For testing, you may use a static peek() method available on the returned component.
      // It lets you get the current state without resetting the mounted instance stack.
      // Don’t use it for anything other than testing.
      /**
       * @param {Object} base: {"target": "_blank", "href": "http://mysite.com/"}
       * @param {Object} bodyAttributes: {"className": "root"}
       * @param {String} defaultTitle: "Default Title"
       * @param {Boolean} defer: true
       * @param {Boolean} encodeSpecialCharacters: true
       * @param {Object} htmlAttributes: {"lang": "en", "amp": undefined}
       * @param {Array} link: [{"rel": "canonical", "href": "http://mysite.com/example"}]
       * @param {Array} meta: [{"name": "description", "content": "Test description"}]
       * @param {Array} noscript: [{"innerHTML": "<img src='http://mysite.com/js/test.js'"}]
       * @param {Function} onChangeClientState: "(newState) => console.log(newState)"
       * @param {Array} script: [{"type": "text/javascript", "src": "http://mysite.com/js/test.js"}]
       * @param {Array} style: [{"type": "text/css", "cssText": "div { display: block; color: blue; }"}]
       * @param {String} title: "Title"
       * @param {Object} titleAttributes: {"itemprop": "name"}
       * @param {String} titleTemplate: "MySite.com - %s"
       */
      set: function set$$1(canUseDOM2) {
        Component2.canUseDOM = canUseDOM2;
      }
    }]);
    return HelmetWrapper;
  }(React$1.Component), _class.propTypes = {
    base: PropTypes.object,
    bodyAttributes: PropTypes.object,
    children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),
    defaultTitle: PropTypes.string,
    defer: PropTypes.bool,
    encodeSpecialCharacters: PropTypes.bool,
    htmlAttributes: PropTypes.object,
    link: PropTypes.arrayOf(PropTypes.object),
    meta: PropTypes.arrayOf(PropTypes.object),
    noscript: PropTypes.arrayOf(PropTypes.object),
    onChangeClientState: PropTypes.func,
    script: PropTypes.arrayOf(PropTypes.object),
    style: PropTypes.arrayOf(PropTypes.object),
    title: PropTypes.string,
    titleAttributes: PropTypes.object,
    titleTemplate: PropTypes.string
  }, _class.defaultProps = {
    defer: true,
    encodeSpecialCharacters: true
  }, _class.peek = Component2.peek, _class.rewind = function() {
    var mappedState = Component2.rewind();
    if (!mappedState) {
      mappedState = mapStateOnServer({
        baseTag: [],
        bodyAttributes: {},
        encodeSpecialCharacters: true,
        htmlAttributes: {},
        linkTags: [],
        metaTags: [],
        noscriptTags: [],
        scriptTags: [],
        styleTags: [],
        title: "",
        titleAttributes: {}
      });
    }
    return mappedState;
  }, _temp;
};
var NullComponent = function NullComponent2() {
  return null;
};
var HelmetSideEffects = withSideEffect$1(reducePropsToState, handleClientStateChange, mapStateOnServer)(NullComponent);
var HelmetExport = Helmet(HelmetSideEffects);
HelmetExport.renderStatic = HelmetExport.rewind;
const __variableDynamicImportRuntimeHelper = (glob, path) => {
  const v4 = glob[path];
  if (v4) {
    return typeof v4 === "function" ? v4() : Promise.resolve(v4);
  }
  return new Promise((_3, reject) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, new Error("Unknown variable dynamic import: " + path)));
  });
};
var bn$1 = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1v = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
bn$1.exports;
(function(module2) {
  (function(module3, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base3, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number2 || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module3 === "object") {
      module3.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$1v.Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max2(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min2(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init3(number2, base3, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base3, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base3 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base3, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base3, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base3, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i3 = 0; i3 < this.length; i3++) {
        this.words[i3] = 0;
      }
      var j2, w3;
      var off2 = 0;
      if (endian === "be") {
        for (i3 = number2.length - 1, j2 = 0; i3 >= 0; i3 -= 3) {
          w3 = number2[i3] | number2[i3 - 1] << 8 | number2[i3 - 2] << 16;
          this.words[j2] |= w3 << off2 & 67108863;
          this.words[j2 + 1] = w3 >>> 26 - off2 & 67108863;
          off2 += 24;
          if (off2 >= 26) {
            off2 -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i3 = 0, j2 = 0; i3 < number2.length; i3 += 3) {
          w3 = number2[i3] | number2[i3 + 1] << 8 | number2[i3 + 2] << 16;
          this.words[j2] |= w3 << off2 & 67108863;
          this.words[j2 + 1] = w3 >>> 26 - off2 & 67108863;
          off2 += 24;
          if (off2 >= 26) {
            off2 -= 26;
            j2++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index2) {
      var c2 = string2.charCodeAt(index2);
      if (c2 >= 48 && c2 <= 57) {
        return c2 - 48;
      } else if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        assert2(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i3 = 0; i3 < this.length; i3++) {
        this.words[i3] = 0;
      }
      var off2 = 0;
      var j2 = 0;
      var w3;
      if (endian === "be") {
        for (i3 = number2.length - 1; i3 >= start; i3 -= 2) {
          w3 = parseHexByte(number2, start, i3) << off2;
          this.words[j2] |= w3 & 67108863;
          if (off2 >= 18) {
            off2 -= 18;
            j2 += 1;
            this.words[j2] |= w3 >>> 26;
          } else {
            off2 += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i3 = parseLength % 2 === 0 ? start + 1 : start; i3 < number2.length; i3 += 2) {
          w3 = parseHexByte(number2, start, i3) << off2;
          this.words[j2] |= w3 & 67108863;
          if (off2 >= 18) {
            off2 -= 18;
            j2 += 1;
            this.words[j2] |= w3 >>> 26;
          } else {
            off2 += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end2, mul5) {
      var r2 = 0;
      var b4 = 0;
      var len2 = Math.min(str.length, end2);
      for (var i3 = start; i3 < len2; i3++) {
        var c2 = str.charCodeAt(i3) - 48;
        r2 *= mul5;
        if (c2 >= 49) {
          b4 = c2 - 49 + 10;
        } else if (c2 >= 17) {
          b4 = c2 - 17 + 10;
        } else {
          b4 = c2;
        }
        assert2(c2 >= 0 && b4 < mul5, "Invalid character");
        r2 += b4;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base3, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number2.length - start;
      var mod2 = total % limbLen;
      var end2 = Math.min(total, total - mod2) + start;
      var word = 0;
      for (var i3 = start; i3 < end2; i3 += limbLen) {
        word = parseBase(number2, i3, i3 + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod2 !== 0) {
        var pow = 1;
        word = parseBase(number2, i3, number2.length, base3);
        for (i3 = 0; i3 < mod2; i3++) {
          pow *= base3;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy2(dest) {
      dest.words = new Array(this.length);
      for (var i3 = 0; i3 < this.length; i3++) {
        dest.words[i3] = this.words[i3];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src2) {
      dest.words = src2.words;
      dest.length = src2.length;
      dest.negative = src2.negative;
      dest.red = src2.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone2() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect5;
      } catch (e2) {
        BN2.prototype.inspect = inspect5;
      }
    } else {
      BN2.prototype.inspect = inspect5;
    }
    function inspect5() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString3(base3, padding2) {
      base3 = base3 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off2 = 0;
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w3 = this.words[i3];
          var word = ((w3 << off2 | carry) & 16777215).toString(16);
          carry = w3 >>> 24 - off2 & 16777215;
          off2 += 2;
          if (off2 >= 26) {
            off2 -= 26;
            i3--;
          }
          if (carry !== 0 || i3 !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modrn(groupBase).toString(base3);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON2() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer2(endian, length2) {
        return this.toArrayLike(Buffer2, endian, length2);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length2) {
      return this.toArrayLike(Array, endian, length2);
    };
    var allocate = function allocate2(ArrayType, size2) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size2);
      }
      return new ArrayType(size2);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
      this._strip();
      var byteLength2 = this.byteLength();
      var reqLength = length2 || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength2);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
      var position = 0;
      var carry = 0;
      for (var i3 = 0, shift = 0; i3 < this.length; i3++) {
        var word = this.words[i3] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
      var position = res.length - 1;
      var carry = 0;
      for (var i3 = 0, shift = 0; i3 < this.length; i3++) {
        var word = this.words[i3] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w3) {
        return 32 - Math.clz32(w3);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w3) {
        var t2 = w3;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w3) {
      if (w3 === 0)
        return 26;
      var t2 = w3;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w3 = this.words[this.length - 1];
      var hi2 = this._countBits(w3);
      return (this.length - 1) * 26 + hi2;
    };
    function toBitArray(num) {
      var w3 = new Array(num.bitLength());
      for (var bit = 0; bit < w3.length; bit++) {
        var off2 = bit / 26 | 0;
        var wbit = bit % 26;
        w3[bit] = num.words[off2] >>> wbit & 1;
      }
      return w3;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i3 = 0; i3 < this.length; i3++) {
        var b4 = this._zeroBits(this.words[i3]);
        r2 += b4;
        if (b4 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg3() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i3 = 0; i3 < num.length; i3++) {
        this.words[i3] = this.words[i3] | num.words[i3];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or2(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b4;
      if (this.length > num.length) {
        b4 = num;
      } else {
        b4 = this;
      }
      for (var i3 = 0; i3 < b4.length; i3++) {
        this.words[i3] = this.words[i3] & num.words[i3];
      }
      this.length = b4.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a3;
      var b4;
      if (this.length > num.length) {
        a3 = this;
        b4 = num;
      } else {
        a3 = num;
        b4 = this;
      }
      for (var i3 = 0; i3 < b4.length; i3++) {
        this.words[i3] = a3.words[i3] ^ b4.words[i3];
      }
      if (this !== a3) {
        for (; i3 < a3.length; i3++) {
          this.words[i3] = a3.words[i3];
        }
      }
      this.length = a3.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i3 = 0; i3 < bytesNeeded; i3++) {
        this.words[i3] = ~this.words[i3] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off2 = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off2 + 1);
      if (val) {
        this.words[off2] = this.words[off2] | 1 << wbit;
      } else {
        this.words[off2] = this.words[off2] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a3, b4;
      if (this.length > num.length) {
        a3 = this;
        b4 = num;
      } else {
        a3 = num;
        b4 = this;
      }
      var carry = 0;
      for (var i3 = 0; i3 < b4.length; i3++) {
        r2 = (a3.words[i3] | 0) + (b4.words[i3] | 0) + carry;
        this.words[i3] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i3 < a3.length; i3++) {
        r2 = (a3.words[i3] | 0) + carry;
        this.words[i3] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a3.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a3 !== this) {
        for (; i3 < a3.length; i3++) {
          this.words[i3] = a3.words[i3];
        }
      }
      return this;
    };
    BN2.prototype.add = function add3(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp2 = this.cmp(num);
      if (cmp2 === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a3, b4;
      if (cmp2 > 0) {
        a3 = this;
        b4 = num;
      } else {
        a3 = num;
        b4 = this;
      }
      var carry = 0;
      for (var i3 = 0; i3 < b4.length; i3++) {
        r2 = (a3.words[i3] | 0) - (b4.words[i3] | 0) + carry;
        carry = r2 >> 26;
        this.words[i3] = r2 & 67108863;
      }
      for (; carry !== 0 && i3 < a3.length; i3++) {
        r2 = (a3.words[i3] | 0) + carry;
        carry = r2 >> 26;
        this.words[i3] = r2 & 67108863;
      }
      if (carry === 0 && i3 < a3.length && a3 !== this) {
        for (; i3 < a3.length; i3++) {
          this.words[i3] = a3.words[i3];
        }
      }
      this.length = Math.max(this.length, i3);
      if (a3 !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len2 = self2.length + num.length | 0;
      out.length = len2;
      len2 = len2 - 1 | 0;
      var a3 = self2.words[0] | 0;
      var b4 = num.words[0] | 0;
      var r2 = a3 * b4;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k3 = 1; k3 < len2; k3++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k3, num.length - 1);
        for (var j2 = Math.max(0, k3 - self2.length + 1); j2 <= maxJ; j2++) {
          var i3 = k3 - j2 | 0;
          a3 = self2.words[i3] | 0;
          b4 = num.words[j2] | 0;
          r2 = a3 * b4 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k3] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k3] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a3 = self2.words;
      var b4 = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi2;
      var a0 = a3[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a3[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a3[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a32 = a3[3] | 0;
      var al3 = a32 & 8191;
      var ah3 = a32 >>> 13;
      var a4 = a3[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a3[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a3[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a3[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a3[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a3[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b4[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b4[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b4[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b32 = b4[3] | 0;
      var bl3 = b32 & 8191;
      var bh3 = b32 >>> 13;
      var b42 = b4[4] | 0;
      var bl4 = b42 & 8191;
      var bh4 = b42 >>> 13;
      var b5 = b4[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b4[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b4[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b4[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b4[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi2 = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi2 = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi2 = hi2 + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi2 = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi2 = hi2 + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi2 = hi2 + Math.imul(ah0, bh2) | 0;
      var w22 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
      w22 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi2 = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi2 = hi2 + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi2 = hi2 + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi2 = hi2 + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi2 = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi2 = hi2 + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi2 = hi2 + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi2 = hi2 + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi2 = hi2 + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi2 = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi2 = hi2 + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi2 = hi2 + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi2 = hi2 + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi2 = hi2 + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi2 = hi2 + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi2 = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi2 = hi2 + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi2 = hi2 + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi2 = hi2 + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi2 = hi2 + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi2 = hi2 + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi2 = hi2 + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi2 = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi2 = hi2 + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi2 = hi2 + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi2 = hi2 + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi2 = hi2 + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi2 = hi2 + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi2 = hi2 + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi2 = hi2 + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi2 = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi2 = hi2 + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi2 = hi2 + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi2 = hi2 + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi2 = hi2 + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi2 = hi2 + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi2 = hi2 + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi2 = hi2 + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi2 = hi2 + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi2 = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi2 = hi2 + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi2 = hi2 + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi2 = hi2 + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi2 = hi2 + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi2 = hi2 + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi2 = hi2 + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi2 = hi2 + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi2 = hi2 + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi2 = hi2 + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi2 = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi2 = hi2 + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi2 = hi2 + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi2 = hi2 + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi2 = hi2 + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi2 = hi2 + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi2 = hi2 + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi2 = hi2 + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi2 = hi2 + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi2 = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi2 = hi2 + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi2 = hi2 + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi2 = hi2 + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi2 = hi2 + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi2 = hi2 + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi2 = hi2 + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi2 = hi2 + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi2 = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi2 = hi2 + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi2 = hi2 + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi2 = hi2 + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi2 = hi2 + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi2 = hi2 + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi2 = hi2 + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi2 = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi2 = hi2 + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi2 = hi2 + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi2 = hi2 + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi2 = hi2 + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi2 = hi2 + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi2 = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi2 = hi2 + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi2 = hi2 + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi2 = hi2 + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi2 = hi2 + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi2 = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi2 = hi2 + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi2 = hi2 + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi2 = hi2 + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi2 = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi2 = hi2 + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi2 = hi2 + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi2 = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi2 = hi2 + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi2 = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w22;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k3 = 0; k3 < out.length - 1; k3++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k3, num.length - 1);
        for (var j2 = Math.max(0, k3 - self2.length + 1); j2 <= maxJ; j2++) {
          var i3 = k3 - j2;
          var a3 = self2.words[i3] | 0;
          var b4 = num.words[j2] | 0;
          var r2 = a3 * b4;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k3] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k3] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len2 = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len2 < 63) {
        res = smallMulTo(this, num, out);
      } else if (len2 < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul5(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i3 = 0; i3 < this.length; i3++) {
        var w3 = (this.words[i3] | 0) * num;
        var lo = (w3 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w3 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i3] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i3] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w3 = toBitArray(num);
      if (w3.length === 0)
        return new BN2(1);
      var res = this;
      for (var i3 = 0; i3 < w3.length; i3++, res = res.sqr()) {
        if (w3[i3] !== 0)
          break;
      }
      if (++i3 < w3.length) {
        for (var q2 = res.sqr(); i3 < w3.length; i3++, q2 = q2.sqr()) {
          if (w3[i3] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s3 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i3;
      if (r2 !== 0) {
        var carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          var newCarry = this.words[i3] & carryMask;
          var c2 = (this.words[i3] | 0) - newCarry << r2;
          this.words[i3] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i3] = carry;
          this.length++;
        }
      }
      if (s3 !== 0) {
        for (i3 = this.length - 1; i3 >= 0; i3--) {
          this.words[i3 + s3] = this.words[i3];
        }
        for (i3 = 0; i3 < s3; i3++) {
          this.words[i3] = 0;
        }
        this.length += s3;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h5;
      if (hint) {
        h5 = (hint - hint % 26) / 26;
      } else {
        h5 = 0;
      }
      var r2 = bits % 26;
      var s3 = Math.min((bits - r2) / 26, this.length);
      var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h5 -= s3;
      h5 = Math.max(0, h5);
      if (maskedWords) {
        for (var i3 = 0; i3 < s3; i3++) {
          maskedWords.words[i3] = this.words[i3];
        }
        maskedWords.length = s3;
      }
      if (s3 === 0)
        ;
      else if (this.length > s3) {
        this.length -= s3;
        for (i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = this.words[i3 + s3];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h5); i3--) {
        var word = this.words[i3] | 0;
        this.words[i3] = carry << 26 - r2 | word >>> r2;
        carry = word & mask2;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s3 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s3)
        return false;
      var w3 = this.words[s3];
      return !!(w3 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s3 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s3) {
        return this;
      }
      if (r2 !== 0) {
        s3++;
      }
      this.length = Math.min(s3, this.length);
      if (r2 !== 0) {
        var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask2;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
        this.words[i3] -= 67108864;
        if (i3 === this.length - 1) {
          this.words[i3 + 1] = 1;
        } else {
          this.words[i3 + 1]++;
        }
      }
      this.length = Math.max(this.length, i3 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
          this.words[i3] += 67108864;
          this.words[i3 + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul5, shift) {
      var len2 = num.length + shift;
      var i3;
      this._expand(len2);
      var w3;
      var carry = 0;
      for (i3 = 0; i3 < num.length; i3++) {
        w3 = (this.words[i3 + shift] | 0) + carry;
        var right = (num.words[i3] | 0) * mul5;
        w3 -= right & 67108863;
        carry = (w3 >> 26) - (right / 67108864 | 0);
        this.words[i3 + shift] = w3 & 67108863;
      }
      for (; i3 < this.length - shift; i3++) {
        w3 = (this.words[i3 + shift] | 0) + carry;
        carry = w3 >> 26;
        this.words[i3 + shift] = w3 & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i3 = 0; i3 < this.length; i3++) {
        w3 = -(this.words[i3] | 0) + carry;
        carry = w3 >> 26;
        this.words[i3] = w3 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift = this.length - num.length;
      var a3 = this.clone();
      var b4 = num;
      var bhi = b4.words[b4.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b4 = b4.ushln(shift);
        a3.iushln(shift);
        bhi = b4.words[b4.length - 1] | 0;
      }
      var m2 = a3.length - b4.length;
      var q2;
      if (mode2 !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i3 = 0; i3 < q2.length; i3++) {
          q2.words[i3] = 0;
        }
      }
      var diff2 = a3.clone()._ishlnsubmul(b4, 1, m2);
      if (diff2.negative === 0) {
        a3 = diff2;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj2 = (a3.words[b4.length + j2] | 0) * 67108864 + (a3.words[b4.length + j2 - 1] | 0);
        qj2 = Math.min(qj2 / bhi | 0, 67108863);
        a3._ishlnsubmul(b4, qj2, j2);
        while (a3.negative !== 0) {
          qj2--;
          a3.negative = 0;
          a3._ishlnsubmul(b4, 1, j2);
          if (!a3.isZero()) {
            a3.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j2] = qj2;
        }
      }
      if (q2) {
        q2._strip();
      }
      a3._strip();
      if (mode2 !== "div" && shift !== 0) {
        a3.iushrn(shift);
      }
      return {
        div: q2 || null,
        mod: a3
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod2, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.iadd(num);
          }
        }
        return {
          div,
          mod: mod2
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod2
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod2(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp2 = mod2.cmp(half);
      if (cmp2 < 0 || r2 === 1 && cmp2 === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p3 = (1 << 26) % num;
      var acc = 0;
      for (var i3 = this.length - 1; i3 >= 0; i3--) {
        acc = (p3 * acc + (this.words[i3] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i3 = this.length - 1; i3 >= 0; i3--) {
        var w3 = (this.words[i3] | 0) + carry * 67108864;
        this.words[i3] = w3 / num | 0;
        carry = w3 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p3) {
      assert2(p3.negative === 0);
      assert2(!p3.isZero());
      var x2 = this;
      var y3 = p3.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p3);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g3 = 0;
      while (x2.isEven() && y3.isEven()) {
        x2.iushrn(1);
        y3.iushrn(1);
        ++g3;
      }
      var yp = y3.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i3 = 0, im = 1; (x2.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
          ;
        if (i3 > 0) {
          x2.iushrn(i3);
          while (i3-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y3.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          y3.iushrn(j2);
          while (j2-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y3) >= 0) {
          x2.isub(y3);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y3.isub(x2);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y3.iushln(g3)
      };
    };
    BN2.prototype._invmp = function _invmp(p3) {
      assert2(p3.negative === 0);
      assert2(!p3.isZero());
      var a3 = this;
      var b4 = p3.clone();
      if (a3.negative !== 0) {
        a3 = a3.umod(p3);
      } else {
        a3 = a3.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b4.clone();
      while (a3.cmpn(1) > 0 && b4.cmpn(1) > 0) {
        for (var i3 = 0, im = 1; (a3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
          ;
        if (i3 > 0) {
          a3.iushrn(i3);
          while (i3-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b4.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          b4.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a3.cmp(b4) >= 0) {
          a3.isub(b4);
          x1.isub(x2);
        } else {
          b4.isub(a3);
          x2.isub(x1);
        }
      }
      var res;
      if (a3.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p3);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a3 = this.clone();
      var b4 = num.clone();
      a3.negative = 0;
      b4.negative = 0;
      for (var shift = 0; a3.isEven() && b4.isEven(); shift++) {
        a3.iushrn(1);
        b4.iushrn(1);
      }
      do {
        while (a3.isEven()) {
          a3.iushrn(1);
        }
        while (b4.isEven()) {
          b4.iushrn(1);
        }
        var r2 = a3.cmp(b4);
        if (r2 < 0) {
          var t2 = a3;
          a3 = b4;
          b4 = t2;
        } else if (r2 === 0 || b4.cmpn(1) === 0) {
          break;
        }
        a3.isub(b4);
      } while (true);
      return b4.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s3 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s3) {
        this._expand(s3 + 1);
        this.words[s3] |= q2;
        return this;
      }
      var carry = q2;
      for (var i3 = s3; carry !== 0 && i3 < this.length; i3++) {
        var w3 = this.words[i3] | 0;
        w3 += carry;
        carry = w3 >>> 26;
        w3 &= 67108863;
        this.words[i3] = w3;
      }
      if (carry !== 0) {
        this.words[i3] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w3 = this.words[0] | 0;
        res = w3 === num ? 0 : w3 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp2(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i3 = this.length - 1; i3 >= 0; i3--) {
        var a3 = this.words[i3] | 0;
        var b4 = num.words[i3] | 0;
        if (a3 === b4)
          continue;
        if (a3 < b4) {
          res = -1;
        } else if (a3 > b4) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt2(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte2(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt2(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte2(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq5(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p3) {
      this.name = name2;
      this.p = new BN2(p3, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp2 = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp2 === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp2 > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask2 = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i3 = 0; i3 < outLen; i3++) {
        output.words[i3] = input.words[i3];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask2;
      for (i3 = 10; i3 < input.length; i3++) {
        var next = input.words[i3] | 0;
        input.words[i3 - 10] = (next & mask2) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i3 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i3 = 0; i3 < num.length; i3++) {
        var w3 = num.words[i3] | 0;
        lo += w3 * 977;
        num.words[i3] = lo & 67108863;
        lo = w3 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i3 = 0; i3 < num.length; i3++) {
        var hi2 = (num.words[i3] | 0) * 19 + carry;
        var lo = hi2 & 67108863;
        hi2 >>>= 26;
        num.words[i3] = lo;
        carry = hi2;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a3) {
      assert2(a3.negative === 0, "red works only with positives");
      assert2(a3.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a3, b4) {
      assert2((a3.negative | b4.negative) === 0, "red works only with positives");
      assert2(
        a3.red && a3.red === b4.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a3) {
      if (this.prime)
        return this.prime.ireduce(a3)._forceRed(this);
      move(a3, a3.umod(this.m)._forceRed(this));
      return a3;
    };
    Red.prototype.neg = function neg3(a3) {
      if (a3.isZero()) {
        return a3.clone();
      }
      return this.m.sub(a3)._forceRed(this);
    };
    Red.prototype.add = function add3(a3, b4) {
      this._verify2(a3, b4);
      var res = a3.add(b4);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a3, b4) {
      this._verify2(a3, b4);
      var res = a3.iadd(b4);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a3, b4) {
      this._verify2(a3, b4);
      var res = a3.sub(b4);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a3, b4) {
      this._verify2(a3, b4);
      var res = a3.isub(b4);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a3, num) {
      this._verify1(a3);
      return this.imod(a3.ushln(num));
    };
    Red.prototype.imul = function imul(a3, b4) {
      this._verify2(a3, b4);
      return this.imod(a3.imul(b4));
    };
    Red.prototype.mul = function mul5(a3, b4) {
      this._verify2(a3, b4);
      return this.imod(a3.mul(b4));
    };
    Red.prototype.isqr = function isqr(a3) {
      return this.imul(a3, a3.clone());
    };
    Red.prototype.sqr = function sqr(a3) {
      return this.mul(a3, a3);
    };
    Red.prototype.sqrt = function sqrt(a3) {
      if (a3.isZero())
        return a3.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a3, pow);
      }
      var q2 = this.m.subn(1);
      var s3 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s3++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q2);
      var r2 = this.pow(a3, q2.addn(1).iushrn(1));
      var t2 = this.pow(a3, q2);
      var m2 = s3;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
          tmp = tmp.redSqr();
        }
        assert2(i3 < m2);
        var b4 = this.pow(c2, new BN2(1).iushln(m2 - i3 - 1));
        r2 = r2.redMul(b4);
        c2 = b4.redSqr();
        t2 = t2.redMul(c2);
        m2 = i3;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a3) {
      var inv = a3._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a3, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a3.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a3;
      for (var i3 = 2; i3 < wnd.length; i3++) {
        wnd[i3] = this.mul(wnd[i3 - 1], a3);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i3 = num.length - 1; i3 >= 0; i3--) {
        var word = num.words[i3];
        for (var j2 = start - 1; j2 >= 0; j2--) {
          var bit = word >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i3 !== 0 || j2 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a3, b4) {
      if (a3.isZero() || b4.isZero()) {
        a3.words[0] = 0;
        a3.length = 1;
        return a3;
      }
      var t2 = a3.imul(b4);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u3 = t2.isub(c2).iushrn(this.shift);
      var res = u3;
      if (u3.cmp(this.m) >= 0) {
        res = u3.isub(this.m);
      } else if (u3.cmpn(0) < 0) {
        res = u3.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul5(a3, b4) {
      if (a3.isZero() || b4.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a3.mul(b4);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u3 = t2.isub(c2).iushrn(this.shift);
      var res = u3;
      if (u3.cmp(this.m) >= 0) {
        res = u3.isub(this.m);
      } else if (u3.cmpn(0) < 0) {
        res = u3.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a3) {
      var res = this.imod(a3._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module2, commonjsGlobal);
})(bn$1);
var bnExports = bn$1.exports;
const BN$3 = /* @__PURE__ */ getDefaultExportFromCjs(bnExports);
const bn = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: BN$3
}, [bnExports]);
const version$q = "logger/5.7.0";
let _permanentCensorErrors$1 = false;
let _censorErrors$1 = false;
const LogLevels$1 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel$1 = LogLevels$1["default"];
let _globalLogger$1 = null;
function _checkNormalize$1() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
const _normalizeError$1 = _checkNormalize$1();
var LogLevel$1;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel$1 || (LogLevel$1 = {}));
var ErrorCode$1;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode$1 || (ErrorCode$1 = {}));
const HEX$1 = "0123456789abcdef";
let Logger$1 = class Logger2 {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels$1[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel$1 > LogLevels$1[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger2.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger2.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger2.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors$1) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger2.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex2 = "";
          for (let i3 = 0; i3 < value.length; i3++) {
            hex2 += HEX$1[value[i3] >> 4];
            hex2 += HEX$1[value[i3] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex2 + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code2) {
      case ErrorCode$1.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode$1.CALL_EXCEPTION:
      case ErrorCode$1.INSUFFICIENT_FUNDS:
      case ErrorCode$1.MISSING_NEW:
      case ErrorCode$1.NONCE_EXPIRED:
      case ErrorCode$1.REPLACEMENT_UNDERPRICED:
      case ErrorCode$1.TRANSACTION_REPLACED:
      case ErrorCode$1.UNPREDICTABLE_GAS_LIMIT:
        url = code2;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger2.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (_normalizeError$1) {
      this.throwError("platform missing String.prototype.normalize", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError$1
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger2.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger2.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger2.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger$1) {
      _globalLogger$1 = new Logger2(version$q);
    }
    return _globalLogger$1;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors$1) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors$1 = !!censorship;
    _permanentCensorErrors$1 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels$1[logLevel.toLowerCase()];
    if (level == null) {
      Logger2.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel$1 = level;
  }
  static from(version2) {
    return new Logger2(version2);
  }
};
Logger$1.errors = ErrorCode$1;
Logger$1.levels = LogLevel$1;
const version$p = "bytes/5.7.0";
const logger$s = new Logger$1(version$p);
function isHexable$1(value) {
  return !!value.toHexString;
}
function addSlice$1(array2) {
  if (array2.slice) {
    return array2;
  }
  array2.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice$1(new Uint8Array(Array.prototype.slice.apply(array2, args)));
  };
  return array2;
}
function isBytesLike(value) {
  return isHexString$3(value) && !(value.length % 2) || isBytes$4(value);
}
function isInteger$1(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes$4(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger$1(value.length) || value.length < 0) {
    return false;
  }
  for (let i3 = 0; i3 < value.length; i3++) {
    const v4 = value[i3];
    if (!isInteger$1(v4) || v4 < 0 || v4 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify$1(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$s.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice$1(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable$1(value)) {
    value = value.toHexString();
  }
  if (isHexString$3(value)) {
    let hex2 = value.substring(2);
    if (hex2.length % 2) {
      if (options.hexPad === "left") {
        hex2 = "0" + hex2;
      } else if (options.hexPad === "right") {
        hex2 += "0";
      } else {
        logger$s.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i3 = 0; i3 < hex2.length; i3 += 2) {
      result.push(parseInt(hex2.substring(i3, i3 + 2), 16));
    }
    return addSlice$1(new Uint8Array(result));
  }
  if (isBytes$4(value)) {
    return addSlice$1(new Uint8Array(value));
  }
  return logger$s.throwArgumentError("invalid arrayify value", "value", value);
}
function concat$6(items) {
  const objects = items.map((item) => arrayify$1(item));
  const length2 = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length2);
  objects.reduce((offset, object2) => {
    result.set(object2, offset);
    return offset + object2.length;
  }, 0);
  return addSlice$1(result);
}
function stripZeros(value) {
  let result = arrayify$1(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length2) {
  value = arrayify$1(value);
  if (value.length > length2) {
    logger$s.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length2);
  result.set(value, length2 - value.length);
  return addSlice$1(result);
}
function isHexString$3(value, length2) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && value.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$s.checkSafeUint53(value, "invalid hexlify value");
    let hex2 = "";
    while (value) {
      hex2 = HexCharacters[value & 15] + hex2;
      value = Math.floor(value / 16);
    }
    if (hex2.length) {
      if (hex2.length % 2) {
        hex2 = "0" + hex2;
      }
      return "0x" + hex2;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable$1(value)) {
    return value.toHexString();
  }
  if (isHexString$3(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger$s.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes$4(value)) {
    let result = "0x";
    for (let i3 = 0; i3 < value.length; i3++) {
      let v4 = value[i3];
      result += HexCharacters[(v4 & 240) >> 4] + HexCharacters[v4 & 15];
    }
    return result;
  }
  return logger$s.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data2) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString$3(data2) || data2.length % 2) {
    return null;
  }
  return (data2.length - 2) / 2;
}
function hexDataSlice(data2, offset, endOffset) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString$3(data2) || data2.length % 2) {
    logger$s.throwArgumentError("invalid hexData", "value", data2);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data2.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data2.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed2 = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed2 === "0x") {
    return "0x0";
  }
  return trimmed2;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString$3(value)) {
    logger$s.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length2) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString$3(value)) {
    logger$s.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length2 + 2) {
    logger$s.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length2 + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes2 = arrayify$1(signature2);
    if (bytes2.length === 64) {
      result.v = 27 + (bytes2[32] >> 7);
      bytes2[32] &= 127;
      result.r = hexlify(bytes2.slice(0, 32));
      result.s = hexlify(bytes2.slice(32, 64));
    } else if (bytes2.length === 65) {
      result.r = hexlify(bytes2.slice(0, 32));
      result.s = hexlify(bytes2.slice(32, 64));
      result.v = bytes2[64];
    } else {
      logger$s.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger$s.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes2[32] |= 128;
    }
    result._vs = hexlify(bytes2.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs3 = zeroPad(arrayify$1(result._vs), 32);
      result._vs = hexlify(vs3);
      const recoveryParam = vs3[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger$s.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs3[0] &= 127;
      const s3 = hexlify(vs3);
      if (result.s == null) {
        result.s = s3;
      } else if (result.s !== s3) {
        logger$s.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger$s.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger$s.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString$3(result.r)) {
      logger$s.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString$3(result.s)) {
      logger$s.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs2 = arrayify$1(result.s);
    if (vs2[0] >= 128) {
      logger$s.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs2[0] |= 128;
    }
    const _vs = hexlify(vs2);
    if (result._vs) {
      if (!isHexString$3(result._vs)) {
        logger$s.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger$s.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
const version$o = "bignumber/5.7.0";
var BN$2 = BN$3.BN;
const logger$r = new Logger$1(version$o);
const _constructorGuard$3 = {};
const MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString$3(value) || typeof value === "bigint" || isBytes$4(value));
}
let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex2) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$r.throwError("cannot call constructor directly; use BigNumber.from", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex2;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o2 = BigNumber.from(other);
    if (o2.isZero()) {
      throwFault$1("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e2) {
    }
    return logger$r.throwError("this platform does not support BigInt", Logger$1.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger$r.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger$r.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger$1.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger$r.throwError("BigNumber.toString does not accept parameters", Logger$1.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key2) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard$3, toHex$1(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard$3, toHex$1(new BN$2(value)));
      }
      return logger$r.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault$1("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault$1("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes$4(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex2 = anyValue.toHexString();
        if (typeof hex2 === "string") {
          return BigNumber.from(hex2);
        }
      } else {
        let hex2 = anyValue._hex;
        if (hex2 == null && anyValue.type === "BigNumber") {
          hex2 = anyValue.hex;
        }
        if (typeof hex2 === "string") {
          if (isHexString$3(hex2) || hex2[0] === "-" && isHexString$3(hex2.substring(1))) {
            return BigNumber.from(hex2);
          }
        }
      }
    }
    return logger$r.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
}
function toHex$1(value) {
  if (typeof value !== "string") {
    return toHex$1(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger$r.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex$1(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex$1(value));
}
function toBN(value) {
  const hex2 = BigNumber.from(value).toHexString();
  if (hex2[0] === "-") {
    return new BN$2("-" + hex2.substring(3), 16);
  }
  return new BN$2(hex2.substring(2), 16);
}
function throwFault$1(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger$r.throwError(fault, Logger$1.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN$2(value, 36).toString(16);
}
const logger$q = new Logger$1(version$o);
const _constructorGuard$2 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$2 = BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger$q.throwError(message, Logger$1.errors.NUMERIC_FAULT, params);
}
let zeros$1 = "0";
while (zeros$1.length < 256) {
  zeros$1 += zeros$1;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e2) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros$1.substring(0, decimals);
  }
  return logger$q.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero$2);
  if (negative) {
    value = value.mul(NegativeOne$2);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger$q.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger$q.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger$q.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne$2);
  }
  return wei;
}
class FixedFormat {
  constructor(constructorGuard, signed2, width, decimals) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$q.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed2;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed")
        ;
      else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger$q.throwArgumentError("invalid fixed format", "format", value);
        }
        signed2 = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check2 = (key2, type2, defaultValue) => {
        if (value[key2] == null) {
          return defaultValue;
        }
        if (typeof value[key2] !== type2) {
          logger$q.throwArgumentError("invalid fixed format (" + key2 + " not " + type2 + ")", "format." + key2, value[key2]);
        }
        return value[key2];
      };
      signed2 = check2("signed", "boolean", signed2);
      width = check2("width", "number", width);
      decimals = check2("decimals", "number", decimals);
    }
    if (width % 8) {
      logger$q.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger$q.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard$2, signed2, width, decimals);
  }
}
class FixedNumber {
  constructor(constructorGuard, hex2, value, format) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$q.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex2;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger$q.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a3 = parseFixed(this._value, this.format.decimals);
    const b4 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a3.add(b4), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a3 = parseFixed(this._value, this.format.decimals);
    const b4 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a3.sub(b4), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a3 = parseFixed(this._value, this.format.decimals);
    const b4 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a3.mul(b4).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a3 = parseFixed(this._value, this.format.decimals);
    const b4 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a3.mul(this.format._multiplier).div(b4), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  // @TODO: Support other rounding algorithms
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger$q.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros$1.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger$q.throwArgumentError("invalid byte width", "width", width);
    }
    const hex2 = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex2, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric2 = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric2.lt(Zero$2)) {
      throwFault("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex2 = null;
    if (fixedFormat.signed) {
      hex2 = numeric2.toTwos(fixedFormat.width).toHexString();
    } else {
      hex2 = numeric2.toHexString();
      hex2 = hexZeroPad(hex2, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric2, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$2, hex2, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify$1(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric2 = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric2 = numeric2.fromTwos(fixedFormat.width);
    }
    const hex2 = numeric2.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric2, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$2, hex2, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if (isBytes$4(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger$1.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger$q.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");
const version$n = "properties/5.7.0";
var __awaiter$b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$p = new Logger$1(version$n);
function defineReadOnly(object2, name2, value) {
  Object.defineProperty(object2, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i3 = 0; i3 < 32; i3++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object2) {
  return __awaiter$b(this, void 0, void 0, function* () {
    const promises = Object.keys(object2).map((key2) => {
      const value = object2[key2];
      return Promise.resolve(value).then((v4) => ({ key: key2, value: v4 }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object2, properties) {
  if (!object2 || typeof object2 !== "object") {
    logger$p.throwArgumentError("invalid object", "object", object2);
  }
  Object.keys(object2).forEach((key2) => {
    if (!properties[key2]) {
      logger$p.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object2);
    }
  });
}
function shallowCopy$1(object2) {
  const result = {};
  for (const key2 in object2) {
    result[key2] = object2[key2];
  }
  return result;
}
const opaque$2 = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object2) {
  if (object2 === void 0 || object2 === null || opaque$2[typeof object2]) {
    return true;
  }
  if (Array.isArray(object2) || typeof object2 === "object") {
    if (!Object.isFrozen(object2)) {
      return false;
    }
    const keys2 = Object.keys(object2);
    for (let i3 = 0; i3 < keys2.length; i3++) {
      let value = null;
      try {
        value = object2[keys2[i3]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger$p.throwArgumentError(`Cannot deepCopy ${typeof object2}`, "object", object2);
}
function _deepCopy(object2) {
  if (_isFrozen(object2)) {
    return object2;
  }
  if (Array.isArray(object2)) {
    return Object.freeze(object2.map((item) => deepCopy(item)));
  }
  if (typeof object2 === "object") {
    const result = {};
    for (const key2 in object2) {
      const value = object2[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger$p.throwArgumentError(`Cannot deepCopy ${typeof object2}`, "object", object2);
}
function deepCopy(object2) {
  return _deepCopy(object2);
}
class Description {
  constructor(info) {
    for (const key2 in info) {
      this[key2] = deepCopy(info[key2]);
    }
  }
}
const version$m = "abstract-provider/5.7.0";
var __awaiter$a = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$o = new Logger$1(version$m);
class ForkEvent extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
}
class Provider {
  constructor() {
    logger$o.checkAbstract(new.target, Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter$a(this, void 0, void 0, function* () {
      const { block: block2, gasPrice } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block2 && block2.baseFeePerGas) {
        lastBaseFeePerGas = block2.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block2.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  // Alias for "on"
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  // Alias for "off"
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
}
const version$l = "networks/5.7.1";
const logger$n = new Logger$1(version$l);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func2 = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip3 = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider = new providers.PocketProvider(network, options.pocket);
        if (provider.network && skip3.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip3 = ["ropsten"];
        const provider = new providers.AnkrProvider(network, options.ankr);
        if (provider.network && skip3.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func2.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func2;
}
function etcDefaultProvider(url, network) {
  const func2 = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func2.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func2;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
const networks$1 = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks$1) {
      const standard2 = networks$1[name2];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks$1[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks$1[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger$n.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger$n.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
const version$k = "logger/5.7.0";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex2 = "";
          for (let i3 = 0; i3 < value.length; i3++) {
            hex2 += HEX[value[i3] >> 4];
            hex2 += HEX[value[i3] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex2 + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code2) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code2;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$k);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version2) {
    return new Logger(version2);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$j = "bytes/5.7.0";
const logger$m = new Logger(version$j);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array2) {
  if (array2.slice) {
    return array2;
  }
  array2.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array2, args)));
  };
  return array2;
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes$3(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i3 = 0; i3 < value.length; i3++) {
    const v4 = value[i3];
    if (!isInteger(v4) || v4 < 0 || v4 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$m.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString$2(value)) {
    let hex2 = value.substring(2);
    if (hex2.length % 2) {
      if (options.hexPad === "left") {
        hex2 = "0" + hex2;
      } else if (options.hexPad === "right") {
        hex2 += "0";
      } else {
        logger$m.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i3 = 0; i3 < hex2.length; i3 += 2) {
      result.push(parseInt(hex2.substring(i3, i3 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes$3(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger$m.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString$2(value, length2) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && value.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
function decode$l(textData) {
  textData = atob(textData);
  const data2 = [];
  for (let i3 = 0; i3 < textData.length; i3++) {
    data2.push(textData.charCodeAt(i3));
  }
  return arrayify(data2);
}
function encode$h(data2) {
  data2 = arrayify(data2);
  let textData = "";
  for (let i3 = 0; i3 < data2.length; i3++) {
    textData += String.fromCharCode(data2[i3]);
  }
  return btoa(textData);
}
class BaseX {
  constructor(alphabet2) {
    defineReadOnly(this, "alphabet", alphabet2);
    defineReadOnly(this, "base", alphabet2.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet2.charAt(0));
    for (let i3 = 0; i3 < alphabet2.length; i3++) {
      this._alphabetMap[alphabet2.charAt(i3)] = i3;
    }
  }
  encode(value) {
    let source = arrayify$1(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i3 = 0; i3 < source.length; ++i3) {
      let carry = source[i3];
      for (let j2 = 0; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string2 = "";
    for (let k3 = 0; source[k3] === 0 && k3 < source.length - 1; ++k3) {
      string2 += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string2 += this.alphabet[digits[q2]];
    }
    return string2;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes2 = [];
    if (value.length === 0) {
      return new Uint8Array(bytes2);
    }
    bytes2.push(0);
    for (let i3 = 0; i3 < value.length; i3++) {
      let byte2 = this._alphabetMap[value[i3]];
      if (byte2 === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte2;
      for (let j2 = 0; j2 < bytes2.length; ++j2) {
        carry += bytes2[j2] * this.base;
        bytes2[j2] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes2.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k3 = 0; value[k3] === this._leader && k3 < value.length - 1; ++k3) {
      bytes2.push(0);
    }
    return arrayify$1(new Uint8Array(bytes2.reverse()));
  }
}
new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
const AddressZero = "0x0000000000000000000000000000000000000000";
const NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1);
const Zero$1 = /* @__PURE__ */ BigNumber.from(0);
const One$1 = /* @__PURE__ */ BigNumber.from(1);
const MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
var sha3$1 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(module2) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root2 = WINDOW ? window : {};
    if (root2.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root2.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root2 = commonjsGlobal;
    } else if (WEB_WORKER) {
      root2 = self;
    }
    var COMMON_JS = !root2.JS_SHA3_NO_COMMON_JS && true && module2.exports;
    var ARRAY_BUFFER = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding2, outputType) {
      return function(message) {
        return new Keccak2(bits2, padding2, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits) {
        return new Keccak2(bits2, padding2, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits, n4, s3) {
        return methods["cshake" + bits2].update(message, outputBits, n4, s3)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding2, outputType) {
      return function(key2, message, outputBits, s3) {
        return methods["kmac" + bits2].update(key2, message, outputBits, s3)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding2) {
      for (var i4 = 0; i4 < OUTPUT_TYPES.length; ++i4) {
        var type2 = OUTPUT_TYPES[i4];
        method[type2] = createMethod2(bits2, padding2, type2);
      }
      return method;
    };
    var createMethod = function(bits2, padding2) {
      var method = createOutputMethod(bits2, padding2, "hex");
      method.create = function() {
        return new Keccak2(bits2, padding2, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding2);
    };
    var createShakeMethod = function(bits2, padding2) {
      var method = createShakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits) {
        return new Keccak2(bits2, padding2, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
    };
    var createCshakeMethod = function(bits2, padding2) {
      var w3 = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits, n4, s3) {
        if (!n4 && !s3) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak2(bits2, padding2, outputBits).bytepad([n4, s3], w3);
        }
      };
      method.update = function(message, outputBits, n4, s3) {
        return method.create(outputBits, n4, s3).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
    };
    var createKmacMethod = function(bits2, padding2) {
      var w3 = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding2, "hex");
      method.create = function(key2, outputBits, s3) {
        return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s3], w3).bytepad([key2], w3);
      };
      method.update = function(key2, message, outputBits, s3) {
        return method.create(key2, outputBits, s3).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
      { name: "sha3", padding: PADDING, bits: BITS, createMethod },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i3 = 0; i3 < algorithms.length; ++i3) {
      var algorithm = algorithms[i3];
      var bits = algorithm.bits;
      for (var j2 = 0; j2 < bits.length; ++j2) {
        var methodName = algorithm.name + "_" + bits[j2];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j2], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j2];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak2(bits2, padding2, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding2;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i4 = 0; i4 < 50; ++i4) {
        this.s[i4] = 0;
      }
    }
    Keccak2.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type2 = typeof message;
      if (type2 !== "string") {
        if (type2 === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index2 = 0, s3 = this.s, i4, code2;
      while (index2 < length2) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i4 = 1; i4 < blockCount + 1; ++i4) {
            blocks[i4] = 0;
          }
        }
        if (notString) {
          for (i4 = this.start; index2 < length2 && i4 < byteCount; ++index2) {
            blocks[i4 >> 2] |= message[index2] << SHIFT[i4++ & 3];
          }
        } else {
          for (i4 = this.start; index2 < length2 && i4 < byteCount; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks[i4 >> 2] |= code2 << SHIFT[i4++ & 3];
            } else if (code2 < 2048) {
              blocks[i4 >> 2] |= (192 | code2 >> 6) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 & 63) << SHIFT[i4++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks[i4 >> 2] |= (224 | code2 >> 12) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 & 63) << SHIFT[i4++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks[i4 >> 2] |= (240 | code2 >> 18) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 & 63) << SHIFT[i4++ & 3];
            }
          }
        }
        this.lastByteIndex = i4;
        if (i4 >= byteCount) {
          this.start = i4 - byteCount;
          this.block = blocks[blockCount];
          for (i4 = 0; i4 < blockCount; ++i4) {
            s3[i4] ^= blocks[i4];
          }
          f4(s3);
          this.reset = true;
        } else {
          this.start = i4;
        }
      }
      return this;
    };
    Keccak2.prototype.encode = function(x2, right) {
      var o2 = x2 & 255, n4 = 1;
      var bytes2 = [o2];
      x2 = x2 >> 8;
      o2 = x2 & 255;
      while (o2 > 0) {
        bytes2.unshift(o2);
        x2 = x2 >> 8;
        o2 = x2 & 255;
        ++n4;
      }
      if (right) {
        bytes2.push(n4);
      } else {
        bytes2.unshift(n4);
      }
      this.update(bytes2);
      return bytes2.length;
    };
    Keccak2.prototype.encodeString = function(str) {
      var notString, type2 = typeof str;
      if (type2 !== "string") {
        if (type2 === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes2 = 0, length2 = str.length;
      if (notString) {
        bytes2 = length2;
      } else {
        for (var i4 = 0; i4 < str.length; ++i4) {
          var code2 = str.charCodeAt(i4);
          if (code2 < 128) {
            bytes2 += 1;
          } else if (code2 < 2048) {
            bytes2 += 2;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes2 += 3;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i4) & 1023);
            bytes2 += 4;
          }
        }
      }
      bytes2 += this.encode(bytes2 * 8);
      this.update(str);
      return bytes2;
    };
    Keccak2.prototype.bytepad = function(strs, w3) {
      var bytes2 = this.encode(w3);
      for (var i4 = 0; i4 < strs.length; ++i4) {
        bytes2 += this.encodeString(strs[i4]);
      }
      var paddingBytes = w3 - bytes2 % w3;
      var zeros2 = [];
      zeros2.length = paddingBytes;
      this.update(zeros2);
      return this;
    };
    Keccak2.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i4 = this.lastByteIndex, blockCount = this.blockCount, s3 = this.s;
      blocks[i4 >> 2] |= this.padding[i4 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i4 = 1; i4 < blockCount + 1; ++i4) {
          blocks[i4] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i4 = 0; i4 < blockCount; ++i4) {
        s3[i4] ^= blocks[i4];
      }
      f4(s3);
    };
    Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j3 = 0;
      var hex2 = "", block2;
      while (j3 < outputBlocks) {
        for (i4 = 0; i4 < blockCount && j3 < outputBlocks; ++i4, ++j3) {
          block2 = s3[i4];
          hex2 += HEX_CHARS[block2 >> 4 & 15] + HEX_CHARS[block2 & 15] + HEX_CHARS[block2 >> 12 & 15] + HEX_CHARS[block2 >> 8 & 15] + HEX_CHARS[block2 >> 20 & 15] + HEX_CHARS[block2 >> 16 & 15] + HEX_CHARS[block2 >> 28 & 15] + HEX_CHARS[block2 >> 24 & 15];
        }
        if (j3 % blockCount === 0) {
          f4(s3);
          i4 = 0;
        }
      }
      if (extraBytes) {
        block2 = s3[i4];
        hex2 += HEX_CHARS[block2 >> 4 & 15] + HEX_CHARS[block2 & 15];
        if (extraBytes > 1) {
          hex2 += HEX_CHARS[block2 >> 12 & 15] + HEX_CHARS[block2 >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex2 += HEX_CHARS[block2 >> 20 & 15] + HEX_CHARS[block2 >> 16 & 15];
        }
      }
      return hex2;
    };
    Keccak2.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j3 = 0;
      var bytes2 = this.outputBits >> 3;
      var buffer2;
      if (extraBytes) {
        buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer2 = new ArrayBuffer(bytes2);
      }
      var array2 = new Uint32Array(buffer2);
      while (j3 < outputBlocks) {
        for (i4 = 0; i4 < blockCount && j3 < outputBlocks; ++i4, ++j3) {
          array2[j3] = s3[i4];
        }
        if (j3 % blockCount === 0) {
          f4(s3);
        }
      }
      if (extraBytes) {
        array2[i4] = s3[i4];
        buffer2 = buffer2.slice(0, bytes2);
      }
      return buffer2;
    };
    Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
    Keccak2.prototype.digest = Keccak2.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j3 = 0;
      var array2 = [], offset, block2;
      while (j3 < outputBlocks) {
        for (i4 = 0; i4 < blockCount && j3 < outputBlocks; ++i4, ++j3) {
          offset = j3 << 2;
          block2 = s3[i4];
          array2[offset] = block2 & 255;
          array2[offset + 1] = block2 >> 8 & 255;
          array2[offset + 2] = block2 >> 16 & 255;
          array2[offset + 3] = block2 >> 24 & 255;
        }
        if (j3 % blockCount === 0) {
          f4(s3);
        }
      }
      if (extraBytes) {
        offset = j3 << 2;
        block2 = s3[i4];
        array2[offset] = block2 & 255;
        if (extraBytes > 1) {
          array2[offset + 1] = block2 >> 8 & 255;
        }
        if (extraBytes > 2) {
          array2[offset + 2] = block2 >> 16 & 255;
        }
      }
      return array2;
    };
    function Kmac(bits2, padding2, outputBits) {
      Keccak2.call(this, bits2, padding2, outputBits);
    }
    Kmac.prototype = new Keccak2();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak2.prototype.finalize.call(this);
    };
    var f4 = function(s3) {
      var h5, l2, n4, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b22, b32, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n4 = 0; n4 < 48; n4 += 2) {
        c0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
        c1 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
        c2 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
        c3 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
        c4 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
        c5 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
        c6 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
        c7 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
        c8 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
        c9 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
        h5 = c8 ^ (c2 << 1 | c3 >>> 31);
        l2 = c9 ^ (c3 << 1 | c2 >>> 31);
        s3[0] ^= h5;
        s3[1] ^= l2;
        s3[10] ^= h5;
        s3[11] ^= l2;
        s3[20] ^= h5;
        s3[21] ^= l2;
        s3[30] ^= h5;
        s3[31] ^= l2;
        s3[40] ^= h5;
        s3[41] ^= l2;
        h5 = c0 ^ (c4 << 1 | c5 >>> 31);
        l2 = c1 ^ (c5 << 1 | c4 >>> 31);
        s3[2] ^= h5;
        s3[3] ^= l2;
        s3[12] ^= h5;
        s3[13] ^= l2;
        s3[22] ^= h5;
        s3[23] ^= l2;
        s3[32] ^= h5;
        s3[33] ^= l2;
        s3[42] ^= h5;
        s3[43] ^= l2;
        h5 = c2 ^ (c6 << 1 | c7 >>> 31);
        l2 = c3 ^ (c7 << 1 | c6 >>> 31);
        s3[4] ^= h5;
        s3[5] ^= l2;
        s3[14] ^= h5;
        s3[15] ^= l2;
        s3[24] ^= h5;
        s3[25] ^= l2;
        s3[34] ^= h5;
        s3[35] ^= l2;
        s3[44] ^= h5;
        s3[45] ^= l2;
        h5 = c4 ^ (c8 << 1 | c9 >>> 31);
        l2 = c5 ^ (c9 << 1 | c8 >>> 31);
        s3[6] ^= h5;
        s3[7] ^= l2;
        s3[16] ^= h5;
        s3[17] ^= l2;
        s3[26] ^= h5;
        s3[27] ^= l2;
        s3[36] ^= h5;
        s3[37] ^= l2;
        s3[46] ^= h5;
        s3[47] ^= l2;
        h5 = c6 ^ (c0 << 1 | c1 >>> 31);
        l2 = c7 ^ (c1 << 1 | c0 >>> 31);
        s3[8] ^= h5;
        s3[9] ^= l2;
        s3[18] ^= h5;
        s3[19] ^= l2;
        s3[28] ^= h5;
        s3[29] ^= l2;
        s3[38] ^= h5;
        s3[39] ^= l2;
        s3[48] ^= h5;
        s3[49] ^= l2;
        b0 = s3[0];
        b1 = s3[1];
        b322 = s3[11] << 4 | s3[10] >>> 28;
        b33 = s3[10] << 4 | s3[11] >>> 28;
        b14 = s3[20] << 3 | s3[21] >>> 29;
        b15 = s3[21] << 3 | s3[20] >>> 29;
        b46 = s3[31] << 9 | s3[30] >>> 23;
        b47 = s3[30] << 9 | s3[31] >>> 23;
        b28 = s3[40] << 18 | s3[41] >>> 14;
        b29 = s3[41] << 18 | s3[40] >>> 14;
        b20 = s3[2] << 1 | s3[3] >>> 31;
        b21 = s3[3] << 1 | s3[2] >>> 31;
        b22 = s3[13] << 12 | s3[12] >>> 20;
        b32 = s3[12] << 12 | s3[13] >>> 20;
        b34 = s3[22] << 10 | s3[23] >>> 22;
        b35 = s3[23] << 10 | s3[22] >>> 22;
        b16 = s3[33] << 13 | s3[32] >>> 19;
        b17 = s3[32] << 13 | s3[33] >>> 19;
        b48 = s3[42] << 2 | s3[43] >>> 30;
        b49 = s3[43] << 2 | s3[42] >>> 30;
        b40 = s3[5] << 30 | s3[4] >>> 2;
        b41 = s3[4] << 30 | s3[5] >>> 2;
        b222 = s3[14] << 6 | s3[15] >>> 26;
        b23 = s3[15] << 6 | s3[14] >>> 26;
        b4 = s3[25] << 11 | s3[24] >>> 21;
        b5 = s3[24] << 11 | s3[25] >>> 21;
        b36 = s3[34] << 15 | s3[35] >>> 17;
        b37 = s3[35] << 15 | s3[34] >>> 17;
        b18 = s3[45] << 29 | s3[44] >>> 3;
        b19 = s3[44] << 29 | s3[45] >>> 3;
        b10 = s3[6] << 28 | s3[7] >>> 4;
        b11 = s3[7] << 28 | s3[6] >>> 4;
        b42 = s3[17] << 23 | s3[16] >>> 9;
        b43 = s3[16] << 23 | s3[17] >>> 9;
        b24 = s3[26] << 25 | s3[27] >>> 7;
        b25 = s3[27] << 25 | s3[26] >>> 7;
        b6 = s3[36] << 21 | s3[37] >>> 11;
        b7 = s3[37] << 21 | s3[36] >>> 11;
        b38 = s3[47] << 24 | s3[46] >>> 8;
        b39 = s3[46] << 24 | s3[47] >>> 8;
        b30 = s3[8] << 27 | s3[9] >>> 5;
        b31 = s3[9] << 27 | s3[8] >>> 5;
        b12 = s3[18] << 20 | s3[19] >>> 12;
        b13 = s3[19] << 20 | s3[18] >>> 12;
        b44 = s3[29] << 7 | s3[28] >>> 25;
        b45 = s3[28] << 7 | s3[29] >>> 25;
        b26 = s3[38] << 8 | s3[39] >>> 24;
        b27 = s3[39] << 8 | s3[38] >>> 24;
        b8 = s3[48] << 14 | s3[49] >>> 18;
        b9 = s3[49] << 14 | s3[48] >>> 18;
        s3[0] = b0 ^ ~b22 & b4;
        s3[1] = b1 ^ ~b32 & b5;
        s3[10] = b10 ^ ~b12 & b14;
        s3[11] = b11 ^ ~b13 & b15;
        s3[20] = b20 ^ ~b222 & b24;
        s3[21] = b21 ^ ~b23 & b25;
        s3[30] = b30 ^ ~b322 & b34;
        s3[31] = b31 ^ ~b33 & b35;
        s3[40] = b40 ^ ~b42 & b44;
        s3[41] = b41 ^ ~b43 & b45;
        s3[2] = b22 ^ ~b4 & b6;
        s3[3] = b32 ^ ~b5 & b7;
        s3[12] = b12 ^ ~b14 & b16;
        s3[13] = b13 ^ ~b15 & b17;
        s3[22] = b222 ^ ~b24 & b26;
        s3[23] = b23 ^ ~b25 & b27;
        s3[32] = b322 ^ ~b34 & b36;
        s3[33] = b33 ^ ~b35 & b37;
        s3[42] = b42 ^ ~b44 & b46;
        s3[43] = b43 ^ ~b45 & b47;
        s3[4] = b4 ^ ~b6 & b8;
        s3[5] = b5 ^ ~b7 & b9;
        s3[14] = b14 ^ ~b16 & b18;
        s3[15] = b15 ^ ~b17 & b19;
        s3[24] = b24 ^ ~b26 & b28;
        s3[25] = b25 ^ ~b27 & b29;
        s3[34] = b34 ^ ~b36 & b38;
        s3[35] = b35 ^ ~b37 & b39;
        s3[44] = b44 ^ ~b46 & b48;
        s3[45] = b45 ^ ~b47 & b49;
        s3[6] = b6 ^ ~b8 & b0;
        s3[7] = b7 ^ ~b9 & b1;
        s3[16] = b16 ^ ~b18 & b10;
        s3[17] = b17 ^ ~b19 & b11;
        s3[26] = b26 ^ ~b28 & b20;
        s3[27] = b27 ^ ~b29 & b21;
        s3[36] = b36 ^ ~b38 & b30;
        s3[37] = b37 ^ ~b39 & b31;
        s3[46] = b46 ^ ~b48 & b40;
        s3[47] = b47 ^ ~b49 & b41;
        s3[8] = b8 ^ ~b0 & b22;
        s3[9] = b9 ^ ~b1 & b32;
        s3[18] = b18 ^ ~b10 & b12;
        s3[19] = b19 ^ ~b11 & b13;
        s3[28] = b28 ^ ~b20 & b222;
        s3[29] = b29 ^ ~b21 & b23;
        s3[38] = b38 ^ ~b30 & b322;
        s3[39] = b39 ^ ~b31 & b33;
        s3[48] = b48 ^ ~b40 & b42;
        s3[49] = b49 ^ ~b41 & b43;
        s3[0] ^= RC[n4];
        s3[1] ^= RC[n4 + 1];
      }
    };
    if (COMMON_JS) {
      module2.exports = methods;
    } else {
      for (i3 = 0; i3 < methodNames.length; ++i3) {
        root2[methodNames[i3]] = methods[methodNames[i3]];
      }
    }
  })();
})(sha3$1);
var sha3Exports = sha3$1.exports;
const sha3 = /* @__PURE__ */ getDefaultExportFromCjs(sha3Exports);
function keccak256(data2) {
  return "0x" + sha3.keccak_256(arrayify$1(data2));
}
const version$i = "strings/5.7.0";
const logger$l = new Logger$1(version$i);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes2, output, badCodepoint) {
  return logger$l.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset, bytes2, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i3 = 0;
    for (let o2 = offset + 1; o2 < bytes2.length; o2++) {
      if (bytes2[o2] >> 6 !== 2) {
        break;
      }
      i3++;
    }
    return i3;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes2, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes2);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes2, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes2 = arrayify$1(bytes2);
  const result = [];
  let i3 = 0;
  while (i3 < bytes2.length) {
    const c2 = bytes2[i3++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i3 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i3 - 1, bytes2, result);
      } else {
        i3 += onError(Utf8ErrorReason.BAD_PREFIX, i3 - 1, bytes2, result);
      }
      continue;
    }
    if (i3 - 1 + extraLength >= bytes2.length) {
      i3 += onError(Utf8ErrorReason.OVERRUN, i3 - 1, bytes2, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes2[i3];
      if ((nextChar & 192) != 128) {
        i3 += onError(Utf8ErrorReason.MISSING_CONTINUE, i3, bytes2, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i3++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i3 += onError(Utf8ErrorReason.OUT_OF_RANGE, i3 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i3 += onError(Utf8ErrorReason.UTF16_SURROGATE, i3 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i3 += onError(Utf8ErrorReason.OVERLONG, i3 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger$l.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i3 = 0; i3 < str.length; i3++) {
    const c2 = str.charCodeAt(i3);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i3++;
      const c22 = str.charCodeAt(i3);
      if (i3 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify$1(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
function id$1(text) {
  return keccak256(toUtf8Bytes(text));
}
const version$h = "hash/5.7.0";
function flat$1(array2, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach2 = result.forEach;
  const flatDeep = function(arr2, depth2) {
    forEach2.call(arr2, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array2, depth);
  return result;
}
function fromEntries(array2) {
  const result = {};
  for (let i3 = 0; i3 < array2.length; i3++) {
    const value = array2[i3];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes2) {
  let pos = 0;
  function u16() {
    return bytes2[pos++] << 8 | bytes2[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i3 = 1; i3 < symbol_count; i3++) {
    acc.push(total += u16());
  }
  let skip3 = u16();
  let pos_payload = pos;
  pos += skip3;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes2[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N10 = 31;
  const FULL = Math.pow(2, N10);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i3 = 0; i3 < N10; i3++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range2 = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range2);
    let start = 0;
    let end2 = symbol_count;
    while (end2 - start > 1) {
      let mid = start + end2 >>> 1;
      if (value < acc[mid]) {
        end2 = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a3 = low + Math.floor(range2 * acc[start] / total);
    let b4 = low + Math.floor(range2 * acc[start + 1] / total) - 1;
    while (((a3 ^ b4) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a3 = a3 << 1 & MASK;
      b4 = b4 << 1 & MASK | 1;
    }
    while (a3 & ~b4 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a3 = a3 << 1 ^ HALF;
      b4 = (b4 ^ HALF) << 1 | HALF | 1;
    }
    low = a3;
    range2 = 1 + b4 - a3;
  }
  let offset = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset) {
      case 3:
        return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 2:
        return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 1:
        return offset + bytes2[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
function read_payload(v4) {
  let pos = 0;
  return () => v4[pos++];
}
function read_compressed_payload(bytes2) {
  return read_payload(decode_arithmetic(bytes2));
}
function signed(i3) {
  return i3 & 1 ? ~i3 >> 1 : i3 >> 1;
}
function read_counts(n4, next) {
  let v4 = Array(n4);
  for (let i3 = 0; i3 < n4; i3++)
    v4[i3] = 1 + next();
  return v4;
}
function read_ascending(n4, next) {
  let v4 = Array(n4);
  for (let i3 = 0, x2 = -1; i3 < n4; i3++)
    v4[i3] = x2 += 1 + next();
  return v4;
}
function read_deltas(n4, next) {
  let v4 = Array(n4);
  for (let i3 = 0, x2 = 0; i3 < n4; i3++)
    v4[i3] = x2 += signed(next());
  return v4;
}
function read_member_array(next, lookup2) {
  let v4 = read_ascending(next(), next);
  let n4 = next();
  let vX = read_ascending(n4, next);
  let vN = read_counts(n4, next);
  for (let i3 = 0; i3 < n4; i3++) {
    for (let j2 = 0; j2 < vN[i3]; j2++) {
      v4.push(vX[i3] + j2);
    }
  }
  return lookup2 ? v4.map((x2) => lookup2[x2]) : v4;
}
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w3 = next();
    if (w3 == 0)
      break;
    ret.push(read_linear_table(w3, next));
  }
  while (true) {
    let w3 = next() - 1;
    if (w3 < 0)
      break;
    ret.push(read_replacement_table(w3, next));
  }
  return fromEntries(flat$1(ret));
}
function read_zero_terminated_array(next) {
  let v4 = [];
  while (true) {
    let i3 = next();
    if (i3 == 0)
      break;
    v4.push(i3);
  }
  return v4;
}
function read_transposed(n4, w3, next) {
  let m2 = Array(n4).fill(void 0).map(() => []);
  for (let i3 = 0; i3 < w3; i3++) {
    read_deltas(n4, next).forEach((x2, j2) => m2[j2].push(x2));
  }
  return m2;
}
function read_linear_table(w3, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m2 = read_transposed(vN.length, 1 + w3, next);
  return flat$1(m2.map((v4, i3) => {
    const x2 = v4[0], ys2 = v4.slice(1);
    return Array(vN[i3]).fill(void 0).map((_3, j2) => {
      let j_dy = j2 * dy;
      return [x2 + j2 * dx, ys2.map((y3) => y3 + j_dy)];
    });
  }));
}
function read_replacement_table(w3, next) {
  let n4 = 1 + next();
  let m2 = read_transposed(n4, 1 + w3, next);
  return m2.map((v4) => [v4[0], v4.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a3, b4) => a3 - b4);
  return read2();
  function read2() {
    let branches = [];
    while (true) {
      let keys2 = read_member_array(next, sorted);
      if (keys2.length == 0)
        break;
      branches.push({ set: new Set(keys2), node: read2() });
    }
    branches.sort((a3, b4) => b4.set.size - a3.set.size);
    let temp = next();
    let valid2 = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check2 = temp == 2;
    return { branches, valid: valid2, fe0f, save, check: check2 };
  }
}
function getData() {
  return read_compressed_payload(decode$l("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const r$b = getData();
const VALID = new Set(read_member_array(r$b));
const IGNORED = new Set(read_member_array(r$b));
const MAPPED = read_mapped_map(r$b);
const EMOJI_ROOT = read_emoji_trie(r$b);
const HYPHEN = 45;
const UNDERSCORE = 95;
function explode_cp(name2) {
  return toUtf8CodePoints(name2);
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
function ens_normalize_post_check(name2) {
  for (let label of name2.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i3 = cps.lastIndexOf(UNDERSCORE) - 1; i3 >= 0; i3--) {
        if (cps[i3] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name2;
}
function ens_normalize(name2) {
  return ens_normalize_post_check(normalize$1(name2, filter_fe0f));
}
function normalize$1(name2, emoji_filter) {
  let input = explode_cp(name2).reverse();
  let output = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
function nfc(s3) {
  return s3.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
  var _a2;
  let node2 = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node2 = (_a2 = node2.branches.find((x2) => x2.set.has(cp))) === null || _a2 === void 0 ? void 0 : _a2.node;
    if (!node2)
      break;
    if (node2.save) {
      saved = cp;
    } else if (node2.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node2.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node2.valid) {
      emoji = stack.slice();
      if (node2.valid == 2)
        emoji.splice(1, 1);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
const logger$k = new Logger$1(version$h);
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name2) {
  const bytes2 = toUtf8Bytes(ens_normalize(name2));
  const comps = [];
  if (name2.length === 0) {
    return comps;
  }
  let last2 = 0;
  for (let i3 = 0; i3 < bytes2.length; i3++) {
    const d3 = bytes2[i3];
    if (d3 === 46) {
      comps.push(checkComponent(bytes2.slice(last2, i3)));
      last2 = i3 + 1;
    }
  }
  if (last2 >= bytes2.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes2.slice(last2)));
  return comps;
}
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger$k.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let result = Zeros;
  const comps = ensNameSplit(name2);
  while (comps.length) {
    result = keccak256(concat$6([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name2) {
  return hexlify(concat$6(ensNameSplit(name2).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}
const version$g = "rlp/5.7.0";
const logger$j = new Logger$1(version$g);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data2, offset, length2) {
  let result = 0;
  for (let i3 = 0; i3 < length2; i3++) {
    result = result * 256 + data2[offset + i3];
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length3 = arrayifyInteger(payload.length);
    length3.unshift(247 + length3.length);
    return length3.concat(payload);
  }
  if (!isBytesLike(object2)) {
    logger$j.throwArgumentError("RLP object must be BytesLike", "object", object2);
  }
  const data2 = Array.prototype.slice.call(arrayify$1(object2));
  if (data2.length === 1 && data2[0] <= 127) {
    return data2;
  } else if (data2.length <= 55) {
    data2.unshift(128 + data2.length);
    return data2;
  }
  const length2 = arrayifyInteger(data2.length);
  length2.unshift(183 + length2.length);
  return length2.concat(data2);
}
function encode$g(object2) {
  return hexlify(_encode(object2));
}
function _decodeChildren(data2, offset, childOffset, length2) {
  const result = [];
  while (childOffset < offset + 1 + length2) {
    const decoded = _decode(data2, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length2) {
      logger$j.throwError("child data too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length2, result };
}
function _decode(data2, offset) {
  if (data2.length === 0) {
    logger$j.throwError("data too short", Logger$1.errors.BUFFER_OVERRUN, {});
  }
  if (data2[offset] >= 248) {
    const lengthLength = data2[offset] - 247;
    if (offset + 1 + lengthLength > data2.length) {
      logger$j.throwError("data short segment too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data2, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length2 > data2.length) {
      logger$j.throwError("data long segment too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset, offset + 1 + lengthLength, lengthLength + length2);
  } else if (data2[offset] >= 192) {
    const length2 = data2[offset] - 192;
    if (offset + 1 + length2 > data2.length) {
      logger$j.throwError("data array too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset, offset + 1, length2);
  } else if (data2[offset] >= 184) {
    const lengthLength = data2[offset] - 183;
    if (offset + 1 + lengthLength > data2.length) {
      logger$j.throwError("data array too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data2, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length2 > data2.length) {
      logger$j.throwError("data array too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length2));
    return { consumed: 1 + lengthLength + length2, result };
  } else if (data2[offset] >= 128) {
    const length2 = data2[offset] - 128;
    if (offset + 1 + length2 > data2.length) {
      logger$j.throwError("data too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset + 1, offset + 1 + length2));
    return { consumed: 1 + length2, result };
  }
  return { consumed: 1, result: hexlify(data2[offset]) };
}
function decode$k(data2) {
  const bytes2 = arrayify$1(data2);
  const decoded = _decode(bytes2, 0);
  if (decoded.consumed !== bytes2.length) {
    logger$j.throwArgumentError("invalid rlp data", "data", data2);
  }
  return decoded.result;
}
const version$f = "address/5.7.0";
const logger$i = new Logger$1(version$f);
function getChecksumAddress(address) {
  if (!isHexString$3(address, 20)) {
    logger$i.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i3 = 0; i3 < 40; i3++) {
    expanded[i3] = chars[i3].charCodeAt(0);
  }
  const hashed = arrayify$1(keccak256(expanded));
  for (let i3 = 0; i3 < 40; i3 += 2) {
    if (hashed[i3 >> 1] >> 4 >= 8) {
      chars[i3] = chars[i3].toUpperCase();
    }
    if ((hashed[i3 >> 1] & 15) >= 8) {
      chars[i3 + 1] = chars[i3 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const MAX_SAFE_INTEGER$2 = 9007199254740991;
function log10(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
const ibanLookup = {};
for (let i3 = 0; i3 < 10; i3++) {
  ibanLookup[String(i3)] = String(i3);
}
for (let i3 = 0; i3 < 26; i3++) {
  ibanLookup[String.fromCharCode(65 + i3)] = String(10 + i3);
}
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER$2));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block2 = expanded.substring(0, safeDigits);
    expanded = parseInt(block2, 10) % 97 + expanded.substring(block2.length);
  }
  let checksum2 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum2.length < 2) {
    checksum2 = "0" + checksum2;
  }
  return checksum2;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger$i.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger$i.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger$i.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger$i.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function getContractAddress(transaction) {
  let from2 = null;
  try {
    from2 = getAddress(transaction.from);
  } catch (error) {
    logger$i.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify$1(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode$g([from2, nonce])), 12));
}
var __awaiter$9 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$h = new Logger$1(version$h);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = arrayify$1(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return hexConcat([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger$h.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger$h.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger$h.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes2 = arrayify$1(value);
      if (bytes2.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes2);
    } catch (error) {
    }
    return logger$h.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type2) {
  {
    const match = type2.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger$h.throwArgumentError("invalid numeric width", "type", type2);
      }
      const boundsUpper = MaxUint256.mask(signed2 ? width - 1 : width);
      const boundsLower = signed2 ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function(value) {
        const v4 = BigNumber.from(value);
        if (v4.lt(boundsLower) || v4.gt(boundsUpper)) {
          logger$h.throwArgumentError(`value out-of-bounds for ${type2}`, "value", value);
        }
        return hexZeroPad(v4.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type2.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger$h.throwArgumentError("invalid bytes width", "type", type2);
      }
      return function(value) {
        const bytes2 = arrayify$1(value);
        if (bytes2.length !== width) {
          logger$h.throwArgumentError(`invalid length for ${type2}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type2) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id$1(value);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type: type2 }) => type2 + " " + name3).join(",")})`;
}
class TypedDataEncoder {
  constructor(types2) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types2)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links2 = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types2).forEach((type2) => {
      links2[type2] = {};
      parents[type2] = [];
      subtypes[type2] = {};
    });
    for (const name2 in types2) {
      const uniqueNames = {};
      types2[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger$h.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types2);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger$h.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types2);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger$h.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types2);
        }
        parents[baseType].push(name2);
        links2[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n4) => parents[n4].length === 0);
    if (primaryTypes.length === 0) {
      logger$h.throwArgumentError("missing primary type", "types", types2);
    } else if (primaryTypes.length > 1) {
      logger$h.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types2);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type2, found) {
      if (found[type2]) {
        logger$h.throwArgumentError(`circular type reference to ${JSON.stringify(type2)}`, "types", types2);
      }
      found[type2] = true;
      Object.keys(links2[type2]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type2];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st2 = Object.keys(subtypes[name2]);
      st2.sort();
      this._types[name2] = encodeType(name2, types2[name2]) + st2.map((t2) => encodeType(t2, types2[t2])).join("");
    }
  }
  getEncoder(type2) {
    let encoder = this._encoderCache[type2];
    if (!encoder) {
      encoder = this._encoderCache[type2] = this._getEncoder(type2);
    }
    return encoder;
  }
  _getEncoder(type2) {
    {
      const encoder = getBaseEncoder(type2);
      if (encoder) {
        return encoder;
      }
    }
    const match = type2.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length2 = parseInt(match[3]);
      return (value) => {
        if (length2 >= 0 && value.length !== length2) {
          logger$h.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256);
        }
        return keccak256(hexConcat(result));
      };
    }
    const fields = this.types[type2];
    if (fields) {
      const encodedType = id$1(this._types[type2]);
      return (value) => {
        const values = fields.map(({ name: name2, type: type3 }) => {
          const result = this.getEncoder(type3)(value[name2]);
          if (this._types[type3]) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger$h.throwArgumentError(`unknown type: ${type2}`, "type", type2);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger$h.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type2, value) {
    return this.getEncoder(type2)(value);
  }
  hashStruct(name2, value) {
    return keccak256(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type2, value, callback) {
    {
      const encoder = getBaseEncoder(type2);
      if (encoder) {
        return callback(type2, value);
      }
    }
    const match = type2.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length2 = parseInt(match[3]);
      if (length2 >= 0 && value.length !== length2) {
        logger$h.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v4) => this._visit(subtype, v4, callback));
    }
    const fields = this.types[type2];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type3 }) => {
        accum[name2] = this._visit(type3, value[name2], callback);
        return accum;
      }, {});
    }
    return logger$h.throwArgumentError(`unknown type: ${type2}`, "type", type2);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types2) {
    return new TypedDataEncoder(types2);
  }
  static getPrimaryType(types2) {
    return TypedDataEncoder.from(types2).primaryType;
  }
  static hashStruct(name2, types2, value) {
    return TypedDataEncoder.from(types2).hashStruct(name2, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name2 in domain) {
      const type2 = domainFieldTypes[name2];
      if (!type2) {
        logger$h.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain);
      }
      domainFields.push({ name: name2, type: type2 });
    }
    domainFields.sort((a3, b4) => {
      return domainFieldNames.indexOf(a3.name) - domainFieldNames.indexOf(b4.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types2, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types2).hash(value)
    ]);
  }
  static hash(domain, types2, value) {
    return keccak256(TypedDataEncoder.encode(domain, types2, value));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(domain, types2, value, resolveName2) {
    return __awaiter$9(this, void 0, void 0, function* () {
      domain = shallowCopy$1(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString$3(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder.from(types2);
      encoder.visit(value, (type2, value2) => {
        if (type2 === "address" && !isHexString$3(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName2(name2);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder.visit(value, (type2, value2) => {
        if (type2 === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types2, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder = TypedDataEncoder.from(types2);
    const typesWithDomain = shallowCopy$1(types2);
    if (typesWithDomain.EIP712Domain) {
      logger$h.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types2);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type2, value2) => {
        if (type2.match(/^bytes(\d*)/)) {
          return hexlify(arrayify$1(value2));
        }
        if (type2.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type2) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger$h.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger$h.throwArgumentError("unsupported type", "type", type2);
      })
    };
  }
}
var hash$6 = {};
var utils$s = {};
var minimalisticAssert$1 = assert$b;
function assert$b(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$b.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
const index$O = /* @__PURE__ */ getDefaultExportFromCjs(minimalisticAssert$1);
const minimalisticAssert$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$O
}, [minimalisticAssert$1]);
const require$$1$R = /* @__PURE__ */ getAugmentedNamespace(minimalisticAssert$2);
var inherits_browser$3 = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser$3.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser$3.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser$3.exports;
const inherits_browser$1 = /* @__PURE__ */ getDefaultExportFromCjs(inherits_browserExports);
const inherits_browser$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: inherits_browser$1
}, [inherits_browserExports]);
const require$$1$Q = /* @__PURE__ */ getAugmentedNamespace(inherits_browser$2);
var assert$a = require$$1$R;
var inherits$6 = require$$1$Q;
var inherits_1 = utils$s.inherits = inherits$6;
function isSurrogatePair(msg, i3) {
  if ((msg.charCodeAt(i3) & 64512) !== 55296) {
    return false;
  }
  if (i3 < 0 || i3 + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i3 + 1) & 64512) === 56320;
}
function toArray$2(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p3 = 0;
      for (var i3 = 0; i3 < msg.length; i3++) {
        var c2 = msg.charCodeAt(i3);
        if (c2 < 128) {
          res[p3++] = c2;
        } else if (c2 < 2048) {
          res[p3++] = c2 >> 6 | 192;
          res[p3++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i3)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i3) & 1023);
          res[p3++] = c2 >> 18 | 240;
          res[p3++] = c2 >> 12 & 63 | 128;
          res[p3++] = c2 >> 6 & 63 | 128;
          res[p3++] = c2 & 63 | 128;
        } else {
          res[p3++] = c2 >> 12 | 224;
          res[p3++] = c2 >> 6 & 63 | 128;
          res[p3++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i3 = 0; i3 < msg.length; i3 += 2)
        res.push(parseInt(msg[i3] + msg[i3 + 1], 16));
    }
  } else {
    for (i3 = 0; i3 < msg.length; i3++)
      res[i3] = msg[i3] | 0;
  }
  return res;
}
var toArray_1 = utils$s.toArray = toArray$2;
function toHex(msg) {
  var res = "";
  for (var i3 = 0; i3 < msg.length; i3++)
    res += zero2(msg[i3].toString(16));
  return res;
}
var toHex_1 = utils$s.toHex = toHex;
function htonl(w3) {
  var res = w3 >>> 24 | w3 >>> 8 & 65280 | w3 << 8 & 16711680 | (w3 & 255) << 24;
  return res >>> 0;
}
var htonl_1 = utils$s.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i3 = 0; i3 < msg.length; i3++) {
    var w3 = msg[i3];
    if (endian === "little")
      w3 = htonl(w3);
    res += zero8(w3.toString(16));
  }
  return res;
}
var toHex32_1 = utils$s.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
var zero2_1 = utils$s.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
var zero8_1 = utils$s.zero8 = zero8;
function join32(msg, start, end2, endian) {
  var len2 = end2 - start;
  assert$a(len2 % 4 === 0);
  var res = new Array(len2 / 4);
  for (var i3 = 0, k3 = start; i3 < res.length; i3++, k3 += 4) {
    var w3;
    if (endian === "big")
      w3 = msg[k3] << 24 | msg[k3 + 1] << 16 | msg[k3 + 2] << 8 | msg[k3 + 3];
    else
      w3 = msg[k3 + 3] << 24 | msg[k3 + 2] << 16 | msg[k3 + 1] << 8 | msg[k3];
    res[i3] = w3 >>> 0;
  }
  return res;
}
var join32_1 = utils$s.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i3 = 0, k3 = 0; i3 < msg.length; i3++, k3 += 4) {
    var m2 = msg[i3];
    if (endian === "big") {
      res[k3] = m2 >>> 24;
      res[k3 + 1] = m2 >>> 16 & 255;
      res[k3 + 2] = m2 >>> 8 & 255;
      res[k3 + 3] = m2 & 255;
    } else {
      res[k3 + 3] = m2 >>> 24;
      res[k3 + 2] = m2 >>> 16 & 255;
      res[k3 + 1] = m2 >>> 8 & 255;
      res[k3] = m2 & 255;
    }
  }
  return res;
}
var split32_1 = utils$s.split32 = split32;
function rotr32$1(w3, b4) {
  return w3 >>> b4 | w3 << 32 - b4;
}
var rotr32_1 = utils$s.rotr32 = rotr32$1;
function rotl32$2(w3, b4) {
  return w3 << b4 | w3 >>> 32 - b4;
}
var rotl32_1 = utils$s.rotl32 = rotl32$2;
function sum32$3(a3, b4) {
  return a3 + b4 >>> 0;
}
var sum32_1 = utils$s.sum32 = sum32$3;
function sum32_3$1(a3, b4, c2) {
  return a3 + b4 + c2 >>> 0;
}
var sum32_3_1 = utils$s.sum32_3 = sum32_3$1;
function sum32_4$2(a3, b4, c2, d3) {
  return a3 + b4 + c2 + d3 >>> 0;
}
var sum32_4_1 = utils$s.sum32_4 = sum32_4$2;
function sum32_5$2(a3, b4, c2, d3, e2) {
  return a3 + b4 + c2 + d3 + e2 >>> 0;
}
var sum32_5_1 = utils$s.sum32_5 = sum32_5$2;
function sum64$1(buf2, pos, ah2, al2) {
  var bh2 = buf2[pos];
  var bl2 = buf2[pos + 1];
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  buf2[pos] = hi2 >>> 0;
  buf2[pos + 1] = lo;
}
var sum64_1 = utils$s.sum64 = sum64$1;
function sum64_hi$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  return hi2 >>> 0;
}
var sum64_hi_1 = utils$s.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2;
  return lo >>> 0;
}
var sum64_lo_1 = utils$s.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + carry;
  return hi2 >>> 0;
}
var sum64_4_hi_1 = utils$s.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var lo = al2 + bl2 + cl2 + dl2;
  return lo >>> 0;
}
var sum64_4_lo_1 = utils$s.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  lo = lo + el2 >>> 0;
  carry += lo < el2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + eh2 + carry;
  return hi2 >>> 0;
}
var sum64_5_hi_1 = utils$s.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var lo = al2 + bl2 + cl2 + dl2 + el2;
  return lo >>> 0;
}
var sum64_5_lo_1 = utils$s.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah2, al2, num) {
  var r2 = al2 << 32 - num | ah2 >>> num;
  return r2 >>> 0;
}
var rotr64_hi_1 = utils$s.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
var rotr64_lo_1 = utils$s.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah2, al2, num) {
  return ah2 >>> num;
}
var shr64_hi_1 = utils$s.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
var shr64_lo_1 = utils$s.shr64_lo = shr64_lo$1;
const utils$r = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$s,
  htonl: htonl_1,
  inherits: inherits_1,
  join32: join32_1,
  rotl32: rotl32_1,
  rotr32: rotr32_1,
  rotr64_hi: rotr64_hi_1,
  rotr64_lo: rotr64_lo_1,
  shr64_hi: shr64_hi_1,
  shr64_lo: shr64_lo_1,
  split32: split32_1,
  sum32: sum32_1,
  sum32_3: sum32_3_1,
  sum32_4: sum32_4_1,
  sum32_5: sum32_5_1,
  sum64: sum64_1,
  sum64_4_hi: sum64_4_hi_1,
  sum64_4_lo: sum64_4_lo_1,
  sum64_5_hi: sum64_5_hi_1,
  sum64_5_lo: sum64_5_lo_1,
  sum64_hi: sum64_hi_1,
  sum64_lo: sum64_lo_1,
  toArray: toArray_1,
  toHex: toHex_1,
  toHex32: toHex32_1,
  zero2: zero2_1,
  zero8: zero8_1
}, [utils$s]);
const require$$0$1u = /* @__PURE__ */ getAugmentedNamespace(utils$r);
var common$a = {};
var utils$q = require$$0$1u;
var assert$9 = require$$1$R;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
var BlockHash_1 = common$a.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$q.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$q.join32(msg, 0, msg.length - r2, this.endian);
    for (var i3 = 0; i3 < msg.length; i3 += this._delta32)
      this._update(msg, i3, i3 + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$9(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len2 = this.pendingTotal;
  var bytes2 = this._delta8;
  var k3 = bytes2 - (len2 + this.padLength) % bytes2;
  var res = new Array(k3 + this.padLength);
  res[0] = 128;
  for (var i3 = 1; i3 < k3; i3++)
    res[i3] = 0;
  len2 <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = len2 >>> 24 & 255;
    res[i3++] = len2 >>> 16 & 255;
    res[i3++] = len2 >>> 8 & 255;
    res[i3++] = len2 & 255;
  } else {
    res[i3++] = len2 & 255;
    res[i3++] = len2 >>> 8 & 255;
    res[i3++] = len2 >>> 16 & 255;
    res[i3++] = len2 >>> 24 & 255;
    res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i3++] = 0;
  }
  return res;
};
const common$9 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  BlockHash: BlockHash_1,
  default: common$a
}, [common$a]);
const require$$1$P = /* @__PURE__ */ getAugmentedNamespace(common$9);
var sha$5 = {};
var common$8 = {};
var utils$p = require$$0$1u;
var rotr32 = utils$p.rotr32;
function ft_1$1(s3, x2, y3, z2) {
  if (s3 === 0)
    return ch32$1(x2, y3, z2);
  if (s3 === 1 || s3 === 3)
    return p32(x2, y3, z2);
  if (s3 === 2)
    return maj32$1(x2, y3, z2);
}
var ft_1_1 = common$8.ft_1 = ft_1$1;
function ch32$1(x2, y3, z2) {
  return x2 & y3 ^ ~x2 & z2;
}
var ch32_1 = common$8.ch32 = ch32$1;
function maj32$1(x2, y3, z2) {
  return x2 & y3 ^ x2 & z2 ^ y3 & z2;
}
var maj32_1 = common$8.maj32 = maj32$1;
function p32(x2, y3, z2) {
  return x2 ^ y3 ^ z2;
}
var p32_1 = common$8.p32 = p32;
function s0_256$1(x2) {
  return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
}
var s0_256_1 = common$8.s0_256 = s0_256$1;
function s1_256$1(x2) {
  return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
}
var s1_256_1 = common$8.s1_256 = s1_256$1;
function g0_256$1(x2) {
  return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
}
var g0_256_1 = common$8.g0_256 = g0_256$1;
function g1_256$1(x2) {
  return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
}
var g1_256_1 = common$8.g1_256 = g1_256$1;
const common$7 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  ch32: ch32_1,
  default: common$8,
  ft_1: ft_1_1,
  g0_256: g0_256_1,
  g1_256: g1_256_1,
  maj32: maj32_1,
  p32: p32_1,
  s0_256: s0_256_1,
  s1_256: s1_256_1
}, [common$8]);
const require$$2$x = /* @__PURE__ */ getAugmentedNamespace(common$7);
var utils$o = require$$0$1u;
var common$6 = require$$1$P;
var shaCommon$1 = require$$2$x;
var rotl32$1 = utils$o.rotl32;
var sum32$2 = utils$o.sum32;
var sum32_5$1 = utils$o.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$6.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$o.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W2 = this.W;
  for (var i3 = 0; i3 < 16; i3++)
    W2[i3] = msg[start + i3];
  for (; i3 < W2.length; i3++)
    W2[i3] = rotl32$1(W2[i3 - 3] ^ W2[i3 - 8] ^ W2[i3 - 14] ^ W2[i3 - 16], 1);
  var a3 = this.h[0];
  var b4 = this.h[1];
  var c2 = this.h[2];
  var d3 = this.h[3];
  var e2 = this.h[4];
  for (i3 = 0; i3 < W2.length; i3++) {
    var s3 = ~~(i3 / 20);
    var t2 = sum32_5$1(rotl32$1(a3, 5), ft_1(s3, b4, c2, d3), e2, W2[i3], sha1_K[s3]);
    e2 = d3;
    d3 = c2;
    c2 = rotl32$1(b4, 30);
    b4 = a3;
    a3 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a3);
  this.h[1] = sum32$2(this.h[1], b4);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d3);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$o.toHex32(this.h, "big");
  else
    return utils$o.split32(this.h, "big");
};
const _1$1 = /* @__PURE__ */ getDefaultExportFromCjs(_1);
const _1$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _1$1
}, [_1]);
const require$$0$1t = /* @__PURE__ */ getAugmentedNamespace(_1$2);
var utils$n = require$$0$1u;
var common$5 = require$$1$P;
var shaCommon = require$$2$x;
var assert$8 = require$$1$R;
var sum32$1 = utils$n.sum32;
var sum32_4$1 = utils$n.sum32_4;
var sum32_5 = utils$n.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$5.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$n.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i3 = 0; i3 < 16; i3++)
    W2[i3] = msg[start + i3];
  for (; i3 < W2.length; i3++)
    W2[i3] = sum32_4$1(g1_256(W2[i3 - 2]), W2[i3 - 7], g0_256(W2[i3 - 15]), W2[i3 - 16]);
  var a3 = this.h[0];
  var b4 = this.h[1];
  var c2 = this.h[2];
  var d3 = this.h[3];
  var e2 = this.h[4];
  var f4 = this.h[5];
  var g3 = this.h[6];
  var h5 = this.h[7];
  assert$8(this.k.length === W2.length);
  for (i3 = 0; i3 < W2.length; i3++) {
    var T1 = sum32_5(h5, s1_256(e2), ch32(e2, f4, g3), this.k[i3], W2[i3]);
    var T2 = sum32$1(s0_256(a3), maj32(a3, b4, c2));
    h5 = g3;
    g3 = f4;
    f4 = e2;
    e2 = sum32$1(d3, T1);
    d3 = c2;
    c2 = b4;
    b4 = a3;
    a3 = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a3);
  this.h[1] = sum32$1(this.h[1], b4);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d3);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f4);
  this.h[6] = sum32$1(this.h[6], g3);
  this.h[7] = sum32$1(this.h[7], h5);
};
SHA256$1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$n.toHex32(this.h, "big");
  else
    return utils$n.split32(this.h, "big");
};
const _256$1 = /* @__PURE__ */ getDefaultExportFromCjs(_256);
const _256$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _256$1
}, [_256]);
const require$$2$w = /* @__PURE__ */ getAugmentedNamespace(_256$2);
var utils$m = require$$0$1u;
var SHA256 = require$$2$w;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$m.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$m.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$m.split32(this.h.slice(0, 7), "big");
};
const _224$1 = /* @__PURE__ */ getDefaultExportFromCjs(_224);
const _224$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _224$1
}, [_224]);
const require$$1$O = /* @__PURE__ */ getAugmentedNamespace(_224$2);
var utils$l = require$$0$1u;
var common$4 = require$$1$P;
var assert$7 = require$$1$R;
var rotr64_hi = utils$l.rotr64_hi;
var rotr64_lo = utils$l.rotr64_lo;
var shr64_hi = utils$l.shr64_hi;
var shr64_lo = utils$l.shr64_lo;
var sum64 = utils$l.sum64;
var sum64_hi = utils$l.sum64_hi;
var sum64_lo = utils$l.sum64_lo;
var sum64_4_hi = utils$l.sum64_4_hi;
var sum64_4_lo = utils$l.sum64_4_lo;
var sum64_5_hi = utils$l.sum64_5_hi;
var sum64_5_lo = utils$l.sum64_5_lo;
var BlockHash$1 = common$4.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$2() {
  if (!(this instanceof SHA512$2))
    return new SHA512$2();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$l.inherits(SHA512$2, BlockHash$1);
var _512 = SHA512$2;
SHA512$2.blockSize = 1024;
SHA512$2.outSize = 512;
SHA512$2.hmacStrength = 192;
SHA512$2.padLength = 128;
SHA512$2.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i3 = 0; i3 < 32; i3++)
    W2[i3] = msg[start + i3];
  for (; i3 < W2.length; i3 += 2) {
    var c0_hi = g1_512_hi(W2[i3 - 4], W2[i3 - 3]);
    var c0_lo = g1_512_lo(W2[i3 - 4], W2[i3 - 3]);
    var c1_hi = W2[i3 - 14];
    var c1_lo = W2[i3 - 13];
    var c2_hi = g0_512_hi(W2[i3 - 30], W2[i3 - 29]);
    var c2_lo = g0_512_lo(W2[i3 - 30], W2[i3 - 29]);
    var c3_hi = W2[i3 - 32];
    var c3_lo = W2[i3 - 31];
    W2[i3] = sum64_4_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
    W2[i3 + 1] = sum64_4_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
  }
};
SHA512$2.prototype._update = function _update3(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah2 = this.h[0];
  var al2 = this.h[1];
  var bh2 = this.h[2];
  var bl2 = this.h[3];
  var ch2 = this.h[4];
  var cl2 = this.h[5];
  var dh2 = this.h[6];
  var dl2 = this.h[7];
  var eh2 = this.h[8];
  var el2 = this.h[9];
  var fh2 = this.h[10];
  var fl2 = this.h[11];
  var gh2 = this.h[12];
  var gl2 = this.h[13];
  var hh2 = this.h[14];
  var hl2 = this.h[15];
  assert$7(this.k.length === W2.length);
  for (var i3 = 0; i3 < W2.length; i3 += 2) {
    var c0_hi = hh2;
    var c0_lo = hl2;
    var c1_hi = s1_512_hi(eh2, el2);
    var c1_lo = s1_512_lo(eh2, el2);
    var c2_hi = ch64_hi(eh2, el2, fh2, fl2, gh2);
    var c2_lo = ch64_lo(eh2, el2, fh2, fl2, gh2, gl2);
    var c3_hi = this.k[i3];
    var c3_lo = this.k[i3 + 1];
    var c4_hi = W2[i3];
    var c4_lo = W2[i3 + 1];
    var T1_hi = sum64_5_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    var T1_lo = sum64_5_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    c0_hi = s0_512_hi(ah2, al2);
    c0_lo = s0_512_lo(ah2, al2);
    c1_hi = maj64_hi(ah2, al2, bh2, bl2, ch2);
    c1_lo = maj64_lo(ah2, al2, bh2, bl2, ch2, cl2);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh2 = gh2;
    hl2 = gl2;
    gh2 = fh2;
    gl2 = fl2;
    fh2 = eh2;
    fl2 = el2;
    eh2 = sum64_hi(dh2, dl2, T1_hi, T1_lo);
    el2 = sum64_lo(dl2, dl2, T1_hi, T1_lo);
    dh2 = ch2;
    dl2 = cl2;
    ch2 = bh2;
    cl2 = bl2;
    bh2 = ah2;
    bl2 = al2;
    ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al2 = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah2, al2);
  sum64(this.h, 2, bh2, bl2);
  sum64(this.h, 4, ch2, cl2);
  sum64(this.h, 6, dh2, dl2);
  sum64(this.h, 8, eh2, el2);
  sum64(this.h, 10, fh2, fl2);
  sum64(this.h, 12, gh2, gl2);
  sum64(this.h, 14, hh2, hl2);
};
SHA512$2.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$l.toHex32(this.h, "big");
  else
    return utils$l.split32(this.h, "big");
};
function ch64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ ~xh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ ~xl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ xh2 & zh2 ^ yh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ xl & zl ^ yl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 28);
  var c1_hi = rotr64_hi(xl, xh2, 2);
  var c2_hi = rotr64_hi(xl, xh2, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 28);
  var c1_lo = rotr64_lo(xl, xh2, 2);
  var c2_lo = rotr64_lo(xl, xh2, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 14);
  var c1_hi = rotr64_hi(xh2, xl, 18);
  var c2_hi = rotr64_hi(xl, xh2, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 14);
  var c1_lo = rotr64_lo(xh2, xl, 18);
  var c2_lo = rotr64_lo(xl, xh2, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 1);
  var c1_hi = rotr64_hi(xh2, xl, 8);
  var c2_hi = shr64_hi(xh2, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 1);
  var c1_lo = rotr64_lo(xh2, xl, 8);
  var c2_lo = shr64_lo(xh2, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 19);
  var c1_hi = rotr64_hi(xl, xh2, 29);
  var c2_hi = shr64_hi(xh2, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 19);
  var c1_lo = rotr64_lo(xl, xh2, 29);
  var c2_lo = shr64_lo(xh2, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
const _512$1 = /* @__PURE__ */ getDefaultExportFromCjs(_512);
const _512$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _512$1
}, [_512]);
const require$$4$h = /* @__PURE__ */ getAugmentedNamespace(_512$2);
var utils$k = require$$0$1u;
var SHA512$1 = require$$4$h;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512$1.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$k.inherits(SHA384, SHA512$1);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$k.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$k.split32(this.h.slice(0, 12), "big");
};
const _384$1 = /* @__PURE__ */ getDefaultExportFromCjs(_384);
const _384$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _384$1
}, [_384]);
const require$$3$m = /* @__PURE__ */ getAugmentedNamespace(_384$2);
var sha1$3 = sha$5.sha1 = require$$0$1t;
var sha224$3 = sha$5.sha224 = require$$1$O;
var sha256$6 = sha$5.sha256 = require$$2$w;
var sha384$3 = sha$5.sha384 = require$$3$m;
var sha512$6 = sha$5.sha512 = require$$4$h;
const sha$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sha$5,
  sha1: sha1$3,
  sha224: sha224$3,
  sha256: sha256$6,
  sha384: sha384$3,
  sha512: sha512$6
}, [sha$5]);
const require$$2$v = /* @__PURE__ */ getAugmentedNamespace(sha$4);
var ripemd$1 = {};
var utils$j = require$$0$1u;
var common$3 = require$$1$P;
var rotl32 = utils$j.rotl32;
var sum32 = utils$j.sum32;
var sum32_3 = utils$j.sum32_3;
var sum32_4 = utils$j.sum32_4;
var BlockHash = common$3.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$j.inherits(RIPEMD160, BlockHash);
var ripemd160 = ripemd$1.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start) {
  var A2 = this.h[0];
  var B2 = this.h[1];
  var C2 = this.h[2];
  var D2 = this.h[3];
  var E3 = this.h[4];
  var Ah2 = A2;
  var Bh2 = B2;
  var Ch2 = C2;
  var Dh2 = D2;
  var Eh2 = E3;
  for (var j2 = 0; j2 < 80; j2++) {
    var T2 = sum32(
      rotl32(
        sum32_4(A2, f$9(j2, B2, C2, D2), msg[r$a[j2] + start], K$7(j2)),
        s$7[j2]
      ),
      E3
    );
    A2 = E3;
    E3 = D2;
    D2 = rotl32(C2, 10);
    C2 = B2;
    B2 = T2;
    T2 = sum32(
      rotl32(
        sum32_4(Ah2, f$9(79 - j2, Bh2, Ch2, Dh2), msg[rh$1[j2] + start], Kh$1(j2)),
        sh$1[j2]
      ),
      Eh2
    );
    Ah2 = Eh2;
    Eh2 = Dh2;
    Dh2 = rotl32(Ch2, 10);
    Ch2 = Bh2;
    Bh2 = T2;
  }
  T2 = sum32_3(this.h[1], C2, Dh2);
  this.h[1] = sum32_3(this.h[2], D2, Eh2);
  this.h[2] = sum32_3(this.h[3], E3, Ah2);
  this.h[3] = sum32_3(this.h[4], A2, Bh2);
  this.h[4] = sum32_3(this.h[0], B2, Ch2);
  this.h[0] = T2;
};
RIPEMD160.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$j.toHex32(this.h, "little");
  else
    return utils$j.split32(this.h, "little");
};
function f$9(j2, x2, y3, z2) {
  if (j2 <= 15)
    return x2 ^ y3 ^ z2;
  else if (j2 <= 31)
    return x2 & y3 | ~x2 & z2;
  else if (j2 <= 47)
    return (x2 | ~y3) ^ z2;
  else if (j2 <= 63)
    return x2 & z2 | y3 & ~z2;
  else
    return x2 ^ (y3 | ~z2);
}
function K$7(j2) {
  if (j2 <= 15)
    return 0;
  else if (j2 <= 31)
    return 1518500249;
  else if (j2 <= 47)
    return 1859775393;
  else if (j2 <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh$1(j2) {
  if (j2 <= 15)
    return 1352829926;
  else if (j2 <= 31)
    return 1548603684;
  else if (j2 <= 47)
    return 1836072691;
  else if (j2 <= 63)
    return 2053994217;
  else
    return 0;
}
var r$a = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh$1 = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s$7 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh$1 = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
const ripemd = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ripemd$1,
  ripemd160
}, [ripemd$1]);
const require$$3$l = /* @__PURE__ */ getAugmentedNamespace(ripemd);
var utils$i = require$$0$1u;
var assert$6 = require$$1$R;
function Hmac(hash2, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash2, key2, enc);
  this.Hash = hash2;
  this.blockSize = hash2.blockSize / 8;
  this.outSize = hash2.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$i.toArray(key2, enc));
}
var hmac$3 = Hmac;
Hmac.prototype._init = function init(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$6(key2.length <= this.blockSize);
  for (var i3 = key2.length; i3 < this.blockSize; i3++)
    key2.push(0);
  for (i3 = 0; i3 < key2.length; i3++)
    key2[i3] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i3 = 0; i3 < key2.length; i3++)
    key2[i3] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
const hmac$4 = /* @__PURE__ */ getDefaultExportFromCjs(hmac$3);
const hmac$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: hmac$4
}, [hmac$3]);
const require$$4$g = /* @__PURE__ */ getAugmentedNamespace(hmac$5);
(function(exports2) {
  var hash2 = exports2;
  hash2.utils = require$$0$1u;
  hash2.common = require$$1$P;
  hash2.sha = require$$2$v;
  hash2.ripemd = require$$3$l;
  hash2.hmac = require$$4$g;
  hash2.sha1 = hash2.sha.sha1;
  hash2.sha256 = hash2.sha.sha256;
  hash2.sha224 = hash2.sha.sha224;
  hash2.sha384 = hash2.sha.sha384;
  hash2.sha512 = hash2.sha.sha512;
  hash2.ripemd160 = hash2.ripemd.ripemd160;
})(hash$6);
const hash$5 = /* @__PURE__ */ getDefaultExportFromCjs(hash$6);
function sha256$5(data2) {
  return "0x" + hash$5.sha256().update(arrayify$1(data2)).digest("hex");
}
const version$e = "web/5.7.1";
var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter$8(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request.mode = opts.mode;
      }
      if (opts.cache) {
        request.cache = opts.cache;
      }
      if (opts.credentials) {
        request.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify$1(new Uint8Array(body))
    };
  });
}
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$g = new Logger$1(version$e);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type2) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type2 && (type2.split("/")[0] === "text" || type2.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
    }
    return hexlify(value);
  }
  return value;
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all2, code2) => {
    return String.fromCharCode(parseInt(code2, 16));
  }));
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger$g.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger$g.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout2 = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger$g.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout2 = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger$g.throwError("basic authentication requires a secure https url", Logger$1.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode$h(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy$1(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] || "text/plain" },
        body: dataMatch[2] ? decode$l(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger$g.throwError("processing response error", Logger$1.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout2) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger$g.makeError("timeout", Logger$1.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout: timeout2,
            url
          }));
        }, timeout2);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter$7(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location2 = response.headers.location || "";
              if (options.method === "GET" && location2.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall2 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall2 = parseInt(retryAfter) * 1e3;
                } else {
                  stall2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall2);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger$g.throwError("missing response", Logger$1.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger$g.throwError("bad response", Logger$1.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout3);
                continue;
              }
            }
            runningTimeout.cancel();
            logger$g.throwError("processing response error", Logger$1.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger$g.throwError("failed response", Logger$1.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json2, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger$g.throwError("invalid JSON", Logger$1.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json2 != null) {
    body = toUtf8Bytes(json2);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy$1(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k3) => k3.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy$1(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func2, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy$1(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done2 = false;
    const cancel = () => {
      if (done2) {
        return false;
      }
      done2 = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check2() {
      return func2().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check2);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check2);
        } else if (!done2) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout2 = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout2 < options.floor) {
            timeout2 = options.floor;
          }
          if (timeout2 > options.ceiling) {
            timeout2 = options.ceiling;
          }
          setTimeout(check2, timeout2);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check2();
  });
}
var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var ALPHABET_MAP = {};
for (var z$7 = 0; z$7 < ALPHABET.length; z$7++) {
  var x$4 = ALPHABET.charAt(z$7);
  if (ALPHABET_MAP[x$4] !== void 0)
    throw new TypeError(x$4 + " is ambiguous");
  ALPHABET_MAP[x$4] = z$7;
}
function polymodStep(pre) {
  var b4 = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b4 >> 0 & 1) & 996825010 ^ -(b4 >> 1 & 1) & 642813549 ^ -(b4 >> 2 & 1) & 513874426 ^ -(b4 >> 3 & 1) & 1027748829 ^ -(b4 >> 4 & 1) & 705979059;
}
function prefixChk(prefix) {
  var chk = 1;
  for (var i3 = 0; i3 < prefix.length; ++i3) {
    var c2 = prefix.charCodeAt(i3);
    if (c2 < 33 || c2 > 126)
      return "Invalid prefix (" + prefix + ")";
    chk = polymodStep(chk) ^ c2 >> 5;
  }
  chk = polymodStep(chk);
  for (i3 = 0; i3 < prefix.length; ++i3) {
    var v4 = prefix.charCodeAt(i3);
    chk = polymodStep(chk) ^ v4 & 31;
  }
  return chk;
}
function encode$f(prefix, words, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix.length + 7 + words.length > LIMIT)
    throw new TypeError("Exceeds length limit");
  prefix = prefix.toLowerCase();
  var chk = prefixChk(prefix);
  if (typeof chk === "string")
    throw new Error(chk);
  var result = prefix + "1";
  for (var i3 = 0; i3 < words.length; ++i3) {
    var x2 = words[i3];
    if (x2 >> 5 !== 0)
      throw new Error("Non 5-bit word");
    chk = polymodStep(chk) ^ x2;
    result += ALPHABET.charAt(x2);
  }
  for (i3 = 0; i3 < 6; ++i3) {
    chk = polymodStep(chk);
  }
  chk ^= 1;
  for (i3 = 0; i3 < 6; ++i3) {
    var v4 = chk >> (5 - i3) * 5 & 31;
    result += ALPHABET.charAt(v4);
  }
  return result;
}
function __decode(str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8)
    return str + " too short";
  if (str.length > LIMIT)
    return "Exceeds length limit";
  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered)
    return "Mixed-case string " + str;
  str = lowered;
  var split = str.lastIndexOf("1");
  if (split === -1)
    return "No separator character for " + str;
  if (split === 0)
    return "Missing prefix for " + str;
  var prefix = str.slice(0, split);
  var wordChars = str.slice(split + 1);
  if (wordChars.length < 6)
    return "Data too short";
  var chk = prefixChk(prefix);
  if (typeof chk === "string")
    return chk;
  var words = [];
  for (var i3 = 0; i3 < wordChars.length; ++i3) {
    var c2 = wordChars.charAt(i3);
    var v4 = ALPHABET_MAP[c2];
    if (v4 === void 0)
      return "Unknown character " + c2;
    chk = polymodStep(chk) ^ v4;
    if (i3 + 6 >= wordChars.length)
      continue;
    words.push(v4);
  }
  if (chk !== 1)
    return "Invalid checksum for " + str;
  return { prefix, words };
}
function decodeUnsafe() {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
}
function decode$j(str) {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
  throw new Error(res);
}
function convert$1(data2, inBits, outBits, pad2) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i3 = 0; i3 < data2.length; ++i3) {
    value = value << inBits | data2[i3];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad2) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWordsUnsafe(bytes2) {
  var res = convert$1(bytes2, 8, 5, true);
  if (Array.isArray(res))
    return res;
}
function toWords(bytes2) {
  var res = convert$1(bytes2, 8, 5, true);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function fromWordsUnsafe(words) {
  var res = convert$1(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words) {
  var res = convert$1(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
var bech32 = {
  decodeUnsafe,
  decode: decode$j,
  encode: encode$f,
  toWordsUnsafe,
  toWords,
  fromWordsUnsafe,
  fromWords
};
const bech32$1 = /* @__PURE__ */ getDefaultExportFromCjs(bech32);
const version$d = "providers/5.7.2";
function createCommonjsModule(fn2, basedir, module2) {
  return module2 = {
    path: basedir,
    exports: {},
    require: function(path, base3) {
      return commonjsRequire$1(path, base3 === void 0 || base3 === null ? module2.path : base3);
    }
  }, fn2(module2, module2.exports), module2.exports;
}
function commonjsRequire$1() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert$5;
function assert$5(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$5.equal = function assertEqual2(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_1$2 = createCommonjsModule(function(module2, exports2) {
  var utils2 = exports2;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i3 = 0; i3 < msg.length; i3++)
        res[i3] = msg[i3] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i3 = 0; i3 < msg.length; i3 += 2)
        res.push(parseInt(msg[i3] + msg[i3 + 1], 16));
    } else {
      for (var i3 = 0; i3 < msg.length; i3++) {
        var c2 = msg.charCodeAt(i3);
        var hi2 = c2 >> 8;
        var lo = c2 & 255;
        if (hi2)
          res.push(hi2, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex2(msg) {
    var res = "";
    for (var i3 = 0; i3 < msg.length; i3++)
      res += zero22(msg[i3].toString(16));
    return res;
  }
  utils2.toHex = toHex2;
  utils2.encode = function encode5(arr2, enc) {
    if (enc === "hex")
      return toHex2(arr2);
    else
      return arr2;
  };
});
var utils_1$1$1 = createCommonjsModule(function(module2, exports2) {
  var utils2 = exports2;
  utils2.assert = minimalisticAssert;
  utils2.toArray = utils_1$2.toArray;
  utils2.zero2 = utils_1$2.zero2;
  utils2.toHex = utils_1$2.toHex;
  utils2.encode = utils_1$2.encode;
  function getNAF2(num, w3, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws2 = 1 << w3 + 1;
    var k3 = num.clone();
    for (var i3 = 0; i3 < naf.length; i3++) {
      var z2;
      var mod2 = k3.andln(ws2 - 1);
      if (k3.isOdd()) {
        if (mod2 > (ws2 >> 1) - 1)
          z2 = (ws2 >> 1) - mod2;
        else
          z2 = mod2;
        k3.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i3] = z2;
      k3.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k22) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k22 = k22.clone();
    var d1 = 0;
    var d22 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k22.andln(3) + d22 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u22;
      if ((m24 & 1) === 0) {
        u22 = 0;
      } else {
        m8 = k22.andln(7) + d22 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u22 = -m24;
        else
          u22 = m24;
      }
      jsf[1].push(u22);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d22 === u22 + 1)
        d22 = 1 - d22;
      k1.iushrn(1);
      k22.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty;
  function parseBytes(bytes2) {
    return typeof bytes2 === "string" ? utils2.toArray(bytes2, "hex") : bytes2;
  }
  utils2.parseBytes = parseBytes;
  function intFromLE(bytes2) {
    return new BN$3(bytes2, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
});
var getNAF = utils_1$1$1.getNAF;
var getJSF = utils_1$1$1.getJSF;
var assert$1$1 = utils_1$1$1.assert;
function BaseCurve(type2, conf) {
  this.type = type2;
  this.p = new BN$3(conf.p, 16);
  this.red = conf.prime ? BN$3.red(conf.prime) : BN$3.mont(this.p);
  this.zero = new BN$3(0).toRed(this.red);
  this.one = new BN$3(1).toRed(this.red);
  this.two = new BN$3(2).toRed(this.red);
  this.n = conf.n && new BN$3(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate2() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p3, k3) {
  assert$1$1(p3.precomputed);
  var doubles = p3._getDoubles();
  var naf = getNAF(k3, 1, this._bitLength);
  var I3 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I3 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a3 = this.jpoint(null, null, null);
  var b4 = this.jpoint(null, null, null);
  for (var i3 = I3; i3 > 0; i3--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i3)
        b4 = b4.mixedAdd(doubles.points[j2]);
      else if (nafW === -i3)
        b4 = b4.mixedAdd(doubles.points[j2].neg());
    }
    a3 = a3.add(b4);
  }
  return a3.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p3, k3) {
  var w3 = 4;
  var nafPoints = p3._getNAFPoints(w3);
  w3 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k3, w3, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i3 = naf.length - 1; i3 >= 0; i3--) {
    for (var l2 = 0; i3 >= 0 && naf[i3] === 0; i3--)
      l2++;
    if (i3 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i3 < 0)
      break;
    var z2 = naf[i3];
    assert$1$1(z2 !== 0);
    if (p3.type === "affine") {
      if (z2 > 0)
        acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
    } else {
      if (z2 > 0)
        acc = acc.add(wnd[z2 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z2 - 1 >> 1].neg());
    }
  }
  return p3.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i3;
  var j2;
  var p3;
  for (i3 = 0; i3 < len2; i3++) {
    p3 = points[i3];
    var nafPoints = p3._getNAFPoints(defW);
    wndWidth[i3] = nafPoints.wnd;
    wnd[i3] = nafPoints.points;
  }
  for (i3 = len2 - 1; i3 >= 1; i3 -= 2) {
    var a3 = i3 - 1;
    var b4 = i3;
    if (wndWidth[a3] !== 1 || wndWidth[b4] !== 1) {
      naf[a3] = getNAF(coeffs[a3], wndWidth[a3], this._bitLength);
      naf[b4] = getNAF(coeffs[b4], wndWidth[b4], this._bitLength);
      max2 = Math.max(naf[a3].length, max2);
      max2 = Math.max(naf[b4].length, max2);
      continue;
    }
    var comb = [
      points[a3],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b4]
      /* 7 */
    ];
    if (points[a3].y.cmp(points[b4].y) === 0) {
      comb[1] = points[a3].add(points[b4]);
      comb[2] = points[a3].toJ().mixedAdd(points[b4].neg());
    } else if (points[a3].y.cmp(points[b4].y.redNeg()) === 0) {
      comb[1] = points[a3].toJ().mixedAdd(points[b4]);
      comb[2] = points[a3].add(points[b4].neg());
    } else {
      comb[1] = points[a3].toJ().mixedAdd(points[b4]);
      comb[2] = points[a3].toJ().mixedAdd(points[b4].neg());
    }
    var index2 = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a3], coeffs[b4]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a3] = new Array(max2);
    naf[b4] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja2 = jsf[0][j2] | 0;
      var jb2 = jsf[1][j2] | 0;
      naf[a3][j2] = index2[(ja2 + 1) * 3 + (jb2 + 1)];
      naf[b4][j2] = 0;
      wnd[a3] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i3 = max2; i3 >= 0; i3--) {
    var k3 = 0;
    while (i3 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len2; j2++) {
        tmp[j2] = naf[j2][i3] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k3++;
      i3--;
    }
    if (i3 >= 0)
      k3++;
    acc = acc.dblp(k3);
    if (i3 < 0)
      break;
    for (j2 = 0; j2 < len2; j2++) {
      var z2 = tmp[j2];
      if (z2 === 0)
        continue;
      else if (z2 > 0)
        p3 = wnd[j2][z2 - 1 >> 1];
      else if (z2 < 0)
        p3 = wnd[j2][-z2 - 1 >> 1].neg();
      if (p3.type === "affine")
        acc = acc.mixedAdd(p3);
      else
        acc = acc.add(p3);
    }
  }
  for (i3 = 0; i3 < len2; i3++)
    wnd[i3] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type2) {
  this.curve = curve;
  this.type = type2;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq2() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate3() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
  bytes2 = utils_1$1$1.toArray(bytes2, enc);
  var len2 = this.p.byteLength();
  if ((bytes2[0] === 4 || bytes2[0] === 6 || bytes2[0] === 7) && bytes2.length - 1 === 2 * len2) {
    if (bytes2[0] === 6)
      assert$1$1(bytes2[bytes2.length - 1] % 2 === 0);
    else if (bytes2[0] === 7)
      assert$1$1(bytes2[bytes2.length - 1] % 2 === 1);
    var res = this.point(
      bytes2.slice(1, 1 + len2),
      bytes2.slice(1 + len2, 1 + 2 * len2)
    );
    return res;
  } else if ((bytes2[0] === 2 || bytes2[0] === 3) && bytes2.length - 1 === len2) {
    return this.pointFromX(bytes2.slice(1, 1 + len2), bytes2[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode2(compact3) {
  var len2 = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len2);
  if (compact3)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len2));
};
BasePoint.prototype.encode = function encode2(enc, compact3) {
  return utils_1$1$1.encode(this._encode(compact3), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k3) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k3.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i3 = 0; i3 < power; i3 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl3 = max2 === 1 ? null : this.dbl();
  for (var i3 = 1; i3 < max2; i3++)
    res[i3] = res[i3 - 1].add(dbl3);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k3) {
  var r2 = this;
  for (var i3 = 0; i3 < k3; i3++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = createCommonjsModule(function(module2) {
  if (typeof Object.create === "function") {
    module2.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2$1 = utils_1$1$1.assert;
function ShortCurve(conf) {
  base$1.call(this, "short", conf);
  this.a = new BN$3(conf.a, 16).toRed(this.red);
  this.b = new BN$3(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base$1);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$3(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$3(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2$1(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$3(vec.a, 16),
        b: new BN$3(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : BN$3.mont(num);
  var tinv = new BN$3(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s3 = new BN$3(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s3).fromRed();
  var l2 = ntinv.redSub(s3).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u3 = lambda;
  var v4 = this.n.clone();
  var x1 = new BN$3(1);
  var y1 = new BN$3(0);
  var x2 = new BN$3(0);
  var y22 = new BN$3(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a22;
  var b22;
  var prevR;
  var i3 = 0;
  var r2;
  var x3;
  while (u3.cmpn(0) !== 0) {
    var q2 = v4.div(u3);
    r2 = v4.sub(q2.mul(u3));
    x3 = x2.sub(q2.mul(x1));
    var y3 = y22.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i3 === 2) {
      break;
    }
    prevR = r2;
    v4 = u3;
    u3 = r2;
    x2 = x1;
    x1 = x3;
    y22 = y1;
    y1 = y3;
  }
  a22 = r2.neg();
  b22 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a22.sqr().add(b22.sqr());
  if (len2.cmp(len1) >= 0) {
    a22 = a0;
    b22 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a22.negative) {
    a22 = a22.neg();
    b22 = b22.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a22, b: b22 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k3) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v22 = basis[1];
  var c1 = v22.b.mul(k3).divRound(this.n);
  var c2 = v1.b.neg().mul(k3).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p22 = c2.mul(v22.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v22.b);
  var k1 = k3.sub(p1).sub(p22);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x2, odd) {
  x2 = new BN$3(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y22 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y3 = y22.redSqrt();
  if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
};
ShortCurve.prototype.validate = function validate4(point3) {
  if (point3.inf)
    return true;
  var x2 = point3.x;
  var y3 = point3.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y3.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i3 = 0; i3 < points.length; i3++) {
    var split = this._endoSplit(coeffs[i3]);
    var p3 = points[i3];
    var beta = p3._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p3 = p3.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i3 * 2] = p3;
    npoints[i3 * 2 + 1] = beta;
    ncoeffs[i3 * 2] = split.k1;
    ncoeffs[i3 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i3 * 2, jacobianResult);
  for (var j2 = 0; j2 < i3 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point(curve, x2, y3, isRed) {
  base$1.BasePoint.call(this, curve, "affine");
  if (x2 === null && y3 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$3(x2, 16);
    this.y = new BN$3(y3, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base$1.BasePoint);
ShortCurve.prototype.point = function point2(x2, y3, isRed) {
  return new Point(this, x2, y3, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p3) {
      return curve.point(p3.x.redMul(curve.endo.beta), p3.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p3) {
  if (this.inf)
    return p3;
  if (p3.inf)
    return this;
  if (this.eq(p3))
    return this.dbl();
  if (this.neg().eq(p3))
    return this.curve.point(null, null);
  if (this.x.cmp(p3.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p3.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p3.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p3.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a3 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a3).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul2(k3) {
  k3 = new BN$3(k3, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k3))
    return this.curve._fixedNafMul(this, k3);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k3]);
  else
    return this.curve._wnafMul(this, k3);
};
Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
  var points = [this, p22];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
  var points = [this, p22];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq3(p3) {
  return this === p3 || this.inf === p3.inf && (this.inf || this.x.cmp(p3.x) === 0 && this.y.cmp(p3.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p3) {
      return p3.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x2, y3, z2) {
  base$1.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y3 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$3(0);
  } else {
    this.x = new BN$3(x2, 16);
    this.y = new BN$3(y3, 16);
    this.z = new BN$3(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base$1.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x2, y3, z2) {
  return new JPoint(this, x2, y3, z2);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p3) {
  if (this.isInfinity())
    return p3;
  if (p3.isInfinity())
    return this;
  var pz2 = p3.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u22 = p3.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p3.z));
  var s22 = p3.y.redMul(z2.redMul(this.z));
  var h5 = u1.redSub(u22);
  var r2 = s1.redSub(s22);
  if (h5.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h5.redSqr();
  var h32 = h22.redMul(h5);
  var v4 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h32).redISub(v4).redISub(v4);
  var ny = r2.redMul(v4.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(p3.z).redMul(h5);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p3) {
  if (this.isInfinity())
    return p3.toJ();
  if (p3.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u22 = p3.x.redMul(z2);
  var s1 = this.y;
  var s22 = p3.y.redMul(z2).redMul(this.z);
  var h5 = u1.redSub(u22);
  var r2 = s1.redSub(s22);
  if (h5.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h5.redSqr();
  var h32 = h22.redMul(h5);
  var v4 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h32).redISub(v4).redISub(v4);
  var ny = r2.redMul(v4.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(h5);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i3;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i3 = 0; i3 < pow; i3++)
      r2 = r2.dbl();
    return r2;
  }
  var a3 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i3 = 0; i3 < pow; i3++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a3.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i3 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s3 = s3.redIAdd(s3);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s3).redISub(s3);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s3.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a3 = this.x.redSqr();
    var b4 = this.y.redSqr();
    var c2 = b4.redSqr();
    var d3 = this.x.redAdd(b4).redSqr().redISub(a3).redISub(c2);
    d3 = d3.redIAdd(d3);
    var e2 = a3.redAdd(a3).redIAdd(a3);
    var f4 = e2.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f4.redISub(d3).redISub(d3);
    ny = e2.redMul(d3.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s3 = s3.redIAdd(s3);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s3).redISub(s3);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s3.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a3 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a3.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee2 = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u3 = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u3);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u3.redMul(t2.redISub(u3)).redISub(e2.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul3(k3, kbase) {
  k3 = new BN$3(k3, kbase);
  return this.curve._wnafMul(this, k3);
};
JPoint.prototype.eq = function eq4(p3) {
  if (p3.type === "affine")
    return this.eq(p3.toJ());
  if (this === p3)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p3.z.redSqr();
  if (this.x.redMul(pz2).redISub(p3.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p3.z);
  return this.y.redMul(pz3).redISub(p3.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x2) {
  var zs2 = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs2);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc2 = x2.clone();
  var t2 = this.curve.redN.redMul(zs2);
  for (; ; ) {
    xc2.iadd(this.curve.n);
    if (xc2.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect3() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module2, exports2) {
  var curve = exports2;
  curve.base = base$1;
  curve.short = short_1;
  curve.mont = /*RicMoo:ethers:require(./mont)*/
  null;
  curve.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
});
var curves_1 = createCommonjsModule(function(module2, exports2) {
  var curves = exports2;
  var assert2 = utils_1$1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$5.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$5.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$5.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$5.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$5.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$5.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$5.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$5.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1$2.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1$2.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1$2.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i3 = 0; i3 < this.V.length; i3++) {
    this.K[i3] = 0;
    this.V[i3] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac2() {
  return new hash$5.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add3;
    add3 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1$2.toArray(entropy, entropyEnc);
  add3 = utils_1$2.toArray(add3, addEnc);
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add3 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate2(len2, enc, add3, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add3;
    add3 = enc;
    enc = null;
  }
  if (add3) {
    add3 = utils_1$2.toArray(add3, addEnc || "hex");
    this._update(add3);
  }
  var temp = [];
  while (temp.length < len2) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len2);
  this._update(add3);
  this._reseed++;
  return utils_1$2.encode(res, enc);
};
var assert$3$1 = utils_1$1$1.assert;
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec2, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec2, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate5() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic(compact3, enc) {
  if (typeof compact3 === "string") {
    enc = compact3;
    compact3 = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact3);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN$3(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3$1(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3$1(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3$1(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair.prototype.inspect = function inspect4() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4$1 = utils_1$1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4$1(options.r && options.s, "Signature without r or s");
  this.r = new BN$3(options.r, 16);
  this.s = new BN$3(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf2, p3) {
  var initial = buf2[p3.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i3 = 0, off2 = p3.place; i3 < octetLen; i3++, off2++) {
    val <<= 8;
    val |= buf2[off2];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p3.place = off2;
  return val;
}
function rmPadding(buf2) {
  var i3 = 0;
  var len2 = buf2.length - 1;
  while (!buf2[i3] && !(buf2[i3 + 1] & 128) && i3 < len2) {
    i3++;
  }
  if (i3 === 0) {
    return buf2;
  }
  return buf2.slice(i3);
}
Signature.prototype._importDER = function _importDER(data2, enc) {
  data2 = utils_1$1$1.toArray(data2, enc);
  var p3 = new Position();
  if (data2[p3.place++] !== 48) {
    return false;
  }
  var len2 = getLength(data2, p3);
  if (len2 === false) {
    return false;
  }
  if (len2 + p3.place !== data2.length) {
    return false;
  }
  if (data2[p3.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data2, p3);
  if (rlen === false) {
    return false;
  }
  var r2 = data2.slice(p3.place, rlen + p3.place);
  p3.place += rlen;
  if (data2[p3.place++] !== 2) {
    return false;
  }
  var slen = getLength(data2, p3);
  if (slen === false) {
    return false;
  }
  if (data2.length !== slen + p3.place) {
    return false;
  }
  var s3 = data2.slice(p3.place, slen + p3.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s3[0] === 0) {
    if (s3[1] & 128) {
      s3 = s3.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$3(r2);
  this.s = new BN$3(s3);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr2, len2) {
  if (len2 < 128) {
    arr2.push(len2);
    return;
  }
  var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
  arr2.push(octets | 128);
  while (--octets) {
    arr2.push(len2 >>> (octets << 3) & 255);
  }
  arr2.push(len2);
}
Signature.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s3 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s3[0] & 128)
    s3 = [0].concat(s3);
  r2 = rmPadding(r2);
  s3 = rmPadding(s3);
  while (!s3[0] && !(s3[1] & 128)) {
    s3 = s3.slice(1);
  }
  var arr2 = [2];
  constructLength(arr2, r2.length);
  arr2 = arr2.concat(r2);
  arr2.push(2);
  constructLength(arr2, s3.length);
  var backHalf = arr2.concat(s3);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1$1.encode(res, enc);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
);
var assert$5$1 = utils_1$1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5$1(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec$1 = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes2 = this.n.byteLength();
  var ns2 = this.n.sub(new BN$3(2));
  for (; ; ) {
    var priv = new BN$3(drbg.generate(bytes2));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new BN$3(msg, 16));
  var bytes2 = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes2);
  var nonce = msg.toArray("be", bytes2);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$3(1));
  for (var iter = 0; ; iter++) {
    var k3 = options.k ? options.k(iter) : new BN$3(drbg.generate(this.n.byteLength()));
    k3 = this._truncateToN(k3, true);
    if (k3.cmpn(1) <= 0 || k3.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k3);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s3 = k3.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s3 = s3.umod(this.n);
    if (s3.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s3.cmp(this.nh) > 0) {
      s3 = this.n.sub(s3);
      recoveryParam ^= 1;
    }
    return new signature({ r: r2, s: s3, recoveryParam });
  }
};
EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
  msg = this._truncateToN(new BN$3(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$1 = new signature(signature$1, "hex");
  var r2 = signature$1.r;
  var s3 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s3.cmpn(1) < 0 || s3.cmp(this.n) >= 0)
    return false;
  var sinv = s3.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u22 = sinv.mul(r2).umod(this.n);
  var p3;
  if (!this.curve._maxwellTrick) {
    p3 = this.g.mulAdd(u1, key2.getPublic(), u22);
    if (p3.isInfinity())
      return false;
    return p3.getX().umod(this.n).cmp(r2) === 0;
  }
  p3 = this.g.jmulAdd(u1, key2.getPublic(), u22);
  if (p3.isInfinity())
    return false;
  return p3.eqXToP(r2);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j2, enc) {
  assert$5$1((3 & j2) === j2, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n4 = this.n;
  var e2 = new BN$3(msg);
  var r2 = signature$1.r;
  var s3 = signature$1.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n4);
  var s1 = n4.sub(e2).mul(rInv).umod(n4);
  var s22 = s3.mul(rInv).umod(n4);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e2, signature$1, Q3, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i3 = 0; i3 < 4; i3++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature$1, i3);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q3))
      return i3;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module2, exports2) {
  var elliptic = exports2;
  elliptic.version = /*RicMoo:ethers*/
  { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1$1;
  elliptic.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec$1;
  elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
});
var EC$1 = elliptic_1.ec;
const version$c = "signing-key/5.7.0";
const logger$f = new Logger$1(version$c);
let _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
class SigningKey {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger$f.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair2 = getCurve().keyFromPrivate(arrayify$1(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify$1(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify$1(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest9) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify$1(this.privateKey));
    const digestBytes = arrayify$1(digest9);
    if (digestBytes.length !== 32) {
      logger$f.throwArgumentError("bad digest length", "digest", digest9);
    }
    const signature2 = keyPair2.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify$1(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify$1(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
}
function recoverPublicKey(digest9, signature2) {
  const sig = splitSignature(signature2);
  const rs2 = { r: arrayify$1(sig.r), s: arrayify$1(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify$1(digest9), rs2, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes2 = arrayify$1(key2);
  if (bytes2.length === 32) {
    const signingKey = new SigningKey(bytes2);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes2).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes2.length === 33) {
    if (compressed) {
      return hexlify(bytes2);
    }
    return "0x" + getCurve().keyFromPublic(bytes2).getPublic(false, "hex");
  } else if (bytes2.length === 65) {
    if (!compressed) {
      return hexlify(bytes2);
    }
    return "0x" + getCurve().keyFromPublic(bytes2).getPublic(true, "hex");
  }
  return logger$f.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const version$b = "transactions/5.7.0";
const logger$e = new Logger$1(version$b);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero$1;
  }
  return BigNumber.from(value);
}
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest9, signature2) {
  return computeAddress(recoverPublicKey(arrayify$1(digest9), signature2));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger$e.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index2) => {
      if (hexDataLength(storageKey) !== 32) {
        logger$e.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index2}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set2, index2) => {
      if (Array.isArray(set2)) {
        if (set2.length > 2) {
          logger$e.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index2}]`, set2);
        }
        return accessSetify(set2[0], set2[1]);
      }
      return accessSetify(set2.address, set2.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a3, b4) => a3.address.localeCompare(b4.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set2) => [set2.address, set2.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger$e.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode$g(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode$g(fields)]);
}
function _parseEipSignature(tx, fields, serialize) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger$e.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest9 = keccak256(serialize(tx));
    tx.from = recoverAddress(digest9, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
  }
}
function _parseEip1559(payload) {
  const transaction = decode$k(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger$e.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode$k(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger$e.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode$k(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger$e.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw2 = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw2.push(hexlify(tx.chainId));
      raw2.push("0x");
      raw2.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest9 = keccak256(encode$g(raw2));
    try {
      tx.from = recoverAddress(digest9, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
    }
    tx.hash = keccak256(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse$d(rawTransaction) {
  const payload = arrayify$1(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
  }
  return logger$e.throwError(`unsupported transaction type: ${payload[0]}`, Logger$1.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
const logger$d = new Logger$1(version$d);
class Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats2 = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data2 = this.data.bind(this);
    const hash2 = this.hash.bind(this);
    const hex2 = this.hex.bind(this);
    const number2 = this.number.bind(this);
    const type2 = this.type.bind(this);
    const strictData = (v4) => {
      return this.data(v4, true);
    };
    formats2.transaction = {
      hash: hash2,
      type: type2,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash2, null),
      blockNumber: Formatter.allowNull(number2, null),
      transactionIndex: Formatter.allowNull(number2, null),
      confirmations: Formatter.allowNull(number2, null),
      from: address,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number2,
      data: data2,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number2),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data2)
    };
    formats2.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number2),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number2),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats2.receiptLog = {
      transactionIndex: number2,
      blockNumber: number2,
      transactionHash: hash2,
      address,
      topics: Formatter.arrayOf(hash2),
      data: data2,
      logIndex: number2,
      blockHash: hash2
    };
    formats2.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number2,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: Formatter.allowNull(hex2),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data2),
      blockHash: hash2,
      transactionHash: hash2,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number2,
      confirmations: Formatter.allowNull(number2, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number2),
      type: type2
    };
    formats2.block = {
      hash: Formatter.allowNull(hash2),
      parentHash: hash2,
      number: number2,
      timestamp: number2,
      nonce: Formatter.allowNull(hex2),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data2,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash2)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats2.blockWithTransactions = shallowCopy$1(formats2.block);
    formats2.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats2.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash2, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats2.filterLog = {
      blockNumber: Formatter.allowNull(number2),
      blockHash: Formatter.allowNull(hash2),
      transactionIndex: number2,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data2, "0x"),
      topics: Formatter.arrayOf(hash2),
      transactionHash: hash2,
      logIndex: number2
    };
    return formats2;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(number2) {
    if (number2 === "0x") {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  type(number2) {
    if (number2 === "0x" || number2 == null) {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  // Strict! Used on input.
  bigNumber(value) {
    return BigNumber.from(value);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString$3(value)) {
        return value.toLowerCase();
      }
    }
    return logger$d.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  // Requires an address
  // Strict! Used on input.
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString$3(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  // Strict! Used on input.
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString$3(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger$d.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v4 = BigNumber.from(value);
    try {
      return v4.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString$3(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString$3(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString$3(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse$d(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger$d.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger$d.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger$d.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v4) => this.topics(v4));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object2) {
    const result = {};
    for (const key2 in format) {
      try {
        const value = format[key2](object2[key2]);
        if (value !== void 0) {
          result[key2] = value;
        }
      } catch (error) {
        error.checkKey = key2;
        error.checkValue = object2[key2];
        throw error;
      }
    }
    return result;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  // Requires an Array satisfying check
  static arrayOf(format) {
    return function(array2) {
      if (!Array.isArray(array2)) {
        throw new Error("not an array");
      }
      const result = [];
      array2.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
}
let throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$c = new Logger$1(version$d);
const MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger$c.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data2) {
  if (data2 === "") {
    return [];
  }
  return data2.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag$1(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger$c.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
const PollableEvents = ["block", "network", "pending", "poll"];
let Event$1 = class Event2 {
  constructor(tag, listener, once3) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once3);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter2 = {};
    if (topics.length > 0) {
      filter2.topics = topics;
    }
    if (address && address !== "*") {
      filter2.address = address;
    }
    return filter2;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
const coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data2) {
  return Base58.encode(concat$6([data2, hexDataSlice(sha256$5(sha256$5(data2)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length2 = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length2);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger$c.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify$1(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes$1(datas) {
  const result = [];
  let byteCount = 0;
  for (let i3 = 0; i3 < datas.length; i3++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i3 = 0; i3 < datas.length; i3++) {
    const data2 = arrayify$1(datas[i3]);
    result[i3] = numPad(byteCount);
    result.push(numPad(data2.length));
    result.push(bytesPad(data2));
    byteCount += 32 + Math.ceil(data2.length / 32) * 32;
  }
  return hexConcat(result);
}
class Resolver {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(provider, address, name2, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name2);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === Logger$1.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes$1([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify$1(result).length % 32 === 4) {
          logger$c.throwError("resolver threw error", Logger$1.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === Logger$1.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger$c.throwError(`unsupported coin type: ${coinType}`, Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes2 = arrayify$1(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length2 = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat$6([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length2 = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat$6([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length2 = bytes2[1];
      let version2 = bytes2[0];
      if (version2 === 0) {
        if (length2 !== 20 && length2 !== 32) {
          version2 = -1;
        }
      } else {
        version2 = -1;
      }
      if (version2 >= 0 && bytes2.length === 2 + length2 && length2 >= 1 && length2 <= 75) {
        const words = bech32$1.toWords(bytes2.slice(2));
        words.unshift(version2);
        return bech32$1.encode(coinInfo.prefix, words);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === Logger$1.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger$c.throwError(`invalid or unsupported coin data`, Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i3 = 0; i3 < matchers.length; i3++) {
          const match = avatar.match(matchers[i3]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length2 = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length2 * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length2 = parseInt(ipns[3], 16);
        if (ipns[4].length === length2 * 2) {
          return "ipns://" + Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash2 = encode$h("0x" + skynet[1]).replace(/[=+\/]/g, (a3) => urlSafe[a3]);
          return "sia://" + hash2;
        }
      }
      return logger$c.throwError(`invalid or unsupported content hash data`, Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat$6([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat$6([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends Provider {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(network) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger$c.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger$c.throwError("no network detected", Logger$1.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger$1.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data2 = calldata.toLowerCase();
      const errorMessages = [];
      for (let i3 = 0; i3 < urls.length; i3++) {
        const url = urls[i3];
        const href = url.replace("{sender}", sender).replace("{data}", data2);
        const json2 = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: data2, sender });
        const result = yield fetchJson({ url: href, errorPassThrough: true }, json2, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger$c.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger$1.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger$c.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m2) => JSON.stringify(m2)).join(", ")}`, Logger$1.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(maxAge) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger$c.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger$c.makeError("network block skew detected", Logger$1.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i3 = this._emitted.block + 1; i3 <= blockNumber; i3++) {
          this.emit("block", i3);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash2 = event.hash;
            let runner = this.getTransactionReceipt(hash2).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash2] = receipt.blockNumber;
              this.emit(hash2, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter2 = event.filter;
              filter2.fromBlock = event._lastBlockNumber + 1;
              filter2.toBlock = blockNumber;
              const minFromBlock = filter2.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter2.fromBlock) {
                filter2.fromBlock = minFromBlock;
              }
              if (filter2.fromBlock < 0) {
                filter2.fromBlock = 0;
              }
              const runner = this.getLogs(filter2).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log3) => {
                  if (log3.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log3.blockNumber;
                  }
                  this._emitted["b:" + log3.blockHash] = log3.blockNumber;
                  this._emitted["t:" + log3.transactionHash] = log3.blockNumber;
                  this.emit(filter2, log3);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return __awaiter$6(this, void 0, void 0, function* () {
      return logger$c.throwError("provider does not support network detection", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger$c.makeError("underlying network changed", Logger$1.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now = getTime();
    if (now - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout2 || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout2, replaceable) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done2 = false;
        const alreadyDone = function() {
          if (done2) {
            return true;
          }
          done2 = true;
          cancelFuncs.forEach((func2) => {
            func2();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter$6(this, void 0, void 0, function* () {
            if (done2) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter$6(this, void 0, void 0, function* () {
              if (done2) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done2) {
                    return;
                  }
                  const block2 = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti2 = 0; ti2 < block2.transactions.length; ti2++) {
                    const tx = block2.transactions[ti2];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done2) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger$c.makeError("transaction was replaced", Logger$1.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done2) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done2) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done2) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout2 === "number" && timeout2 > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger$c.makeError("timeout exceeded", Logger$1.errors.TIMEOUT, { timeout: timeout2 }));
          }, timeout2);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$6(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$c.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$c.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger$c.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$c.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p3) => hexValue(p3))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$c.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(tx, hash2, startBlock) {
    if (hash2 != null && hexDataLength(hash2) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash2 != null && tx.hash !== hash2) {
      logger$c.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger$1.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash2 });
    }
    result.wait = (confirms, timeout2) => __awaiter$6(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout2 == null) {
        timeout2 = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout2, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger$c.throwError("transaction failed", Logger$1.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify(t2));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash2 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash2, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v4) => v4 ? this._getAddress(v4) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v4) => v4 ? BigNumber.from(v4) : null);
      });
      ["type"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v4) => v4 != null ? v4 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v4) => v4 ? hexlify(v4) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      filter2 = yield filter2;
      const result = {};
      if (filter2.address != null) {
        result.address = this._getAddress(filter2.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = filter2[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter2[key2]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger$c.throwError("CCIP read exceeded maximum redirections", Logger$1.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", { transaction, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data2 = hexDataSlice(result, 4);
          const sender = hexDataSlice(data2, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger$c.throwError("CCIP Read sender did not match", Logger$1.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data2, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data2, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data2, urlsOffset + 32);
          for (let u3 = 0; u3 < urlsLength; u3++) {
            const url = _parseString(urlsData, u3 * 32);
            if (url == null) {
              logger$c.throwError("CCIP Read contained corrupt URL string", Logger$1.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data2, 64);
          if (!BigNumber.from(hexDataSlice(data2, 100, 128)).isZero()) {
            logger$c.throwError("CCIP Read callback selector included junk", Logger$1.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data2, 96, 100);
          const extraData = _parseBytes(data2, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger$c.throwError("CCIP Read disabled or provided no URLs", Logger$1.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes$1([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === Logger$1.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger$c.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$c.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter$6(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger$c.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger$c.throwError("ENS name not configured", Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString$3(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString$3(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger$c.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const block2 = yield this.perform("getBlock", params);
        if (block2 == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i3 = 0; i3 < block2.transactions.length; i3++) {
            const tx = block2.transactions[i3];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block2);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block2);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter2) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log3) => {
        if (log3.removed == null) {
          log3.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger$c.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      let currentName = name2;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name2 !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name2);
          if (currentName !== name2 && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name2, operation) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger$c.throwError("network does not support ENS", Logger$1.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
      }
      try {
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + namehash(name2).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if (isHexString$3(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger$c.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter$6(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node2, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name2 = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash(node2).substring(2)
      }), 0);
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter$6(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString$3(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node2, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node2);
        try {
          const avatar2 = yield resolver.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error) {
          if (error.code !== Logger$1.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name2 = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash(node2).substring(2)
          }), 0);
          resolver = yield this.getResolver(name2);
        } catch (error) {
          if (error.code !== Logger$1.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger$c.throwError(method + " not implemented", Logger$1.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once3) {
    const event = new Event$1(getEventTag$1(eventName), listener, once3);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag$1(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag$1(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag$1(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag$1(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag$1(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
}
const version$a = "abstract-signer/5.7.0";
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$b = new Logger$1(version$a);
const allowedTransactionKeys$1 = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
const forwardErrors = [
  Logger$1.errors.INSUFFICIENT_FUNDS,
  Logger$1.errors.NONCE_EXPIRED,
  Logger$1.errors.REPLACEMENT_UNDERPRICED
];
class Signer {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    logger$b.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(transaction) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(transaction, blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(transaction) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(transaction) {
    for (const key2 in transaction) {
      if (allowedTransactionKeys$1.indexOf(key2) === -1) {
        logger$b.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
      }
    }
    const tx = shallowCopy$1(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger$b.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(transaction) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter$5(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger$b.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger$b.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger$b.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger$b.throwError("network does not support EIP-1559", Logger$1.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger$b.throwError("failed to get consistent fee data", Logger$1.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger$b.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger$1.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger$b.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(operation) {
    if (!this.provider) {
      logger$b.throwError("missing provider", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
}
class VoidSigner extends Signer {
  constructor(address, provider) {
    super();
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger$b.throwError(message, Logger$1.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types2, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
}
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$a = new Logger$1(version$d);
const errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data2 = isHexString$3(value.data) ? value.data : null;
    if (!requireData || data2) {
      return { message: value.message, data: data2 };
    }
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunk(value[key2], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {
    }
  }
  return null;
}
function checkError(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger$a.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger$1.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger$a.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger$1.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === Logger$1.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger$a.throwError("insufficient funds for intrinsic transaction cost", Logger$1.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger$a.throwError("nonce has already been used", Logger$1.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger$a.throwError("replacement fee too low", Logger$1.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger$a.throwError("legacy pre-eip-155 transactions not supported", Logger$1.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger$a.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger$1.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer$1(timeout2) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout2);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
const _constructorGuard$1 = {};
class JsonRpcSigner extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard$1) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger$a.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger$a.throwError("cannot alter JSON-RPC Signer connection", Logger$1.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard$1, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger$a.throwError("unknown account #" + this._index, Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy$1(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy$1(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter$4(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger$a.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger$a.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash2) => {
        return hash2;
      }, (error) => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$a.throwError("user rejected transaction", Logger$1.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger$a.throwError("signing transactions is unsupported", Logger$1.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash2 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter$4(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash2);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash2, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash2;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data2), address.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$a.throwError("user rejected signing", Logger$1.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data2)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$a.throwError("user rejected signing", Logger$1.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain, types2, value) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types2, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types2, populated.value))
        ]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$a.throwError("user rejected signing", Logger$1.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            messageData: { domain: populated.domain, types: types2, value: populated.value }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash2) => {
      return {
        hash: hash2,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash2, confirmations);
        }
      };
    });
  }
}
const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
let JsonRpcProvider$1 = class JsonRpcProvider2 extends BaseProvider {
  constructor(url, network) {
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy$1(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield timer$1(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger$a.throwError("could not detect network", Logger$1.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger$a.throwError("could not detect network", Logger$1.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard$1, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a3) => this.formatter.address(a3));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
    }
    return null;
  }
  perform(method, params) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy$1(params);
              params.transaction = shallowCopy$1(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger$a.throwError(method + " not implemented", Logger$1.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash2) {
            self2._emitted["t:" + hash2.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash2).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer$1(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy$1(allowedTransactionKeys);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction[key2]));
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction[key2]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
};
let WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger2 = new Logger$1(version$d);
  WS = function() {
    logger2.throwError("WebSockets not supported in this environment", Logger$1.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$9 = new Logger$1(version$d);
let NextId = 1;
class WebSocketProvider extends JsonRpcProvider$1 {
  constructor(url, network) {
    if (network === "any") {
      logger$9.throwError("WebSocketProvider does not support 'any' network yet", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    if (typeof url === "string") {
      super(url, network);
    } else {
      super("_websocket", network);
    }
    this._pollingInterval = -1;
    this._wsReady = false;
    if (typeof url === "string") {
      defineReadOnly(this, "_websocket", new WS(this.connection.url));
    } else {
      defineReadOnly(this, "_websocket", url);
    }
    defineReadOnly(this, "_requests", {});
    defineReadOnly(this, "_subs", {});
    defineReadOnly(this, "_subIds", {});
    defineReadOnly(this, "_detectNetwork", super.detectNetwork());
    this.websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id2) => {
        this.websocket.send(this._requests[id2].payload);
      });
    };
    this.websocket.onmessage = (messageEvent) => {
      const data2 = messageEvent.data;
      const result = JSON.parse(data2);
      if (result.id != null) {
        const id2 = String(result.id);
        const request = this._requests[id2];
        delete this._requests[id2];
        if (result.result !== void 0) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly(error, "code", result.error.code || null);
            defineReadOnly(error, "response", data2);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, void 0);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  // Cannot narrow the type of _websocket, as that is not backwards compatible
  // so we add a getter and let the WebSocket be a public API.
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger$9.throwError("cannot reset events block on WebSocketProvider", Logger$1.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger$9.throwError("cannot set polling interval on WebSocketProvider", Logger$1.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger$9.throwError("cannot set polling on WebSocketProvider", Logger$1.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this.websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash2 = event2.hash;
          this.getTransactionReceipt(hash2).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash2, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e2) => e2.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e2) => e2.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this.websocket.onopen = function() {
            resolve(true);
          };
          this.websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this.websocket.close(1e3);
    });
  }
}
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$8 = new Logger$1(version$d);
class StaticJsonRpcProvider extends JsonRpcProvider$1 {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter$2(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger$8.throwError("no network detected", Logger$1.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
}
class UrlJsonRpcProvider extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger$8.checkAbstract(new.target, UrlJsonRpcProvider);
    network = getStatic(new.target, "getNetwork")(network);
    apiKey = getStatic(new.target, "getApiKey")(apiKey);
    const connection = getStatic(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      defineReadOnly(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key2) => {
        defineReadOnly(this, key2, apiKey[key2]);
      });
    }
  }
  _startPending() {
    logger$8.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger$8.throwError("API provider does not support signing", Logger$1.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  // Return a defaultApiKey if null, otherwise validate the API key
  static getApiKey(apiKey) {
    return apiKey;
  }
  // Returns the url or connection for the given network and API key. The
  // API key will have been sanitized by the getApiKey first, so any validation
  // or transformations can be done there.
  static getUrl(network, apiKey) {
    return logger$8.throwError("not implemented; sub-classes must override getUrl", Logger$1.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
}
const logger$7 = new Logger$1(version$d);
const defaultProjectId = "84842078b09946638c03157f83405213";
class InfuraWebSocketProvider extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger$7.throwError("INFURA WebSocket project secrets unsupported", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineReadOnly(this, "apiKey", provider.projectId);
    defineReadOnly(this, "projectId", provider.projectId);
    defineReadOnly(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}
class InfuraProvider extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger$7.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger$7.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host2 = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host2 = "mainnet.infura.io";
        break;
      case "goerli":
        host2 = "goerli.infura.io";
        break;
      case "sepolia":
        host2 = "sepolia.infura.io";
        break;
      case "matic":
        host2 = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host2 = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host2 = "optimism-mainnet.infura.io";
        break;
      case "optimism-goerli":
        host2 = "optimism-goerli.infura.io";
        break;
      case "arbitrum":
        host2 = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-goerli":
        host2 = "arbitrum-goerli.infura.io";
        break;
      default:
        logger$7.throwError("unsupported network", Logger$1.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host2 + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}
const logger$6 = new Logger$1(version$d);
let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
class Web3Provider extends JsonRpcProvider$1 {
  constructor(provider, network) {
    if (provider == null) {
      logger$6.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger$6.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
}
const version$9 = "abi/5.7.0";
const logger$5 = new Logger$1(version$9);
const _constructorGuard = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type2, name2) {
  if (type2 === "bytes" || type2 === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type2 === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type2.indexOf("[") >= 0 || type2 === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger$5.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError2(i3) {
    logger$5.throwArgumentError(`unexpected character at position ${i3}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node3 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node3.indexed = false;
    }
    return node3;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node2 = parent;
  for (let i3 = 0; i3 < param.length; i3++) {
    let c2 = param[i3];
    switch (c2) {
      case "(":
        if (node2.state.allowType && node2.type === "") {
          node2.type = "tuple";
        } else if (!node2.state.allowParams) {
          throwError2(i3);
        }
        node2.state.allowType = false;
        node2.type = verifyType(node2.type);
        node2.components = [newNode(node2)];
        node2 = node2.components[0];
        break;
      case ")":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i3);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let child = node2;
        node2 = node2.parent;
        if (!node2) {
          throwError2(i3);
        }
        delete child.parent;
        node2.state.allowParams = false;
        node2.state.allowName = true;
        node2.state.allowArray = true;
        break;
      case ",":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i3);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let sibling = newNode(node2.parent);
        node2.parent.components.push(sibling);
        delete node2.parent;
        node2 = sibling;
        break;
      case " ":
        if (node2.state.allowType) {
          if (node2.type !== "") {
            node2.type = verifyType(node2.type);
            delete node2.state.allowType;
            node2.state.allowName = true;
            node2.state.allowParams = true;
          }
        }
        if (node2.state.allowName) {
          if (node2.name !== "") {
            if (node2.name === "indexed") {
              if (!allowIndexed) {
                throwError2(i3);
              }
              if (node2.indexed) {
                throwError2(i3);
              }
              node2.indexed = true;
              node2.name = "";
            } else if (checkModifier(node2.type, node2.name)) {
              node2.name = "";
            } else {
              node2.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node2.state.allowArray) {
          throwError2(i3);
        }
        node2.type += c2;
        node2.state.allowArray = false;
        node2.state.allowName = false;
        node2.state.readArray = true;
        break;
      case "]":
        if (!node2.state.readArray) {
          throwError2(i3);
        }
        node2.type += c2;
        node2.state.readArray = false;
        node2.state.allowArray = true;
        node2.state.allowName = true;
        break;
      default:
        if (node2.state.allowType) {
          node2.type += c2;
          node2.state.allowParams = true;
          node2.state.allowArray = true;
        } else if (node2.state.allowName) {
          node2.name += c2;
          delete node2.state.allowArray;
        } else if (node2.state.readArray) {
          node2.type += c2;
        } else {
          throwError2(i3);
        }
    }
  }
  if (node2.parent) {
    logger$5.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node2.name === "indexed") {
    if (!allowIndexed) {
      throwError2(originalParam.length - 7);
    }
    if (node2.indexed) {
      throwError2(originalParam.length - 7);
    }
    node2.indexed = true;
    node2.name = "";
  } else if (checkModifier(node2.type, node2.name)) {
    node2.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object2, params) {
  for (let key2 in params) {
    defineReadOnly(object2, key2, params[key2]);
  }
}
const FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard) {
      logger$5.throwError("use fromString", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node2) {
      return ParamType.fromObject({
        name: node2.name,
        type: node2.type,
        indexed: node2.indexed,
        components: node2.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard) {
      logger$5.throwError("use a static from method", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$5.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger$5.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
}
class EventFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger$5.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard, params);
  }
  static fromString(value) {
    let match = value.match(regexParen);
    if (!match) {
      logger$5.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger$5.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger$5.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger$5.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger$5.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger$5.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger$5.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger$5.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger$5.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
class ConstructorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    if (format === FormatTypes.sighash) {
      logger$5.throwError("cannot format a constructor for sighash", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger$5.throwArgumentError("invalid constructor object", "value", value);
    }
    let state2 = verifyState(value);
    if (state2.constant) {
      logger$5.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger$5.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
        outputs: this.outputs.map((output) => JSON.parse(output.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger$5.throwArgumentError("invalid function object", "value", value);
    }
    let state2 = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state2.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger$5.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger$5.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger$5.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger$5.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
class ErrorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger$5.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger$5.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
}
function verifyType(type2) {
  if (type2.match(/^uint($|[^1-9])/)) {
    type2 = "uint256" + type2.substring(4);
  } else if (type2.match(/^int($|[^1-9])/)) {
    type2 = "int256" + type2.substring(3);
  }
  return type2;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger$5.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c2 = value[offset];
    if (c2 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c2;
      if (c2 === "(") {
        depth++;
      } else if (c2 === ")") {
        depth--;
        if (depth === -1) {
          logger$5.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
const logger$4 = new Logger$1(version$9);
function checkResultErrors(result) {
  const errors2 = [];
  const checkErrors = function(path, object2) {
    if (!Array.isArray(object2)) {
      return;
    }
    for (let key2 in object2) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object2[key2]);
      } catch (error) {
        errors2.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors2;
}
class Coder {
  constructor(name2, type2, localName, dynamic2) {
    this.name = name2;
    this.type = type2;
    this.localName = localName;
    this.dynamic = dynamic2;
  }
  _throwError(message, value) {
    logger$4.throwArgumentError(message, this.localName, value);
  }
}
let Writer$2 = class Writer2 {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data2) {
    this._data.push(data2);
    this._dataLength += data2.length;
    return data2.length;
  }
  appendWriter(writer2) {
    return this._writeData(concat$6(writer2._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(value) {
    let bytes2 = arrayify$1(value);
    const paddingOffset = bytes2.length % this.wordSize;
    if (paddingOffset) {
      bytes2 = concat$6([bytes2, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes2);
  }
  _getValue(value) {
    let bytes2 = arrayify$1(BigNumber.from(value));
    if (bytes2.length > this.wordSize) {
      logger$4.throwError("value out-of-bounds", Logger$1.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes2.length
      });
    }
    if (bytes2.length % this.wordSize) {
      bytes2 = concat$6([this._padding.slice(bytes2.length % this.wordSize), bytes2]);
    }
    return bytes2;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
};
let Reader$2 = class Reader2 {
  constructor(data2, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify$1(data2));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(name2, value) {
    let match = name2.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name2, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value);
    }
    return Reader2.coerce(name2, value);
  }
  _peekBytes(offset, length2, loose) {
    let alignedLength = Math.ceil(length2 / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length2 <= this._data.length) {
        alignedLength = length2;
      } else {
        logger$4.throwError("data out-of-bounds", Logger$1.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new Reader2(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length2, loose) {
    let bytes2 = this._peekBytes(0, length2, !!loose);
    this._offset += bytes2.length;
    return bytes2.slice(0, length2);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
};
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer2, value) {
    try {
      value = getAddress(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer2.writeValue(value);
  }
  decode(reader2) {
    return getAddress(hexZeroPad(reader2.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer2, value) {
    return this.coder.encode(writer2, value);
  }
  decode(reader2) {
    return this.coder.decode(reader2);
  }
}
const logger$3 = new Logger$1(version$9);
function pack$1(writer2, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger$3.throwError("cannot encode object for signature with missing names", Logger$1.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger$3.throwError("cannot encode object for signature with duplicate names", Logger$1.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger$3.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger$3.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer$2(writer2.wordSize);
  let dynamicWriter = new Writer$2(writer2.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index2) => {
    let value = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func2) => {
    func2(staticWriter.length);
  });
  let length2 = writer2.appendWriter(staticWriter);
  length2 += writer2.appendWriter(dynamicWriter);
  return length2;
}
function unpack(reader2, coders) {
  let values = [];
  let baseReader = reader2.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader2.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger$1.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader2);
      } catch (error) {
        if (error.code === Logger$1.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index2) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value = values[index2];
    if (value instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name2] = value;
    }
  });
  for (let i3 = 0; i3 < values.length; i3++) {
    const value = values[i3];
    if (value instanceof Error) {
      Object.defineProperty(values, i3, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
class ArrayCoder extends Coder {
  constructor(coder, length2, localName) {
    const type2 = coder.type + "[" + (length2 >= 0 ? length2 : "") + "]";
    const dynamic2 = length2 === -1 || coder.dynamic;
    super("array", type2, localName, dynamic2);
    this.coder = coder;
    this.length = length2;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i3 = 0; i3 < this.length; i3++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer2, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count2 = this.length;
    if (count2 === -1) {
      count2 = value.length;
      writer2.writeValue(value.length);
    }
    logger$3.checkArgumentCount(value.length, count2, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i3 = 0; i3 < value.length; i3++) {
      coders.push(this.coder);
    }
    return pack$1(writer2, coders, value);
  }
  decode(reader2) {
    let count2 = this.length;
    if (count2 === -1) {
      count2 = reader2.readValue().toNumber();
      if (count2 * 32 > reader2._data.length) {
        logger$3.throwError("insufficient data length", Logger$1.errors.BUFFER_OVERRUN, {
          length: reader2._data.length,
          count: count2
        });
      }
    }
    let coders = [];
    for (let i3 = 0; i3 < count2; i3++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader2.coerce(this.name, unpack(reader2, coders));
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer2, value) {
    return writer2.writeValue(value ? 1 : 0);
  }
  decode(reader2) {
    return reader2.coerce(this.type, !reader2.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type2, localName) {
    super(type2, type2, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer2, value) {
    value = arrayify$1(value);
    let length2 = writer2.writeValue(value.length);
    length2 += writer2.writeBytes(value);
    return length2;
  }
  decode(reader2) {
    return reader2.readBytes(reader2.readValue().toNumber(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader2) {
    return reader2.coerce(this.name, hexlify(super.decode(reader2)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size2, localName) {
    let name2 = "bytes" + String(size2);
    super(name2, name2, localName, false);
    this.size = size2;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer2, value) {
    let data2 = arrayify$1(value);
    if (data2.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer2.writeBytes(data2);
  }
  decode(reader2) {
    return reader2.coerce(this.name, hexlify(reader2.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer2, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer2.writeBytes([]);
  }
  decode(reader2) {
    reader2.readBytes(0);
    return reader2.coerce(this.name, null);
  }
}
class NumberCoder extends Coder {
  constructor(size2, signed2, localName) {
    const name2 = (signed2 ? "int" : "uint") + size2 * 8;
    super(name2, name2, localName, false);
    this.size = size2;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer2, value) {
    let v4 = BigNumber.from(value);
    let maxUintValue = MaxUint256$1.mask(writer2.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v4.gt(bounds) || v4.lt(bounds.add(One$1).mul(NegativeOne$1))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v4.lt(Zero$1) || v4.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v4 = v4.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v4 = v4.fromTwos(this.size * 8).toTwos(8 * writer2.wordSize);
    }
    return writer2.writeValue(v4);
  }
  decode(reader2) {
    let value = reader2.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader2.coerce(this.name, value);
  }
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer2, value) {
    return super.encode(writer2, toUtf8Bytes(value));
  }
  decode(reader2) {
    return toUtf8String(super.decode(reader2));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic2 = false;
    const types2 = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic2 = true;
      }
      types2.push(coder.type);
    });
    const type2 = "tuple(" + types2.join(",") + ")";
    super("tuple", type2, localName, dynamic2);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index2];
    });
    return Object.freeze(values);
  }
  encode(writer2, value) {
    return pack$1(writer2, this.coders, value);
  }
  decode(reader2) {
    return reader2.coerce(this.name, unpack(reader2, this.coders));
  }
}
const logger$2 = new Logger$1(version$9);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size2 = parseInt(match[2] || "256");
      if (size2 === 0 || size2 > 256 || size2 % 8 !== 0) {
        logger$2.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size2 / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size2 = parseInt(match[1]);
      if (size2 === 0 || size2 > 32) {
        logger$2.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size2, param.name);
    }
    return logger$2.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data2, allowLoose) {
    return new Reader$2(data2, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer$2(this._getWordSize());
  }
  getDefaultValue(types2) {
    const coders = types2.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types2, values) {
    if (types2.length !== values.length) {
      logger$2.throwError("types/values length mismatch", Logger$1.errors.INVALID_ARGUMENT, {
        count: { types: types2.length, values: values.length },
        value: { types: types2, values }
      });
    }
    const coders = types2.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    const writer2 = this._getWriter();
    coder.encode(writer2, values);
    return writer2.data;
  }
  decode(types2, data2, loose) {
    const coders = types2.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify$1(data2), loose));
  }
}
const defaultAbiCoder = new AbiCoder();
const logger$1 = new Logger$1(version$9);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
  const wrap2 = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap2.error = error;
  return wrap2;
}
class Interface {
  constructor(fragments) {
    let abi2 = [];
    if (typeof fragments === "string") {
      abi2 = JSON.parse(fragments);
    } else {
      abi2 = fragments;
    }
    defineReadOnly(this, "fragments", abi2.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket2 = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger$1.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          bucket2 = this.functions;
          break;
        case "event":
          bucket2 = this.events;
          break;
        case "error":
          bucket2 = this.errors;
          break;
        default:
          return;
      }
      let signature2 = fragment.format();
      if (bucket2[signature2]) {
        logger$1.warn("duplicate definition - " + signature2);
        return;
      }
      bucket2[signature2] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.full;
    }
    if (format === FormatTypes.sighash) {
      logger$1.throwArgumentError("interface does not support formatting sighash", "format", format);
    }
    const abi2 = this.fragments.map((fragment) => fragment.format(format));
    if (format === FormatTypes.json) {
      return JSON.stringify(abi2.map((j2) => JSON.parse(j2)));
    }
    return abi2;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id$1(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id$1(eventFragment.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString$3(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger$1.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f4) => f4.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$1.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger$1.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$1.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString$3(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger$1.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f4) => f4.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$1.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger$1.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger$1.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(nameOrSignatureOrSighash) {
    if (isHexString$3(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name2];
        }
      }
      logger$1.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f4) => f4.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$1.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger$1.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$1.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_3) {
          throw error;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data2) {
    return this._abiCoder.decode(params, data2);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data2) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes2 = arrayify$1(data2);
    if (hexlify(bytes2.slice(0, 4)) !== this.getSighash(fragment)) {
      logger$1.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes2));
    }
    return this._decodeParams(fragment.inputs, bytes2.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat$6([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(functionFragment, data2) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes2 = arrayify$1(data2);
    if (hexlify(bytes2.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger$1.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes2));
    }
    return this._decodeParams(functionFragment.inputs, bytes2.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat$6([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(functionFragment, data2) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes2 = arrayify$1(data2);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes2.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes2);
        } catch (error) {
        }
        break;
      case 4: {
        const selector = hexlify(bytes2.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes2.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
          if (errorName === "Error") {
            message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
          } else if (errorName === "Panic") {
            message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
          }
        } else {
          try {
            const error = this.getError(selector);
            errorArgs = this._abiCoder.decode(error.inputs, bytes2.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
          }
        }
        break;
      }
    }
    return logger$1.throwError("call revert exception" + message, Logger$1.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: hexlify(data2),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger$1.throwError("too many arguments for " + eventFragment.format(), Logger$1.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id$1(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = BigNumber.from(value).toHexString();
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    };
    values.forEach((value, index2) => {
      let param = eventFragment.inputs[index2];
      if (!param.indexed) {
        if (value != null) {
          logger$1.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger$1.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger$1.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index2) => {
      const value = values[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id$1(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(eventFragment, data2, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString$3(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger$1.throwError("fragment/topic mismatch", Logger$1.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic2 = [];
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic2.push(true);
        } else {
          indexed.push(param);
          dynamic2.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic2.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat$6(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data2, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index2] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic2[index2]) {
          result[index2] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index2] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index2] = error;
          }
        }
      } else {
        try {
          result[index2] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index2] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index2];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i3 = 0; i3 < result.length; i3++) {
      const value = result[i3];
      if (value instanceof Error) {
        Object.defineProperty(result, i3, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i3}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(log3) {
    let fragment = this.getEvent(log3.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log3.data, log3.topics)
    });
  }
  parseError(data2) {
    const hexData = hexlify(data2);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
}
const version$8 = "contracts/5.7.0";
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger = new Logger$1(version$8);
function resolveName(resolver, nameOrPromise) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return getAddress(name2);
    } catch (error) {
    }
    if (!resolver) {
      logger.throwError("a provider or signer is needed to resolve ENS names", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name2);
    if (address == null) {
      logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter$1(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index2) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index2] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger.makeError("invalid value for array", Logger$1.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v4) => resolveAddresses(resolver, v4, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter$1(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy$1(args.pop());
    }
    logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check2) => __awaiter$1(this, void 0, void 0, function* () {
          if (getAddress(check2.signer) !== check2.override) {
            logger.throwError("Contract with a Signer cannot override from", Logger$1.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check2.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data2 = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data: data2,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes2 = arrayify$1(data2);
      for (let i3 = 0; i3 < bytes2.length; i3++) {
        intrinsic += 4;
        if (bytes2[i3]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger.throwError("non-payable method cannot override value", Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy$1(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger.throwError(`cannot override ${leftovers.map((l2) => JSON.stringify(l2)).join(",")}`, Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger.throwError("estimate require a provider or signer", Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log3) => {
        let event = deepCopy(log3);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log3);
        } catch (e2) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data2, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data2, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy$1(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger$1.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger.throwError("sending a transaction requires a signer", Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag(filter2) {
  if (filter2.address && (filter2.topics == null || filter2.topics.length === 0)) {
    return "*";
  }
  return (filter2.address || "*") + "@" + (filter2.topics ? filter2.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
class RunningEvent {
  constructor(tag, filter2) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter2);
    this._listeners = [];
  }
  addListener(listener, once3) {
    this._listeners.push({ listener, once: once3 });
  }
  removeListener(listener) {
    let done2 = false;
    this._listeners = this._listeners.filter((item) => {
      if (done2 || item.listener !== listener) {
        return true;
      }
      done2 = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i3) => i3.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount2 = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount2;
  }
  prepareEvent(event) {
  }
  // Returns the array that will be applied to an emit
  getEmit(event) {
    return [event];
  }
}
class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}
class FragmentRunningEvent extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter2 = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter2.topics = topics.slice();
    } else {
      filter2.topics = [topic];
    }
    super(getEventTag(filter2), filter2);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data2, topics) => {
      return this.interface.decodeEventLog(this.fragment, data2, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors2 = checkResultErrors(event.args);
    if (errors2.length) {
      throw errors2[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
}
class WildcardRunningEvent extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data2, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data2, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
}
class BaseContract {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name2) => {
        const filters = uniqueFilters[name2];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name2, this.filters[filters[0]]);
        } else {
          logger.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error) {
        logger.throwError("provider is required to use ENS name as contract address", Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e2) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature2) => {
      const fragment = this.interface.functions[signature2];
      if (uniqueSignatures[signature2]) {
        logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
        return;
      }
      uniqueSignatures[signature2] = true;
      {
        const name2 = fragment.name;
        if (!uniqueNames[`%${name2}`]) {
          uniqueNames[`%${name2}`] = [];
        }
        uniqueNames[`%${name2}`].push(signature2);
      }
      if (this[signature2] == null) {
        defineReadOnly(this, signature2, buildDefault(this, fragment, true));
      }
      if (this.functions[signature2] == null) {
        defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature2] == null) {
        defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature2] == null) {
        defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature2] == null) {
        defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name2) => {
      const signatures = uniqueNames[name2];
      if (signatures.length > 1) {
        return;
      }
      name2 = name2.substring(1);
      const signature2 = signatures[0];
      try {
        if (this[name2] == null) {
          defineReadOnly(this, name2, this[signature2]);
        }
      } catch (e2) {
      }
      if (this.functions[name2] == null) {
        defineReadOnly(this.functions, name2, this.functions[signature2]);
      }
      if (this.callStatic[name2] == null) {
        defineReadOnly(this.callStatic, name2, this.callStatic[signature2]);
      }
      if (this.populateTransaction[name2] == null) {
        defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature2]);
      }
      if (this.estimateGas[name2] == null) {
        defineReadOnly(this.estimateGas, name2, this.estimateGas[signature2]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code2) => {
          if (code2 === "0x") {
            logger.throwError("contract not deployed", Logger$1.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(overrides) {
    if (!this.signer) {
      logger.throwError("sending a transactions require a signer", Logger$1.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy$1(overrides || {});
    ["from", "to"].forEach(function(key2) {
      if (tx[key2] == null) {
        return;
      }
      logger.throwError("cannot override " + key2, Logger$1.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  // Reconnect to a different signer or provider
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter2 = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter2), filter2));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit3 = this._wrappedEmits[runningEvent.tag];
      if (emit3 && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit3);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(runningEvent, log3, listener) {
    const event = deepCopy(log3);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log3.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log3.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log3.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once3) {
    if (!this.provider) {
      logger.throwError("events require a provider or a signer with a provider", Logger$1.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once3);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log3) => {
        let event = this._wrapEvent(runningEvent, log3, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter2 = shallowCopy$1(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString$3(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter2.blockHash = fromBlockOrBlockhash;
    } else {
      filter2.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter2.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter2).then((logs) => {
      return logs.map((log3) => this._wrapEvent(runningEvent, log3, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key2) => {
        return accum + this._runningEvents[key2].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
}
class Contract extends BaseContract {
}
const t$7 = Symbol();
const s$6 = Object.getPrototypeOf, c$7 = /* @__PURE__ */ new WeakMap(), l$5 = (e2) => e2 && (c$7.has(e2) ? c$7.get(e2) : s$6(e2) === Object.prototype || s$6(e2) === Array.prototype), y$8 = (e2) => l$5(e2) && e2[t$7] || null, h$b = (e2, t2 = true) => {
  c$7.set(e2, t2);
};
const isObject$3 = (x2) => typeof x2 === "object" && x2 !== null;
const proxyStateMap = /* @__PURE__ */ new WeakMap();
const refSet = /* @__PURE__ */ new WeakSet();
const buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x2) => isObject$3(x2) && !refSet.has(x2) && (Array.isArray(x2) || !(Symbol.iterator in x2)) && !(x2 instanceof WeakMap) && !(x2 instanceof WeakSet) && !(x2 instanceof Error) && !(x2 instanceof Number) && !(x2 instanceof Date) && !(x2 instanceof String) && !(x2 instanceof RegExp) && !(x2 instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version2, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version2) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  h$b(snap, true);
  snapCache.set(target, [version2, snap]);
  Reflect.ownKeys(target).forEach((key2) => {
    if (Object.getOwnPropertyDescriptor(snap, key2)) {
      return;
    }
    const value = Reflect.get(target, key2);
    const desc = {
      value,
      enumerable: true,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: true
    };
    if (refSet.has(value)) {
      h$b(value, false);
    } else if (value instanceof Promise) {
      delete desc.value;
      desc.get = () => handlePromise(value);
    } else if (proxyStateMap.has(value)) {
      const [target2, ensureVersion] = proxyStateMap.get(
        value
      );
      desc.value = createSnapshot(
        target2,
        ensureVersion(),
        handlePromise
      );
    }
    Object.defineProperty(snap, key2, desc);
  });
  return Object.preventExtensions(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
  if (!isObject$3(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version2 = versionHolder[0];
  const listeners2 = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version2 !== nextVersion) {
      version2 = nextVersion;
      listeners2.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners2.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version2) {
          version2 = propVersion;
        }
      });
    }
    return version2;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (({ "VITE_CHAIN_NAME": "optimisticEthereum", "VITE_process.env.NODE_DEBUG": "", "VITE_RAW_global.WebSocket": "window.WebSocket", "VITE_INFURA_ID": "781d8466252d47508e177b8637b1c2fd", "VITE_IPFS_AUTH_USERNAME": "1xds8y1D4cqT4rt77cC1jBLOrQk", "VITE_IPFS_AUTH_PASSWORD": "858749f19398b5ae89787172852c179b", "VITE_WALLET_CONNECT_PROJECT_ID": "806b7118ca48eec75f6cf7981bfca00d", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners2.size) {
      const remove2 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove2]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a2;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a2 = entry[1]) == null ? void 0 : _a2.call(entry);
    }
  };
  const addListener2 = (listener) => {
    listeners2.add(listener);
    if (listeners2.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (({ "VITE_CHAIN_NAME": "optimisticEthereum", "VITE_process.env.NODE_DEBUG": "", "VITE_RAW_global.WebSocket": "window.WebSocket", "VITE_INFURA_ID": "781d8466252d47508e177b8637b1c2fd", "VITE_IPFS_AUTH_USERNAME": "1xds8y1D4cqT4rt77cC1jBLOrQk", "VITE_IPFS_AUTH_PASSWORD": "858749f19398b5ae89787172852c179b", "VITE_WALLET_CONNECT_PROJECT_ID": "806b7118ca48eec75f6cf7981bfca00d", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove2 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove2]);
      });
    }
    const removeListener2 = () => {
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        propProxyStates.forEach(([propProxyState, remove2], prop) => {
          if (remove2) {
            remove2();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener2;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject$3(value)) {
        value = y$8(value) || value;
      }
      let nextValue = value;
      if (value instanceof Promise) {
        value.then((v4) => {
          value.status = "fulfilled";
          value.value = v4;
          notifyUpdate(["resolve", [prop], v4]);
        }).catch((e2) => {
          value.status = "rejected";
          value.reason = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxyFunction(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [
    baseObject,
    ensureVersion,
    createSnapshot,
    addListener2
  ];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key2) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key2
    );
    if ("value" in desc) {
      proxyObject[key2] = initialObject[key2];
      delete desc.value;
      delete desc.writable;
    }
    Object.defineProperty(baseObject, key2, desc);
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
const [defaultProxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return defaultProxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (({ "VITE_CHAIN_NAME": "optimisticEthereum", "VITE_process.env.NODE_DEBUG": "", "VITE_RAW_global.WebSocket": "window.WebSocket", "VITE_INFURA_ID": "781d8466252d47508e177b8637b1c2fd", "VITE_IPFS_AUTH_USERNAME": "1xds8y1D4cqT4rt77cC1jBLOrQk", "VITE_IPFS_AUTH_PASSWORD": "858749f19398b5ae89787172852c179b", "VITE_WALLET_CONNECT_PROJECT_ID": "806b7118ca48eec75f6cf7981bfca00d", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener2 = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener2 = addListener2(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener2();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (({ "VITE_CHAIN_NAME": "optimisticEthereum", "VITE_process.env.NODE_DEBUG": "", "VITE_RAW_global.WebSocket": "window.WebSocket", "VITE_INFURA_ID": "781d8466252d47508e177b8637b1c2fd", "VITE_IPFS_AUTH_USERNAME": "1xds8y1D4cqT4rt77cC1jBLOrQk", "VITE_IPFS_AUTH_PASSWORD": "858749f19398b5ae89787172852c179b", "VITE_WALLET_CONNECT_PROJECT_ID": "806b7118ca48eec75f6cf7981bfca00d", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function subscribeKey(proxyObject, key2, callback, notifyInSync) {
  let prevValue = proxyObject[key2];
  return subscribe(
    proxyObject,
    () => {
      const nextValue = proxyObject[key2];
      if (!Object.is(prevValue, nextValue)) {
        callback(prevValue = nextValue);
      }
    },
    notifyInSync
  );
}
const SECURE_SITE = "https://secure.web3modal.com";
const ConstantsUtil$1 = {
  FOUR_MINUTES_MS: 24e4,
  TEN_SEC_MS: 1e4,
  ONE_SEC_MS: 1e3,
  SECURE_SITE,
  SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
  SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
  RESTRICTED_TIMEZONES: [
    "ASIA/SHANGHAI",
    "ASIA/URUMQI",
    "ASIA/CHONGQING",
    "ASIA/HARBIN",
    "ASIA/KASHGAR",
    "ASIA/MACAU",
    "ASIA/HONG_KONG",
    "ASIA/MACAO",
    "ASIA/BEIJING",
    "ASIA/HARBIN"
  ],
  CONNECTOR_RDNS_MAP: {
    coinbaseWallet: "com.coinbase.wallet"
  }
};
const CoreHelperUtil = {
  isMobile() {
    if (typeof window !== "undefined") {
      return Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
    }
    return false;
  },
  isAndroid() {
    const ua2 = window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && ua2.includes("android");
  },
  isIos() {
    const ua2 = window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && (ua2.includes("iphone") || ua2.includes("ipad"));
  },
  isClient() {
    return typeof window !== "undefined";
  },
  isPairingExpired(expiry) {
    return expiry ? expiry - Date.now() <= ConstantsUtil$1.TEN_SEC_MS : true;
  },
  isAllowedRetry(lastRetry) {
    return Date.now() - lastRetry >= ConstantsUtil$1.ONE_SEC_MS;
  },
  copyToClopboard(text) {
    navigator.clipboard.writeText(text);
  },
  getPairingExpiry() {
    return Date.now() + ConstantsUtil$1.FOUR_MINUTES_MS;
  },
  getPlainAddress(caipAddress) {
    return caipAddress.split(":")[2];
  },
  async wait(milliseconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  },
  debounce(func2, timeout2 = 500) {
    let timer2 = void 0;
    return (...args) => {
      function next() {
        func2(...args);
      }
      if (timer2) {
        clearTimeout(timer2);
      }
      timer2 = setTimeout(next, timeout2);
    };
  },
  isHttpUrl(url) {
    return url.startsWith("http://") || url.startsWith("https://");
  },
  formatNativeUrl(appUrl, wcUri) {
    if (CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatUniversalUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.includes("://")) {
      safeAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
      safeAppUrl = `${safeAppUrl}://`;
    }
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  formatUniversalUrl(appUrl, wcUri) {
    if (!CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatNativeUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  openHref(href, target) {
    window.open(href, target, "noreferrer noopener");
  },
  async preloadImage(src2) {
    const imagePromise = new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = resolve;
      image.onerror = reject;
      image.crossOrigin = "anonymous";
      image.src = src2;
    });
    return Promise.race([imagePromise, CoreHelperUtil.wait(2e3)]);
  },
  formatBalance(balance, symbol2) {
    let formattedBalance = void 0;
    if (balance === "0") {
      formattedBalance = "0.000";
    } else if (typeof balance === "string") {
      const number2 = Number(balance);
      if (number2) {
        formattedBalance = number2.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0];
      }
    }
    return formattedBalance ? `${formattedBalance} ${symbol2}` : `0.000 ${symbol2}`;
  },
  isRestrictedRegion() {
    try {
      const { timeZone } = new Intl.DateTimeFormat().resolvedOptions();
      const capTimeZone = timeZone.toUpperCase();
      return ConstantsUtil$1.RESTRICTED_TIMEZONES.includes(capTimeZone);
    } catch {
      return false;
    }
  },
  getApiUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? "https://api.web3modal.org" : "https://api.web3modal.com";
  },
  getBlockchainApiUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com";
  },
  getAnalyticsUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? "https://pulse.walletconnect.org" : "https://pulse.walletconnect.com";
  },
  getUUID() {
    if (crypto?.randomUUID) {
      return crypto.randomUUID();
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (c2) => {
      const r2 = Math.random() * 16 | 0;
      const v4 = c2 === "x" ? r2 : r2 & 3 | 8;
      return v4.toString(16);
    });
  },
  parseError(error) {
    if (typeof error === "string") {
      return error;
    } else if (typeof error?.issues?.[0]?.message === "string") {
      return error.issues[0].message;
    } else if (error instanceof Error) {
      return error.message;
    }
    return "Unknown error";
  }
};
const state$i = proxy({
  isConnected: false
});
const AccountController = {
  state: state$i,
  subscribe(callback) {
    return subscribe(state$i, () => callback(state$i));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$i, key2, callback);
  },
  setIsConnected(isConnected) {
    state$i.isConnected = isConnected;
  },
  setCaipAddress(caipAddress) {
    state$i.caipAddress = caipAddress;
    state$i.address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
  },
  setBalance(balance, balanceSymbol) {
    state$i.balance = balance;
    state$i.balanceSymbol = balanceSymbol;
  },
  setProfileName(profileName) {
    state$i.profileName = profileName;
  },
  setProfileImage(profileImage) {
    state$i.profileImage = profileImage;
  },
  setAddressExplorerUrl(explorerUrl) {
    state$i.addressExplorerUrl = explorerUrl;
  },
  resetAccount() {
    state$i.isConnected = false;
    state$i.caipAddress = void 0;
    state$i.address = void 0;
    state$i.balance = void 0;
    state$i.balanceSymbol = void 0;
    state$i.profileName = void 0;
    state$i.profileImage = void 0;
    state$i.addressExplorerUrl = void 0;
  }
};
class FetchUtil {
  constructor({ baseUrl: baseUrl2 }) {
    this.baseUrl = baseUrl2;
  }
  async get({ headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, { method: "GET", headers });
    return response.json();
  }
  async getBlob({ headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, { method: "GET", headers });
    return response.blob();
  }
  async post({ body, headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: "POST",
      headers,
      body: body ? JSON.stringify(body) : void 0
    });
    return response.json();
  }
  async put({ body, headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: "PUT",
      headers,
      body: body ? JSON.stringify(body) : void 0
    });
    return response.json();
  }
  async delete({ body, headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: "DELETE",
      headers,
      body: body ? JSON.stringify(body) : void 0
    });
    return response.json();
  }
  createUrl({ path, params }) {
    const url = new URL(path, this.baseUrl);
    if (params) {
      Object.entries(params).forEach(([key2, value]) => {
        if (value) {
          url.searchParams.append(key2, value);
        }
      });
    }
    return url;
  }
}
const WC_DEEPLINK = "WALLETCONNECT_DEEPLINK_CHOICE";
const W3M_RECENT = "@w3m/recent";
const W3M_CONNECTED_WALLET_IMAGE_URL = "@w3m/connected_wallet_image_url";
const W3M_CONNECTED_CONNECTOR = "@w3m/connected_connector";
const StorageUtil = {
  setWalletConnectDeepLink({ href, name: name2 }) {
    try {
      localStorage.setItem(WC_DEEPLINK, JSON.stringify({ href, name: name2 }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  getWalletConnectDeepLink() {
    try {
      const deepLink = localStorage.getItem(WC_DEEPLINK);
      if (deepLink) {
        return JSON.parse(deepLink);
      }
    } catch {
      console.info("Unable to get WalletConnect deep link");
    }
    return void 0;
  },
  deleteWalletConnectDeepLink() {
    try {
      localStorage.removeItem(WC_DEEPLINK);
    } catch {
      console.info("Unable to delete WalletConnect deep link");
    }
  },
  setWeb3ModalRecent(wallet) {
    try {
      const recentWallets = StorageUtil.getRecentWallets();
      const exists2 = recentWallets.find((w3) => w3.id === wallet.id);
      if (!exists2) {
        recentWallets.unshift(wallet);
        if (recentWallets.length > 2) {
          recentWallets.pop();
        }
        localStorage.setItem(W3M_RECENT, JSON.stringify(recentWallets));
      }
    } catch {
      console.info("Unable to set Web3Modal recent");
    }
  },
  getRecentWallets() {
    try {
      const recent = localStorage.getItem(W3M_RECENT);
      return recent ? JSON.parse(recent) : [];
    } catch {
      console.info("Unable to get Web3Modal recent");
    }
    return [];
  },
  setConnectedWalletImageUrl(imageUrl) {
    try {
      localStorage.setItem(W3M_CONNECTED_WALLET_IMAGE_URL, imageUrl);
    } catch {
      console.info("Unable to set Connected Wallet Image Url");
    }
  },
  getConnectedWalletImageUrl() {
    try {
      return localStorage.getItem(W3M_CONNECTED_WALLET_IMAGE_URL);
    } catch {
      console.info("Unable to set Connected Wallet Image Url");
    }
    return void 0;
  },
  setConnectedConnector(connectorType) {
    try {
      localStorage.setItem(W3M_CONNECTED_CONNECTOR, connectorType);
    } catch {
      console.info("Unable to set Connected Connector");
    }
  },
  getConnectedConnector() {
    try {
      return localStorage.getItem(W3M_CONNECTED_CONNECTOR);
    } catch {
      console.info("Unable to get Connected Connector");
    }
    return void 0;
  }
};
const state$h = proxy({
  walletImages: {},
  networkImages: {},
  connectorImages: {},
  tokenImages: {}
});
const AssetController = {
  state: state$h,
  subscribeNetworkImages(callback) {
    return subscribe(state$h.networkImages, () => callback(state$h.networkImages));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$h, key2, callback);
  },
  setWalletImage(key2, value) {
    state$h.walletImages[key2] = value;
  },
  setNetworkImage(key2, value) {
    state$h.networkImages[key2] = value;
  },
  setConnectorImage(key2, value) {
    state$h.connectorImages[key2] = value;
  },
  setTokenImage(key2, value) {
    state$h.tokenImages[key2] = value;
  }
};
const state$g = proxy({
  projectId: "",
  sdkType: "w3m",
  sdkVersion: "html-wagmi-undefined"
});
const OptionsController = {
  state: state$g,
  subscribeKey(key2, callback) {
    return subscribeKey(state$g, key2, callback);
  },
  setProjectId(projectId) {
    state$g.projectId = projectId;
  },
  setIncludeWalletIds(includeWalletIds) {
    state$g.includeWalletIds = includeWalletIds;
  },
  setExcludeWalletIds(excludeWalletIds) {
    state$g.excludeWalletIds = excludeWalletIds;
  },
  setFeaturedWalletIds(featuredWalletIds) {
    state$g.featuredWalletIds = featuredWalletIds;
  },
  setTokens(tokens) {
    state$g.tokens = tokens;
  },
  setTermsConditionsUrl(termsConditionsUrl) {
    state$g.termsConditionsUrl = termsConditionsUrl;
  },
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    state$g.privacyPolicyUrl = privacyPolicyUrl;
  },
  setCustomWallets(customWallets) {
    state$g.customWallets = customWallets;
  },
  setEnableAnalytics(enableAnalytics) {
    state$g.enableAnalytics = enableAnalytics;
  },
  setSdkVersion(sdkVersion) {
    state$g.sdkVersion = sdkVersion;
  },
  setMetadata(metadata) {
    state$g.metadata = metadata;
  }
};
const state$f = proxy({
  connectors: []
});
const ConnectorController = {
  state: state$f,
  subscribeKey(key2, callback) {
    return subscribeKey(state$f, key2, callback);
  },
  setConnectors(connectors) {
    state$f.connectors = connectors.map((c2) => ref(c2));
  },
  addConnector(connector) {
    state$f.connectors.push(ref(connector));
    if (connector.id === "w3mEmail") {
      const emailConnector = connector;
      const optionsState = snapshot(OptionsController.state);
      emailConnector?.provider?.syncDappData?.({
        metadata: optionsState.metadata,
        sdkVersion: optionsState.sdkVersion,
        projectId: optionsState.projectId
      });
    }
  },
  getEmailConnector() {
    return state$f.connectors.find((c2) => c2.type === "EMAIL");
  },
  getAnnouncedConnectorRdns() {
    return state$f.connectors.filter((c2) => c2.type === "ANNOUNCED").map((c2) => c2.info?.rdns);
  },
  getConnectors() {
    return state$f.connectors;
  }
};
const state$e = proxy({
  open: false,
  selectedNetworkId: void 0
});
const PublicStateController = {
  state: state$e,
  subscribe(callback) {
    return subscribe(state$e, () => callback(state$e));
  },
  set(newState) {
    Object.assign(state$e, { ...state$e, ...newState });
  }
};
const state$d = proxy({
  supportsAllNetworks: true,
  isDefaultCaipNetwork: false
});
const NetworkController = {
  state: state$d,
  subscribeKey(key2, callback) {
    return subscribeKey(state$d, key2, callback);
  },
  _getClient() {
    if (!state$d._client) {
      throw new Error("NetworkController client not set");
    }
    return state$d._client;
  },
  setClient(client2) {
    state$d._client = ref(client2);
  },
  setCaipNetwork(caipNetwork) {
    state$d.caipNetwork = caipNetwork;
    PublicStateController.set({ selectedNetworkId: caipNetwork?.id });
  },
  setDefaultCaipNetwork(caipNetwork) {
    state$d.caipNetwork = caipNetwork;
    PublicStateController.set({ selectedNetworkId: caipNetwork?.id });
    state$d.isDefaultCaipNetwork = true;
  },
  setRequestedCaipNetworks(requestedNetworks) {
    state$d.requestedCaipNetworks = requestedNetworks;
  },
  async getApprovedCaipNetworksData() {
    const data2 = await this._getClient().getApprovedCaipNetworksData();
    state$d.supportsAllNetworks = data2.supportsAllNetworks;
    state$d.approvedCaipNetworkIds = data2.approvedCaipNetworkIds;
  },
  async switchActiveNetwork(network) {
    await this._getClient().switchCaipNetwork(network);
    state$d.caipNetwork = network;
  },
  resetNetwork() {
    if (!state$d.isDefaultCaipNetwork) {
      state$d.caipNetwork = void 0;
    }
    state$d.approvedCaipNetworkIds = void 0;
    state$d.supportsAllNetworks = true;
  }
};
const baseUrl$2 = CoreHelperUtil.getApiUrl();
const api$4 = new FetchUtil({ baseUrl: baseUrl$2 });
const entries = "40";
const recommendedEntries = "4";
const state$c = proxy({
  page: 1,
  count: 0,
  featured: [],
  recommended: [],
  wallets: [],
  search: []
});
const ApiController = {
  state: state$c,
  subscribeKey(key2, callback) {
    return subscribeKey(state$c, key2, callback);
  },
  _getApiHeaders() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  async _fetchWalletImage(imageId) {
    const imageUrl = `${api$4.baseUrl}/getWalletImage/${imageId}`;
    const blob = await api$4.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setWalletImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchNetworkImage(imageId) {
    const imageUrl = `${api$4.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api$4.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setNetworkImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchConnectorImage(imageId) {
    const imageUrl = `${api$4.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api$4.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setConnectorImage(imageId, URL.createObjectURL(blob));
  },
  async fetchNetworkImages() {
    const { requestedCaipNetworks } = NetworkController.state;
    const ids = requestedCaipNetworks?.map(({ imageId }) => imageId).filter(Boolean);
    if (ids) {
      await Promise.allSettled(ids.map((id2) => ApiController._fetchNetworkImage(id2)));
    }
  },
  async fetchConnectorImages() {
    const { connectors } = ConnectorController.state;
    const ids = connectors.map(({ imageId }) => imageId).filter(Boolean);
    await Promise.allSettled(ids.map((id2) => ApiController._fetchConnectorImage(id2)));
  },
  async fetchFeaturedWallets() {
    const { featuredWalletIds } = OptionsController.state;
    if (featuredWalletIds?.length) {
      const { data: data2 } = await api$4.get({
        path: "/getWallets",
        headers: ApiController._getApiHeaders(),
        params: {
          page: "1",
          entries: featuredWalletIds?.length ? String(featuredWalletIds.length) : recommendedEntries,
          include: featuredWalletIds?.join(",")
        }
      });
      data2.sort((a3, b4) => featuredWalletIds.indexOf(a3.id) - featuredWalletIds.indexOf(b4.id));
      const images = data2.map((d3) => d3.image_id).filter(Boolean);
      await Promise.allSettled(images.map((id2) => ApiController._fetchWalletImage(id2)));
      state$c.featured = data2;
    }
  },
  async fetchRecommendedWallets() {
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [...excludeWalletIds ?? [], ...featuredWalletIds ?? []].filter(Boolean);
    const { data: data2, count: count2 } = await api$4.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        entries: recommendedEntries,
        include: includeWalletIds?.join(","),
        exclude: exclude?.join(",")
      }
    });
    const recent = StorageUtil.getRecentWallets();
    const recommendedImages = data2.map((d3) => d3.image_id).filter(Boolean);
    const recentImages = recent.map((r2) => r2.image_id).filter(Boolean);
    await Promise.allSettled([...recommendedImages, ...recentImages].map((id2) => ApiController._fetchWalletImage(id2)));
    state$c.recommended = data2;
    state$c.count = count2 ?? 0;
  },
  async fetchWallets({ page }) {
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [
      ...state$c.recommended.map(({ id: id2 }) => id2),
      ...excludeWalletIds ?? [],
      ...featuredWalletIds ?? []
    ].filter(Boolean);
    const { data: data2, count: count2 } = await api$4.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: String(page),
        entries,
        include: includeWalletIds?.join(","),
        exclude: exclude.join(",")
      }
    });
    const images = data2.map((w3) => w3.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id2) => ApiController._fetchWalletImage(id2)),
      CoreHelperUtil.wait(300)
    ]);
    state$c.wallets = [...state$c.wallets, ...data2];
    state$c.count = count2 > state$c.count ? count2 : state$c.count;
    state$c.page = page;
  },
  async searchWallet({ search }) {
    const { includeWalletIds, excludeWalletIds } = OptionsController.state;
    state$c.search = [];
    const { data: data2 } = await api$4.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        entries: "100",
        search,
        include: includeWalletIds?.join(","),
        exclude: excludeWalletIds?.join(",")
      }
    });
    const images = data2.map((w3) => w3.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id2) => ApiController._fetchWalletImage(id2)),
      CoreHelperUtil.wait(300)
    ]);
    state$c.search = data2;
  },
  prefetch() {
    state$c.prefetchPromise = Promise.race([
      Promise.allSettled([
        ApiController.fetchFeaturedWallets(),
        ApiController.fetchRecommendedWallets(),
        ApiController.fetchNetworkImages(),
        ApiController.fetchConnectorImages()
      ]),
      CoreHelperUtil.wait(3e3)
    ]);
  }
};
const baseUrl$1 = CoreHelperUtil.getAnalyticsUrl();
const api$3 = new FetchUtil({ baseUrl: baseUrl$1 });
const excluded = ["MODAL_CREATED"];
const state$b = proxy({
  timestamp: Date.now(),
  data: {
    type: "track",
    event: "MODAL_CREATED"
  }
});
const EventsController = {
  state: state$b,
  subscribe(callback) {
    return subscribe(state$b, () => callback(state$b));
  },
  _getApiHeaders() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  async _sendAnalyticsEvent(payload) {
    try {
      if (excluded.includes(payload.data.event) || typeof window === "undefined") {
        return;
      }
      await api$3.post({
        path: "/e",
        headers: EventsController._getApiHeaders(),
        body: {
          eventId: CoreHelperUtil.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: payload.timestamp,
          props: payload.data
        }
      });
    } catch {
    }
  },
  sendEvent(data2) {
    state$b.timestamp = Date.now();
    state$b.data = data2;
    if (OptionsController.state.enableAnalytics) {
      EventsController._sendAnalyticsEvent(state$b);
    }
  }
};
const state$a = proxy({
  view: "Connect",
  history: ["Connect"]
});
const RouterController = {
  state: state$a,
  subscribeKey(key2, callback) {
    return subscribeKey(state$a, key2, callback);
  },
  push(view, data2) {
    if (view !== state$a.view) {
      state$a.view = view;
      state$a.history.push(view);
      state$a.data = data2;
    }
  },
  reset(view) {
    state$a.view = view;
    state$a.history = [view];
  },
  replace(view, data2) {
    if (state$a.history.length > 1 && state$a.history.at(-1) !== view) {
      state$a.view = view;
      state$a.history[state$a.history.length - 1] = view;
      state$a.data = data2;
    }
  },
  goBack() {
    if (state$a.history.length > 1) {
      state$a.history.pop();
      const [last2] = state$a.history.slice(-1);
      if (last2) {
        state$a.view = last2;
      }
    }
  },
  goBackToIndex(historyIndex) {
    if (state$a.history.length > 1) {
      state$a.history = state$a.history.slice(0, historyIndex + 1);
      const [last2] = state$a.history.slice(-1);
      if (last2) {
        state$a.view = last2;
      }
    }
  }
};
const state$9 = proxy({
  loading: false,
  open: false
});
const ModalController = {
  state: state$9,
  subscribe(callback) {
    return subscribe(state$9, () => callback(state$9));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$9, key2, callback);
  },
  async open(options) {
    await ApiController.state.prefetchPromise;
    if (options?.view) {
      RouterController.reset(options.view);
    } else if (AccountController.state.isConnected) {
      RouterController.reset("Account");
    } else {
      RouterController.reset("Connect");
    }
    state$9.open = true;
    PublicStateController.set({ open: true });
    EventsController.sendEvent({ type: "track", event: "MODAL_OPEN" });
  },
  close() {
    state$9.open = false;
    PublicStateController.set({ open: false });
    EventsController.sendEvent({ type: "track", event: "MODAL_CLOSE" });
  },
  setLoading(loading) {
    state$9.loading = loading;
  }
};
const baseUrl = CoreHelperUtil.getBlockchainApiUrl();
const api$2 = new FetchUtil({ baseUrl });
const BlockchainApiController = {
  fetchIdentity({ caipChainId, address }) {
    return api$2.get({
      path: `/v1/identity/${address}`,
      params: {
        chainId: caipChainId,
        projectId: OptionsController.state.projectId
      }
    });
  },
  fetchTransactions({ account, projectId, cursor }) {
    const queryParams = cursor ? { cursor } : {};
    return api$2.get({
      path: `/v1/account/${account}/history?projectId=${projectId}`,
      params: queryParams
    });
  }
};
const state$8 = proxy({
  message: "",
  variant: "success",
  open: false
});
const SnackController = {
  state: state$8,
  subscribeKey(key2, callback) {
    return subscribeKey(state$8, key2, callback);
  },
  showSuccess(message) {
    state$8.message = message;
    state$8.variant = "success";
    state$8.open = true;
  },
  showError(message) {
    const errorMessage = CoreHelperUtil.parseError(message);
    state$8.message = errorMessage;
    state$8.variant = "error";
    state$8.open = true;
  },
  hide() {
    state$8.open = false;
  }
};
const state$7 = proxy({
  transactions: [],
  transactionsByYear: {},
  loading: false,
  empty: false,
  next: void 0
});
const TransactionsController = {
  state: state$7,
  subscribe(callback) {
    return subscribe(state$7, () => callback(state$7));
  },
  async fetchTransactions(accountAddress) {
    const { projectId } = OptionsController.state;
    if (!projectId || !accountAddress) {
      throw new Error("Transactions can't be fetched without a projectId and an accountAddress");
    }
    state$7.loading = true;
    try {
      const response = await BlockchainApiController.fetchTransactions({
        account: accountAddress,
        projectId,
        cursor: state$7.next
      });
      const nonSpamTransactions = this.filterSpamTransactions(response.data);
      const filteredTransactions = [...state$7.transactions, ...nonSpamTransactions];
      state$7.loading = false;
      state$7.transactions = filteredTransactions;
      state$7.transactionsByYear = this.groupTransactionsByYear(state$7.transactionsByYear, nonSpamTransactions);
      state$7.empty = filteredTransactions.length === 0;
      state$7.next = response.next ? response.next : void 0;
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "ERROR_FETCH_TRANSACTIONS",
        properties: {
          address: accountAddress,
          projectId,
          cursor: state$7.next
        }
      });
      SnackController.showError("Failed to fetch transactions");
      state$7.loading = false;
      state$7.empty = true;
    }
  },
  groupTransactionsByYear(transactionsMap = {}, transactions = []) {
    const grouped = transactionsMap;
    transactions.forEach((transaction) => {
      const year = new Date(transaction.metadata.minedAt).getFullYear();
      if (!grouped[year]) {
        grouped[year] = [];
      }
      grouped[year]?.push(transaction);
    });
    return grouped;
  },
  filterSpamTransactions(transactions) {
    return transactions.filter((transaction) => {
      const isAllSpam = transaction.transfers.every((transfer) => transfer.nft_info?.flags.is_spam === true);
      return !isAllSpam;
    });
  },
  resetTransactions() {
    state$7.transactions = [];
    state$7.transactionsByYear = {};
    state$7.loading = false;
    state$7.empty = false;
    state$7.next = void 0;
  }
};
const state$6 = proxy({
  wcError: false,
  buffering: false
});
const ConnectionController = {
  state: state$6,
  subscribeKey(key2, callback) {
    return subscribeKey(state$6, key2, callback);
  },
  _getClient() {
    if (!state$6._client) {
      throw new Error("ConnectionController client not set");
    }
    return state$6._client;
  },
  setClient(client2) {
    state$6._client = ref(client2);
  },
  connectWalletConnect() {
    state$6.wcPromise = this._getClient().connectWalletConnect((uri) => {
      state$6.wcUri = uri;
      state$6.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
    });
  },
  async connectExternal(options) {
    await this._getClient().connectExternal?.(options);
    StorageUtil.setConnectedConnector(options.type);
  },
  async signMessage(message) {
    return this._getClient().signMessage(message);
  },
  checkInstalled(ids) {
    return this._getClient().checkInstalled?.(ids);
  },
  resetWcConnection() {
    state$6.wcUri = void 0;
    state$6.wcPairingExpiry = void 0;
    state$6.wcPromise = void 0;
    state$6.wcLinking = void 0;
    state$6.recentWallet = void 0;
    TransactionsController.resetTransactions();
    StorageUtil.deleteWalletConnectDeepLink();
  },
  setWcLinking(wcLinking) {
    state$6.wcLinking = wcLinking;
  },
  setWcError(wcError) {
    state$6.wcError = wcError;
    state$6.buffering = false;
  },
  setRecentWallet(wallet) {
    state$6.recentWallet = wallet;
  },
  setBuffering(buffering) {
    state$6.buffering = buffering;
  },
  async disconnect() {
    await this._getClient().disconnect();
    this.resetWcConnection();
  }
};
const state$5 = proxy({
  status: "uninitialized",
  isSiweEnabled: false
});
const SIWEController = {
  state: state$5,
  subscribeKey(key2, callback) {
    return subscribeKey(state$5, key2, callback);
  },
  subscribe(callback) {
    return subscribe(state$5, () => callback(state$5));
  },
  _getClient() {
    if (!state$5._client) {
      throw new Error("SIWEController client not set");
    }
    return state$5._client;
  },
  async getNonce() {
    const client2 = this._getClient();
    const nonce = await client2.getNonce();
    this.setNonce(nonce);
    return nonce;
  },
  async getSession() {
    const client2 = this._getClient();
    const session = await client2.getSession();
    if (session) {
      this.setSession(session);
      this.setStatus("success");
    }
    return session;
  },
  createMessage(args) {
    const client2 = this._getClient();
    const message = client2.createMessage(args);
    this.setMessage(message);
    return message;
  },
  async verifyMessage(args) {
    const client2 = this._getClient();
    const isValid3 = await client2.verifyMessage(args);
    return isValid3;
  },
  async signIn() {
    const client2 = this._getClient();
    const session = await client2.signIn();
    return session;
  },
  async signOut() {
    const client2 = this._getClient();
    await client2.signOut();
    this.setStatus("ready");
    client2.onSignOut?.();
  },
  onSignIn(args) {
    const client2 = this._getClient();
    client2.onSignIn?.(args);
  },
  onSignOut() {
    const client2 = this._getClient();
    client2.onSignOut?.();
  },
  setSIWEClient(client2) {
    state$5._client = ref(client2);
    state$5.status = "ready";
    state$5.isSiweEnabled = client2.options.enabled;
  },
  setNonce(nonce) {
    state$5.nonce = nonce;
  },
  setStatus(status) {
    state$5.status = status;
  },
  setMessage(message) {
    state$5.message = message;
  },
  setSession(session) {
    state$5.session = session;
  }
};
const state$4 = proxy({
  themeMode: "dark",
  themeVariables: {}
});
const ThemeController = {
  state: state$4,
  subscribe(callback) {
    return subscribe(state$4, () => callback(state$4));
  },
  setThemeMode(themeMode) {
    state$4.themeMode = themeMode;
  },
  setThemeVariables(themeVariables) {
    state$4.themeVariables = { ...state$4.themeVariables, ...themeVariables };
  },
  getSnapshot() {
    return snapshot(state$4);
  }
};
const AssetUtil = {
  getWalletImage(wallet) {
    if (wallet?.image_url) {
      return wallet?.image_url;
    }
    if (wallet?.image_id) {
      return AssetController.state.walletImages[wallet.image_id];
    }
    return void 0;
  },
  getNetworkImage(network) {
    if (network?.imageUrl) {
      return network?.imageUrl;
    }
    if (network?.imageId) {
      return AssetController.state.networkImages[network.imageId];
    }
    return void 0;
  },
  getConnectorImage(connector) {
    if (connector?.imageUrl) {
      return connector.imageUrl;
    }
    if (connector?.imageId) {
      return AssetController.state.connectorImages[connector.imageId];
    }
    return void 0;
  }
};
const RouterUtil = {
  goBackOrCloseModal() {
    if (RouterController.state.history.length > 1) {
      RouterController.goBack();
    } else {
      ModalController.close();
    }
  },
  navigateAfterNetworkSwitch() {
    const { history } = RouterController.state;
    const networkSelectIndex = history.findIndex((name2) => name2 === "Networks");
    if (networkSelectIndex >= 1) {
      RouterController.goBackToIndex(networkSelectIndex - 1);
    } else {
      ModalController.close();
    }
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$6 = globalThis, e$7 = t$6.ShadowRoot && (void 0 === t$6.ShadyCSS || t$6.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$5 = Symbol(), o$8 = /* @__PURE__ */ new WeakMap();
let n$7 = class n2 {
  constructor(t2, e2, o2) {
    if (this._$cssResult$ = true, o2 !== s$5)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2, this.t = e2;
  }
  get styleSheet() {
    let t2 = this.o;
    const s3 = this.t;
    if (e$7 && void 0 === t2) {
      const e2 = void 0 !== s3 && 1 === s3.length;
      e2 && (t2 = o$8.get(s3)), void 0 === t2 && ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText), e2 && o$8.set(s3, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
const r$9 = (t2) => new n$7("string" == typeof t2 ? t2 : t2 + "", void 0, s$5), i$7 = (t2, ...e2) => {
  const o2 = 1 === t2.length ? t2[0] : e2.reduce((e3, s3, o3) => e3 + ((t3) => {
    if (true === t3._$cssResult$)
      return t3.cssText;
    if ("number" == typeof t3)
      return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s3) + t2[o3 + 1], t2[0]);
  return new n$7(o2, t2, s$5);
}, S$7 = (s3, o2) => {
  if (e$7)
    s3.adoptedStyleSheets = o2.map((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet);
  else
    for (const e2 of o2) {
      const o3 = document.createElement("style"), n4 = t$6.litNonce;
      void 0 !== n4 && o3.setAttribute("nonce", n4), o3.textContent = e2.cssText, s3.appendChild(o3);
    }
}, c$6 = e$7 ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e2 = "";
  for (const s3 of t3.cssRules)
    e2 += s3.cssText;
  return r$9(e2);
})(t2) : t2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$6, defineProperty: e$6, getOwnPropertyDescriptor: r$8, getOwnPropertyNames: h$a, getOwnPropertySymbols: o$7, getPrototypeOf: n$6 } = Object, a$5 = globalThis, c$5 = a$5.trustedTypes, l$4 = c$5 ? c$5.emptyScript : "", p$8 = a$5.reactiveElementPolyfillSupport, d$5 = (t2, s3) => t2, u$6 = { toAttribute(t2, s3) {
  switch (s3) {
    case Boolean:
      t2 = t2 ? l$4 : null;
      break;
    case Object:
    case Array:
      t2 = null == t2 ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, s3) {
  let i3 = t2;
  switch (s3) {
    case Boolean:
      i3 = null !== t2;
      break;
    case Number:
      i3 = null === t2 ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        i3 = JSON.parse(t2);
      } catch (t3) {
        i3 = null;
      }
  }
  return i3;
} }, f$8 = (t2, s3) => !i$6(t2, s3), y$7 = { attribute: true, type: String, converter: u$6, reflect: false, hasChanged: f$8 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$5.litPropertyMetadata ?? (a$5.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let b$7 = class b2 extends HTMLElement {
  static addInitializer(t2) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t2);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t2, s3 = y$7) {
    if (s3.state && (s3.attribute = false), this._$Ei(), this.elementProperties.set(t2, s3), !s3.noAccessor) {
      const i3 = Symbol(), r2 = this.getPropertyDescriptor(t2, i3, s3);
      void 0 !== r2 && e$6(this.prototype, t2, r2);
    }
  }
  static getPropertyDescriptor(t2, s3, i3) {
    const { get: e2, set: h5 } = r$8(this.prototype, t2) ?? { get() {
      return this[s3];
    }, set(t3) {
      this[s3] = t3;
    } };
    return { get() {
      return e2?.call(this);
    }, set(s4) {
      const r2 = e2?.call(this);
      h5.call(this, s4), this.requestUpdate(t2, r2, i3);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) ?? y$7;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$5("elementProperties")))
      return;
    const t2 = n$6(this);
    t2.finalize(), void 0 !== t2.l && (this.l = [...t2.l]), this.elementProperties = new Map(t2.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$5("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d$5("properties"))) {
      const t3 = this.properties, s3 = [...h$a(t3), ...o$7(t3)];
      for (const i3 of s3)
        this.createProperty(i3, t3[i3]);
    }
    const t2 = this[Symbol.metadata];
    if (null !== t2) {
      const s3 = litPropertyMetadata.get(t2);
      if (void 0 !== s3)
        for (const [t3, i3] of s3)
          this.elementProperties.set(t3, i3);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t3, s3] of this.elementProperties) {
      const i3 = this._$Eu(t3, s3);
      void 0 !== i3 && this._$Eh.set(i3, t3);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s3) {
    const i3 = [];
    if (Array.isArray(s3)) {
      const e2 = new Set(s3.flat(1 / 0).reverse());
      for (const s4 of e2)
        i3.unshift(c$6(s4));
    } else
      void 0 !== s3 && i3.push(c$6(s3));
    return i3;
  }
  static _$Eu(t2, s3) {
    const i3 = s3.attribute;
    return false === i3 ? void 0 : "string" == typeof i3 ? i3 : "string" == typeof t2 ? t2.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$Eg = new Promise((t2) => this.enableUpdating = t2), this._$AL = /* @__PURE__ */ new Map(), this._$ES(), this.requestUpdate(), this.constructor.l?.forEach((t2) => t2(this));
  }
  addController(t2) {
    (this._$E_ ?? (this._$E_ = /* @__PURE__ */ new Set())).add(t2), void 0 !== this.renderRoot && this.isConnected && t2.hostConnected?.();
  }
  removeController(t2) {
    this._$E_?.delete(t2);
  }
  _$ES() {
    const t2 = /* @__PURE__ */ new Map(), s3 = this.constructor.elementProperties;
    for (const i3 of s3.keys())
      this.hasOwnProperty(i3) && (t2.set(i3, this[i3]), delete this[i3]);
    t2.size > 0 && (this._$Ep = t2);
  }
  createRenderRoot() {
    const t2 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$7(t2, this.constructor.elementStyles), t2;
  }
  connectedCallback() {
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), this._$E_?.forEach((t2) => t2.hostConnected?.());
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    this._$E_?.forEach((t2) => t2.hostDisconnected?.());
  }
  attributeChangedCallback(t2, s3, i3) {
    this._$AK(t2, i3);
  }
  _$EO(t2, s3) {
    const i3 = this.constructor.elementProperties.get(t2), e2 = this.constructor._$Eu(t2, i3);
    if (void 0 !== e2 && true === i3.reflect) {
      const r2 = (void 0 !== i3.converter?.toAttribute ? i3.converter : u$6).toAttribute(s3, i3.type);
      this._$Em = t2, null == r2 ? this.removeAttribute(e2) : this.setAttribute(e2, r2), this._$Em = null;
    }
  }
  _$AK(t2, s3) {
    const i3 = this.constructor, e2 = i3._$Eh.get(t2);
    if (void 0 !== e2 && this._$Em !== e2) {
      const t3 = i3.getPropertyOptions(e2), r2 = "function" == typeof t3.converter ? { fromAttribute: t3.converter } : void 0 !== t3.converter?.fromAttribute ? t3.converter : u$6;
      this._$Em = e2, this[e2] = r2.fromAttribute(s3, t3.type), this._$Em = null;
    }
  }
  requestUpdate(t2, s3, i3) {
    if (void 0 !== t2) {
      if (i3 ?? (i3 = this.constructor.getPropertyOptions(t2)), !(i3.hasChanged ?? f$8)(this[t2], s3))
        return;
      this.C(t2, s3, i3);
    }
    false === this.isUpdatePending && (this._$Eg = this._$EP());
  }
  C(t2, s3, i3) {
    this._$AL.has(t2) || this._$AL.set(t2, s3), true === i3.reflect && this._$Em !== t2 && (this._$ET ?? (this._$ET = /* @__PURE__ */ new Set())).add(t2);
  }
  async _$EP() {
    this.isUpdatePending = true;
    try {
      await this._$Eg;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [t4, s4] of this._$Ep)
          this[t4] = s4;
        this._$Ep = void 0;
      }
      const t3 = this.constructor.elementProperties;
      if (t3.size > 0)
        for (const [s4, i3] of t3)
          true !== i3.wrapped || this._$AL.has(s4) || void 0 === this[s4] || this.C(s4, this[s4], i3);
    }
    let t2 = false;
    const s3 = this._$AL;
    try {
      t2 = this.shouldUpdate(s3), t2 ? (this.willUpdate(s3), this._$E_?.forEach((t3) => t3.hostUpdate?.()), this.update(s3)) : this._$Ej();
    } catch (s4) {
      throw t2 = false, this._$Ej(), s4;
    }
    t2 && this._$AE(s3);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    this._$E_?.forEach((t3) => t3.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$Ej() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$Eg;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._$ET && (this._$ET = this._$ET.forEach((t3) => this._$EO(t3, this[t3]))), this._$Ej();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
};
b$7.elementStyles = [], b$7.shadowRootOptions = { mode: "open" }, b$7[d$5("elementProperties")] = /* @__PURE__ */ new Map(), b$7[d$5("finalized")] = /* @__PURE__ */ new Map(), p$8?.({ ReactiveElement: b$7 }), (a$5.reactiveElementVersions ?? (a$5.reactiveElementVersions = [])).push("2.0.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$5 = globalThis, i$5 = t$5.trustedTypes, s$4 = i$5 ? i$5.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0, e$5 = "$lit$", h$9 = `lit$${(Math.random() + "").slice(9)}$`, o$6 = "?" + h$9, n$5 = `<${o$6}>`, r$7 = document, l$3 = () => r$7.createComment(""), c$4 = (t2) => null === t2 || "object" != typeof t2 && "function" != typeof t2, a$4 = Array.isArray, u$5 = (t2) => a$4(t2) || "function" == typeof t2?.[Symbol.iterator], d$4 = "[ 	\n\f\r]", f$7 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v$7 = /-->/g, _$6 = />/g, m$6 = RegExp(`>|${d$4}(?:([^\\s"'>=/]+)(${d$4}*=${d$4}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p$7 = /'/g, g$7 = /"/g, $$4 = /^(?:script|style|textarea|title)$/i, y$6 = (t2) => (i3, ...s3) => ({ _$litType$: t2, strings: i3, values: s3 }), x$3 = y$6(1), b$6 = y$6(2), w$6 = Symbol.for("lit-noChange"), T$5 = Symbol.for("lit-nothing"), A$6 = /* @__PURE__ */ new WeakMap(), E$6 = r$7.createTreeWalker(r$7, 129);
function C$4(t2, i3) {
  if (!Array.isArray(t2) || !t2.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== s$4 ? s$4.createHTML(i3) : i3;
}
const P$6 = (t2, i3) => {
  const s3 = t2.length - 1, o2 = [];
  let r2, l2 = 2 === i3 ? "<svg>" : "", c2 = f$7;
  for (let i4 = 0; i4 < s3; i4++) {
    const s4 = t2[i4];
    let a3, u3, d3 = -1, y3 = 0;
    for (; y3 < s4.length && (c2.lastIndex = y3, u3 = c2.exec(s4), null !== u3); )
      y3 = c2.lastIndex, c2 === f$7 ? "!--" === u3[1] ? c2 = v$7 : void 0 !== u3[1] ? c2 = _$6 : void 0 !== u3[2] ? ($$4.test(u3[2]) && (r2 = RegExp("</" + u3[2], "g")), c2 = m$6) : void 0 !== u3[3] && (c2 = m$6) : c2 === m$6 ? ">" === u3[0] ? (c2 = r2 ?? f$7, d3 = -1) : void 0 === u3[1] ? d3 = -2 : (d3 = c2.lastIndex - u3[2].length, a3 = u3[1], c2 = void 0 === u3[3] ? m$6 : '"' === u3[3] ? g$7 : p$7) : c2 === g$7 || c2 === p$7 ? c2 = m$6 : c2 === v$7 || c2 === _$6 ? c2 = f$7 : (c2 = m$6, r2 = void 0);
    const x2 = c2 === m$6 && t2[i4 + 1].startsWith("/>") ? " " : "";
    l2 += c2 === f$7 ? s4 + n$5 : d3 >= 0 ? (o2.push(a3), s4.slice(0, d3) + e$5 + s4.slice(d3) + h$9 + x2) : s4 + h$9 + (-2 === d3 ? i4 : x2);
  }
  return [C$4(t2, l2 + (t2[s3] || "<?>") + (2 === i3 ? "</svg>" : "")), o2];
};
let V$5 = class V2 {
  constructor({ strings: t2, _$litType$: s3 }, n4) {
    let r2;
    this.parts = [];
    let c2 = 0, a3 = 0;
    const u3 = t2.length - 1, d3 = this.parts, [f4, v4] = P$6(t2, s3);
    if (this.el = V2.createElement(f4, n4), E$6.currentNode = this.el.content, 2 === s3) {
      const t3 = this.el.content.firstChild;
      t3.replaceWith(...t3.childNodes);
    }
    for (; null !== (r2 = E$6.nextNode()) && d3.length < u3; ) {
      if (1 === r2.nodeType) {
        if (r2.hasAttributes())
          for (const t3 of r2.getAttributeNames())
            if (t3.endsWith(e$5)) {
              const i3 = v4[a3++], s4 = r2.getAttribute(t3).split(h$9), e2 = /([.?@])?(.*)/.exec(i3);
              d3.push({ type: 1, index: c2, name: e2[2], strings: s4, ctor: "." === e2[1] ? k$7 : "?" === e2[1] ? H$5 : "@" === e2[1] ? I$4 : R$4 }), r2.removeAttribute(t3);
            } else
              t3.startsWith(h$9) && (d3.push({ type: 6, index: c2 }), r2.removeAttribute(t3));
        if ($$4.test(r2.tagName)) {
          const t3 = r2.textContent.split(h$9), s4 = t3.length - 1;
          if (s4 > 0) {
            r2.textContent = i$5 ? i$5.emptyScript : "";
            for (let i3 = 0; i3 < s4; i3++)
              r2.append(t3[i3], l$3()), E$6.nextNode(), d3.push({ type: 2, index: ++c2 });
            r2.append(t3[s4], l$3());
          }
        }
      } else if (8 === r2.nodeType)
        if (r2.data === o$6)
          d3.push({ type: 2, index: c2 });
        else {
          let t3 = -1;
          for (; -1 !== (t3 = r2.data.indexOf(h$9, t3 + 1)); )
            d3.push({ type: 7, index: c2 }), t3 += h$9.length - 1;
        }
      c2++;
    }
  }
  static createElement(t2, i3) {
    const s3 = r$7.createElement("template");
    return s3.innerHTML = t2, s3;
  }
};
function N$6(t2, i3, s3 = t2, e2) {
  if (i3 === w$6)
    return i3;
  let h5 = void 0 !== e2 ? s3._$Co?.[e2] : s3._$Cl;
  const o2 = c$4(i3) ? void 0 : i3._$litDirective$;
  return h5?.constructor !== o2 && (h5?._$AO?.(false), void 0 === o2 ? h5 = void 0 : (h5 = new o2(t2), h5._$AT(t2, s3, e2)), void 0 !== e2 ? (s3._$Co ?? (s3._$Co = []))[e2] = h5 : s3._$Cl = h5), void 0 !== h5 && (i3 = N$6(t2, h5._$AS(t2, i3.values), h5, e2)), i3;
}
let S$6 = class S2 {
  constructor(t2, i3) {
    this._$AV = [], this._$AN = void 0, this._$AD = t2, this._$AM = i3;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t2) {
    const { el: { content: i3 }, parts: s3 } = this._$AD, e2 = (t2?.creationScope ?? r$7).importNode(i3, true);
    E$6.currentNode = e2;
    let h5 = E$6.nextNode(), o2 = 0, n4 = 0, l2 = s3[0];
    for (; void 0 !== l2; ) {
      if (o2 === l2.index) {
        let i4;
        2 === l2.type ? i4 = new M$5(h5, h5.nextSibling, this, t2) : 1 === l2.type ? i4 = new l2.ctor(h5, l2.name, l2.strings, this, t2) : 6 === l2.type && (i4 = new L$5(h5, this, t2)), this._$AV.push(i4), l2 = s3[++n4];
      }
      o2 !== l2?.index && (h5 = E$6.nextNode(), o2++);
    }
    return E$6.currentNode = r$7, e2;
  }
  p(t2) {
    let i3 = 0;
    for (const s3 of this._$AV)
      void 0 !== s3 && (void 0 !== s3.strings ? (s3._$AI(t2, s3, i3), i3 += s3.strings.length - 2) : s3._$AI(t2[i3])), i3++;
  }
};
let M$5 = class M2 {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t2, i3, s3, e2) {
    this.type = 2, this._$AH = T$5, this._$AN = void 0, this._$AA = t2, this._$AB = i3, this._$AM = s3, this.options = e2, this._$Cv = e2?.isConnected ?? true;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i3 = this._$AM;
    return void 0 !== i3 && 11 === t2?.nodeType && (t2 = i3.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i3 = this) {
    t2 = N$6(this, t2, i3), c$4(t2) ? t2 === T$5 || null == t2 || "" === t2 ? (this._$AH !== T$5 && this._$AR(), this._$AH = T$5) : t2 !== this._$AH && t2 !== w$6 && this._(t2) : void 0 !== t2._$litType$ ? this.g(t2) : void 0 !== t2.nodeType ? this.$(t2) : u$5(t2) ? this.T(t2) : this._(t2);
  }
  k(t2) {
    return this._$AA.parentNode.insertBefore(t2, this._$AB);
  }
  $(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.k(t2));
  }
  _(t2) {
    this._$AH !== T$5 && c$4(this._$AH) ? this._$AA.nextSibling.data = t2 : this.$(r$7.createTextNode(t2)), this._$AH = t2;
  }
  g(t2) {
    const { values: i3, _$litType$: s3 } = t2, e2 = "number" == typeof s3 ? this._$AC(t2) : (void 0 === s3.el && (s3.el = V$5.createElement(C$4(s3.h, s3.h[0]), this.options)), s3);
    if (this._$AH?._$AD === e2)
      this._$AH.p(i3);
    else {
      const t3 = new S$6(e2, this), s4 = t3.u(this.options);
      t3.p(i3), this.$(s4), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i3 = A$6.get(t2.strings);
    return void 0 === i3 && A$6.set(t2.strings, i3 = new V$5(t2)), i3;
  }
  T(t2) {
    a$4(this._$AH) || (this._$AH = [], this._$AR());
    const i3 = this._$AH;
    let s3, e2 = 0;
    for (const h5 of t2)
      e2 === i3.length ? i3.push(s3 = new M2(this.k(l$3()), this.k(l$3()), this, this.options)) : s3 = i3[e2], s3._$AI(h5), e2++;
    e2 < i3.length && (this._$AR(s3 && s3._$AB.nextSibling, e2), i3.length = e2);
  }
  _$AR(t2 = this._$AA.nextSibling, i3) {
    for (this._$AP?.(false, true, i3); t2 && t2 !== this._$AB; ) {
      const i4 = t2.nextSibling;
      t2.remove(), t2 = i4;
    }
  }
  setConnected(t2) {
    void 0 === this._$AM && (this._$Cv = t2, this._$AP?.(t2));
  }
};
let R$4 = class R2 {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t2, i3, s3, e2, h5) {
    this.type = 1, this._$AH = T$5, this._$AN = void 0, this.element = t2, this.name = i3, this._$AM = e2, this.options = h5, s3.length > 2 || "" !== s3[0] || "" !== s3[1] ? (this._$AH = Array(s3.length - 1).fill(new String()), this.strings = s3) : this._$AH = T$5;
  }
  _$AI(t2, i3 = this, s3, e2) {
    const h5 = this.strings;
    let o2 = false;
    if (void 0 === h5)
      t2 = N$6(this, t2, i3, 0), o2 = !c$4(t2) || t2 !== this._$AH && t2 !== w$6, o2 && (this._$AH = t2);
    else {
      const e3 = t2;
      let n4, r2;
      for (t2 = h5[0], n4 = 0; n4 < h5.length - 1; n4++)
        r2 = N$6(this, e3[s3 + n4], i3, n4), r2 === w$6 && (r2 = this._$AH[n4]), o2 || (o2 = !c$4(r2) || r2 !== this._$AH[n4]), r2 === T$5 ? t2 = T$5 : t2 !== T$5 && (t2 += (r2 ?? "") + h5[n4 + 1]), this._$AH[n4] = r2;
    }
    o2 && !e2 && this.O(t2);
  }
  O(t2) {
    t2 === T$5 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t2 ?? "");
  }
};
let k$7 = class k2 extends R$4 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  O(t2) {
    this.element[this.name] = t2 === T$5 ? void 0 : t2;
  }
};
let H$5 = class H2 extends R$4 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  O(t2) {
    this.element.toggleAttribute(this.name, !!t2 && t2 !== T$5);
  }
};
let I$4 = class I2 extends R$4 {
  constructor(t2, i3, s3, e2, h5) {
    super(t2, i3, s3, e2, h5), this.type = 5;
  }
  _$AI(t2, i3 = this) {
    if ((t2 = N$6(this, t2, i3, 0) ?? T$5) === w$6)
      return;
    const s3 = this._$AH, e2 = t2 === T$5 && s3 !== T$5 || t2.capture !== s3.capture || t2.once !== s3.once || t2.passive !== s3.passive, h5 = t2 !== T$5 && (s3 === T$5 || e2);
    e2 && this.element.removeEventListener(this.name, this, s3), h5 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t2) : this._$AH.handleEvent(t2);
  }
};
let L$5 = class L2 {
  constructor(t2, i3, s3) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i3, this.options = s3;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    N$6(this, t2);
  }
};
const Z$3 = t$5.litHtmlPolyfillSupport;
Z$3?.(V$5, M$5), (t$5.litHtmlVersions ?? (t$5.litHtmlVersions = [])).push("3.1.1");
const j$5 = (t2, i3, s3) => {
  const e2 = s3?.renderBefore ?? i3;
  let h5 = e2._$litPart$;
  if (void 0 === h5) {
    const t3 = s3?.renderBefore ?? null;
    e2._$litPart$ = h5 = new M$5(i3.insertBefore(l$3(), t3), t3, void 0, s3 ?? {});
  }
  return h5._$AI(t2), h5;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$3 = class s2 extends b$7 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var _a2;
    const t2 = super.createRenderRoot();
    return (_a2 = this.renderOptions).renderBefore ?? (_a2.renderBefore = t2.firstChild), t2;
  }
  update(t2) {
    const i3 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Do = j$5(i3, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(false);
  }
  render() {
    return w$6;
  }
};
s$3._$litElement$ = true, s$3["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: s$3 });
const r$6 = globalThis.litElementPolyfillSupport;
r$6?.({ LitElement: s$3 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.3");
let themeTag = void 0;
let darkModeTag = void 0;
let lightModeTag = void 0;
function initializeTheming(themeVariables, themeMode) {
  themeTag = document.createElement("style");
  darkModeTag = document.createElement("style");
  lightModeTag = document.createElement("style");
  themeTag.textContent = createRootStyles(themeVariables).core.cssText;
  darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
  lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  document.head.appendChild(themeTag);
  document.head.appendChild(darkModeTag);
  document.head.appendChild(lightModeTag);
  setColorTheme(themeMode);
}
function setColorTheme(themeMode) {
  if (darkModeTag && lightModeTag) {
    if (themeMode === "light") {
      darkModeTag.removeAttribute("media");
      lightModeTag.media = "enabled";
    } else {
      lightModeTag.removeAttribute("media");
      darkModeTag.media = "enabled";
    }
  }
}
function setThemeVariables(themeVariables) {
  if (themeTag && darkModeTag && lightModeTag) {
    themeTag.textContent = createRootStyles(themeVariables).core.cssText;
    darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
    lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  }
}
function createRootStyles(themeVariables) {
  return {
    core: i$7`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      :root {
        --w3m-color-mix-strength: ${r$9(themeVariables?.["--w3m-color-mix-strength"] ? `${themeVariables["--w3m-color-mix-strength"]}%` : "0%")};
        --w3m-font-family: ${r$9(themeVariables?.["--w3m-font-family"] || "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
        --w3m-font-size-master: ${r$9(themeVariables?.["--w3m-font-size-master"] || "10px")};
        --w3m-border-radius-master: ${r$9(themeVariables?.["--w3m-border-radius-master"] || "4px")};
        --w3m-z-index: ${r$9(themeVariables?.["--w3m-z-index"] || 100)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-blue-100: var(--wui-color-blue-base-100);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-accent-glass-090: var(--wui-accent-glass-base-090);
        --wui-accent-glass-080: var(--wui-accent-glass-base-080);
        --wui-accent-glass-020: var(--wui-accent-glass-base-020);
        --wui-accent-glass-015: var(--wui-accent-glass-base-015);
        --wui-accent-glass-010: var(--wui-accent-glass-base-010);
        --wui-accent-glass-005: var(--wui-accent-glass-base-005);
        --wui-accent-glass-002: var(--wui-accent-glass-base-002);

        --wui-color-fg-100: var(--wui-color-fg-base-100);
        --wui-color-fg-125: var(--wui-color-fg-base-125);
        --wui-color-fg-150: var(--wui-color-fg-base-150);
        --wui-color-fg-175: var(--wui-color-fg-base-175);
        --wui-color-fg-200: var(--wui-color-fg-base-200);
        --wui-color-fg-225: var(--wui-color-fg-base-225);
        --wui-color-fg-250: var(--wui-color-fg-base-250);
        --wui-color-fg-275: var(--wui-color-fg-base-275);
        --wui-color-fg-300: var(--wui-color-fg-base-300);

        --wui-color-bg-100: var(--wui-color-bg-base-100);
        --wui-color-bg-125: var(--wui-color-bg-base-125);
        --wui-color-bg-150: var(--wui-color-bg-base-150);
        --wui-color-bg-175: var(--wui-color-bg-base-175);
        --wui-color-bg-200: var(--wui-color-bg-base-200);
        --wui-color-bg-225: var(--wui-color-bg-base-225);
        --wui-color-bg-250: var(--wui-color-bg-base-250);
        --wui-color-bg-275: var(--wui-color-bg-base-275);
        --wui-color-bg-300: var(--wui-color-bg-base-300);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-error-100: var(--wui-color-error-base-100);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-base-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-box-shadow-blue: rgba(71, 161, 255, 0.16);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 16%, transparent);

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            var(--w3m-default)
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            var(--w3m-default)
          );

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );

          --wui-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-300)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-300)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-base-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );
        }
      }
    `,
    light: i$7`
      :root {
        --w3m-color-mix: ${r$9(themeVariables?.["--w3m-color-mix"] || "#fff")};
        --w3m-accent: ${r$9(themeVariables?.["--w3m-accent"] || "#47a1ff")};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: #191a1a;

        --wui-color-blue-base-100: #47a1ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #59aaff;
        --wui-color-accent-base-080: #6cb4ff;

        --wui-accent-glass-base-090: rgba(71, 161, 255, 0.9);
        --wui-accent-glass-base-080: rgba(71, 161, 255, 0.8);
        --wui-accent-glass-base-020: rgba(71, 161, 255, 0.2);
        --wui-accent-glass-base-015: rgba(71, 161, 255, 0.15);
        --wui-accent-glass-base-010: rgba(71, 161, 255, 0.1);
        --wui-accent-glass-base-005: rgba(71, 161, 255, 0.05);
        --wui-accent-glass-base-002: rgba(71, 161, 255, 0.02);

        --wui-color-fg-base-100: #e4e7e7;
        --wui-color-fg-base-125: #d0d5d5;
        --wui-color-fg-base-150: #a8b1b1;
        --wui-color-fg-base-175: #a8b0b0;
        --wui-color-fg-base-200: #949e9e;
        --wui-color-fg-base-225: #868f8f;
        --wui-color-fg-base-250: #788080;
        --wui-color-fg-base-275: #788181;
        --wui-color-fg-base-300: #6e7777;

        --wui-color-bg-base-100: #141414;
        --wui-color-bg-base-125: #191a1a;
        --wui-color-bg-base-150: #1e1f1f;
        --wui-color-bg-base-175: #222525;
        --wui-color-bg-base-200: #272a2a;
        --wui-color-bg-base-225: #2c3030;
        --wui-color-bg-base-250: #313535;
        --wui-color-bg-base-275: #363b3b;
        --wui-color-bg-base-300: #3b4040;

        --wui-color-success-base-100: #26d962;
        --wui-color-error-base-100: #f25a67;

        --wui-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: var(--wui-success-glass-015);
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-base-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-gray-glass-080: rgba(255, 255, 255, 0.8);
      }
    `,
    dark: i$7`
      :root {
        --w3m-color-mix: ${r$9(themeVariables?.["--w3m-color-mix"] || "#000")};
        --w3m-accent: ${r$9(themeVariables?.["--w3m-accent"] || "#3396ff")};
        --w3m-default: #000;

        --wui-color-modal-bg-base: #fff;

        --wui-color-blue-base-100: #3396ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #2d7dd2;
        --wui-color-accent-base-080: #2978cc;

        --wui-accent-glass-base-090: rgba(51, 150, 255, 0.9);
        --wui-accent-glass-base-080: rgba(51, 150, 255, 0.8);
        --wui-accent-glass-base-020: rgba(51, 150, 255, 0.2);
        --wui-accent-glass-base-015: rgba(51, 150, 255, 0.15);
        --wui-accent-glass-base-010: rgba(51, 150, 255, 0.1);
        --wui-accent-glass-base-005: rgba(51, 150, 255, 0.05);
        --wui-accent-glass-base-002: rgba(51, 150, 255, 0.02);

        --wui-color-fg-base-100: #141414;
        --wui-color-fg-base-125: #2d3131;
        --wui-color-fg-base-150: #474d4d;
        --wui-color-fg-base-175: #636d6d;
        --wui-color-fg-base-200: #798686;
        --wui-color-fg-base-225: #828f8f;
        --wui-color-fg-base-250: #8b9797;
        --wui-color-fg-base-275: #95a0a0;
        --wui-color-fg-base-300: #9ea9a9;

        --wui-color-bg-base-100: #ffffff;
        --wui-color-bg-base-125: #f5fafa;
        --wui-color-bg-base-150: #f3f8f8;
        --wui-color-bg-base-175: #eef4f4;
        --wui-color-bg-base-200: #eaf1f1;
        --wui-color-bg-base-225: #e5eded;
        --wui-color-bg-base-250: #e1e9e9;
        --wui-color-bg-base-275: #dce7e7;
        --wui-color-bg-base-300: #d8e3e3;

        --wui-color-success-base-100: #26b562;
        --wui-color-error-base-100: #f05142;

        --wui-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-base-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-gray-glass-080: rgba(0, 0, 0, 0.8);
      }
    `
  };
}
const resetStyles = i$7`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`;
const elementStyles = i$7`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    outline: none;
    border: 1px solid transparent;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-005);
    }

    button:active:enabled {
      transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
      background-color: var(--wui-gray-glass-010);
    }

    button[data-variant='fill']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='accentBg']:hover:enabled {
      background: var(--wui-accent-glass-015);
    }

    button[data-variant='accentBg']:active:enabled {
      background: var(--wui-accent-glass-020);
    }
  }

  button:disabled {
    cursor: not-allowed;
    background-color: var(--wui-gray-glass-005);
  }

  button[data-variant='shade']:disabled,
  button[data-variant='accent']:disabled,
  button[data-variant='accentBg']:disabled {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-gray-glass-015);
    filter: grayscale(1);
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  button:focus-visible,
  a:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  button[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  button[data-variant='fill']:disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
  }

  button[data-variant='fill']:disabled > wui-icon {
    color: var(--wui-gray-glass-015);
  }

  button[data-variant='shade'] {
    color: var(--wui-color-fg-200);
  }

  button[data-variant='accent'],
  button[data-variant='accentBg'] {
    color: var(--wui-color-accent-100);
  }

  button[data-variant='accentBg'] {
    background: var(--wui-accent-glass-010);
    border: 1px solid var(--wui-accent-glass-010);
  }

  button[data-variant='fullWidth'] {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    height: 56px;
    border: none;
    background-color: var(--wui-gray-glass-002);
    color: var(--wui-color-fg-200);
    gap: var(--wui-spacing-xs);
  }

  button:active:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  button[data-variant='fill']:active:enabled {
    background-color: var(--wui-color-accent-080);
    border: 1px solid var(--wui-gray-glass-010);
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;
const colorStyles = i$7`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }
`;
function standardCustomElement(tagName, descriptor) {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    finisher(clazz) {
      if (!customElements.get(tagName)) {
        customElements.define(tagName, clazz);
      }
    }
  };
}
function legacyCustomElement(tagName, clazz) {
  if (!customElements.get(tagName)) {
    customElements.define(tagName, clazz);
  }
  return clazz;
}
function customElement(tagName) {
  return function create5(classOrDescriptor) {
    return typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
  };
}
const styles$19 = i$7`
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }
`;
var __decorate$1s = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCard = class WuiCard2 extends s$3 {
  render() {
    return x$3`<slot></slot>`;
  }
};
WuiCard.styles = [resetStyles, styles$19];
WuiCard = __decorate$1s([
  customElement("wui-card")
], WuiCard);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$5 = { attribute: true, type: String, converter: u$6, reflect: false, hasChanged: f$8 }, r$5 = (t2 = o$5, e2, r2) => {
  const { kind: n4, metadata: i3 } = r2;
  let s3 = globalThis.litPropertyMetadata.get(i3);
  if (void 0 === s3 && globalThis.litPropertyMetadata.set(i3, s3 = /* @__PURE__ */ new Map()), s3.set(r2.name, t2), "accessor" === n4) {
    const { name: o2 } = r2;
    return { set(r3) {
      const n5 = e2.get.call(this);
      e2.set.call(this, r3), this.requestUpdate(o2, n5, t2);
    }, init(e3) {
      return void 0 !== e3 && this.C(o2, void 0, t2), e3;
    } };
  }
  if ("setter" === n4) {
    const { name: o2 } = r2;
    return function(r3) {
      const n5 = this[o2];
      e2.call(this, r3), this.requestUpdate(o2, n5, t2);
    };
  }
  throw Error("Unsupported decorator location: " + n4);
};
function n$4(t2) {
  return (e2, o2) => "object" == typeof o2 ? r$5(t2, e2, o2) : ((t3, e3, o3) => {
    const r2 = e3.hasOwnProperty(o3);
    return e3.constructor.createProperty(o3, r2 ? { ...t3, wrapped: true } : t3), r2 ? Object.getOwnPropertyDescriptor(e3, o3) : void 0;
  })(t2, e2, o2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$4(r2) {
  return n$4({ ...r2, state: true, attribute: false });
}
const styles$18 = i$7`
  :host {
    display: flex;
    aspect-ratio: 1 / 1;
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }
`;
const allWalletsSvg = b$6`<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`;
const appStoreSvg = b$6`
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`;
const appleSvg = b$6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const arrowBottomSvg = b$6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowLeftSvg = b$6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowRightSvg = b$6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowTopSvg = b$6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
const browserSvg$1 = b$6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const checkmarkSvg = b$6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M12.04 2.65c.47.3.6.91.3 1.38l-5.78 9a1 1 0 0 1-1.61.1L1.73 9.27A1 1 0 1 1 3.27 8L5.6 10.8l5.05-7.85a1 1 0 0 1 1.38-.3Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronBottomSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronLeftSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronRightSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronTopSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const chromeStoreSvg = b$6`<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`;
const clockSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 2.99a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-7 5a7 7 0 1 1 14 0 7 7 0 0 1-14 0Zm7-4a1 1 0 0 1 1 1v2.58l1.85 1.85a1 1 0 0 1-1.41 1.42L6.29 8.69A1 1 0 0 1 6 8v-3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const closeSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const coinPlaceholderSvg = b$6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`;
const compassSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`;
const copySvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.5 0h1.67c.68 0 1.26 0 1.73.04.5.05.97.14 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73V6.5c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.43.03-.95.03-1.57.03 0 .62 0 1.14-.04 1.57-.04.5-.14.97-.4 1.42-.29.52-.72.95-1.24 1.24-.44.26-.92.35-1.41.4-.48.04-1.05.04-1.74.04H4.83c-.68 0-1.26 0-1.73-.04-.5-.05-.97-.14-1.42-.4-.52-.3-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.42A20.9 20.9 0 0 1 0 11.17V9.5c0-.69 0-1.26.04-1.74.05-.5.14-.97.4-1.41.3-.52.72-.95 1.24-1.25.45-.25.92-.35 1.42-.4.43-.03.95-.03 1.57-.03 0-.62 0-1.14.04-1.57.04-.5.14-.97.4-1.42.29-.52.72-.95 1.24-1.24.44-.26.92-.35 1.41-.4A20.9 20.9 0 0 1 9.5 0ZM4.67 6.67c-.63 0-1.06 0-1.4.03-.35.03-.5.09-.6.14-.2.12-.38.3-.5.5-.05.1-.1.24-.14.6C2 8.32 2 8.8 2 9.54v1.59c0 .73 0 1.22.03 1.6.04.35.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h1.58c.74 0 1.22 0 1.6-.03.36-.04.5-.1.6-.15.2-.11.38-.29.5-.5.05-.09.1-.24.14-.6.03-.33.03-.76.03-1.39-.6 0-1.13 0-1.57-.04-.5-.04-.97-.14-1.41-.4-.52-.29-.95-.72-1.25-1.24a3.39 3.39 0 0 1-.4-1.41c-.03-.44-.03-.96-.03-1.57Zm3.27-4.64c-.36.04-.5.1-.6.15-.2.11-.38.29-.5.5-.05.09-.1.24-.14.6-.03.37-.03.86-.03 1.6v1.58c0 .74 0 1.22.03 1.6.03.36.09.5.14.6.12.2.3.38.5.5.1.05.24.1.6.14.38.03.86.03 1.6.03h1.59c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6V4.87c0-.73 0-1.22-.03-1.6a1.46 1.46 0 0 0-.15-.6c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.14-.37-.03-.86-.03-1.6-.03H9.55c-.74 0-1.22 0-1.6.03Z"
    clip-rule="evenodd"
  />
</svg>`;
const cursorSvg = b$6` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`;
const desktopSvg = b$6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`;
const disconnectSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const discordSvg = b$6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`;
const etherscanSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`;
const extensionSvg = b$6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`;
const externalLinkSvg = b$6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const facebookSvg = b$6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const filtersSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const githubSvg = b$6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const googleSvg = b$6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#fff" fill-opacity=".05" />
      <g clip-path="url(#c)">
        <path
          fill="#4285F4"
          d="M20 17.7v4.65h6.46a5.53 5.53 0 0 1-2.41 3.61l3.9 3.02c2.26-2.09 3.57-5.17 3.57-8.82 0-.85-.08-1.67-.22-2.46H20Z"
        />
        <path
          fill="#34A853"
          d="m13.27 22.17-.87.67-3.11 2.42A12 12 0 0 0 20 31.9c3.24 0 5.96-1.07 7.94-2.9l-3.9-3.03A7.15 7.15 0 0 1 20 27.12a7.16 7.16 0 0 1-6.72-4.94v-.01Z"
        />
        <path
          fill="#FBBC05"
          d="M9.29 14.5a11.85 11.85 0 0 0 0 10.76l3.99-3.1a7.19 7.19 0 0 1 0-4.55l-4-3.1Z"
        />
        <path
          fill="#EA4335"
          d="M20 12.66c1.77 0 3.34.61 4.6 1.8l3.43-3.44A11.51 11.51 0 0 0 20 7.89c-4.7 0-8.74 2.69-10.71 6.62l3.99 3.1A7.16 7.16 0 0 1 20 12.66Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const helpCircleSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`;
const infoCircleSvg = b$6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const mailSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`;
const mobileSvg = b$6`<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`;
const networkPlaceholderSvg = b$6`<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`;
const nftPlaceholderSvg = b$6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const offSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
    clip-rule="evenodd"
  />
</svg>`;
const playStoreSvg = b$6` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`;
const qrCodeIcon = b$6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`;
const refreshSvg = b$6`<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`;
const searchSvg = b$6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapHorizontalSvg = b$6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapHorizontalBoldSvg = b$6`<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapVerticalSvg = b$6`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const telegramSvg = b$6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg> `;
const twitchSvg = b$6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const twitterSvg = b$6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1D9BF0" />
      <path
        fill="#fff"
        d="M30 13.81c-.74.33-1.53.55-2.36.65.85-.51 1.5-1.32 1.8-2.27-.79.47-1.66.8-2.6 1a4.1 4.1 0 0 0-7 3.73c-3.4-.17-6.42-1.8-8.45-4.28a4.1 4.1 0 0 0 1.27 5.47c-.67-.02-1.3-.2-1.86-.5a4.1 4.1 0 0 0 3.3 4.07c-.58.15-1.21.19-1.86.07a4.1 4.1 0 0 0 3.83 2.85A8.25 8.25 0 0 1 10 26.3a11.62 11.62 0 0 0 6.29 1.84c7.62 0 11.92-6.44 11.66-12.2.8-.59 1.5-1.3 2.05-2.13Z"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`;
const twitterIconSvg = b$6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`;
const verifySvg = b$6`<svg fill="none" viewBox="0 0 28 28">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const verifyFilledSvg = b$6`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.7.07-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
    clip-rule="evenodd"
  />
</svg>`;
const walletPlaceholderSvg = b$6`
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`;
const walletSvg = b$6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`;
const walletConnectSvg = b$6`<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`;
const warningCircleSvg = b$6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const alphaSvg = b$6`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="12" viewBox="0 0 14 12" fill="none">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.687 0.557043C11.1462 0.671832 11.4254 1.13706 11.3106 1.59615C11.2044 2.02082 11.0975 2.51184 10.9822 3.04102C10.7176 4.25623 10.4091 5.6727 9.96482 6.94907C10.1435 7.58939 10.3065 8.16905 10.4935 8.68429C10.6447 9.10072 10.7858 9.39487 10.9179 9.58289C11.0055 9.70747 11.0597 9.74443 11.0748 9.75277C11.096 9.75724 11.1075 9.75764 11.1531 9.71916C11.2342 9.65067 11.3386 9.50891 11.4426 9.28357C11.5416 9.06892 11.614 8.8366 11.662 8.6497C11.6854 8.55831 11.7019 8.48242 11.7122 8.43111C11.7174 8.40555 11.7209 8.38638 11.723 8.37476L11.725 8.36363C11.8 7.89659 12.2395 7.57864 12.7068 7.65342C13.1742 7.72822 13.4925 8.16766 13.4177 8.63494C13.4153 8.64924 13.42 8.62063 13.4177 8.63494L13.4175 8.63596L13.4173 8.63721L13.4168 8.64037L13.4153 8.64924L13.4105 8.67692C13.4064 8.69961 13.4006 8.73069 13.3929 8.76891C13.3776 8.84516 13.3545 8.95091 13.3224 9.07586C13.2593 9.32166 13.1564 9.66085 12.9992 10.0015C12.8469 10.3315 12.6139 10.7288 12.2595 11.0282C11.8757 11.3523 11.35 11.5553 10.7293 11.4312C10.1645 11.3183 9.77597 10.939 9.51527 10.5681C9.2535 10.1957 9.05129 9.7349 8.88212 9.26898C8.87877 9.25975 8.87542 9.25049 8.87208 9.2412C8.03954 10.4941 6.83375 11.4479 5.03926 11.4479C3.48049 11.4479 2.31021 10.7159 1.56788 9.63945C0.846767 8.5938 0.544023 7.25403 0.573206 5.9702C0.60242 4.68505 0.966023 3.36073 1.69055 2.33272C2.42915 1.28475 3.5614 0.531453 5.03927 0.531453C6.44937 0.531453 7.4408 1.29593 8.1276 2.27567C8.48261 2.7821 8.77248 3.36668 9.0177 3.97383C9.1059 3.59106 9.18901 3.20908 9.27086 2.83294C9.39492 2.26277 9.51606 1.70605 9.64752 1.18046C9.76235 0.721369 10.2277 0.442254 10.687 0.557043ZM8.16354 6.87693C8.08689 6.60534 8.01003 6.33741 7.93241 6.08076C7.59522 4.96581 7.22132 3.969 6.72371 3.25914C6.24674 2.57873 5.72135 2.24516 5.03927 2.24516C4.21565 2.24516 3.56947 2.6422 3.09195 3.31975C2.60035 4.01725 2.31013 4.99361 2.28705 6.00913C2.26393 7.02599 2.51041 7.9869 2.97927 8.66676C3.42691 9.31586 4.08734 9.73417 5.03926 9.73417C6.48097 9.73417 7.4216 8.72164 8.14437 6.9249C8.15079 6.90893 8.15718 6.89294 8.16354 6.87693Z" fill="#47A1FF"/>
</svg>`;
var __decorate$1r = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const svgOptions$1 = {
  allWallets: allWalletsSvg,
  alpha: alphaSvg,
  appStore: appStoreSvg,
  chromeStore: chromeStoreSvg,
  apple: appleSvg,
  arrowBottom: arrowBottomSvg,
  arrowLeft: arrowLeftSvg,
  arrowRight: arrowRightSvg,
  arrowTop: arrowTopSvg,
  browser: browserSvg$1,
  checkmark: checkmarkSvg,
  chevronBottom: chevronBottomSvg,
  chevronLeft: chevronLeftSvg,
  chevronRight: chevronRightSvg,
  chevronTop: chevronTopSvg,
  clock: clockSvg,
  close: closeSvg,
  compass: compassSvg,
  coinPlaceholder: coinPlaceholderSvg,
  copy: copySvg,
  cursor: cursorSvg,
  desktop: desktopSvg,
  disconnect: disconnectSvg,
  discord: discordSvg,
  etherscan: etherscanSvg,
  extension: extensionSvg,
  externalLink: externalLinkSvg,
  facebook: facebookSvg,
  filters: filtersSvg,
  github: githubSvg,
  google: googleSvg,
  helpCircle: helpCircleSvg,
  infoCircle: infoCircleSvg,
  mail: mailSvg,
  mobile: mobileSvg,
  networkPlaceholder: networkPlaceholderSvg,
  nftPlaceholder: nftPlaceholderSvg,
  off: offSvg,
  playStore: playStoreSvg,
  qrCode: qrCodeIcon,
  refresh: refreshSvg,
  search: searchSvg,
  swapHorizontal: swapHorizontalSvg,
  swapHorizontalBold: swapHorizontalBoldSvg,
  swapVertical: swapVerticalSvg,
  telegram: telegramSvg,
  twitch: twitchSvg,
  twitter: twitterSvg,
  twitterIcon: twitterIconSvg,
  verify: verifySvg,
  verifyFilled: verifyFilledSvg,
  wallet: walletSvg,
  walletConnect: walletConnectSvg,
  walletPlaceholder: walletPlaceholderSvg,
  warningCircle: warningCircleSvg
};
let WuiIcon = class WuiIcon2 extends s$3 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "copy";
    this.color = "fg-300";
  }
  render() {
    this.style.cssText = `
      --local-color: ${`var(--wui-color-${this.color});`}
      --local-width: ${`var(--wui-icon-size-${this.size});`}
    `;
    return x$3`${svgOptions$1[this.name]}`;
  }
};
WuiIcon.styles = [resetStyles, colorStyles, styles$18];
__decorate$1r([
  n$4()
], WuiIcon.prototype, "size", void 0);
__decorate$1r([
  n$4()
], WuiIcon.prototype, "name", void 0);
__decorate$1r([
  n$4()
], WuiIcon.prototype, "color", void 0);
WuiIcon = __decorate$1r([
  customElement("wui-icon")
], WuiIcon);
const styles$17 = i$7`
  :host {
    display: block;
    width: 100%;
    height: 100%;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
  }
`;
var __decorate$1q = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiImage = class WuiImage2 extends s$3 {
  constructor() {
    super(...arguments);
    this.src = "./path/to/image.jpg";
    this.alt = "Image";
  }
  render() {
    return x$3`<img src=${this.src} alt=${this.alt} />`;
  }
};
WuiImage.styles = [resetStyles, colorStyles, styles$17];
__decorate$1q([
  n$4()
], WuiImage.prototype, "src", void 0);
__decorate$1q([
  n$4()
], WuiImage.prototype, "alt", void 0);
WuiImage = __decorate$1q([
  customElement("wui-image")
], WuiImage);
const styles$16 = i$7`
  :host {
    display: block;
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
  }

  svg {
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
    fill: none;
    stroke: transparent;
    stroke-linecap: round;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  use {
    stroke: var(--wui-color-accent-100);
    stroke-width: 2px;
    stroke-dasharray: 54, 118;
    stroke-dashoffset: 172;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$1p = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLoadingHexagon = class WuiLoadingHexagon2 extends s$3 {
  render() {
    return x$3`
      <svg viewBox="0 0 54 59">
        <path
          id="wui-loader-path"
          d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
        />
        <use xlink:href="#wui-loader-path"></use>
      </svg>
    `;
  }
};
WuiLoadingHexagon.styles = [resetStyles, styles$16];
WuiLoadingHexagon = __decorate$1p([
  customElement("wui-loading-hexagon")
], WuiLoadingHexagon);
const styles$15 = i$7`
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 2s linear infinite;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`;
var __decorate$1o = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLoadingSpinner = class WuiLoadingSpinner2 extends s$3 {
  constructor() {
    super(...arguments);
    this.color = "accent-100";
    this.size = "lg";
  }
  render() {
    this.style.cssText = `--local-color: var(--wui-color-${this.color});`;
    this.dataset["size"] = this.size;
    return x$3`<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`;
  }
};
WuiLoadingSpinner.styles = [resetStyles, styles$15];
__decorate$1o([
  n$4()
], WuiLoadingSpinner.prototype, "color", void 0);
__decorate$1o([
  n$4()
], WuiLoadingSpinner.prototype, "size", void 0);
WuiLoadingSpinner = __decorate$1o([
  customElement("wui-loading-spinner")
], WuiLoadingSpinner);
const styles$14 = i$7`
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$1n = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLoadingThumbnail = class WuiLoadingThumbnail2 extends s$3 {
  constructor() {
    super(...arguments);
    this.radius = 36;
  }
  render() {
    return this.svgLoaderTemplate();
  }
  svgLoaderTemplate() {
    const radius = this.radius > 50 ? 50 : this.radius;
    const standardValue = 36;
    const radiusFactor = standardValue - radius;
    const dashArrayStart = 116 + radiusFactor;
    const dashArrayEnd = 245 + radiusFactor;
    const dashOffset = 360 + radiusFactor * 1.75;
    return x$3`
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${radius}
          stroke-dasharray="${dashArrayStart} ${dashArrayEnd}"
          stroke-dashoffset=${dashOffset}
        />
      </svg>
    `;
  }
};
WuiLoadingThumbnail.styles = [resetStyles, styles$14];
__decorate$1n([
  n$4({ type: Number })
], WuiLoadingThumbnail.prototype, "radius", void 0);
WuiLoadingThumbnail = __decorate$1n([
  customElement("wui-loading-thumbnail")
], WuiLoadingThumbnail);
const styles$13 = i$7`
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`;
var __decorate$1m = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiShimmer = class WuiShimmer2 extends s$3 {
  constructor() {
    super(...arguments);
    this.width = "";
    this.height = "";
    this.borderRadius = "m";
  }
  render() {
    this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: ${`clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px)`};
    `;
    return x$3`<slot></slot>`;
  }
};
WuiShimmer.styles = [styles$13];
__decorate$1m([
  n$4()
], WuiShimmer.prototype, "width", void 0);
__decorate$1m([
  n$4()
], WuiShimmer.prototype, "height", void 0);
__decorate$1m([
  n$4()
], WuiShimmer.prototype, "borderRadius", void 0);
WuiShimmer = __decorate$1m([
  customElement("wui-shimmer")
], WuiShimmer);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$4 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, e$4 = (t2) => (...e2) => ({ _$litDirective$: t2, values: e2 });
let i$4 = class i2 {
  constructor(t2) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t2, e2, i3) {
    this._$Ct = t2, this._$AM = e2, this._$Ci = i3;
  }
  _$AS(t2, e2) {
    return this.update(t2, e2);
  }
  update(t2, e2) {
    return this.render(...e2);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$3 = e$4(class extends i$4 {
  constructor(t2) {
    if (super(t2), t2.type !== t$4.ATTRIBUTE || "class" !== t2.name || t2.strings?.length > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t2) {
    return " " + Object.keys(t2).filter((s3) => t2[s3]).join(" ") + " ";
  }
  update(s3, [i3]) {
    if (void 0 === this.it) {
      this.it = /* @__PURE__ */ new Set(), void 0 !== s3.strings && (this.st = new Set(s3.strings.join(" ").split(/\s/).filter((t2) => "" !== t2)));
      for (const t2 in i3)
        i3[t2] && !this.st?.has(t2) && this.it.add(t2);
      return this.render(i3);
    }
    const r2 = s3.element.classList;
    for (const t2 of this.it)
      t2 in i3 || (r2.remove(t2), this.it.delete(t2));
    for (const t2 in i3) {
      const s4 = !!i3[t2];
      s4 === this.it.has(t2) || this.st?.has(t2) || (s4 ? (r2.add(t2), this.it.add(t2)) : (r2.remove(t2), this.it.delete(t2)));
    }
    return w$6;
  }
});
const styles$12 = i$7`
  :host {
    display: flex !important;
  }

  slot {
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-small-400,
  .wui-font-paragraph-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }
`;
var __decorate$1l = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiText = class WuiText2 extends s$3 {
  constructor() {
    super(...arguments);
    this.variant = "paragraph-500";
    this.color = "fg-300";
    this.align = "left";
  }
  render() {
    const classes2 = {
      [`wui-font-${this.variant}`]: true,
      [`wui-color-${this.color}`]: true
    };
    this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `;
    return x$3`<slot class=${e$3(classes2)}></slot>`;
  }
};
WuiText.styles = [resetStyles, styles$12];
__decorate$1l([
  n$4()
], WuiText.prototype, "variant", void 0);
__decorate$1l([
  n$4()
], WuiText.prototype, "color", void 0);
__decorate$1l([
  n$4()
], WuiText.prototype, "align", void 0);
WuiText = __decorate$1l([
  customElement("wui-text")
], WuiText);
const browserSvg = b$6`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="30" />
  <circle cx="30" cy="30" r="3" fill="#fff" />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
  />
  <path
    fill="#1DC956"
    d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
  />
  <path
    fill="#86F999"
    d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
  />
  <circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `;
const daoSvg = b$6`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#clip0_7734_50402)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#EB8B47"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
      fill="white"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
      fill="#FF974C"
    />
    <path
      d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
    <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="clip0_7734_50402">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const defiSvg = b$6`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#1DC956"
      d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
    />
    <path
      fill="#2BEE6C"
      d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
    />
    <path
      fill="#fff"
      d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
    <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg>`;
const defiAltSvg = b$6`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="30" />
    <path
      fill="#E87DE8"
      d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
    />
    <path
      fill="#fff"
      d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M31 0v60h-2V0h2Z" />
    <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;
const ethSvg = b$6`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#987DE8" rx="30" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
      clip-rule="evenodd"
    />
    <path
      fill="#643CDD"
      d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
    />
    <path
      fill="#BDADEB"
      d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
    />
    <path
      fill="#643CDD"
      d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
    />
    <path
      fill="#BDADEB"
      d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
    />
    <path
      fill="#401AB3"
      d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
    />
    <path
      fill="#7C5AE2"
      d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;
const layersSvg = b$6`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="3" />
  <path
    fill="#1FAD7E"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#86F999"
    stroke="#fff"
    stroke-width="2"
    d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const lockSvg = b$6`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#fff"
    d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
  />
  <path
    fill="#E87DE8"
    d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
  />
  <path
    fill="#E87DE8"
    fill-rule="evenodd"
    d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
    clip-rule="evenodd"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const loginSvg = b$6`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#EB8B47"
      d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
    />
    <path
      stroke="#062B2B"
      stroke-opacity=".1"
      d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
    />
    <path
      fill="#FF974C"
      stroke="#fff"
      stroke-width="2"
      d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
    />
    <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg> `;
const networkSvg$1 = b$6`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#00ACE6" rx="30" />
    <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
    <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
    <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg>`;
const nftSvg = b$6`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="3" />
    <path
      fill="#E87DE8"
      stroke="#fff"
      stroke-width="2"
      d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
      clip-rule="evenodd"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
  </defs>
</svg> `;
const nounSvg = b$6`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#794CFF" rx="3" />
  <path
    fill="#987DE8"
    stroke="#fff"
    stroke-width="2"
    d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
  />
  <path fill="#fff" d="M37.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M42.5 25h5v10h-5z" />
  <path fill="#fff" d="M19.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M24.5 25h5v10h-5z" />
  <path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const profileSvg = b$6`<svg
  viewBox="0 0 60 60"
  fill="none"
>
  <g clip-path="url(#1)">
    <rect width="60" height="60" rx="30" fill="#00ACE6" />
    <path
      d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
    <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
    <path
      d="M31 20L28 28H32"
      stroke="white"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </g>
  <rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" rx="30" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const systemSvg = b$6`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#1)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#794CFF"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
    <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const styles$11 = i$7`
  :host {
    display: block;
    width: 55px;
    height: 55px;
  }
`;
var __decorate$1k = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const svgOptions = {
  browser: browserSvg,
  dao: daoSvg,
  defi: defiSvg,
  defiAlt: defiAltSvg,
  eth: ethSvg,
  layers: layersSvg,
  lock: lockSvg,
  login: loginSvg,
  network: networkSvg$1,
  nft: nftSvg,
  noun: nounSvg,
  profile: profileSvg,
  system: systemSvg
};
let WuiVisual = class WuiVisual2 extends s$3 {
  constructor() {
    super(...arguments);
    this.name = "browser";
  }
  render() {
    return x$3`${svgOptions[this.name]}`;
  }
};
WuiVisual.styles = [resetStyles, styles$11];
__decorate$1k([
  n$4()
], WuiVisual.prototype, "name", void 0);
WuiVisual = __decorate$1k([
  customElement("wui-visual")
], WuiVisual);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$4 = (o2) => o2 ?? T$5;
const UiHelperUtil = {
  getSpacingStyles(spacing, index2) {
    if (Array.isArray(spacing)) {
      return spacing[index2] ? `var(--wui-spacing-${spacing[index2]})` : void 0;
    } else if (typeof spacing === "string") {
      return `var(--wui-spacing-${spacing})`;
    }
    return void 0;
  },
  getFormattedDate(date2) {
    return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(date2);
  },
  getHostName(url) {
    const newUrl = new URL(url);
    return newUrl.hostname;
  },
  getTruncateString({ string: string2, charsStart, charsEnd, truncate }) {
    if (string2.length <= charsStart + charsEnd) {
      return string2;
    }
    if (truncate === "end") {
      return `${string2.substring(0, charsStart)}...`;
    } else if (truncate === "start") {
      return `...${string2.substring(string2.length - charsEnd)}`;
    }
    return `${string2.substring(0, Math.floor(charsStart))}...${string2.substring(string2.length - Math.floor(charsEnd))}`;
  },
  generateAvatarColors(address) {
    const hash2 = address.toLowerCase().replace(/^0x/iu, "");
    const baseColor = hash2.substring(0, 6);
    const rgbColor = this.hexToRgb(baseColor);
    const masterBorderRadius = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master");
    const radius = Number(masterBorderRadius?.replace("px", ""));
    const edge = 100 - 3 * radius;
    const gradientCircle = `${edge}% ${edge}% at 65% 40%`;
    const colors = [];
    for (let i3 = 0; i3 < 5; i3 += 1) {
      const tintedColor = this.tintColor(rgbColor, 0.15 * i3);
      colors.push(`rgb(${tintedColor[0]}, ${tintedColor[1]}, ${tintedColor[2]})`);
    }
    return `
    --local-color-1: ${colors[0]};
    --local-color-2: ${colors[1]};
    --local-color-3: ${colors[2]};
    --local-color-4: ${colors[3]};
    --local-color-5: ${colors[4]};
    --local-radial-circle: ${gradientCircle}
   `;
  },
  hexToRgb(hex2) {
    const bigint2 = parseInt(hex2, 16);
    const r2 = bigint2 >> 16 & 255;
    const g3 = bigint2 >> 8 & 255;
    const b4 = bigint2 & 255;
    return [r2, g3, b4];
  },
  tintColor(rgb, tint) {
    const [r2, g3, b4] = rgb;
    const tintedR = Math.round(r2 + (255 - r2) * tint);
    const tintedG = Math.round(g3 + (255 - g3) * tint);
    const tintedB = Math.round(b4 + (255 - b4) * tint);
    return [tintedR, tintedG, tintedB];
  },
  isNumber(character) {
    const regex2 = {
      number: /^[0-9]+$/u
    };
    return regex2.number.test(character);
  },
  getColorTheme(theme) {
    if (theme) {
      return theme;
    } else if (typeof window !== "undefined" && window.matchMedia) {
      if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
        return "dark";
      }
      return "light";
    }
    return "dark";
  }
};
const styles$10 = i$7`
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$1j = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiFlex = class WuiFlex2 extends s$3 {
  render() {
    this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
    return x$3`<slot></slot>`;
  }
};
WuiFlex.styles = [resetStyles, styles$10];
__decorate$1j([
  n$4()
], WuiFlex.prototype, "flexDirection", void 0);
__decorate$1j([
  n$4()
], WuiFlex.prototype, "flexWrap", void 0);
__decorate$1j([
  n$4()
], WuiFlex.prototype, "flexBasis", void 0);
__decorate$1j([
  n$4()
], WuiFlex.prototype, "flexGrow", void 0);
__decorate$1j([
  n$4()
], WuiFlex.prototype, "flexShrink", void 0);
__decorate$1j([
  n$4()
], WuiFlex.prototype, "alignItems", void 0);
__decorate$1j([
  n$4()
], WuiFlex.prototype, "justifyContent", void 0);
__decorate$1j([
  n$4()
], WuiFlex.prototype, "columnGap", void 0);
__decorate$1j([
  n$4()
], WuiFlex.prototype, "rowGap", void 0);
__decorate$1j([
  n$4()
], WuiFlex.prototype, "gap", void 0);
__decorate$1j([
  n$4()
], WuiFlex.prototype, "padding", void 0);
__decorate$1j([
  n$4()
], WuiFlex.prototype, "margin", void 0);
WuiFlex = __decorate$1j([
  customElement("wui-flex")
], WuiFlex);
const styles$$ = i$7`
  :host {
    display: block;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    overflow: hidden;
    position: relative;
  }

  :host([data-variant='generated']) {
    --mixed-local-color-1: var(--local-color-1);
    --mixed-local-color-2: var(--local-color-2);
    --mixed-local-color-3: var(--local-color-3);
    --mixed-local-color-4: var(--local-color-4);
    --mixed-local-color-5: var(--local-color-5);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host([data-variant='generated']) {
      --mixed-local-color-1: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-1)
      );
      --mixed-local-color-2: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-2)
      );
      --mixed-local-color-3: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-3)
      );
      --mixed-local-color-4: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-4)
      );
      --mixed-local-color-5: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-5)
      );
    }
  }

  :host([data-variant='generated']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      var(--local-radial-circle),
      #fff 0.52%,
      var(--mixed-local-color-5) 31.25%,
      var(--mixed-local-color-3) 51.56%,
      var(--mixed-local-color-2) 65.63%,
      var(--mixed-local-color-1) 82.29%,
      var(--mixed-local-color-4) 100%
    );
  }

  :host([data-variant='default']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      #f5ccfc 31.25%,
      #dba4f5 51.56%,
      #9a8ee8 65.63%,
      #6493da 82.29%,
      #6ebdea 100%
    );
  }
`;
var __decorate$1i = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiAvatar = class WuiAvatar2 extends s$3 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.alt = void 0;
    this.address = void 0;
  }
  render() {
    return x$3`${this.visualTemplate()}`;
  }
  visualTemplate() {
    if (this.imageSrc) {
      this.dataset["variant"] = "image";
      return x$3`<wui-image src=${this.imageSrc} alt=${this.alt ?? "avatar"}></wui-image>`;
    } else if (this.address) {
      this.dataset["variant"] = "generated";
      const cssColors = UiHelperUtil.generateAvatarColors(this.address);
      this.style.cssText = cssColors;
      return null;
    }
    this.dataset["variant"] = "default";
    return null;
  }
};
WuiAvatar.styles = [resetStyles, styles$$];
__decorate$1i([
  n$4()
], WuiAvatar.prototype, "imageSrc", void 0);
__decorate$1i([
  n$4()
], WuiAvatar.prototype, "alt", void 0);
__decorate$1i([
  n$4()
], WuiAvatar.prototype, "address", void 0);
WuiAvatar = __decorate$1i([
  customElement("wui-avatar")
], WuiAvatar);
const styles$_ = i$7`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-gray-glass-020);
    border-radius: var(--local-border-radius);
    box-shadow: 0 0 0 1px var(--local-border);
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`;
var __decorate$1h = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiIconBox = class WuiIconBox2 extends s$3 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.backgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.background = "transparent";
    this.border = false;
    this.borderColor = "wui-color-bg-125";
    this.icon = "copy";
  }
  render() {
    const iconSize = this.iconSize || this.size;
    const isLg = this.size === "lg";
    const isXl = this.size === "xl";
    const bgMix = isLg ? "12%" : "16%";
    const borderRadius = isLg ? "xxs" : isXl ? "s" : "3xl";
    const isGray = this.background === "gray";
    const isOpaque = this.background === "opaque";
    const isColorChange = this.backgroundColor === "accent-100" && isOpaque || this.backgroundColor === "success-100" && isOpaque || this.backgroundColor === "error-100" && isOpaque || this.backgroundColor === "inverse-100" && isOpaque;
    let bgValueVariable = `var(--wui-color-${this.backgroundColor})`;
    if (isColorChange) {
      bgValueVariable = `var(--wui-icon-box-bg-${this.backgroundColor})`;
    } else if (isGray) {
      bgValueVariable = `var(--wui-gray-${this.backgroundColor})`;
    }
    this.style.cssText = `
       --local-bg-value: ${bgValueVariable};
       --local-bg-mix: ${isColorChange || isGray ? `100%` : bgMix};
       --local-border-radius: var(--wui-border-radius-${borderRadius});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${this.borderColor === "wui-color-bg-125" ? `2px` : `1px`} solid ${this.border ? `var(--${this.borderColor})` : `transparent`}
   `;
    return x$3` <wui-icon color=${this.iconColor} size=${iconSize} name=${this.icon}></wui-icon> `;
  }
};
WuiIconBox.styles = [resetStyles, elementStyles, styles$_];
__decorate$1h([
  n$4()
], WuiIconBox.prototype, "size", void 0);
__decorate$1h([
  n$4()
], WuiIconBox.prototype, "backgroundColor", void 0);
__decorate$1h([
  n$4()
], WuiIconBox.prototype, "iconColor", void 0);
__decorate$1h([
  n$4()
], WuiIconBox.prototype, "iconSize", void 0);
__decorate$1h([
  n$4()
], WuiIconBox.prototype, "background", void 0);
__decorate$1h([
  n$4({ type: Boolean })
], WuiIconBox.prototype, "border", void 0);
__decorate$1h([
  n$4()
], WuiIconBox.prototype, "borderColor", void 0);
__decorate$1h([
  n$4()
], WuiIconBox.prototype, "icon", void 0);
WuiIconBox = __decorate$1h([
  customElement("wui-icon-box")
], WuiIconBox);
const styles$Z = i$7`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    background: var(--wui-gray-glass-002);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-005);
  }

  button:disabled {
    background: var(--wui-gray-glass-015);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-flex > wui-avatar {
    filter: grayscale(1);
  }

  button:has(wui-image) {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-3xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
  }

  wui-text {
    color: var(--wui-color-fg-100);
  }

  wui-flex > wui-text {
    color: var(--wui-color-fg-200);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  wui-flex {
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    padding: 4px var(--wui-spacing-m) 4px var(--wui-spacing-xxs);
  }

  button.local-no-balance {
    border-radius: 0px;
    border: none;
    background: transparent;
  }

  wui-avatar {
    width: 20px;
    height: 20px;
    box-shadow: 0 0 0 2px var(--wui-accent-glass-010);
  }

  @media (max-width: 500px) {
    button {
      gap: 0px;
      padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) !important;
      height: 32px;
    }
    wui-image,
    wui-icon-box,
    button > wui-text {
      visibility: hidden;
      width: 0px;
      height: 0px;
    }
    button {
      border-radius: 0px;
      border: none;
      background: transparent;
      padding: 0px;
    }
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }

    button:active:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }
  }
`;
var __decorate$1g = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiAccountButton = class WuiAccountButton2 extends s$3 {
  constructor() {
    super(...arguments);
    this.networkSrc = void 0;
    this.avatarSrc = void 0;
    this.balance = void 0;
    this.disabled = false;
    this.isProfileName = false;
    this.address = "";
    this.charsStart = 4;
    this.charsEnd = 6;
  }
  render() {
    return x$3`
      <button
        ?disabled=${this.disabled}
        class=${o$4(this.balance ? void 0 : "local-no-balance")}
      >
        ${this.balanceTemplate()}
        <wui-flex gap="xxs" alignItems="center">
          <wui-avatar
            .imageSrc=${this.avatarSrc}
            alt=${this.address}
            address=${this.address}
          ></wui-avatar>
          <wui-text variant="paragraph-600" color="inherit">
            ${UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: this.isProfileName ? 18 : this.charsStart,
      charsEnd: this.isProfileName ? 0 : this.charsEnd,
      truncate: this.isProfileName ? "end" : "middle"
    })}
          </wui-text>
        </wui-flex>
      </button>
    `;
  }
  balanceTemplate() {
    if (this.balance) {
      const networkElement = this.networkSrc ? x$3`<wui-image src=${this.networkSrc}></wui-image>` : x$3`
            <wui-icon-box
              size="sm"
              iconColor="fg-200"
              backgroundColor="fg-300"
              icon="networkPlaceholder"
            ></wui-icon-box>
          `;
      return x$3`
        ${networkElement}
        <wui-text variant="paragraph-600" color="inherit"> ${this.balance} </wui-text>
      `;
    }
    return null;
  }
};
WuiAccountButton.styles = [resetStyles, elementStyles, styles$Z];
__decorate$1g([
  n$4()
], WuiAccountButton.prototype, "networkSrc", void 0);
__decorate$1g([
  n$4()
], WuiAccountButton.prototype, "avatarSrc", void 0);
__decorate$1g([
  n$4()
], WuiAccountButton.prototype, "balance", void 0);
__decorate$1g([
  n$4({ type: Boolean })
], WuiAccountButton.prototype, "disabled", void 0);
__decorate$1g([
  n$4({ type: Boolean })
], WuiAccountButton.prototype, "isProfileName", void 0);
__decorate$1g([
  n$4()
], WuiAccountButton.prototype, "address", void 0);
__decorate$1g([
  n$4()
], WuiAccountButton.prototype, "charsStart", void 0);
__decorate$1g([
  n$4()
], WuiAccountButton.prototype, "charsEnd", void 0);
WuiAccountButton = __decorate$1g([
  customElement("wui-account-button")
], WuiAccountButton);
const styles$Y = i$7`
  :host {
    position: relative;
    background-color: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host > wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }

  :host > wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid var(--wui-color-bg-base-150, #1e1f1f);
    padding: 1px;
  }
`;
var __decorate$1f = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiWalletImage = class WuiWalletImage2 extends s$3 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "";
    this.installed = false;
    this.badgeSize = "xs";
  }
  render() {
    let borderRadius = "xxs";
    if (this.size === "lg") {
      borderRadius = "m";
    } else if (this.size === "md") {
      borderRadius = "xs";
    } else {
      borderRadius = "xxs";
    }
    this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${borderRadius});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `;
    if (this.walletIcon) {
      this.dataset["walletIcon"] = this.walletIcon;
    }
    return x$3`
      <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
    `;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$3`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`;
    } else if (this.walletIcon) {
      return x$3`<wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></wui-icon>`;
    }
    return x$3`<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
  }
};
WuiWalletImage.styles = [resetStyles, styles$Y];
__decorate$1f([
  n$4()
], WuiWalletImage.prototype, "size", void 0);
__decorate$1f([
  n$4()
], WuiWalletImage.prototype, "name", void 0);
__decorate$1f([
  n$4()
], WuiWalletImage.prototype, "imageSrc", void 0);
__decorate$1f([
  n$4()
], WuiWalletImage.prototype, "walletIcon", void 0);
__decorate$1f([
  n$4({ type: Boolean })
], WuiWalletImage.prototype, "installed", void 0);
__decorate$1f([
  n$4()
], WuiWalletImage.prototype, "badgeSize", void 0);
WuiWalletImage = __decorate$1f([
  customElement("wui-wallet-image")
], WuiWalletImage);
const styles$X = i$7`
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-flex {
    padding: 2px;
    position: fixed;
    overflow: hidden;
    left: 34px;
    bottom: 8px;
    background: var(--dark-background-150, #1e1f1f);
    border-radius: 50%;
    z-index: 2;
    display: flex;
  }
`;
var __decorate$1e = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const TOTAL_IMAGES = 4;
let WuiAllWalletsImage = class WuiAllWalletsImage2 extends s$3 {
  constructor() {
    super(...arguments);
    this.walletImages = [];
  }
  render() {
    const isPlaceholders = this.walletImages.length < TOTAL_IMAGES;
    return x$3`${this.walletImages.slice(0, TOTAL_IMAGES).map(({ src: src2, walletName }) => x$3`
            <wui-wallet-image
              size="inherit"
              imageSrc=${src2}
              name=${o$4(walletName)}
            ></wui-wallet-image>
          `)}
      ${isPlaceholders ? [...Array(TOTAL_IMAGES - this.walletImages.length)].map(() => x$3` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`) : null}
      <wui-flex>
        <wui-icon-box
          size="xxs"
          iconSize="xxs"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>`;
  }
};
WuiAllWalletsImage.styles = [resetStyles, styles$X];
__decorate$1e([
  n$4({ type: Array })
], WuiAllWalletsImage.prototype, "walletImages", void 0);
WuiAllWalletsImage = __decorate$1e([
  customElement("wui-all-wallets-image")
], WuiAllWalletsImage);
const styles$W = i$7`
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    width: var(--local-width);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-010);
  }

  button[data-size='sm'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s);
  }

  button[data-size='sm'][data-icon-left='true'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  button[data-size='sm'][data-icon-right='true'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-xs) var(--wui-spacing-xxs)
      var(--wui-spacing-s);
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button[data-size='md'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'][data-icon-left='true'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
  }

  button[data-size='md'][data-icon-right='true'] {
    padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
  }

  wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transition: all 200ms ease-in-out;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`;
var __decorate$1d = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiButton = class WuiButton2 extends s$3 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.disabled = false;
    this.fullWidth = false;
    this.loading = false;
    this.variant = "fill";
    this.hasIconLeft = false;
    this.hasIconRight = false;
  }
  render() {
    this.style.cssText = `
    --local-width: ${this.fullWidth ? "100%" : "auto"};
    --local-opacity-100: ${this.loading ? 0 : 1};
    --local-opacity-000: ${this.loading ? 1 : 0};`;
    const textVariant = this.size === "md" ? "paragraph-600" : "small-600";
    return x$3`
      <button
        data-variant=${this.variant}
        data-icon-left=${this.hasIconLeft}
        data-icon-right=${this.hasIconRight}
        data-size=${this.size}
        ?disabled=${this.disabled || this.loading}
        ontouchstart
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft" @slotchange=${() => this.handleSlotLeftChange()}></slot>
        <wui-text variant=${textVariant} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight" @slotchange=${() => this.handleSlotRightChange()}></slot>
      </button>
    `;
  }
  handleSlotLeftChange() {
    this.hasIconLeft = true;
  }
  handleSlotRightChange() {
    this.hasIconRight = true;
  }
  loadingTemplate() {
    if (this.loading) {
      return x$3`<wui-loading-spinner color="fg-300"></wui-loading-spinner>`;
    }
    return x$3``;
  }
};
WuiButton.styles = [resetStyles, elementStyles, styles$W];
__decorate$1d([
  n$4()
], WuiButton.prototype, "size", void 0);
__decorate$1d([
  n$4({ type: Boolean })
], WuiButton.prototype, "disabled", void 0);
__decorate$1d([
  n$4({ type: Boolean })
], WuiButton.prototype, "fullWidth", void 0);
__decorate$1d([
  n$4({ type: Boolean })
], WuiButton.prototype, "loading", void 0);
__decorate$1d([
  n$4()
], WuiButton.prototype, "variant", void 0);
__decorate$1d([
  n$4({ type: Boolean })
], WuiButton.prototype, "hasIconLeft", void 0);
__decorate$1d([
  n$4({ type: Boolean })
], WuiButton.prototype, "hasIconRight", void 0);
WuiButton = __decorate$1d([
  customElement("wui-button")
], WuiButton);
const networkSvg = b$6`<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`;
const styles$V = i$7`
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-gray-glass-010);
    stroke-width: 1px;
  }
`;
var __decorate$1c = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCardSelectLoader = class WuiCardSelectLoader2 extends s$3 {
  constructor() {
    super(...arguments);
    this.type = "wallet";
  }
  render() {
    return x$3`
      ${this.shimmerTemplate()}
      <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
    `;
  }
  shimmerTemplate() {
    if (this.type === "network") {
      return x$3` <wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></wui-shimmer>
        ${networkSvg}`;
    }
    return x$3`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
  }
};
WuiCardSelectLoader.styles = [resetStyles, elementStyles, styles$V];
__decorate$1c([
  n$4()
], WuiCardSelectLoader.prototype, "type", void 0);
WuiCardSelectLoader = __decorate$1c([
  customElement("wui-card-select-loader")
], WuiCardSelectLoader);
const networkLgSvg = b$6`<svg width="86" height="96" fill="none">
  <path
    d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
  />
</svg>`;
const styles$U = i$7`
  :host {
    position: relative;
    border-radius: inherit;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-width);
    height: var(--local-height);
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    fill: var(--wui-gray-glass-002);
  }

  svg > path {
    stroke: var(--local-stroke);
    transition: stroke var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image {
    width: 100%;
    height: 100%;
    -webkit-clip-path: var(--local-path);
    clip-path: var(--local-path);
    background: var(--wui-gray-glass-002);
  }

  wui-icon {
    transform: translateY(-5%);
    width: var(--local-icon-size);
    height: var(--local-icon-size);
  }
`;
var __decorate$1b = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiNetworkImage = class WuiNetworkImage2 extends s$3 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "uknown";
    this.selected = false;
  }
  render() {
    const isLg = this.size === "lg";
    this.style.cssText = `
      --local-stroke: ${this.selected ? "var(--wui-color-accent-100)" : "var(--wui-gray-glass-010)"};
      --local-path: ${isLg ? "var(--wui-path-network-lg)" : "var(--wui-path-network)"};
      --local-width: ${isLg ? "86px" : "48px"};
      --local-height: ${isLg ? "96px" : "54px"};
      --local-icon-size: ${isLg ? "42px" : "24px"};
    `;
    return x$3`${this.templateVisual()} ${isLg ? networkLgSvg : networkSvg}`;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$3`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`;
    }
    return x$3`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiNetworkImage.styles = [resetStyles, styles$U];
__decorate$1b([
  n$4()
], WuiNetworkImage.prototype, "size", void 0);
__decorate$1b([
  n$4()
], WuiNetworkImage.prototype, "name", void 0);
__decorate$1b([
  n$4()
], WuiNetworkImage.prototype, "imageSrc", void 0);
__decorate$1b([
  n$4({ type: Boolean })
], WuiNetworkImage.prototype, "selected", void 0);
WuiNetworkImage = __decorate$1b([
  customElement("wui-network-image")
], WuiNetworkImage);
const styles$T = i$7`
  button {
    flex-direction: column;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
  }

  button > wui-text {
    color: var(--wui-color-fg-100);
    max-width: var(--wui-icon-box-size-xl);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-accent-glass-010);
  }
`;
var __decorate$1a = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCardSelect = class WuiCardSelect2 extends s$3 {
  constructor() {
    super(...arguments);
    this.name = "Unknown";
    this.type = "wallet";
    this.imageSrc = void 0;
    this.disabled = false;
    this.selected = false;
    this.installed = false;
  }
  render() {
    return x$3`
      <button data-selected=${o$4(this.selected)} ?disabled=${this.disabled} ontouchstart>
        ${this.imageTemplate()}
        <wui-text variant="tiny-500" color=${this.selected ? "accent-100" : "inherit"}>
          ${this.name}
        </wui-text>
      </button>
    `;
  }
  imageTemplate() {
    if (this.type === "network") {
      return x$3`
        <wui-network-image
          .selected=${this.selected}
          imageSrc=${o$4(this.imageSrc)}
          name=${this.name}
        >
        </wui-network-image>
      `;
    }
    return x$3`
      <wui-wallet-image
        size="md"
        imageSrc=${o$4(this.imageSrc)}
        name=${this.name}
        .installed=${this.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `;
  }
};
WuiCardSelect.styles = [resetStyles, elementStyles, styles$T];
__decorate$1a([
  n$4()
], WuiCardSelect.prototype, "name", void 0);
__decorate$1a([
  n$4()
], WuiCardSelect.prototype, "type", void 0);
__decorate$1a([
  n$4()
], WuiCardSelect.prototype, "imageSrc", void 0);
__decorate$1a([
  n$4({ type: Boolean })
], WuiCardSelect.prototype, "disabled", void 0);
__decorate$1a([
  n$4({ type: Boolean })
], WuiCardSelect.prototype, "selected", void 0);
__decorate$1a([
  n$4({ type: Boolean })
], WuiCardSelect.prototype, "installed", void 0);
WuiCardSelect = __decorate$1a([
  customElement("wui-card-select")
], WuiCardSelect);
const styles$S = i$7`
  a {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  a.disabled > wui-icon,
  a.disabled > wui-image {
    filter: grayscale(1);
  }

  a[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  a[data-variant='shade'],
  a[data-variant='shadeSmall'] {
    background-color: transparent;
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  a[data-variant='success'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-success-glass-010);
    background-color: var(--wui-success-glass-010);
    color: var(--wui-color-success-100);
  }

  a[data-variant='transparent'] {
    column-gap: var(--wui-spacing-xxs);
    background-color: transparent;
    color: var(--wui-color-fg-150);
  }

  a[data-variant='transparent'],
  a[data-variant='success'],
  a[data-variant='shadeSmall'] {
    padding: 7px var(--wui-spacing-s) 7px 10px;
  }

  a[data-variant='transparent']:has(wui-text:first-child),
  a[data-variant='success']:has(wui-text:first-child),
  a[data-variant='shadeSmall']:has(wui-text:first-child) {
    padding: 7px var(--wui-spacing-s);
  }

  a[data-variant='fill'],
  a[data-variant='shade'] {
    column-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  a[data-variant='fill']:has(wui-text:first-child),
  a[data-variant='shade']:has(wui-text:first-child) {
    padding: 9px var(--wui-spacing-m) 9px var(--wui-spacing-m);
  }

  a[data-variant='fill'] > wui-image,
  a[data-variant='shade'] > wui-image {
    width: 24px;
    height: 24px;
  }

  a[data-variant='fill'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  a[data-variant='shade'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-010);
  }

  a[data-variant='fill'] > wui-icon,
  a[data-variant='shade'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-image,
  a[data-variant='success'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-icon,
  a[data-variant='success'] > wui-icon,
  a[data-variant='shadeSmall'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  a[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  a[data-variant='shade']:focus-visible,
  a[data-variant='shadeSmall']:focus-visible {
    background-color: var(--wui-gray-glass-015);
  }

  a[data-variant='transparent']:focus-visible {
    background-color: var(--wui-gray-glass-005);
  }

  a[data-variant='success']:focus-visible {
    background-color: var(--wui-success-glass-015);
  }

  a.disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
    pointer-events: none;
  }

  @media (hover: hover) and (pointer: fine) {
    a[data-variant='fill']:hover {
      background-color: var(--wui-color-accent-090);
    }

    a[data-variant='shade']:hover,
    a[data-variant='shadeSmall']:hover {
      background-color: var(--wui-gray-glass-015);
    }

    a[data-variant='transparent']:hover {
      background-color: var(--wui-gray-glass-005);
    }

    a[data-variant='success']:hover {
      background-color: var(--wui-success-glass-015);
    }
  }

  a[data-variant='fill']:active {
    background-color: var(--wui-color-accent-080);
  }

  a[data-variant='shade']:active,
  a[data-variant='shadeSmall']:active {
    background-color: var(--wui-gray-glass-020);
  }

  a[data-variant='transparent']:active {
    background-color: var(--wui-gray-glass-010);
  }

  a[data-variant='success']:active {
    background-color: var(--wui-success-glass-020);
  }
`;
var __decorate$19 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiChip = class WuiChip2 extends s$3 {
  constructor() {
    super(...arguments);
    this.variant = "fill";
    this.imageSrc = void 0;
    this.disabled = false;
    this.icon = "externalLink";
    this.href = "";
    this.text = void 0;
  }
  render() {
    const isSmall = this.variant === "success" || this.variant === "transparent" || this.variant === "shadeSmall";
    const textVariant = isSmall ? "small-600" : "paragraph-600";
    return x$3`
      <a
        rel="noreferrer"
        target="_blank"
        href=${this.href}
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
      >
        ${this.imageTemplate()}
        <wui-text variant=${textVariant} color="inherit">
          ${this.title ? this.title : UiHelperUtil.getHostName(this.href)}
        </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </a>
    `;
  }
  imageTemplate() {
    if (this.imageSrc) {
      return x$3`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return null;
  }
};
WuiChip.styles = [resetStyles, elementStyles, styles$S];
__decorate$19([
  n$4()
], WuiChip.prototype, "variant", void 0);
__decorate$19([
  n$4()
], WuiChip.prototype, "imageSrc", void 0);
__decorate$19([
  n$4({ type: Boolean })
], WuiChip.prototype, "disabled", void 0);
__decorate$19([
  n$4()
], WuiChip.prototype, "icon", void 0);
__decorate$19([
  n$4()
], WuiChip.prototype, "href", void 0);
__decorate$19([
  n$4()
], WuiChip.prototype, "text", void 0);
WuiChip = __decorate$19([
  customElement("wui-chip")
], WuiChip);
const styles$R = i$7`
  :host {
    position: relative;
    display: block;
  }

  button {
    background: var(--wui-color-accent-100);
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    gap: var(--wui-spacing-xs);
  }

  button.loading {
    background: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-gray-glass-010);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-080);
    }
  }

  button:focus-visible {
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-color-accent-090);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-size='sm'] {
    padding: 6.75px 10px 7.25px;
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
    color: var(--wui-color-inverse-100);
  }

  button[data-size='md'] {
    padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'] + wui-text {
    padding-left: var(--wui-spacing-3xs);
  }

  @media (max-width: 500px) {
    button[data-size='md'] {
      height: 32px;
      padding: 5px 12px;
    }

    button[data-size='md'] > wui-text > slot {
      font-size: 14px !important;
    }
  }

  wui-loading-spinner {
    width: 14px;
    height: 14px;
  }

  wui-loading-spinner::slotted(svg) {
    width: 10px !important;
    height: 10px !important;
  }

  button[data-size='sm'] > wui-loading-spinner {
    width: 12px;
    height: 12px;
  }
`;
var __decorate$18 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiConnectButton = class WuiConnectButton2 extends s$3 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.loading = false;
  }
  render() {
    const textVariant = this.size === "md" ? "paragraph-600" : "small-600";
    return x$3`
      <button data-size=${this.size} ?disabled=${this.loading} ontouchstart>
        ${this.loadingTemplate()}
        <wui-text variant=${textVariant} color=${this.loading ? "accent-100" : "inherit"}>
          <slot></slot>
        </wui-text>
      </button>
    `;
  }
  loadingTemplate() {
    if (!this.loading) {
      return null;
    }
    return x$3`<wui-loading-spinner size=${this.size} color="accent-100"></wui-loading-spinner>`;
  }
};
WuiConnectButton.styles = [resetStyles, elementStyles, styles$R];
__decorate$18([
  n$4()
], WuiConnectButton.prototype, "size", void 0);
__decorate$18([
  n$4({ type: Boolean })
], WuiConnectButton.prototype, "loading", void 0);
WuiConnectButton = __decorate$18([
  customElement("wui-connect-button")
], WuiConnectButton);
const styles$Q = i$7`
  wui-flex {
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$17 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCtaButton = class WuiCtaButton2 extends s$3 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.label = "";
    this.buttonLabel = "";
  }
  render() {
    return x$3`
      <wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${["1xs", "2l", "1xs", "2l"]}
      >
        <wui-text variant="paragraph-500" color="fg-200">${this.label}</wui-text>
        <wui-button size="sm" variant="accent">
          ${this.buttonLabel}
          <wui-icon size="xs" color="inherit" slot="iconRight" name="chevronRight"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
  }
};
WuiCtaButton.styles = [resetStyles, elementStyles, styles$Q];
__decorate$17([
  n$4({ type: Boolean })
], WuiCtaButton.prototype, "disabled", void 0);
__decorate$17([
  n$4()
], WuiCtaButton.prototype, "label", void 0);
__decorate$17([
  n$4()
], WuiCtaButton.prototype, "buttonLabel", void 0);
WuiCtaButton = __decorate$17([
  customElement("wui-cta-button")
], WuiCtaButton);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const f$6 = (o2) => void 0 === o2.strings;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s$2 = (i3, t2) => {
  const e2 = i3._$AN;
  if (void 0 === e2)
    return false;
  for (const i4 of e2)
    i4._$AO?.(t2, false), s$2(i4, t2);
  return true;
}, o$3 = (i3) => {
  let t2, e2;
  do {
    if (void 0 === (t2 = i3._$AM))
      break;
    e2 = t2._$AN, e2.delete(i3), i3 = t2;
  } while (0 === e2?.size);
}, r$3 = (i3) => {
  for (let t2; t2 = i3._$AM; i3 = t2) {
    let e2 = t2._$AN;
    if (void 0 === e2)
      t2._$AN = e2 = /* @__PURE__ */ new Set();
    else if (e2.has(i3))
      break;
    e2.add(i3), c$3(t2);
  }
};
function h$8(i3) {
  void 0 !== this._$AN ? (o$3(this), this._$AM = i3, r$3(this)) : this._$AM = i3;
}
function n$3(i3, t2 = false, e2 = 0) {
  const r2 = this._$AH, h5 = this._$AN;
  if (void 0 !== h5 && 0 !== h5.size)
    if (t2)
      if (Array.isArray(r2))
        for (let i4 = e2; i4 < r2.length; i4++)
          s$2(r2[i4], false), o$3(r2[i4]);
      else
        null != r2 && (s$2(r2, false), o$3(r2));
    else
      s$2(this, i3);
}
const c$3 = (i3) => {
  i3.type == t$4.CHILD && (i3._$AP ?? (i3._$AP = n$3), i3._$AQ ?? (i3._$AQ = h$8));
};
let f$5 = class f2 extends i$4 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i3, t2, e2) {
    super._$AT(i3, t2, e2), r$3(this), this.isConnected = i3._$AU;
  }
  _$AO(i3, t2 = true) {
    i3 !== this.isConnected && (this.isConnected = i3, i3 ? this.reconnected?.() : this.disconnected?.()), t2 && (s$2(this, i3), o$3(this));
  }
  setValue(t2) {
    if (f$6(this._$Ct))
      this._$Ct._$AI(t2, this);
    else {
      const i3 = [...this._$Ct._$AH];
      i3[this._$Ci] = t2, this._$Ct._$AI(i3, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$2 = () => new h$7();
let h$7 = class h2 {
};
const o$2 = /* @__PURE__ */ new WeakMap(), n$2 = e$4(class extends f$5 {
  render(i3) {
    return T$5;
  }
  update(i3, [s3]) {
    const e2 = s3 !== this.G;
    return e2 && void 0 !== this.G && this.ot(void 0), (e2 || this.rt !== this.lt) && (this.G = s3, this.ct = i3.options?.host, this.ot(this.lt = i3.element)), T$5;
  }
  ot(t2) {
    if ("function" == typeof this.G) {
      const i3 = this.ct ?? globalThis;
      let s3 = o$2.get(i3);
      void 0 === s3 && (s3 = /* @__PURE__ */ new WeakMap(), o$2.set(i3, s3)), void 0 !== s3.get(this.G) && this.G.call(this.ct, void 0), s3.set(this.G, t2), void 0 !== t2 && this.G.call(this.ct, t2);
    } else
      this.G.value = t2;
  }
  get rt() {
    return "function" == typeof this.G ? o$2.get(this.ct ?? globalThis)?.get(this.G) : this.G?.value;
  }
  disconnected() {
    this.rt === this.lt && this.ot(void 0);
  }
  reconnected() {
    this.ot(this.lt);
  }
});
const styles$P = i$7`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    font-size: var(--wui-font-size-paragraph);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
  }

  input:disabled::placeholder,
  input:disabled + wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .wui-size-md,
  wui-loading-spinner + .wui-size-md {
    padding: 10.5px var(--wui-spacing-3xl) 10.5px 40px;
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-l);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    transition: all var(--wui-ease-in-power-2) var(--wui-duration-md);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`;
var __decorate$16 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiInputText = class WuiInputText2 extends s$3 {
  constructor() {
    super(...arguments);
    this.inputElementRef = e$2();
    this.size = "md";
    this.disabled = false;
    this.placeholder = "";
    this.type = "text";
  }
  render() {
    const sizeClass = `wui-size-${this.size}`;
    return x$3` ${this.templateIcon()}
      <input
        ${n$2(this.inputElementRef)}
        class=${sizeClass}
        type=${this.type}
        enterkeyhint=${o$4(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
        value=${o$4(this.value)}
      />
      <slot></slot>`;
  }
  templateIcon() {
    if (this.icon) {
      return x$3`<wui-icon
        data-input=${this.size}
        size="sm"
        color="inherit"
        name=${this.icon}
      ></wui-icon>`;
    }
    return null;
  }
  dispatchInputChangeEvent() {
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: this.inputElementRef.value?.value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiInputText.styles = [resetStyles, elementStyles, styles$P];
__decorate$16([
  n$4()
], WuiInputText.prototype, "size", void 0);
__decorate$16([
  n$4()
], WuiInputText.prototype, "icon", void 0);
__decorate$16([
  n$4({ type: Boolean })
], WuiInputText.prototype, "disabled", void 0);
__decorate$16([
  n$4()
], WuiInputText.prototype, "placeholder", void 0);
__decorate$16([
  n$4()
], WuiInputText.prototype, "type", void 0);
__decorate$16([
  n$4()
], WuiInputText.prototype, "keyHint", void 0);
__decorate$16([
  n$4()
], WuiInputText.prototype, "value", void 0);
WuiInputText = __decorate$16([
  customElement("wui-input-text")
], WuiInputText);
const styles$O = i$7`
  :host {
    position: relative;
    display: inline-block;
  }

  wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;
var __decorate$15 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiEmailInput = class WuiEmailInput2 extends s$3 {
  constructor() {
    super(...arguments);
    this.disabled = false;
  }
  render() {
    return x$3`
      <wui-input-text
        placeholder="Email"
        icon="mail"
        size="md"
        .disabled=${this.disabled}
        .value=${this.value}
        data-testid="wui-email-input"
      ></wui-input-text>
      ${this.templateError()}
    `;
  }
  templateError() {
    if (this.errorMessage) {
      return x$3`<wui-text variant="tiny-500" color="error-100">${this.errorMessage}</wui-text>`;
    }
    return null;
  }
};
WuiEmailInput.styles = [resetStyles, styles$O];
__decorate$15([
  n$4()
], WuiEmailInput.prototype, "errorMessage", void 0);
__decorate$15([
  n$4({ type: Boolean })
], WuiEmailInput.prototype, "disabled", void 0);
__decorate$15([
  n$4()
], WuiEmailInput.prototype, "value", void 0);
WuiEmailInput = __decorate$15([
  customElement("wui-email-input")
], WuiEmailInput);
const styles$N = i$7`
  button {
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-fg-100);
    padding: var(--wui-spacing-2xs);
  }

  @media (max-width: 700px) {
    button {
      padding: var(--wui-spacing-s);
    }
  }

  button > wui-icon {
    pointer-events: none;
  }

  button:disabled > wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`;
var __decorate$14 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiIconLink = class WuiIconLink2 extends s$3 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.disabled = false;
    this.icon = "copy";
    this.iconColor = "inherit";
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
      </button>
    `;
  }
};
WuiIconLink.styles = [resetStyles, elementStyles, colorStyles, styles$N];
__decorate$14([
  n$4()
], WuiIconLink.prototype, "size", void 0);
__decorate$14([
  n$4({ type: Boolean })
], WuiIconLink.prototype, "disabled", void 0);
__decorate$14([
  n$4()
], WuiIconLink.prototype, "icon", void 0);
__decorate$14([
  n$4()
], WuiIconLink.prototype, "iconColor", void 0);
WuiIconLink = __decorate$14([
  customElement("wui-icon-link")
], WuiIconLink);
const styles$M = i$7`
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  button:active:enabled {
    background-color: var(--wui-color-fg-225);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }
  }
`;
var __decorate$13 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiInputElement = class WuiInputElement2 extends s$3 {
  constructor() {
    super(...arguments);
    this.icon = "copy";
  }
  render() {
    return x$3`
      <button>
        <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
      </button>
    `;
  }
};
WuiInputElement.styles = [resetStyles, elementStyles, styles$M];
__decorate$13([
  n$4()
], WuiInputElement.prototype, "icon", void 0);
WuiInputElement = __decorate$13([
  customElement("wui-input-element")
], WuiInputElement);
const styles$L = i$7`
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    font-family: var(--wui-font-family);
    font-size: var(--wui-font-size-large);
    font-weight: var(--wui-font-weight-regular);
    letter-spacing: var(--wui-letter-spacing-large);
    text-align: center;
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
    background: var(--wui-gray-glass-005);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }
  @media (hover: hover) and (pointer: fine) {
    input:hover:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }
`;
var __decorate$12 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiInputNumeric = class WuiInputNumeric2 extends s$3 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.value = "";
  }
  render() {
    return x$3`<input
      type="number"
      maxlength="1"
      inputmode="numeric"
      autofocus
      ?disabled=${this.disabled}
      value=${this.value}
    /> `;
  }
};
WuiInputNumeric.styles = [resetStyles, elementStyles, styles$L];
__decorate$12([
  n$4({ type: Boolean })
], WuiInputNumeric.prototype, "disabled", void 0);
__decorate$12([
  n$4({ type: String })
], WuiInputNumeric.prototype, "value", void 0);
WuiInputNumeric = __decorate$12([
  customElement("wui-input-numeric")
], WuiInputNumeric);
const styles$K = i$7`
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-gray-glass-015);
  }
`;
var __decorate$11 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLink = class WuiLink2 extends s$3 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled} ontouchstart>
        <slot name="iconLeft"></slot>
        <wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `;
  }
};
WuiLink.styles = [resetStyles, elementStyles, styles$K];
__decorate$11([
  n$4({ type: Boolean })
], WuiLink.prototype, "disabled", void 0);
__decorate$11([
  n$4()
], WuiLink.prototype, "color", void 0);
WuiLink = __decorate$11([
  customElement("wui-link")
], WuiLink);
const styles$J = i$7`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > wui-flex {
    flex: 1;
  }

  button > wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > wui-icon {
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button[data-loading='true'] > wui-icon {
    transition: opacity 200ms ease-in-out;
    opacity: 0;
  }

  wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`;
var __decorate$10 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListItem = class WuiListItem2 extends s$3 {
  constructor() {
    super(...arguments);
    this.variant = "icon";
    this.disabled = false;
    this.imageSrc = void 0;
    this.alt = void 0;
    this.chevron = false;
    this.loading = false;
  }
  render() {
    return x$3`
      <button
        ?disabled=${this.loading ? true : Boolean(this.disabled)}
        data-loading=${this.loading}
        data-iconvariant=${o$4(this.iconVariant)}
        ontouchstart
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <wui-flex gap="3xs">
          <slot></slot>
        </wui-flex>
        ${this.chevronTemplate()}
      </button>
    `;
  }
  visualTemplate() {
    if (this.variant === "image" && this.imageSrc) {
      return x$3`<wui-image src=${this.imageSrc} alt=${this.alt ?? "list item"}></wui-image>`;
    } else if (this.iconVariant === "square" && this.icon && this.variant === "icon") {
      return x$3`<wui-icon name=${this.icon}></wui-icon>`;
    } else if (this.variant === "icon" && this.icon && this.iconVariant) {
      const color = ["blue", "square-blue"].includes(this.iconVariant) ? "accent-100" : "fg-200";
      const size2 = this.iconVariant === "square-blue" ? "mdl" : "md";
      const iconSize = this.iconSize ? this.iconSize : size2;
      return x$3`
        <wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${iconSize}
          background="transparent"
          iconColor=${color}
          backgroundColor=${color}
          size=${size2}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  loadingTemplate() {
    if (this.loading) {
      return x$3`<wui-loading-spinner color="fg-300"></wui-loading-spinner>`;
    }
    return x$3``;
  }
  chevronTemplate() {
    if (this.chevron) {
      return x$3`<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>`;
    }
    return null;
  }
};
WuiListItem.styles = [resetStyles, elementStyles, styles$J];
__decorate$10([
  n$4()
], WuiListItem.prototype, "icon", void 0);
__decorate$10([
  n$4()
], WuiListItem.prototype, "iconSize", void 0);
__decorate$10([
  n$4()
], WuiListItem.prototype, "variant", void 0);
__decorate$10([
  n$4()
], WuiListItem.prototype, "iconVariant", void 0);
__decorate$10([
  n$4({ type: Boolean })
], WuiListItem.prototype, "disabled", void 0);
__decorate$10([
  n$4()
], WuiListItem.prototype, "imageSrc", void 0);
__decorate$10([
  n$4()
], WuiListItem.prototype, "alt", void 0);
__decorate$10([
  n$4({ type: Boolean })
], WuiListItem.prototype, "chevron", void 0);
__decorate$10([
  n$4({ type: Boolean })
], WuiListItem.prototype, "loading", void 0);
WuiListItem = __decorate$10([
  customElement("wui-list-item")
], WuiListItem);
var TransactionTypePastTense;
(function(TransactionTypePastTense2) {
  TransactionTypePastTense2["approve"] = "approved";
  TransactionTypePastTense2["bought"] = "bought";
  TransactionTypePastTense2["borrow"] = "borrowed";
  TransactionTypePastTense2["burn"] = "burnt";
  TransactionTypePastTense2["cancel"] = "canceled";
  TransactionTypePastTense2["claim"] = "claimed";
  TransactionTypePastTense2["deploy"] = "deployed";
  TransactionTypePastTense2["deposit"] = "deposited";
  TransactionTypePastTense2["execute"] = "executed";
  TransactionTypePastTense2["mint"] = "minted";
  TransactionTypePastTense2["receive"] = "received";
  TransactionTypePastTense2["repay"] = "repaid";
  TransactionTypePastTense2["send"] = "sent";
  TransactionTypePastTense2["sell"] = "sold";
  TransactionTypePastTense2["stake"] = "staked";
  TransactionTypePastTense2["trade"] = "swapped";
  TransactionTypePastTense2["unstake"] = "unstaked";
  TransactionTypePastTense2["withdraw"] = "withdrawn";
})(TransactionTypePastTense || (TransactionTypePastTense = {}));
const styles$I = i$7`
  :host > wui-flex {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: 40px;
    height: 40px;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-005);
  }

  :host > wui-flex wui-image {
    display: block;
    z-index: -1;
  }

  :host > wui-flex,
  :host > wui-flex wui-image,
  .swap-images-container,
  .swap-images-container.nft,
  wui-image.nft {
    border-top-left-radius: var(--local-left-border-radius);
    border-top-right-radius: var(--local-right-border-radius);
    border-bottom-left-radius: var(--local-left-border-radius);
    border-bottom-right-radius: var(--local-right-border-radius);
  }

  wui-icon {
    width: 20px;
    height: 20px;
  }

  wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }

  .swap-images-container {
    position: relative;
    width: 40px;
    height: 40px;
    overflow: hidden;
  }

  .swap-images-container wui-image:first-child {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 0;
    left: 0%;
    clip-path: inset(0px calc(50% + 2px) 0px 0%);
  }

  .swap-images-container wui-image:last-child {
    clip-path: inset(0px 0px 0px calc(50% + 2px));
  }
`;
var __decorate$$ = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTransactionVisual = class WuiTransactionVisual2 extends s$3 {
  constructor() {
    super(...arguments);
    this.images = [];
    this.secondImage = {
      type: void 0,
      url: ""
    };
  }
  render() {
    const [firstImage, secondImage] = this.images;
    const isLeftNFT = firstImage?.type === "NFT";
    const isRightNFT = secondImage?.url ? secondImage.type === "NFT" : isLeftNFT;
    const leftRadius = isLeftNFT ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
    const rightRadius = isRightNFT ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
    this.style.cssText = `
    --local-left-border-radius: ${leftRadius};
    --local-right-border-radius: ${rightRadius};
    `;
    return x$3`<wui-flex> ${this.templateVisual()} ${this.templateIcon()} </wui-flex>`;
  }
  templateVisual() {
    const [firstImage, secondImage] = this.images;
    const firstImageType = firstImage?.type;
    const haveTwoImages = this.images.length === 2;
    if (haveTwoImages && (firstImage?.url || secondImage?.url)) {
      return x$3`<div class="swap-images-container">
        ${firstImage?.url ? x$3`<wui-image src=${firstImage.url} alt="Transaction image"></wui-image>` : null}
        ${secondImage?.url ? x$3`<wui-image src=${secondImage.url} alt="Transaction image"></wui-image>` : null}
      </div>`;
    } else if (firstImage?.url) {
      return x$3`<wui-image src=${firstImage.url} alt="Transaction image"></wui-image>`;
    } else if (firstImageType === "NFT") {
      return x$3`<wui-icon size="inherit" color="fg-200" name="nftPlaceholder"></wui-icon>`;
    }
    return x$3`<wui-icon size="inherit" color="fg-200" name="coinPlaceholder"></wui-icon>`;
  }
  templateIcon() {
    let color = "accent-100";
    let icon = void 0;
    icon = this.getIcon();
    if (this.status) {
      color = this.getStatusColor();
    }
    if (!icon) {
      return null;
    }
    return x$3`
      <wui-icon-box
        size="xxs"
        iconColor=${color}
        backgroundColor=${color}
        background="opaque"
        icon=${icon}
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
    `;
  }
  getDirectionIcon() {
    switch (this.direction) {
      case "in":
        return "arrowBottom";
      case "out":
        return "arrowTop";
      default:
        return void 0;
    }
  }
  getIcon() {
    if (this.onlyDirectionIcon) {
      return this.getDirectionIcon();
    }
    if (this.type === "trade") {
      return "swapHorizontalBold";
    } else if (this.type === "approve") {
      return "checkmark";
    } else if (this.type === "cancel") {
      return "close";
    }
    return this.getDirectionIcon();
  }
  getStatusColor() {
    switch (this.status) {
      case "confirmed":
        return "success-100";
      case "failed":
        return "error-100";
      case "pending":
        return "inverse-100";
      default:
        return "accent-100";
    }
  }
};
WuiTransactionVisual.styles = [styles$I];
__decorate$$([
  n$4()
], WuiTransactionVisual.prototype, "type", void 0);
__decorate$$([
  n$4()
], WuiTransactionVisual.prototype, "status", void 0);
__decorate$$([
  n$4()
], WuiTransactionVisual.prototype, "direction", void 0);
__decorate$$([
  n$4({ type: Boolean })
], WuiTransactionVisual.prototype, "onlyDirectionIcon", void 0);
__decorate$$([
  n$4({ type: Array })
], WuiTransactionVisual.prototype, "images", void 0);
__decorate$$([
  n$4({ type: Object })
], WuiTransactionVisual.prototype, "secondImage", void 0);
WuiTransactionVisual = __decorate$$([
  customElement("wui-transaction-visual")
], WuiTransactionVisual);
const styles$H = i$7`
  :host > wui-flex:first-child {
    align-items: center;
    column-gap: var(--wui-spacing-s);
    padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
    width: 100%;
  }

  :host > wui-flex:first-child wui-text:nth-child(1) {
    text-transform: capitalize;
  }

  wui-transaction-visual {
    width: 40px;
    height: 40px;
  }

  wui-flex {
    flex: 1;
  }

  :host wui-flex wui-flex {
    overflow: hidden;
  }

  :host .description-container wui-text span {
    word-break: break-all;
  }

  :host .description-container wui-text {
    overflow: hidden;
  }

  :host .description-separator-icon {
    margin: 0px 6px;
  }

  :host wui-text > span {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
`;
var __decorate$_ = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTransactionListItem = class WuiTransactionListItem2 extends s$3 {
  constructor() {
    super(...arguments);
    this.type = "approve";
    this.onlyDirectionIcon = false;
    this.images = [];
  }
  render() {
    return x$3`
      <wui-flex>
        <wui-transaction-visual
          .status=${this.status}
          direction=${o$4(this.direction)}
          type=${this.type}
          onlyDirectionIcon=${o$4(this.onlyDirectionIcon)}
          .images=${this.images}
        ></wui-transaction-visual>
        <wui-flex flexDirection="column" gap="3xs">
          <wui-text variant="paragraph-600" color="fg-100">
            ${TransactionTypePastTense[this.type]}
          </wui-text>
          <wui-flex class="description-container">
            ${this.templateDescription()} ${this.templateSecondDescription()}
          </wui-flex>
        </wui-flex>
        <wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>
      </wui-flex>
    `;
  }
  templateDescription() {
    const description = this.descriptions?.[0];
    return description ? x$3`
          <wui-text variant="small-500" color="fg-200">
            <span>${description}</span>
          </wui-text>
        ` : null;
  }
  templateSecondDescription() {
    const description = this.descriptions?.[1];
    return description ? x$3`
          <wui-icon class="description-separator-icon" size="xxs" name="arrowRight"></wui-icon>
          <wui-text variant="small-400" color="fg-200">
            <span>${description}</span>
          </wui-text>
        ` : null;
  }
};
WuiTransactionListItem.styles = [resetStyles, styles$H];
__decorate$_([
  n$4()
], WuiTransactionListItem.prototype, "type", void 0);
__decorate$_([
  n$4({ type: Array })
], WuiTransactionListItem.prototype, "descriptions", void 0);
__decorate$_([
  n$4()
], WuiTransactionListItem.prototype, "date", void 0);
__decorate$_([
  n$4({ type: Boolean })
], WuiTransactionListItem.prototype, "onlyDirectionIcon", void 0);
__decorate$_([
  n$4()
], WuiTransactionListItem.prototype, "status", void 0);
__decorate$_([
  n$4()
], WuiTransactionListItem.prototype, "direction", void 0);
__decorate$_([
  n$4({ type: Array })
], WuiTransactionListItem.prototype, "images", void 0);
WuiTransactionListItem = __decorate$_([
  customElement("wui-transaction-list-item")
], WuiTransactionListItem);
const styles$G = i$7`
  :host > wui-flex:first-child {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
  }

  wui-flex {
    display: flex;
    flex: 1;
  }
`;
var __decorate$Z = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTransactionListItemLoader = class WuiTransactionListItemLoader2 extends s$3 {
  render() {
    return x$3`
      <wui-flex alignItems="center">
        <wui-shimmer width="40px" height="40px"></wui-shimmer>
        <wui-flex flexDirection="column" gap="2xs">
          <wui-shimmer width="72px" height="16px" borderRadius="4xs"></wui-shimmer>
          <wui-shimmer width="148px" height="14px" borderRadius="4xs"></wui-shimmer>
        </wui-flex>
        <wui-shimmer width="24px" height="12px" borderRadius="5xs"></wui-shimmer>
      </wui-flex>
    `;
  }
};
WuiTransactionListItemLoader.styles = [resetStyles, styles$G];
WuiTransactionListItemLoader = __decorate$Z([
  customElement("wui-transaction-list-item-loader")
], WuiTransactionListItemLoader);
const styles$F = i$7`
  :host {
    display: block;
    padding: 3.5px 5px !important;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }
`;
var __decorate$Y = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTag = class WuiTag2 extends s$3 {
  constructor() {
    super(...arguments);
    this.variant = "main";
  }
  render() {
    this.dataset["variant"] = this.variant;
    return x$3`
      <wui-text data-variant=${this.variant} variant="micro-700" color="inherit">
        <slot></slot>
      </wui-text>
    `;
  }
};
WuiTag.styles = [resetStyles, styles$F];
__decorate$Y([
  n$4()
], WuiTag.prototype, "variant", void 0);
WuiTag = __decorate$Y([
  customElement("wui-tag")
], WuiTag);
const styles$E = i$7`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;
var __decorate$X = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListWallet = class WuiListWallet2 extends s$3 {
  constructor() {
    super(...arguments);
    this.walletImages = [];
    this.imageSrc = "";
    this.name = "";
    this.installed = false;
    this.disabled = false;
    this.showAllWallets = false;
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled} ontouchstart>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
        ${this.templateStatus()}
      </button>
    `;
  }
  templateAllWallets() {
    if (this.showAllWallets && this.imageSrc) {
      return x$3` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> `;
    } else if (this.showAllWallets && this.walletIcon) {
      return x$3` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> `;
    }
    return null;
  }
  templateWalletImage() {
    if (!this.showAllWallets && this.imageSrc) {
      return x$3`<wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
        .installed=${this.installed}
      ></wui-wallet-image>`;
    } else if (!this.showAllWallets && !this.imageSrc) {
      return x$3`<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>`;
    }
    return null;
  }
  templateStatus() {
    if (this.tagLabel && this.tagVariant) {
      return x$3`<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>`;
    } else if (this.icon) {
      return x$3`<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>`;
    }
    return null;
  }
};
WuiListWallet.styles = [resetStyles, elementStyles, styles$E];
__decorate$X([
  n$4({ type: Array })
], WuiListWallet.prototype, "walletImages", void 0);
__decorate$X([
  n$4()
], WuiListWallet.prototype, "imageSrc", void 0);
__decorate$X([
  n$4()
], WuiListWallet.prototype, "name", void 0);
__decorate$X([
  n$4()
], WuiListWallet.prototype, "tagLabel", void 0);
__decorate$X([
  n$4()
], WuiListWallet.prototype, "tagVariant", void 0);
__decorate$X([
  n$4()
], WuiListWallet.prototype, "icon", void 0);
__decorate$X([
  n$4()
], WuiListWallet.prototype, "walletIcon", void 0);
__decorate$X([
  n$4({ type: Boolean })
], WuiListWallet.prototype, "installed", void 0);
__decorate$X([
  n$4({ type: Boolean })
], WuiListWallet.prototype, "disabled", void 0);
__decorate$X([
  n$4({ type: Boolean })
], WuiListWallet.prototype, "showAllWallets", void 0);
WuiListWallet = __decorate$X([
  customElement("wui-list-wallet")
], WuiListWallet);
const styles$D = i$7`
  :host {
    display: block;
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-010);
    overflow: hidden;
  }

  wui-icon {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$W = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLogo = class WuiLogo2 extends s$3 {
  constructor() {
    super(...arguments);
    this.logo = "google";
  }
  render() {
    return x$3`<wui-icon color="inherit" size="inherit" name=${this.logo}></wui-icon> `;
  }
};
WuiLogo.styles = [resetStyles, styles$D];
__decorate$W([
  n$4()
], WuiLogo.prototype, "logo", void 0);
WuiLogo = __decorate$W([
  customElement("wui-logo")
], WuiLogo);
const styles$C = i$7`
  :host {
    display: block;
  }

  button {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$V = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLogoSelect = class WuiLogoSelect2 extends s$3 {
  constructor() {
    super(...arguments);
    this.logo = "google";
    this.disabled = false;
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-logo logo=${this.logo}></wui-logo>
      </button>
    `;
  }
};
WuiLogoSelect.styles = [resetStyles, elementStyles, styles$C];
__decorate$V([
  n$4()
], WuiLogoSelect.prototype, "logo", void 0);
__decorate$V([
  n$4({ type: Boolean })
], WuiLogoSelect.prototype, "disabled", void 0);
WuiLogoSelect = __decorate$V([
  customElement("wui-logo-select")
], WuiLogoSelect);
const styles$B = i$7`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-s) var(--wui-spacing-2xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-gray-glass-005);
    color: var(--wui-color-fg-100);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-010);
    }

    button:active:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }
`;
var __decorate$U = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiNetworkButton = class WuiNetworkButton2 extends s$3 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.disabled = false;
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled}>
        ${this.visualTemplate()}
        <wui-text variant="paragraph-600" color="inherit">
          <slot></slot>
        </wui-text>
      </button>
    `;
  }
  visualTemplate() {
    if (this.imageSrc) {
      return x$3`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return x$3`
      <wui-icon-box
        size="sm"
        iconColor="inverse-100"
        backgroundColor="fg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
  }
};
WuiNetworkButton.styles = [resetStyles, elementStyles, styles$B];
__decorate$U([
  n$4()
], WuiNetworkButton.prototype, "imageSrc", void 0);
__decorate$U([
  n$4({ type: Boolean })
], WuiNetworkButton.prototype, "disabled", void 0);
WuiNetworkButton = __decorate$U([
  customElement("wui-network-button")
], WuiNetworkButton);
const styles$A = i$7`
  :host {
    position: relative;
    display: block;
  }
`;
var __decorate$T = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiOtp = class WuiOtp2 extends s$3 {
  constructor() {
    super(...arguments);
    this.length = 6;
    this.otp = "";
    this.values = Array.from({ length: this.length }).map(() => "");
    this.numerics = [];
    this.shouldInputBeEnabled = (index2) => {
      const previousInputs = this.values.slice(0, index2);
      return previousInputs.every((input) => input !== "");
    };
    this.handleKeyDown = (e2, index2) => {
      const inputElement = e2.target;
      const input = this.getInputElement(inputElement);
      const keyArr = ["ArrowLeft", "ArrowRight", "Shift", "Delete"];
      if (!input) {
        return;
      }
      if (keyArr.includes(e2.key)) {
        e2.preventDefault();
      }
      const currentCaretPos = input.selectionStart;
      switch (e2.key) {
        case "ArrowLeft":
          if (currentCaretPos) {
            input.setSelectionRange(currentCaretPos + 1, currentCaretPos + 1);
          }
          this.focusInputField("prev", index2);
          break;
        case "ArrowRight":
          this.focusInputField("next", index2);
          break;
        case "Shift":
          this.focusInputField("next", index2);
          break;
        case "Delete":
          if (input.value === "") {
            this.focusInputField("prev", index2);
          } else {
            this.updateInput(input, index2, "");
          }
          break;
        case "Backspace":
          if (input.value === "") {
            this.focusInputField("prev", index2);
          } else {
            this.updateInput(input, index2, "");
          }
          break;
      }
    };
    this.focusInputField = (dir, index2) => {
      if (dir === "next") {
        const nextIndex = index2 + 1;
        if (!this.shouldInputBeEnabled(nextIndex)) {
          return;
        }
        const numeric2 = this.numerics[nextIndex < this.length ? nextIndex : index2];
        const input = numeric2 ? this.getInputElement(numeric2) : void 0;
        if (input) {
          input.disabled = false;
          input.focus();
        }
      }
      if (dir === "prev") {
        const nextIndex = index2 - 1;
        const numeric2 = this.numerics[nextIndex > -1 ? nextIndex : index2];
        const input = numeric2 ? this.getInputElement(numeric2) : void 0;
        if (input) {
          input.focus();
        }
      }
    };
  }
  firstUpdated() {
    if (this.otp) {
      this.values = this.otp.split("");
    }
    const numericElements = this.shadowRoot?.querySelectorAll("wui-input-numeric");
    if (numericElements) {
      this.numerics = Array.from(numericElements);
    }
    this.numerics[0]?.focus();
  }
  render() {
    return x$3`
      <wui-flex gap="xxs" data-testid="wui-otp-input">
        ${Array.from({ length: this.length }).map((_3, index2) => x$3`
            <wui-input-numeric
              @input=${(e2) => this.handleInput(e2, index2)}
              @keydown=${(e2) => this.handleKeyDown(e2, index2)}
              .disabled=${!this.shouldInputBeEnabled(index2)}
              .value=${this.values[index2] || ""}
            >
            </wui-input-numeric>
          `)}
      </wui-flex>
    `;
  }
  updateInput(element, index2, value) {
    const numeric2 = this.numerics[index2];
    const input = element || (numeric2 ? this.getInputElement(numeric2) : void 0);
    if (input) {
      input.value = value;
      this.values = this.values.map((val, i3) => i3 === index2 ? value : val);
    }
  }
  handleInput(e2, index2) {
    const inputElement = e2.target;
    const input = this.getInputElement(inputElement);
    if (input) {
      const inputValue = input.value;
      if (e2.inputType === "insertFromPaste") {
        this.handlePaste(input, inputValue, index2);
      } else {
        const isValid3 = UiHelperUtil.isNumber(inputValue);
        if (isValid3 && e2.data) {
          this.updateInput(input, index2, e2.data);
          this.focusInputField("next", index2);
        } else {
          this.updateInput(input, index2, "");
        }
      }
    }
    this.dispatchInputChangeEvent();
  }
  handlePaste(input, inputValue, index2) {
    const value = inputValue[0];
    const isValid3 = value && UiHelperUtil.isNumber(value);
    if (isValid3) {
      this.updateInput(input, index2, value);
      const inputString = inputValue.substring(1);
      if (index2 + 1 < this.length && inputString.length) {
        const nextNumeric = this.numerics[index2 + 1];
        const nextInput = nextNumeric ? this.getInputElement(nextNumeric) : void 0;
        if (nextInput) {
          this.handlePaste(nextInput, inputString, index2 + 1);
        }
      } else {
        this.focusInputField("next", index2);
      }
    } else {
      this.updateInput(input, index2, "");
    }
  }
  getInputElement(el2) {
    if (el2.shadowRoot?.querySelector("input")) {
      return el2.shadowRoot.querySelector("input");
    }
    return null;
  }
  dispatchInputChangeEvent() {
    const value = this.values.join("");
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiOtp.styles = [resetStyles, styles$A];
__decorate$T([
  n$4({ type: Number })
], WuiOtp.prototype, "length", void 0);
__decorate$T([
  n$4({ type: String })
], WuiOtp.prototype, "otp", void 0);
__decorate$T([
  r$4()
], WuiOtp.prototype, "values", void 0);
WuiOtp = __decorate$T([
  customElement("wui-otp")
], WuiOtp);
var browser$b = {};
var canPromise$1 = function() {
  return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};
const canPromise$2 = /* @__PURE__ */ getDefaultExportFromCjs(canPromise$1);
const canPromise$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: canPromise$2
}, [canPromise$1]);
const require$$0$1s = /* @__PURE__ */ getAugmentedNamespace(canPromise$3);
var qrcode$1 = {};
var utils$h = {};
let toSJISFunction;
const CODEWORDS_COUNT = [
  0,
  // Not used
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
var getSymbolSize$1 = utils$h.getSymbolSize = function getSymbolSize2(version2) {
  if (!version2)
    throw new Error('"version" cannot be null or undefined');
  if (version2 < 1 || version2 > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return version2 * 4 + 17;
};
var getSymbolTotalCodewords = utils$h.getSymbolTotalCodewords = function getSymbolTotalCodewords2(version2) {
  return CODEWORDS_COUNT[version2];
};
var getBCHDigit = utils$h.getBCHDigit = function(data2) {
  let digit = 0;
  while (data2 !== 0) {
    digit++;
    data2 >>>= 1;
  }
  return digit;
};
var setToSJISFunction = utils$h.setToSJISFunction = function setToSJISFunction2(f4) {
  if (typeof f4 !== "function") {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction = f4;
};
var isKanjiModeEnabled = utils$h.isKanjiModeEnabled = function() {
  return typeof toSJISFunction !== "undefined";
};
var toSJIS = utils$h.toSJIS = function toSJIS2(kanji2) {
  return toSJISFunction(kanji2);
};
const utils$g = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$h,
  getBCHDigit,
  getSymbolSize: getSymbolSize$1,
  getSymbolTotalCodewords,
  isKanjiModeEnabled,
  setToSJISFunction,
  toSJIS
}, [utils$h]);
const require$$0$1r = /* @__PURE__ */ getAugmentedNamespace(utils$g);
var errorCorrectionLevel$2 = {};
(function(exports2) {
  exports2.L = { bit: 1 };
  exports2.M = { bit: 0 };
  exports2.Q = { bit: 3 };
  exports2.H = { bit: 2 };
  function fromString2(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports2.L;
      case "m":
      case "medium":
        return exports2.M;
      case "q":
      case "quartile":
        return exports2.Q;
      case "h":
      case "high":
        return exports2.H;
      default:
        throw new Error("Unknown EC Level: " + string2);
    }
  }
  exports2.isValid = function isValid3(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports2.from = function from2(value, defaultValue) {
    if (exports2.isValid(value)) {
      return value;
    }
    try {
      return fromString2(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(errorCorrectionLevel$2);
const errorCorrectionLevel = /* @__PURE__ */ getDefaultExportFromCjs(errorCorrectionLevel$2);
const errorCorrectionLevel$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: errorCorrectionLevel
}, [errorCorrectionLevel$2]);
const require$$1$N = /* @__PURE__ */ getAugmentedNamespace(errorCorrectionLevel$1);
function BitBuffer$1() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer$1.prototype = {
  get: function(index2) {
    const bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
  },
  put: function(num, length2) {
    for (let i3 = 0; i3 < length2; i3++) {
      this.putBit((num >>> length2 - i3 - 1 & 1) === 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var bitBuffer = BitBuffer$1;
const bitBuffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(bitBuffer);
const bitBuffer$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: bitBuffer$1
}, [bitBuffer]);
const require$$2$u = /* @__PURE__ */ getAugmentedNamespace(bitBuffer$2);
function BitMatrix$1(size2) {
  if (!size2 || size2 < 1) {
    throw new Error("BitMatrix size must be defined and greater than 0");
  }
  this.size = size2;
  this.data = new Uint8Array(size2 * size2);
  this.reservedBit = new Uint8Array(size2 * size2);
}
BitMatrix$1.prototype.set = function(row, col, value, reserved) {
  const index2 = row * this.size + col;
  this.data[index2] = value;
  if (reserved)
    this.reservedBit[index2] = true;
};
BitMatrix$1.prototype.get = function(row, col) {
  return this.data[row * this.size + col];
};
BitMatrix$1.prototype.xor = function(row, col, value) {
  this.data[row * this.size + col] ^= value;
};
BitMatrix$1.prototype.isReserved = function(row, col) {
  return this.reservedBit[row * this.size + col];
};
var bitMatrix = BitMatrix$1;
const bitMatrix$1 = /* @__PURE__ */ getDefaultExportFromCjs(bitMatrix);
const bitMatrix$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: bitMatrix$1
}, [bitMatrix]);
const require$$3$k = /* @__PURE__ */ getAugmentedNamespace(bitMatrix$2);
var alignmentPattern$2 = {};
(function(exports2) {
  const getSymbolSize3 = require$$0$1r.getSymbolSize;
  exports2.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1)
      return [];
    const posCount = Math.floor(version2 / 7) + 2;
    const size2 = getSymbolSize3(version2);
    const intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
    const positions = [size2 - 7];
    for (let i3 = 1; i3 < posCount - 1; i3++) {
      positions[i3] = positions[i3 - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports2.getPositions = function getPositions3(version2) {
    const coords = [];
    const pos = exports2.getRowColCoords(version2);
    const posLength = pos.length;
    for (let i3 = 0; i3 < posLength; i3++) {
      for (let j2 = 0; j2 < posLength; j2++) {
        if (i3 === 0 && j2 === 0 || // top-left
        i3 === 0 && j2 === posLength - 1 || // bottom-left
        i3 === posLength - 1 && j2 === 0) {
          continue;
        }
        coords.push([pos[i3], pos[j2]]);
      }
    }
    return coords;
  };
})(alignmentPattern$2);
const alignmentPattern = /* @__PURE__ */ getDefaultExportFromCjs(alignmentPattern$2);
const alignmentPattern$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: alignmentPattern
}, [alignmentPattern$2]);
const require$$4$f = /* @__PURE__ */ getAugmentedNamespace(alignmentPattern$1);
var finderPattern$1 = {};
const getSymbolSize = require$$0$1r.getSymbolSize;
const FINDER_PATTERN_SIZE = 7;
var getPositions = finderPattern$1.getPositions = function getPositions2(version2) {
  const size2 = getSymbolSize(version2);
  return [
    // top-left
    [0, 0],
    // top-right
    [size2 - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size2 - FINDER_PATTERN_SIZE]
  ];
};
const finderPattern = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: finderPattern$1,
  getPositions
}, [finderPattern$1]);
const require$$5$e = /* @__PURE__ */ getAugmentedNamespace(finderPattern);
var maskPattern$2 = {};
(function(exports2) {
  exports2.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports2.isValid = function isValid3(mask2) {
    return mask2 != null && mask2 !== "" && !isNaN(mask2) && mask2 >= 0 && mask2 <= 7;
  };
  exports2.from = function from2(value) {
    return exports2.isValid(value) ? parseInt(value, 10) : void 0;
  };
  exports2.getPenaltyN1 = function getPenaltyN1(data2) {
    const size2 = data2.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for (let row = 0; row < size2; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (let col = 0; col < size2; col++) {
        let module2 = data2.get(row, col);
        if (module2 === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module2;
          sameCountCol = 1;
        }
        module2 = data2.get(col, row);
        if (module2 === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module2;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5)
        points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5)
        points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports2.getPenaltyN2 = function getPenaltyN2(data2) {
    const size2 = data2.size;
    let points = 0;
    for (let row = 0; row < size2 - 1; row++) {
      for (let col = 0; col < size2 - 1; col++) {
        const last2 = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
        if (last2 === 4 || last2 === 0)
          points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports2.getPenaltyN3 = function getPenaltyN3(data2) {
    const size2 = data2.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for (let row = 0; row < size2; row++) {
      bitsCol = bitsRow = 0;
      for (let col = 0; col < size2; col++) {
        bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
          points++;
        bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
          points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports2.getPenaltyN4 = function getPenaltyN4(data2) {
    let darkCount = 0;
    const modulesCount = data2.data.length;
    for (let i3 = 0; i3 < modulesCount; i3++)
      darkCount += data2.data[i3];
    const k3 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k3 * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern2, i3, j2) {
    switch (maskPattern2) {
      case exports2.Patterns.PATTERN000:
        return (i3 + j2) % 2 === 0;
      case exports2.Patterns.PATTERN001:
        return i3 % 2 === 0;
      case exports2.Patterns.PATTERN010:
        return j2 % 3 === 0;
      case exports2.Patterns.PATTERN011:
        return (i3 + j2) % 3 === 0;
      case exports2.Patterns.PATTERN100:
        return (Math.floor(i3 / 2) + Math.floor(j2 / 3)) % 2 === 0;
      case exports2.Patterns.PATTERN101:
        return i3 * j2 % 2 + i3 * j2 % 3 === 0;
      case exports2.Patterns.PATTERN110:
        return (i3 * j2 % 2 + i3 * j2 % 3) % 2 === 0;
      case exports2.Patterns.PATTERN111:
        return (i3 * j2 % 3 + (i3 + j2) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  }
  exports2.applyMask = function applyMask(pattern2, data2) {
    const size2 = data2.size;
    for (let col = 0; col < size2; col++) {
      for (let row = 0; row < size2; row++) {
        if (data2.isReserved(row, col))
          continue;
        data2.xor(row, col, getMaskAt(pattern2, row, col));
      }
    }
  };
  exports2.getBestMask = function getBestMask(data2, setupFormatFunc) {
    const numPatterns = Object.keys(exports2.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for (let p3 = 0; p3 < numPatterns; p3++) {
      setupFormatFunc(p3);
      exports2.applyMask(p3, data2);
      const penalty = exports2.getPenaltyN1(data2) + exports2.getPenaltyN2(data2) + exports2.getPenaltyN3(data2) + exports2.getPenaltyN4(data2);
      exports2.applyMask(p3, data2);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p3;
      }
    }
    return bestPattern;
  };
})(maskPattern$2);
const maskPattern = /* @__PURE__ */ getDefaultExportFromCjs(maskPattern$2);
const maskPattern$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: maskPattern
}, [maskPattern$2]);
const require$$6$b = /* @__PURE__ */ getAugmentedNamespace(maskPattern$1);
var errorCorrectionCode$1 = {};
const ECLevel$1 = require$$1$N;
const EC_BLOCKS_TABLE = [
  // L  M  Q  H
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
];
const EC_CODEWORDS_TABLE = [
  // L  M  Q  H
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
var getBlocksCount = errorCorrectionCode$1.getBlocksCount = function getBlocksCount2(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var getTotalCodewordsCount = errorCorrectionCode$1.getTotalCodewordsCount = function getTotalCodewordsCount2(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
const errorCorrectionCode = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: errorCorrectionCode$1,
  getBlocksCount,
  getTotalCodewordsCount
}, [errorCorrectionCode$1]);
const require$$7$6 = /* @__PURE__ */ getAugmentedNamespace(errorCorrectionCode);
var polynomial$2 = {};
var galoisField$1 = {};
const EXP_TABLE = new Uint8Array(512);
const LOG_TABLE = new Uint8Array(256);
(function initTables() {
  let x2 = 1;
  for (let i3 = 0; i3 < 255; i3++) {
    EXP_TABLE[i3] = x2;
    LOG_TABLE[x2] = i3;
    x2 <<= 1;
    if (x2 & 256) {
      x2 ^= 285;
    }
  }
  for (let i3 = 255; i3 < 512; i3++) {
    EXP_TABLE[i3] = EXP_TABLE[i3 - 255];
  }
})();
var log$1 = galoisField$1.log = function log2(n4) {
  if (n4 < 1)
    throw new Error("log(" + n4 + ")");
  return LOG_TABLE[n4];
};
var exp = galoisField$1.exp = function exp2(n4) {
  return EXP_TABLE[n4];
};
var mul = galoisField$1.mul = function mul4(x2, y3) {
  if (x2 === 0 || y3 === 0)
    return 0;
  return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y3]];
};
const galoisField = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: galoisField$1,
  exp,
  log: log$1,
  mul
}, [galoisField$1]);
const require$$0$1q = /* @__PURE__ */ getAugmentedNamespace(galoisField);
(function(exports2) {
  const GF = require$$0$1q;
  exports2.mul = function mul5(p1, p22) {
    const coeff = new Uint8Array(p1.length + p22.length - 1);
    for (let i3 = 0; i3 < p1.length; i3++) {
      for (let j2 = 0; j2 < p22.length; j2++) {
        coeff[i3 + j2] ^= GF.mul(p1[i3], p22[j2]);
      }
    }
    return coeff;
  };
  exports2.mod = function mod2(divident, divisor) {
    let result = new Uint8Array(divident);
    while (result.length - divisor.length >= 0) {
      const coeff = result[0];
      for (let i3 = 0; i3 < divisor.length; i3++) {
        result[i3] ^= GF.mul(divisor[i3], coeff);
      }
      let offset = 0;
      while (offset < result.length && result[offset] === 0)
        offset++;
      result = result.slice(offset);
    }
    return result;
  };
  exports2.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1]);
    for (let i3 = 0; i3 < degree; i3++) {
      poly = exports2.mul(poly, new Uint8Array([1, GF.exp(i3)]));
    }
    return poly;
  };
})(polynomial$2);
const polynomial = /* @__PURE__ */ getDefaultExportFromCjs(polynomial$2);
const polynomial$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: polynomial
}, [polynomial$2]);
const require$$0$1p = /* @__PURE__ */ getAugmentedNamespace(polynomial$1);
const Polynomial = require$$0$1p;
function ReedSolomonEncoder$1(degree) {
  this.genPoly = void 0;
  this.degree = degree;
  if (this.degree)
    this.initialize(this.degree);
}
ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$1.prototype.encode = function encode3(data2) {
  if (!this.genPoly) {
    throw new Error("Encoder not initialized");
  }
  const paddedData = new Uint8Array(data2.length + this.degree);
  paddedData.set(data2);
  const remainder = Polynomial.mod(paddedData, this.genPoly);
  const start = this.degree - remainder.length;
  if (start > 0) {
    const buff = new Uint8Array(this.degree);
    buff.set(remainder, start);
    return buff;
  }
  return remainder;
};
var reedSolomonEncoder = ReedSolomonEncoder$1;
const reedSolomonEncoder$1 = /* @__PURE__ */ getDefaultExportFromCjs(reedSolomonEncoder);
const reedSolomonEncoder$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: reedSolomonEncoder$1
}, [reedSolomonEncoder]);
const require$$8$5 = /* @__PURE__ */ getAugmentedNamespace(reedSolomonEncoder$2);
var version$7 = {};
var mode$2 = {};
var versionCheck$1 = {};
var isValid$1 = versionCheck$1.isValid = function isValid2(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40;
};
const versionCheck = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: versionCheck$1,
  isValid: isValid$1
}, [versionCheck$1]);
const require$$4$e = /* @__PURE__ */ getAugmentedNamespace(versionCheck);
var regex$1 = {};
const numeric$1 = "[0-9]+";
const alphanumeric = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
var KANJI = regex$1.KANJI = new RegExp(kanji, "g");
var BYTE_KANJI = regex$1.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
var BYTE = regex$1.BYTE = new RegExp(byte, "g");
var NUMERIC = regex$1.NUMERIC = new RegExp(numeric$1, "g");
var ALPHANUMERIC = regex$1.ALPHANUMERIC = new RegExp(alphanumeric, "g");
const TEST_KANJI = new RegExp("^" + kanji + "$");
const TEST_NUMERIC = new RegExp("^" + numeric$1 + "$");
const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
var testKanji = regex$1.testKanji = function testKanji2(str) {
  return TEST_KANJI.test(str);
};
var testNumeric = regex$1.testNumeric = function testNumeric2(str) {
  return TEST_NUMERIC.test(str);
};
var testAlphanumeric = regex$1.testAlphanumeric = function testAlphanumeric2(str) {
  return TEST_ALPHANUMERIC.test(str);
};
const regex = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  ALPHANUMERIC,
  BYTE,
  BYTE_KANJI,
  KANJI,
  NUMERIC,
  default: regex$1,
  testAlphanumeric,
  testKanji,
  testNumeric
}, [regex$1]);
const require$$5$d = /* @__PURE__ */ getAugmentedNamespace(regex);
(function(exports2) {
  const VersionCheck = require$$4$e;
  const Regex = require$$5$d;
  exports2.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports2.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports2.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports2.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports2.MIXED = {
    bit: -1
  };
  exports2.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
    if (!mode2.ccBits)
      throw new Error("Invalid mode: " + mode2);
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid version: " + version2);
    }
    if (version2 >= 1 && version2 < 10)
      return mode2.ccBits[0];
    else if (version2 < 27)
      return mode2.ccBits[1];
    return mode2.ccBits[2];
  };
  exports2.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr))
      return exports2.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr))
      return exports2.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr))
      return exports2.KANJI;
    else
      return exports2.BYTE;
  };
  exports2.toString = function toString3(mode2) {
    if (mode2 && mode2.id)
      return mode2.id;
    throw new Error("Invalid mode");
  };
  exports2.isValid = function isValid3(mode2) {
    return mode2 && mode2.bit && mode2.ccBits;
  };
  function fromString2(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports2.NUMERIC;
      case "alphanumeric":
        return exports2.ALPHANUMERIC;
      case "kanji":
        return exports2.KANJI;
      case "byte":
        return exports2.BYTE;
      default:
        throw new Error("Unknown mode: " + string2);
    }
  }
  exports2.from = function from2(value, defaultValue) {
    if (exports2.isValid(value)) {
      return value;
    }
    try {
      return fromString2(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(mode$2);
const mode = /* @__PURE__ */ getDefaultExportFromCjs(mode$2);
const mode$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: mode
}, [mode$2]);
const require$$11$5 = /* @__PURE__ */ getAugmentedNamespace(mode$1);
(function(exports2) {
  const Utils2 = require$$0$1r;
  const ECCode2 = require$$7$6;
  const ECLevel2 = require$$1$N;
  const Mode2 = require$$11$5;
  const VersionCheck = require$$4$e;
  const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  const G18_BCH = Utils2.getBCHDigit(G18);
  function getBestVersionForDataLength(mode2, length2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (length2 <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4;
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    let totalBits = 0;
    segments2.forEach(function(data2) {
      const reservedBits = getReservedBitsCount(data2.mode, version2);
      totalBits += reservedBits + data2.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      const length2 = getTotalBitsFromDataArray(segments2, currentVersion);
      if (length2 <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  exports2.from = function from2(value, defaultValue) {
    if (VersionCheck.isValid(value)) {
      return parseInt(value, 10);
    }
    return defaultValue;
  };
  exports2.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode2 === "undefined")
      mode2 = Mode2.BYTE;
    const totalCodewords = Utils2.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode2 === Mode2.MIXED)
      return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode2.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode2.KANJI:
        return Math.floor(usableBits / 13);
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports2.getBestVersionForData = function getBestVersionForData(data2, errorCorrectionLevel2) {
    let seg;
    const ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
    if (Array.isArray(data2)) {
      if (data2.length > 1) {
        return getBestVersionForMixedData(data2, ecl);
      }
      if (data2.length === 0) {
        return 1;
      }
      seg = data2[0];
    } else {
      seg = data2;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports2.getEncodedBits = function getEncodedBits3(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error("Invalid QR Code version");
    }
    let d3 = version2 << 12;
    while (Utils2.getBCHDigit(d3) - G18_BCH >= 0) {
      d3 ^= G18 << Utils2.getBCHDigit(d3) - G18_BCH;
    }
    return version2 << 12 | d3;
  };
})(version$7);
const version$5 = /* @__PURE__ */ getDefaultExportFromCjs(version$7);
const version$6 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: version$5
}, [version$7]);
const require$$9$5 = /* @__PURE__ */ getAugmentedNamespace(version$6);
var formatInfo$1 = {};
const Utils$3 = require$$0$1r;
const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
const G15_BCH = Utils$3.getBCHDigit(G15);
var getEncodedBits = formatInfo$1.getEncodedBits = function getEncodedBits2(errorCorrectionLevel2, mask2) {
  const data2 = errorCorrectionLevel2.bit << 3 | mask2;
  let d3 = data2 << 10;
  while (Utils$3.getBCHDigit(d3) - G15_BCH >= 0) {
    d3 ^= G15 << Utils$3.getBCHDigit(d3) - G15_BCH;
  }
  return (data2 << 10 | d3) ^ G15_MASK;
};
const formatInfo = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formatInfo$1,
  getEncodedBits
}, [formatInfo$1]);
const require$$10$5 = /* @__PURE__ */ getAugmentedNamespace(formatInfo);
var segments$2 = {};
const Mode$4 = require$$11$5;
function NumericData(data2) {
  this.mode = Mode$4.NUMERIC;
  this.data = data2.toString();
}
NumericData.getBitsLength = function getBitsLength(length2) {
  return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength2() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength2() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write2(bitBuffer2) {
  let i3, group, value;
  for (i3 = 0; i3 + 3 <= this.data.length; i3 += 3) {
    group = this.data.substr(i3, 3);
    value = parseInt(group, 10);
    bitBuffer2.put(value, 10);
  }
  const remainingNum = this.data.length - i3;
  if (remainingNum > 0) {
    group = this.data.substr(i3);
    value = parseInt(group, 10);
    bitBuffer2.put(value, remainingNum * 3 + 1);
  }
};
var numericData = NumericData;
const numericData$1 = /* @__PURE__ */ getDefaultExportFromCjs(numericData);
const numericData$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: numericData$1
}, [numericData]);
const require$$1$M = /* @__PURE__ */ getAugmentedNamespace(numericData$2);
const Mode$3 = require$$11$5;
const ALPHA_NUM_CHARS = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function AlphanumericData(data2) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data2;
}
AlphanumericData.getBitsLength = function getBitsLength3(length2) {
  return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
};
AlphanumericData.prototype.getLength = function getLength3() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength4() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write3(bitBuffer2) {
  let i3;
  for (i3 = 0; i3 + 2 <= this.data.length; i3 += 2) {
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i3]) * 45;
    value += ALPHA_NUM_CHARS.indexOf(this.data[i3 + 1]);
    bitBuffer2.put(value, 11);
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i3]), 6);
  }
};
var alphanumericData = AlphanumericData;
const alphanumericData$1 = /* @__PURE__ */ getDefaultExportFromCjs(alphanumericData);
const alphanumericData$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: alphanumericData$1
}, [alphanumericData]);
const require$$2$t = /* @__PURE__ */ getAugmentedNamespace(alphanumericData$2);
var encodeUtf8$1 = function encodeUtf82(input) {
  var result = [];
  var size2 = input.length;
  for (var index2 = 0; index2 < size2; index2++) {
    var point3 = input.charCodeAt(index2);
    if (point3 >= 55296 && point3 <= 56319 && size2 > index2 + 1) {
      var second = input.charCodeAt(index2 + 1);
      if (second >= 56320 && second <= 57343) {
        point3 = (point3 - 55296) * 1024 + second - 56320 + 65536;
        index2 += 1;
      }
    }
    if (point3 < 128) {
      result.push(point3);
      continue;
    }
    if (point3 < 2048) {
      result.push(point3 >> 6 | 192);
      result.push(point3 & 63 | 128);
      continue;
    }
    if (point3 < 55296 || point3 >= 57344 && point3 < 65536) {
      result.push(point3 >> 12 | 224);
      result.push(point3 >> 6 & 63 | 128);
      result.push(point3 & 63 | 128);
      continue;
    }
    if (point3 >= 65536 && point3 <= 1114111) {
      result.push(point3 >> 18 | 240);
      result.push(point3 >> 12 & 63 | 128);
      result.push(point3 >> 6 & 63 | 128);
      result.push(point3 & 63 | 128);
      continue;
    }
    result.push(239, 191, 189);
  }
  return new Uint8Array(result).buffer;
};
const index$N = /* @__PURE__ */ getDefaultExportFromCjs(encodeUtf8$1);
const encodeUtf8$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$N
}, [encodeUtf8$1]);
const require$$0$1o = /* @__PURE__ */ getAugmentedNamespace(encodeUtf8$2);
const encodeUtf8 = require$$0$1o;
const Mode$2 = require$$11$5;
function ByteData(data2) {
  this.mode = Mode$2.BYTE;
  if (typeof data2 === "string") {
    data2 = encodeUtf8(data2);
  }
  this.data = new Uint8Array(data2);
}
ByteData.getBitsLength = function getBitsLength5(length2) {
  return length2 * 8;
};
ByteData.prototype.getLength = function getLength4() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength6() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(bitBuffer2) {
  for (let i3 = 0, l2 = this.data.length; i3 < l2; i3++) {
    bitBuffer2.put(this.data[i3], 8);
  }
};
var byteData = ByteData;
const byteData$1 = /* @__PURE__ */ getDefaultExportFromCjs(byteData);
const byteData$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: byteData$1
}, [byteData]);
const require$$3$j = /* @__PURE__ */ getAugmentedNamespace(byteData$2);
const Mode$1 = require$$11$5;
const Utils$2 = require$$0$1r;
function KanjiData(data2) {
  this.mode = Mode$1.KANJI;
  this.data = data2;
}
KanjiData.getBitsLength = function getBitsLength7(length2) {
  return length2 * 13;
};
KanjiData.prototype.getLength = function getLength5() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength8() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(bitBuffer2) {
  let i3;
  for (i3 = 0; i3 < this.data.length; i3++) {
    let value = Utils$2.toSJIS(this.data[i3]);
    if (value >= 33088 && value <= 40956) {
      value -= 33088;
    } else if (value >= 57408 && value <= 60351) {
      value -= 49472;
    } else {
      throw new Error(
        "Invalid SJIS character: " + this.data[i3] + "\nMake sure your charset is UTF-8"
      );
    }
    value = (value >>> 8 & 255) * 192 + (value & 255);
    bitBuffer2.put(value, 13);
  }
};
var kanjiData = KanjiData;
const kanjiData$1 = /* @__PURE__ */ getDefaultExportFromCjs(kanjiData);
const kanjiData$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: kanjiData$1
}, [kanjiData]);
const require$$4$d = /* @__PURE__ */ getAugmentedNamespace(kanjiData$2);
var dijkstra$2 = { exports: {} };
(function(module2) {
  var dijkstra2 = {
    single_source_shortest_paths: function(graph, s3, d3) {
      var predecessors = {};
      var costs = {};
      costs[s3] = 0;
      var open = dijkstra2.PriorityQueue.make();
      open.push(s3, 0);
      var closest, u3, v4, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open.empty()) {
        closest = open.pop();
        u3 = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u3] || {};
        for (v4 in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v4)) {
            cost_of_e = adjacent_nodes[v4];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v4];
            first_visit = typeof costs[v4] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v4] = cost_of_s_to_u_plus_cost_of_e;
              open.push(v4, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v4] = u3;
            }
          }
        }
      }
      if (typeof d3 !== "undefined" && typeof costs[d3] === "undefined") {
        var msg = ["Could not find a path from ", s3, " to ", d3, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d3) {
      var nodes = [];
      var u3 = d3;
      while (u3) {
        nodes.push(u3);
        predecessors[u3];
        u3 = predecessors[u3];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s3, d3) {
      var predecessors = dijkstra2.single_source_shortest_paths(graph, s3, d3);
      return dijkstra2.extract_shortest_path_from_predecessor_list(
        predecessors,
        d3
      );
    },
    /**
     * A very naive priority queue implementation.
     */
    PriorityQueue: {
      make: function(opts) {
        var T2 = dijkstra2.PriorityQueue, t2 = {}, key2;
        opts = opts || {};
        for (key2 in T2) {
          if (T2.hasOwnProperty(key2)) {
            t2[key2] = T2[key2];
          }
        }
        t2.queue = [];
        t2.sorter = opts.sorter || T2.default_sorter;
        return t2;
      },
      default_sorter: function(a3, b4) {
        return a3.cost - b4.cost;
      },
      /**
       * Add a new item to the queue and ensure the highest priority element
       * is at the front of the queue.
       */
      push: function(value, cost) {
        var item = { value, cost };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      /**
       * Return the highest priority element in the queue.
       */
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  {
    module2.exports = dijkstra2;
  }
})(dijkstra$2);
var dijkstraExports = dijkstra$2.exports;
const dijkstra = /* @__PURE__ */ getDefaultExportFromCjs(dijkstraExports);
const dijkstra$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: dijkstra
}, [dijkstraExports]);
const require$$7$5 = /* @__PURE__ */ getAugmentedNamespace(dijkstra$1);
(function(exports2) {
  const Mode2 = require$$11$5;
  const NumericData2 = require$$1$M;
  const AlphanumericData2 = require$$2$t;
  const ByteData2 = require$$3$j;
  const KanjiData2 = require$$4$d;
  const Regex = require$$5$d;
  const Utils2 = require$$0$1r;
  const dijkstra2 = require$$7$5;
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex2, mode2, str) {
    const segments2 = [];
    let result;
    while ((result = regex2.exec(str)) !== null) {
      segments2.push({
        data: result[0],
        index: result.index,
        mode: mode2,
        length: result[0].length
      });
    }
    return segments2;
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
      kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s22) {
      return s1.index - s22.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length2, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length2);
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length2);
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length2);
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length2);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    const nodes = [];
    for (let i3 = 0; i3 < segs.length; i3++) {
      const seg = segs[i3];
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.KANJI:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
          break;
        case Mode2.BYTE:
          nodes.push([
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version2) {
    const table = {};
    const graph = { start: {} };
    let prevNodeIds = ["start"];
    for (let i3 = 0; i3 < nodes.length; i3++) {
      const nodeGroup = nodes[i3];
      const currentNodeIds = [];
      for (let j2 = 0; j2 < nodeGroup.length; j2++) {
        const node2 = nodeGroup[j2];
        const key2 = "" + i3 + j2;
        currentNodeIds.push(key2);
        table[key2] = { node: node2, lastCount: 0 };
        graph[key2] = {};
        for (let n4 = 0; n4 < prevNodeIds.length; n4++) {
          const prevNodeId = prevNodeIds[n4];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node2.mode) {
            graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node2.length, node2.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node2.mode);
            table[prevNodeId].lastCount += node2.length;
          } else {
            if (table[prevNodeId])
              table[prevNodeId].lastCount = node2.length;
            graph[prevNodeId][key2] = getSegmentBitsLength(node2.length, node2.mode) + 4 + Mode2.getCharCountIndicator(node2.mode, version2);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (let n4 = 0; n4 < prevNodeIds.length; n4++) {
      graph[prevNodeIds[n4]].end = 0;
    }
    return { map: graph, table };
  }
  function buildSingleSegment(data2, modesHint) {
    let mode2;
    const bestMode = Mode2.getBestModeForData(data2);
    mode2 = Mode2.from(modesHint, bestMode);
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE;
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data2);
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data2);
      case Mode2.KANJI:
        return new KanjiData2(data2);
      case Mode2.BYTE:
        return new ByteData2(data2);
    }
  }
  exports2.fromArray = function fromArray2(array2) {
    return array2.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports2.fromString = function fromString2(data2, version2) {
    const segs = getSegmentsFromString(data2, Utils2.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version2);
    const path = dijkstra2.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for (let i3 = 1; i3 < path.length - 1; i3++) {
      optimizedSegs.push(graph.table[path[i3]].node);
    }
    return exports2.fromArray(mergeSegments(optimizedSegs));
  };
  exports2.rawSplit = function rawSplit(data2) {
    return exports2.fromArray(
      getSegmentsFromString(data2, Utils2.isKanjiModeEnabled())
    );
  };
})(segments$2);
const segments = /* @__PURE__ */ getDefaultExportFromCjs(segments$2);
const segments$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: segments
}, [segments$2]);
const require$$12$5 = /* @__PURE__ */ getAugmentedNamespace(segments$1);
const Utils$1 = require$$0$1r;
const ECLevel = require$$1$N;
const BitBuffer = require$$2$u;
const BitMatrix = require$$3$k;
const AlignmentPattern = require$$4$f;
const FinderPattern = require$$5$e;
const MaskPattern = require$$6$b;
const ECCode = require$$7$6;
const ReedSolomonEncoder = require$$8$5;
const Version = require$$9$5;
const FormatInfo = require$$10$5;
const Mode = require$$11$5;
const Segments = require$$12$5;
function setupFinderPattern(matrix, version2) {
  const size2 = matrix.size;
  const pos = FinderPattern.getPositions(version2);
  for (let i3 = 0; i3 < pos.length; i3++) {
    const row = pos[i3][0];
    const col = pos[i3][1];
    for (let r2 = -1; r2 <= 7; r2++) {
      if (row + r2 <= -1 || size2 <= row + r2)
        continue;
      for (let c2 = -1; c2 <= 7; c2++) {
        if (col + c2 <= -1 || size2 <= col + c2)
          continue;
        if (r2 >= 0 && r2 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c2 >= 2 && c2 <= 4) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupTimingPattern(matrix) {
  const size2 = matrix.size;
  for (let r2 = 8; r2 < size2 - 8; r2++) {
    const value = r2 % 2 === 0;
    matrix.set(r2, 6, value, true);
    matrix.set(6, r2, value, true);
  }
}
function setupAlignmentPattern(matrix, version2) {
  const pos = AlignmentPattern.getPositions(version2);
  for (let i3 = 0; i3 < pos.length; i3++) {
    const row = pos[i3][0];
    const col = pos[i3][1];
    for (let r2 = -2; r2 <= 2; r2++) {
      for (let c2 = -2; c2 <= 2; c2++) {
        if (r2 === -2 || r2 === 2 || c2 === -2 || c2 === 2 || r2 === 0 && c2 === 0) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupVersionInfo(matrix, version2) {
  const size2 = matrix.size;
  const bits = Version.getEncodedBits(version2);
  let row, col, mod2;
  for (let i3 = 0; i3 < 18; i3++) {
    row = Math.floor(i3 / 3);
    col = i3 % 3 + size2 - 8 - 3;
    mod2 = (bits >> i3 & 1) === 1;
    matrix.set(row, col, mod2, true);
    matrix.set(col, row, mod2, true);
  }
}
function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
  const size2 = matrix.size;
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
  let i3, mod2;
  for (i3 = 0; i3 < 15; i3++) {
    mod2 = (bits >> i3 & 1) === 1;
    if (i3 < 6) {
      matrix.set(i3, 8, mod2, true);
    } else if (i3 < 8) {
      matrix.set(i3 + 1, 8, mod2, true);
    } else {
      matrix.set(size2 - 15 + i3, 8, mod2, true);
    }
    if (i3 < 8) {
      matrix.set(8, size2 - i3 - 1, mod2, true);
    } else if (i3 < 9) {
      matrix.set(8, 15 - i3 - 1 + 1, mod2, true);
    } else {
      matrix.set(8, 15 - i3 - 1, mod2, true);
    }
  }
  matrix.set(size2 - 8, 8, 1, true);
}
function setupData(matrix, data2) {
  const size2 = matrix.size;
  let inc2 = -1;
  let row = size2 - 1;
  let bitIndex = 7;
  let byteIndex = 0;
  for (let col = size2 - 1; col > 0; col -= 2) {
    if (col === 6)
      col--;
    while (true) {
      for (let c2 = 0; c2 < 2; c2++) {
        if (!matrix.isReserved(row, col - c2)) {
          let dark = false;
          if (byteIndex < data2.length) {
            dark = (data2[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix.set(row, col - c2, dark);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc2;
      if (row < 0 || size2 <= row) {
        row -= inc2;
        inc2 = -inc2;
        break;
      }
    }
  }
}
function createData(version2, errorCorrectionLevel2, segments2) {
  const buffer2 = new BitBuffer();
  segments2.forEach(function(data2) {
    buffer2.put(data2.mode.bit, 4);
    buffer2.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version2));
    data2.write(buffer2);
  });
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(0);
  }
  const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
  for (let i3 = 0; i3 < remainingByte; i3++) {
    buffer2.put(i3 % 2 ? 17 : 236, 8);
  }
  return createCodewords(buffer2, version2, errorCorrectionLevel2);
}
function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewords = totalCodewords - ecTotalCodewords;
  const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  const rs2 = new ReedSolomonEncoder(ecCount);
  let offset = 0;
  const dcData = new Array(ecTotalBlocks);
  const ecData = new Array(ecTotalBlocks);
  let maxDataSize = 0;
  const buffer2 = new Uint8Array(bitBuffer2.buffer);
  for (let b4 = 0; b4 < ecTotalBlocks; b4++) {
    const dataSize = b4 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b4] = buffer2.slice(offset, offset + dataSize);
    ecData[b4] = rs2.encode(dcData[b4]);
    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  const data2 = new Uint8Array(totalCodewords);
  let index2 = 0;
  let i3, r2;
  for (i3 = 0; i3 < maxDataSize; i3++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      if (i3 < dcData[r2].length) {
        data2[index2++] = dcData[r2][i3];
      }
    }
  }
  for (i3 = 0; i3 < ecCount; i3++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      data2[index2++] = ecData[r2][i3];
    }
  }
  return data2;
}
function createSymbol(data2, version2, errorCorrectionLevel2, maskPattern2) {
  let segments2;
  if (Array.isArray(data2)) {
    segments2 = Segments.fromArray(data2);
  } else if (typeof data2 === "string") {
    let estimatedVersion = version2;
    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data2);
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
    }
    segments2 = Segments.fromString(data2, estimatedVersion || 40);
  } else {
    throw new Error("Invalid data");
  }
  const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
  if (!bestVersion) {
    throw new Error("The amount of data is too big to be stored in a QR Code");
  }
  if (!version2) {
    version2 = bestVersion;
  } else if (version2 < bestVersion) {
    throw new Error(
      "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
    );
  }
  const dataBits = createData(version2, errorCorrectionLevel2, segments2);
  const moduleCount = Utils$1.getSymbolSize(version2);
  const modules = new BitMatrix(moduleCount);
  setupFinderPattern(modules, version2);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version2);
  setupFormatInfo(modules, errorCorrectionLevel2, 0);
  if (version2 >= 7) {
    setupVersionInfo(modules, version2);
  }
  setupData(modules, dataBits);
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern.getBestMask(
      modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
    );
  }
  MaskPattern.applyMask(maskPattern2, modules);
  setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2
  };
}
var create$7 = qrcode$1.create = function create2(data2, options) {
  if (typeof data2 === "undefined" || data2 === "") {
    throw new Error("No input text");
  }
  let errorCorrectionLevel2 = ECLevel.M;
  let version2;
  let mask2;
  if (typeof options !== "undefined") {
    errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version2 = Version.from(options.version);
    mask2 = MaskPattern.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol(data2, version2, errorCorrectionLevel2, mask2);
};
const qrcode = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  create: create$7,
  default: qrcode$1
}, [qrcode$1]);
const require$$1$L = /* @__PURE__ */ getAugmentedNamespace(qrcode);
var canvas$2 = {};
var utils$f = {};
(function(exports2) {
  function hex2rgba(hex2) {
    if (typeof hex2 === "number") {
      hex2 = hex2.toString();
    }
    if (typeof hex2 !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    let hexCode = hex2.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex2);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
        return [c2, c2];
      }));
    }
    if (hexCode.length === 6)
      hexCode.push("F", "F");
    const hexValue2 = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue2 >> 24 & 255,
      g: hexValue2 >> 16 & 255,
      b: hexValue2 >> 8 & 255,
      a: hexValue2 & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports2.getOptions = function getOptions(options) {
    if (!options)
      options = {};
    if (!options.color)
      options.color = {};
    const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width = options.width && options.width >= 21 ? options.width : void 0;
    const scale = options.scale || 4;
    return {
      width,
      scale: width ? 4 : scale,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports2.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports2.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports2.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports2.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size2 = qr.modules.size;
    const data2 = qr.modules.data;
    const scale = exports2.getScale(size2, opts);
    const symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
    const scaledMargin = opts.margin * scale;
    const palette = [opts.color.light, opts.color.dark];
    for (let i3 = 0; i3 < symbolSize; i3++) {
      for (let j2 = 0; j2 < symbolSize; j2++) {
        let posDst = (i3 * symbolSize + j2) * 4;
        let pxColor = opts.color.light;
        if (i3 >= scaledMargin && j2 >= scaledMargin && i3 < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
          const iSrc = Math.floor((i3 - scaledMargin) / scale);
          const jSrc = Math.floor((j2 - scaledMargin) / scale);
          pxColor = palette[data2[iSrc * size2 + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
})(utils$f);
const utils$d = /* @__PURE__ */ getDefaultExportFromCjs(utils$f);
const utils$e = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$d
}, [utils$f]);
const require$$0$1n = /* @__PURE__ */ getAugmentedNamespace(utils$e);
(function(exports2) {
  const Utils2 = require$$0$1n;
  function clearCanvas(ctx, canvas2, size2) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height);
    if (!canvas2.style)
      canvas2.style = {};
    canvas2.height = size2;
    canvas2.width = size2;
    canvas2.style.height = size2 + "px";
    canvas2.style.width = size2 + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e2) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports2.render = function render3(qrData, canvas2, options) {
    let opts = options;
    let canvasEl = canvas2;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!canvas2) {
      canvasEl = getCanvasElement();
    }
    opts = Utils2.getOptions(opts);
    const size2 = Utils2.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image = ctx.createImageData(size2, size2);
    Utils2.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size2);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports2.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!opts)
      opts = {};
    const canvasEl = exports2.render(qrData, canvas2, opts);
    const type2 = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type2, rendererOpts.quality);
  };
})(canvas$2);
const canvas = /* @__PURE__ */ getDefaultExportFromCjs(canvas$2);
const canvas$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: canvas
}, [canvas$2]);
const require$$2$s = /* @__PURE__ */ getAugmentedNamespace(canvas$1);
var svgTag$1 = {};
const Utils = require$$0$1n;
function getColorAttrib(color, attrib) {
  const alpha = color.a / 255;
  const str = attrib + '="' + color.hex + '"';
  return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
}
function svgCmd(cmd, x2, y3) {
  let str = cmd + x2;
  if (typeof y3 !== "undefined")
    str += " " + y3;
  return str;
}
function qrToPath(data2, size2, margin) {
  let path = "";
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;
  for (let i3 = 0; i3 < data2.length; i3++) {
    const col = Math.floor(i3 % size2);
    const row = Math.floor(i3 / size2);
    if (!col && !newRow)
      newRow = true;
    if (data2[i3]) {
      lineLength++;
      if (!(i3 > 0 && col > 0 && data2[i3 - 1])) {
        path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col + 1 < size2 && data2[i3 + 1])) {
        path += svgCmd("h", lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
var render$1 = svgTag$1.render = function render2(qrData, options, cb2) {
  const opts = Utils.getOptions(options);
  const size2 = qrData.modules.size;
  const data2 = qrData.modules.data;
  const qrcodesize = size2 + opts.margin * 2;
  const bg2 = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
  const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data2, size2, opts.margin) + '"/>';
  const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
  const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
  const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg2 + path + "</svg>\n";
  if (typeof cb2 === "function") {
    cb2(null, svgTag2);
  }
  return svgTag2;
};
const svgTag = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: svgTag$1,
  render: render$1
}, [svgTag$1]);
const require$$3$i = /* @__PURE__ */ getAugmentedNamespace(svgTag);
const canPromise = require$$0$1s;
const QRCode$4 = require$$1$L;
const CanvasRenderer = require$$2$s;
const SvgRenderer = require$$3$i;
function renderCanvas(renderFunc, canvas2, text, opts, cb2) {
  const args = [].slice.call(arguments, 1);
  const argsNum = args.length;
  const isLastArgCb = typeof args[argsNum - 1] === "function";
  if (!isLastArgCb && !canPromise()) {
    throw new Error("Callback required as last argument");
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 2) {
      cb2 = text;
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb2 === "undefined") {
        cb2 = opts;
        opts = void 0;
      } else {
        cb2 = opts;
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 1) {
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text;
      text = canvas2;
      canvas2 = void 0;
    }
    return new Promise(function(resolve, reject) {
      try {
        const data2 = QRCode$4.create(text, opts);
        resolve(renderFunc(data2, canvas2, opts));
      } catch (e2) {
        reject(e2);
      }
    });
  }
  try {
    const data2 = QRCode$4.create(text, opts);
    cb2(null, renderFunc(data2, canvas2, opts));
  } catch (e2) {
    cb2(e2);
  }
}
browser$b.create = QRCode$4.create;
browser$b.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
browser$b.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
browser$b.toString = renderCanvas.bind(null, function(data2, _3, opts) {
  return SvgRenderer.render(data2, opts);
});
const CONNECTING_ERROR_MARGIN = 0.1;
const CIRCLE_SIZE_MODIFIER = 2.5;
const QRCODE_MATRIX_MARGIN = 7;
function isAdjecentDots(cy, otherCy, cellSize) {
  if (cy === otherCy) {
    return false;
  }
  const diff2 = cy - otherCy < 0 ? otherCy - cy : cy - otherCy;
  return diff2 <= cellSize + CONNECTING_ERROR_MARGIN;
}
function getMatrix(value, errorCorrectionLevel2) {
  const arr2 = Array.prototype.slice.call(browser$b.create(value, { errorCorrectionLevel: errorCorrectionLevel2 }).modules.data, 0);
  const sqrt = Math.sqrt(arr2.length);
  return arr2.reduce((rows, key2, index2) => (index2 % sqrt === 0 ? rows.push([key2]) : rows[rows.length - 1].push(key2)) && rows, []);
}
const QrCodeUtil = {
  generate(uri, size2, logoSize) {
    const dotColor = "#141414";
    const edgeColor = "transparent";
    const strokeWidth = 5;
    const dots = [];
    const matrix = getMatrix(uri, "Q");
    const cellSize = size2 / matrix.length;
    const qrList = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 }
    ];
    qrList.forEach(({ x: x2, y: y3 }) => {
      const x1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * x2;
      const y1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * y3;
      const borderRadius = 0.45;
      for (let i3 = 0; i3 < qrList.length; i3 += 1) {
        const dotSize = cellSize * (QRCODE_MATRIX_MARGIN - i3 * 2);
        dots.push(b$6`
            <rect
              fill=${i3 === 2 ? dotColor : edgeColor}
              width=${i3 === 0 ? dotSize - strokeWidth : dotSize}
              rx= ${i3 === 0 ? (dotSize - strokeWidth) * borderRadius : dotSize * borderRadius}
              ry= ${i3 === 0 ? (dotSize - strokeWidth) * borderRadius : dotSize * borderRadius}
              stroke=${dotColor}
              stroke-width=${i3 === 0 ? strokeWidth : 0}
              height=${i3 === 0 ? dotSize - strokeWidth : dotSize}
              x= ${i3 === 0 ? y1 + cellSize * i3 + strokeWidth / 2 : y1 + cellSize * i3}
              y= ${i3 === 0 ? x1 + cellSize * i3 + strokeWidth / 2 : x1 + cellSize * i3}
            />
          `);
      }
    });
    const clearArenaSize = Math.floor((logoSize + 25) / cellSize);
    const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
    const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
    const circles = [];
    matrix.forEach((row, i3) => {
      row.forEach((_3, j2) => {
        if (matrix[i3][j2]) {
          if (!(i3 < QRCODE_MATRIX_MARGIN && j2 < QRCODE_MATRIX_MARGIN || i3 > matrix.length - (QRCODE_MATRIX_MARGIN + 1) && j2 < QRCODE_MATRIX_MARGIN || i3 < QRCODE_MATRIX_MARGIN && j2 > matrix.length - (QRCODE_MATRIX_MARGIN + 1))) {
            if (!(i3 > matrixMiddleStart && i3 < matrixMiddleEnd && j2 > matrixMiddleStart && j2 < matrixMiddleEnd)) {
              const cx = i3 * cellSize + cellSize / 2;
              const cy = j2 * cellSize + cellSize / 2;
              circles.push([cx, cy]);
            }
          }
        }
      });
    });
    const circlesToConnect = {};
    circles.forEach(([cx, cy]) => {
      if (circlesToConnect[cx]) {
        circlesToConnect[cx]?.push(cy);
      } else {
        circlesToConnect[cx] = [cy];
      }
    });
    Object.entries(circlesToConnect).map(([cx, cys]) => {
      const newCys = cys.filter((cy) => cys.every((otherCy) => !isAdjecentDots(cy, otherCy, cellSize)));
      return [Number(cx), newCys];
    }).forEach(([cx, cys]) => {
      cys.forEach((cy) => {
        dots.push(b$6`<circle cx=${cx} cy=${cy} fill=${dotColor} r=${cellSize / CIRCLE_SIZE_MODIFIER} />`);
      });
    });
    Object.entries(circlesToConnect).filter(([_3, cys]) => cys.length > 1).map(([cx, cys]) => {
      const newCys = cys.filter((cy) => cys.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
      return [Number(cx), newCys];
    }).map(([cx, cys]) => {
      cys.sort((a3, b4) => a3 < b4 ? -1 : 1);
      const groups = [];
      for (const cy of cys) {
        const group = groups.find((item) => item.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
        if (group) {
          group.push(cy);
        } else {
          groups.push([cy]);
        }
      }
      return [cx, groups.map((item) => [item[0], item[item.length - 1]])];
    }).forEach(([cx, groups]) => {
      groups.forEach(([y1, y22]) => {
        dots.push(b$6`
              <line
                x1=${cx}
                x2=${cx}
                y1=${y1}
                y2=${y22}
                stroke=${dotColor}
                stroke-width=${cellSize / (CIRCLE_SIZE_MODIFIER / 2)}
                stroke-linecap="round"
              />
            `);
      });
    });
    return dots;
  }
};
const styles$z = i$7`
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: #3396ff !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`;
var __decorate$S = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiQrCode = class WuiQrCode2 extends s$3 {
  constructor() {
    super(...arguments);
    this.uri = "";
    this.size = 0;
    this.theme = "dark";
    this.imageSrc = void 0;
    this.alt = void 0;
  }
  render() {
    this.dataset["theme"] = this.theme;
    this.style.cssText = `--local-size: ${this.size}px`;
    return x$3`${this.templateVisual()} ${this.templateSvg()}`;
  }
  templateSvg() {
    const size2 = this.theme === "light" ? this.size : this.size - 16 * 2;
    return b$6`
      <svg height=${size2} width=${size2}>
        ${QrCodeUtil.generate(this.uri, size2, size2 / 4)}
      </svg>
    `;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$3`<wui-image src=${this.imageSrc} alt=${this.alt ?? "logo"}></wui-image>`;
    }
    return x$3`<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`;
  }
};
WuiQrCode.styles = [resetStyles, styles$z];
__decorate$S([
  n$4()
], WuiQrCode.prototype, "uri", void 0);
__decorate$S([
  n$4({ type: Number })
], WuiQrCode.prototype, "size", void 0);
__decorate$S([
  n$4()
], WuiQrCode.prototype, "theme", void 0);
__decorate$S([
  n$4()
], WuiQrCode.prototype, "imageSrc", void 0);
__decorate$S([
  n$4()
], WuiQrCode.prototype, "alt", void 0);
WuiQrCode = __decorate$S([
  customElement("wui-qr-code")
], WuiQrCode);
const styles$y = i$7`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;
var __decorate$R = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiSearchBar = class WuiSearchBar2 extends s$3 {
  constructor() {
    super(...arguments);
    this.inputComponentRef = e$2();
  }
  render() {
    return x$3`
      <wui-input-text
        ${n$2(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <wui-input-element @click=${this.clearValue} icon="close"></wui-input-element>
      </wui-input-text>
    `;
  }
  clearValue() {
    const inputComponent = this.inputComponentRef.value;
    const inputElement = inputComponent?.inputElementRef.value;
    if (inputElement) {
      inputElement.value = "";
      inputElement.focus();
      inputElement.dispatchEvent(new Event("input"));
    }
  }
};
WuiSearchBar.styles = [resetStyles, styles$y];
WuiSearchBar = __decorate$R([
  customElement("wui-search-bar")
], WuiSearchBar);
const styles$x = i$7`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-xs);
    align-items: center;
    padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);
  }
`;
var __decorate$Q = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiSnackbar = class WuiSnackbar2 extends s$3 {
  constructor() {
    super(...arguments);
    this.backgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.icon = "checkmark";
    this.message = "";
  }
  render() {
    return x$3`
      <wui-icon-box
        size="sm"
        iconSize="xs"
        iconColor=${this.iconColor}
        backgroundColor=${this.backgroundColor}
        icon=${this.icon}
        background="opaque"
      ></wui-icon-box>
      <wui-text variant="paragraph-500" color="fg-100">${this.message}</wui-text>
    `;
  }
};
WuiSnackbar.styles = [resetStyles, styles$x];
__decorate$Q([
  n$4()
], WuiSnackbar.prototype, "backgroundColor", void 0);
__decorate$Q([
  n$4()
], WuiSnackbar.prototype, "iconColor", void 0);
__decorate$Q([
  n$4()
], WuiSnackbar.prototype, "icon", void 0);
__decorate$Q([
  n$4()
], WuiSnackbar.prototype, "message", void 0);
WuiSnackbar = __decorate$Q([
  customElement("wui-snackbar")
], WuiSnackbar);
const styles$w = i$7`
  :host {
    display: inline-flex;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--wui-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > wui-icon,
  button[data-active='true'] > wui-text {
    color: var(--wui-color-fg-100);
  }

  button[data-active='false'] > wui-icon,
  button[data-active='false'] > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: 0.5;
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='false']:disabled > wui-text {
    color: var(--wui-color-fg-300);
  }

  button > wui-icon,
  button > wui-text {
    pointer-events: none;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  button {
    width: var(--local-tab-width);
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > wui-icon,
  button:active:enabled > wui-icon {
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > wui-text,
  button:active:enabled > wui-text {
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var __decorate$P = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTabs = class WuiTabs2 extends s$3 {
  constructor() {
    super(...arguments);
    this.tabs = [];
    this.onTabChange = () => null;
    this.buttons = [];
    this.disabled = false;
    this.activeTab = 0;
    this.localTabWidth = "100px";
    this.isDense = false;
  }
  render() {
    this.isDense = this.tabs.length > 3;
    this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `;
    this.dataset["type"] = this.isDense ? "flex" : "block";
    return this.tabs.map((tab, index2) => {
      const isActive = index2 === this.activeTab;
      return x$3`
        <button
          ?disabled=${this.disabled}
          @click=${() => this.onTabClick(index2)}
          data-active=${isActive}
        >
          <wui-icon size="xs" color="inherit" name=${tab.icon}></wui-icon>
          <wui-text variant="small-600" color="inherit"> ${tab.label} </wui-text>
        </button>
      `;
    });
  }
  firstUpdated() {
    if (this.shadowRoot && this.isDense) {
      this.buttons = [...this.shadowRoot.querySelectorAll("button")];
      setTimeout(() => {
        this.animateTabs(0, true);
      }, 0);
    }
  }
  onTabClick(index2) {
    if (this.buttons) {
      this.animateTabs(index2, false);
    }
    this.activeTab = index2;
    this.onTabChange(index2);
  }
  animateTabs(index2, initialAnimation) {
    const passiveBtn = this.buttons[this.activeTab];
    const activeBtn = this.buttons[index2];
    const passiveBtnText = passiveBtn?.querySelector("wui-text");
    const activeBtnText = activeBtn?.querySelector("wui-text");
    const activeBtnBounds = activeBtn?.getBoundingClientRect();
    const activeBtnTextBounds = activeBtnText?.getBoundingClientRect();
    if (passiveBtn && passiveBtnText && !initialAnimation && index2 !== this.activeTab) {
      passiveBtnText.animate([{ opacity: 0 }], {
        duration: 50,
        easing: "ease",
        fill: "forwards"
      });
      passiveBtn.animate([{ width: `34px` }], {
        duration: 500,
        easing: "ease",
        fill: "forwards"
      });
    }
    if (activeBtn && activeBtnBounds && activeBtnTextBounds && activeBtnText) {
      if (index2 !== this.activeTab || initialAnimation) {
        this.localTabWidth = `${Math.round(activeBtnBounds.width + activeBtnTextBounds.width) + 6}px`;
        activeBtn.animate([{ width: `${activeBtnBounds.width + activeBtnTextBounds.width}px` }], {
          duration: initialAnimation ? 0 : 500,
          fill: "forwards",
          easing: "ease"
        });
        activeBtnText.animate([{ opacity: 1 }], {
          duration: initialAnimation ? 0 : 125,
          delay: initialAnimation ? 0 : 200,
          fill: "forwards",
          easing: "ease"
        });
      }
    }
  }
};
WuiTabs.styles = [resetStyles, elementStyles, styles$w];
__decorate$P([
  n$4({ type: Array })
], WuiTabs.prototype, "tabs", void 0);
__decorate$P([
  n$4()
], WuiTabs.prototype, "onTabChange", void 0);
__decorate$P([
  n$4({ type: Array })
], WuiTabs.prototype, "buttons", void 0);
__decorate$P([
  n$4({ type: Boolean })
], WuiTabs.prototype, "disabled", void 0);
__decorate$P([
  r$4()
], WuiTabs.prototype, "activeTab", void 0);
__decorate$P([
  r$4()
], WuiTabs.prototype, "localTabWidth", void 0);
__decorate$P([
  r$4()
], WuiTabs.prototype, "isDense", void 0);
WuiTabs = __decorate$P([
  customElement("wui-tabs")
], WuiTabs);
const styles$v = i$7`
  :host {
    display: block;
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    background-color: var(--wui-color-fg-100);
    color: var(--wui-color-bg-100);
    position: relative;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
  }

  wui-icon[data-placement='top'] {
    bottom: 0;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var __decorate$O = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTooltip = class WuiTooltip2 extends s$3 {
  constructor() {
    super(...arguments);
    this.placement = "top";
    this.message = "";
  }
  render() {
    return x$3`<wui-icon
        data-placement=${this.placement}
        color="fg-100"
        size="inherit"
        name="cursor"
      ></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>`;
  }
};
WuiTooltip.styles = [resetStyles, elementStyles, styles$v];
__decorate$O([
  n$4()
], WuiTooltip.prototype, "placement", void 0);
__decorate$O([
  n$4()
], WuiTooltip.prototype, "message", void 0);
WuiTooltip = __decorate$O([
  customElement("wui-tooltip")
], WuiTooltip);
const styles$u = i$7`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    box-shadow: 0 0 0 8px var(--wui-thumbnail-border);
    border-radius: var(--local-border-radius);
    overflow: hidden;
  }

  wui-icon {
    width: 32px;
    height: 32px;
  }
`;
var __decorate$N = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiVisualThumbnail = class WuiVisualThumbnail2 extends s$3 {
  render() {
    this.style.cssText = `--local-border-radius: ${this.borderRadiusFull ? "1000px" : "20px"};`;
    return x$3`${this.templateVisual()}`;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$3`<wui-image src=${this.imageSrc} alt=${this.alt ?? ""}></wui-image>`;
    }
    return x$3`<wui-icon
      data-parent-size="md"
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
  }
};
WuiVisualThumbnail.styles = [resetStyles, styles$u];
__decorate$N([
  n$4()
], WuiVisualThumbnail.prototype, "imageSrc", void 0);
__decorate$N([
  n$4()
], WuiVisualThumbnail.prototype, "alt", void 0);
__decorate$N([
  n$4({ type: Boolean })
], WuiVisualThumbnail.prototype, "borderRadiusFull", void 0);
WuiVisualThumbnail = __decorate$N([
  customElement("wui-visual-thumbnail")
], WuiVisualThumbnail);
const styles$t = i$7`
  :host {
    display: block;
  }

  button {
    width: 100%;
    display: block;
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-2l);
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-accent-glass-015);
  }

  button:hover {
    background-color: var(--wui-accent-glass-010) !important;
  }

  button:active {
    background-color: var(--wui-accent-glass-020) !important;
  }
`;
var __decorate$M = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiNoticeCard = class WuiNoticeCard2 extends s$3 {
  constructor() {
    super(...arguments);
    this.label = "";
    this.description = "";
    this.icon = "wallet";
  }
  render() {
    return x$3`
      <button>
        <wui-flex gap="m" alignItems="center" justifyContent="space-between">
          <wui-icon-box
            size="lg"
            iconcolor="accent-100"
            backgroundcolor="accent-100"
            icon=${this.icon}
            background="transparent"
          ></wui-icon-box>

          <wui-flex flexDirection="column" gap="3xs">
            <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
            <wui-text variant="small-400" color="fg-200">${this.description}</wui-text>
          </wui-flex>

          <wui-icon size="md" color="fg-200" name="chevronRight"></wui-icon>
        </wui-flex>
      </button>
    `;
  }
};
WuiNoticeCard.styles = [resetStyles, elementStyles, styles$t];
__decorate$M([
  n$4()
], WuiNoticeCard.prototype, "label", void 0);
__decorate$M([
  n$4()
], WuiNoticeCard.prototype, "description", void 0);
__decorate$M([
  n$4()
], WuiNoticeCard.prototype, "icon", void 0);
WuiNoticeCard = __decorate$M([
  customElement("wui-notice-card")
], WuiNoticeCard);
const styles$s = i$7`
  button {
    height: auto;
    position: relative;
    flex-direction: column;
    gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  .overflowedContent {
    width: 100%;
    overflow: hidden;
  }

  .overflowedContent[data-active='false']:after {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, var(--wui-color-bg-200), transparent);
    border-bottom-left-radius: var(--wui-border-radius-xs);
    border-bottom-right-radius: var(--wui-border-radius-xs);
  }

  .heightContent {
    max-height: 100px;
  }

  pre {
    text-align: left;
    white-space: pre-wrap;
    height: auto;
    overflow-x: auto;
    overflow-wrap: anywhere;
  }
`;
var __decorate$L = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const MAX_HEIGHT = 100;
let WuiListAccordion = class WuiListAccordion2 extends s$3 {
  constructor() {
    super(...arguments);
    this.textTitle = "";
    this.overflowedContent = "";
    this.toggled = false;
    this.enableAccordion = false;
    this.scrollElement = void 0;
    this.scrollHeightElement = 0;
  }
  firstUpdated() {
    setTimeout(() => {
      const heightElement = this.shadowRoot?.querySelector(".heightContent");
      if (heightElement) {
        this.scrollElement = heightElement;
        const scrollHeight = heightElement?.scrollHeight;
        if (scrollHeight && scrollHeight > MAX_HEIGHT) {
          this.enableAccordion = true;
          this.scrollHeightElement = scrollHeight;
          this.requestUpdate();
        }
      }
    }, 0);
  }
  render() {
    return x$3`
      <button ontouchstart @click=${() => this.onClick()}>
        <wui-flex justifyContent="space-between" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-100">${this.textTitle}</wui-text>
          ${this.chevronTemplate()}
        </wui-flex>
        <div
          data-active=${this.enableAccordion ? Boolean(this.toggled) : true}
          class="overflowedContent"
        >
          <div class="heightContent">
            <wui-text variant="paragraph-400" color="fg-200">
              <pre>${this.overflowedContent}</pre>
            </wui-text>
          </div>
        </div>
      </button>
    `;
  }
  onClick() {
    const icon = this.shadowRoot?.querySelector("wui-icon");
    if (this.enableAccordion) {
      this.toggled = !this.toggled;
      this.requestUpdate();
      if (this.scrollElement) {
        this.scrollElement.animate([
          { maxHeight: this.toggled ? `${MAX_HEIGHT}px` : `${this.scrollHeightElement}px` },
          { maxHeight: this.toggled ? `${this.scrollHeightElement}px` : `${MAX_HEIGHT}px` }
        ], {
          duration: 300,
          fill: "forwards",
          easing: "ease"
        });
      }
      if (icon) {
        icon.animate([
          { transform: this.toggled ? `rotate(0deg)` : `rotate(180deg)` },
          { transform: this.toggled ? `rotate(180deg)` : `rotate(0deg)` }
        ], {
          duration: 300,
          fill: "forwards",
          easing: "ease"
        });
      }
    }
  }
  chevronTemplate() {
    if (this.enableAccordion) {
      return x$3` <wui-icon color="fg-100" size="sm" name="chevronBottom"></wui-icon>`;
    }
    return null;
  }
};
WuiListAccordion.styles = [resetStyles, elementStyles, styles$s];
__decorate$L([
  n$4()
], WuiListAccordion.prototype, "textTitle", void 0);
__decorate$L([
  n$4()
], WuiListAccordion.prototype, "overflowedContent", void 0);
WuiListAccordion = __decorate$L([
  customElement("wui-list-accordion")
], WuiListAccordion);
const styles$r = i$7`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$K = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListContent = class WuiListContent2 extends s$3 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.textTitle = "";
    this.textValue = void 0;
  }
  render() {
    return x$3`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color=${this.textValue ? "fg-200" : "fg-100"}>
          ${this.textTitle}
        </wui-text>
        ${this.templateContent()}
      </wui-flex>
    `;
  }
  templateContent() {
    if (this.imageSrc) {
      return x$3`<wui-image src=${this.imageSrc} alt=${this.textTitle}></wui-image>`;
    } else if (this.textValue) {
      return x$3` <wui-text variant="paragraph-400" color="fg-100"> ${this.textValue} </wui-text>`;
    }
    return x$3`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiListContent.styles = [resetStyles, elementStyles, styles$r];
__decorate$K([
  n$4()
], WuiListContent.prototype, "imageSrc", void 0);
__decorate$K([
  n$4()
], WuiListContent.prototype, "textTitle", void 0);
__decorate$K([
  n$4()
], WuiListContent.prototype, "textValue", void 0);
WuiListContent = __decorate$K([
  customElement("wui-list-content")
], WuiListContent);
const styles$q = i$7`
  :host {
    display: flex;
    flex-direction: column;
    gap: var(--wui-spacing-l);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$J = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListWalletTransaction = class WuiListWalletTransaction2 extends s$3 {
  constructor() {
    super(...arguments);
    this.amount = "";
    this.networkCurreny = "";
    this.networkImageUrl = "";
    this.receiverAddress = "";
  }
  render() {
    return x$3`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">Sending</wui-text>
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">
            ${this.amount} ${this.networkCurreny}
          </wui-text>
          ${this.templateNetworkVisual()}
        </wui-flex>
      </wui-flex>
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">To</wui-text>
        <wui-chip
          icon="externalLink"
          variant="shadeSmall"
          href=${this.receiverAddress}
          title=${this.receiverAddress}
        ></wui-chip>
      </wui-flex>
    `;
  }
  templateNetworkVisual() {
    if (this.networkImageUrl) {
      return x$3`<wui-image src=${this.networkImageUrl} alt="Network Image"></wui-image>`;
    }
    return x$3`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiListWalletTransaction.styles = [resetStyles, elementStyles, styles$q];
__decorate$J([
  n$4()
], WuiListWalletTransaction.prototype, "amount", void 0);
__decorate$J([
  n$4()
], WuiListWalletTransaction.prototype, "networkCurreny", void 0);
__decorate$J([
  n$4()
], WuiListWalletTransaction.prototype, "networkImageUrl", void 0);
__decorate$J([
  n$4()
], WuiListWalletTransaction.prototype, "receiverAddress", void 0);
WuiListWalletTransaction = __decorate$J([
  customElement("wui-list-wallet-transaction")
], WuiListWalletTransaction);
const styles$p = i$7`
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$I = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiGrid = class WuiGrid2 extends s$3 {
  render() {
    this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
    return x$3`<slot></slot>`;
  }
};
WuiGrid.styles = [resetStyles, styles$p];
__decorate$I([
  n$4()
], WuiGrid.prototype, "gridTemplateRows", void 0);
__decorate$I([
  n$4()
], WuiGrid.prototype, "gridTemplateColumns", void 0);
__decorate$I([
  n$4()
], WuiGrid.prototype, "justifyItems", void 0);
__decorate$I([
  n$4()
], WuiGrid.prototype, "alignItems", void 0);
__decorate$I([
  n$4()
], WuiGrid.prototype, "justifyContent", void 0);
__decorate$I([
  n$4()
], WuiGrid.prototype, "alignContent", void 0);
__decorate$I([
  n$4()
], WuiGrid.prototype, "columnGap", void 0);
__decorate$I([
  n$4()
], WuiGrid.prototype, "rowGap", void 0);
__decorate$I([
  n$4()
], WuiGrid.prototype, "gap", void 0);
__decorate$I([
  n$4()
], WuiGrid.prototype, "padding", void 0);
__decorate$I([
  n$4()
], WuiGrid.prototype, "margin", void 0);
WuiGrid = __decorate$I([
  customElement("wui-grid")
], WuiGrid);
const styles$o = i$7`
  :host {
    position: relative;
    display: flex;
    width: 100%;
    height: 1px;
    background-color: var(--wui-gray-glass-005);
    justify-content: center;
    align-items: center;
  }

  :host > wui-text {
    position: absolute;
    padding: 0px 10px;
    background-color: var(--wui-color-modal-bg);
  }
`;
var __decorate$H = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiSeparator = class WuiSeparator2 extends s$3 {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  render() {
    return x$3`${this.template()}`;
  }
  template() {
    if (this.text) {
      return x$3`<wui-text variant="small-500" color="fg-200">${this.text}</wui-text>`;
    }
    return null;
  }
};
WuiSeparator.styles = [resetStyles, styles$o];
__decorate$H([
  n$4()
], WuiSeparator.prototype, "text", void 0);
WuiSeparator = __decorate$H([
  customElement("wui-separator")
], WuiSeparator);
var dayjs_min = { exports: {} };
(function(module2, exports2) {
  !function(t2, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n4 = 36e5, r2 = "millisecond", i3 = "second", s3 = "minute", u3 = "hour", a3 = "day", o2 = "week", c2 = "month", f4 = "quarter", h5 = "year", d3 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y3 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M3 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n5 = t3 % 100;
      return "[" + t3 + (e3[(n5 - 20) % 10] || e3[n5] || e3[0]) + "]";
    } }, m2 = function(t3, e3, n5) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n5) + t3;
    }, v4 = { s: m2, z: function(t3) {
      var e3 = -t3.utcOffset(), n5 = Math.abs(e3), r3 = Math.floor(n5 / 60), i4 = n5 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i4, 2, "0");
    }, m: function t3(e3, n5) {
      if (e3.date() < n5.date())
        return -t3(n5, e3);
      var r3 = 12 * (n5.year() - e3.year()) + (n5.month() - e3.month()), i4 = e3.clone().add(r3, c2), s4 = n5 - i4 < 0, u4 = e3.clone().add(r3 + (s4 ? -1 : 1), c2);
      return +(-(r3 + (n5 - i4) / (s4 ? i4 - u4 : u4 - i4)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h5, w: o2, d: a3, D: d3, h: u3, m: s3, s: i3, ms: r2, Q: f4 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g3 = "en", D2 = {};
    D2[g3] = M3;
    var p3 = "$isDayjsObject", S3 = function(t3) {
      return t3 instanceof _3 || !(!t3 || !t3[p3]);
    }, w3 = function t3(e3, n5, r3) {
      var i4;
      if (!e3)
        return g3;
      if ("string" == typeof e3) {
        var s4 = e3.toLowerCase();
        D2[s4] && (i4 = s4), n5 && (D2[s4] = n5, i4 = s4);
        var u4 = e3.split("-");
        if (!i4 && u4.length > 1)
          return t3(u4[0]);
      } else {
        var a4 = e3.name;
        D2[a4] = e3, i4 = a4;
      }
      return !r3 && i4 && (g3 = i4), i4 || !r3 && g3;
    }, O2 = function(t3, e3) {
      if (S3(t3))
        return t3.clone();
      var n5 = "object" == typeof e3 ? e3 : {};
      return n5.date = t3, n5.args = arguments, new _3(n5);
    }, b4 = v4;
    b4.l = w3, b4.i = S3, b4.w = function(t3, e3) {
      return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _3 = function() {
      function M4(t3) {
        this.$L = w3(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p3] = true;
      }
      var m3 = M4.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n5 = t4.utc;
          if (null === e3)
            return /* @__PURE__ */ new Date(NaN);
          if (b4.u(e3))
            return /* @__PURE__ */ new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($2);
            if (r3) {
              var i4 = r3[2] - 1 || 0, s4 = (r3[7] || "0").substring(0, 3);
              return n5 ? new Date(Date.UTC(r3[1], i4, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s4)) : new Date(r3[1], i4, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s4);
            }
          }
          return new Date(e3);
        }(t3), this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return b4;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t3, e3) {
        var n5 = O2(t3);
        return this.startOf(e3) <= n5 && n5 <= this.endOf(e3);
      }, m3.isAfter = function(t3, e3) {
        return O2(t3) < this.startOf(e3);
      }, m3.isBefore = function(t3, e3) {
        return this.endOf(e3) < O2(t3);
      }, m3.$g = function(t3, e3, n5) {
        return b4.u(t3) ? this[e3] : this.set(n5, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e3) {
        var n5 = this, r3 = !!b4.u(e3) || e3, f5 = b4.p(t3), l3 = function(t4, e4) {
          var i4 = b4.w(n5.$u ? Date.UTC(n5.$y, e4, t4) : new Date(n5.$y, e4, t4), n5);
          return r3 ? i4 : i4.endOf(a3);
        }, $3 = function(t4, e4) {
          return b4.w(n5.toDate()[t4].apply(n5.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n5);
        }, y4 = this.$W, M5 = this.$M, m4 = this.$D, v5 = "set" + (this.$u ? "UTC" : "");
        switch (f5) {
          case h5:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M5) : l3(0, M5 + 1);
          case o2:
            var g4 = this.$locale().weekStart || 0, D3 = (y4 < g4 ? y4 + 7 : y4) - g4;
            return l3(r3 ? m4 - D3 : m4 + (6 - D3), M5);
          case a3:
          case d3:
            return $3(v5 + "Hours", 0);
          case u3:
            return $3(v5 + "Minutes", 1);
          case s3:
            return $3(v5 + "Seconds", 2);
          case i3:
            return $3(v5 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e3) {
        var n5, o3 = b4.p(t3), f5 = "set" + (this.$u ? "UTC" : ""), l3 = (n5 = {}, n5[a3] = f5 + "Date", n5[d3] = f5 + "Date", n5[c2] = f5 + "Month", n5[h5] = f5 + "FullYear", n5[u3] = f5 + "Hours", n5[s3] = f5 + "Minutes", n5[i3] = f5 + "Seconds", n5[r2] = f5 + "Milliseconds", n5)[o3], $3 = o3 === a3 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c2 || o3 === h5) {
          var y4 = this.clone().set(d3, 1);
          y4.$d[l3]($3), y4.init(), this.$d = y4.set(d3, Math.min(this.$D, y4.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($3);
        return this.init(), this;
      }, m3.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m3.get = function(t3) {
        return this[b4.p(t3)]();
      }, m3.add = function(r3, f5) {
        var d4, l3 = this;
        r3 = Number(r3);
        var $3 = b4.p(f5), y4 = function(t3) {
          var e3 = O2(l3);
          return b4.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        };
        if ($3 === c2)
          return this.set(c2, this.$M + r3);
        if ($3 === h5)
          return this.set(h5, this.$y + r3);
        if ($3 === a3)
          return y4(1);
        if ($3 === o2)
          return y4(7);
        var M5 = (d4 = {}, d4[s3] = e2, d4[u3] = n4, d4[i3] = t2, d4)[$3] || 1, m4 = this.$d.getTime() + r3 * M5;
        return b4.w(m4, this);
      }, m3.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m3.format = function(t3) {
        var e3 = this, n5 = this.$locale();
        if (!this.isValid())
          return n5.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i4 = b4.z(this), s4 = this.$H, u4 = this.$m, a4 = this.$M, o3 = n5.weekdays, c3 = n5.months, f5 = n5.meridiem, h6 = function(t4, n6, i5, s5) {
          return t4 && (t4[n6] || t4(e3, r3)) || i5[n6].slice(0, s5);
        }, d4 = function(t4) {
          return b4.s(s4 % 12 || 12, t4, "0");
        }, $3 = f5 || function(t4, e4, n6) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n6 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y3, function(t4, r4) {
          return r4 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b4.s(e3.$y, 4, "0");
              case "M":
                return a4 + 1;
              case "MM":
                return b4.s(a4 + 1, 2, "0");
              case "MMM":
                return h6(n5.monthsShort, a4, c3, 3);
              case "MMMM":
                return h6(c3, a4);
              case "D":
                return e3.$D;
              case "DD":
                return b4.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h6(n5.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h6(n5.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s4);
              case "HH":
                return b4.s(s4, 2, "0");
              case "h":
                return d4(1);
              case "hh":
                return d4(2);
              case "a":
                return $3(s4, u4, true);
              case "A":
                return $3(s4, u4, false);
              case "m":
                return String(u4);
              case "mm":
                return b4.s(u4, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b4.s(e3.$s, 2, "0");
              case "SSS":
                return b4.s(e3.$ms, 3, "0");
              case "Z":
                return i4;
            }
            return null;
          }(t4) || i4.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d4, l3) {
        var $3, y4 = this, M5 = b4.p(d4), m4 = O2(r3), v5 = (m4.utcOffset() - this.utcOffset()) * e2, g4 = this - m4, D3 = function() {
          return b4.m(y4, m4);
        };
        switch (M5) {
          case h5:
            $3 = D3() / 12;
            break;
          case c2:
            $3 = D3();
            break;
          case f4:
            $3 = D3() / 3;
            break;
          case o2:
            $3 = (g4 - v5) / 6048e5;
            break;
          case a3:
            $3 = (g4 - v5) / 864e5;
            break;
          case u3:
            $3 = g4 / n4;
            break;
          case s3:
            $3 = g4 / e2;
            break;
          case i3:
            $3 = g4 / t2;
            break;
          default:
            $3 = g4;
        }
        return l3 ? $3 : b4.a($3);
      }, m3.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n5 = this.clone(), r3 = w3(t3, e3, true);
        return r3 && (n5.$L = r3), n5;
      }, m3.clone = function() {
        return b4.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M4;
    }(), k3 = _3.prototype;
    return O2.prototype = k3, [["$ms", r2], ["$s", i3], ["$m", s3], ["$H", u3], ["$W", a3], ["$M", c2], ["$y", h5], ["$D", d3]].forEach(function(t3) {
      k3[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), O2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _3, O2), t3.$i = true), O2;
    }, O2.locale = w3, O2.isDayjs = S3, O2.unix = function(t3) {
      return O2(1e3 * t3);
    }, O2.en = D2[g3], O2.Ls = D2, O2.p = {}, O2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var updateLocale$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, n4) {
    module2.exports = n4();
  }(commonjsGlobal, function() {
    return function(e2, n4, t2) {
      t2.updateLocale = function(e3, n5) {
        var o2 = t2.Ls[e3];
        if (o2)
          return (n5 ? Object.keys(n5) : []).forEach(function(e4) {
            o2[e4] = n5[e4];
          }), o2;
      };
    };
  });
})(updateLocale$1);
var updateLocaleExports = updateLocale$1.exports;
const updateLocale = /* @__PURE__ */ getDefaultExportFromCjs(updateLocaleExports);
var relativeTime$1 = { exports: {} };
(function(module2, exports2) {
  !function(r2, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    return function(r2, e2, t2) {
      r2 = r2 || {};
      var n4 = e2.prototype, o2 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function i3(r3, e3, t3, o3) {
        return n4.fromToBase(r3, e3, t3, o3);
      }
      t2.en.relativeTime = o2, n4.fromToBase = function(e3, n5, i4, d4, u3) {
        for (var f4, a3, s3, l2 = i4.$locale().relativeTime || o2, h5 = r2.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m2 = h5.length, c2 = 0; c2 < m2; c2 += 1) {
          var y3 = h5[c2];
          y3.d && (f4 = d4 ? t2(e3).diff(i4, y3.d, true) : i4.diff(e3, y3.d, true));
          var p3 = (r2.rounding || Math.round)(Math.abs(f4));
          if (s3 = f4 > 0, p3 <= y3.r || !y3.r) {
            p3 <= 1 && c2 > 0 && (y3 = h5[c2 - 1]);
            var v4 = l2[y3.l];
            u3 && (p3 = u3("" + p3)), a3 = "string" == typeof v4 ? v4.replace("%d", p3) : v4(p3, n5, y3.l, s3);
            break;
          }
        }
        if (n5)
          return a3;
        var M3 = s3 ? l2.future : l2.past;
        return "function" == typeof M3 ? M3(a3) : M3.replace("%s", a3);
      }, n4.to = function(r3, e3) {
        return i3(r3, e3, this, true);
      }, n4.from = function(r3, e3) {
        return i3(r3, e3, this);
      };
      var d3 = function(r3) {
        return r3.$u ? t2.utc() : t2();
      };
      n4.toNow = function(r3) {
        return this.to(d3(this), r3);
      }, n4.fromNow = function(r3) {
        return this.from(d3(this), r3);
      };
    };
  });
})(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = /* @__PURE__ */ getDefaultExportFromCjs(relativeTimeExports);
dayjs.extend(relativeTime);
dayjs.extend(updateLocale);
dayjs.updateLocale("en", {
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "%s sec",
    m: "1 min",
    mm: "%d min",
    h: "1 hr",
    hh: "%d hrs",
    d: "1 d",
    dd: "%d d",
    M: "1 mo",
    MM: "%d mo",
    y: "1 yr",
    yy: "%d yr"
  }
});
const DateUtil = {
  getYear(date2 = (/* @__PURE__ */ new Date()).toISOString()) {
    return dayjs(date2).year();
  },
  getRelativeDateFromNow(date2) {
    return dayjs(date2).fromNow(true);
  }
};
const FLOAT_FIXED_VALUE = 3;
const plusTypes = ["receive", "deposit", "borrow", "claim"];
const minusTypes = ["withdraw", "repay", "burn"];
const TransactionUtil = {
  getTransactionGroupTitle(year) {
    const currentYear = DateUtil.getYear();
    const isCurrentYear = year === currentYear;
    const groupTitle = isCurrentYear ? "This Year" : year;
    return groupTitle;
  },
  getTransactionImages(transfers) {
    const [transfer, secondTransfer] = transfers;
    const isAllNFT = Boolean(transfer) && transfers?.every((item) => Boolean(item.nft_info));
    const haveMultipleTransfers = transfers?.length > 1;
    const haveTwoTransfers = transfers?.length === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return [this.getTransactionImage(transfer), this.getTransactionImage(secondTransfer)];
    }
    if (haveMultipleTransfers) {
      return transfers.map((item) => this.getTransactionImage(item));
    }
    return [this.getTransactionImage(transfer)];
  },
  getTransactionImage(transfer) {
    return {
      type: TransactionUtil.getTransactionTransferTokenType(transfer),
      url: TransactionUtil.getTransactionImageURL(transfer)
    };
  },
  getTransactionImageURL(transfer) {
    let imageURL = null;
    const isNFT = Boolean(transfer?.nft_info);
    const isFungible = Boolean(transfer?.fungible_info);
    if (transfer && isNFT) {
      imageURL = transfer?.nft_info?.content?.preview?.url;
    } else if (transfer && isFungible) {
      imageURL = transfer?.fungible_info?.icon?.url;
    }
    return imageURL;
  },
  getTransactionTransferTokenType(transfer) {
    if (transfer?.fungible_info) {
      return "FUNGIBLE";
    } else if (transfer?.nft_info) {
      return "NFT";
    }
    return null;
  },
  getTransactionDescriptions(transaction) {
    const type2 = transaction.metadata?.operationType;
    const transfers = transaction.transfers;
    const haveTransfer = transaction.transfers?.length > 0;
    const haveMultipleTransfers = transaction.transfers?.length > 1;
    const isFungible = haveTransfer && transfers?.every((transfer) => Boolean(transfer.fungible_info));
    const [firstTransfer, secondTransfer] = transfers;
    let firstDescription = this.getTransferDescription(firstTransfer);
    let secondDescription = this.getTransferDescription(secondTransfer);
    if (!haveTransfer) {
      const isSendOrReceive = type2 === "send" || type2 === "receive";
      if (isSendOrReceive && isFungible) {
        firstDescription = UiHelperUtil.getTruncateString({
          string: transaction.metadata.sentFrom,
          charsStart: 4,
          charsEnd: 6,
          truncate: "middle"
        });
        secondDescription = UiHelperUtil.getTruncateString({
          string: transaction.metadata.sentTo,
          charsStart: 4,
          charsEnd: 6,
          truncate: "middle"
        });
        return [firstDescription, secondDescription];
      }
      return [transaction.metadata.status];
    }
    if (haveMultipleTransfers) {
      return transfers.map((item) => this.getTransferDescription(item));
    }
    let prefix = "";
    if (plusTypes.includes(type2)) {
      prefix = "+";
    } else if (minusTypes.includes(type2)) {
      prefix = "-";
    }
    firstDescription = prefix.concat(firstDescription);
    return [firstDescription];
  },
  getTransferDescription(transfer) {
    let description = "";
    if (!transfer) {
      return description;
    }
    if (transfer?.nft_info) {
      description = transfer?.nft_info?.name || "-";
    } else if (transfer?.fungible_info) {
      description = this.getFungibleTransferDescription(transfer) || "-";
    }
    return description;
  },
  getFungibleTransferDescription(transfer) {
    if (!transfer) {
      return null;
    }
    const quantity = this.getQuantityFixedValue(transfer?.quantity.numeric);
    const description = [quantity, transfer?.fungible_info?.symbol].join(" ").trim();
    return description;
  },
  getQuantityFixedValue(value) {
    if (!value) {
      return null;
    }
    const parsedValue = parseFloat(value);
    return parsedValue.toFixed(FLOAT_FIXED_VALUE);
  }
};
var __decorate$G = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountButton = class W3mAccountButton2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = "show";
    this.charsStart = 4;
    this.charsEnd = 6;
    this.address = AccountController.state.address;
    this.balanceVal = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.profileName = AccountController.state.profileName;
    this.profileImage = AccountController.state.profileImage;
    this.network = NetworkController.state.caipNetwork;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.isConnected) {
          this.address = val.address;
          this.balanceVal = val.balance;
          this.profileName = val.profileName;
          this.profileImage = val.profileImage;
          this.balanceSymbol = val.balanceSymbol;
        } else {
          this.address = "";
          this.balanceVal = "";
          this.profileName = "";
          this.profileImage = "";
          this.balanceSymbol = "";
        }
      }),
      NetworkController.subscribeKey("caipNetwork", (val) => this.network = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const networkImage = AssetUtil.getNetworkImage(this.network);
    const showBalance = this.balance === "show";
    return x$3`
      <wui-account-button
        .disabled=${Boolean(this.disabled)}
        address=${o$4(this.profileName ?? this.address)}
        ?isProfileName=${Boolean(this.profileName)}
        networkSrc=${o$4(networkImage)}
        avatarSrc=${o$4(this.profileImage)}
        balance=${showBalance ? CoreHelperUtil.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
        @click=${this.onClick.bind(this)}
        data-testid="account-button"
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
      >
      </wui-account-button>
    `;
  }
  onClick() {
    ModalController.open();
  }
};
__decorate$G([
  n$4({ type: Boolean })
], W3mAccountButton.prototype, "disabled", void 0);
__decorate$G([
  n$4()
], W3mAccountButton.prototype, "balance", void 0);
__decorate$G([
  n$4()
], W3mAccountButton.prototype, "charsStart", void 0);
__decorate$G([
  n$4()
], W3mAccountButton.prototype, "charsEnd", void 0);
__decorate$G([
  r$4()
], W3mAccountButton.prototype, "address", void 0);
__decorate$G([
  r$4()
], W3mAccountButton.prototype, "balanceVal", void 0);
__decorate$G([
  r$4()
], W3mAccountButton.prototype, "balanceSymbol", void 0);
__decorate$G([
  r$4()
], W3mAccountButton.prototype, "profileName", void 0);
__decorate$G([
  r$4()
], W3mAccountButton.prototype, "profileImage", void 0);
__decorate$G([
  r$4()
], W3mAccountButton.prototype, "network", void 0);
W3mAccountButton = __decorate$G([
  customElement("w3m-account-button")
], W3mAccountButton);
const styles$n = i$7`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$F = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mButton = class W3mButton2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = void 0;
    this.size = void 0;
    this.label = void 0;
    this.loadingLabel = void 0;
    this.charsStart = 4;
    this.charsEnd = 6;
    this.isAccount = AccountController.state.isConnected;
    this.unsubscribe.push(AccountController.subscribeKey("isConnected", (val) => {
      this.isAccount = val;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return this.isAccount ? x$3`
          <w3m-account-button
            .disabled=${Boolean(this.disabled)}
            balance=${o$4(this.balance)}
            .charsStart=${o$4(this.charsStart)}
            .charsEnd=${o$4(this.charsEnd)}
          >
          </w3m-account-button>
        ` : x$3`
          <w3m-connect-button
            size=${o$4(this.size)}
            label=${o$4(this.label)}
            loadingLabel=${o$4(this.loadingLabel)}
          ></w3m-connect-button>
        `;
  }
};
W3mButton.styles = styles$n;
__decorate$F([
  n$4({ type: Boolean })
], W3mButton.prototype, "disabled", void 0);
__decorate$F([
  n$4()
], W3mButton.prototype, "balance", void 0);
__decorate$F([
  n$4()
], W3mButton.prototype, "size", void 0);
__decorate$F([
  n$4()
], W3mButton.prototype, "label", void 0);
__decorate$F([
  n$4()
], W3mButton.prototype, "loadingLabel", void 0);
__decorate$F([
  n$4()
], W3mButton.prototype, "charsStart", void 0);
__decorate$F([
  n$4()
], W3mButton.prototype, "charsEnd", void 0);
__decorate$F([
  r$4()
], W3mButton.prototype, "isAccount", void 0);
W3mButton = __decorate$F([
  customElement("w3m-button")
], W3mButton);
var __decorate$E = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectButton = class W3mConnectButton2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.size = "md";
    this.label = "Connect Wallet";
    this.loadingLabel = "Connecting...";
    this.open = ModalController.state.open;
    this.loading = ModalController.state.loading;
    this.unsubscribe.push(ModalController.subscribe((val) => {
      this.open = val.open;
      this.loading = val.loading;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const isLoading = this.loading || this.open;
    return x$3`
      <wui-connect-button
        size=${o$4(this.size)}
        .loading=${isLoading}
        @click=${this.onClick.bind(this)}
        data-testid="connect-button"
      >
        ${isLoading ? this.loadingLabel : this.label}
      </wui-connect-button>
    `;
  }
  onClick() {
    if (this.open) {
      ModalController.close();
    } else if (!this.loading) {
      ModalController.open();
    }
  }
};
__decorate$E([
  n$4()
], W3mConnectButton.prototype, "size", void 0);
__decorate$E([
  n$4()
], W3mConnectButton.prototype, "label", void 0);
__decorate$E([
  n$4()
], W3mConnectButton.prototype, "loadingLabel", void 0);
__decorate$E([
  r$4()
], W3mConnectButton.prototype, "open", void 0);
__decorate$E([
  r$4()
], W3mConnectButton.prototype, "loading", void 0);
W3mConnectButton = __decorate$E([
  customElement("w3m-connect-button")
], W3mConnectButton);
const styles$m = i$7`
  :host {
    z-index: var(--w3m-z-index);
    display: block;
    backface-visibility: hidden;
    will-change: opacity;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    background-color: var(--wui-cover);
  }

  @keyframes zoom-in {
    0% {
      transform: scale(0.95) translateY(0);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes slide-in {
    0% {
      transform: scale(1) translateY(50px);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  wui-card {
    max-width: 360px;
    width: 100%;
    position: relative;
    animation-delay: 0.3s;
    animation-duration: 0.2s;
    animation-name: zoom-in;
    animation-fill-mode: backwards;
    animation-timing-function: var(--wui-ease-out-power-2);
    outline: none;
  }

  wui-flex {
    overflow-x: hidden;
    overflow-y: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  @media (max-height: 700px) and (min-width: 431px) {
    wui-flex {
      align-items: flex-start;
    }

    wui-card {
      margin: var(--wui-spacing-xxl) 0px;
    }
  }

  @media (max-width: 430px) {
    wui-flex {
      align-items: flex-end;
    }

    wui-card {
      max-width: 100%;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-bottom: none;
      animation-name: slide-in;
    }
  }
`;
var __decorate$D = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const SCROLL_LOCK = "scroll-lock";
let W3mModal = class W3mModal2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.abortController = void 0;
    this.open = ModalController.state.open;
    this.caipAddress = AccountController.state.address;
    this.isSiweEnabled = SIWEController.state.isSiweEnabled;
    this.initializeTheming();
    ApiController.prefetch();
    this.unsubscribe.push(ModalController.subscribeKey("open", (val) => val ? this.onOpen() : this.onClose()), SIWEController.subscribeKey("isSiweEnabled", (isEnabled) => {
      this.isSiweEnabled = isEnabled;
    }), AccountController.subscribe((newAccountState) => this.onNewAccountState(newAccountState)));
    EventsController.sendEvent({ type: "track", event: "MODAL_LOADED" });
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    this.onRemoveKeyboardListener();
  }
  render() {
    return this.open ? x$3`
          <wui-flex @click=${this.onOverlayClick.bind(this)}>
            <wui-card role="alertdialog" aria-modal="true" tabindex="0">
              <w3m-header></w3m-header>
              <w3m-router></w3m-router>
              <w3m-snackbar></w3m-snackbar>
            </wui-card>
          </wui-flex>
        ` : null;
  }
  async onOverlayClick(event) {
    if (event.target === event.currentTarget) {
      await this.handleClose();
    }
  }
  async handleClose() {
    if (this.isSiweEnabled && SIWEController.state.status !== "success") {
      await ConnectionController.disconnect();
    }
    ModalController.close();
  }
  initializeTheming() {
    const { themeVariables, themeMode } = ThemeController.state;
    const defaultThemeMode = UiHelperUtil.getColorTheme(themeMode);
    initializeTheming(themeVariables, defaultThemeMode);
  }
  async onClose() {
    this.onScrollUnlock();
    await this.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards"
    }).finished;
    SnackController.hide();
    this.open = false;
    this.onRemoveKeyboardListener();
  }
  async onOpen() {
    this.onScrollLock();
    this.open = true;
    await this.animate([{ opacity: 0 }, { opacity: 1 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards",
      delay: 300
    }).finished;
    this.onAddKeyboardListener();
  }
  onScrollLock() {
    const styleTag = document.createElement("style");
    styleTag.dataset["w3m"] = SCROLL_LOCK;
    styleTag.textContent = `
      html, body {
        touch-action: none;
        overflow: hidden;
        overscroll-behavior: contain;
      }
      w3m-modal {
        pointer-events: auto;
      }
    `;
    document.head.appendChild(styleTag);
  }
  onScrollUnlock() {
    const styleTag = document.head.querySelector(`style[data-w3m="${SCROLL_LOCK}"]`);
    if (styleTag) {
      styleTag.remove();
    }
  }
  onAddKeyboardListener() {
    this.abortController = new AbortController();
    const card = this.shadowRoot?.querySelector("wui-card");
    card?.focus();
    window.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        this.handleClose();
      } else if (event.key === "Tab") {
        const { tagName } = event.target;
        if (tagName && !tagName.includes("W3M-") && !tagName.includes("WUI-")) {
          card?.focus();
        }
      }
    }, this.abortController);
  }
  onRemoveKeyboardListener() {
    this.abortController?.abort();
    this.abortController = void 0;
  }
  async onNewAccountState(newState) {
    const { isConnected, caipAddress: newCaipAddress } = newState;
    if (this.isSiweEnabled) {
      if (isConnected && !this.caipAddress) {
        this.caipAddress = newCaipAddress;
      }
      if (isConnected && newCaipAddress && this.caipAddress !== newCaipAddress) {
        await SIWEController.signOut();
        this.onSiweNavigation();
        this.caipAddress = newCaipAddress;
      }
      try {
        const session = await SIWEController.getSession();
        if (session && !isConnected) {
          await SIWEController.signOut();
        } else if (isConnected && !session) {
          this.onSiweNavigation();
        }
      } catch (error) {
        if (isConnected) {
          this.onSiweNavigation();
        }
      }
    }
  }
  onSiweNavigation() {
    if (this.open) {
      RouterController.push("ConnectingSiwe");
    } else {
      ModalController.open({
        view: "ConnectingSiwe"
      });
    }
  }
};
W3mModal.styles = styles$m;
__decorate$D([
  r$4()
], W3mModal.prototype, "open", void 0);
__decorate$D([
  r$4()
], W3mModal.prototype, "caipAddress", void 0);
__decorate$D([
  r$4()
], W3mModal.prototype, "isSiweEnabled", void 0);
W3mModal = __decorate$D([
  customElement("w3m-modal")
], W3mModal);
const index$M = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get W3mModal() {
    return W3mModal;
  }
}, Symbol.toStringTag, { value: "Module" }));
const styles$l = i$7`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$C = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mNetworkButton = class W3mNetworkButton2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.network = NetworkController.state.caipNetwork;
    this.connected = AccountController.state.isConnected;
    this.loading = ModalController.state.loading;
    this.unsubscribe.push(...[
      NetworkController.subscribeKey("caipNetwork", (val) => this.network = val),
      AccountController.subscribeKey("isConnected", (val) => this.connected = val),
      ModalController.subscribeKey("loading", (val) => this.loading = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`
      <wui-network-button
        .disabled=${Boolean(this.disabled || this.loading)}
        imageSrc=${o$4(AssetUtil.getNetworkImage(this.network))}
        @click=${this.onClick.bind(this)}
      >
        ${this.network?.name ?? (this.connected ? "Unknown Network" : "Select Network")}
      </wui-network-button>
    `;
  }
  onClick() {
    if (!this.loading) {
      ModalController.open({ view: "Networks" });
    }
  }
};
W3mNetworkButton.styles = styles$l;
__decorate$C([
  n$4({ type: Boolean })
], W3mNetworkButton.prototype, "disabled", void 0);
__decorate$C([
  r$4()
], W3mNetworkButton.prototype, "network", void 0);
__decorate$C([
  r$4()
], W3mNetworkButton.prototype, "connected", void 0);
__decorate$C([
  r$4()
], W3mNetworkButton.prototype, "loading", void 0);
W3mNetworkButton = __decorate$C([
  customElement("w3m-network-button")
], W3mNetworkButton);
const styles$k = i$7`
  :host {
    display: block;
    will-change: transform, opacity;
  }
`;
var __decorate$B = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mRouter = class W3mRouter2 extends s$3 {
  constructor() {
    super();
    this.resizeObserver = void 0;
    this.prevHeight = "0px";
    this.prevHistoryLength = 1;
    this.unsubscribe = [];
    this.view = RouterController.state.view;
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => this.onViewChange(val)));
  }
  firstUpdated() {
    this.resizeObserver = new ResizeObserver(async ([content]) => {
      const height = `${content?.contentRect.height}px`;
      if (this.prevHeight !== "0px") {
        await this.animate([{ height: this.prevHeight }, { height }], {
          duration: 150,
          easing: "ease",
          fill: "forwards"
        }).finished;
        this.style.height = "auto";
      }
      this.prevHeight = height;
    });
    this.resizeObserver.observe(this.getWrapper());
  }
  disconnectedCallback() {
    this.resizeObserver?.unobserve(this.getWrapper());
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`<div>${this.viewTemplate()}</div>`;
  }
  viewTemplate() {
    switch (this.view) {
      case "Connect":
        return x$3`<w3m-connect-view></w3m-connect-view>`;
      case "ConnectingWalletConnect":
        return x$3`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
      case "ConnectingExternal":
        return x$3`<w3m-connecting-external-view></w3m-connecting-external-view>`;
      case "ConnectingSiwe":
        return x$3`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
      case "AllWallets":
        return x$3`<w3m-all-wallets-view></w3m-all-wallets-view>`;
      case "Networks":
        return x$3`<w3m-networks-view></w3m-networks-view>`;
      case "SwitchNetwork":
        return x$3`<w3m-network-switch-view></w3m-network-switch-view>`;
      case "Account":
        return x$3`<w3m-account-view></w3m-account-view>`;
      case "WhatIsAWallet":
        return x$3`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
      case "WhatIsANetwork":
        return x$3`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
      case "GetWallet":
        return x$3`<w3m-get-wallet-view></w3m-get-wallet-view>`;
      case "Downloads":
        return x$3`<w3m-downloads-view></w3m-downloads-view>`;
      case "EmailVerifyOtp":
        return x$3`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
      case "EmailVerifyDevice":
        return x$3`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
      case "ApproveTransaction":
        return x$3`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
      case "Transactions":
        return x$3`<w3m-transactions-view></w3m-transactions-view>`;
      case "UpgradeEmailWallet":
        return x$3`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
      case "UpdateEmailWallet":
        return x$3`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
      case "UpdateEmailWalletWaiting":
        return x$3`<w3m-update-email-wallet-waiting-view></w3m-update-email-wallet-waiting-view>`;
      default:
        return x$3`<w3m-connect-view></w3m-connect-view>`;
    }
  }
  async onViewChange(newView) {
    const { history } = RouterController.state;
    let xOut = -10;
    let xIn = 10;
    if (history.length < this.prevHistoryLength) {
      xOut = 10;
      xIn = -10;
    }
    this.prevHistoryLength = history.length;
    await this.animate([
      { opacity: 1, transform: "translateX(0px)" },
      { opacity: 0, transform: `translateX(${xOut}px)` }
    ], { duration: 150, easing: "ease", fill: "forwards" }).finished;
    this.view = newView;
    await this.animate([
      { opacity: 0, transform: `translateX(${xIn}px)` },
      { opacity: 1, transform: "translateX(0px)" }
    ], { duration: 150, easing: "ease", fill: "forwards", delay: 50 }).finished;
  }
  getWrapper() {
    return this.shadowRoot?.querySelector("div");
  }
};
W3mRouter.styles = styles$k;
__decorate$B([
  r$4()
], W3mRouter.prototype, "view", void 0);
W3mRouter = __decorate$B([
  customElement("w3m-router")
], W3mRouter);
const styles$j = i$7`
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  wui-notice-card {
    margin-bottom: var(--wui-spacing-3xs);
  }
`;
var __decorate$A = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountView = class W3mAccountView2 extends s$3 {
  constructor() {
    super();
    this.usubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.balance = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.network = NetworkController.state.caipNetwork;
    this.disconecting = false;
    this.usubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.balance = val.balance;
          this.balanceSymbol = val.balanceSymbol;
        } else {
          ModalController.close();
        }
      })
    ], NetworkController.subscribeKey("caipNetwork", (val) => {
      if (val?.id) {
        this.network = val;
      }
    }));
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return x$3`
      <wui-flex
        flexDirection="column"
        .padding=${["0", "s", "m", "s"]}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${o$4(this.profileImage === null ? void 0 : this.profileImage)}
        ></wui-avatar>

        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="large-600" color="fg-100">
              ${this.profileName ? UiHelperUtil.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
          <wui-flex gap="s" flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-200">
              ${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}
            </wui-text>

            ${this.explorerBtnTemplate()}
          </wui-flex>
        </wui-flex>
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
        ${this.emailCardTemplate()} ${this.emailBtnTemplate()}

        <wui-list-item
          .variant=${networkImage ? "image" : "icon"}
          iconVariant="overlay"
          icon="networkPlaceholder"
          imageSrc=${o$4(networkImage)}
          ?chevron=${this.isAllowedNetworkSwitch()}
          @click=${this.onNetworks.bind(this)}
          data-testid="w3m-account-select-network"
        >
          <wui-text variant="paragraph-500" color="fg-100">
            ${this.network?.name ?? "Unknown"}
          </wui-text>
        </wui-list-item>
        <wui-list-item
          iconVariant="blue"
          icon="swapHorizontalBold"
          iconSize="sm"
          ?chevron=${true}
          @click=${this.onTransactions.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-100">Activity</wui-text>
        </wui-list-item>
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${false}
          .loading=${this.disconecting}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>
    `;
  }
  emailCardTemplate() {
    const type2 = StorageUtil.getConnectedConnector();
    const emailConnector = ConnectorController.getEmailConnector();
    const { origin } = location;
    if (!emailConnector || type2 !== "EMAIL" || origin.includes(ConstantsUtil$1.SECURE_SITE)) {
      return null;
    }
    return x$3`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a non-custodial wallet"
        icon="wallet"
      ></wui-notice-card>
    `;
  }
  emailBtnTemplate() {
    const type2 = StorageUtil.getConnectedConnector();
    const emailConnector = ConnectorController.getEmailConnector();
    if (!emailConnector || type2 !== "EMAIL") {
      return null;
    }
    const email = emailConnector.provider.getEmail() ?? "";
    return x$3`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="mail"
        iconSize="sm"
        ?chevron=${true}
        @click=${() => this.onGoToUpdateEmail(email)}
      >
        <wui-text variant="paragraph-500" color="fg-100">${email}</wui-text>
      </wui-list-item>
    `;
  }
  explorerBtnTemplate() {
    const { addressExplorerUrl } = AccountController.state;
    if (!addressExplorerUrl) {
      return null;
    }
    return x$3`
      <wui-button size="sm" variant="shade" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    `;
  }
  isAllowedNetworkSwitch() {
    const { requestedCaipNetworks } = NetworkController.state;
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks?.find(({ id: id2 }) => id2 === this.network?.id);
    return isMultiNetwork || !isValidNetwork;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      RouterController.push("Networks");
    }
  }
  onTransactions() {
    EventsController.sendEvent({ type: "track", event: "CLICK_TRANSACTIONS" });
    RouterController.push("Transactions");
  }
  async onDisconnect() {
    try {
      this.disconecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconecting = false;
    }
  }
  onExplorer() {
    const { addressExplorerUrl } = AccountController.state;
    if (addressExplorerUrl) {
      CoreHelperUtil.openHref(addressExplorerUrl, "_blank");
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
  onGoToUpdateEmail(email) {
    RouterController.push("UpdateEmailWallet", { email });
  }
};
W3mAccountView.styles = styles$j;
__decorate$A([
  r$4()
], W3mAccountView.prototype, "address", void 0);
__decorate$A([
  r$4()
], W3mAccountView.prototype, "profileImage", void 0);
__decorate$A([
  r$4()
], W3mAccountView.prototype, "profileName", void 0);
__decorate$A([
  r$4()
], W3mAccountView.prototype, "balance", void 0);
__decorate$A([
  r$4()
], W3mAccountView.prototype, "balanceSymbol", void 0);
__decorate$A([
  r$4()
], W3mAccountView.prototype, "network", void 0);
__decorate$A([
  r$4()
], W3mAccountView.prototype, "disconecting", void 0);
W3mAccountView = __decorate$A([
  customElement("w3m-account-view")
], W3mAccountView);
var __decorate$z = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAllWalletsView = class W3mAllWalletsView2 extends s$3 {
  constructor() {
    super(...arguments);
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    });
  }
  render() {
    const isSearch = this.search.length >= 2;
    return x$3`
      <wui-flex padding="s" gap="s">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${isSearch ? x$3`<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>` : x$3`<w3m-all-wallets-list></w3m-all-wallets-list>`}
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  qrButtonTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return x$3`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  onWalletConnectQr() {
    RouterController.push("ConnectingWalletConnect");
  }
};
__decorate$z([
  r$4()
], W3mAllWalletsView.prototype, "search", void 0);
W3mAllWalletsView = __decorate$z([
  customElement("w3m-all-wallets-view")
], W3mAllWalletsView);
const styles$i = i$7`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$y = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectView = class W3mConnectView2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-email-login-widget></w3m-email-login-widget>

        ${this.walletConnectConnectorTemplate()} ${this.recentTemplate()}
        ${this.announcedTemplate()} ${this.injectedTemplate()} ${this.featuredTemplate()}
        ${this.customTemplate()} ${this.recommendedTemplate()} ${this.connectorsTemplate()}
        ${this.allWalletsTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  walletConnectConnectorTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return null;
    }
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    return x$3`
      <wui-list-wallet
        imageSrc=${o$4(AssetUtil.getConnectorImage(connector))}
        name=${connector.name ?? "Unknown"}
        @click=${() => this.onConnector(connector)}
        tagLabel="qr code"
        tagVariant="main"
        data-testid="wallet-selector-walletconnect"
      >
      </wui-list-wallet>
    `;
  }
  customTemplate() {
    const { customWallets } = OptionsController.state;
    if (!customWallets?.length) {
      return null;
    }
    const wallets2 = this.filterOutDuplicateWallets(customWallets);
    return wallets2.map((wallet) => x$3`
        <wui-list-wallet
          imageSrc=${o$4(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
        >
        </wui-list-wallet>
      `);
  }
  featuredTemplate() {
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    const { featured } = ApiController.state;
    if (!featured.length) {
      return null;
    }
    const wallets2 = this.filterOutDuplicateWallets(featured);
    return wallets2.map((wallet) => x$3`
        <wui-list-wallet
          imageSrc=${o$4(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
        >
        </wui-list-wallet>
      `);
  }
  recentTemplate() {
    const recent = StorageUtil.getRecentWallets();
    return recent.map((wallet) => x$3`
        <wui-list-wallet
          imageSrc=${o$4(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
          tagLabel="recent"
          tagVariant="shade"
        >
        </wui-list-wallet>
      `);
  }
  announcedTemplate() {
    return this.connectors.map((connector) => {
      if (connector.type !== "ANNOUNCED") {
        return null;
      }
      return x$3`
        <wui-list-wallet
          imageSrc=${o$4(AssetUtil.getConnectorImage(connector))}
          name=${connector.name ?? "Unknown"}
          @click=${() => this.onConnector(connector)}
          tagVariant="success"
          .installed=${true}
        >
        </wui-list-wallet>
      `;
    });
  }
  injectedTemplate() {
    const announced = this.connectors.find((c2) => c2.type === "ANNOUNCED");
    return this.connectors.map((connector) => {
      if (connector.type !== "INJECTED") {
        return null;
      }
      if (!ConnectionController.checkInstalled()) {
        return null;
      }
      return x$3`
        <wui-list-wallet
          imageSrc=${o$4(AssetUtil.getConnectorImage(connector))}
          .installed=${Boolean(announced)}
          name=${connector.name ?? "Unknown"}
          @click=${() => this.onConnector(connector)}
        >
        </wui-list-wallet>
      `;
    });
  }
  connectorsTemplate() {
    const announcedRdns = ConnectorController.getAnnouncedConnectorRdns();
    return this.connectors.map((connector) => {
      if (["WALLET_CONNECT", "INJECTED", "ANNOUNCED", "EMAIL"].includes(connector.type)) {
        return null;
      }
      if (announcedRdns.includes(ConstantsUtil$1.CONNECTOR_RDNS_MAP[connector.id])) {
        return null;
      }
      return x$3`
        <wui-list-wallet
          imageSrc=${o$4(AssetUtil.getConnectorImage(connector))}
          name=${connector.name ?? "Unknown"}
          @click=${() => this.onConnector(connector)}
        >
        </wui-list-wallet>
      `;
    });
  }
  allWalletsTemplate() {
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    const count2 = ApiController.state.count;
    const featuredCount = ApiController.state.featured.length;
    const rawCount = count2 + featuredCount;
    const roundedCount = rawCount < 10 ? rawCount : Math.floor(rawCount / 10) * 10;
    const tagLabel = roundedCount < rawCount ? `${roundedCount}+` : `${roundedCount}`;
    return x$3`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${tagLabel}
        tagVariant="shade"
        data-testid="all-wallets"
      ></wui-list-wallet>
    `;
  }
  recommendedTemplate() {
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    const { recommended } = ApiController.state;
    const { customWallets, featuredWalletIds } = OptionsController.state;
    const { connectors } = ConnectorController.state;
    const recent = StorageUtil.getRecentWallets();
    const eip6963 = connectors.filter((c2) => c2.type === "ANNOUNCED");
    if (featuredWalletIds || customWallets || !recommended.length) {
      return null;
    }
    const overrideLength = eip6963.length + recent.length;
    const maxRecommended = Math.max(0, 2 - overrideLength);
    const wallets2 = this.filterOutDuplicateWallets(recommended).slice(0, maxRecommended);
    return wallets2.map((wallet) => x$3`
        <wui-list-wallet
          imageSrc=${o$4(AssetUtil.getWalletImage(wallet))}
          name=${wallet?.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
        >
        </wui-list-wallet>
      `);
  }
  onConnector(connector) {
    if (connector.type === "WALLET_CONNECT") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", { connector });
    }
  }
  filterOutDuplicateWallets(wallets2) {
    const { connectors } = ConnectorController.state;
    const recent = StorageUtil.getRecentWallets();
    const recentIds = recent.map((wallet) => wallet.id);
    const rdnsIds = connectors.map((c2) => c2.info?.rdns).filter(Boolean);
    const filtered = wallets2.filter((wallet) => !recentIds.includes(wallet.id) && !rdnsIds.includes(wallet.rdns ?? void 0));
    return filtered;
  }
  onAllWallets() {
    EventsController.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" });
    RouterController.push("AllWallets");
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
W3mConnectView.styles = styles$i;
__decorate$y([
  r$4()
], W3mConnectView.prototype, "connectors", void 0);
W3mConnectView = __decorate$y([
  customElement("w3m-connect-view")
], W3mConnectView);
const styles$h = i$7`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;
var __decorate$x = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
class W3mConnectingWidget extends s$3 {
  constructor() {
    super();
    this.wallet = RouterController.state.data?.wallet;
    this.connector = RouterController.state.data?.connector;
    this.timeout = void 0;
    this.secondaryBtnLabel = "Try again";
    this.secondaryBtnIcon = "refresh";
    this.secondaryLabel = "Accept connection request in the wallet";
    this.onConnect = void 0;
    this.onRender = void 0;
    this.onAutoConnect = void 0;
    this.isWalletConnect = true;
    this.unsubscribe = [];
    this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector);
    this.name = this.wallet?.name ?? this.connector?.name ?? "Wallet";
    this.isRetrying = false;
    this.uri = ConnectionController.state.wcUri;
    this.error = ConnectionController.state.wcError;
    this.ready = false;
    this.showRetry = false;
    this.buffering = false;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      ConnectionController.subscribeKey("wcUri", (val) => {
        this.uri = val;
        if (this.isRetrying && this.onRetry) {
          this.isRetrying = false;
          this.onConnect?.();
        }
      }),
      ConnectionController.subscribeKey("wcError", (val) => this.error = val),
      ConnectionController.subscribeKey("buffering", (val) => this.buffering = val)
    ]);
  }
  firstUpdated() {
    this.onAutoConnect?.();
    this.showRetry = !this.onAutoConnect;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearTimeout(this.timeout);
  }
  render() {
    this.onRender?.();
    this.onShowRetry();
    const subLabel = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
    let label = `Continue in ${this.name}`;
    if (this.buffering) {
      label = "Connecting...";
    }
    if (this.error) {
      label = "Connection declined";
    }
    return x$3`
      <wui-flex
        data-error=${o$4(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${o$4(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          variant="accent"
          ?disabled=${!this.error && this.buffering}
          @click=${this.onTryAgain.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
          ${this.secondaryBtnLabel}
        </wui-button>
      </wui-flex>

      ${this.isWalletConnect ? x$3`
            <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          ` : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onShowRetry() {
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = this.shadowRoot?.querySelector("wui-button");
      retryButton?.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onTryAgain() {
    if (!this.buffering) {
      ConnectionController.setWcError(false);
      if (this.onRetry) {
        this.isRetrying = true;
        this.onRetry?.();
      } else {
        this.onConnect?.();
      }
    }
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return x$3`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
}
W3mConnectingWidget.styles = styles$h;
__decorate$x([
  r$4()
], W3mConnectingWidget.prototype, "uri", void 0);
__decorate$x([
  r$4()
], W3mConnectingWidget.prototype, "error", void 0);
__decorate$x([
  r$4()
], W3mConnectingWidget.prototype, "ready", void 0);
__decorate$x([
  r$4()
], W3mConnectingWidget.prototype, "showRetry", void 0);
__decorate$x([
  r$4()
], W3mConnectingWidget.prototype, "buffering", void 0);
__decorate$x([
  n$4({ type: Boolean })
], W3mConnectingWidget.prototype, "isMobile", void 0);
__decorate$x([
  n$4()
], W3mConnectingWidget.prototype, "onRetry", void 0);
var __decorate$w = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const platformMap = {
  INJECTED: "browser",
  ANNOUNCED: "browser"
};
let W3mConnectingExternalView = class W3mConnectingExternalView2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.connector) {
      throw new Error("w3m-connecting-view: No connector provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: {
        name: this.connector.name ?? "Unknown",
        platform: platformMap[this.connector.type] ?? "external"
      }
    });
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    this.isWalletConnect = false;
  }
  async onConnectProxy() {
    try {
      this.error = false;
      if (this.connector) {
        if (this.connector.imageUrl) {
          StorageUtil.setConnectedWalletImageUrl(this.connector.imageUrl);
        }
        await ConnectionController.connectExternal(this.connector);
        if (SIWEController.state.isSiweEnabled) {
          RouterController.push("ConnectingSiwe");
        } else {
          ModalController.close();
        }
        EventsController.sendEvent({
          type: "track",
          event: "CONNECT_SUCCESS",
          properties: { method: "external" }
        });
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: error?.message ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingExternalView = __decorate$w([
  customElement("w3m-connecting-external-view")
], W3mConnectingExternalView);
var __decorate$v = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingSiweView = class W3mConnectingSiweView2 extends s$3 {
  constructor() {
    super(...arguments);
    this.dappName = OptionsController.state.metadata?.name;
    this.isSigning = false;
  }
  render() {
    return x$3`
      <wui-flex justifyContent="center" .padding=${["2xl", "0", "xxl", "0"]}>
        <w3m-connecting-siwe></w3m-connecting-siwe>
      </wui-flex>
      <wui-flex
        .padding=${["0", "4xl", "l", "4xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100"
          >${this.dappName ?? "Dapp"} needs to connect to your wallet</wui-text
        >
      </wui-flex>
      <wui-flex
        .padding=${["0", "3xl", "l", "3xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="small-400" align="center" color="fg-200"
          >Sign this message to prove you own this wallet and proceed. Canceling will disconnect
          you.</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
        <wui-button
          size="md"
          ?fullwidth=${true}
          variant="shade"
          @click=${this.onCancel.bind(this)}
          data-testid="w3m-connecting-siwe-cancel"
        >
          Cancel
        </wui-button>
        <wui-button
          size="md"
          ?fullwidth=${true}
          variant="fill"
          @click=${this.onSign.bind(this)}
          ?loading=${this.isSigning}
          data-testid="w3m-connecting-siwe-sign"
        >
          ${this.isSigning ? "Signing..." : "Sign"}
        </wui-button>
      </wui-flex>
    `;
  }
  async onSign() {
    this.isSigning = true;
    EventsController.sendEvent({
      event: "CLICK_SIGN_SIWE_MESSAGE",
      type: "track"
    });
    try {
      SIWEController.setStatus("loading");
      const session = await SIWEController.signIn();
      SIWEController.setStatus("success");
      EventsController.sendEvent({
        event: "SIWE_AUTH_SUCCESS",
        type: "track"
      });
      return session;
    } catch (error) {
      SnackController.showError("Signature declined");
      SIWEController.setStatus("error");
      return EventsController.sendEvent({
        event: "SIWE_AUTH_ERROR",
        type: "track"
      });
    } finally {
      this.isSigning = false;
    }
  }
  async onCancel() {
    const { isConnected } = AccountController.state;
    if (isConnected) {
      await ConnectionController.disconnect();
      ModalController.close();
    } else {
      RouterController.push("Connect");
    }
    EventsController.sendEvent({
      event: "CLICK_CANCEL_SIWE",
      type: "track"
    });
  }
};
__decorate$v([
  r$4()
], W3mConnectingSiweView.prototype, "isSigning", void 0);
W3mConnectingSiweView = __decorate$v([
  customElement("w3m-connecting-siwe-view")
], W3mConnectingSiweView);
var __decorate$u = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcView = class W3mConnectingWcView2 extends s$3 {
  constructor() {
    super();
    this.interval = void 0;
    this.lastRetry = Date.now();
    this.wallet = RouterController.state.data?.wallet;
    this.platform = void 0;
    this.platforms = [];
    this.initializeConnection();
    this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil$1.TEN_SEC_MS);
  }
  disconnectedCallback() {
    clearTimeout(this.interval);
  }
  render() {
    if (!this.wallet) {
      return x$3`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
    }
    this.determinePlatforms();
    return x$3`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `;
  }
  async initializeConnection(retry2 = false) {
    try {
      const { wcPairingExpiry } = ConnectionController.state;
      if (retry2 || CoreHelperUtil.isPairingExpired(wcPairingExpiry)) {
        ConnectionController.connectWalletConnect();
        if (this.wallet) {
          const url = AssetUtil.getWalletImage(this.wallet);
          if (url) {
            StorageUtil.setConnectedWalletImageUrl(url);
          }
        } else {
          const connectors = ConnectorController.state.connectors;
          const connector = connectors.find((c2) => c2.type === "WALLET_CONNECT");
          const url = AssetUtil.getConnectorImage(connector);
          if (url) {
            StorageUtil.setConnectedWalletImageUrl(url);
          }
        }
        await ConnectionController.state.wcPromise;
        this.finalizeConnection();
        if (SIWEController.state.isSiweEnabled) {
          RouterController.push("ConnectingSiwe");
        } else {
          ModalController.close();
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: error?.message ?? "Unknown" }
      });
      ConnectionController.setWcError(true);
      if (CoreHelperUtil.isAllowedRetry(this.lastRetry)) {
        SnackController.showError("Declined");
        this.lastRetry = Date.now();
        this.initializeConnection(true);
      }
    }
  }
  finalizeConnection() {
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setWeb3ModalRecent(recentWallet);
    }
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: wcLinking ? "mobile" : "qrcode"
      }
    });
  }
  determinePlatforms() {
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-view:determinePlatforms No wallet");
    }
    if (this.platform) {
      return;
    }
    const { mobile_link, desktop_link, webapp_link, injected, rdns } = this.wallet;
    const injectedIds = injected?.map(({ injected_id }) => injected_id).filter(Boolean);
    const browserIds = rdns ? [rdns] : injectedIds ?? [];
    const isBrowser = browserIds.length;
    const isMobileWc = mobile_link;
    const isWebWc = webapp_link;
    const isBrowserInstalled = ConnectionController.checkInstalled(browserIds);
    const isBrowserWc = isBrowser && isBrowserInstalled;
    const isDesktopWc = desktop_link && !CoreHelperUtil.isMobile();
    if (isBrowserWc) {
      this.platforms.push("browser");
    }
    if (isMobileWc) {
      this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode");
    }
    if (isWebWc) {
      this.platforms.push("web");
    }
    if (isDesktopWc) {
      this.platforms.push("desktop");
    }
    if (!isBrowserWc && isBrowser) {
      this.platforms.push("unsupported");
    }
    this.platform = this.platforms[0];
  }
  platformTemplate() {
    switch (this.platform) {
      case "browser":
        return x$3`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
      case "desktop":
        return x$3`
          <w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-desktop>
        `;
      case "web":
        return x$3`
          <w3m-connecting-wc-web .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-web>
        `;
      case "mobile":
        return x$3`
          <w3m-connecting-wc-mobile isMobile .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-mobile>
        `;
      case "qrcode":
        return x$3`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
      default:
        return x$3`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
    }
  }
  headerTemplate() {
    const multiPlatform = this.platforms.length > 1;
    if (!multiPlatform) {
      return null;
    }
    return x$3`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    `;
  }
  async onSelectPlatform(platform) {
    const container2 = this.shadowRoot?.querySelector("div");
    if (container2) {
      await container2.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.platform = platform;
      container2.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
__decorate$u([
  r$4()
], W3mConnectingWcView.prototype, "platform", void 0);
__decorate$u([
  r$4()
], W3mConnectingWcView.prototype, "platforms", void 0);
W3mConnectingWcView = __decorate$u([
  customElement("w3m-connecting-wc-view")
], W3mConnectingWcView);
var __decorate$t = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mDownloadsView = class W3mDownloadsView2 extends s$3 {
  constructor() {
    super(...arguments);
    this.wallet = RouterController.state.data?.wallet;
  }
  render() {
    if (!this.wallet) {
      throw new Error("w3m-downloads-view");
    }
    return x$3`
      <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
  }
  chromeTemplate() {
    if (!this.wallet?.chrome_store) {
      return null;
    }
    return x$3`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>`;
  }
  iosTemplate() {
    if (!this.wallet?.app_store) {
      return null;
    }
    return x$3`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>`;
  }
  androidTemplate() {
    if (!this.wallet?.play_store) {
      return null;
    }
    return x$3`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>`;
  }
  homepageTemplate() {
    if (!this.wallet?.homepage) {
      return null;
    }
    return x$3`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    `;
  }
  onChromeStore() {
    if (this.wallet?.chrome_store) {
      CoreHelperUtil.openHref(this.wallet.chrome_store, "_blank");
    }
  }
  onAppStore() {
    if (this.wallet?.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    if (this.wallet?.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    if (this.wallet?.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mDownloadsView = __decorate$t([
  customElement("w3m-downloads-view")
], W3mDownloadsView);
var __decorate$s = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const EXPLORER = "https://walletconnect.com/explorer";
let W3mGetWalletView = class W3mGetWalletView2 extends s$3 {
  render() {
    return x$3`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${() => {
      CoreHelperUtil.openHref("https://walletconnect.com/explorer?type=wallet", "_blank");
    }}
        ></wui-list-wallet>
      </wui-flex>
    `;
  }
  recommendedWalletsTemplate() {
    const { recommended, featured } = ApiController.state;
    const { customWallets } = OptionsController.state;
    const wallets2 = [...featured, ...customWallets ?? [], ...recommended].slice(0, 4);
    return wallets2.map((wallet) => x$3`
        <wui-list-wallet
          name=${wallet.name ?? "Unknown"}
          tagVariant="main"
          imageSrc=${o$4(AssetUtil.getWalletImage(wallet))}
          @click=${() => {
      CoreHelperUtil.openHref(wallet.homepage ?? EXPLORER, "_blank");
    }}
        ></wui-list-wallet>
      `);
  }
};
W3mGetWalletView = __decorate$s([
  customElement("w3m-get-wallet-view")
], W3mGetWalletView);
const styles$g = i$7`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;
var __decorate$r = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mNetworkSwitchView = class W3mNetworkSwitchView2 extends s$3 {
  constructor() {
    super();
    this.network = RouterController.state.data?.network;
    this.unsubscribe = [];
    this.showRetry = false;
    this.error = false;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    this.onSwitchNetwork();
  }
  render() {
    if (!this.network) {
      throw new Error("w3m-network-switch-view: No network provided");
    }
    this.onShowRetry();
    const label = this.error ? "Switch declined" : "Approve in wallet";
    const subLabel = this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
    return x$3`
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${o$4(AssetUtil.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error ? null : x$3`<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${true}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${label}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="fill"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `;
  }
  onShowRetry() {
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = this.shadowRoot?.querySelector("wui-button");
      retryButton?.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onSwitchNetwork() {
    try {
      this.error = false;
      if (this.network) {
        await NetworkController.switchActiveNetwork(this.network);
        if (!SIWEController.state.isSiweEnabled) {
          RouterUtil.navigateAfterNetworkSwitch();
        }
      }
    } catch {
      this.error = true;
    }
  }
};
W3mNetworkSwitchView.styles = styles$g;
__decorate$r([
  r$4()
], W3mNetworkSwitchView.prototype, "showRetry", void 0);
__decorate$r([
  r$4()
], W3mNetworkSwitchView.prototype, "error", void 0);
W3mNetworkSwitchView = __decorate$r([
  customElement("w3m-network-switch-view")
], W3mNetworkSwitchView);
const styles$f = i$7`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$q = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mNetworksView = class W3mNetworksView2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.caipNetwork = NetworkController.state.caipNetwork;
    this.unsubscribe.push(NetworkController.subscribeKey("caipNetwork", (val) => this.caipNetwork = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`
      <wui-grid padding="s" gridTemplateColumns="repeat(4, 1fr)" rowGap="l" columnGap="xs">
        ${this.networksTemplate()}
      </wui-grid>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-400" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `;
  }
  onNetworkHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_NETWORK_HELP" });
    RouterController.push("WhatIsANetwork");
  }
  networksTemplate() {
    const { approvedCaipNetworkIds, requestedCaipNetworks, supportsAllNetworks } = NetworkController.state;
    const approvedIds = approvedCaipNetworkIds;
    const requestedNetworks = requestedCaipNetworks;
    const approvedIndexMap = {};
    if (requestedNetworks && approvedIds) {
      approvedIds.forEach((id2, index2) => {
        approvedIndexMap[id2] = index2;
      });
      requestedNetworks.sort((a3, b4) => {
        const indexA = approvedIndexMap[a3.id];
        const indexB = approvedIndexMap[b4.id];
        if (indexA !== void 0 && indexB !== void 0) {
          return indexA - indexB;
        } else if (indexA !== void 0) {
          return -1;
        } else if (indexB !== void 0) {
          return 1;
        }
        return 0;
      });
    }
    return requestedNetworks?.map((network) => x$3`
        <wui-card-select
          .selected=${this.caipNetwork?.id === network.id}
          imageSrc=${o$4(AssetUtil.getNetworkImage(network))}
          type="network"
          name=${network.name ?? network.id}
          @click=${() => this.onSwitchNetwork(network)}
          .disabled=${!supportsAllNetworks && !approvedIds?.includes(network.id)}
          data-testid=${`w3m-network-switch-${network.name ?? network.id}`}
        ></wui-card-select>
      `);
  }
  async onSwitchNetwork(network) {
    const { isConnected } = AccountController.state;
    const { approvedCaipNetworkIds, supportsAllNetworks, caipNetwork } = NetworkController.state;
    const { data: data2 } = RouterController.state;
    if (isConnected && caipNetwork?.id !== network.id) {
      if (approvedCaipNetworkIds?.includes(network.id)) {
        await NetworkController.switchActiveNetwork(network);
        RouterUtil.navigateAfterNetworkSwitch();
      } else if (supportsAllNetworks) {
        RouterController.push("SwitchNetwork", { ...data2, network });
      }
    } else if (!isConnected) {
      NetworkController.setCaipNetwork(network);
      RouterController.push("Connect");
    }
  }
};
W3mNetworksView.styles = styles$f;
__decorate$q([
  r$4()
], W3mNetworksView.prototype, "caipNetwork", void 0);
W3mNetworksView = __decorate$q([
  customElement("w3m-networks-view")
], W3mNetworksView);
const styles$e = i$7`
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }
`;
var __decorate$p = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const PAGINATOR_ID$1 = "last-transaction";
const LOADING_ITEM_COUNT = 7;
let W3mTransactionsView = class W3mTransactionsView2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.address = AccountController.state.address;
    this.transactions = TransactionsController.state.transactions;
    this.transactionsByYear = TransactionsController.state.transactionsByYear;
    this.loading = TransactionsController.state.loading;
    this.empty = TransactionsController.state.empty;
    this.next = TransactionsController.state.next;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.isConnected) {
          if (this.address !== val.address) {
            this.address = val.address;
            TransactionsController.resetTransactions();
            TransactionsController.fetchTransactions(val.address);
          }
        }
      }),
      TransactionsController.subscribe((val) => {
        this.transactions = val.transactions;
        this.transactionsByYear = val.transactionsByYear;
        this.loading = val.loading;
        this.empty = val.empty;
        this.next = val.next;
      })
    ]);
  }
  firstUpdated() {
    if (this.transactions.length === 0) {
      TransactionsController.fetchTransactions(this.address);
    }
    this.createPaginationObserver();
  }
  updated() {
    this.setPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`
      <wui-flex flexDirection="column" padding="s" gap="s">
        ${this.empty ? null : this.templateTransactionsByYear()}
        ${this.loading ? this.templateLoading() : null}
        ${!this.loading && this.empty ? this.templateEmpty() : null}
      </wui-flex>
    `;
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.transactionsByYear).sort().reverse();
    return sortedYearKeys.map((year, index2) => {
      const isLastGroup = index2 === sortedYearKeys.length - 1;
      const yearInt = parseInt(year, 10);
      const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt);
      const transactions = this.transactionsByYear[yearInt];
      if (!transactions) {
        return null;
      }
      return x$3`
        <wui-flex flexDirection="column" gap="s">
          <wui-flex
            alignItems="center"
            flexDirection="row"
            .padding=${["xs", "s", "s", "s"]}
          >
            <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
          </wui-flex>
          <wui-flex flexDirection="column" gap="xs">
            ${this.templateTransactions(transactions, isLastGroup)}
          </wui-flex>
        </wui-flex>
      `;
    });
  }
  templateRenderTransaction(transaction, isLastTransaction) {
    const { date: date2, descriptions, direction, isAllNFT, images, status, transfers, type: type2 } = this.getTransactionListItemProps(transaction);
    const haveMultipleTransfers = transfers?.length > 1;
    const haveTwoTransfers = transfers?.length === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return x$3`
        <wui-transaction-list-item
          date=${date2}
          .direction=${direction}
          id=${isLastTransaction && this.next ? PAGINATOR_ID$1 : ""}
          status=${status}
          type=${type2}
          .images=${images}
          .descriptions=${descriptions}
        ></wui-transaction-list-item>
      `;
    }
    if (haveMultipleTransfers) {
      return transfers.map((transfer, index2) => {
        const description = TransactionUtil.getTransferDescription(transfer);
        const isLastTransfer = isLastTransaction && index2 === transfers.length - 1;
        return x$3` <wui-transaction-list-item
          date=${date2}
          direction=${transfer.direction}
          id=${isLastTransfer && this.next ? PAGINATOR_ID$1 : ""}
          status=${status}
          type=${type2}
          .onlyDirectionIcon=${true}
          .images=${[images?.[index2]]}
          .descriptions=${[description]}
        ></wui-transaction-list-item>`;
      });
    }
    return x$3`
      <wui-transaction-list-item
        date=${date2}
        .direction=${direction}
        id=${isLastTransaction && this.next ? PAGINATOR_ID$1 : ""}
        status=${status}
        type=${type2}
        .images=${images}
        .descriptions=${descriptions}
      ></wui-transaction-list-item>
    `;
  }
  templateTransactions(transactions, isLastGroup) {
    return transactions.map((transaction, index2) => {
      const isLastTransaction = isLastGroup && index2 === transactions.length - 1;
      return x$3`${this.templateRenderTransaction(transaction, isLastTransaction)}`;
    });
  }
  templateEmpty() {
    return x$3`
      <wui-flex
        flexGrow="1"
        flexDirection="column"
        justifyContent="center"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-icon-box
          backgroundColor="glass-005"
          background="gray"
          iconColor="fg-200"
          icon="wallet"
          size="lg"
          ?border=${true}
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100"
            >No Transactions yet</wui-text
          >
          <wui-text align="center" variant="small-500" color="fg-200"
            >Start trading on dApps <br />
            to grow your wallet!</wui-text
          >
        </wui-flex>
      </wui-flex>
    `;
  }
  templateLoading() {
    return Array(LOADING_ITEM_COUNT).fill(x$3` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((item) => item);
  }
  createPaginationObserver() {
    const { projectId } = OptionsController.state;
    this.paginationObserver = new IntersectionObserver(([element]) => {
      if (element?.isIntersecting && !this.loading) {
        TransactionsController.fetchTransactions(this.address);
        EventsController.sendEvent({
          type: "track",
          event: "LOAD_MORE_TRANSACTIONS",
          properties: {
            address: this.address,
            projectId,
            cursor: this.next
          }
        });
      }
    }, {});
    this.setPaginationObserver();
  }
  setPaginationObserver() {
    this.paginationObserver?.disconnect();
    const lastItem = this.shadowRoot?.querySelector(`#${PAGINATOR_ID$1}`);
    if (lastItem) {
      this.paginationObserver?.observe(lastItem);
    }
  }
  getTransactionListItemProps(transaction) {
    const date2 = DateUtil.getRelativeDateFromNow(transaction?.metadata?.minedAt);
    const descriptions = TransactionUtil.getTransactionDescriptions(transaction);
    const transfers = transaction?.transfers;
    const transfer = transaction?.transfers?.[0];
    const isAllNFT = Boolean(transfer) && transaction?.transfers?.every((item) => Boolean(item.nft_info));
    const images = TransactionUtil.getTransactionImages(transfers);
    return {
      date: date2,
      direction: transfer?.direction,
      descriptions,
      isAllNFT,
      images,
      status: transaction.metadata?.status,
      transfers,
      type: transaction.metadata?.operationType
    };
  }
};
W3mTransactionsView.styles = styles$e;
__decorate$p([
  r$4()
], W3mTransactionsView.prototype, "address", void 0);
__decorate$p([
  r$4()
], W3mTransactionsView.prototype, "transactions", void 0);
__decorate$p([
  r$4()
], W3mTransactionsView.prototype, "transactionsByYear", void 0);
__decorate$p([
  r$4()
], W3mTransactionsView.prototype, "loading", void 0);
__decorate$p([
  r$4()
], W3mTransactionsView.prototype, "empty", void 0);
__decorate$p([
  r$4()
], W3mTransactionsView.prototype, "next", void 0);
W3mTransactionsView = __decorate$p([
  customElement("w3m-transactions-view")
], W3mTransactionsView);
var __decorate$o = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const data$1 = [
  {
    images: ["network", "layers", "system"],
    title: "The system’s nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
  },
  {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
  }
];
let W3mWhatIsANetworkView = class W3mWhatIsANetworkView2 extends s$3 {
  render() {
    return x$3`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data$1}></w3m-help-widget>
        <wui-button
          variant="fill"
          size="sm"
          @click=${() => {
      CoreHelperUtil.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
  }
};
W3mWhatIsANetworkView = __decorate$o([
  customElement("w3m-what-is-a-network-view")
], W3mWhatIsANetworkView);
var __decorate$n = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const data = [
  {
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
  },
  {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
  },
  {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
  }
];
let W3mWhatIsAWalletView = class W3mWhatIsAWalletView2 extends s$3 {
  render() {
    return x$3`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data}></w3m-help-widget>
        <wui-button variant="fill" size="sm" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a wallet
        </wui-button>
      </wui-flex>
    `;
  }
  onGetWallet() {
    EventsController.sendEvent({ type: "track", event: "CLICK_GET_WALLET" });
    RouterController.push("GetWallet");
  }
};
W3mWhatIsAWalletView = __decorate$n([
  customElement("w3m-what-is-a-wallet-view")
], W3mWhatIsAWalletView);
const styles$d = i$7`
  wui-loading-spinner {
    margin: 9px auto;
  }
`;
const W3mFrameConstants = {
  SECURE_SITE_SDK: "https://secure.web3modal.com/sdk",
  APP_EVENT_KEY: "@w3m-app/",
  FRAME_EVENT_KEY: "@w3m-frame/",
  RPC_METHOD_KEY: "RPC_",
  STORAGE_KEY: "@w3m-storage/",
  SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
  EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
  LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
  LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
  EMAIL: "EMAIL",
  APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
  APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
  APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
  APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
  APP_GET_USER: "@w3m-app/GET_USER",
  APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
  APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
  APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
  APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
  APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
  APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
  APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
  APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
  FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
  FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
  FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
  FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
  FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
  FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
  FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
  FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
  FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
  FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
  FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
  FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
  FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
  FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
  FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
  FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
  FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
  FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
  FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
  FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
  FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
  FRAME_AWAIT_UPDATE_EMAIL_SUCCESS: "@w3m-frame/AWAIT_UPDATE_EMAIL_SUCCESS",
  FRAME_AWAIT_UPDATE_EMAIL_ERROR: "@w3m-frame/AWAIT_UPDATE_EMAIL_ERROR",
  FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
  FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
  FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
  FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR"
};
var util$c;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k3) => typeof obj[obj[k3]] !== "number");
    const filtered = {};
    for (const k3 of validKeys) {
      filtered[k3] = obj[k3];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys2 = [];
    for (const key2 in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key2)) {
        keys2.push(key2);
      }
    }
    return keys2;
  };
  util2.find = (arr2, checker) => {
    for (const item of arr2) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_3, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$c || (util$c = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return {
      ...first2,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$c.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data2) => {
  const t2 = typeof data2;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data2)) {
        return ZodParsedType.array;
      }
      if (data2 === null) {
        return ZodParsedType.null;
      }
      if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data2 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data2 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data2 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util$c.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i3 = 0;
          while (i3 < issue.path.length) {
            const el2 = issue.path[i3];
            const terminal = i3 === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i3++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$c.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$c.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$c.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$c.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$c.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$c.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$c.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data: data2, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data: data2, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s3 of results) {
      if (s3.status === "aborted")
        return INVALID;
      if (s3.status === "dirty")
        status.dirty();
      arrayValue.push(s3.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key: key2, value } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key2.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path, key2) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key2;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data2, params) {
    const result = this.safeParse(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data2, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data2, params) {
    const result = await this.safeParseAsync(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data2, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data2) => {
          if (!data2) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex2 = datetimeRegex(check2);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util$c.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data2) => regex2.test(data2), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len2, message) {
    return this._addCheck({
      kind: "length",
      value: len2,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get minLength() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util$c.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util$c.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util$c.isInteger(ch2.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      } else if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util$c.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$c.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i3) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i3) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len2, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len2, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util$c.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key2 in ctx.data) {
        if (!shapeKeys.includes(key2)) {
          extraKeys.push(key2);
        }
      }
    }
    const pairs2 = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape[key2];
      const value = ctx.data[key2];
      pairs2.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value = ctx.data[key2];
        pairs2.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key2)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key2 = await pair.key;
          syncPairs.push({
            key: key2,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b, _c, _d;
          const defaultError = (_c = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask2) {
    const shape = {};
    util$c.objectKeys(mask2).forEach((key2) => {
      if (mask2[key2] && this.shape[key2]) {
        shape[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask2) {
    const shape = {};
    util$c.objectKeys(this.shape).forEach((key2) => {
      if (!mask2[key2]) {
        shape[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask2) {
    const newShape = {};
    util$c.objectKeys(this.shape).forEach((key2) => {
      const fieldSchema = this.shape[key2];
      if (mask2 && !mask2[key2]) {
        newShape[key2] = fieldSchema;
      } else {
        newShape[key2] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask2) {
    const newShape = {};
    util$c.objectKeys(this.shape).forEach((key2) => {
      if (mask2 && !mask2[key2]) {
        newShape[key2] = this.shape[key2];
      } else {
        const fieldSchema = this.shape[key2];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key2] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util$c.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return Object.keys(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [void 0];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type2 of options) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type2);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a3, b4) {
  const aType = getParsedType(a3);
  const bType = getParsedType(b4);
  if (a3 === b4) {
    return { valid: true, data: a3 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util$c.objectKeys(b4);
    const sharedKeys = util$c.objectKeys(a3).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a3, ...b4 };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a3[key2], b4[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a3.length !== b4.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a3.length; index2++) {
      const itemA = a3[index2];
      const itemB = b4[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a3 === +b4) {
    return { valid: true, data: a3 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first2, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first2,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first2,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key2, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key2 = await pair.key;
          const value = await pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key2 = pair.key;
        const value = pair.value;
        if (key2.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  strictImplement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util$c.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util$c.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util$c.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util$c.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util$c.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data2) => {
      return this._def.type.parseAsync(data2, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base3 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base3))
          return base3;
        const result = effect.transform(base3.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
          if (!isValid(base3))
            return base3;
          return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$c.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data2 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data2 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data2 = ctx.data;
    return this._def.type._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a3, b4) {
    return new ZodPipeline({
      in: a3,
      out: b4,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
const custom = (check2, params = {}, fatal) => {
  if (check2)
    return ZodAny.create().superRefine((data2, ctx) => {
      var _a2, _b;
      if (!check2(data2)) {
        const p3 = typeof params === "function" ? params(data2) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a2 = p3.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p3 === "string" ? { message: p3 } : p3;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data2) => data2 instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce$6 = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER$1 = INVALID;
var z$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util$c;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce: coerce$6,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER: NEVER$1,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const zError = z$6.object({ message: z$6.string() });
function zType(key2) {
  return z$6.literal(W3mFrameConstants[key2]);
}
z$6.object({
  accessList: z$6.array(z$6.string()),
  blockHash: z$6.string().nullable(),
  blockNumber: z$6.string().nullable(),
  chainId: z$6.string(),
  from: z$6.string(),
  gas: z$6.string(),
  hash: z$6.string(),
  input: z$6.string().nullable(),
  maxFeePerGas: z$6.string(),
  maxPriorityFeePerGas: z$6.string(),
  nonce: z$6.string(),
  r: z$6.string(),
  s: z$6.string(),
  to: z$6.string(),
  transactionIndex: z$6.string().nullable(),
  type: z$6.string(),
  v: z$6.string(),
  value: z$6.string()
});
const AppSwitchNetworkRequest = z$6.object({ chainId: z$6.number() });
const AppConnectEmailRequest = z$6.object({ email: z$6.string().email() });
const AppConnectOtpRequest = z$6.object({ otp: z$6.string() });
const AppGetUserRequest = z$6.object({ chainId: z$6.optional(z$6.number()) });
const AppUpdateEmailRequest = z$6.object({ email: z$6.string().email() });
const AppSyncThemeRequest = z$6.object({
  themeMode: z$6.optional(z$6.enum(["light", "dark"])),
  themeVariables: z$6.optional(z$6.record(z$6.string(), z$6.string().or(z$6.number())))
});
const AppSyncDappDataRequest = z$6.object({
  metadata: z$6.object({
    name: z$6.string(),
    description: z$6.string(),
    url: z$6.string(),
    icons: z$6.array(z$6.string())
  }).optional(),
  sdkVersion: z$6.string(),
  projectId: z$6.string()
});
const FrameConnectEmailResponse = z$6.object({
  action: z$6.enum(["VERIFY_DEVICE", "VERIFY_OTP"])
});
const FrameGetUserResponse = z$6.object({
  email: z$6.string().email(),
  address: z$6.string(),
  chainId: z$6.number()
});
const FrameIsConnectedResponse = z$6.object({ isConnected: z$6.boolean() });
const FrameGetChainIdResponse = z$6.object({ chainId: z$6.number() });
const FrameSwitchNetworkResponse = z$6.object({ chainId: z$6.number() });
const FrameAwaitUpdateEmailResponse = z$6.object({ email: z$6.string().email() });
const RpcResponse = z$6.any();
const RpcPersonalSignRequest = z$6.object({
  method: z$6.literal("personal_sign"),
  params: z$6.array(z$6.any())
});
const RpcEthSendTransactionRequest = z$6.object({
  method: z$6.literal("eth_sendTransaction"),
  params: z$6.array(z$6.any())
});
const RpcEthAccountsRequest = z$6.object({
  method: z$6.literal("eth_accounts")
});
const RpcGetBalance = z$6.object({
  method: z$6.literal("eth_getBalance"),
  params: z$6.array(z$6.any())
});
const RpcEthEstimateGas = z$6.object({
  method: z$6.literal("eth_estimateGas"),
  params: z$6.array(z$6.any())
});
const RpcEthGasPrice = z$6.object({
  method: z$6.literal("eth_gasPrice")
});
const RpcEthSignTypedDataV4 = z$6.object({
  method: z$6.literal("eth_signTypedData_v4"),
  params: z$6.array(z$6.any())
});
const RpcEthGetTransactionByHash = z$6.object({
  method: z$6.literal("eth_getTransactionByHash"),
  params: z$6.array(z$6.any())
});
const RpcEthBlockNumber = z$6.object({
  method: z$6.literal("eth_blockNumber")
});
const RpcEthChainId = z$6.object({
  method: z$6.literal("eth_chainId")
});
const FrameSession = z$6.object({
  token: z$6.string()
});
({
  appEvent: z$6.object({ type: zType("APP_SWITCH_NETWORK"), payload: AppSwitchNetworkRequest }).or(z$6.object({ type: zType("APP_CONNECT_EMAIL"), payload: AppConnectEmailRequest })).or(z$6.object({ type: zType("APP_CONNECT_DEVICE") })).or(z$6.object({ type: zType("APP_CONNECT_OTP"), payload: AppConnectOtpRequest })).or(z$6.object({ type: zType("APP_GET_USER"), payload: z$6.optional(AppGetUserRequest) })).or(z$6.object({ type: zType("APP_SIGN_OUT") })).or(z$6.object({ type: zType("APP_IS_CONNECTED"), payload: z$6.optional(FrameSession) })).or(z$6.object({ type: zType("APP_GET_CHAIN_ID") })).or(z$6.object({
    type: zType("APP_RPC_REQUEST"),
    payload: RpcPersonalSignRequest.or(RpcEthSendTransactionRequest).or(RpcEthAccountsRequest).or(RpcGetBalance).or(RpcEthEstimateGas).or(RpcEthGasPrice).or(RpcEthSignTypedDataV4).or(RpcEthBlockNumber).or(RpcEthChainId).or(RpcEthGetTransactionByHash)
  })).or(z$6.object({ type: zType("APP_UPDATE_EMAIL"), payload: AppUpdateEmailRequest })).or(z$6.object({ type: zType("APP_AWAIT_UPDATE_EMAIL") })).or(z$6.object({ type: zType("APP_SYNC_THEME"), payload: AppSyncThemeRequest })).or(z$6.object({ type: zType("APP_SYNC_DAPP_DATA"), payload: AppSyncDappDataRequest })),
  frameEvent: z$6.object({ type: zType("FRAME_SWITCH_NETWORK_ERROR"), payload: zError }).or(z$6.object({ type: zType("FRAME_SWITCH_NETWORK_SUCCESS"), payload: FrameSwitchNetworkResponse })).or(z$6.object({ type: zType("FRAME_CONNECT_EMAIL_ERROR"), payload: zError })).or(z$6.object({ type: zType("FRAME_CONNECT_EMAIL_SUCCESS"), payload: FrameConnectEmailResponse })).or(z$6.object({ type: zType("FRAME_CONNECT_OTP_ERROR"), payload: zError })).or(z$6.object({ type: zType("FRAME_CONNECT_OTP_SUCCESS") })).or(z$6.object({ type: zType("FRAME_CONNECT_DEVICE_ERROR"), payload: zError })).or(z$6.object({ type: zType("FRAME_CONNECT_DEVICE_SUCCESS") })).or(z$6.object({ type: zType("FRAME_GET_USER_ERROR"), payload: zError })).or(z$6.object({ type: zType("FRAME_GET_USER_SUCCESS"), payload: FrameGetUserResponse })).or(z$6.object({ type: zType("FRAME_SIGN_OUT_ERROR"), payload: zError })).or(z$6.object({ type: zType("FRAME_SIGN_OUT_SUCCESS") })).or(z$6.object({ type: zType("FRAME_IS_CONNECTED_ERROR"), payload: zError })).or(z$6.object({ type: zType("FRAME_IS_CONNECTED_SUCCESS"), payload: FrameIsConnectedResponse })).or(z$6.object({ type: zType("FRAME_GET_CHAIN_ID_ERROR"), payload: zError })).or(z$6.object({ type: zType("FRAME_GET_CHAIN_ID_SUCCESS"), payload: FrameGetChainIdResponse })).or(z$6.object({ type: zType("FRAME_RPC_REQUEST_ERROR"), payload: zError })).or(z$6.object({ type: zType("FRAME_RPC_REQUEST_SUCCESS"), payload: RpcResponse })).or(z$6.object({ type: zType("FRAME_SESSION_UPDATE"), payload: FrameSession })).or(z$6.object({ type: zType("FRAME_UPDATE_EMAIL_ERROR"), payload: zError })).or(z$6.object({ type: zType("FRAME_UPDATE_EMAIL_SUCCESS") })).or(z$6.object({ type: zType("FRAME_AWAIT_UPDATE_EMAIL_ERROR"), payload: zError })).or(z$6.object({
    type: zType("FRAME_AWAIT_UPDATE_EMAIL_SUCCESS"),
    payload: FrameAwaitUpdateEmailResponse
  })).or(z$6.object({ type: zType("FRAME_SYNC_THEME_ERROR"), payload: zError })).or(z$6.object({ type: zType("FRAME_SYNC_THEME_SUCCESS") })).or(z$6.object({ type: zType("FRAME_SYNC_DAPP_DATA_ERROR"), payload: zError })).or(z$6.object({ type: zType("FRAME_SYNC_DAPP_DATA_SUCCESS") }))
});
const W3mFrameStorage = {
  set(key2, value) {
    localStorage.setItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`, value);
  },
  get(key2) {
    return localStorage.getItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`);
  },
  delete(key2) {
    localStorage.removeItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`);
  }
};
const RESTRICTED_TIMEZONES = [
  "ASIA/SHANGHAI",
  "ASIA/URUMQI",
  "ASIA/CHONGQING",
  "ASIA/HARBIN",
  "ASIA/KASHGAR",
  "ASIA/MACAU",
  "ASIA/HONG_KONG",
  "ASIA/MACAO",
  "ASIA/BEIJING",
  "ASIA/HARBIN"
];
const EMAIL_MINIMUM_TIMEOUT = 30 * 1e3;
const W3mFrameHelpers = {
  getBlockchainApiUrl() {
    try {
      const { timeZone } = new Intl.DateTimeFormat().resolvedOptions();
      const capTimeZone = timeZone.toUpperCase();
      return RESTRICTED_TIMEZONES.includes(capTimeZone) ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com";
    } catch {
      return false;
    }
  },
  checkIfAllowedToTriggerEmail() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        const cooldownSec = Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
        throw new Error(`Please try again after ${cooldownSec} seconds`);
      }
    }
  },
  getTimeToNextEmailLogin() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        return Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
      }
    }
    return 0;
  }
};
var __decorate$m = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const OTP_LENGTH = 6;
let W3mEmailVerifyOtpView = class W3mEmailVerifyOtpView2 extends s$3 {
  constructor() {
    super(...arguments);
    this.email = RouterController.state.data?.email;
    this.emailConnector = ConnectorController.getEmailConnector();
    this.loading = false;
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.error = "";
    this.otp = "";
  }
  firstUpdated() {
    this.startOTPTimeout();
  }
  disconnectedCallback() {
    clearTimeout(this.OTPTimeout);
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-verify-otp-view: No email provided");
    }
    const isResendDisabled = Boolean(this.timeoutTimeLeft);
    return x$3`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["l", "0", "l", "0"]}
        gap="l"
      >
        <wui-flex flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100"> Enter the code we sent to </wui-text>
          <wui-text variant="paragraph-500" color="fg-100">${this.email}</wui-text>
        </wui-flex>

        <wui-text variant="small-400" color="fg-200">The code expires in 20 minutes</wui-text>

        ${this.loading ? x$3`<wui-loading-spinner size="xl" color="accent-100"></wui-loading-spinner>` : x$3` <wui-flex flexDirection="column" alignItems="center" gap="xs">
              <wui-otp
                dissabled
                length="6"
                @inputChange=${this.onOtpInputChange.bind(this)}
                .otp=${this.otp}
              ></wui-otp>
              ${this.error ? x$3`<wui-text variant="small-400" color="error-100"
                    >${this.error}. Try Again</wui-text
                  >` : null}
            </wui-flex>`}

        <wui-flex alignItems="center">
          <wui-text variant="small-400" color="fg-200">Didn't receive it?</wui-text>
          <wui-link @click=${this.onResendCode.bind(this)} .disabled=${isResendDisabled}>
            Resend ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : "Code"}
          </wui-link>
        </wui-flex>
      </wui-flex>
    `;
  }
  startOTPTimeout() {
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.OTPTimeout = setInterval(() => {
      if (this.timeoutTimeLeft > 0) {
        this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
      } else {
        clearInterval(this.OTPTimeout);
      }
    }, 1e3);
  }
  async onOtpInputChange(event) {
    try {
      if (!this.loading) {
        this.otp = event.detail;
        if (this.emailConnector && this.otp.length === OTP_LENGTH) {
          this.loading = true;
          await this.emailConnector.provider.connectOtp({ otp: this.otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          await ConnectionController.connectExternal(this.emailConnector);
          ModalController.close();
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "email" }
          });
        }
      }
    } catch (error) {
      EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
      this.error = CoreHelperUtil.parseError(error);
      this.loading = false;
    }
  }
  async onResendCode() {
    try {
      if (!this.loading && !this.timeoutTimeLeft) {
        this.error = "";
        this.otp = "";
        const emailConnector = ConnectorController.getEmailConnector();
        if (!emailConnector || !this.email) {
          throw new Error("w3m-email-login-widget: Unable to resend email");
        }
        this.loading = true;
        await emailConnector.provider.connectEmail({ email: this.email });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        this.startOTPTimeout();
        SnackController.showSuccess("Code email resent");
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
};
W3mEmailVerifyOtpView.styles = styles$d;
__decorate$m([
  r$4()
], W3mEmailVerifyOtpView.prototype, "loading", void 0);
__decorate$m([
  r$4()
], W3mEmailVerifyOtpView.prototype, "timeoutTimeLeft", void 0);
__decorate$m([
  r$4()
], W3mEmailVerifyOtpView.prototype, "error", void 0);
W3mEmailVerifyOtpView = __decorate$m([
  customElement("w3m-email-verify-otp-view")
], W3mEmailVerifyOtpView);
const styles$c = i$7`
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var __decorate$l = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mEmailVerifyDeviceView = class W3mEmailVerifyDeviceView2 extends s$3 {
  constructor() {
    super();
    this.email = RouterController.state.data?.email;
    this.emailConnector = ConnectorController.getEmailConnector();
    this.loading = false;
    this.listenForDeviceApproval();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-verify-device-view: No email provided");
    }
    if (!this.emailConnector) {
      throw new Error("w3m-email-verify-device-view: No email connector provided");
    }
    return x$3`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="verify"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve the login link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            The code expires in 20 minutes
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  async listenForDeviceApproval() {
    if (this.emailConnector) {
      await this.emailConnector.provider.connectDevice();
      EventsController.sendEvent({ type: "track", event: "DEVICE_REGISTERED_FOR_EMAIL" });
      EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
      RouterController.replace("EmailVerifyOtp", { email: this.email });
    }
  }
  async onResendCode() {
    try {
      if (!this.loading) {
        if (!this.emailConnector || !this.email) {
          throw new Error("w3m-email-login-widget: Unable to resend email");
        }
        this.loading = true;
        await this.emailConnector.provider.connectEmail({ email: this.email });
        SnackController.showSuccess("Code email resent");
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
};
W3mEmailVerifyDeviceView.styles = styles$c;
__decorate$l([
  r$4()
], W3mEmailVerifyDeviceView.prototype, "loading", void 0);
W3mEmailVerifyDeviceView = __decorate$l([
  customElement("w3m-email-verify-device-view")
], W3mEmailVerifyDeviceView);
const styles$b = i$7`
  div {
    width: 100%;
    height: 400px;
  }

  [data-ready='false'] {
    transform: scale(1.05);
  }

  @media (max-width: 430px) {
    [data-ready='false'] {
      transform: translateY(-50px);
    }
  }
`;
var __decorate$k = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mApproveTransactionView = class W3mApproveTransactionView2 extends s$3 {
  constructor() {
    super();
    this.bodyObserver = void 0;
    this.unsubscribe = [];
    this.iframe = document.getElementById("w3m-iframe");
    this.ready = false;
    this.unsubscribe.push(ModalController.subscribeKey("open", (val) => {
      if (!val) {
        this.onHideIframe();
      }
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    this.bodyObserver?.unobserve(window.document.body);
  }
  firstUpdated() {
    const verticalPadding = 10;
    this.iframe.style.display = "block";
    const blueprint = this.renderRoot.querySelector("div");
    this.bodyObserver = new ResizeObserver(() => {
      const data2 = blueprint?.getBoundingClientRect();
      const dimensions = data2 ?? { left: 0, top: 0, width: 0, height: 0 };
      this.iframe.style.width = `${dimensions.width}px`;
      this.iframe.style.height = `${dimensions.height - verticalPadding}px`;
      this.iframe.style.left = `${dimensions.left}px`;
      this.iframe.style.top = `${dimensions.top + verticalPadding / 2}px`;
      this.ready = true;
    });
    this.bodyObserver.observe(window.document.body);
  }
  render() {
    if (this.ready) {
      this.onShowIframe();
    }
    return x$3`<div data-ready=${this.ready}></div>`;
  }
  onShowIframe() {
    const isMobile = window.innerWidth <= 430;
    this.iframe.animate([
      { opacity: 0, transform: isMobile ? "translateY(50px)" : "scale(.95)" },
      { opacity: 1, transform: isMobile ? "translateY(0)" : "scale(1)" }
    ], { duration: 200, easing: "ease", fill: "forwards", delay: 300 });
  }
  async onHideIframe() {
    await this.iframe.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards"
    }).finished;
    this.iframe.style.display = "none";
  }
};
W3mApproveTransactionView.styles = styles$b;
__decorate$k([
  r$4()
], W3mApproveTransactionView.prototype, "ready", void 0);
W3mApproveTransactionView = __decorate$k([
  customElement("w3m-approve-transaction-view")
], W3mApproveTransactionView);
var __decorate$j = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUpgradeWalletView = class W3mUpgradeWalletView2 extends s$3 {
  render() {
    return x$3`
      <wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
        <wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</wui-text>
        <wui-chip
          icon="externalLink"
          variant="fill"
          href=${ConstantsUtil$1.SECURE_SITE_DASHBOARD}
          imageSrc=${ConstantsUtil$1.SECURE_SITE_FAVICON}
        >
        </wui-chip>
        <wui-text variant="small-400" color="fg-200">
          You will have to reconnect for security reasons
        </wui-text>
      </wui-flex>
    `;
  }
};
W3mUpgradeWalletView = __decorate$j([
  customElement("w3m-upgrade-wallet-view")
], W3mUpgradeWalletView);
const styles$a = i$7`
  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }
`;
var __decorate$i = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUpdateEmailWalletView = class W3mUpdateEmailWalletView2 extends s$3 {
  constructor() {
    super(...arguments);
    this.formRef = e$2();
    this.initialValue = RouterController.state.data?.email ?? "";
    this.email = "";
    this.loading = false;
  }
  firstUpdated() {
    this.formRef.value?.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    const showSubmit = !this.loading && this.email.length > 3 && this.email !== this.initialValue;
    return x$3`
      <wui-flex flexDirection="column" padding="m" gap="m">
        <form ${n$2(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
          <wui-email-input
            value=${this.initialValue}
            .disabled=${this.loading}
            @inputChange=${this.onEmailInputChange.bind(this)}
          >
          </wui-email-input>
          <input type="submit" hidden />
        </form>

        <wui-flex gap="s">
          <wui-button size="md" variant="shade" fullWidth @click=${RouterController.goBack}>
            Cancel
          </wui-button>

          <wui-button
            size="md"
            variant="fill"
            fullWidth
            @click=${this.onSubmitEmail.bind(this)}
            .disabled=${!showSubmit}
            .loading=${this.loading}
          >
            Save
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  onEmailInputChange(event) {
    this.email = event.detail;
  }
  async onSubmitEmail(event) {
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const emailConnector = ConnectorController.getEmailConnector();
      if (!emailConnector) {
        throw new Error("w3m-update-email-wallet: Email connector not found");
      }
      await emailConnector.provider.updateEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_EDIT" });
      RouterController.replace("UpdateEmailWalletWaiting", { email: this.email });
    } catch (error) {
      SnackController.showError(error);
      this.loading = false;
    }
  }
};
W3mUpdateEmailWalletView.styles = styles$a;
__decorate$i([
  r$4()
], W3mUpdateEmailWalletView.prototype, "email", void 0);
__decorate$i([
  r$4()
], W3mUpdateEmailWalletView.prototype, "loading", void 0);
W3mUpdateEmailWalletView = __decorate$i([
  customElement("w3m-update-email-wallet-view")
], W3mUpdateEmailWalletView);
const styles$9 = i$7`
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var __decorate$h = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUpdateEmailWalletWaitingView = class W3mUpdateEmailWalletWaitingView2 extends s$3 {
  constructor() {
    super();
    this.email = RouterController.state.data?.email;
    this.emailConnector = ConnectorController.getEmailConnector();
    this.loading = false;
    this.listenForEmailUpdateApproval();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-update-email-wallet-waiting-view: No email provided");
    }
    if (!this.emailConnector) {
      throw new Error("w3m-update-email-wallet-waiting-view: No email connector provided");
    }
    return x$3`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="mail"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve verification link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100">${this.email}</wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            You will receive an approval request on your former mail to confirm the new one
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  async listenForEmailUpdateApproval() {
    if (this.emailConnector) {
      await this.emailConnector.provider.awaitUpdateEmail();
      RouterController.replace("Account");
      SnackController.showSuccess("Email updated");
    }
  }
  async onResendCode() {
    try {
      if (!this.loading) {
        if (!this.emailConnector || !this.email) {
          throw new Error("w3m-update-email-wallet-waiting-view: Unable to resend email");
        }
        this.loading = true;
        await this.emailConnector.provider.updateEmail({ email: this.email });
        this.listenForEmailUpdateApproval();
        SnackController.showSuccess("Code email resent");
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
};
W3mUpdateEmailWalletWaitingView.styles = styles$9;
__decorate$h([
  r$4()
], W3mUpdateEmailWalletWaitingView.prototype, "loading", void 0);
W3mUpdateEmailWalletWaitingView = __decorate$h([
  customElement("w3m-update-email-wallet-waiting-view")
], W3mUpdateEmailWalletWaitingView);
const styles$8 = i$7`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 76px);
  }

  @media (max-width: 435px) {
    wui-grid {
      grid-template-columns: repeat(auto-fill, 77px);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;
function markWalletsAsInstalled(wallets2) {
  const { connectors } = ConnectorController.state;
  const installedConnectors = connectors.filter((c2) => c2.type === "ANNOUNCED").reduce((acum, val) => {
    if (!val.info?.rdns) {
      return acum;
    }
    acum[val.info.rdns] = true;
    return acum;
  }, {});
  const walletsWithInstalled = wallets2.map((wallet) => ({
    ...wallet,
    installed: Boolean(wallet.rdns) && Boolean(installedConnectors[wallet.rdns ?? ""])
  }));
  const sortedWallets = walletsWithInstalled.sort((a3, b4) => Number(b4.installed) - Number(a3.installed));
  return sortedWallets;
}
var __decorate$g = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const PAGINATOR_ID = "local-paginator";
let W3mAllWalletsList = class W3mAllWalletsList2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.initial = !ApiController.state.wallets.length;
    this.wallets = ApiController.state.wallets;
    this.recommended = ApiController.state.recommended;
    this.featured = ApiController.state.featured;
    this.unsubscribe.push(...[
      ApiController.subscribeKey("wallets", (val) => this.wallets = val),
      ApiController.subscribeKey("recommended", (val) => this.recommended = val),
      ApiController.subscribeKey("featured", (val) => this.featured = val)
    ]);
  }
  firstUpdated() {
    this.initialFetch();
    this.createPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    this.paginationObserver?.disconnect();
  }
  render() {
    return x$3`
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `;
  }
  async initialFetch() {
    const gridEl = this.shadowRoot?.querySelector("wui-grid");
    if (this.initial && gridEl) {
      await ApiController.fetchWallets({ page: 1 });
      await gridEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.initial = false;
      gridEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  shimmerTemplate(items, id2) {
    return [...Array(items)].map(() => x$3`
        <wui-card-select-loader type="wallet" id=${o$4(id2)}></wui-card-select-loader>
      `);
  }
  walletsTemplate() {
    const wallets2 = [...this.featured, ...this.recommended, ...this.wallets];
    const walletsWithInstalled = markWalletsAsInstalled(wallets2);
    return walletsWithInstalled.map((wallet) => x$3`
        <wui-card-select
          imageSrc=${o$4(AssetUtil.getWalletImage(wallet))}
          type="wallet"
          name=${wallet.name}
          @click=${() => this.onConnectWallet(wallet)}
          .installed=${wallet.installed}
        ></wui-card-select>
      `);
  }
  paginationLoaderTemplate() {
    const { wallets: wallets2, recommended, featured, count: count2 } = ApiController.state;
    const columns = window.innerWidth < 352 ? 3 : 4;
    const currentWallets = wallets2.length + recommended.length;
    const minimumRows = Math.ceil(currentWallets / columns);
    let shimmerCount = minimumRows * columns - currentWallets + columns;
    shimmerCount -= wallets2.length ? featured.length % columns : 0;
    if (count2 === 0 && featured.length > 0) {
      return null;
    }
    if (count2 === 0 || [...featured, ...wallets2, ...recommended].length < count2) {
      return this.shimmerTemplate(shimmerCount, PAGINATOR_ID);
    }
    return null;
  }
  createPaginationObserver() {
    const loaderEl = this.shadowRoot?.querySelector(`#${PAGINATOR_ID}`);
    if (loaderEl) {
      this.paginationObserver = new IntersectionObserver(([element]) => {
        if (element?.isIntersecting && !this.initial) {
          const { page, count: count2, wallets: wallets2 } = ApiController.state;
          if (wallets2.length < count2) {
            ApiController.fetchWallets({ page: page + 1 });
          }
        }
      });
      this.paginationObserver.observe(loaderEl);
    }
  }
  onConnectWallet(wallet) {
    const { connectors } = ConnectorController.state;
    const connector = connectors.find(({ explorerId }) => explorerId === wallet.id);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsList.styles = styles$8;
__decorate$g([
  r$4()
], W3mAllWalletsList.prototype, "initial", void 0);
__decorate$g([
  r$4()
], W3mAllWalletsList.prototype, "wallets", void 0);
__decorate$g([
  r$4()
], W3mAllWalletsList.prototype, "recommended", void 0);
__decorate$g([
  r$4()
], W3mAllWalletsList.prototype, "featured", void 0);
W3mAllWalletsList = __decorate$g([
  customElement("w3m-all-wallets-list")
], W3mAllWalletsList);
const styles$7 = i$7`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }
`;
var __decorate$f = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAllWalletsSearch = class W3mAllWalletsSearch2 extends s$3 {
  constructor() {
    super(...arguments);
    this.prevQuery = "";
    this.loading = true;
    this.query = "";
  }
  render() {
    this.onSearch();
    return this.loading ? x$3`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate();
  }
  async onSearch() {
    if (this.query !== this.prevQuery) {
      this.prevQuery = this.query;
      this.loading = true;
      await ApiController.searchWallet({ search: this.query });
      this.loading = false;
    }
  }
  walletsTemplate() {
    const { search } = ApiController.state;
    const wallets2 = markWalletsAsInstalled(search);
    if (!search.length) {
      return x$3`
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `;
    }
    return x$3`
      <wui-grid
        .padding=${["0", "s", "s", "s"]}
        gridTemplateColumns="repeat(4, 1fr)"
        rowGap="l"
        columnGap="xs"
      >
        ${wallets2.map((wallet) => x$3`
            <wui-card-select
              imageSrc=${o$4(AssetUtil.getWalletImage(wallet))}
              type="wallet"
              name=${wallet.name}
              @click=${() => this.onConnectWallet(wallet)}
              .installed=${wallet.installed}
            ></wui-card-select>
          `)}
      </wui-grid>
    `;
  }
  onConnectWallet(wallet) {
    const { connectors } = ConnectorController.state;
    const connector = connectors.find(({ explorerId }) => explorerId === wallet.id);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsSearch.styles = styles$7;
__decorate$f([
  r$4()
], W3mAllWalletsSearch.prototype, "loading", void 0);
__decorate$f([
  n$4()
], W3mAllWalletsSearch.prototype, "query", void 0);
W3mAllWalletsSearch = __decorate$f([
  customElement("w3m-all-wallets-search")
], W3mAllWalletsSearch);
var __decorate$e = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingHeader = class W3mConnectingHeader2 extends s$3 {
  constructor() {
    super();
    this.platformTabs = [];
    this.unsubscribe = [];
    this.platforms = [];
    this.onSelectPlatfrom = void 0;
    this.buffering = false;
    this.unsubscribe.push(ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const tabs = this.generateTabs();
    return x$3`
      <wui-flex justifyContent="center" .padding=${["l", "0", "0", "0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${tabs}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `;
  }
  generateTabs() {
    const tabs = this.platforms.map((platform) => {
      if (platform === "browser") {
        return { label: "Browser", icon: "extension", platform: "browser" };
      } else if (platform === "mobile") {
        return { label: "Mobile", icon: "mobile", platform: "mobile" };
      } else if (platform === "qrcode") {
        return { label: "Mobile", icon: "mobile", platform: "qrcode" };
      } else if (platform === "web") {
        return { label: "Webapp", icon: "browser", platform: "web" };
      } else if (platform === "desktop") {
        return { label: "Desktop", icon: "desktop", platform: "desktop" };
      }
      return { label: "Browser", icon: "extension", platform: "unsupported" };
    });
    this.platformTabs = tabs.map(({ platform }) => platform);
    return tabs;
  }
  onTabChange(index2) {
    const tab = this.platformTabs[index2];
    if (tab) {
      this.onSelectPlatfrom?.(tab);
    }
  }
};
__decorate$e([
  n$4({ type: Array })
], W3mConnectingHeader.prototype, "platforms", void 0);
__decorate$e([
  n$4()
], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0);
__decorate$e([
  r$4()
], W3mConnectingHeader.prototype, "buffering", void 0);
W3mConnectingHeader = __decorate$e([
  customElement("w3m-connecting-header")
], W3mConnectingHeader);
var __decorate$d = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcBrowser = class W3mConnectingWcBrowser2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-browser: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  async onConnectProxy() {
    try {
      this.error = false;
      const { connectors } = ConnectorController.state;
      const announcedConnector = connectors.find((c2) => c2.type === "ANNOUNCED" && c2.info?.rdns === this.wallet?.rdns);
      const injectedConnector = connectors.find((c2) => c2.type === "INJECTED");
      if (announcedConnector) {
        await ConnectionController.connectExternal(announcedConnector);
      } else if (injectedConnector) {
        await ConnectionController.connectExternal(injectedConnector);
      }
      ModalController.close();
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        properties: { method: "browser" }
      });
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: error?.message ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingWcBrowser = __decorate$d([
  customElement("w3m-connecting-wc-browser")
], W3mConnectingWcBrowser);
var __decorate$c = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcDesktop = class W3mConnectingWcDesktop2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-desktop: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "desktop" }
    });
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.ready = true;
      this.timeout = setTimeout(() => {
        this.onConnect?.();
      }, 200);
    }
  }
  onConnectProxy() {
    if (this.wallet?.desktop_link && this.uri) {
      try {
        this.error = false;
        const { desktop_link, name: name2 } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(desktop_link, this.uri);
        ConnectionController.setWcLinking({ name: name2, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcDesktop = __decorate$c([
  customElement("w3m-connecting-wc-desktop")
], W3mConnectingWcDesktop);
var __decorate$b = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcMobile = class W3mConnectingWcMobile2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-mobile: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    document.addEventListener("visibilitychange", this.onBuffering.bind(this));
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "mobile" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("visibilitychange", this.onBuffering.bind(this));
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.ready = true;
      this.onConnect?.();
    }
  }
  onConnectProxy() {
    if (this.wallet?.mobile_link && this.uri) {
      try {
        this.error = false;
        const { mobile_link, name: name2 } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(mobile_link, this.uri);
        ConnectionController.setWcLinking({ name: name2, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_self");
      } catch {
        this.error = true;
      }
    }
  }
  onBuffering() {
    const isIos = CoreHelperUtil.isIos();
    if (document?.visibilityState === "visible" && !this.error && isIos) {
      ConnectionController.setBuffering(true);
      setTimeout(() => {
        ConnectionController.setBuffering(false);
      }, 5e3);
    }
  }
};
W3mConnectingWcMobile = __decorate$b([
  customElement("w3m-connecting-wc-mobile")
], W3mConnectingWcMobile);
const styles$6 = i$7`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;
var __decorate$a = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcQrcode = class W3mConnectingWcQrcode2 extends W3mConnectingWidget {
  constructor() {
    super();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    window.addEventListener("resize", this.forceUpdate);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet?.name ?? "WalletConnect", platform: "qrcode" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    return x$3`
      <wui-flex padding="xl" flexDirection="column" gap="xl" alignItems="center">
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 200);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size2 = this.getBoundingClientRect().width - 40;
    const alt = this.wallet ? this.wallet.name : void 0;
    ConnectionController.setWcLinking(void 0);
    ConnectionController.setRecentWallet(this.wallet);
    return x$3` <wui-qr-code
      size=${size2}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${o$4(AssetUtil.getWalletImage(this.wallet))}
      alt=${o$4(alt)}
    ></wui-qr-code>`;
  }
  copyTemplate() {
    const inactive = !this.uri || !this.ready;
    return x$3`<wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
  }
};
W3mConnectingWcQrcode.styles = styles$6;
W3mConnectingWcQrcode = __decorate$a([
  customElement("w3m-connecting-wc-qrcode")
], W3mConnectingWcQrcode);
const styles$5 = i$7`
  :host {
    display: flex;
    justify-content: center;
    gap: var(--wui-spacing-2xl);
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`;
var __decorate$9 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingSiwe = class W3mConnectingSiwe2 extends s$3 {
  constructor() {
    super(...arguments);
    this.dappImageUrl = OptionsController.state.metadata?.icons;
    this.walletImageUrl = StorageUtil.getConnectedWalletImageUrl();
  }
  firstUpdated() {
    const visuals = this.shadowRoot?.querySelectorAll("wui-visual-thumbnail");
    if (visuals?.[0]) {
      this.createAnimation(visuals[0], "translate(18px)");
    }
    if (visuals?.[1]) {
      this.createAnimation(visuals[1], "translate(-18px)");
    }
  }
  render() {
    return x$3`
      <wui-visual-thumbnail
        ?borderRadiusFull=${true}
        .imageSrc=${this.dappImageUrl?.[0]}
      ></wui-visual-thumbnail>
      <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>
    `;
  }
  createAnimation(element, translation) {
    element.animate([{ transform: "translateX(0px)" }, { transform: translation }], {
      duration: 1600,
      easing: "cubic-bezier(0.56, 0, 0.48, 1)",
      direction: "alternate",
      iterations: Infinity
    });
  }
};
W3mConnectingSiwe.styles = styles$5;
W3mConnectingSiwe = __decorate$9([
  customElement("w3m-connecting-siwe")
], W3mConnectingSiwe);
var __decorate$8 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcUnsupported = class W3mConnectingWcUnsupported2 extends s$3 {
  constructor() {
    super();
    this.wallet = RouterController.state.data?.wallet;
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  render() {
    return x$3`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${o$4(AssetUtil.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
};
W3mConnectingWcUnsupported = __decorate$8([
  customElement("w3m-connecting-wc-unsupported")
], W3mConnectingWcUnsupported);
var __decorate$7 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcWeb = class W3mConnectingWcWeb2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-web: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.secondaryBtnLabel = "Open";
    this.secondaryLabel = "Open and continue in a new browser tab";
    this.secondaryBtnIcon = "externalLink";
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "web" }
    });
  }
  onConnectProxy() {
    if (this.wallet?.webapp_link && this.uri) {
      try {
        this.error = false;
        const { webapp_link, name: name2 } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatUniversalUrl(webapp_link, this.uri);
        ConnectionController.setWcLinking({ name: name2, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcWeb = __decorate$7([
  customElement("w3m-connecting-wc-web")
], W3mConnectingWcWeb);
const styles$4 = i$7`
  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }
`;
var __decorate$6 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
function headings() {
  const connectorName = RouterController.state.data?.connector?.name;
  const walletName = RouterController.state.data?.wallet?.name;
  const networkName = RouterController.state.data?.network?.name;
  const name2 = walletName ?? connectorName;
  const connectors = ConnectorController.getConnectors();
  const isEmail = connectors.length === 1 && connectors[0]?.id === "w3m-email";
  return {
    Connect: `Connect ${isEmail ? "Email" : ""} Wallet`,
    Account: void 0,
    ConnectingExternal: name2 ?? "Connect Wallet",
    ConnectingWalletConnect: name2 ?? "WalletConnect",
    ConnectingSiwe: "Sign In",
    Networks: "Choose Network",
    SwitchNetwork: networkName ?? "Switch Network",
    AllWallets: "All Wallets",
    WhatIsANetwork: "What is a network?",
    WhatIsAWallet: "What is a wallet?",
    GetWallet: "Get a wallet",
    Downloads: name2 ? `Get ${name2}` : "Downloads",
    EmailVerifyOtp: "Confirm Email",
    EmailVerifyDevice: "Register Device",
    ApproveTransaction: "Approve Transaction",
    Transactions: "Activity",
    UpgradeEmailWallet: "Upgrade your Wallet",
    UpdateEmailWallet: "Edit Email",
    UpdateEmailWalletWaiting: "Approve Email"
  };
}
let W3mHeader = class W3mHeader2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.heading = headings()[RouterController.state.view];
    this.buffering = false;
    this.showBack = false;
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => {
      this.onViewChange(val);
      this.onHistoryChange();
    }), ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.dynamicButtonTemplate()} ${this.titleTemplate()}
        <wui-icon-link
          ?disabled=${this.buffering}
          icon="close"
          @click=${this.onClose.bind(this)}
          data-testid="w3m-header-close"
        ></wui-icon-link>
      </wui-flex>
      ${this.separatorTemplate()}
    `;
  }
  onWalletHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_WALLET_HELP" });
    RouterController.push("WhatIsAWallet");
  }
  async onClose() {
    if (SIWEController.state.isSiweEnabled && SIWEController.state.status !== "success") {
      await ConnectionController.disconnect();
    }
    ModalController.close();
  }
  titleTemplate() {
    return x$3`<wui-text variant="paragraph-700" color="fg-100">${this.heading}</wui-text>`;
  }
  dynamicButtonTemplate() {
    const { view } = RouterController.state;
    const isConnectHelp = view === "Connect";
    const isApproveTransaction = view === "ApproveTransaction";
    if (this.showBack && !isApproveTransaction) {
      return x$3`<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>`;
    }
    return x$3`<wui-icon-link
      data-hidden=${!isConnectHelp}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`;
  }
  separatorTemplate() {
    if (!this.heading) {
      return null;
    }
    return x$3`<wui-separator></wui-separator>`;
  }
  getPadding() {
    if (this.heading) {
      return ["l", "2l", "l", "2l"];
    }
    return ["l", "2l", "0", "2l"];
  }
  async onViewChange(view) {
    const headingEl = this.shadowRoot?.querySelector("wui-text");
    if (headingEl) {
      const preset = headings()[view];
      await headingEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.heading = preset;
      headingEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onHistoryChange() {
    const { history } = RouterController.state;
    const buttonEl = this.shadowRoot?.querySelector("#dynamic");
    if (history.length > 1 && !this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = true;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    } else if (history.length <= 1 && this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = false;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onGoBack() {
    if (RouterController.state.view === "ConnectingSiwe") {
      RouterController.push("Connect");
    } else {
      RouterController.goBack();
    }
  }
};
W3mHeader.styles = [styles$4];
__decorate$6([
  r$4()
], W3mHeader.prototype, "heading", void 0);
__decorate$6([
  r$4()
], W3mHeader.prototype, "buffering", void 0);
__decorate$6([
  r$4()
], W3mHeader.prototype, "showBack", void 0);
W3mHeader = __decorate$6([
  customElement("w3m-header")
], W3mHeader);
var __decorate$5 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mHelpWidget = class W3mHelpWidget2 extends s$3 {
  constructor() {
    super(...arguments);
    this.data = [];
  }
  render() {
    return x$3`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map((item) => x$3`
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${item.images.map((image) => x$3`<wui-visual name=${image}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${item.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${item.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
__decorate$5([
  n$4({ type: Array })
], W3mHelpWidget.prototype, "data", void 0);
W3mHelpWidget = __decorate$5([
  customElement("w3m-help-widget")
], W3mHelpWidget);
const styles$3 = i$7`
  wui-flex {
    background-color: var(--wui-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
  }
`;
var __decorate$4 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mLegalFooter = class W3mLegalFooter2 extends s$3 {
  render() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    return x$3`
      <wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
        <wui-text color="fg-250" variant="small-400" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    `;
  }
  andTemplate() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    return termsConditionsUrl && privacyPolicyUrl ? "and" : "";
  }
  termsTemplate() {
    const { termsConditionsUrl } = OptionsController.state;
    if (!termsConditionsUrl) {
      return null;
    }
    return x$3`<a href=${termsConditionsUrl}>Terms of Service</a>`;
  }
  privacyTemplate() {
    const { privacyPolicyUrl } = OptionsController.state;
    if (!privacyPolicyUrl) {
      return null;
    }
    return x$3`<a href=${privacyPolicyUrl}>Privacy Policy</a>`;
  }
};
W3mLegalFooter.styles = [styles$3];
W3mLegalFooter = __decorate$4([
  customElement("w3m-legal-footer")
], W3mLegalFooter);
const styles$2 = i$7`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;
var __decorate$3 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mMobileDownloadLinks = class W3mMobileDownloadLinks2 extends s$3 {
  constructor() {
    super(...arguments);
    this.wallet = void 0;
  }
  render() {
    if (!this.wallet) {
      this.style.display = "none";
      return null;
    }
    const { name: name2, app_store, play_store, chrome_store, homepage } = this.wallet;
    const isMobile = CoreHelperUtil.isMobile();
    const isIos = CoreHelperUtil.isIos();
    const isAndroid = CoreHelperUtil.isAndroid();
    const isMultiple = [app_store, play_store, homepage, chrome_store].filter(Boolean).length > 1;
    const shortName = UiHelperUtil.getTruncateString({
      string: name2,
      charsStart: 12,
      charsEnd: 0,
      truncate: "end"
    });
    if (isMultiple && !isMobile) {
      return x$3`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${() => RouterController.push("Downloads", { wallet: this.wallet })}
        ></wui-cta-button>
      `;
    }
    if (!isMultiple && homepage) {
      return x$3`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (app_store && isIos) {
      return x$3`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (play_store && isAndroid) {
      return x$3`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    this.style.display = "none";
    return null;
  }
  onAppStore() {
    if (this.wallet?.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    if (this.wallet?.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    if (this.wallet?.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mMobileDownloadLinks.styles = [styles$2];
__decorate$3([
  n$4({ type: Object })
], W3mMobileDownloadLinks.prototype, "wallet", void 0);
W3mMobileDownloadLinks = __decorate$3([
  customElement("w3m-mobile-download-links")
], W3mMobileDownloadLinks);
const styles$1 = i$7`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;
var __decorate$2 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const presets = {
  success: {
    backgroundColor: "success-100",
    iconColor: "success-100",
    icon: "checkmark"
  },
  error: {
    backgroundColor: "error-100",
    iconColor: "error-100",
    icon: "close"
  }
};
let W3mSnackBar = class W3mSnackBar2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.open = SnackController.state.open;
    this.unsubscribe.push(SnackController.subscribeKey("open", (val) => {
      this.open = val;
      this.onOpen();
    }));
  }
  disconnectedCallback() {
    clearTimeout(this.timeout);
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { message, variant } = SnackController.state;
    const preset = presets[variant];
    return x$3`
      <wui-snackbar
        message=${message}
        backgroundColor=${preset.backgroundColor}
        iconColor=${preset.iconColor}
        icon=${preset.icon}
      ></wui-snackbar>
    `;
  }
  onOpen() {
    clearTimeout(this.timeout);
    if (this.open) {
      this.animate([
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
        { opacity: 1, transform: "translateX(-50%) scale(1)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      this.timeout = setTimeout(() => SnackController.hide(), 2500);
    } else {
      this.animate([
        { opacity: 1, transform: "translateX(-50%) scale(1)" },
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
W3mSnackBar.styles = styles$1;
__decorate$2([
  r$4()
], W3mSnackBar.prototype, "open", void 0);
W3mSnackBar = __decorate$2([
  customElement("w3m-snackbar")
], W3mSnackBar);
const styles = i$7`
  wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }

  wui-icon-link,
  wui-loading-spinner {
    position: absolute;
    top: 21px;
    transform: translateY(-50%);
  }

  wui-icon-link {
    right: var(--wui-spacing-xs);
  }

  wui-loading-spinner {
    right: var(--wui-spacing-m);
  }

  .alphaBanner {
    padding: 10px 12px 10px 10px;
    border-radius: var(--wui-border-radius-s);
    background: var(--wui-accent-glass-010);
    margin-bottom: var(--wui-spacing-s);
  }
`;
var __decorate$1 = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mEmailLoginWidget = class W3mEmailLoginWidget2 extends s$3 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.formRef = e$2();
    this.connectors = ConnectorController.state.connectors;
    this.email = "";
    this.loading = false;
    this.error = "";
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    this.formRef.value?.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    const multipleConnectors = this.connectors.length > 1;
    const connector = this.connectors.find((c2) => c2.type === "EMAIL");
    if (!connector) {
      return null;
    }
    return x$3`
      ${this.alphaWarningTemplate()}
      <form ${n$2(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          .errorMessage=${this.error}
        >
        </wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>

      ${multipleConnectors ? x$3`<wui-separator text="or"></wui-separator>` : null}
    `;
  }
  alphaWarningTemplate() {
    const showAlphaWarning = true;
    return showAlphaWarning ? x$3`
          <wui-flex class="alphaBanner" gap="xs" alignItems="center" justifyContent="center">
            <wui-icon-box
              size="sm"
              icon="alpha"
              iconColor="accent-100"
              background="opaque"
              backgroundColor="accent-100"
            ></wui-icon-box>
            <wui-text variant="small-400" color="accent-100">
              This is an alpha version to test before launch
            </wui-text>
          </wui-flex>
        ` : null;
  }
  submitButtonTemplate() {
    const showSubmit = !this.loading && this.email.length > 3;
    return showSubmit ? x$3`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </wui-icon-link>
        ` : null;
  }
  loadingTemplate() {
    return this.loading ? x$3`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null;
  }
  onEmailInputChange(event) {
    this.email = event.detail;
    this.error = "";
  }
  async onSubmitEmail(event) {
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const emailConnector = ConnectorController.getEmailConnector();
      if (!emailConnector) {
        throw new Error("w3m-email-login-widget: Email connector not found");
      }
      const { action } = await emailConnector.provider.connectEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_SUBMITTED" });
      if (action === "VERIFY_OTP") {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.push("EmailVerifyOtp", { email: this.email });
      } else if (action === "VERIFY_DEVICE") {
        RouterController.push("EmailVerifyDevice", { email: this.email });
      }
    } catch (error) {
      const parsedError = CoreHelperUtil.parseError(error);
      if (parsedError?.includes("Invalid email")) {
        this.error = "Invalid email. Try again.";
      } else {
        SnackController.showError(error);
      }
    } finally {
      this.loading = false;
    }
  }
  onFocusEvent() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_LOGIN_SELECTED" });
  }
};
W3mEmailLoginWidget.styles = styles;
__decorate$1([
  r$4()
], W3mEmailLoginWidget.prototype, "connectors", void 0);
__decorate$1([
  r$4()
], W3mEmailLoginWidget.prototype, "email", void 0);
__decorate$1([
  r$4()
], W3mEmailLoginWidget.prototype, "loading", void 0);
__decorate$1([
  r$4()
], W3mEmailLoginWidget.prototype, "error", void 0);
W3mEmailLoginWidget = __decorate$1([
  customElement("w3m-email-login-widget")
], W3mEmailLoginWidget);
let isInitialized = false;
class Web3ModalScaffold {
  constructor(options) {
    this.initPromise = void 0;
    this.setIsConnected = (isConnected) => {
      AccountController.setIsConnected(isConnected);
    };
    this.setCaipAddress = (caipAddress) => {
      AccountController.setCaipAddress(caipAddress);
    };
    this.setBalance = (balance, balanceSymbol) => {
      AccountController.setBalance(balance, balanceSymbol);
    };
    this.setProfileName = (profileName) => {
      AccountController.setProfileName(profileName);
    };
    this.setProfileImage = (profileImage) => {
      AccountController.setProfileImage(profileImage);
    };
    this.resetAccount = () => {
      AccountController.resetAccount();
    };
    this.setCaipNetwork = (caipNetwork) => {
      NetworkController.setCaipNetwork(caipNetwork);
    };
    this.getCaipNetwork = () => NetworkController.state.caipNetwork;
    this.setRequestedCaipNetworks = (requestedCaipNetworks) => {
      NetworkController.setRequestedCaipNetworks(requestedCaipNetworks);
    };
    this.getApprovedCaipNetworksData = () => NetworkController.getApprovedCaipNetworksData();
    this.resetNetwork = () => {
      NetworkController.resetNetwork();
    };
    this.setConnectors = (connectors) => {
      ConnectorController.setConnectors(connectors);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.getConnectors = () => ConnectorController.getConnectors();
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.setAddressExplorerUrl = (addressExplorerUrl) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl);
    };
    this.setSIWENonce = (nonce) => {
      SIWEController.setNonce(nonce);
    };
    this.setSIWESession = (session) => {
      SIWEController.setSession(session);
    };
    this.setSIWEStatus = (status) => {
      SIWEController.setStatus(status);
    };
    this.setSIWEMessage = (message) => {
      SIWEController.setMessage(message);
    };
    this.initControllers(options);
    this.initOrContinue();
  }
  async open(options) {
    await this.initOrContinue();
    ModalController.open(options);
  }
  async close() {
    await this.initOrContinue();
    ModalController.close();
  }
  setLoading(loading) {
    ModalController.setLoading(loading);
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
    try {
      const emailConnector = ConnectorController.getEmailConnector();
      if (emailConnector) {
        emailConnector.provider.syncTheme({
          themeMode: ThemeController.getSnapshot().themeMode
        });
      }
    } catch {
      console.info("Unable to sync theme to email connector");
    }
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
    try {
      const emailConnector = ConnectorController.getEmailConnector();
      if (emailConnector) {
        emailConnector.provider.syncTheme({
          themeVariables: ThemeController.getSnapshot().themeVariables
        });
      }
    } catch {
      console.info("Unable to sync theme to email connector");
    }
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  getState() {
    return { ...PublicStateController.state };
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  subscribeSIWEState(callback) {
    return SIWEController.subscribe(callback);
  }
  initControllers(options) {
    NetworkController.setClient(options.networkControllerClient);
    NetworkController.setDefaultCaipNetwork(options.defaultChain);
    OptionsController.setProjectId(options.projectId);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setEnableAnalytics(options.enableAnalytics);
    OptionsController.setSdkVersion(options._sdkVersion);
    ConnectionController.setClient(options.connectionControllerClient);
    if (options.siweControllerClient) {
      const siweClient = options.siweControllerClient;
      SIWEController.setSIWEClient(siweClient);
    }
    if (options.metadata) {
      OptionsController.setMetadata(options.metadata);
    }
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
  }
  async initOrContinue() {
    if (!this.initPromise && !isInitialized && CoreHelperUtil.isClient()) {
      isInitialized = true;
      this.initPromise = new Promise(async (resolve) => {
        await Promise.all([__vitePreload(() => import("./index-37225613.js"), true ? [] : void 0), __vitePreload(() => Promise.resolve().then(() => index$M), true ? void 0 : void 0)]);
        const modal2 = document.createElement("w3m-modal");
        document.body.insertAdjacentElement("beforeend", modal2);
        resolve();
      });
    }
    return this.initPromise;
  }
}
const ConstantsUtil = {
  WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
  INJECTED_CONNECTOR_ID: "injected",
  COINBASE_CONNECTOR_ID: "coinbaseWallet",
  SAFE_CONNECTOR_ID: "safe",
  LEDGER_CONNECTOR_ID: "ledger",
  EIP6963_CONNECTOR_ID: "eip6963",
  EMAIL_CONNECTOR_ID: "w3mEmail",
  EIP155: "eip155",
  ADD_CHAIN_METHOD: "wallet_addEthereumChain",
  EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
  EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
  VERSION: "3.5.7"
};
const PresetsUtil = {
  ConnectorExplorerIds: {
    [ConstantsUtil.COINBASE_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil.SAFE_CONNECTOR_ID]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
    [ConstantsUtil.LEDGER_CONNECTOR_ID]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927"
  },
  EIP155NetworkImageIds: {
    1: "692ed6ba-e569-459a-556a-776476829e00",
    42161: "600a9a04-c1b9-42ca-6785-9b4b6ff85200",
    43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
    56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
    250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
    10: "ab9c186a-c52f-464b-2906-ca59d760a400",
    137: "41d04d42-da3b-4453-8506-668cc0727900",
    100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
    9001: "f926ff41-260d-4028-635e-91913fc28e00",
    324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
    314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
    4689: "34e68754-e536-40da-c153-6ef2e7188a00",
    1088: "3897a66d-40b9-4833-162f-a2c90531c900",
    1284: "161038da-44ae-4ec7-1208-0ea569454b00",
    1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
    7777777: "845c60df-d429-4991-e687-91ae45791600",
    42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
    8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
    1313161554: "3ff73439-a619-4894-9262-4470c773a100"
  },
  ConnectorImageIds: {
    [ConstantsUtil.COINBASE_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil.SAFE_CONNECTOR_ID]: "461db637-8616-43ce-035a-d89b8a1d5800",
    [ConstantsUtil.LEDGER_CONNECTOR_ID]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
    [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
    [ConstantsUtil.INJECTED_CONNECTOR_ID]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
  },
  ConnectorNamesMap: {
    [ConstantsUtil.INJECTED_CONNECTOR_ID]: "Browser Wallet",
    [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "WalletConnect",
    [ConstantsUtil.COINBASE_CONNECTOR_ID]: "Coinbase",
    [ConstantsUtil.LEDGER_CONNECTOR_ID]: "Ledger",
    [ConstantsUtil.SAFE_CONNECTOR_ID]: "Safe"
  },
  ConnectorTypesMap: {
    [ConstantsUtil.INJECTED_CONNECTOR_ID]: "INJECTED",
    [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "WALLET_CONNECT",
    [ConstantsUtil.EIP6963_CONNECTOR_ID]: "ANNOUNCED",
    [ConstantsUtil.EMAIL_CONNECTOR_ID]: "EMAIL"
  },
  WalletConnectRpcChainIds: [
    1,
    5,
    11155111,
    10,
    420,
    42161,
    421613,
    137,
    80001,
    42220,
    1313161554,
    1313161555,
    56,
    97,
    43114,
    43113,
    100,
    8453,
    84531,
    7777777,
    999,
    324,
    280
  ]
};
const HelpersUtil = {
  caipNetworkIdToNumber(caipnetworkId) {
    return caipnetworkId ? Number(caipnetworkId.split(":")[1]) : void 0;
  },
  getCaipTokens(tokens) {
    if (!tokens) {
      return void 0;
    }
    const caipTokens = {};
    Object.entries(tokens).forEach(([id2, token2]) => {
      caipTokens[`${ConstantsUtil.EIP155}:${id2}`] = token2;
    });
    return caipTokens;
  }
};
var events$1 = { exports: {} };
var R$3 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R$3 && typeof R$3.apply === "function" ? R$3.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R$3 && typeof R$3.ownKeys === "function") {
  ReflectOwnKeys = R$3.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events$1.exports = EventEmitter$1;
var once_1 = events$1.exports.once = once$2;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter$1.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n4) {
  if (typeof n4 !== "number" || n4 < 0 || NumberIsNaN(n4)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n4 + ".");
  }
  this._maxListeners = n4;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$1.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter$1.prototype.emit = function emit(type2) {
  var args = [];
  for (var i3 = 1; i3 < arguments.length; i3++)
    args.push(arguments[i3]);
  var doError = type2 === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er2;
    if (args.length > 0)
      er2 = args[0];
    if (er2 instanceof Error) {
      throw er2;
    }
    var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
    err.context = er2;
    throw err;
  }
  var handler = events2[type2];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len2 = handler.length;
    var listeners2 = arrayClone$1(handler, len2);
    for (var i3 = 0; i3 < len2; ++i3)
      ReflectApply(listeners2[i3], this, args);
  }
  return true;
};
function _addListener(target, type2, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type2];
  }
  if (existing === void 0) {
    existing = events2[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w3 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w3.name = "MaxListenersExceededWarning";
      w3.emitter = target;
      w3.type = type2;
      w3.count = existing.length;
      ProcessEmitWarning(w3);
    }
  }
  return target;
}
EventEmitter$1.prototype.addListener = function addListener(type2, listener) {
  return _addListener(this, type2, listener, false);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function prependListener(type2, listener) {
  return _addListener(this, type2, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type2, listener) {
  var state2 = { fired: false, wrapFn: void 0, target, type: type2, listener };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter$1.prototype.once = function once2(type2, listener) {
  checkListener(listener);
  this.on(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter$1.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
  checkListener(listener);
  this.prependListener(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter$1.prototype.removeListener = function removeListener(type2, listener) {
  var list, events2, position, i3, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type2];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type2];
      if (events2.removeListener)
        this.emit("removeListener", type2, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i3 = list.length - 1; i3 >= 0; i3--) {
      if (list[i3] === listener || list[i3].listener === listener) {
        originalListener = list[i3].listener;
        position = i3;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type2] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type2, originalListener || listener);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(type2) {
  var listeners2, events2, i3;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type2] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type2];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    var key2;
    for (i3 = 0; i3 < keys2.length; ++i3) {
      key2 = keys2[i3];
      if (key2 === "removeListener")
        continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type2];
  if (typeof listeners2 === "function") {
    this.removeListener(type2, listeners2);
  } else if (listeners2 !== void 0) {
    for (i3 = listeners2.length - 1; i3 >= 0; i3--) {
      this.removeListener(type2, listeners2[i3]);
    }
  }
  return this;
};
function _listeners(target, type2, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type2];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone$1(evlistener, evlistener.length);
}
EventEmitter$1.prototype.listeners = function listeners(type2) {
  return _listeners(this, type2, true);
};
EventEmitter$1.prototype.rawListeners = function rawListeners(type2) {
  return _listeners(this, type2, false);
};
EventEmitter$1.listenerCount = function(emitter, type2) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type2);
  } else {
    return listenerCount.call(emitter, type2);
  }
};
EventEmitter$1.prototype.listenerCount = listenerCount;
function listenerCount(type2) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone$1(arr2, n4) {
  var copy2 = new Array(n4);
  for (var i3 = 0; i3 < n4; ++i3)
    copy2[i3] = arr2[i3];
  return copy2;
}
function spliceOne(list, index2) {
  for (; index2 + 1 < list.length; index2++)
    list[index2] = list[index2 + 1];
  list.pop();
}
function unwrapListeners(arr2) {
  var ret = new Array(arr2.length);
  for (var i3 = 0; i3 < ret.length; ++i3) {
    ret[i3] = arr2[i3].listener || arr2[i3];
  }
  return ret;
}
function once$2(emitter, name2) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name2, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
    if (name2 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name2, listener);
    } else {
      emitter.on(name2, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name2, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name2, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var eventsExports = events$1.exports;
const $g$1 = /* @__PURE__ */ getDefaultExportFromCjs(eventsExports);
const events = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: $g$1,
  once: once_1
}, [eventsExports]);
var chacha20poly1305 = {};
var chacha$1 = {};
var binary$1 = {};
var int$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  function imulShim(a3, b4) {
    var ah2 = a3 >>> 16 & 65535, al2 = a3 & 65535;
    var bh2 = b4 >>> 16 & 65535, bl2 = b4 & 65535;
    return al2 * bl2 + (ah2 * bl2 + al2 * bh2 << 16 >>> 0) | 0;
  }
  exports2.mul = Math.imul || imulShim;
  function add3(a3, b4) {
    return a3 + b4 | 0;
  }
  exports2.add = add3;
  function sub(a3, b4) {
    return a3 - b4 | 0;
  }
  exports2.sub = sub;
  function rotl(x2, n4) {
    return x2 << n4 | x2 >>> 32 - n4;
  }
  exports2.rotl = rotl;
  function rotr(x2, n4) {
    return x2 << 32 - n4 | x2 >>> n4;
  }
  exports2.rotr = rotr;
  function isIntegerShim(n4) {
    return typeof n4 === "number" && isFinite(n4) && Math.floor(n4) === n4;
  }
  exports2.isInteger = Number.isInteger || isIntegerShim;
  exports2.MAX_SAFE_INTEGER = 9007199254740991;
  exports2.isSafeInteger = function(n4) {
    return exports2.isInteger(n4) && (n4 >= -exports2.MAX_SAFE_INTEGER && n4 <= exports2.MAX_SAFE_INTEGER);
  };
})(int$2);
const int = /* @__PURE__ */ getDefaultExportFromCjs(int$2);
const int$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: int
}, [int$2]);
const require$$0$1m = /* @__PURE__ */ getAugmentedNamespace(int$1);
Object.defineProperty(binary$1, "__esModule", { value: true });
var int_1 = require$$0$1m;
function readInt16BE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array2[offset + 0] << 8 | array2[offset + 1]) << 16 >> 16;
}
var readInt16BE_1 = binary$1.readInt16BE = readInt16BE;
function readUint16BE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array2[offset + 0] << 8 | array2[offset + 1]) >>> 0;
}
var readUint16BE_1 = binary$1.readUint16BE = readUint16BE;
function readInt16LE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array2[offset + 1] << 8 | array2[offset]) << 16 >> 16;
}
var readInt16LE_1 = binary$1.readInt16LE = readInt16LE;
function readUint16LE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array2[offset + 1] << 8 | array2[offset]) >>> 0;
}
var readUint16LE_1 = binary$1.readUint16LE = readUint16LE;
function writeUint16BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 8;
  out[offset + 1] = value >>> 0;
  return out;
}
var writeUint16BE_1 = binary$1.writeUint16BE = writeUint16BE;
var writeInt16BE = binary$1.writeInt16BE = writeUint16BE;
function writeUint16LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  return out;
}
var writeUint16LE_1 = binary$1.writeUint16LE = writeUint16LE;
var writeInt16LE = binary$1.writeInt16LE = writeUint16LE;
function readInt32BE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array2[offset] << 24 | array2[offset + 1] << 16 | array2[offset + 2] << 8 | array2[offset + 3];
}
var readInt32BE_1 = binary$1.readInt32BE = readInt32BE;
function readUint32BE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array2[offset] << 24 | array2[offset + 1] << 16 | array2[offset + 2] << 8 | array2[offset + 3]) >>> 0;
}
var readUint32BE_1 = binary$1.readUint32BE = readUint32BE;
function readInt32LE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array2[offset + 3] << 24 | array2[offset + 2] << 16 | array2[offset + 1] << 8 | array2[offset];
}
var readInt32LE_1 = binary$1.readInt32LE = readInt32LE;
function readUint32LE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array2[offset + 3] << 24 | array2[offset + 2] << 16 | array2[offset + 1] << 8 | array2[offset]) >>> 0;
}
var readUint32LE_1 = binary$1.readUint32LE = readUint32LE;
function writeUint32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 24;
  out[offset + 1] = value >>> 16;
  out[offset + 2] = value >>> 8;
  out[offset + 3] = value >>> 0;
  return out;
}
var writeUint32BE_1 = binary$1.writeUint32BE = writeUint32BE;
var writeInt32BE = binary$1.writeInt32BE = writeUint32BE;
function writeUint32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  out[offset + 2] = value >>> 16;
  out[offset + 3] = value >>> 24;
  return out;
}
var writeUint32LE_1 = binary$1.writeUint32LE = writeUint32LE;
var writeInt32LE = binary$1.writeInt32LE = writeUint32LE;
function readInt64BE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi2 = readInt32BE(array2, offset);
  var lo = readInt32BE(array2, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
var readInt64BE_1 = binary$1.readInt64BE = readInt64BE;
function readUint64BE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi2 = readUint32BE(array2, offset);
  var lo = readUint32BE(array2, offset + 4);
  return hi2 * 4294967296 + lo;
}
var readUint64BE_1 = binary$1.readUint64BE = readUint64BE;
function readInt64LE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readInt32LE(array2, offset);
  var hi2 = readInt32LE(array2, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
var readInt64LE_1 = binary$1.readInt64LE = readInt64LE;
function readUint64LE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readUint32LE(array2, offset);
  var hi2 = readUint32LE(array2, offset + 4);
  return hi2 * 4294967296 + lo;
}
var readUint64LE_1 = binary$1.readUint64LE = readUint64LE;
function writeUint64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32BE(value / 4294967296 >>> 0, out, offset);
  writeUint32BE(value >>> 0, out, offset + 4);
  return out;
}
var writeUint64BE_1 = binary$1.writeUint64BE = writeUint64BE;
var writeInt64BE = binary$1.writeInt64BE = writeUint64BE;
function writeUint64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32LE(value >>> 0, out, offset);
  writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
  return out;
}
var writeUint64LE_1 = binary$1.writeUint64LE = writeUint64LE;
var writeInt64LE = binary$1.writeInt64LE = writeUint64LE;
function readUintBE$1(bitLength, array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array2.length - offset) {
    throw new Error("readUintBE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul5 = 1;
  for (var i3 = bitLength / 8 + offset - 1; i3 >= offset; i3--) {
    result += array2[i3] * mul5;
    mul5 *= 256;
  }
  return result;
}
var readUintBE_1 = binary$1.readUintBE = readUintBE$1;
function readUintLE$1(bitLength, array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array2.length - offset) {
    throw new Error("readUintLE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul5 = 1;
  for (var i3 = offset; i3 < offset + bitLength / 8; i3++) {
    result += array2[i3] * mul5;
    mul5 *= 256;
  }
  return result;
}
var readUintLE_1 = binary$1.readUintLE = readUintLE$1;
function writeUintBE$1(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintBE value must be an integer");
  }
  var div = 1;
  for (var i3 = bitLength / 8 + offset - 1; i3 >= offset; i3--) {
    out[i3] = value / div & 255;
    div *= 256;
  }
  return out;
}
var writeUintBE_1 = binary$1.writeUintBE = writeUintBE$1;
function writeUintLE$1(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintLE value must be an integer");
  }
  var div = 1;
  for (var i3 = offset; i3 < offset + bitLength / 8; i3++) {
    out[i3] = value / div & 255;
    div *= 256;
  }
  return out;
}
var writeUintLE_1 = binary$1.writeUintLE = writeUintLE$1;
function readFloat32BE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
  return view.getFloat32(offset);
}
var readFloat32BE_1 = binary$1.readFloat32BE = readFloat32BE;
function readFloat32LE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
  return view.getFloat32(offset, true);
}
var readFloat32LE_1 = binary$1.readFloat32LE = readFloat32LE;
function readFloat64BE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
  return view.getFloat64(offset);
}
var readFloat64BE_1 = binary$1.readFloat64BE = readFloat64BE;
function readFloat64LE(array2, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
  return view.getFloat64(offset, true);
}
var readFloat64LE_1 = binary$1.readFloat64LE = readFloat64LE;
function writeFloat32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value);
  return out;
}
var writeFloat32BE_1 = binary$1.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value, true);
  return out;
}
var writeFloat32LE_1 = binary$1.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value);
  return out;
}
var writeFloat64BE_1 = binary$1.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value, true);
  return out;
}
var writeFloat64LE_1 = binary$1.writeFloat64LE = writeFloat64LE;
const binary = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: binary$1,
  readFloat32BE: readFloat32BE_1,
  readFloat32LE: readFloat32LE_1,
  readFloat64BE: readFloat64BE_1,
  readFloat64LE: readFloat64LE_1,
  readInt16BE: readInt16BE_1,
  readInt16LE: readInt16LE_1,
  readInt32BE: readInt32BE_1,
  readInt32LE: readInt32LE_1,
  readInt64BE: readInt64BE_1,
  readInt64LE: readInt64LE_1,
  readUint16BE: readUint16BE_1,
  readUint16LE: readUint16LE_1,
  readUint32BE: readUint32BE_1,
  readUint32LE: readUint32LE_1,
  readUint64BE: readUint64BE_1,
  readUint64LE: readUint64LE_1,
  readUintBE: readUintBE_1,
  readUintLE: readUintLE_1,
  writeFloat32BE: writeFloat32BE_1,
  writeFloat32LE: writeFloat32LE_1,
  writeFloat64BE: writeFloat64BE_1,
  writeFloat64LE: writeFloat64LE_1,
  writeInt16BE,
  writeInt16LE,
  writeInt32BE,
  writeInt32LE,
  writeInt64BE,
  writeInt64LE,
  writeUint16BE: writeUint16BE_1,
  writeUint16LE: writeUint16LE_1,
  writeUint32BE: writeUint32BE_1,
  writeUint32LE: writeUint32LE_1,
  writeUint64BE: writeUint64BE_1,
  writeUint64LE: writeUint64LE_1,
  writeUintBE: writeUintBE_1,
  writeUintLE: writeUintLE_1
}, [binary$1]);
const require$$0$1l = /* @__PURE__ */ getAugmentedNamespace(binary);
var wipe$2 = {};
Object.defineProperty(wipe$2, "__esModule", { value: true });
function wipe(array2) {
  for (var i3 = 0; i3 < array2.length; i3++) {
    array2[i3] = 0;
  }
  return array2;
}
var wipe_2 = wipe$2.wipe = wipe;
const wipe$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: wipe$2,
  wipe: wipe_2
}, [wipe$2]);
const require$$2$r = /* @__PURE__ */ getAugmentedNamespace(wipe$1);
Object.defineProperty(chacha$1, "__esModule", { value: true });
var binary_1 = require$$0$1l;
var wipe_1$3 = require$$2$r;
var ROUNDS = 20;
function core(out, input, key2) {
  var j0 = 1634760805;
  var j1 = 857760878;
  var j2 = 2036477234;
  var j3 = 1797285236;
  var j4 = key2[3] << 24 | key2[2] << 16 | key2[1] << 8 | key2[0];
  var j5 = key2[7] << 24 | key2[6] << 16 | key2[5] << 8 | key2[4];
  var j6 = key2[11] << 24 | key2[10] << 16 | key2[9] << 8 | key2[8];
  var j7 = key2[15] << 24 | key2[14] << 16 | key2[13] << 8 | key2[12];
  var j8 = key2[19] << 24 | key2[18] << 16 | key2[17] << 8 | key2[16];
  var j9 = key2[23] << 24 | key2[22] << 16 | key2[21] << 8 | key2[20];
  var j10 = key2[27] << 24 | key2[26] << 16 | key2[25] << 8 | key2[24];
  var j11 = key2[31] << 24 | key2[30] << 16 | key2[29] << 8 | key2[28];
  var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
  var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
  var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
  var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
  var x0 = j0;
  var x1 = j1;
  var x2 = j2;
  var x3 = j3;
  var x4 = j4;
  var x5 = j5;
  var x6 = j6;
  var x7 = j7;
  var x8 = j8;
  var x9 = j9;
  var x10 = j10;
  var x11 = j11;
  var x12 = j12;
  var x13 = j13;
  var x14 = j14;
  var x15 = j15;
  for (var i3 = 0; i3 < ROUNDS; i3 += 2) {
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 7 | x5 << 7;
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 7 | x5 << 7;
  }
  binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
  binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
  binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
  binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
  binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
  binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
  binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
  binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
  binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
  binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
  binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
  binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
  binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
  binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
  binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
  binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
function streamXOR(key2, nonce, src2, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  if (key2.length !== 32) {
    throw new Error("ChaCha: key size must be 32 bytes");
  }
  if (dst.length < src2.length) {
    throw new Error("ChaCha: destination is shorter than source");
  }
  var nc2;
  var counterLength;
  if (nonceInplaceCounterLength === 0) {
    if (nonce.length !== 8 && nonce.length !== 12) {
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    }
    nc2 = new Uint8Array(16);
    counterLength = nc2.length - nonce.length;
    nc2.set(nonce, counterLength);
  } else {
    if (nonce.length !== 16) {
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    }
    nc2 = nonce;
    counterLength = nonceInplaceCounterLength;
  }
  var block2 = new Uint8Array(64);
  for (var i3 = 0; i3 < src2.length; i3 += 64) {
    core(block2, nc2, key2);
    for (var j2 = i3; j2 < i3 + 64 && j2 < src2.length; j2++) {
      dst[j2] = src2[j2] ^ block2[j2 - i3];
    }
    incrementCounter(nc2, 0, counterLength);
  }
  wipe_1$3.wipe(block2);
  if (nonceInplaceCounterLength === 0) {
    wipe_1$3.wipe(nc2);
  }
  return dst;
}
var streamXOR_1 = chacha$1.streamXOR = streamXOR;
function stream(key2, nonce, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  wipe_1$3.wipe(dst);
  return streamXOR(key2, nonce, dst, dst, nonceInplaceCounterLength);
}
var stream_1 = chacha$1.stream = stream;
function incrementCounter(counter, pos, len2) {
  var carry = 1;
  while (len2--) {
    carry = carry + (counter[pos] & 255) | 0;
    counter[pos] = carry & 255;
    carry >>>= 8;
    pos++;
  }
  if (carry > 0) {
    throw new Error("ChaCha: counter overflow");
  }
}
const chacha = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: chacha$1,
  stream: stream_1,
  streamXOR: streamXOR_1
}, [chacha$1]);
const require$$0$1k = /* @__PURE__ */ getAugmentedNamespace(chacha);
var poly1305$2 = {};
var constantTime$1 = {};
Object.defineProperty(constantTime$1, "__esModule", { value: true });
function select(subject, resultIfOne, resultIfZero) {
  return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
}
var select_1 = constantTime$1.select = select;
function lessOrEqual(a3, b4) {
  return (a3 | 0) - (b4 | 0) - 1 >>> 31 & 1;
}
var lessOrEqual_1 = constantTime$1.lessOrEqual = lessOrEqual;
function compare$f(a3, b4) {
  if (a3.length !== b4.length) {
    return 0;
  }
  var result = 0;
  for (var i3 = 0; i3 < a3.length; i3++) {
    result |= a3[i3] ^ b4[i3];
  }
  return 1 & result - 1 >>> 8;
}
var compare_1$1 = constantTime$1.compare = compare$f;
function equal$2(a3, b4) {
  if (a3.length === 0 || b4.length === 0) {
    return false;
  }
  return compare$f(a3, b4) !== 0;
}
var equal_1 = constantTime$1.equal = equal$2;
const constantTime = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  compare: compare_1$1,
  default: constantTime$1,
  equal: equal_1,
  lessOrEqual: lessOrEqual_1,
  select: select_1
}, [constantTime$1]);
const require$$1$K = /* @__PURE__ */ getAugmentedNamespace(constantTime);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var constant_time_12 = require$$1$K;
  var wipe_12 = require$$2$r;
  exports2.DIGEST_LENGTH = 16;
  var Poly1305 = (
    /** @class */
    function() {
      function Poly13052(key2) {
        this.digestLength = exports2.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key2[0] | key2[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key2[2] | key2[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key2[4] | key2[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key2[6] | key2[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key2[8] | key2[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this._r[5] = t4 >>> 1 & 8190;
        var t5 = key2[10] | key2[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key2[12] | key2[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key2[14] | key2[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this._r[9] = t7 >>> 5 & 127;
        this._pad[0] = key2[16] | key2[17] << 8;
        this._pad[1] = key2[18] | key2[19] << 8;
        this._pad[2] = key2[20] | key2[21] << 8;
        this._pad[3] = key2[22] | key2[23] << 8;
        this._pad[4] = key2[24] | key2[25] << 8;
        this._pad[5] = key2[26] | key2[27] << 8;
        this._pad[6] = key2[28] | key2[29] << 8;
        this._pad[7] = key2[30] | key2[31] << 8;
      }
      Poly13052.prototype._blocks = function(m2, mpos, bytes2) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h22 = this._h[2], h32 = this._h[3], h42 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes2 >= 16) {
          var t0 = m2[mpos + 0] | m2[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m2[mpos + 2] | m2[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m2[mpos + 4] | m2[mpos + 5] << 8;
          h22 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m2[mpos + 6] | m2[mpos + 7] << 8;
          h32 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m2[mpos + 8] | m2[mpos + 9] << 8;
          h42 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          var t5 = m2[mpos + 10] | m2[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m2[mpos + 12] | m2[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m2[mpos + 14] | m2[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          var c2 = 0;
          var d0 = c2;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h22 * (5 * r8);
          d0 += h32 * (5 * r7);
          d0 += h42 * (5 * r6);
          c2 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c2 += d0 >>> 13;
          d0 &= 8191;
          var d1 = c2;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h22 * (5 * r9);
          d1 += h32 * (5 * r8);
          d1 += h42 * (5 * r7);
          c2 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c2 += d1 >>> 13;
          d1 &= 8191;
          var d22 = c2;
          d22 += h0 * r2;
          d22 += h1 * r1;
          d22 += h22 * r0;
          d22 += h32 * (5 * r9);
          d22 += h42 * (5 * r8);
          c2 = d22 >>> 13;
          d22 &= 8191;
          d22 += h5 * (5 * r7);
          d22 += h6 * (5 * r6);
          d22 += h7 * (5 * r5);
          d22 += h8 * (5 * r4);
          d22 += h9 * (5 * r3);
          c2 += d22 >>> 13;
          d22 &= 8191;
          var d3 = c2;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h22 * r1;
          d3 += h32 * r0;
          d3 += h42 * (5 * r9);
          c2 = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c2 += d3 >>> 13;
          d3 &= 8191;
          var d4 = c2;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h22 * r2;
          d4 += h32 * r1;
          d4 += h42 * r0;
          c2 = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c2 += d4 >>> 13;
          d4 &= 8191;
          var d5 = c2;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h22 * r3;
          d5 += h32 * r2;
          d5 += h42 * r1;
          c2 = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c2 += d5 >>> 13;
          d5 &= 8191;
          var d6 = c2;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h22 * r4;
          d6 += h32 * r3;
          d6 += h42 * r2;
          c2 = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c2 += d6 >>> 13;
          d6 &= 8191;
          var d7 = c2;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h22 * r5;
          d7 += h32 * r4;
          d7 += h42 * r3;
          c2 = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c2 += d7 >>> 13;
          d7 &= 8191;
          var d8 = c2;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h22 * r6;
          d8 += h32 * r5;
          d8 += h42 * r4;
          c2 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c2 += d8 >>> 13;
          d8 &= 8191;
          var d9 = c2;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h22 * r7;
          d9 += h32 * r6;
          d9 += h42 * r5;
          c2 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c2 += d9 >>> 13;
          d9 &= 8191;
          c2 = (c2 << 2) + c2 | 0;
          c2 = c2 + d0 | 0;
          d0 = c2 & 8191;
          c2 = c2 >>> 13;
          d1 += c2;
          h0 = d0;
          h1 = d1;
          h22 = d22;
          h32 = d3;
          h42 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes2 -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h22;
        this._h[3] = h32;
        this._h[4] = h42;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };
      Poly13052.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }
        var g3 = new Uint16Array(10);
        var c2;
        var mask2;
        var f4;
        var i3;
        if (this._leftover) {
          i3 = this._leftover;
          this._buffer[i3++] = 1;
          for (; i3 < 16; i3++) {
            this._buffer[i3] = 0;
          }
          this._fin = 1;
          this._blocks(this._buffer, 0, 16);
        }
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        for (i3 = 2; i3 < 10; i3++) {
          this._h[i3] += c2;
          c2 = this._h[i3] >>> 13;
          this._h[i3] &= 8191;
        }
        this._h[0] += c2 * 5;
        c2 = this._h[0] >>> 13;
        this._h[0] &= 8191;
        this._h[1] += c2;
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        this._h[2] += c2;
        g3[0] = this._h[0] + 5;
        c2 = g3[0] >>> 13;
        g3[0] &= 8191;
        for (i3 = 1; i3 < 10; i3++) {
          g3[i3] = this._h[i3] + c2;
          c2 = g3[i3] >>> 13;
          g3[i3] &= 8191;
        }
        g3[9] -= 1 << 13;
        mask2 = (c2 ^ 1) - 1;
        for (i3 = 0; i3 < 10; i3++) {
          g3[i3] &= mask2;
        }
        mask2 = ~mask2;
        for (i3 = 0; i3 < 10; i3++) {
          this._h[i3] = this._h[i3] & mask2 | g3[i3];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
        f4 = this._h[0] + this._pad[0];
        this._h[0] = f4 & 65535;
        for (i3 = 1; i3 < 8; i3++) {
          f4 = (this._h[i3] + this._pad[i3] | 0) + (f4 >>> 16) | 0;
          this._h[i3] = f4 & 65535;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };
      Poly13052.prototype.update = function(m2) {
        var mpos = 0;
        var bytes2 = m2.length;
        var want;
        if (this._leftover) {
          want = 16 - this._leftover;
          if (want > bytes2) {
            want = bytes2;
          }
          for (var i3 = 0; i3 < want; i3++) {
            this._buffer[this._leftover + i3] = m2[mpos + i3];
          }
          bytes2 -= want;
          mpos += want;
          this._leftover += want;
          if (this._leftover < 16) {
            return this;
          }
          this._blocks(this._buffer, 0, 16);
          this._leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this._blocks(m2, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (var i3 = 0; i3 < bytes2; i3++) {
            this._buffer[this._leftover + i3] = m2[mpos + i3];
          }
          this._leftover += bytes2;
        }
        return this;
      };
      Poly13052.prototype.digest = function() {
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };
      Poly13052.prototype.clean = function() {
        wipe_12.wipe(this._buffer);
        wipe_12.wipe(this._r);
        wipe_12.wipe(this._h);
        wipe_12.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true;
        return this;
      };
      return Poly13052;
    }()
  );
  exports2.Poly1305 = Poly1305;
  function oneTimeAuth(key2, data2) {
    var h5 = new Poly1305(key2);
    h5.update(data2);
    var digest9 = h5.digest();
    h5.clean();
    return digest9;
  }
  exports2.oneTimeAuth = oneTimeAuth;
  function equal2(a3, b4) {
    if (a3.length !== exports2.DIGEST_LENGTH || b4.length !== exports2.DIGEST_LENGTH) {
      return false;
    }
    return constant_time_12.equal(a3, b4);
  }
  exports2.equal = equal2;
})(poly1305$2);
const poly1305 = /* @__PURE__ */ getDefaultExportFromCjs(poly1305$2);
const poly1305$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: poly1305
}, [poly1305$2]);
const require$$1$J = /* @__PURE__ */ getAugmentedNamespace(poly1305$1);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var chacha_1 = require$$0$1k;
  var poly1305_1 = require$$1$J;
  var wipe_12 = require$$2$r;
  var binary_12 = require$$0$1l;
  var constant_time_12 = require$$1$K;
  exports2.KEY_LENGTH = 32;
  exports2.NONCE_LENGTH = 12;
  exports2.TAG_LENGTH = 16;
  var ZEROS = new Uint8Array(16);
  var ChaCha20Poly1305 = (
    /** @class */
    function() {
      function ChaCha20Poly13052(key2) {
        this.nonceLength = exports2.NONCE_LENGTH;
        this.tagLength = exports2.TAG_LENGTH;
        if (key2.length !== exports2.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key2);
      }
      ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        wipe_12.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        if (!constant_time_12.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        }
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        wipe_12.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.clean = function() {
        wipe_12.wipe(this._key);
        return this;
      };
      ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h5 = new poly1305_1.Poly1305(authKey);
        if (associatedData) {
          h5.update(associatedData);
          if (associatedData.length % 16 > 0) {
            h5.update(ZEROS.subarray(associatedData.length % 16));
          }
        }
        h5.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
          h5.update(ZEROS.subarray(ciphertext.length % 16));
        }
        var length2 = new Uint8Array(8);
        if (associatedData) {
          binary_12.writeUint64LE(associatedData.length, length2);
        }
        h5.update(length2);
        binary_12.writeUint64LE(ciphertext.length, length2);
        h5.update(length2);
        var tag = h5.digest();
        for (var i3 = 0; i3 < tag.length; i3++) {
          tagOut[i3] = tag[i3];
        }
        h5.clean();
        wipe_12.wipe(tag);
        wipe_12.wipe(length2);
      };
      return ChaCha20Poly13052;
    }()
  );
  exports2.ChaCha20Poly1305 = ChaCha20Poly1305;
})(chacha20poly1305);
var hkdf = {};
var hmac$2 = {};
var hash$4 = {};
Object.defineProperty(hash$4, "__esModule", { value: true });
function isSerializableHash(h5) {
  return typeof h5.saveState !== "undefined" && typeof h5.restoreState !== "undefined" && typeof h5.cleanSavedState !== "undefined";
}
var isSerializableHash_1 = hash$4.isSerializableHash = isSerializableHash;
const hash$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: hash$4,
  isSerializableHash: isSerializableHash_1
}, [hash$4]);
const require$$0$1j = /* @__PURE__ */ getAugmentedNamespace(hash$3);
Object.defineProperty(hmac$2, "__esModule", { value: true });
var hash_1 = require$$0$1j;
var constant_time_1 = require$$1$K;
var wipe_1$2 = require$$2$r;
var HMAC = (
  /** @class */
  function() {
    function HMAC2(hash2, key2) {
      this._finished = false;
      this._inner = new hash2();
      this._outer = new hash2();
      this.blockSize = this._outer.blockSize;
      this.digestLength = this._outer.digestLength;
      var pad2 = new Uint8Array(this.blockSize);
      if (key2.length > this.blockSize) {
        this._inner.update(key2).finish(pad2).clean();
      } else {
        pad2.set(key2);
      }
      for (var i3 = 0; i3 < pad2.length; i3++) {
        pad2[i3] ^= 54;
      }
      this._inner.update(pad2);
      for (var i3 = 0; i3 < pad2.length; i3++) {
        pad2[i3] ^= 54 ^ 92;
      }
      this._outer.update(pad2);
      if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
        this._innerKeyedState = this._inner.saveState();
        this._outerKeyedState = this._outer.saveState();
      }
      wipe_1$2.wipe(pad2);
    }
    HMAC2.prototype.reset = function() {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      }
      this._inner.restoreState(this._innerKeyedState);
      this._outer.restoreState(this._outerKeyedState);
      this._finished = false;
      return this;
    };
    HMAC2.prototype.clean = function() {
      if (hash_1.isSerializableHash(this._inner)) {
        this._inner.cleanSavedState(this._innerKeyedState);
      }
      if (hash_1.isSerializableHash(this._outer)) {
        this._outer.cleanSavedState(this._outerKeyedState);
      }
      this._inner.clean();
      this._outer.clean();
    };
    HMAC2.prototype.update = function(data2) {
      this._inner.update(data2);
      return this;
    };
    HMAC2.prototype.finish = function(out) {
      if (this._finished) {
        this._outer.finish(out);
        return this;
      }
      this._inner.finish(out);
      this._outer.update(out.subarray(0, this.digestLength)).finish(out);
      this._finished = true;
      return this;
    };
    HMAC2.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      this.finish(out);
      return out;
    };
    HMAC2.prototype.saveState = function() {
      if (!hash_1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      }
      return this._inner.saveState();
    };
    HMAC2.prototype.restoreState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      }
      this._inner.restoreState(savedState);
      this._outer.restoreState(this._outerKeyedState);
      this._finished = false;
      return this;
    };
    HMAC2.prototype.cleanSavedState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      }
      this._inner.cleanSavedState(savedState);
    };
    return HMAC2;
  }()
);
var HMAC_1 = hmac$2.HMAC = HMAC;
function hmac(hash2, key2, data2) {
  var h5 = new HMAC(hash2, key2);
  h5.update(data2);
  var digest9 = h5.digest();
  h5.clean();
  return digest9;
}
var hmac_2 = hmac$2.hmac = hmac;
var equal$1 = hmac$2.equal = constant_time_1.equal;
const hmac$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  HMAC: HMAC_1,
  default: hmac$2,
  equal: equal$1,
  hmac: hmac_2
}, [hmac$2]);
const require$$0$1i = /* @__PURE__ */ getAugmentedNamespace(hmac$1);
Object.defineProperty(hkdf, "__esModule", { value: true });
var hmac_1 = require$$0$1i;
var wipe_1$1 = require$$2$r;
var HKDF = (
  /** @class */
  function() {
    function HKDF2(hash2, key2, salt, info) {
      if (salt === void 0) {
        salt = new Uint8Array(0);
      }
      this._counter = new Uint8Array(1);
      this._hash = hash2;
      this._info = info;
      var okm = hmac_1.hmac(this._hash, salt, key2);
      this._hmac = new hmac_1.HMAC(hash2, okm);
      this._buffer = new Uint8Array(this._hmac.digestLength);
      this._bufpos = this._buffer.length;
    }
    HKDF2.prototype._fillBuffer = function() {
      this._counter[0]++;
      var ctr = this._counter[0];
      if (ctr === 0) {
        throw new Error("hkdf: cannot expand more");
      }
      this._hmac.reset();
      if (ctr > 1) {
        this._hmac.update(this._buffer);
      }
      if (this._info) {
        this._hmac.update(this._info);
      }
      this._hmac.update(this._counter);
      this._hmac.finish(this._buffer);
      this._bufpos = 0;
    };
    HKDF2.prototype.expand = function(length2) {
      var out = new Uint8Array(length2);
      for (var i3 = 0; i3 < out.length; i3++) {
        if (this._bufpos === this._buffer.length) {
          this._fillBuffer();
        }
        out[i3] = this._buffer[this._bufpos++];
      }
      return out;
    };
    HKDF2.prototype.clean = function() {
      this._hmac.clean();
      wipe_1$1.wipe(this._buffer);
      wipe_1$1.wipe(this._counter);
      this._bufpos = 0;
    };
    return HKDF2;
  }()
);
var HKDF_1 = hkdf.HKDF = HKDF;
var random$2 = {};
var system$1 = {};
var browser$a = {};
Object.defineProperty(browser$a, "__esModule", { value: true });
var BrowserRandomSource_1 = browser$a.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
    if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
      this._crypto = browserCrypto;
      this.isAvailable = true;
      this.isInstantiated = true;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Browser random byte generator is not available.");
    }
    const out = new Uint8Array(length2);
    for (let i3 = 0; i3 < out.length; i3 += QUOTA) {
      this._crypto.getRandomValues(out.subarray(i3, i3 + Math.min(out.length - i3, QUOTA)));
    }
    return out;
  }
}
BrowserRandomSource_1 = browser$a.BrowserRandomSource = BrowserRandomSource;
const browser$9 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get BrowserRandomSource() {
    return BrowserRandomSource_1;
  },
  default: browser$a
}, [browser$a]);
const require$$0$1h = /* @__PURE__ */ getAugmentedNamespace(browser$9);
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var node$1 = {};
Object.defineProperty(node$1, "__esModule", { value: true });
var NodeRandomSource_1 = node$1.NodeRandomSource = void 0;
const wipe_1 = require$$2$r;
class NodeRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    if (typeof commonjsRequire !== "undefined") {
      const nodeCrypto = require$$0$1v;
      if (nodeCrypto && nodeCrypto.randomBytes) {
        this._crypto = nodeCrypto;
        this.isAvailable = true;
        this.isInstantiated = true;
      }
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Node.js random byte generator is not available.");
    }
    let buffer2 = this._crypto.randomBytes(length2);
    if (buffer2.length !== length2) {
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    }
    const out = new Uint8Array(length2);
    for (let i3 = 0; i3 < out.length; i3++) {
      out[i3] = buffer2[i3];
    }
    (0, wipe_1.wipe)(buffer2);
    return out;
  }
}
NodeRandomSource_1 = node$1.NodeRandomSource = NodeRandomSource;
const node = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get NodeRandomSource() {
    return NodeRandomSource_1;
  },
  default: node$1
}, [node$1]);
const require$$1$I = /* @__PURE__ */ getAugmentedNamespace(node);
Object.defineProperty(system$1, "__esModule", { value: true });
var SystemRandomSource_1 = system$1.SystemRandomSource = void 0;
const browser_1 = require$$0$1h;
const node_1 = require$$1$I;
class SystemRandomSource {
  constructor() {
    this.isAvailable = false;
    this.name = "";
    this._source = new browser_1.BrowserRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Browser";
      return;
    }
    this._source = new node_1.NodeRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Node";
      return;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable) {
      throw new Error("System random byte generator is not available.");
    }
    return this._source.randomBytes(length2);
  }
}
SystemRandomSource_1 = system$1.SystemRandomSource = SystemRandomSource;
const system = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get SystemRandomSource() {
    return SystemRandomSource_1;
  },
  default: system$1
}, [system$1]);
const require$$0$1g = /* @__PURE__ */ getAugmentedNamespace(system);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.randomStringForEntropy = exports2.randomString = exports2.randomUint32 = exports2.randomBytes = exports2.defaultRandomSource = void 0;
  const system_1 = require$$0$1g;
  const binary_12 = require$$0$1l;
  const wipe_12 = require$$2$r;
  exports2.defaultRandomSource = new system_1.SystemRandomSource();
  function randomBytes(length2, prng = exports2.defaultRandomSource) {
    return prng.randomBytes(length2);
  }
  exports2.randomBytes = randomBytes;
  function randomUint32(prng = exports2.defaultRandomSource) {
    const buf2 = randomBytes(4, prng);
    const result = (0, binary_12.readUint32LE)(buf2);
    (0, wipe_12.wipe)(buf2);
    return result;
  }
  exports2.randomUint32 = randomUint32;
  const ALPHANUMERIC2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function randomString(length2, charset = ALPHANUMERIC2, prng = exports2.defaultRandomSource) {
    if (charset.length < 2) {
      throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
      throw new Error("randomString charset is too long");
    }
    let out = "";
    const charsLen = charset.length;
    const maxByte = 256 - 256 % charsLen;
    while (length2 > 0) {
      const buf2 = randomBytes(Math.ceil(length2 * 256 / maxByte), prng);
      for (let i3 = 0; i3 < buf2.length && length2 > 0; i3++) {
        const randomByte = buf2[i3];
        if (randomByte < maxByte) {
          out += charset.charAt(randomByte % charsLen);
          length2--;
        }
      }
      (0, wipe_12.wipe)(buf2);
    }
    return out;
  }
  exports2.randomString = randomString;
  function randomStringForEntropy(bits, charset = ALPHANUMERIC2, prng = exports2.defaultRandomSource) {
    const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length2, charset, prng);
  }
  exports2.randomStringForEntropy = randomStringForEntropy;
})(random$2);
const random = /* @__PURE__ */ getDefaultExportFromCjs(random$2);
const random$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: random
}, [random$2]);
var sha256$4 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var binary_12 = require$$0$1l;
  var wipe_12 = require$$2$r;
  exports2.DIGEST_LENGTH = 32;
  exports2.BLOCK_SIZE = 64;
  var SHA2562 = (
    /** @class */
    function() {
      function SHA2563() {
        this.digestLength = exports2.DIGEST_LENGTH;
        this.blockSize = exports2.BLOCK_SIZE;
        this._state = new Int32Array(8);
        this._temp = new Int32Array(64);
        this._buffer = new Uint8Array(128);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      SHA2563.prototype._initState = function() {
        this._state[0] = 1779033703;
        this._state[1] = 3144134277;
        this._state[2] = 1013904242;
        this._state[3] = 2773480762;
        this._state[4] = 1359893119;
        this._state[5] = 2600822924;
        this._state[6] = 528734635;
        this._state[7] = 1541459225;
      };
      SHA2563.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA2563.prototype.clean = function() {
        wipe_12.wipe(this._buffer);
        wipe_12.wipe(this._temp);
        this.reset();
      };
      SHA2563.prototype.update = function(data2, dataLength) {
        if (dataLength === void 0) {
          dataLength = data2.length;
        }
        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data2[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data2, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data2[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA2563.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left] = 128;
          for (var i3 = left + 1; i3 < padLength - 8; i3++) {
            this._buffer[i3] = 0;
          }
          binary_12.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_12.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i3 = 0; i3 < this.digestLength / 4; i3++) {
          binary_12.writeUint32BE(this._state[i3], out, i3 * 4);
        }
        return this;
      };
      SHA2563.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA2563.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA2563.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA2563.prototype.cleanSavedState = function(savedState) {
        wipe_12.wipe(savedState.state);
        if (savedState.buffer) {
          wipe_12.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA2563;
    }()
  );
  exports2.SHA256 = SHA2562;
  var K3 = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function hashBlocks(w3, v4, p3, pos, len2) {
    while (len2 >= 64) {
      var a3 = v4[0];
      var b4 = v4[1];
      var c2 = v4[2];
      var d3 = v4[3];
      var e2 = v4[4];
      var f4 = v4[5];
      var g3 = v4[6];
      var h5 = v4[7];
      for (var i3 = 0; i3 < 16; i3++) {
        var j2 = pos + i3 * 4;
        w3[i3] = binary_12.readUint32BE(p3, j2);
      }
      for (var i3 = 16; i3 < 64; i3++) {
        var u3 = w3[i3 - 2];
        var t1 = (u3 >>> 17 | u3 << 32 - 17) ^ (u3 >>> 19 | u3 << 32 - 19) ^ u3 >>> 10;
        u3 = w3[i3 - 15];
        var t2 = (u3 >>> 7 | u3 << 32 - 7) ^ (u3 >>> 18 | u3 << 32 - 18) ^ u3 >>> 3;
        w3[i3] = (t1 + w3[i3 - 7] | 0) + (t2 + w3[i3 - 16] | 0);
      }
      for (var i3 = 0; i3 < 64; i3++) {
        var t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f4 ^ ~e2 & g3) | 0) + (h5 + (K3[i3] + w3[i3] | 0) | 0) | 0;
        var t2 = ((a3 >>> 2 | a3 << 32 - 2) ^ (a3 >>> 13 | a3 << 32 - 13) ^ (a3 >>> 22 | a3 << 32 - 22)) + (a3 & b4 ^ a3 & c2 ^ b4 & c2) | 0;
        h5 = g3;
        g3 = f4;
        f4 = e2;
        e2 = d3 + t1 | 0;
        d3 = c2;
        c2 = b4;
        b4 = a3;
        a3 = t1 + t2 | 0;
      }
      v4[0] += a3;
      v4[1] += b4;
      v4[2] += c2;
      v4[3] += d3;
      v4[4] += e2;
      v4[5] += f4;
      v4[6] += g3;
      v4[7] += h5;
      pos += 64;
      len2 -= 64;
    }
    return pos;
  }
  function hash2(data2) {
    var h5 = new SHA2562();
    h5.update(data2);
    var digest9 = h5.digest();
    h5.clean();
    return digest9;
  }
  exports2.hash = hash2;
})(sha256$4);
var x25519 = {};
const require$$0$1f = /* @__PURE__ */ getAugmentedNamespace(random$1);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.sharedKey = exports2.generateKeyPair = exports2.generateKeyPairFromSeed = exports2.scalarMultBase = exports2.scalarMult = exports2.SHARED_KEY_LENGTH = exports2.SECRET_KEY_LENGTH = exports2.PUBLIC_KEY_LENGTH = void 0;
  const random_1 = require$$0$1f;
  const wipe_12 = require$$2$r;
  exports2.PUBLIC_KEY_LENGTH = 32;
  exports2.SECRET_KEY_LENGTH = 32;
  exports2.SHARED_KEY_LENGTH = 32;
  function gf2(init3) {
    const r2 = new Float64Array(16);
    if (init3) {
      for (let i3 = 0; i3 < init3.length; i3++) {
        r2[i3] = init3[i3];
      }
    }
    return r2;
  }
  const _9 = new Uint8Array(32);
  _9[0] = 9;
  const _121665 = gf2([56129, 1]);
  function car25519(o2) {
    let c2 = 1;
    for (let i3 = 0; i3 < 16; i3++) {
      let v4 = o2[i3] + c2 + 65535;
      c2 = Math.floor(v4 / 65536);
      o2[i3] = v4 - c2 * 65536;
    }
    o2[0] += c2 - 1 + 37 * (c2 - 1);
  }
  function sel25519(p3, q2, b4) {
    const c2 = ~(b4 - 1);
    for (let i3 = 0; i3 < 16; i3++) {
      const t2 = c2 & (p3[i3] ^ q2[i3]);
      p3[i3] ^= t2;
      q2[i3] ^= t2;
    }
  }
  function pack25519(o2, n4) {
    const m2 = gf2();
    const t2 = gf2();
    for (let i3 = 0; i3 < 16; i3++) {
      t2[i3] = n4[i3];
    }
    car25519(t2);
    car25519(t2);
    car25519(t2);
    for (let j2 = 0; j2 < 2; j2++) {
      m2[0] = t2[0] - 65517;
      for (let i3 = 1; i3 < 15; i3++) {
        m2[i3] = t2[i3] - 65535 - (m2[i3 - 1] >> 16 & 1);
        m2[i3 - 1] &= 65535;
      }
      m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
      const b4 = m2[15] >> 16 & 1;
      m2[14] &= 65535;
      sel25519(t2, m2, 1 - b4);
    }
    for (let i3 = 0; i3 < 16; i3++) {
      o2[2 * i3] = t2[i3] & 255;
      o2[2 * i3 + 1] = t2[i3] >> 8;
    }
  }
  function unpack25519(o2, n4) {
    for (let i3 = 0; i3 < 16; i3++) {
      o2[i3] = n4[2 * i3] + (n4[2 * i3 + 1] << 8);
    }
    o2[15] &= 32767;
  }
  function add3(o2, a3, b4) {
    for (let i3 = 0; i3 < 16; i3++) {
      o2[i3] = a3[i3] + b4[i3];
    }
  }
  function sub(o2, a3, b4) {
    for (let i3 = 0; i3 < 16; i3++) {
      o2[i3] = a3[i3] - b4[i3];
    }
  }
  function mul5(o2, a3, b4) {
    let v4, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b4[0], b1 = b4[1], b22 = b4[2], b32 = b4[3], b42 = b4[4], b5 = b4[5], b6 = b4[6], b7 = b4[7], b8 = b4[8], b9 = b4[9], b10 = b4[10], b11 = b4[11], b12 = b4[12], b13 = b4[13], b14 = b4[14], b15 = b4[15];
    v4 = a3[0];
    t0 += v4 * b0;
    t1 += v4 * b1;
    t2 += v4 * b22;
    t3 += v4 * b32;
    t4 += v4 * b42;
    t5 += v4 * b5;
    t6 += v4 * b6;
    t7 += v4 * b7;
    t8 += v4 * b8;
    t9 += v4 * b9;
    t10 += v4 * b10;
    t11 += v4 * b11;
    t12 += v4 * b12;
    t13 += v4 * b13;
    t14 += v4 * b14;
    t15 += v4 * b15;
    v4 = a3[1];
    t1 += v4 * b0;
    t2 += v4 * b1;
    t3 += v4 * b22;
    t4 += v4 * b32;
    t5 += v4 * b42;
    t6 += v4 * b5;
    t7 += v4 * b6;
    t8 += v4 * b7;
    t9 += v4 * b8;
    t10 += v4 * b9;
    t11 += v4 * b10;
    t12 += v4 * b11;
    t13 += v4 * b12;
    t14 += v4 * b13;
    t15 += v4 * b14;
    t16 += v4 * b15;
    v4 = a3[2];
    t2 += v4 * b0;
    t3 += v4 * b1;
    t4 += v4 * b22;
    t5 += v4 * b32;
    t6 += v4 * b42;
    t7 += v4 * b5;
    t8 += v4 * b6;
    t9 += v4 * b7;
    t10 += v4 * b8;
    t11 += v4 * b9;
    t12 += v4 * b10;
    t13 += v4 * b11;
    t14 += v4 * b12;
    t15 += v4 * b13;
    t16 += v4 * b14;
    t17 += v4 * b15;
    v4 = a3[3];
    t3 += v4 * b0;
    t4 += v4 * b1;
    t5 += v4 * b22;
    t6 += v4 * b32;
    t7 += v4 * b42;
    t8 += v4 * b5;
    t9 += v4 * b6;
    t10 += v4 * b7;
    t11 += v4 * b8;
    t12 += v4 * b9;
    t13 += v4 * b10;
    t14 += v4 * b11;
    t15 += v4 * b12;
    t16 += v4 * b13;
    t17 += v4 * b14;
    t18 += v4 * b15;
    v4 = a3[4];
    t4 += v4 * b0;
    t5 += v4 * b1;
    t6 += v4 * b22;
    t7 += v4 * b32;
    t8 += v4 * b42;
    t9 += v4 * b5;
    t10 += v4 * b6;
    t11 += v4 * b7;
    t12 += v4 * b8;
    t13 += v4 * b9;
    t14 += v4 * b10;
    t15 += v4 * b11;
    t16 += v4 * b12;
    t17 += v4 * b13;
    t18 += v4 * b14;
    t19 += v4 * b15;
    v4 = a3[5];
    t5 += v4 * b0;
    t6 += v4 * b1;
    t7 += v4 * b22;
    t8 += v4 * b32;
    t9 += v4 * b42;
    t10 += v4 * b5;
    t11 += v4 * b6;
    t12 += v4 * b7;
    t13 += v4 * b8;
    t14 += v4 * b9;
    t15 += v4 * b10;
    t16 += v4 * b11;
    t17 += v4 * b12;
    t18 += v4 * b13;
    t19 += v4 * b14;
    t20 += v4 * b15;
    v4 = a3[6];
    t6 += v4 * b0;
    t7 += v4 * b1;
    t8 += v4 * b22;
    t9 += v4 * b32;
    t10 += v4 * b42;
    t11 += v4 * b5;
    t12 += v4 * b6;
    t13 += v4 * b7;
    t14 += v4 * b8;
    t15 += v4 * b9;
    t16 += v4 * b10;
    t17 += v4 * b11;
    t18 += v4 * b12;
    t19 += v4 * b13;
    t20 += v4 * b14;
    t21 += v4 * b15;
    v4 = a3[7];
    t7 += v4 * b0;
    t8 += v4 * b1;
    t9 += v4 * b22;
    t10 += v4 * b32;
    t11 += v4 * b42;
    t12 += v4 * b5;
    t13 += v4 * b6;
    t14 += v4 * b7;
    t15 += v4 * b8;
    t16 += v4 * b9;
    t17 += v4 * b10;
    t18 += v4 * b11;
    t19 += v4 * b12;
    t20 += v4 * b13;
    t21 += v4 * b14;
    t22 += v4 * b15;
    v4 = a3[8];
    t8 += v4 * b0;
    t9 += v4 * b1;
    t10 += v4 * b22;
    t11 += v4 * b32;
    t12 += v4 * b42;
    t13 += v4 * b5;
    t14 += v4 * b6;
    t15 += v4 * b7;
    t16 += v4 * b8;
    t17 += v4 * b9;
    t18 += v4 * b10;
    t19 += v4 * b11;
    t20 += v4 * b12;
    t21 += v4 * b13;
    t22 += v4 * b14;
    t23 += v4 * b15;
    v4 = a3[9];
    t9 += v4 * b0;
    t10 += v4 * b1;
    t11 += v4 * b22;
    t12 += v4 * b32;
    t13 += v4 * b42;
    t14 += v4 * b5;
    t15 += v4 * b6;
    t16 += v4 * b7;
    t17 += v4 * b8;
    t18 += v4 * b9;
    t19 += v4 * b10;
    t20 += v4 * b11;
    t21 += v4 * b12;
    t22 += v4 * b13;
    t23 += v4 * b14;
    t24 += v4 * b15;
    v4 = a3[10];
    t10 += v4 * b0;
    t11 += v4 * b1;
    t12 += v4 * b22;
    t13 += v4 * b32;
    t14 += v4 * b42;
    t15 += v4 * b5;
    t16 += v4 * b6;
    t17 += v4 * b7;
    t18 += v4 * b8;
    t19 += v4 * b9;
    t20 += v4 * b10;
    t21 += v4 * b11;
    t22 += v4 * b12;
    t23 += v4 * b13;
    t24 += v4 * b14;
    t25 += v4 * b15;
    v4 = a3[11];
    t11 += v4 * b0;
    t12 += v4 * b1;
    t13 += v4 * b22;
    t14 += v4 * b32;
    t15 += v4 * b42;
    t16 += v4 * b5;
    t17 += v4 * b6;
    t18 += v4 * b7;
    t19 += v4 * b8;
    t20 += v4 * b9;
    t21 += v4 * b10;
    t22 += v4 * b11;
    t23 += v4 * b12;
    t24 += v4 * b13;
    t25 += v4 * b14;
    t26 += v4 * b15;
    v4 = a3[12];
    t12 += v4 * b0;
    t13 += v4 * b1;
    t14 += v4 * b22;
    t15 += v4 * b32;
    t16 += v4 * b42;
    t17 += v4 * b5;
    t18 += v4 * b6;
    t19 += v4 * b7;
    t20 += v4 * b8;
    t21 += v4 * b9;
    t22 += v4 * b10;
    t23 += v4 * b11;
    t24 += v4 * b12;
    t25 += v4 * b13;
    t26 += v4 * b14;
    t27 += v4 * b15;
    v4 = a3[13];
    t13 += v4 * b0;
    t14 += v4 * b1;
    t15 += v4 * b22;
    t16 += v4 * b32;
    t17 += v4 * b42;
    t18 += v4 * b5;
    t19 += v4 * b6;
    t20 += v4 * b7;
    t21 += v4 * b8;
    t22 += v4 * b9;
    t23 += v4 * b10;
    t24 += v4 * b11;
    t25 += v4 * b12;
    t26 += v4 * b13;
    t27 += v4 * b14;
    t28 += v4 * b15;
    v4 = a3[14];
    t14 += v4 * b0;
    t15 += v4 * b1;
    t16 += v4 * b22;
    t17 += v4 * b32;
    t18 += v4 * b42;
    t19 += v4 * b5;
    t20 += v4 * b6;
    t21 += v4 * b7;
    t22 += v4 * b8;
    t23 += v4 * b9;
    t24 += v4 * b10;
    t25 += v4 * b11;
    t26 += v4 * b12;
    t27 += v4 * b13;
    t28 += v4 * b14;
    t29 += v4 * b15;
    v4 = a3[15];
    t15 += v4 * b0;
    t16 += v4 * b1;
    t17 += v4 * b22;
    t18 += v4 * b32;
    t19 += v4 * b42;
    t20 += v4 * b5;
    t21 += v4 * b6;
    t22 += v4 * b7;
    t23 += v4 * b8;
    t24 += v4 * b9;
    t25 += v4 * b10;
    t26 += v4 * b11;
    t27 += v4 * b12;
    t28 += v4 * b13;
    t29 += v4 * b14;
    t30 += v4 * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c2 = 1;
    v4 = t0 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t0 = v4 - c2 * 65536;
    v4 = t1 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t1 = v4 - c2 * 65536;
    v4 = t2 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t2 = v4 - c2 * 65536;
    v4 = t3 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t3 = v4 - c2 * 65536;
    v4 = t4 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t4 = v4 - c2 * 65536;
    v4 = t5 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t5 = v4 - c2 * 65536;
    v4 = t6 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t6 = v4 - c2 * 65536;
    v4 = t7 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t7 = v4 - c2 * 65536;
    v4 = t8 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t8 = v4 - c2 * 65536;
    v4 = t9 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t9 = v4 - c2 * 65536;
    v4 = t10 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t10 = v4 - c2 * 65536;
    v4 = t11 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t11 = v4 - c2 * 65536;
    v4 = t12 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t12 = v4 - c2 * 65536;
    v4 = t13 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t13 = v4 - c2 * 65536;
    v4 = t14 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t14 = v4 - c2 * 65536;
    v4 = t15 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t15 = v4 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    c2 = 1;
    v4 = t0 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t0 = v4 - c2 * 65536;
    v4 = t1 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t1 = v4 - c2 * 65536;
    v4 = t2 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t2 = v4 - c2 * 65536;
    v4 = t3 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t3 = v4 - c2 * 65536;
    v4 = t4 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t4 = v4 - c2 * 65536;
    v4 = t5 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t5 = v4 - c2 * 65536;
    v4 = t6 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t6 = v4 - c2 * 65536;
    v4 = t7 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t7 = v4 - c2 * 65536;
    v4 = t8 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t8 = v4 - c2 * 65536;
    v4 = t9 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t9 = v4 - c2 * 65536;
    v4 = t10 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t10 = v4 - c2 * 65536;
    v4 = t11 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t11 = v4 - c2 * 65536;
    v4 = t12 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t12 = v4 - c2 * 65536;
    v4 = t13 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t13 = v4 - c2 * 65536;
    v4 = t14 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t14 = v4 - c2 * 65536;
    v4 = t15 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t15 = v4 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    o2[0] = t0;
    o2[1] = t1;
    o2[2] = t2;
    o2[3] = t3;
    o2[4] = t4;
    o2[5] = t5;
    o2[6] = t6;
    o2[7] = t7;
    o2[8] = t8;
    o2[9] = t9;
    o2[10] = t10;
    o2[11] = t11;
    o2[12] = t12;
    o2[13] = t13;
    o2[14] = t14;
    o2[15] = t15;
  }
  function square(o2, a3) {
    mul5(o2, a3, a3);
  }
  function inv25519(o2, inp) {
    const c2 = gf2();
    for (let i3 = 0; i3 < 16; i3++) {
      c2[i3] = inp[i3];
    }
    for (let i3 = 253; i3 >= 0; i3--) {
      square(c2, c2);
      if (i3 !== 2 && i3 !== 4) {
        mul5(c2, c2, inp);
      }
    }
    for (let i3 = 0; i3 < 16; i3++) {
      o2[i3] = c2[i3];
    }
  }
  function scalarMult(n4, p3) {
    const z2 = new Uint8Array(32);
    const x2 = new Float64Array(80);
    const a3 = gf2(), b4 = gf2(), c2 = gf2(), d3 = gf2(), e2 = gf2(), f4 = gf2();
    for (let i3 = 0; i3 < 31; i3++) {
      z2[i3] = n4[i3];
    }
    z2[31] = n4[31] & 127 | 64;
    z2[0] &= 248;
    unpack25519(x2, p3);
    for (let i3 = 0; i3 < 16; i3++) {
      b4[i3] = x2[i3];
    }
    a3[0] = d3[0] = 1;
    for (let i3 = 254; i3 >= 0; --i3) {
      const r2 = z2[i3 >>> 3] >>> (i3 & 7) & 1;
      sel25519(a3, b4, r2);
      sel25519(c2, d3, r2);
      add3(e2, a3, c2);
      sub(a3, a3, c2);
      add3(c2, b4, d3);
      sub(b4, b4, d3);
      square(d3, e2);
      square(f4, a3);
      mul5(a3, c2, a3);
      mul5(c2, b4, e2);
      add3(e2, a3, c2);
      sub(a3, a3, c2);
      square(b4, a3);
      sub(c2, d3, f4);
      mul5(a3, c2, _121665);
      add3(a3, a3, d3);
      mul5(c2, c2, a3);
      mul5(a3, d3, f4);
      mul5(d3, b4, x2);
      square(b4, e2);
      sel25519(a3, b4, r2);
      sel25519(c2, d3, r2);
    }
    for (let i3 = 0; i3 < 16; i3++) {
      x2[i3 + 16] = a3[i3];
      x2[i3 + 32] = c2[i3];
      x2[i3 + 48] = b4[i3];
      x2[i3 + 64] = d3[i3];
    }
    const x32 = x2.subarray(32);
    const x16 = x2.subarray(16);
    inv25519(x32, x32);
    mul5(x16, x16, x32);
    const q2 = new Uint8Array(32);
    pack25519(q2, x16);
    return q2;
  }
  exports2.scalarMult = scalarMult;
  function scalarMultBase(n4) {
    return scalarMult(n4, _9);
  }
  exports2.scalarMultBase = scalarMultBase;
  function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports2.SECRET_KEY_LENGTH) {
      throw new Error(`x25519: seed must be ${exports2.SECRET_KEY_LENGTH} bytes`);
    }
    const secretKey = new Uint8Array(seed);
    const publicKey = scalarMultBase(secretKey);
    return {
      publicKey,
      secretKey
    };
  }
  exports2.generateKeyPairFromSeed = generateKeyPairFromSeed;
  function generateKeyPair2(prng) {
    const seed = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed);
    (0, wipe_12.wipe)(seed);
    return result;
  }
  exports2.generateKeyPair = generateKeyPair2;
  function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    if (mySecretKey.length !== exports2.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports2.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect public key length");
    }
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
      let zeros2 = 0;
      for (let i3 = 0; i3 < result.length; i3++) {
        zeros2 |= result[i3];
      }
      if (zeros2 === 0) {
        throw new Error("X25519: invalid shared key");
      }
    }
    return result;
  }
  exports2.sharedKey = sharedKey;
})(x25519);
function base(ALPHABET2, name2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i3 = 0; i3 < ALPHABET2.length; i3++) {
    var x2 = ALPHABET2.charAt(i3);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i3;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode5(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i4 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i4 < length2) && it1 !== -1; it1--, i4++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i4;
      pbegin++;
    }
    var it2 = size2 - length2;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe2(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i4 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i4 < length2) && it3 !== -1; it3--, i4++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i4;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length2;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j3 = zeroes;
    while (it4 !== size2) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe2(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode5,
    decodeUnsafe: decodeUnsafe2,
    decode: decode2
  };
}
var src$4 = base;
var _brrp__multiformats_scope_baseX = src$4;
const empty$3 = new Uint8Array(0);
const fromHex = (hex2) => {
  const hexes = hex2.match(/../g);
  return hexes ? new Uint8Array(hexes.map((b4) => parseInt(b4, 16))) : empty$3;
};
const equals$1 = (aa2, bb2) => {
  if (aa2 === bb2)
    return true;
  if (aa2.byteLength !== bb2.byteLength) {
    return false;
  }
  for (let ii2 = 0; ii2 < aa2.byteLength; ii2++) {
    if (aa2[ii2] !== bb2[ii2]) {
      return false;
    }
  }
  return true;
};
const coerce$5 = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString$4 = (str) => new TextEncoder().encode(str);
const toString$5 = (b4) => new TextDecoder().decode(b4);
class Encoder {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$1(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or$1(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$1 = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix, baseEncode);
    this.decoder = new Decoder(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$2 = ({ name: name2, prefix, encode: encode5, decode: decode2 }) => new Codec(name2, prefix, encode5, decode2);
const baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode5, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name2);
  return from$2({
    prefix,
    name: name2,
    encode: encode5,
    decode: (text) => coerce$5(decode2(text))
  });
};
const decode$i = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i3 = 0; i3 < alphabet2.length; ++i3) {
    codes2[alphabet2[i3]] = i3;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i3 = 0; i3 < end2; ++i3) {
    const value = codes2[string2[i3]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$e = (data2, alphabet2, bitsPerChar) => {
  const pad2 = alphabet2[alphabet2.length - 1] === "=";
  const mask2 = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i3 = 0; i3 < data2.length; ++i3) {
    buffer2 = buffer2 << 8 | data2[i3];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask2 & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask2 & buffer2 << bitsPerChar - bits];
  }
  if (pad2) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$2({
    prefix,
    name: name2,
    encode(input) {
      return encode$e(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$i(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const identity$1 = from$2({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString$5(buf2),
  decode: (str) => fromString$4(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$1
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base64$6 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$6,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
const alphabetBytesToChars = alphabet.reduce((p3, c2, i3) => {
  p3[i3] = c2;
  return p3;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p3, c2, i3) => {
  p3[c2.codePointAt(0)] = i3;
  return p3;
}, []);
function encode$d(data2) {
  return data2.reduce((p3, c2) => {
    p3 += alphabetBytesToChars[c2];
    return p3;
  }, "");
}
function decode$h(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from$2({
  prefix: "🚀",
  name: "base256emoji",
  encode: encode$d,
  decode: decode$h
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
var encode_1$1 = encode$c;
var MSB$2 = 128, REST$2 = 127, MSBALL$1 = ~REST$2, INT$1 = Math.pow(2, 31);
function encode$c(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$1) {
    out[offset++] = num & 255 | MSB$2;
    num /= 128;
  }
  while (num & MSBALL$1) {
    out[offset++] = num & 255 | MSB$2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$c.bytes = offset - oldOffset + 1;
  return out;
}
var decode$g = read$2;
var MSB$1$1 = 128, REST$1$1 = 127;
function read$2(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b4, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read$2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b4 = buf2[counter++];
    res += shift < 28 ? (b4 & REST$1$1) << shift : (b4 & REST$1$1) * Math.pow(2, shift);
    shift += 7;
  } while (b4 >= MSB$1$1);
  read$2.bytes = counter - offset;
  return res;
}
var N1$1 = Math.pow(2, 7);
var N2$1 = Math.pow(2, 14);
var N3$1 = Math.pow(2, 21);
var N4$1 = Math.pow(2, 28);
var N5$1 = Math.pow(2, 35);
var N6$1 = Math.pow(2, 42);
var N7$1 = Math.pow(2, 49);
var N8$1 = Math.pow(2, 56);
var N9$1 = Math.pow(2, 63);
var length$3 = function(value) {
  return value < N1$1 ? 1 : value < N2$1 ? 2 : value < N3$1 ? 3 : value < N4$1 ? 4 : value < N5$1 ? 5 : value < N6$1 ? 6 : value < N7$1 ? 7 : value < N8$1 ? 8 : value < N9$1 ? 9 : 10;
};
var varint$2 = {
  encode: encode_1$1,
  decode: decode$g,
  encodingLength: length$3
};
var _brrp_varint = varint$2;
const decode$f = (data2) => {
  const code2 = _brrp_varint.decode(data2);
  return [
    code2,
    _brrp_varint.decode.bytes
  ];
};
const encodeTo = (int2, target, offset = 0) => {
  _brrp_varint.encode(int2, target, offset);
  return target;
};
const encodingLength = (int2) => {
  return _brrp_varint.encodingLength(int2);
};
const create$6 = (code2, digest9) => {
  const size2 = digest9.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size2);
  const bytes2 = new Uint8Array(digestOffset + size2);
  encodeTo(code2, bytes2, 0);
  encodeTo(size2, bytes2, sizeOffset);
  bytes2.set(digest9, digestOffset);
  return new Digest(code2, size2, digest9, bytes2);
};
const decode$e = (multihash) => {
  const bytes2 = coerce$5(multihash);
  const [code2, sizeOffset] = decode$f(bytes2);
  const [size2, digestOffset] = decode$f(bytes2.subarray(sizeOffset));
  const digest9 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest9.byteLength !== size2) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size2, digest9, bytes2);
};
const equals = (a3, b4) => {
  if (a3 === b4) {
    return true;
  } else {
    return a3.code === b4.code && a3.size === b4.size && equals$1(a3.bytes, b4.bytes);
  }
};
class Digest {
  constructor(code2, size2, digest9, bytes2) {
    this.code = code2;
    this.size = size2;
    this.digest = digest9;
    this.bytes = bytes2;
  }
}
const from$1 = ({ name: name2, code: code2, encode: encode5 }) => new Hasher(name2, code2, encode5);
class Hasher {
  constructor(name2, code2, encode5) {
    this.name = name2;
    this.code = code2;
    this.encode = encode5;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create$6(this.code, result) : result.then((digest9) => create$6(this.code, digest9));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
const sha$3 = (name2) => async (data2) => new Uint8Array(await crypto.subtle.digest(name2, data2));
const sha256$3 = from$1({
  name: "sha2-256",
  code: 18,
  encode: sha$3("SHA-256")
});
const name$3 = "raw";
const code$4 = 85;
const encode$b = (node2) => coerce$5(node2);
const decode$d = (data2) => coerce$5(data2);
const raw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code: code$4,
  decode: decode$d,
  encode: encode$b,
  name: name$3
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
class CID {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly$1,
      version: readonly$1,
      multihash: readonly$1,
      bytes: readonly$1,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest9 } = this.multihash;
        const multihash = create$6(code2, digest9);
        return CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0(bytes2, _baseCache, base3 || base58btc.encoder);
      default:
        return toStringV1(bytes2, _baseCache, base3 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate$1(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
      return new CID(version2, code2, multihash, bytes2 || encodeCID(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest9 = decode$e(multihash);
      return CID.create(version2, code2, digest9);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest9) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new CID(version2, code2, digest9, digest9.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID(version2, code2, digest9.bytes);
        return new CID(version2, code2, digest9, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest9) {
    return CID.create(0, DAG_PB_CODE, digest9);
  }
  static createV1(code2, digest9) {
    return CID.create(1, code2, digest9);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce$5(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest9 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID.createV0(digest9) : CID.createV1(specs.codec, digest9);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i3, length2] = decode$f(initialBytes.subarray(offset));
      offset += length2;
      return i3;
    };
    let version2 = next();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size2 = offset + digestSize;
    const multihashSize = size2 - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size: size2
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes(source, base3);
    const cid = CID.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base3 || base32;
      return [
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
const encodeCID = (version2, code2, multihash) => {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version2, bytes2, 0);
  encodeTo(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol = Symbol.for("@ipld/js-cid/CID");
const readonly$1 = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$4 = "0.0.0-dev";
const deprecate$1 = (range2, message) => {
  if (range2.test(version$4)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$7,
  ...base256emoji$1
};
var __spreadArray$1 = globalThis && globalThis.__spreadArray || function(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i3 = 0, l2 = from2.length, ar2; i3 < l2; i3++) {
      if (ar2 || !(i3 in from2)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from2, 0, i3);
        ar2[i3] = from2[i3];
      }
    }
  return to.concat(ar2 || Array.prototype.slice.call(from2));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name2, version2, os2) {
      this.name = name2;
      this.version = version2;
      this.os = os2;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version2) {
      this.version = version2;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name2, version2, os2, bot) {
      this.name = name2;
      this.version = version2;
      this.os = os2;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser2 = _a2[0], regex2 = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex2.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray$1(__spreadArray$1([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os2 = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version2, os2, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version2, os2);
}
function detectOS(ua2) {
  for (var ii2 = 0, count2 = operatingSystemRules.length; ii2 < count2; ii2++) {
    var _a2 = operatingSystemRules[ii2], os2 = _a2[0], regex2 = _a2[1];
    var match = regex2.exec(ua2);
    if (match) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count2) {
  var output = [];
  for (var ii2 = 0; ii2 < count2; ii2++) {
    output.push("0");
  }
  return output;
}
var cjs$d = {};
var tslib$5 = { exports: {} };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
(function(module2) {
  var __extends2;
  var __assign2;
  var __rest2;
  var __decorate2;
  var __param;
  var __metadata;
  var __awaiter2;
  var __generator2;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar2;
  var __importDefault2;
  var __classPrivateFieldGet2;
  var __classPrivateFieldSet2;
  var __createBinding2;
  (function(factory2) {
    var root2 = typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : {};
    {
      factory2(createExporter(root2, createExporter(module2.exports)));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root2) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id2, v4) {
        return exports2[id2] = previous ? previous(id2, v4) : v4;
      };
    }
  })(function(exporter) {
    var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
      d3.__proto__ = b4;
    } || function(d3, b4) {
      for (var p3 in b4)
        if (b4.hasOwnProperty(p3))
          d3[p3] = b4[p3];
    };
    __extends2 = function(d3, b4) {
      extendStatics2(d3, b4);
      function __2() {
        this.constructor = d3;
      }
      d3.prototype = b4 === null ? Object.create(b4) : (__2.prototype = b4.prototype, new __2());
    };
    __assign2 = Object.assign || function(t2) {
      for (var s3, i3 = 1, n4 = arguments.length; i3 < n4; i3++) {
        s3 = arguments[i3];
        for (var p3 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p3))
            t2[p3] = s3[p3];
      }
      return t2;
    };
    __rest2 = function(s3, e2) {
      var t2 = {};
      for (var p3 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p3) && e2.indexOf(p3) < 0)
          t2[p3] = s3[p3];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
          if (e2.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
            t2[p3[i3]] = s3[p3[i3]];
        }
      return t2;
    };
    __decorate2 = function(decorators, target, key2, desc) {
      var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r2 = Reflect.decorate(decorators, target, key2, desc);
      else
        for (var i3 = decorators.length - 1; i3 >= 0; i3--)
          if (d3 = decorators[i3])
            r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
      return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key2) {
        decorator(target, key2, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter2 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator2 = function(thisArg, body) {
      var _3 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f4, y3, t2, g3;
      return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
        return this;
      }), g3;
      function verb(n4) {
        return function(v4) {
          return step([n4, v4]);
        };
      }
      function step(op) {
        if (f4)
          throw new TypeError("Generator is already executing.");
        while (_3)
          try {
            if (f4 = 1, y3 && (t2 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t2 = y3["return"]) && t2.call(y3), 0) : y3.next) && !(t2 = t2.call(y3, op[1])).done)
              return t2;
            if (y3 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _3.label++;
                return { value: op[1], done: false };
              case 5:
                _3.label++;
                y3 = op[1];
                op = [0];
                continue;
              case 7:
                op = _3.ops.pop();
                _3.trys.pop();
                continue;
              default:
                if (!(t2 = _3.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _3 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _3.label = op[1];
                  break;
                }
                if (op[0] === 6 && _3.label < t2[1]) {
                  _3.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _3.label < t2[2]) {
                  _3.label = t2[2];
                  _3.ops.push(op);
                  break;
                }
                if (t2[2])
                  _3.ops.pop();
                _3.trys.pop();
                continue;
            }
            op = body.call(thisArg, _3);
          } catch (e2) {
            op = [6, e2];
            y3 = 0;
          } finally {
            f4 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __createBinding2 = function(o2, m2, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o2[k22] = m2[k3];
    };
    __exportStar = function(m2, exports2) {
      for (var p3 in m2)
        if (p3 !== "default" && !exports2.hasOwnProperty(p3))
          exports2[p3] = m2[p3];
    };
    __values = function(o2) {
      var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o2[s3], i3 = 0;
      if (m2)
        return m2.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i3 >= o2.length)
              o2 = void 0;
            return { value: o2 && o2[i3++], done: !o2 };
          }
        };
      throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o2, n4) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2)
        return o2;
      var i3 = m2.call(o2), r2, ar2 = [], e2;
      try {
        while ((n4 === void 0 || n4-- > 0) && !(r2 = i3.next()).done)
          ar2.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i3["return"]))
            m2.call(i3);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar2;
    };
    __spread = function() {
      for (var ar2 = [], i3 = 0; i3 < arguments.length; i3++)
        ar2 = ar2.concat(__read(arguments[i3]));
      return ar2;
    };
    __spreadArrays = function() {
      for (var s3 = 0, i3 = 0, il2 = arguments.length; i3 < il2; i3++)
        s3 += arguments[i3].length;
      for (var r2 = Array(s3), k3 = 0, i3 = 0; i3 < il2; i3++)
        for (var a3 = arguments[i3], j2 = 0, jl2 = a3.length; j2 < jl2; j2++, k3++)
          r2[k3] = a3[j2];
      return r2;
    };
    __await = function(v4) {
      return this instanceof __await ? (this.v = v4, this) : new __await(v4);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g3 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
      return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
        return this;
      }, i3;
      function verb(n4) {
        if (g3[n4])
          i3[n4] = function(v4) {
            return new Promise(function(a3, b4) {
              q2.push([n4, v4, a3, b4]) > 1 || resume(n4, v4);
            });
          };
      }
      function resume(n4, v4) {
        try {
          step(g3[n4](v4));
        } catch (e2) {
          settle(q2[0][3], e2);
        }
      }
      function step(r2) {
        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f4, v4) {
        if (f4(v4), q2.shift(), q2.length)
          resume(q2[0][0], q2[0][1]);
      }
    };
    __asyncDelegator = function(o2) {
      var i3, p3;
      return i3 = {}, verb("next"), verb("throw", function(e2) {
        throw e2;
      }), verb("return"), i3[Symbol.iterator] = function() {
        return this;
      }, i3;
      function verb(n4, f4) {
        i3[n4] = o2[n4] ? function(v4) {
          return (p3 = !p3) ? { value: __await(o2[n4](v4)), done: n4 === "return" } : f4 ? f4(v4) : v4;
        } : f4;
      }
    };
    __asyncValues = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m2 = o2[Symbol.asyncIterator], i3;
      return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
        return this;
      }, i3);
      function verb(n4) {
        i3[n4] = o2[n4] && function(v4) {
          return new Promise(function(resolve, reject) {
            v4 = o2[n4](v4), settle(resolve, reject, v4.done, v4.value);
          });
        };
      }
      function settle(resolve, reject, d3, v4) {
        Promise.resolve(v4).then(function(v5) {
          resolve({ value: v5, done: d3 });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw2) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw2 });
      } else {
        cooked.raw = raw2;
      }
      return cooked;
    };
    __importStar2 = function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k3 in mod2)
          if (Object.hasOwnProperty.call(mod2, k3))
            result[k3] = mod2[k3];
      }
      result["default"] = mod2;
      return result;
    };
    __importDefault2 = function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    __classPrivateFieldGet2 = function(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return privateMap.get(receiver);
    };
    __classPrivateFieldSet2 = function(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }
      privateMap.set(receiver, value);
      return value;
    };
    exporter("__extends", __extends2);
    exporter("__assign", __assign2);
    exporter("__rest", __rest2);
    exporter("__decorate", __decorate2);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter2);
    exporter("__generator", __generator2);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding2);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar2);
    exporter("__importDefault", __importDefault2);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
  });
})(tslib$5);
var tslibExports$1 = tslib$5.exports;
const tslib$3 = /* @__PURE__ */ getDefaultExportFromCjs(tslibExports$1);
const tslib$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: tslib$3
}, [tslibExports$1]);
const require$$0$1e = /* @__PURE__ */ getAugmentedNamespace(tslib$4);
var utils$c = {};
var delay$1 = {};
var hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay)
    return delay$1;
  hasRequiredDelay = 1;
  Object.defineProperty(delay$1, "__esModule", { value: true });
  delay$1.delay = void 0;
  function delay2(timeout2) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(true);
      }, timeout2);
    });
  }
  delay$1.delay = delay2;
  return delay$1;
}
var convert = {};
var constants$9 = {};
var misc$3 = {};
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc)
    return misc$3;
  hasRequiredMisc = 1;
  Object.defineProperty(misc$3, "__esModule", { value: true });
  misc$3.ONE_THOUSAND = misc$3.ONE_HUNDRED = void 0;
  misc$3.ONE_HUNDRED = 100;
  misc$3.ONE_THOUSAND = 1e3;
  return misc$3;
}
var time$3 = {};
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime)
    return time$3;
  hasRequiredTime = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ONE_YEAR = exports2.FOUR_WEEKS = exports2.THREE_WEEKS = exports2.TWO_WEEKS = exports2.ONE_WEEK = exports2.THIRTY_DAYS = exports2.SEVEN_DAYS = exports2.FIVE_DAYS = exports2.THREE_DAYS = exports2.ONE_DAY = exports2.TWENTY_FOUR_HOURS = exports2.TWELVE_HOURS = exports2.SIX_HOURS = exports2.THREE_HOURS = exports2.ONE_HOUR = exports2.SIXTY_MINUTES = exports2.THIRTY_MINUTES = exports2.TEN_MINUTES = exports2.FIVE_MINUTES = exports2.ONE_MINUTE = exports2.SIXTY_SECONDS = exports2.THIRTY_SECONDS = exports2.TEN_SECONDS = exports2.FIVE_SECONDS = exports2.ONE_SECOND = void 0;
    exports2.ONE_SECOND = 1;
    exports2.FIVE_SECONDS = 5;
    exports2.TEN_SECONDS = 10;
    exports2.THIRTY_SECONDS = 30;
    exports2.SIXTY_SECONDS = 60;
    exports2.ONE_MINUTE = exports2.SIXTY_SECONDS;
    exports2.FIVE_MINUTES = exports2.ONE_MINUTE * 5;
    exports2.TEN_MINUTES = exports2.ONE_MINUTE * 10;
    exports2.THIRTY_MINUTES = exports2.ONE_MINUTE * 30;
    exports2.SIXTY_MINUTES = exports2.ONE_MINUTE * 60;
    exports2.ONE_HOUR = exports2.SIXTY_MINUTES;
    exports2.THREE_HOURS = exports2.ONE_HOUR * 3;
    exports2.SIX_HOURS = exports2.ONE_HOUR * 6;
    exports2.TWELVE_HOURS = exports2.ONE_HOUR * 12;
    exports2.TWENTY_FOUR_HOURS = exports2.ONE_HOUR * 24;
    exports2.ONE_DAY = exports2.TWENTY_FOUR_HOURS;
    exports2.THREE_DAYS = exports2.ONE_DAY * 3;
    exports2.FIVE_DAYS = exports2.ONE_DAY * 5;
    exports2.SEVEN_DAYS = exports2.ONE_DAY * 7;
    exports2.THIRTY_DAYS = exports2.ONE_DAY * 30;
    exports2.ONE_WEEK = exports2.SEVEN_DAYS;
    exports2.TWO_WEEKS = exports2.ONE_WEEK * 2;
    exports2.THREE_WEEKS = exports2.ONE_WEEK * 3;
    exports2.FOUR_WEEKS = exports2.ONE_WEEK * 4;
    exports2.ONE_YEAR = exports2.ONE_DAY * 365;
  })(time$3);
  return time$3;
}
var hasRequiredConstants$2;
function requireConstants$2() {
  if (hasRequiredConstants$2)
    return constants$9;
  hasRequiredConstants$2 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_12 = require$$0$1e;
    tslib_12.__exportStar(requireMisc(), exports2);
    tslib_12.__exportStar(requireTime(), exports2);
  })(constants$9);
  return constants$9;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert)
    return convert;
  hasRequiredConvert = 1;
  Object.defineProperty(convert, "__esModule", { value: true });
  convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const constants_12 = requireConstants$2();
  function toMiliseconds(seconds) {
    return seconds * constants_12.ONE_THOUSAND;
  }
  convert.toMiliseconds = toMiliseconds;
  function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_12.ONE_THOUSAND);
  }
  convert.fromMiliseconds = fromMiliseconds;
  return convert;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1)
    return utils$c;
  hasRequiredUtils$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_12 = require$$0$1e;
    tslib_12.__exportStar(requireDelay(), exports2);
    tslib_12.__exportStar(requireConvert(), exports2);
  })(utils$c);
  return utils$c;
}
var watch$2 = {};
var hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1)
    return watch$2;
  hasRequiredWatch$1 = 1;
  Object.defineProperty(watch$2, "__esModule", { value: true });
  watch$2.Watch = void 0;
  class Watch {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(label) {
      if (this.timestamps.has(label)) {
        throw new Error(`Watch already started for label: ${label}`);
      }
      this.timestamps.set(label, { started: Date.now() });
    }
    stop(label) {
      const timestamp2 = this.get(label);
      if (typeof timestamp2.elapsed !== "undefined") {
        throw new Error(`Watch already stopped for label: ${label}`);
      }
      const elapsed = Date.now() - timestamp2.started;
      this.timestamps.set(label, { started: timestamp2.started, elapsed });
    }
    get(label) {
      const timestamp2 = this.timestamps.get(label);
      if (typeof timestamp2 === "undefined") {
        throw new Error(`No timestamp found for label: ${label}`);
      }
      return timestamp2;
    }
    elapsed(label) {
      const timestamp2 = this.get(label);
      const elapsed = timestamp2.elapsed || Date.now() - timestamp2.started;
      return elapsed;
    }
  }
  watch$2.Watch = Watch;
  watch$2.default = Watch;
  return watch$2;
}
var types$7 = {};
var watch$1 = {};
var hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch)
    return watch$1;
  hasRequiredWatch = 1;
  Object.defineProperty(watch$1, "__esModule", { value: true });
  watch$1.IWatch = void 0;
  class IWatch {
  }
  watch$1.IWatch = IWatch;
  return watch$1;
}
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1)
    return types$7;
  hasRequiredTypes$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_12 = require$$0$1e;
    tslib_12.__exportStar(requireWatch(), exports2);
  })(types$7);
  return types$7;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  const tslib_12 = require$$0$1e;
  tslib_12.__exportStar(requireUtils$1(), exports2);
  tslib_12.__exportStar(requireWatch$1(), exports2);
  tslib_12.__exportStar(requireTypes$1(), exports2);
  tslib_12.__exportStar(requireConstants$2(), exports2);
})(cjs$d);
const index$L = /* @__PURE__ */ getDefaultExportFromCjs(cjs$d);
const cjs$c = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$L
}, [cjs$d]);
var cjs$b = {};
Object.defineProperty(cjs$b, "__esModule", { value: true });
var getLocalStorage_1$2 = cjs$b.getLocalStorage = getLocalStorageOrThrow_1$2 = cjs$b.getLocalStorageOrThrow = getCrypto_1$2 = cjs$b.getCrypto = getCryptoOrThrow_1$2 = cjs$b.getCryptoOrThrow = getLocation_1$2 = cjs$b.getLocation = getLocationOrThrow_1$2 = cjs$b.getLocationOrThrow = getNavigator_1$2 = cjs$b.getNavigator = getNavigatorOrThrow_1$2 = cjs$b.getNavigatorOrThrow = getDocument_1$2 = cjs$b.getDocument = getDocumentOrThrow_1$2 = cjs$b.getDocumentOrThrow = getFromWindowOrThrow_1$2 = cjs$b.getFromWindowOrThrow = getFromWindow_1$2 = cjs$b.getFromWindow = void 0;
function getFromWindow$2(name2) {
  let res = void 0;
  if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
    res = window[name2];
  }
  return res;
}
var getFromWindow_1$2 = cjs$b.getFromWindow = getFromWindow$2;
function getFromWindowOrThrow$2(name2) {
  const res = getFromWindow$2(name2);
  if (!res) {
    throw new Error(`${name2} is not defined in Window`);
  }
  return res;
}
var getFromWindowOrThrow_1$2 = cjs$b.getFromWindowOrThrow = getFromWindowOrThrow$2;
function getDocumentOrThrow$2() {
  return getFromWindowOrThrow$2("document");
}
var getDocumentOrThrow_1$2 = cjs$b.getDocumentOrThrow = getDocumentOrThrow$2;
function getDocument$2() {
  return getFromWindow$2("document");
}
var getDocument_1$2 = cjs$b.getDocument = getDocument$2;
function getNavigatorOrThrow$2() {
  return getFromWindowOrThrow$2("navigator");
}
var getNavigatorOrThrow_1$2 = cjs$b.getNavigatorOrThrow = getNavigatorOrThrow$2;
function getNavigator$2() {
  return getFromWindow$2("navigator");
}
var getNavigator_1$2 = cjs$b.getNavigator = getNavigator$2;
function getLocationOrThrow$2() {
  return getFromWindowOrThrow$2("location");
}
var getLocationOrThrow_1$2 = cjs$b.getLocationOrThrow = getLocationOrThrow$2;
function getLocation$2() {
  return getFromWindow$2("location");
}
var getLocation_1$2 = cjs$b.getLocation = getLocation$2;
function getCryptoOrThrow$2() {
  return getFromWindowOrThrow$2("crypto");
}
var getCryptoOrThrow_1$2 = cjs$b.getCryptoOrThrow = getCryptoOrThrow$2;
function getCrypto$2() {
  return getFromWindow$2("crypto");
}
var getCrypto_1$2 = cjs$b.getCrypto = getCrypto$2;
function getLocalStorageOrThrow$2() {
  return getFromWindowOrThrow$2("localStorage");
}
var getLocalStorageOrThrow_1$2 = cjs$b.getLocalStorageOrThrow = getLocalStorageOrThrow$2;
function getLocalStorage$2() {
  return getFromWindow$2("localStorage");
}
getLocalStorage_1$2 = cjs$b.getLocalStorage = getLocalStorage$2;
const cjs$a = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: cjs$b,
  get getCrypto() {
    return getCrypto_1$2;
  },
  get getCryptoOrThrow() {
    return getCryptoOrThrow_1$2;
  },
  get getDocument() {
    return getDocument_1$2;
  },
  get getDocumentOrThrow() {
    return getDocumentOrThrow_1$2;
  },
  get getFromWindow() {
    return getFromWindow_1$2;
  },
  get getFromWindowOrThrow() {
    return getFromWindowOrThrow_1$2;
  },
  get getLocalStorage() {
    return getLocalStorage_1$2;
  },
  get getLocalStorageOrThrow() {
    return getLocalStorageOrThrow_1$2;
  },
  get getLocation() {
    return getLocation_1$2;
  },
  get getLocationOrThrow() {
    return getLocationOrThrow_1$2;
  },
  get getNavigator() {
    return getNavigator_1$2;
  },
  get getNavigatorOrThrow() {
    return getNavigatorOrThrow_1$2;
  }
}, [cjs$b]);
var cjs$9 = {};
const require$$0$1d = /* @__PURE__ */ getAugmentedNamespace(cjs$a);
Object.defineProperty(cjs$9, "__esModule", { value: true });
cjs$9.getWindowMetadata = void 0;
const window_getters_1$2 = require$$0$1d;
function getWindowMetadata$2() {
  let doc;
  let loc;
  try {
    doc = window_getters_1$2.getDocumentOrThrow();
    loc = window_getters_1$2.getLocationOrThrow();
  } catch (e2) {
    return null;
  }
  function getIcons() {
    const links2 = doc.getElementsByTagName("link");
    const icons2 = [];
    for (let i3 = 0; i3 < links2.length; i3++) {
      const link = links2[i3];
      const rel = link.getAttribute("rel");
      if (rel) {
        if (rel.toLowerCase().indexOf("icon") > -1) {
          const href = link.getAttribute("href");
          if (href) {
            if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
              let absoluteHref = loc.protocol + "//" + loc.host;
              if (href.indexOf("/") === 0) {
                absoluteHref += href;
              } else {
                const path = loc.pathname.split("/");
                path.pop();
                const finalPath = path.join("/");
                absoluteHref += finalPath + "/" + href;
              }
              icons2.push(absoluteHref);
            } else if (href.indexOf("//") === 0) {
              const absoluteUrl = loc.protocol + href;
              icons2.push(absoluteUrl);
            } else {
              icons2.push(href);
            }
          }
        }
      }
    }
    return icons2;
  }
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc.getElementsByTagName("meta");
    for (let i3 = 0; i3 < metaTags.length; i3++) {
      const tag = metaTags[i3];
      const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
        if (attr) {
          return args.includes(attr);
        }
        return false;
      });
      if (attributes.length && attributes) {
        const content = tag.getAttribute("content");
        if (content) {
          return content;
        }
      }
    }
    return "";
  }
  function getName() {
    let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    if (!name3) {
      name3 = doc.title;
    }
    return name3;
  }
  function getDescription() {
    const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
    return description2;
  }
  const name2 = getName();
  const description = getDescription();
  const url = loc.origin;
  const icons = getIcons();
  const meta = {
    description,
    url,
    icons,
    name: name2
  };
  return meta;
}
cjs$9.getWindowMetadata = getWindowMetadata$2;
var queryString$2 = {};
var strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
const index$K = /* @__PURE__ */ getDefaultExportFromCjs(strictUriEncode);
const strictUriEncode$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$K
}, [strictUriEncode]);
const require$$0$1c = /* @__PURE__ */ getAugmentedNamespace(strictUriEncode$1);
var token$2 = "%[a-f0-9]{2}";
var singleMatcher$2 = new RegExp("(" + token$2 + ")|([^%]+?)", "gi");
var multiMatcher$2 = new RegExp("(" + token$2 + ")+", "gi");
function decodeComponents$2(components, split) {
  try {
    return [decodeURIComponent(components.join(""))];
  } catch (err) {
  }
  if (components.length === 1) {
    return components;
  }
  split = split || 1;
  var left = components.slice(0, split);
  var right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents$2(left), decodeComponents$2(right));
}
function decode$c(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher$2) || [];
    for (var i3 = 1; i3 < tokens.length; i3++) {
      input = decodeComponents$2(tokens, i3).join("");
      tokens = input.match(singleMatcher$2) || [];
    }
    return input;
  }
}
function customDecodeURIComponent$2(input) {
  var replaceMap = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  };
  var match = multiMatcher$2.exec(input);
  while (match) {
    try {
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode$c(match[0]);
      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }
    match = multiMatcher$2.exec(input);
  }
  replaceMap["%C2"] = "�";
  var entries2 = Object.keys(replaceMap);
  for (var i3 = 0; i3 < entries2.length; i3++) {
    var key2 = entries2[i3];
    input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
  }
  return input;
}
var decodeUriComponent$4 = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent$2(encodedURI);
  }
};
const index$J = /* @__PURE__ */ getDefaultExportFromCjs(decodeUriComponent$4);
const decodeUriComponent$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$J
}, [decodeUriComponent$4]);
const require$$1$H = /* @__PURE__ */ getAugmentedNamespace(decodeUriComponent$5);
var splitOnFirst = (string2, separator) => {
  if (!(typeof string2 === "string" && typeof separator === "string")) {
    throw new TypeError("Expected the arguments to be of type `string`");
  }
  if (separator === "") {
    return [string2];
  }
  const separatorIndex = string2.indexOf(separator);
  if (separatorIndex === -1) {
    return [string2];
  }
  return [
    string2.slice(0, separatorIndex),
    string2.slice(separatorIndex + separator.length)
  ];
};
const index$I = /* @__PURE__ */ getDefaultExportFromCjs(splitOnFirst);
const splitOnFirst$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$I
}, [splitOnFirst]);
const require$$2$q = /* @__PURE__ */ getAugmentedNamespace(splitOnFirst$1);
var filterObj = function(obj, predicate) {
  var ret = {};
  var keys2 = Object.keys(obj);
  var isArr = Array.isArray(predicate);
  for (var i3 = 0; i3 < keys2.length; i3++) {
    var key2 = keys2[i3];
    var val = obj[key2];
    if (isArr ? predicate.indexOf(key2) !== -1 : predicate(key2, val, obj)) {
      ret[key2] = val;
    }
  }
  return ret;
};
const index$H = /* @__PURE__ */ getDefaultExportFromCjs(filterObj);
const filterObj$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$H
}, [filterObj]);
const require$$3$h = /* @__PURE__ */ getAugmentedNamespace(filterObj$1);
(function(exports2) {
  const strictUriEncode2 = require$$0$1c;
  const decodeComponent = require$$1$H;
  const splitOnFirst2 = require$$2$q;
  const filterObject = require$$3$h;
  const isNullOrUndefined = (value) => value === null || value === void 0;
  const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case "index":
        return (key2) => (result, value) => {
          const index2 = result.length;
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode5(key2, options), "[", index2, "]"].join("")];
          }
          return [
            ...result,
            [encode5(key2, options), "[", encode5(index2, options), "]=", encode5(value, options)].join("")
          ];
        };
      case "bracket":
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode5(key2, options), "[]"].join("")];
          }
          return [...result, [encode5(key2, options), "[]=", encode5(value, options)].join("")];
        };
      case "colon-list-separator":
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode5(key2, options), ":list="].join("")];
          }
          return [...result, [encode5(key2, options), ":list=", encode5(value, options)].join("")];
        };
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          value = value === null ? "" : value;
          if (result.length === 0) {
            return [[encode5(key2, options), keyValueSep, encode5(value, options)].join("")];
          }
          return [[result, encode5(value, options)].join(options.arrayFormatSeparator)];
        };
      }
      default:
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, encode5(key2, options)];
          }
          return [...result, [encode5(key2, options), "=", encode5(value, options)].join("")];
        };
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case "index":
        return (key2, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key2);
          key2 = key2.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = {};
          }
          accumulator[key2][result[1]] = value;
        };
      case "bracket":
        return (key2, value, accumulator) => {
          result = /(\[\])$/.exec(key2);
          key2 = key2.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = [value];
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
      case "colon-list-separator":
        return (key2, value, accumulator) => {
          result = /(:list)$/.exec(key2);
          key2 = key2.replace(/:list$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = [value];
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
      case "comma":
      case "separator":
        return (key2, value, accumulator) => {
          const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
          accumulator[key2] = newValue;
        };
      case "bracket-separator":
        return (key2, value, accumulator) => {
          const isArray2 = /(\[\])$/.test(key2);
          key2 = key2.replace(/\[\]$/, "");
          if (!isArray2) {
            accumulator[key2] = value ? decode2(value, options) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
          if (accumulator[key2] === void 0) {
            accumulator[key2] = arrayValue;
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], arrayValue);
        };
      default:
        return (key2, value, accumulator) => {
          if (accumulator[key2] === void 0) {
            accumulator[key2] = value;
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode5(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode2(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a3, b4) => Number(a3) - Number(b4)).map((key2) => input[key2]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash2 = url.slice(hashStart);
    }
    return hash2;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function parse2(query2, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);
    const ret = /* @__PURE__ */ Object.create(null);
    if (typeof query2 !== "string") {
      return ret;
    }
    query2 = query2.trim().replace(/^[?#&]/, "");
    if (!query2) {
      return ret;
    }
    for (const param of query2.split("&")) {
      if (param === "") {
        continue;
      }
      let [key2, value] = splitOnFirst2(options.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
      formatter(decode2(key2, options), value, ret);
    }
    for (const key2 of Object.keys(ret)) {
      const value = ret[key2];
      if (typeof value === "object" && value !== null) {
        for (const k3 of Object.keys(value)) {
          value[k3] = parseValue(value[k3], options);
        }
      } else {
        ret[key2] = parseValue(value, options);
      }
    }
    if (options.sort === false) {
      return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
      const value = ret[key2];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key2] = keysSorter(value);
      } else {
        result[key2] = value;
      }
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  exports2.extract = extract;
  exports2.parse = parse2;
  exports2.stringify = (object2, options) => {
    if (!object2) {
      return "";
    }
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object2[key2]) || options.skipEmptyString && object2[key2] === "";
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key2 of Object.keys(object2)) {
      if (!shouldFilter(key2)) {
        objectCopy[key2] = object2[key2];
      }
    }
    const keys2 = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys2.sort(options.sort);
    }
    return keys2.map((key2) => {
      const value = object2[key2];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode5(key2, options);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === "bracket-separator") {
          return encode5(key2, options) + "[]";
        }
        return value.reduce(formatter(key2), []).join("&");
      }
      return encode5(key2, options) + "=" + encode5(value, options);
    }).filter((x2) => x2.length > 0).join("&");
  };
  exports2.parseUrl = (url, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url_, hash2] = splitOnFirst2(url, "#");
    return Object.assign(
      {
        url: url_.split("?")[0] || "",
        query: parse2(extract(url), options)
      },
      options && options.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options) } : {}
    );
  };
  exports2.stringifyUrl = (object2, options) => {
    options = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options);
    const url = removeHash(object2.url).split("?")[0] || "";
    const queryFromUrl = exports2.extract(object2.url);
    const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
    const query2 = Object.assign(parsedQueryFromUrl, object2.query);
    let queryString2 = exports2.stringify(query2, options);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash2 = getHash(object2.url);
    if (object2.fragmentIdentifier) {
      hash2 = `#${options[encodeFragmentIdentifier] ? encode5(object2.fragmentIdentifier, options) : object2.fragmentIdentifier}`;
    }
    return `${url}${queryString2}${hash2}`;
  };
  exports2.pick = (input, filter2, options) => {
    options = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options);
    const { url, query: query2, fragmentIdentifier } = exports2.parseUrl(input, options);
    return exports2.stringifyUrl({
      url,
      query: filterObject(query2, filter2),
      fragmentIdentifier
    }, options);
  };
  exports2.exclude = (input, filter2, options) => {
    const exclusionFilter = Array.isArray(filter2) ? (key2) => !filter2.includes(key2) : (key2, value) => !filter2(key2, value);
    return exports2.pick(input, exclusionFilter, options);
  };
})(queryString$2);
const RELAY_JSONRPC = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};
function Un(e2, n4 = []) {
  const t2 = [];
  return Object.keys(e2).forEach((r2) => {
    if (n4.length && !n4.includes(r2))
      return;
    const o2 = e2[r2];
    t2.push(...o2.accounts);
  }), t2;
}
const nn$2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
function U$5(e2, n4) {
  const { message: t2, code: r2 } = nn$2[e2];
  return { message: n4 ? `${t2} ${n4}` : t2, code: r2 };
}
function k$6(e2, n4) {
  return Array.isArray(e2) ? typeof n4 < "u" && e2.length ? e2.every(n4) : true : false;
}
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key2, value) {
  if (key2 === "__proto__" || key2 === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key2);
    return;
  }
  return value;
}
function warnKeyDropped(key2) {
  console.warn(`[destr] Dropping "${key2}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  const _value = value.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    value[0] === '"' && value.at(-1) === '"' && !value.includes("\\")
  ) {
    return _value.slice(1, -1);
  }
  if (_value.length <= 9) {
    const _lval = _value.toLowerCase();
    if (_lval === "true") {
      return true;
    }
    if (_lval === "false") {
      return false;
    }
    if (_lval === "undefined") {
      return void 0;
    }
    if (_lval === "null") {
      return null;
    }
    if (_lval === "nan") {
      return Number.NaN;
    }
    if (_lval === "infinity") {
      return Number.POSITIVE_INFINITY;
    }
    if (_lval === "-infinity") {
      return Number.NEGATIVE_INFINITY;
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}
var buffer$7 = {};
var base64Js$1 = {};
var byteLength_1 = base64Js$1.byteLength = byteLength;
var toByteArray_1 = base64Js$1.toByteArray = toByteArray;
var fromByteArray_1 = base64Js$1.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$3 = 0, len = code$3.length; i$3 < len; ++i$3) {
  lookup[i$3] = code$3[i$3];
  revLookup[code$3.charCodeAt(i$3)] = i$3;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i3;
  for (i3 = 0; i3 < len2; i3 += 4) {
    tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
    arr2[curByte++] = tmp >> 16 & 255;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  return arr2;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end2) {
  var tmp;
  var output = [];
  for (var i3 = start; i3 < end2; i3 += 3) {
    tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
const base64Js = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  byteLength: byteLength_1,
  default: base64Js$1,
  fromByteArray: fromByteArray_1,
  toByteArray: toByteArray_1
}, [base64Js$1]);
const require$$0$1b = /* @__PURE__ */ getAugmentedNamespace(base64Js);
var ieee754$1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var read$1 = ieee754$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i3 = isLE ? nBytes - 1 : 0;
  var d3 = isLE ? -1 : 1;
  var s3 = buffer2[offset + i3];
  i3 += d3;
  e2 = s3 & (1 << -nBits) - 1;
  s3 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i3], i3 += d3, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i3], i3 += d3, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s3 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s3 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
var write = ieee754$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i3 = isLE ? 0 : nBytes - 1;
  var d3 = isLE ? 1 : -1;
  var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt2 / c2;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i3] = m2 & 255, i3 += d3, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i3] = e2 & 255, i3 += d3, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset + i3 - d3] |= s3 * 128;
};
const ieee754 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ieee754$1,
  read: read$1,
  write
}, [ieee754$1]);
const require$$1$G = /* @__PURE__ */ getAugmentedNamespace(ieee754);
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  var base642 = require$$0$1b;
  var ieee7542 = require$$1$G;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      var arr2 = new Uint8Array(1);
      var proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr2, proto);
      return arr2.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    var buf2 = new Uint8Array(length2);
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    var b4 = fromObject(value);
    if (b4)
      return b4;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(
        value[Symbol.toPrimitive]("string"),
        encodingOrOffset,
        length2
      );
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc3(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc3(size2, fill, encoding);
  };
  function allocUnsafe2(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length2 = byteLength2(string2, encoding) | 0;
    var buf2 = createBuffer(length2);
    var actual = buf2.write(string2, encoding);
    if (actual !== length2) {
      buf2 = buf2.slice(0, actual);
    }
    return buf2;
  }
  function fromArrayLike(array2) {
    var length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
    var buf2 = createBuffer(length2);
    for (var i3 = 0; i3 < length2; i3 += 1) {
      buf2[i3] = array2[i3] & 255;
    }
    return buf2;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array2, byteOffset, length2) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf2;
    if (byteOffset === void 0 && length2 === void 0) {
      buf2 = new Uint8Array(array2);
    } else if (length2 === void 0) {
      buf2 = new Uint8Array(array2, byteOffset);
    } else {
      buf2 = new Uint8Array(array2, byteOffset, length2);
    }
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      var len2 = checked(obj.length) | 0;
      var buf2 = createBuffer(len2);
      if (buf2.length === 0) {
        return buf2;
      }
      obj.copy(buf2, 0, 0, len2);
      return buf2;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer3(b4) {
    return b4 != null && b4._isBuffer === true && b4 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a3, b4) {
    if (isInstance(a3, Uint8Array))
      a3 = Buffer2.from(a3, a3.offset, a3.byteLength);
    if (isInstance(b4, Uint8Array))
      b4 = Buffer2.from(b4, b4.offset, b4.byteLength);
    if (!Buffer2.isBuffer(a3) || !Buffer2.isBuffer(b4)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a3 === b4)
      return 0;
    var x2 = a3.length;
    var y3 = b4.length;
    for (var i3 = 0, len2 = Math.min(x2, y3); i3 < len2; ++i3) {
      if (a3[i3] !== b4[i3]) {
        x2 = a3[i3];
        y3 = b4[i3];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    var i3;
    if (length2 === void 0) {
      length2 = 0;
      for (i3 = 0; i3 < list.length; ++i3) {
        length2 += list[i3].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length2);
    var pos = 0;
    for (i3 = 0; i3 < list.length; ++i3) {
      var buf2 = list[i3];
      if (isInstance(buf2, Uint8Array)) {
        if (pos + buf2.length > buffer2.length) {
          Buffer2.from(buf2).copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf2,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf2.copy(buffer2, pos);
      }
      pos += buf2.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    var len2 = string2.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end2) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice2(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b4, n4, m2) {
    var i3 = b4[n4];
    b4[n4] = b4[m2];
    b4[m2] = i3;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i3 = 0; i3 < len2; i3 += 2) {
      swap(this, i3, i3 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i3 = 0; i3 < len2; i3 += 4) {
      swap(this, i3, i3 + 3);
      swap(this, i3 + 1, i3 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i3 = 0; i3 < len2; i3 += 8) {
      swap(this, i3, i3 + 7);
      swap(this, i3 + 1, i3 + 6);
      swap(this, i3 + 2, i3 + 5);
      swap(this, i3 + 3, i3 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    var length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice2(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b4) {
    if (!Buffer2.isBuffer(b4))
      throw new TypeError("Argument must be a Buffer");
    if (this === b4)
      return true;
    return Buffer2.compare(this, b4) === 0;
  };
  Buffer2.prototype.inspect = function inspect5() {
    var str = "";
    var max2 = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x2 = thisEnd - thisStart;
    var y3 = end2 - start;
    var len2 = Math.min(x2, y3);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end2);
    for (var i3 = 0; i3 < len2; ++i3) {
      if (thisCopy[i3] !== targetCopy[i3]) {
        x2 = thisCopy[i3];
        y3 = targetCopy[i3];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr2.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr2.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf2, i4) {
      if (indexSize === 1) {
        return buf2[i4];
      } else {
        return buf2.readUInt16BE(i4 * indexSize);
      }
    }
    var i3;
    if (dir) {
      var foundIndex = -1;
      for (i3 = byteOffset; i3 < arrLength; i3++) {
        if (read2(arr2, i3) === read2(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i3;
          if (i3 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i3 -= i3 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i3 = byteOffset; i3 >= 0; i3--) {
        var found = true;
        for (var j2 = 0; j2 < valLength; j2++) {
          if (read2(arr2, i3 + j2) !== read2(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i3;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf2, string2, offset, length2) {
    offset = Number(offset) || 0;
    var remaining = buf2.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    var strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    for (var i3 = 0; i3 < length2; ++i3) {
      var parsed = parseInt(string2.substr(i3 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i3;
      buf2[offset + i3] = parsed;
    }
    return i3;
  }
  function utf8Write(buf2, string2, offset, length2) {
    return blitBuffer(utf8ToBytes2(string2, buf2.length - offset), buf2, offset, length2);
  }
  function asciiWrite(buf2, string2, offset, length2) {
    return blitBuffer(asciiToBytes(string2), buf2, offset, length2);
  }
  function base64Write(buf2, string2, offset, length2) {
    return blitBuffer(base64ToBytes(string2), buf2, offset, length2);
  }
  function ucs2Write(buf2, string2, offset, length2) {
    return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length2);
  }
  Buffer2.prototype.write = function write4(string2, offset, length2, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    var remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length2);
        case "base64":
          return base64Write(this, string2, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf2, start, end2) {
    if (start === 0 && end2 === buf2.length) {
      return base642.fromByteArray(buf2);
    } else {
      return base642.fromByteArray(buf2.slice(start, end2));
    }
  }
  function utf8Slice2(buf2, start, end2) {
    end2 = Math.min(buf2.length, end2);
    var res = [];
    var i3 = start;
    while (i3 < end2) {
      var firstByte = buf2[i3];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i3 + bytesPerSequence <= end2) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[i3 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[i3 + 1];
            thirdByte = buf2[i3 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[i3 + 1];
            thirdByte = buf2[i3 + 2];
            fourthByte = buf2[i3 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i3 += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  var MAX_ARGUMENTS_LENGTH2 = 4096;
  function decodeCodePointsArray2(codePoints) {
    var len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i3 = 0;
    while (i3 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH2)
      );
    }
    return res;
  }
  function asciiSlice(buf2, start, end2) {
    var ret = "";
    end2 = Math.min(buf2.length, end2);
    for (var i3 = start; i3 < end2; ++i3) {
      ret += String.fromCharCode(buf2[i3] & 127);
    }
    return ret;
  }
  function latin1Slice(buf2, start, end2) {
    var ret = "";
    end2 = Math.min(buf2.length, end2);
    for (var i3 = start; i3 < end2; ++i3) {
      ret += String.fromCharCode(buf2[i3]);
    }
    return ret;
  }
  function hexSlice(buf2, start, end2) {
    var len2 = buf2.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len2)
      end2 = len2;
    var out = "";
    for (var i3 = start; i3 < end2; ++i3) {
      out += hexSliceLookupTable[buf2[i3]];
    }
    return out;
  }
  function utf16leSlice(buf2, start, end2) {
    var bytes2 = buf2.slice(start, end2);
    var res = "";
    for (var i3 = 0; i3 < bytes2.length - 1; i3 += 2) {
      res += String.fromCharCode(bytes2[i3] + bytes2[i3 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice3(start, end2) {
    var len2 = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len2 : ~~end2;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end2 < 0) {
      end2 += len2;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len2) {
      end2 = len2;
    }
    if (end2 < start)
      end2 = start;
    var newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length2) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul5 = 1;
    var i3 = 0;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      val += this[offset + i3] * mul5;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul5 = 1;
    while (byteLength3 > 0 && (mul5 *= 256)) {
      val += this[offset + --byteLength3] * mul5;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul5 = 1;
    var i3 = 0;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      val += this[offset + i3] * mul5;
    }
    mul5 *= 128;
    if (val >= mul5)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var i3 = byteLength3;
    var mul5 = 1;
    var val = this[offset + --i3];
    while (i3 > 0 && (mul5 *= 256)) {
      val += this[offset + --i3] * mul5;
    }
    mul5 *= 128;
    if (val >= mul5)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, false, 52, 8);
  };
  function checkInt(buf2, value, offset, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var mul5 = 1;
    var i3 = 0;
    this[offset] = value & 255;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      this[offset + i3] = value / mul5 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var i3 = byteLength3 - 1;
    var mul5 = 1;
    this[offset + i3] = value & 255;
    while (--i3 >= 0 && (mul5 *= 256)) {
      this[offset + i3] = value / mul5 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i3 = 0;
    var mul5 = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i3] = (value / mul5 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i3 = byteLength3 - 1;
    var mul5 = 1;
    var sub = 0;
    this[offset + i3] = value & 255;
    while (--i3 >= 0 && (mul5 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i3] = (value / mul5 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function checkIEEE754(buf2, value, offset, ext, max2, min2) {
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 4);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 8);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    var len2 = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end2),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end2, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding = end2;
        end2 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    var i3;
    if (typeof val === "number") {
      for (i3 = start; i3 < end2; ++i3) {
        this[i3] = val;
      }
    } else {
      var bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      var len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i3 = 0; i3 < end2 - start; ++i3) {
        this[i3 + start] = bytes2[i3 % len2];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    var codePoint;
    var length2 = string2.length;
    var leadSurrogate = null;
    var bytes2 = [];
    for (var i3 = 0; i3 < length2; ++i3) {
      codePoint = string2.charCodeAt(i3);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i3 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i3 = 0; i3 < str.length; ++i3) {
      byteArray.push(str.charCodeAt(i3) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c2, hi2, lo;
    var byteArray = [];
    for (var i3 = 0; i3 < str.length; ++i3) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i3);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length2) {
    for (var i3 = 0; i3 < length2; ++i3) {
      if (i3 + offset >= dst.length || i3 >= src2.length)
        break;
      dst[i3 + offset] = src2[i3];
    }
    return i3;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet2 = "0123456789abcdef";
    var table = new Array(256);
    for (var i3 = 0; i3 < 16; ++i3) {
      var i16 = i3 * 16;
      for (var j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet2[i3] + alphabet2[j2];
      }
    }
    return table;
  }();
})(buffer$7);
const index$G = /* @__PURE__ */ getDefaultExportFromCjs(buffer$7);
const buffer$6 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$G
}, [buffer$7]);
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type2 = typeof value;
  return value === null || type2 !== "object" && type2 !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify$6(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify$6(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof buffer$7.Buffer === void 0) {
    throw new TypeError("[unstorage] Buffer is not supported!");
  }
}
const BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  checkBufferSupport();
  const base642 = buffer$7.Buffer.from(value).toString("base64");
  return BASE64_PREFIX + base642;
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  checkBufferSupport();
  return buffer$7.Buffer.from(value.slice(BASE64_PREFIX.length), "base64");
}
function normalizeKey(key2) {
  if (!key2) {
    return "";
  }
  return key2.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "");
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base3) {
  base3 = normalizeKey(base3);
  return base3 ? base3 + ":" : "";
}
function defineDriver(factory2) {
  return factory2;
}
const DRIVER_NAME = "memory";
const memory = defineDriver(() => {
  const data2 = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    options: {},
    hasItem(key2) {
      return data2.has(key2);
    },
    getItem(key2) {
      return data2.get(key2) ?? null;
    },
    getItemRaw(key2) {
      return data2.get(key2) ?? null;
    },
    setItem(key2, value) {
      data2.set(key2, value);
    },
    setItemRaw(key2, value) {
      data2.set(key2, value);
    },
    removeItem(key2) {
      data2.delete(key2);
    },
    getKeys() {
      return Array.from(data2.keys());
    },
    clear() {
      data2.clear();
    },
    dispose() {
      data2.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key2) => {
    for (const base3 of context.mountpoints) {
      if (key2.startsWith(base3)) {
        return {
          base: base3,
          relativeKey: key2.slice(base3.length),
          driver: context.mounts[base3]
        };
      }
    }
    return {
      base: "",
      relativeKey: key2,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base3, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base3) || includeParent && base3.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base3.length > mountpoint.length ? base3.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key2) => {
    if (!context.watching) {
      return;
    }
    key2 = normalizeKey(key2);
    for (const listener of context.watchListeners) {
      listener(event, key2);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb2) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch2 = batches.get(mount.base);
      if (!batch2) {
        batch2 = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch2);
      }
      return batch2;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key2 = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key2);
      getBatch(mount).items.push({
        key: key2,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch2) => cb2(batch2))).then(
      (r2) => r2.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions) {
      return runBatch(items, commonOptions, (batch2) => {
        if (batch2.driver.getItems) {
          return asyncCall(
            batch2.driver.getItems,
            batch2.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r2) => r2.map((item) => ({
              key: joinKeys(batch2.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch2.items.map((item) => {
            return asyncCall(
              batch2.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key2, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key2);
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify$6(value), opts);
      if (!driver.watch) {
        onChange("update", key2);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch2) => {
        if (batch2.driver.setItems) {
          await asyncCall(
            batch2.driver.setItems,
            batch2.items.map((item) => ({
              key: item.relativeKey,
              value: stringify$6(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch2.driver.setItem) {
          return;
        }
        await Promise.all(
          batch2.items.map((item) => {
            return asyncCall(
              batch2.driver.setItem,
              item.relativeKey,
              stringify$6(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key2, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key2, opts);
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key2);
      }
    },
    async removeItem(key2, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key2);
      }
    },
    // Meta
    async getMeta(key2, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key2, value, opts = {}) {
      return this.setItem(key2 + "$", value, opts);
    },
    removeMeta(key2, opts = {}) {
      return this.removeItem(key2 + "$", opts);
    },
    // Keys
    async getKeys(base3, opts = {}) {
      base3 = normalizeBaseKey(base3);
      const mounts = getMounts(base3, true);
      let maskedMounts = [];
      const allKeys = [];
      for (const mount of mounts) {
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        const keys2 = rawKeys.map((key2) => mount.mountpoint + normalizeKey(key2)).filter((key2) => !maskedMounts.some((p3) => key2.startsWith(p3)));
        allKeys.push(...keys2);
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p3) => !p3.startsWith(mount.mountpoint))
        ];
      }
      return base3 ? allKeys.filter((key2) => key2.startsWith(base3) && !key2.endsWith("$")) : allKeys.filter((key2) => !key2.endsWith("$"));
    },
    // Utils
    async clear(base3, opts = {}) {
      base3 = normalizeBaseKey(base3);
      await Promise.all(
        getMounts(base3, false).map(async (m2) => {
          if (m2.driver.clear) {
            return asyncCall(m2.driver.clear, m2.relativeBase, opts);
          }
          if (m2.driver.removeItem) {
            const keys2 = await m2.driver.getKeys(m2.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key2) => m2.driver.removeItem(key2, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base3, driver) {
      base3 = normalizeBaseKey(base3);
      if (base3 && context.mounts[base3]) {
        throw new Error(`already mounted at ${base3}`);
      }
      if (base3) {
        context.mountpoints.push(base3);
        context.mountpoints.sort((a3, b4) => b4.length - a3.length);
      }
      context.mounts[base3] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base3)).then((unwatcher) => {
          context.unwatch[base3] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base3, _dispose = true) {
      base3 = normalizeBaseKey(base3);
      if (!base3 || !context.mounts[base3]) {
        return;
      }
      if (context.watching && base3 in context.unwatch) {
        context.unwatch[base3]();
        delete context.unwatch[base3];
      }
      if (_dispose) {
        await dispose(context.mounts[base3]);
      }
      context.mountpoints = context.mountpoints.filter((key2) => key2 !== base3);
      delete context.mounts[base3];
    },
    getMount(key2 = "") {
      key2 = normalizeKey(key2) + ":";
      const m2 = getMount(key2);
      return {
        driver: m2.driver,
        base: m2.base
      };
    },
    getMounts(base3 = "", opts = {}) {
      base3 = normalizeKey(base3);
      const mounts = getMounts(base3, opts.parents);
      return mounts.map((m2) => ({
        driver: m2.driver,
        base: m2.mountpoint
      }));
    }
  };
  return storage;
}
function watch(driver, onChange, base3) {
  return driver.watch ? driver.watch((event, key2) => onChange(event, base3 + key2)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db2) => callback(db2.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get$2(key2, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key2)));
}
function set$1(key2, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key2);
    return promisifyRequest(store.transaction);
  });
}
function del$1(key2, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key2);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}
const JSONStringify = (data2) => JSON.stringify(data2, (_3, value) => typeof value === "bigint" ? value.toString() + "n" : value);
const JSONParse = (json2) => {
  const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
  const serializedData = json2.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
  return JSON.parse(serializedData, (_3, value) => {
    const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
    if (isCustomFormatBigInt)
      return BigInt(value.substring(0, value.length - 1));
    return value;
  });
};
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSONParse(value);
  } catch (_a2) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSONStringify(value) || "";
}
const x$2 = "idb-keyval";
var z$5 = (i3 = {}) => {
  const t2 = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e2 = (s3) => t2 + s3;
  let n4;
  return i3.dbName && i3.storeName && (n4 = createStore(i3.dbName, i3.storeName)), { name: x$2, options: i3, async hasItem(s3) {
    return !(typeof await get$2(e2(s3), n4) > "u");
  }, async getItem(s3) {
    return await get$2(e2(s3), n4) ?? null;
  }, setItem(s3, a3) {
    return set$1(e2(s3), a3, n4);
  }, removeItem(s3) {
    return del$1(e2(s3), n4);
  }, getKeys() {
    return keys(n4);
  }, clear() {
    return clear(n4);
  } };
};
const D$6 = "WALLET_CONNECT_V2_INDEXED_DB", E$5 = "keyvaluestorage";
let _$5 = class _2 {
  constructor() {
    this.indexedDb = createStorage({ driver: z$5({ dbName: D$6, storeName: E$5 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t2) => [t2.key, t2.value]);
  }
  async getItem(t2) {
    const e2 = await this.indexedDb.getItem(t2);
    if (e2 !== null)
      return e2;
  }
  async setItem(t2, e2) {
    await this.indexedDb.setItem(t2, safeJsonStringify(e2));
  }
  async removeItem(t2) {
    await this.indexedDb.removeItem(t2);
  }
};
var l$2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, c$2 = { exports: {} };
(function() {
  let i3;
  function t2() {
  }
  i3 = t2, i3.prototype.getItem = function(e2) {
    return this.hasOwnProperty(e2) ? String(this[e2]) : null;
  }, i3.prototype.setItem = function(e2, n4) {
    this[e2] = String(n4);
  }, i3.prototype.removeItem = function(e2) {
    delete this[e2];
  }, i3.prototype.clear = function() {
    const e2 = this;
    Object.keys(e2).forEach(function(n4) {
      e2[n4] = void 0, delete e2[n4];
    });
  }, i3.prototype.key = function(e2) {
    return e2 = e2 || 0, Object.keys(this)[e2];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l$2 < "u" && l$2.localStorage ? c$2.exports = l$2.localStorage : typeof window < "u" && window.localStorage ? c$2.exports = window.localStorage : c$2.exports = new t2();
})();
function k$5(i3) {
  var t2;
  return [i3[0], safeJsonParse((t2 = i3[1]) != null ? t2 : "")];
}
let K$6 = class K2 {
  constructor() {
    this.localStorage = c$2.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k$5);
  }
  async getItem(t2) {
    const e2 = this.localStorage.getItem(t2);
    if (e2 !== null)
      return safeJsonParse(e2);
  }
  async setItem(t2, e2) {
    this.localStorage.setItem(t2, safeJsonStringify(e2));
  }
  async removeItem(t2) {
    this.localStorage.removeItem(t2);
  }
};
const N$5 = "wc_storage_version", y$5 = 1, O$6 = async (i3, t2, e2) => {
  const n4 = N$5, s3 = await t2.getItem(n4);
  if (s3 && s3 >= y$5) {
    e2(t2);
    return;
  }
  const a3 = await i3.getKeys();
  if (!a3.length) {
    e2(t2);
    return;
  }
  const m2 = [];
  for (; a3.length; ) {
    const r2 = a3.shift();
    if (!r2)
      continue;
    const o2 = r2.toLowerCase();
    if (o2.includes("wc@") || o2.includes("walletconnect") || o2.includes("wc_") || o2.includes("wallet_connect")) {
      const f4 = await i3.getItem(r2);
      await t2.setItem(r2, f4), m2.push(r2);
    }
  }
  await t2.setItem(n4, y$5), e2(t2), j$4(i3, m2);
}, j$4 = async (i3, t2) => {
  t2.length && t2.forEach(async (e2) => {
    await i3.removeItem(e2);
  });
};
let h$6 = class h3 {
  constructor() {
    this.initialized = false, this.setInitialized = (e2) => {
      this.storage = e2, this.initialized = true;
    };
    const t2 = new K$6();
    this.storage = t2;
    try {
      const e2 = new _$5();
      O$6(t2, e2, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t2) {
    return await this.initialize(), this.storage.getItem(t2);
  }
  async setItem(t2, e2) {
    return await this.initialize(), this.storage.setItem(t2, e2);
  }
  async removeItem(t2) {
    return await this.initialize(), this.storage.removeItem(t2);
  }
  async initialize() {
    this.initialized || await new Promise((t2) => {
      const e2 = setInterval(() => {
        this.initialized && (clearInterval(e2), t2());
      }, 20);
    });
  }
};
var cjs$8 = {};
var heartbeat$2 = {};
const require$$0$1a = /* @__PURE__ */ getAugmentedNamespace(events);
const require$$2$p = /* @__PURE__ */ getAugmentedNamespace(cjs$c);
var types$6 = {};
var heartbeat$1 = {};
let IEvents$1 = class IEvents2 {
};
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IEvents: IEvents$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$19 = /* @__PURE__ */ getAugmentedNamespace(esm);
var hasRequiredHeartbeat$2;
function requireHeartbeat$2() {
  if (hasRequiredHeartbeat$2)
    return heartbeat$1;
  hasRequiredHeartbeat$2 = 1;
  Object.defineProperty(heartbeat$1, "__esModule", { value: true });
  heartbeat$1.IHeartBeat = void 0;
  const events_12 = require$$0$19;
  class IHeartBeat extends events_12.IEvents {
    constructor(opts) {
      super();
    }
  }
  heartbeat$1.IHeartBeat = IHeartBeat;
  return heartbeat$1;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes)
    return types$6;
  hasRequiredTypes = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_12 = require$$0$1e;
    tslib_12.__exportStar(requireHeartbeat$2(), exports2);
  })(types$6);
  return types$6;
}
var constants$8 = {};
var heartbeat = {};
var hasRequiredHeartbeat$1;
function requireHeartbeat$1() {
  if (hasRequiredHeartbeat$1)
    return heartbeat;
  hasRequiredHeartbeat$1 = 1;
  Object.defineProperty(heartbeat, "__esModule", { value: true });
  heartbeat.HEARTBEAT_EVENTS = heartbeat.HEARTBEAT_INTERVAL = void 0;
  const time_1 = require$$2$p;
  heartbeat.HEARTBEAT_INTERVAL = time_1.FIVE_SECONDS;
  heartbeat.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  };
  return heartbeat;
}
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1)
    return constants$8;
  hasRequiredConstants$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_12 = require$$0$1e;
    tslib_12.__exportStar(requireHeartbeat$1(), exports2);
  })(constants$8);
  return constants$8;
}
var hasRequiredHeartbeat;
function requireHeartbeat() {
  if (hasRequiredHeartbeat)
    return heartbeat$2;
  hasRequiredHeartbeat = 1;
  Object.defineProperty(heartbeat$2, "__esModule", { value: true });
  heartbeat$2.HeartBeat = void 0;
  const tslib_12 = require$$0$1e;
  const events_12 = require$$0$1a;
  const time_1 = require$$2$p;
  const types_12 = requireTypes();
  const constants_12 = requireConstants$1();
  class HeartBeat extends types_12.IHeartBeat {
    constructor(opts) {
      super(opts);
      this.events = new events_12.EventEmitter();
      this.interval = constants_12.HEARTBEAT_INTERVAL;
      this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_12.HEARTBEAT_INTERVAL;
    }
    static init(opts) {
      return tslib_12.__awaiter(this, void 0, void 0, function* () {
        const heartbeat2 = new HeartBeat(opts);
        yield heartbeat2.init();
        return heartbeat2;
      });
    }
    init() {
      return tslib_12.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize();
      });
    }
    stop() {
      clearInterval(this.intervalRef);
    }
    on(event, listener) {
      this.events.on(event, listener);
    }
    once(event, listener) {
      this.events.once(event, listener);
    }
    off(event, listener) {
      this.events.off(event, listener);
    }
    removeListener(event, listener) {
      this.events.removeListener(event, listener);
    }
    initialize() {
      return tslib_12.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(() => this.pulse(), time_1.toMiliseconds(this.interval));
      });
    }
    pulse() {
      this.events.emit(constants_12.HEARTBEAT_EVENTS.pulse);
    }
  }
  heartbeat$2.HeartBeat = HeartBeat;
  return heartbeat$2;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  const tslib_12 = require$$0$1e;
  tslib_12.__exportStar(requireHeartbeat(), exports2);
  tslib_12.__exportStar(requireTypes(), exports2);
  tslib_12.__exportStar(requireConstants$1(), exports2);
})(cjs$8);
var cjs$7 = {};
var quickFormatUnescaped;
var hasRequiredQuickFormatUnescaped;
function requireQuickFormatUnescaped() {
  if (hasRequiredQuickFormatUnescaped)
    return quickFormatUnescaped;
  hasRequiredQuickFormatUnescaped = 1;
  function tryStringify(o2) {
    try {
      return JSON.stringify(o2);
    } catch (e2) {
      return '"[Circular]"';
    }
  }
  quickFormatUnescaped = format;
  function format(f4, args, opts) {
    var ss2 = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f4 === "object" && f4 !== null) {
      var len2 = args.length + offset;
      if (len2 === 1)
        return f4;
      var objects = new Array(len2);
      objects[0] = ss2(f4);
      for (var index2 = 1; index2 < len2; index2++) {
        objects[index2] = ss2(args[index2]);
      }
      return objects.join(" ");
    }
    if (typeof f4 !== "string") {
      return f4;
    }
    var argLen = args.length;
    if (argLen === 0)
      return f4;
    var str = "";
    var a3 = 1 - offset;
    var lastPos = -1;
    var flen = f4 && f4.length || 0;
    for (var i3 = 0; i3 < flen; ) {
      if (f4.charCodeAt(i3) === 37 && i3 + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f4.charCodeAt(i3 + 1)) {
          case 100:
          case 102:
            if (a3 >= argLen)
              break;
            if (args[a3] == null)
              break;
            if (lastPos < i3)
              str += f4.slice(lastPos, i3);
            str += Number(args[a3]);
            lastPos = i3 + 2;
            i3++;
            break;
          case 105:
            if (a3 >= argLen)
              break;
            if (args[a3] == null)
              break;
            if (lastPos < i3)
              str += f4.slice(lastPos, i3);
            str += Math.floor(Number(args[a3]));
            lastPos = i3 + 2;
            i3++;
            break;
          case 79:
          case 111:
          case 106:
            if (a3 >= argLen)
              break;
            if (args[a3] === void 0)
              break;
            if (lastPos < i3)
              str += f4.slice(lastPos, i3);
            var type2 = typeof args[a3];
            if (type2 === "string") {
              str += "'" + args[a3] + "'";
              lastPos = i3 + 2;
              i3++;
              break;
            }
            if (type2 === "function") {
              str += args[a3].name || "<anonymous>";
              lastPos = i3 + 2;
              i3++;
              break;
            }
            str += ss2(args[a3]);
            lastPos = i3 + 2;
            i3++;
            break;
          case 115:
            if (a3 >= argLen)
              break;
            if (lastPos < i3)
              str += f4.slice(lastPos, i3);
            str += String(args[a3]);
            lastPos = i3 + 2;
            i3++;
            break;
          case 37:
            if (lastPos < i3)
              str += f4.slice(lastPos, i3);
            str += "%";
            lastPos = i3 + 2;
            i3++;
            a3--;
            break;
        }
        ++a3;
      }
      ++i3;
    }
    if (lastPos === -1)
      return f4;
    else if (lastPos < flen) {
      str += f4.slice(lastPos);
    }
    return str;
  }
  return quickFormatUnescaped;
}
var browser$8;
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$8;
  hasRequiredBrowser$1 = 1;
  const format = requireQuickFormatUnescaped();
  browser$8 = pino;
  const _console = pfGlobalThisOrFallback().console || {};
  const stdSerializers = {
    mapHttpRequest: mock,
    mapHttpResponse: mock,
    wrapRequestSerializer: passthrough2,
    wrapResponseSerializer: passthrough2,
    wrapErrorSerializer: passthrough2,
    req: mock,
    res: mock,
    err: asErrValue
  };
  function shouldSerialize(serialize, serializers) {
    if (Array.isArray(serialize)) {
      const hasToFilter = serialize.filter(function(k3) {
        return k3 !== "!stdSerializers.err";
      });
      return hasToFilter;
    } else if (serialize === true) {
      return Object.keys(serializers);
    }
    return false;
  }
  function pino(opts) {
    opts = opts || {};
    opts.browser = opts.browser || {};
    const transmit2 = opts.browser.transmit;
    if (transmit2 && typeof transmit2.send !== "function") {
      throw Error("pino: transmit option must have a send function");
    }
    const proto = opts.browser.write || _console;
    if (opts.browser.write)
      opts.browser.asObject = true;
    const serializers = opts.serializers || {};
    const serialize = shouldSerialize(opts.browser.serialize, serializers);
    let stdErrSerialize = opts.browser.serialize;
    if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
      stdErrSerialize = false;
    const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
    if (typeof proto === "function") {
      proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
    }
    if (opts.enabled === false)
      opts.level = "silent";
    const level = opts.level || "info";
    const logger2 = Object.create(proto);
    if (!logger2.log)
      logger2.log = noop2;
    Object.defineProperty(logger2, "levelVal", {
      get: getLevelVal
    });
    Object.defineProperty(logger2, "level", {
      get: getLevel,
      set: setLevel
    });
    const setOpts = {
      transmit: transmit2,
      serialize,
      asObject: opts.browser.asObject,
      levels,
      timestamp: getTimeFunction(opts)
    };
    logger2.levels = pino.levels;
    logger2.level = level;
    logger2.setMaxListeners = logger2.getMaxListeners = logger2.emit = logger2.addListener = logger2.on = logger2.prependListener = logger2.once = logger2.prependOnceListener = logger2.removeListener = logger2.removeAllListeners = logger2.listeners = logger2.listenerCount = logger2.eventNames = logger2.write = logger2.flush = noop2;
    logger2.serializers = serializers;
    logger2._serialize = serialize;
    logger2._stdErrSerialize = stdErrSerialize;
    logger2.child = child;
    if (transmit2)
      logger2._logEvent = createLogEventShape();
    function getLevelVal() {
      return this.level === "silent" ? Infinity : this.levels.values[this.level];
    }
    function getLevel() {
      return this._level;
    }
    function setLevel(level2) {
      if (level2 !== "silent" && !this.levels.values[level2]) {
        throw Error("unknown level " + level2);
      }
      this._level = level2;
      set2(setOpts, logger2, "error", "log");
      set2(setOpts, logger2, "fatal", "error");
      set2(setOpts, logger2, "warn", "error");
      set2(setOpts, logger2, "info", "log");
      set2(setOpts, logger2, "debug", "log");
      set2(setOpts, logger2, "trace", "log");
    }
    function child(bindings, childOptions) {
      if (!bindings) {
        throw new Error("missing bindings for child Pino");
      }
      childOptions = childOptions || {};
      if (serialize && bindings.serializers) {
        childOptions.serializers = bindings.serializers;
      }
      const childOptionsSerializers = childOptions.serializers;
      if (serialize && childOptionsSerializers) {
        var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
        var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
        delete bindings.serializers;
        applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
      }
      function Child(parent) {
        this._childLevel = (parent._childLevel | 0) + 1;
        this.error = bind3(parent, bindings, "error");
        this.fatal = bind3(parent, bindings, "fatal");
        this.warn = bind3(parent, bindings, "warn");
        this.info = bind3(parent, bindings, "info");
        this.debug = bind3(parent, bindings, "debug");
        this.trace = bind3(parent, bindings, "trace");
        if (childSerializers) {
          this.serializers = childSerializers;
          this._serialize = childSerialize;
        }
        if (transmit2) {
          this._logEvent = createLogEventShape(
            [].concat(parent._logEvent.bindings, bindings)
          );
        }
      }
      Child.prototype = this;
      return new Child(this);
    }
    return logger2;
  }
  pino.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  };
  pino.stdSerializers = stdSerializers;
  pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
  function set2(opts, logger2, level, fallback) {
    const proto = Object.getPrototypeOf(logger2);
    logger2[level] = logger2.levelVal > logger2.levels.values[level] ? noop2 : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop2;
    wrap2(opts, logger2, level);
  }
  function wrap2(opts, logger2, level) {
    if (!opts.transmit && logger2[level] === noop2)
      return;
    logger2[level] = function(write4) {
      return function LOG() {
        const ts2 = opts.timestamp();
        const args = new Array(arguments.length);
        const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
        for (var i3 = 0; i3 < args.length; i3++)
          args[i3] = arguments[i3];
        if (opts.serialize && !opts.asObject) {
          applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
        }
        if (opts.asObject)
          write4.call(proto, asObject(this, level, args, ts2));
        else
          write4.apply(proto, args);
        if (opts.transmit) {
          const transmitLevel = opts.transmit.level || logger2.level;
          const transmitValue = pino.levels.values[transmitLevel];
          const methodValue = pino.levels.values[level];
          if (methodValue < transmitValue)
            return;
          transmit(this, {
            ts: ts2,
            methodLevel: level,
            methodValue,
            transmitLevel,
            transmitValue: pino.levels.values[opts.transmit.level || logger2.level],
            send: opts.transmit.send,
            val: logger2.levelVal
          }, args);
        }
      };
    }(logger2[level]);
  }
  function asObject(logger2, level, args, ts2) {
    if (logger2._serialize)
      applySerializers(args, logger2._serialize, logger2.serializers, logger2._stdErrSerialize);
    const argsCloned = args.slice();
    let msg = argsCloned[0];
    const o2 = {};
    if (ts2) {
      o2.time = ts2;
    }
    o2.level = pino.levels.values[level];
    let lvl = (logger2._childLevel | 0) + 1;
    if (lvl < 1)
      lvl = 1;
    if (msg !== null && typeof msg === "object") {
      while (lvl-- && typeof argsCloned[0] === "object") {
        Object.assign(o2, argsCloned.shift());
      }
      msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
    } else if (typeof msg === "string")
      msg = format(argsCloned.shift(), argsCloned);
    if (msg !== void 0)
      o2.msg = msg;
    return o2;
  }
  function applySerializers(args, serialize, serializers, stdErrSerialize) {
    for (const i3 in args) {
      if (stdErrSerialize && args[i3] instanceof Error) {
        args[i3] = pino.stdSerializers.err(args[i3]);
      } else if (typeof args[i3] === "object" && !Array.isArray(args[i3])) {
        for (const k3 in args[i3]) {
          if (serialize && serialize.indexOf(k3) > -1 && k3 in serializers) {
            args[i3][k3] = serializers[k3](args[i3][k3]);
          }
        }
      }
    }
  }
  function bind3(parent, bindings, level) {
    return function() {
      const args = new Array(1 + arguments.length);
      args[0] = bindings;
      for (var i3 = 1; i3 < args.length; i3++) {
        args[i3] = arguments[i3 - 1];
      }
      return parent[level].apply(this, args);
    };
  }
  function transmit(logger2, opts, args) {
    const send = opts.send;
    const ts2 = opts.ts;
    const methodLevel = opts.methodLevel;
    const methodValue = opts.methodValue;
    const val = opts.val;
    const bindings = logger2._logEvent.bindings;
    applySerializers(
      args,
      logger2._serialize || Object.keys(logger2.serializers),
      logger2.serializers,
      logger2._stdErrSerialize === void 0 ? true : logger2._stdErrSerialize
    );
    logger2._logEvent.ts = ts2;
    logger2._logEvent.messages = args.filter(function(arg) {
      return bindings.indexOf(arg) === -1;
    });
    logger2._logEvent.level.label = methodLevel;
    logger2._logEvent.level.value = methodValue;
    send(methodLevel, logger2._logEvent, val);
    logger2._logEvent = createLogEventShape(bindings);
  }
  function createLogEventShape(bindings) {
    return {
      ts: 0,
      messages: [],
      bindings: bindings || [],
      level: { label: "", value: 0 }
    };
  }
  function asErrValue(err) {
    const obj = {
      type: err.constructor.name,
      msg: err.message,
      stack: err.stack
    };
    for (const key2 in err) {
      if (obj[key2] === void 0) {
        obj[key2] = err[key2];
      }
    }
    return obj;
  }
  function getTimeFunction(opts) {
    if (typeof opts.timestamp === "function") {
      return opts.timestamp;
    }
    if (opts.timestamp === false) {
      return nullTime;
    }
    return epochTime;
  }
  function mock() {
    return {};
  }
  function passthrough2(a3) {
    return a3;
  }
  function noop2() {
  }
  function nullTime() {
    return false;
  }
  function epochTime() {
    return Date.now();
  }
  function unixTime() {
    return Math.round(Date.now() / 1e3);
  }
  function isoTime() {
    return new Date(Date.now()).toISOString();
  }
  function pfGlobalThisOrFallback() {
    function defd(o2) {
      return typeof o2 !== "undefined" && o2;
    }
    try {
      if (typeof globalThis !== "undefined")
        return globalThis;
      Object.defineProperty(Object.prototype, "globalThis", {
        get: function() {
          delete Object.prototype.globalThis;
          return this.globalThis = this;
        },
        configurable: true
      });
      return globalThis;
    } catch (e2) {
      return defd(self) || defd(window) || defd(this) || {};
    }
  }
  return browser$8;
}
var constants$7 = {};
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants)
    return constants$7;
  hasRequiredConstants = 1;
  Object.defineProperty(constants$7, "__esModule", { value: true });
  constants$7.PINO_CUSTOM_CONTEXT_KEY = constants$7.PINO_LOGGER_DEFAULTS = void 0;
  constants$7.PINO_LOGGER_DEFAULTS = {
    level: "info"
  };
  constants$7.PINO_CUSTOM_CONTEXT_KEY = "custom_context";
  return constants$7;
}
var utils$b = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$b;
  hasRequiredUtils = 1;
  Object.defineProperty(utils$b, "__esModule", { value: true });
  utils$b.generateChildLogger = utils$b.formatChildLoggerContext = utils$b.getLoggerContext = utils$b.setBrowserLoggerContext = utils$b.getBrowserLoggerContext = utils$b.getDefaultLoggerOptions = void 0;
  const constants_12 = requireConstants();
  function getDefaultLoggerOptions(opts) {
    return Object.assign(Object.assign({}, opts), { level: (opts === null || opts === void 0 ? void 0 : opts.level) || constants_12.PINO_LOGGER_DEFAULTS.level });
  }
  utils$b.getDefaultLoggerOptions = getDefaultLoggerOptions;
  function getBrowserLoggerContext(logger2, customContextKey = constants_12.PINO_CUSTOM_CONTEXT_KEY) {
    return logger2[customContextKey] || "";
  }
  utils$b.getBrowserLoggerContext = getBrowserLoggerContext;
  function setBrowserLoggerContext(logger2, context, customContextKey = constants_12.PINO_CUSTOM_CONTEXT_KEY) {
    logger2[customContextKey] = context;
    return logger2;
  }
  utils$b.setBrowserLoggerContext = setBrowserLoggerContext;
  function getLoggerContext(logger2, customContextKey = constants_12.PINO_CUSTOM_CONTEXT_KEY) {
    let context = "";
    if (typeof logger2.bindings === "undefined") {
      context = getBrowserLoggerContext(logger2, customContextKey);
    } else {
      context = logger2.bindings().context || "";
    }
    return context;
  }
  utils$b.getLoggerContext = getLoggerContext;
  function formatChildLoggerContext(logger2, childContext, customContextKey = constants_12.PINO_CUSTOM_CONTEXT_KEY) {
    const parentContext = getLoggerContext(logger2, customContextKey);
    const context = parentContext.trim() ? `${parentContext}/${childContext}` : childContext;
    return context;
  }
  utils$b.formatChildLoggerContext = formatChildLoggerContext;
  function generateChildLogger(logger2, childContext, customContextKey = constants_12.PINO_CUSTOM_CONTEXT_KEY) {
    const context = formatChildLoggerContext(logger2, childContext, customContextKey);
    const child = logger2.child({ context });
    return setBrowserLoggerContext(child, context, customContextKey);
  }
  utils$b.generateChildLogger = generateChildLogger;
  return utils$b;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.pino = void 0;
  const tslib_12 = require$$0$1e;
  const pino_1 = tslib_12.__importDefault(requireBrowser$1());
  Object.defineProperty(exports2, "pino", { enumerable: true, get: function() {
    return pino_1.default;
  } });
  tslib_12.__exportStar(requireConstants(), exports2);
  tslib_12.__exportStar(requireUtils(), exports2);
})(cjs$7);
let n$1 = class n3 extends IEvents$1 {
  constructor(s3) {
    super(), this.opts = s3, this.protocol = "wc", this.version = 2;
  }
};
let h$5 = class h4 extends IEvents$1 {
  constructor(s3, t2) {
    super(), this.core = s3, this.logger = t2, this.records = /* @__PURE__ */ new Map();
  }
};
let a$3 = class a2 {
  constructor(s3, t2) {
    this.logger = s3, this.core = t2;
  }
};
let u$4 = class u2 extends IEvents$1 {
  constructor(s3, t2) {
    super(), this.relayer = s3, this.logger = t2;
  }
};
let g$6 = class g2 extends IEvents$1 {
  constructor(s3) {
    super();
  }
};
let p$6 = class p2 {
  constructor(s3, t2, o2, M3) {
    this.core = s3, this.logger = t2, this.name = o2;
  }
};
let d$3 = class d2 extends IEvents$1 {
  constructor(s3, t2) {
    super(), this.relayer = s3, this.logger = t2;
  }
};
let E$4 = class E2 extends IEvents$1 {
  constructor(s3, t2) {
    super(), this.core = s3, this.logger = t2;
  }
};
let y$4 = class y2 {
  constructor(s3, t2) {
    this.projectId = s3, this.logger = t2;
  }
};
let v$6 = class v2 {
  constructor(s3, t2) {
    this.projectId = s3, this.logger = t2;
  }
};
let b$5 = class b3 {
  constructor(s3) {
    this.opts = s3, this.protocol = "wc", this.version = 2;
  }
};
let w$5 = class w2 {
  constructor(s3) {
    this.client = s3;
  }
};
var ed25519 = {};
var sha512$5 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var binary_12 = require$$0$1l;
  var wipe_12 = require$$2$r;
  exports2.DIGEST_LENGTH = 64;
  exports2.BLOCK_SIZE = 128;
  var SHA5122 = (
    /** @class */
    function() {
      function SHA5123() {
        this.digestLength = exports2.DIGEST_LENGTH;
        this.blockSize = exports2.BLOCK_SIZE;
        this._stateHi = new Int32Array(8);
        this._stateLo = new Int32Array(8);
        this._tempHi = new Int32Array(16);
        this._tempLo = new Int32Array(16);
        this._buffer = new Uint8Array(256);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      SHA5123.prototype._initState = function() {
        this._stateHi[0] = 1779033703;
        this._stateHi[1] = 3144134277;
        this._stateHi[2] = 1013904242;
        this._stateHi[3] = 2773480762;
        this._stateHi[4] = 1359893119;
        this._stateHi[5] = 2600822924;
        this._stateHi[6] = 528734635;
        this._stateHi[7] = 1541459225;
        this._stateLo[0] = 4089235720;
        this._stateLo[1] = 2227873595;
        this._stateLo[2] = 4271175723;
        this._stateLo[3] = 1595750129;
        this._stateLo[4] = 2917565137;
        this._stateLo[5] = 725511199;
        this._stateLo[6] = 4215389547;
        this._stateLo[7] = 327033209;
      };
      SHA5123.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA5123.prototype.clean = function() {
        wipe_12.wipe(this._buffer);
        wipe_12.wipe(this._tempHi);
        wipe_12.wipe(this._tempLo);
        this.reset();
      };
      SHA5123.prototype.update = function(data2, dataLength) {
        if (dataLength === void 0) {
          dataLength = data2.length;
        }
        if (this._finished) {
          throw new Error("SHA512: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < exports2.BLOCK_SIZE && dataLength > 0) {
            this._buffer[this._bufferLength++] = data2[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data2, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data2[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA5123.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 128 < 112 ? 128 : 256;
          this._buffer[left] = 128;
          for (var i3 = left + 1; i3 < padLength - 8; i3++) {
            this._buffer[i3] = 0;
          }
          binary_12.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_12.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i3 = 0; i3 < this.digestLength / 8; i3++) {
          binary_12.writeUint32BE(this._stateHi[i3], out, i3 * 8);
          binary_12.writeUint32BE(this._stateLo[i3], out, i3 * 8 + 4);
        }
        return this;
      };
      SHA5123.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA5123.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA5123.prototype.restoreState = function(savedState) {
        this._stateHi.set(savedState.stateHi);
        this._stateLo.set(savedState.stateLo);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA5123.prototype.cleanSavedState = function(savedState) {
        wipe_12.wipe(savedState.stateHi);
        wipe_12.wipe(savedState.stateLo);
        if (savedState.buffer) {
          wipe_12.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA5123;
    }()
  );
  exports2.SHA512 = SHA5122;
  var K3 = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function hashBlocks(wh2, wl2, hh2, hl2, m2, pos, len2) {
    var ah0 = hh2[0], ah1 = hh2[1], ah2 = hh2[2], ah3 = hh2[3], ah4 = hh2[4], ah5 = hh2[5], ah6 = hh2[6], ah7 = hh2[7], al0 = hl2[0], al1 = hl2[1], al2 = hl2[2], al3 = hl2[3], al4 = hl2[4], al5 = hl2[5], al6 = hl2[6], al7 = hl2[7];
    var h5, l2;
    var th2, tl2;
    var a3, b4, c2, d3;
    while (len2 >= 128) {
      for (var i3 = 0; i3 < 16; i3++) {
        var j2 = 8 * i3 + pos;
        wh2[i3] = binary_12.readUint32BE(m2, j2);
        wl2[i3] = binary_12.readUint32BE(m2, j2 + 4);
      }
      for (var i3 = 0; i3 < 80; i3++) {
        var bh0 = ah0;
        var bh1 = ah1;
        var bh2 = ah2;
        var bh3 = ah3;
        var bh4 = ah4;
        var bh5 = ah5;
        var bh6 = ah6;
        var bh7 = ah7;
        var bl0 = al0;
        var bl1 = al1;
        var bl2 = al2;
        var bl3 = al3;
        var bl4 = al4;
        var bl5 = al5;
        var bl6 = al6;
        var bl7 = al7;
        h5 = ah7;
        l2 = al7;
        a3 = l2 & 65535;
        b4 = l2 >>> 16;
        c2 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
        l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c2 += h5 & 65535;
        d3 += h5 >>> 16;
        h5 = ah4 & ah5 ^ ~ah4 & ah6;
        l2 = al4 & al5 ^ ~al4 & al6;
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c2 += h5 & 65535;
        d3 += h5 >>> 16;
        h5 = K3[i3 * 2];
        l2 = K3[i3 * 2 + 1];
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c2 += h5 & 65535;
        d3 += h5 >>> 16;
        h5 = wh2[i3 % 16];
        l2 = wl2[i3 % 16];
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c2 += h5 & 65535;
        d3 += h5 >>> 16;
        b4 += a3 >>> 16;
        c2 += b4 >>> 16;
        d3 += c2 >>> 16;
        th2 = c2 & 65535 | d3 << 16;
        tl2 = a3 & 65535 | b4 << 16;
        h5 = th2;
        l2 = tl2;
        a3 = l2 & 65535;
        b4 = l2 >>> 16;
        c2 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
        l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c2 += h5 & 65535;
        d3 += h5 >>> 16;
        h5 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
        l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c2 += h5 & 65535;
        d3 += h5 >>> 16;
        b4 += a3 >>> 16;
        c2 += b4 >>> 16;
        d3 += c2 >>> 16;
        bh7 = c2 & 65535 | d3 << 16;
        bl7 = a3 & 65535 | b4 << 16;
        h5 = bh3;
        l2 = bl3;
        a3 = l2 & 65535;
        b4 = l2 >>> 16;
        c2 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = th2;
        l2 = tl2;
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c2 += h5 & 65535;
        d3 += h5 >>> 16;
        b4 += a3 >>> 16;
        c2 += b4 >>> 16;
        d3 += c2 >>> 16;
        bh3 = c2 & 65535 | d3 << 16;
        bl3 = a3 & 65535 | b4 << 16;
        ah1 = bh0;
        ah2 = bh1;
        ah3 = bh2;
        ah4 = bh3;
        ah5 = bh4;
        ah6 = bh5;
        ah7 = bh6;
        ah0 = bh7;
        al1 = bl0;
        al2 = bl1;
        al3 = bl2;
        al4 = bl3;
        al5 = bl4;
        al6 = bl5;
        al7 = bl6;
        al0 = bl7;
        if (i3 % 16 === 15) {
          for (var j2 = 0; j2 < 16; j2++) {
            h5 = wh2[j2];
            l2 = wl2[j2];
            a3 = l2 & 65535;
            b4 = l2 >>> 16;
            c2 = h5 & 65535;
            d3 = h5 >>> 16;
            h5 = wh2[(j2 + 9) % 16];
            l2 = wl2[(j2 + 9) % 16];
            a3 += l2 & 65535;
            b4 += l2 >>> 16;
            c2 += h5 & 65535;
            d3 += h5 >>> 16;
            th2 = wh2[(j2 + 1) % 16];
            tl2 = wl2[(j2 + 1) % 16];
            h5 = (th2 >>> 1 | tl2 << 32 - 1) ^ (th2 >>> 8 | tl2 << 32 - 8) ^ th2 >>> 7;
            l2 = (tl2 >>> 1 | th2 << 32 - 1) ^ (tl2 >>> 8 | th2 << 32 - 8) ^ (tl2 >>> 7 | th2 << 32 - 7);
            a3 += l2 & 65535;
            b4 += l2 >>> 16;
            c2 += h5 & 65535;
            d3 += h5 >>> 16;
            th2 = wh2[(j2 + 14) % 16];
            tl2 = wl2[(j2 + 14) % 16];
            h5 = (th2 >>> 19 | tl2 << 32 - 19) ^ (tl2 >>> 61 - 32 | th2 << 32 - (61 - 32)) ^ th2 >>> 6;
            l2 = (tl2 >>> 19 | th2 << 32 - 19) ^ (th2 >>> 61 - 32 | tl2 << 32 - (61 - 32)) ^ (tl2 >>> 6 | th2 << 32 - 6);
            a3 += l2 & 65535;
            b4 += l2 >>> 16;
            c2 += h5 & 65535;
            d3 += h5 >>> 16;
            b4 += a3 >>> 16;
            c2 += b4 >>> 16;
            d3 += c2 >>> 16;
            wh2[j2] = c2 & 65535 | d3 << 16;
            wl2[j2] = a3 & 65535 | b4 << 16;
          }
        }
      }
      h5 = ah0;
      l2 = al0;
      a3 = l2 & 65535;
      b4 = l2 >>> 16;
      c2 = h5 & 65535;
      d3 = h5 >>> 16;
      h5 = hh2[0];
      l2 = hl2[0];
      a3 += l2 & 65535;
      b4 += l2 >>> 16;
      c2 += h5 & 65535;
      d3 += h5 >>> 16;
      b4 += a3 >>> 16;
      c2 += b4 >>> 16;
      d3 += c2 >>> 16;
      hh2[0] = ah0 = c2 & 65535 | d3 << 16;
      hl2[0] = al0 = a3 & 65535 | b4 << 16;
      h5 = ah1;
      l2 = al1;
      a3 = l2 & 65535;
      b4 = l2 >>> 16;
      c2 = h5 & 65535;
      d3 = h5 >>> 16;
      h5 = hh2[1];
      l2 = hl2[1];
      a3 += l2 & 65535;
      b4 += l2 >>> 16;
      c2 += h5 & 65535;
      d3 += h5 >>> 16;
      b4 += a3 >>> 16;
      c2 += b4 >>> 16;
      d3 += c2 >>> 16;
      hh2[1] = ah1 = c2 & 65535 | d3 << 16;
      hl2[1] = al1 = a3 & 65535 | b4 << 16;
      h5 = ah2;
      l2 = al2;
      a3 = l2 & 65535;
      b4 = l2 >>> 16;
      c2 = h5 & 65535;
      d3 = h5 >>> 16;
      h5 = hh2[2];
      l2 = hl2[2];
      a3 += l2 & 65535;
      b4 += l2 >>> 16;
      c2 += h5 & 65535;
      d3 += h5 >>> 16;
      b4 += a3 >>> 16;
      c2 += b4 >>> 16;
      d3 += c2 >>> 16;
      hh2[2] = ah2 = c2 & 65535 | d3 << 16;
      hl2[2] = al2 = a3 & 65535 | b4 << 16;
      h5 = ah3;
      l2 = al3;
      a3 = l2 & 65535;
      b4 = l2 >>> 16;
      c2 = h5 & 65535;
      d3 = h5 >>> 16;
      h5 = hh2[3];
      l2 = hl2[3];
      a3 += l2 & 65535;
      b4 += l2 >>> 16;
      c2 += h5 & 65535;
      d3 += h5 >>> 16;
      b4 += a3 >>> 16;
      c2 += b4 >>> 16;
      d3 += c2 >>> 16;
      hh2[3] = ah3 = c2 & 65535 | d3 << 16;
      hl2[3] = al3 = a3 & 65535 | b4 << 16;
      h5 = ah4;
      l2 = al4;
      a3 = l2 & 65535;
      b4 = l2 >>> 16;
      c2 = h5 & 65535;
      d3 = h5 >>> 16;
      h5 = hh2[4];
      l2 = hl2[4];
      a3 += l2 & 65535;
      b4 += l2 >>> 16;
      c2 += h5 & 65535;
      d3 += h5 >>> 16;
      b4 += a3 >>> 16;
      c2 += b4 >>> 16;
      d3 += c2 >>> 16;
      hh2[4] = ah4 = c2 & 65535 | d3 << 16;
      hl2[4] = al4 = a3 & 65535 | b4 << 16;
      h5 = ah5;
      l2 = al5;
      a3 = l2 & 65535;
      b4 = l2 >>> 16;
      c2 = h5 & 65535;
      d3 = h5 >>> 16;
      h5 = hh2[5];
      l2 = hl2[5];
      a3 += l2 & 65535;
      b4 += l2 >>> 16;
      c2 += h5 & 65535;
      d3 += h5 >>> 16;
      b4 += a3 >>> 16;
      c2 += b4 >>> 16;
      d3 += c2 >>> 16;
      hh2[5] = ah5 = c2 & 65535 | d3 << 16;
      hl2[5] = al5 = a3 & 65535 | b4 << 16;
      h5 = ah6;
      l2 = al6;
      a3 = l2 & 65535;
      b4 = l2 >>> 16;
      c2 = h5 & 65535;
      d3 = h5 >>> 16;
      h5 = hh2[6];
      l2 = hl2[6];
      a3 += l2 & 65535;
      b4 += l2 >>> 16;
      c2 += h5 & 65535;
      d3 += h5 >>> 16;
      b4 += a3 >>> 16;
      c2 += b4 >>> 16;
      d3 += c2 >>> 16;
      hh2[6] = ah6 = c2 & 65535 | d3 << 16;
      hl2[6] = al6 = a3 & 65535 | b4 << 16;
      h5 = ah7;
      l2 = al7;
      a3 = l2 & 65535;
      b4 = l2 >>> 16;
      c2 = h5 & 65535;
      d3 = h5 >>> 16;
      h5 = hh2[7];
      l2 = hl2[7];
      a3 += l2 & 65535;
      b4 += l2 >>> 16;
      c2 += h5 & 65535;
      d3 += h5 >>> 16;
      b4 += a3 >>> 16;
      c2 += b4 >>> 16;
      d3 += c2 >>> 16;
      hh2[7] = ah7 = c2 & 65535 | d3 << 16;
      hl2[7] = al7 = a3 & 65535 | b4 << 16;
      pos += 128;
      len2 -= 128;
    }
    return pos;
  }
  function hash2(data2) {
    var h5 = new SHA5122();
    h5.update(data2);
    var digest9 = h5.digest();
    h5.clean();
    return digest9;
  }
  exports2.hash = hash2;
})(sha512$5);
const sha512$3 = /* @__PURE__ */ getDefaultExportFromCjs(sha512$5);
const sha512$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sha512$3
}, [sha512$5]);
const require$$1$F = /* @__PURE__ */ getAugmentedNamespace(sha512$4);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.convertSecretKeyToX25519 = exports2.convertPublicKeyToX25519 = exports2.verify = exports2.sign = exports2.extractPublicKeyFromSecretKey = exports2.generateKeyPair = exports2.generateKeyPairFromSeed = exports2.SEED_LENGTH = exports2.SECRET_KEY_LENGTH = exports2.PUBLIC_KEY_LENGTH = exports2.SIGNATURE_LENGTH = void 0;
  const random_1 = require$$0$1f;
  const sha512_1 = require$$1$F;
  const wipe_12 = require$$2$r;
  exports2.SIGNATURE_LENGTH = 64;
  exports2.PUBLIC_KEY_LENGTH = 32;
  exports2.SECRET_KEY_LENGTH = 64;
  exports2.SEED_LENGTH = 32;
  function gf2(init3) {
    const r2 = new Float64Array(16);
    if (init3) {
      for (let i3 = 0; i3 < init3.length; i3++) {
        r2[i3] = init3[i3];
      }
    }
    return r2;
  }
  const _9 = new Uint8Array(32);
  _9[0] = 9;
  const gf0 = gf2();
  const gf1 = gf2([1]);
  const D2 = gf2([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]);
  const D22 = gf2([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]);
  const X2 = gf2([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]);
  const Y2 = gf2([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]);
  const I3 = gf2([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function set25519(r2, a3) {
    for (let i3 = 0; i3 < 16; i3++) {
      r2[i3] = a3[i3] | 0;
    }
  }
  function car25519(o2) {
    let c2 = 1;
    for (let i3 = 0; i3 < 16; i3++) {
      let v4 = o2[i3] + c2 + 65535;
      c2 = Math.floor(v4 / 65536);
      o2[i3] = v4 - c2 * 65536;
    }
    o2[0] += c2 - 1 + 37 * (c2 - 1);
  }
  function sel25519(p3, q2, b4) {
    const c2 = ~(b4 - 1);
    for (let i3 = 0; i3 < 16; i3++) {
      const t2 = c2 & (p3[i3] ^ q2[i3]);
      p3[i3] ^= t2;
      q2[i3] ^= t2;
    }
  }
  function pack25519(o2, n4) {
    const m2 = gf2();
    const t2 = gf2();
    for (let i3 = 0; i3 < 16; i3++) {
      t2[i3] = n4[i3];
    }
    car25519(t2);
    car25519(t2);
    car25519(t2);
    for (let j2 = 0; j2 < 2; j2++) {
      m2[0] = t2[0] - 65517;
      for (let i3 = 1; i3 < 15; i3++) {
        m2[i3] = t2[i3] - 65535 - (m2[i3 - 1] >> 16 & 1);
        m2[i3 - 1] &= 65535;
      }
      m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
      const b4 = m2[15] >> 16 & 1;
      m2[14] &= 65535;
      sel25519(t2, m2, 1 - b4);
    }
    for (let i3 = 0; i3 < 16; i3++) {
      o2[2 * i3] = t2[i3] & 255;
      o2[2 * i3 + 1] = t2[i3] >> 8;
    }
  }
  function verify32(x2, y3) {
    let d3 = 0;
    for (let i3 = 0; i3 < 32; i3++) {
      d3 |= x2[i3] ^ y3[i3];
    }
    return (1 & d3 - 1 >>> 8) - 1;
  }
  function neq25519(a3, b4) {
    const c2 = new Uint8Array(32);
    const d3 = new Uint8Array(32);
    pack25519(c2, a3);
    pack25519(d3, b4);
    return verify32(c2, d3);
  }
  function par25519(a3) {
    const d3 = new Uint8Array(32);
    pack25519(d3, a3);
    return d3[0] & 1;
  }
  function unpack25519(o2, n4) {
    for (let i3 = 0; i3 < 16; i3++) {
      o2[i3] = n4[2 * i3] + (n4[2 * i3 + 1] << 8);
    }
    o2[15] &= 32767;
  }
  function add3(o2, a3, b4) {
    for (let i3 = 0; i3 < 16; i3++) {
      o2[i3] = a3[i3] + b4[i3];
    }
  }
  function sub(o2, a3, b4) {
    for (let i3 = 0; i3 < 16; i3++) {
      o2[i3] = a3[i3] - b4[i3];
    }
  }
  function mul5(o2, a3, b4) {
    let v4, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b4[0], b1 = b4[1], b22 = b4[2], b32 = b4[3], b42 = b4[4], b5 = b4[5], b6 = b4[6], b7 = b4[7], b8 = b4[8], b9 = b4[9], b10 = b4[10], b11 = b4[11], b12 = b4[12], b13 = b4[13], b14 = b4[14], b15 = b4[15];
    v4 = a3[0];
    t0 += v4 * b0;
    t1 += v4 * b1;
    t2 += v4 * b22;
    t3 += v4 * b32;
    t4 += v4 * b42;
    t5 += v4 * b5;
    t6 += v4 * b6;
    t7 += v4 * b7;
    t8 += v4 * b8;
    t9 += v4 * b9;
    t10 += v4 * b10;
    t11 += v4 * b11;
    t12 += v4 * b12;
    t13 += v4 * b13;
    t14 += v4 * b14;
    t15 += v4 * b15;
    v4 = a3[1];
    t1 += v4 * b0;
    t2 += v4 * b1;
    t3 += v4 * b22;
    t4 += v4 * b32;
    t5 += v4 * b42;
    t6 += v4 * b5;
    t7 += v4 * b6;
    t8 += v4 * b7;
    t9 += v4 * b8;
    t10 += v4 * b9;
    t11 += v4 * b10;
    t12 += v4 * b11;
    t13 += v4 * b12;
    t14 += v4 * b13;
    t15 += v4 * b14;
    t16 += v4 * b15;
    v4 = a3[2];
    t2 += v4 * b0;
    t3 += v4 * b1;
    t4 += v4 * b22;
    t5 += v4 * b32;
    t6 += v4 * b42;
    t7 += v4 * b5;
    t8 += v4 * b6;
    t9 += v4 * b7;
    t10 += v4 * b8;
    t11 += v4 * b9;
    t12 += v4 * b10;
    t13 += v4 * b11;
    t14 += v4 * b12;
    t15 += v4 * b13;
    t16 += v4 * b14;
    t17 += v4 * b15;
    v4 = a3[3];
    t3 += v4 * b0;
    t4 += v4 * b1;
    t5 += v4 * b22;
    t6 += v4 * b32;
    t7 += v4 * b42;
    t8 += v4 * b5;
    t9 += v4 * b6;
    t10 += v4 * b7;
    t11 += v4 * b8;
    t12 += v4 * b9;
    t13 += v4 * b10;
    t14 += v4 * b11;
    t15 += v4 * b12;
    t16 += v4 * b13;
    t17 += v4 * b14;
    t18 += v4 * b15;
    v4 = a3[4];
    t4 += v4 * b0;
    t5 += v4 * b1;
    t6 += v4 * b22;
    t7 += v4 * b32;
    t8 += v4 * b42;
    t9 += v4 * b5;
    t10 += v4 * b6;
    t11 += v4 * b7;
    t12 += v4 * b8;
    t13 += v4 * b9;
    t14 += v4 * b10;
    t15 += v4 * b11;
    t16 += v4 * b12;
    t17 += v4 * b13;
    t18 += v4 * b14;
    t19 += v4 * b15;
    v4 = a3[5];
    t5 += v4 * b0;
    t6 += v4 * b1;
    t7 += v4 * b22;
    t8 += v4 * b32;
    t9 += v4 * b42;
    t10 += v4 * b5;
    t11 += v4 * b6;
    t12 += v4 * b7;
    t13 += v4 * b8;
    t14 += v4 * b9;
    t15 += v4 * b10;
    t16 += v4 * b11;
    t17 += v4 * b12;
    t18 += v4 * b13;
    t19 += v4 * b14;
    t20 += v4 * b15;
    v4 = a3[6];
    t6 += v4 * b0;
    t7 += v4 * b1;
    t8 += v4 * b22;
    t9 += v4 * b32;
    t10 += v4 * b42;
    t11 += v4 * b5;
    t12 += v4 * b6;
    t13 += v4 * b7;
    t14 += v4 * b8;
    t15 += v4 * b9;
    t16 += v4 * b10;
    t17 += v4 * b11;
    t18 += v4 * b12;
    t19 += v4 * b13;
    t20 += v4 * b14;
    t21 += v4 * b15;
    v4 = a3[7];
    t7 += v4 * b0;
    t8 += v4 * b1;
    t9 += v4 * b22;
    t10 += v4 * b32;
    t11 += v4 * b42;
    t12 += v4 * b5;
    t13 += v4 * b6;
    t14 += v4 * b7;
    t15 += v4 * b8;
    t16 += v4 * b9;
    t17 += v4 * b10;
    t18 += v4 * b11;
    t19 += v4 * b12;
    t20 += v4 * b13;
    t21 += v4 * b14;
    t22 += v4 * b15;
    v4 = a3[8];
    t8 += v4 * b0;
    t9 += v4 * b1;
    t10 += v4 * b22;
    t11 += v4 * b32;
    t12 += v4 * b42;
    t13 += v4 * b5;
    t14 += v4 * b6;
    t15 += v4 * b7;
    t16 += v4 * b8;
    t17 += v4 * b9;
    t18 += v4 * b10;
    t19 += v4 * b11;
    t20 += v4 * b12;
    t21 += v4 * b13;
    t22 += v4 * b14;
    t23 += v4 * b15;
    v4 = a3[9];
    t9 += v4 * b0;
    t10 += v4 * b1;
    t11 += v4 * b22;
    t12 += v4 * b32;
    t13 += v4 * b42;
    t14 += v4 * b5;
    t15 += v4 * b6;
    t16 += v4 * b7;
    t17 += v4 * b8;
    t18 += v4 * b9;
    t19 += v4 * b10;
    t20 += v4 * b11;
    t21 += v4 * b12;
    t22 += v4 * b13;
    t23 += v4 * b14;
    t24 += v4 * b15;
    v4 = a3[10];
    t10 += v4 * b0;
    t11 += v4 * b1;
    t12 += v4 * b22;
    t13 += v4 * b32;
    t14 += v4 * b42;
    t15 += v4 * b5;
    t16 += v4 * b6;
    t17 += v4 * b7;
    t18 += v4 * b8;
    t19 += v4 * b9;
    t20 += v4 * b10;
    t21 += v4 * b11;
    t22 += v4 * b12;
    t23 += v4 * b13;
    t24 += v4 * b14;
    t25 += v4 * b15;
    v4 = a3[11];
    t11 += v4 * b0;
    t12 += v4 * b1;
    t13 += v4 * b22;
    t14 += v4 * b32;
    t15 += v4 * b42;
    t16 += v4 * b5;
    t17 += v4 * b6;
    t18 += v4 * b7;
    t19 += v4 * b8;
    t20 += v4 * b9;
    t21 += v4 * b10;
    t22 += v4 * b11;
    t23 += v4 * b12;
    t24 += v4 * b13;
    t25 += v4 * b14;
    t26 += v4 * b15;
    v4 = a3[12];
    t12 += v4 * b0;
    t13 += v4 * b1;
    t14 += v4 * b22;
    t15 += v4 * b32;
    t16 += v4 * b42;
    t17 += v4 * b5;
    t18 += v4 * b6;
    t19 += v4 * b7;
    t20 += v4 * b8;
    t21 += v4 * b9;
    t22 += v4 * b10;
    t23 += v4 * b11;
    t24 += v4 * b12;
    t25 += v4 * b13;
    t26 += v4 * b14;
    t27 += v4 * b15;
    v4 = a3[13];
    t13 += v4 * b0;
    t14 += v4 * b1;
    t15 += v4 * b22;
    t16 += v4 * b32;
    t17 += v4 * b42;
    t18 += v4 * b5;
    t19 += v4 * b6;
    t20 += v4 * b7;
    t21 += v4 * b8;
    t22 += v4 * b9;
    t23 += v4 * b10;
    t24 += v4 * b11;
    t25 += v4 * b12;
    t26 += v4 * b13;
    t27 += v4 * b14;
    t28 += v4 * b15;
    v4 = a3[14];
    t14 += v4 * b0;
    t15 += v4 * b1;
    t16 += v4 * b22;
    t17 += v4 * b32;
    t18 += v4 * b42;
    t19 += v4 * b5;
    t20 += v4 * b6;
    t21 += v4 * b7;
    t22 += v4 * b8;
    t23 += v4 * b9;
    t24 += v4 * b10;
    t25 += v4 * b11;
    t26 += v4 * b12;
    t27 += v4 * b13;
    t28 += v4 * b14;
    t29 += v4 * b15;
    v4 = a3[15];
    t15 += v4 * b0;
    t16 += v4 * b1;
    t17 += v4 * b22;
    t18 += v4 * b32;
    t19 += v4 * b42;
    t20 += v4 * b5;
    t21 += v4 * b6;
    t22 += v4 * b7;
    t23 += v4 * b8;
    t24 += v4 * b9;
    t25 += v4 * b10;
    t26 += v4 * b11;
    t27 += v4 * b12;
    t28 += v4 * b13;
    t29 += v4 * b14;
    t30 += v4 * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c2 = 1;
    v4 = t0 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t0 = v4 - c2 * 65536;
    v4 = t1 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t1 = v4 - c2 * 65536;
    v4 = t2 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t2 = v4 - c2 * 65536;
    v4 = t3 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t3 = v4 - c2 * 65536;
    v4 = t4 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t4 = v4 - c2 * 65536;
    v4 = t5 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t5 = v4 - c2 * 65536;
    v4 = t6 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t6 = v4 - c2 * 65536;
    v4 = t7 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t7 = v4 - c2 * 65536;
    v4 = t8 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t8 = v4 - c2 * 65536;
    v4 = t9 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t9 = v4 - c2 * 65536;
    v4 = t10 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t10 = v4 - c2 * 65536;
    v4 = t11 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t11 = v4 - c2 * 65536;
    v4 = t12 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t12 = v4 - c2 * 65536;
    v4 = t13 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t13 = v4 - c2 * 65536;
    v4 = t14 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t14 = v4 - c2 * 65536;
    v4 = t15 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t15 = v4 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    c2 = 1;
    v4 = t0 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t0 = v4 - c2 * 65536;
    v4 = t1 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t1 = v4 - c2 * 65536;
    v4 = t2 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t2 = v4 - c2 * 65536;
    v4 = t3 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t3 = v4 - c2 * 65536;
    v4 = t4 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t4 = v4 - c2 * 65536;
    v4 = t5 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t5 = v4 - c2 * 65536;
    v4 = t6 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t6 = v4 - c2 * 65536;
    v4 = t7 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t7 = v4 - c2 * 65536;
    v4 = t8 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t8 = v4 - c2 * 65536;
    v4 = t9 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t9 = v4 - c2 * 65536;
    v4 = t10 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t10 = v4 - c2 * 65536;
    v4 = t11 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t11 = v4 - c2 * 65536;
    v4 = t12 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t12 = v4 - c2 * 65536;
    v4 = t13 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t13 = v4 - c2 * 65536;
    v4 = t14 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t14 = v4 - c2 * 65536;
    v4 = t15 + c2 + 65535;
    c2 = Math.floor(v4 / 65536);
    t15 = v4 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    o2[0] = t0;
    o2[1] = t1;
    o2[2] = t2;
    o2[3] = t3;
    o2[4] = t4;
    o2[5] = t5;
    o2[6] = t6;
    o2[7] = t7;
    o2[8] = t8;
    o2[9] = t9;
    o2[10] = t10;
    o2[11] = t11;
    o2[12] = t12;
    o2[13] = t13;
    o2[14] = t14;
    o2[15] = t15;
  }
  function square(o2, a3) {
    mul5(o2, a3, a3);
  }
  function inv25519(o2, i3) {
    const c2 = gf2();
    let a3;
    for (a3 = 0; a3 < 16; a3++) {
      c2[a3] = i3[a3];
    }
    for (a3 = 253; a3 >= 0; a3--) {
      square(c2, c2);
      if (a3 !== 2 && a3 !== 4) {
        mul5(c2, c2, i3);
      }
    }
    for (a3 = 0; a3 < 16; a3++) {
      o2[a3] = c2[a3];
    }
  }
  function pow2523(o2, i3) {
    const c2 = gf2();
    let a3;
    for (a3 = 0; a3 < 16; a3++) {
      c2[a3] = i3[a3];
    }
    for (a3 = 250; a3 >= 0; a3--) {
      square(c2, c2);
      if (a3 !== 1) {
        mul5(c2, c2, i3);
      }
    }
    for (a3 = 0; a3 < 16; a3++) {
      o2[a3] = c2[a3];
    }
  }
  function edadd(p3, q2) {
    const a3 = gf2(), b4 = gf2(), c2 = gf2(), d3 = gf2(), e2 = gf2(), f4 = gf2(), g3 = gf2(), h5 = gf2(), t2 = gf2();
    sub(a3, p3[1], p3[0]);
    sub(t2, q2[1], q2[0]);
    mul5(a3, a3, t2);
    add3(b4, p3[0], p3[1]);
    add3(t2, q2[0], q2[1]);
    mul5(b4, b4, t2);
    mul5(c2, p3[3], q2[3]);
    mul5(c2, c2, D22);
    mul5(d3, p3[2], q2[2]);
    add3(d3, d3, d3);
    sub(e2, b4, a3);
    sub(f4, d3, c2);
    add3(g3, d3, c2);
    add3(h5, b4, a3);
    mul5(p3[0], e2, f4);
    mul5(p3[1], h5, g3);
    mul5(p3[2], g3, f4);
    mul5(p3[3], e2, h5);
  }
  function cswap(p3, q2, b4) {
    for (let i3 = 0; i3 < 4; i3++) {
      sel25519(p3[i3], q2[i3], b4);
    }
  }
  function pack2(r2, p3) {
    const tx = gf2(), ty = gf2(), zi2 = gf2();
    inv25519(zi2, p3[2]);
    mul5(tx, p3[0], zi2);
    mul5(ty, p3[1], zi2);
    pack25519(r2, ty);
    r2[31] ^= par25519(tx) << 7;
  }
  function scalarmult(p3, q2, s3) {
    set25519(p3[0], gf0);
    set25519(p3[1], gf1);
    set25519(p3[2], gf1);
    set25519(p3[3], gf0);
    for (let i3 = 255; i3 >= 0; --i3) {
      const b4 = s3[i3 / 8 | 0] >> (i3 & 7) & 1;
      cswap(p3, q2, b4);
      edadd(q2, p3);
      edadd(p3, p3);
      cswap(p3, q2, b4);
    }
  }
  function scalarbase(p3, s3) {
    const q2 = [gf2(), gf2(), gf2(), gf2()];
    set25519(q2[0], X2);
    set25519(q2[1], Y2);
    set25519(q2[2], gf1);
    mul5(q2[3], X2, Y2);
    scalarmult(p3, q2, s3);
  }
  function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports2.SEED_LENGTH) {
      throw new Error(`ed25519: seed must be ${exports2.SEED_LENGTH} bytes`);
    }
    const d3 = (0, sha512_1.hash)(seed);
    d3[0] &= 248;
    d3[31] &= 127;
    d3[31] |= 64;
    const publicKey = new Uint8Array(32);
    const p3 = [gf2(), gf2(), gf2(), gf2()];
    scalarbase(p3, d3);
    pack2(publicKey, p3);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey, 32);
    return {
      publicKey,
      secretKey
    };
  }
  exports2.generateKeyPairFromSeed = generateKeyPairFromSeed;
  function generateKeyPair2(prng) {
    const seed = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed);
    (0, wipe_12.wipe)(seed);
    return result;
  }
  exports2.generateKeyPair = generateKeyPair2;
  function extractPublicKeyFromSecretKey(secretKey) {
    if (secretKey.length !== exports2.SECRET_KEY_LENGTH) {
      throw new Error(`ed25519: secret key must be ${exports2.SECRET_KEY_LENGTH} bytes`);
    }
    return new Uint8Array(secretKey.subarray(32));
  }
  exports2.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
  const L3 = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function modL(r2, x2) {
    let carry;
    let i3;
    let j2;
    let k3;
    for (i3 = 63; i3 >= 32; --i3) {
      carry = 0;
      for (j2 = i3 - 32, k3 = i3 - 12; j2 < k3; ++j2) {
        x2[j2] += carry - 16 * x2[i3] * L3[j2 - (i3 - 32)];
        carry = Math.floor((x2[j2] + 128) / 256);
        x2[j2] -= carry * 256;
      }
      x2[j2] += carry;
      x2[i3] = 0;
    }
    carry = 0;
    for (j2 = 0; j2 < 32; j2++) {
      x2[j2] += carry - (x2[31] >> 4) * L3[j2];
      carry = x2[j2] >> 8;
      x2[j2] &= 255;
    }
    for (j2 = 0; j2 < 32; j2++) {
      x2[j2] -= carry * L3[j2];
    }
    for (i3 = 0; i3 < 32; i3++) {
      x2[i3 + 1] += x2[i3] >> 8;
      r2[i3] = x2[i3] & 255;
    }
  }
  function reduce2(r2) {
    const x2 = new Float64Array(64);
    for (let i3 = 0; i3 < 64; i3++) {
      x2[i3] = r2[i3];
    }
    for (let i3 = 0; i3 < 64; i3++) {
      r2[i3] = 0;
    }
    modL(r2, x2);
  }
  function sign3(secretKey, message) {
    const x2 = new Float64Array(64);
    const p3 = [gf2(), gf2(), gf2(), gf2()];
    const d3 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
    d3[0] &= 248;
    d3[31] &= 127;
    d3[31] |= 64;
    const signature2 = new Uint8Array(64);
    signature2.set(d3.subarray(32), 32);
    const hs2 = new sha512_1.SHA512();
    hs2.update(signature2.subarray(32));
    hs2.update(message);
    const r2 = hs2.digest();
    hs2.clean();
    reduce2(r2);
    scalarbase(p3, r2);
    pack2(signature2, p3);
    hs2.reset();
    hs2.update(signature2.subarray(0, 32));
    hs2.update(secretKey.subarray(32));
    hs2.update(message);
    const h5 = hs2.digest();
    reduce2(h5);
    for (let i3 = 0; i3 < 32; i3++) {
      x2[i3] = r2[i3];
    }
    for (let i3 = 0; i3 < 32; i3++) {
      for (let j2 = 0; j2 < 32; j2++) {
        x2[i3 + j2] += h5[i3] * d3[j2];
      }
    }
    modL(signature2.subarray(32), x2);
    return signature2;
  }
  exports2.sign = sign3;
  function unpackneg(r2, p3) {
    const t2 = gf2(), chk = gf2(), num = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
    set25519(r2[2], gf1);
    unpack25519(r2[1], p3);
    square(num, r2[1]);
    mul5(den, num, D2);
    sub(num, num, r2[2]);
    add3(den, r2[2], den);
    square(den2, den);
    square(den4, den2);
    mul5(den6, den4, den2);
    mul5(t2, den6, num);
    mul5(t2, t2, den);
    pow2523(t2, t2);
    mul5(t2, t2, num);
    mul5(t2, t2, den);
    mul5(t2, t2, den);
    mul5(r2[0], t2, den);
    square(chk, r2[0]);
    mul5(chk, chk, den);
    if (neq25519(chk, num)) {
      mul5(r2[0], r2[0], I3);
    }
    square(chk, r2[0]);
    mul5(chk, chk, den);
    if (neq25519(chk, num)) {
      return -1;
    }
    if (par25519(r2[0]) === p3[31] >> 7) {
      sub(r2[0], gf0, r2[0]);
    }
    mul5(r2[3], r2[0], r2[1]);
    return 0;
  }
  function verify3(publicKey, message, signature2) {
    const t2 = new Uint8Array(32);
    const p3 = [gf2(), gf2(), gf2(), gf2()];
    const q2 = [gf2(), gf2(), gf2(), gf2()];
    if (signature2.length !== exports2.SIGNATURE_LENGTH) {
      throw new Error(`ed25519: signature must be ${exports2.SIGNATURE_LENGTH} bytes`);
    }
    if (unpackneg(q2, publicKey)) {
      return false;
    }
    const hs2 = new sha512_1.SHA512();
    hs2.update(signature2.subarray(0, 32));
    hs2.update(publicKey);
    hs2.update(message);
    const h5 = hs2.digest();
    reduce2(h5);
    scalarmult(p3, q2, h5);
    scalarbase(q2, signature2.subarray(32));
    edadd(p3, q2);
    pack2(t2, p3);
    if (verify32(signature2, t2)) {
      return false;
    }
    return true;
  }
  exports2.verify = verify3;
  function convertPublicKeyToX25519(publicKey) {
    let q2 = [gf2(), gf2(), gf2(), gf2()];
    if (unpackneg(q2, publicKey)) {
      throw new Error("Ed25519: invalid public key");
    }
    let a3 = gf2();
    let b4 = gf2();
    let y3 = q2[1];
    add3(a3, gf1, y3);
    sub(b4, gf1, y3);
    inv25519(b4, b4);
    mul5(a3, a3, b4);
    let z2 = new Uint8Array(32);
    pack25519(z2, a3);
    return z2;
  }
  exports2.convertPublicKeyToX25519 = convertPublicKeyToX25519;
  function convertSecretKeyToX25519(secretKey) {
    const d3 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
    d3[0] &= 248;
    d3[31] &= 127;
    d3[31] |= 64;
    const o2 = new Uint8Array(d3.subarray(0, 32));
    (0, wipe_12.wipe)(d3);
    return o2;
  }
  exports2.convertSecretKeyToX25519 = convertSecretKeyToX25519;
})(ed25519);
const JWT_IRIDIUM_ALG = "EdDSA";
const JWT_IRIDIUM_TYP = "JWT";
const JWT_DELIMITER = ".";
const JWT_ENCODING = "base64url";
const JSON_ENCODING = "utf8";
const DATA_ENCODING = "utf8";
const DID_DELIMITER = ":";
const DID_PREFIX = "did";
const DID_METHOD = "key";
const MULTICODEC_ED25519_ENCODING = "base58btc";
const MULTICODEC_ED25519_BASE = "z";
const MULTICODEC_ED25519_HEADER = "K36";
const KEY_PAIR_SEED_LENGTH = 32;
function allocUnsafe$1(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return globalThis.Buffer.allocUnsafe(size2);
  }
  return new Uint8Array(size2);
}
function concat$4(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe$1(length2);
  let offset = 0;
  for (const arr2 of arrays) {
    output.set(arr2, offset);
    offset += arr2.length;
  }
  return output;
}
const concat$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  concat: concat$4
}, Symbol.toStringTag, { value: "Module" }));
function createCodec$1(name2, prefix, encode5, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode5
    },
    decoder: { decode: decode2 }
  };
}
const string$2 = createCodec$1("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii$1 = createCodec$1("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i3 = 0; i3 < buf2.length; i3++) {
    string2 += String.fromCharCode(buf2[i3]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe$1(str.length);
  for (let i3 = 0; i3 < str.length; i3++) {
    buf2[i3] = str.charCodeAt(i3);
  }
  return buf2;
});
const BASES$1 = {
  utf8: string$2,
  "utf-8": string$2,
  hex: bases.base16,
  latin1: ascii$1,
  ascii: ascii$1,
  binary: ascii$1,
  ...bases
};
function toString$4(array2, encoding = "utf8") {
  const base3 = BASES$1[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array2.buffer, array2.byteOffset, array2.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array2).substring(1);
}
function fromString$2(string2, encoding = "utf8") {
  const base3 = BASES$1[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(string2, "utf8");
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
const fromString$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fromString: fromString$2
}, Symbol.toStringTag, { value: "Module" }));
function encodeJSON(val) {
  return toString$4(fromString$2(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(publicKey) {
  const header = fromString$2(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
  const multicodec = MULTICODEC_ED25519_BASE + toString$4(concat$4([header, publicKey]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
}
function encodeSig(bytes2) {
  return toString$4(bytes2, JWT_ENCODING);
}
function encodeData(params) {
  return fromString$2([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(params) {
  return [
    encodeJSON(params.header),
    encodeJSON(params.payload),
    encodeSig(params.signature)
  ].join(JWT_DELIMITER);
}
function generateKeyPair(seed = random$2.randomBytes(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(seed);
}
async function signJWT(sub, aud, ttl, keyPair2, iat = cjs$d.fromMiliseconds(Date.now())) {
  const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
  const iss = encodeIss(keyPair2.publicKey);
  const exp3 = iat + ttl;
  const payload = { iss, sub, aud, iat, exp: exp3 };
  const data2 = encodeData({ header, payload });
  const signature2 = ed25519.sign(keyPair2.secretKey, data2);
  return encodeJWT({ header, payload, signature: signature2 });
}
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}
function allocUnsafe(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}
function concat$3(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length2);
  let offset = 0;
  for (const arr2 of arrays) {
    output.set(arr2, offset);
    offset += arr2.length;
  }
  return asUint8Array(output);
}
function createCodec(name2, prefix, encode5, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode5
    },
    decoder: { decode: decode2 }
  };
}
const string$1 = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i3 = 0; i3 < buf2.length; i3++) {
    string2 += String.fromCharCode(buf2[i3]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i3 = 0; i3 < str.length; i3++) {
    buf2[i3] = str.charCodeAt(i3);
  }
  return buf2;
});
const BASES = {
  utf8: string$1,
  "utf-8": string$1,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function fromString$1(string2, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
function toString$3(array2, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array2.buffer, array2.byteOffset, array2.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array2).substring(1);
}
var cjs$6 = {};
Object.defineProperty(cjs$6, "__esModule", { value: true });
var getLocalStorage_1$1 = cjs$6.getLocalStorage = getLocalStorageOrThrow_1$1 = cjs$6.getLocalStorageOrThrow = getCrypto_1$1 = cjs$6.getCrypto = getCryptoOrThrow_1$1 = cjs$6.getCryptoOrThrow = getLocation_1$1 = cjs$6.getLocation = getLocationOrThrow_1$1 = cjs$6.getLocationOrThrow = getNavigator_1$1 = cjs$6.getNavigator = getNavigatorOrThrow_1$1 = cjs$6.getNavigatorOrThrow = getDocument_1$1 = cjs$6.getDocument = getDocumentOrThrow_1$1 = cjs$6.getDocumentOrThrow = getFromWindowOrThrow_1$1 = cjs$6.getFromWindowOrThrow = getFromWindow_1$1 = cjs$6.getFromWindow = void 0;
function getFromWindow$1(name2) {
  let res = void 0;
  if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
    res = window[name2];
  }
  return res;
}
var getFromWindow_1$1 = cjs$6.getFromWindow = getFromWindow$1;
function getFromWindowOrThrow$1(name2) {
  const res = getFromWindow$1(name2);
  if (!res) {
    throw new Error(`${name2} is not defined in Window`);
  }
  return res;
}
var getFromWindowOrThrow_1$1 = cjs$6.getFromWindowOrThrow = getFromWindowOrThrow$1;
function getDocumentOrThrow$1() {
  return getFromWindowOrThrow$1("document");
}
var getDocumentOrThrow_1$1 = cjs$6.getDocumentOrThrow = getDocumentOrThrow$1;
function getDocument$1() {
  return getFromWindow$1("document");
}
var getDocument_1$1 = cjs$6.getDocument = getDocument$1;
function getNavigatorOrThrow$1() {
  return getFromWindowOrThrow$1("navigator");
}
var getNavigatorOrThrow_1$1 = cjs$6.getNavigatorOrThrow = getNavigatorOrThrow$1;
function getNavigator$1() {
  return getFromWindow$1("navigator");
}
var getNavigator_1$1 = cjs$6.getNavigator = getNavigator$1;
function getLocationOrThrow$1() {
  return getFromWindowOrThrow$1("location");
}
var getLocationOrThrow_1$1 = cjs$6.getLocationOrThrow = getLocationOrThrow$1;
function getLocation$1() {
  return getFromWindow$1("location");
}
var getLocation_1$1 = cjs$6.getLocation = getLocation$1;
function getCryptoOrThrow$1() {
  return getFromWindowOrThrow$1("crypto");
}
var getCryptoOrThrow_1$1 = cjs$6.getCryptoOrThrow = getCryptoOrThrow$1;
function getCrypto$1() {
  return getFromWindow$1("crypto");
}
var getCrypto_1$1 = cjs$6.getCrypto = getCrypto$1;
function getLocalStorageOrThrow$1() {
  return getFromWindowOrThrow$1("localStorage");
}
var getLocalStorageOrThrow_1$1 = cjs$6.getLocalStorageOrThrow = getLocalStorageOrThrow$1;
function getLocalStorage$1() {
  return getFromWindow$1("localStorage");
}
getLocalStorage_1$1 = cjs$6.getLocalStorage = getLocalStorage$1;
const cjs$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: cjs$6,
  get getCrypto() {
    return getCrypto_1$1;
  },
  get getCryptoOrThrow() {
    return getCryptoOrThrow_1$1;
  },
  get getDocument() {
    return getDocument_1$1;
  },
  get getDocumentOrThrow() {
    return getDocumentOrThrow_1$1;
  },
  get getFromWindow() {
    return getFromWindow_1$1;
  },
  get getFromWindowOrThrow() {
    return getFromWindowOrThrow_1$1;
  },
  get getLocalStorage() {
    return getLocalStorage_1$1;
  },
  get getLocalStorageOrThrow() {
    return getLocalStorageOrThrow_1$1;
  },
  get getLocation() {
    return getLocation_1$1;
  },
  get getLocationOrThrow() {
    return getLocationOrThrow_1$1;
  },
  get getNavigator() {
    return getNavigator_1$1;
  },
  get getNavigatorOrThrow() {
    return getNavigatorOrThrow_1$1;
  }
}, [cjs$6]);
var cjs$4 = {};
const require$$0$18 = /* @__PURE__ */ getAugmentedNamespace(cjs$5);
Object.defineProperty(cjs$4, "__esModule", { value: true });
var getWindowMetadata_1 = cjs$4.getWindowMetadata = void 0;
const window_getters_1$1 = require$$0$18;
function getWindowMetadata$1() {
  let doc;
  let loc;
  try {
    doc = window_getters_1$1.getDocumentOrThrow();
    loc = window_getters_1$1.getLocationOrThrow();
  } catch (e2) {
    return null;
  }
  function getIcons() {
    const links2 = doc.getElementsByTagName("link");
    const icons2 = [];
    for (let i3 = 0; i3 < links2.length; i3++) {
      const link = links2[i3];
      const rel = link.getAttribute("rel");
      if (rel) {
        if (rel.toLowerCase().indexOf("icon") > -1) {
          const href = link.getAttribute("href");
          if (href) {
            if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
              let absoluteHref = loc.protocol + "//" + loc.host;
              if (href.indexOf("/") === 0) {
                absoluteHref += href;
              } else {
                const path = loc.pathname.split("/");
                path.pop();
                const finalPath = path.join("/");
                absoluteHref += finalPath + "/" + href;
              }
              icons2.push(absoluteHref);
            } else if (href.indexOf("//") === 0) {
              const absoluteUrl = loc.protocol + href;
              icons2.push(absoluteUrl);
            } else {
              icons2.push(href);
            }
          }
        }
      }
    }
    return icons2;
  }
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc.getElementsByTagName("meta");
    for (let i3 = 0; i3 < metaTags.length; i3++) {
      const tag = metaTags[i3];
      const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
        if (attr) {
          return args.includes(attr);
        }
        return false;
      });
      if (attributes.length && attributes) {
        const content = tag.getAttribute("content");
        if (content) {
          return content;
        }
      }
    }
    return "";
  }
  function getName() {
    let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    if (!name3) {
      name3 = doc.title;
    }
    return name3;
  }
  function getDescription() {
    const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
    return description2;
  }
  const name2 = getName();
  const description = getDescription();
  const url = loc.origin;
  const icons = getIcons();
  const meta = {
    description,
    url,
    icons,
    name: name2
  };
  return meta;
}
getWindowMetadata_1 = cjs$4.getWindowMetadata = getWindowMetadata$1;
var queryString$1 = {};
var token$1 = "%[a-f0-9]{2}";
var singleMatcher$1 = new RegExp("(" + token$1 + ")|([^%]+?)", "gi");
var multiMatcher$1 = new RegExp("(" + token$1 + ")+", "gi");
function decodeComponents$1(components, split) {
  try {
    return [decodeURIComponent(components.join(""))];
  } catch (err) {
  }
  if (components.length === 1) {
    return components;
  }
  split = split || 1;
  var left = components.slice(0, split);
  var right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents$1(left), decodeComponents$1(right));
}
function decode$b(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher$1) || [];
    for (var i3 = 1; i3 < tokens.length; i3++) {
      input = decodeComponents$1(tokens, i3).join("");
      tokens = input.match(singleMatcher$1) || [];
    }
    return input;
  }
}
function customDecodeURIComponent$1(input) {
  var replaceMap = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  };
  var match = multiMatcher$1.exec(input);
  while (match) {
    try {
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode$b(match[0]);
      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }
    match = multiMatcher$1.exec(input);
  }
  replaceMap["%C2"] = "�";
  var entries2 = Object.keys(replaceMap);
  for (var i3 = 0; i3 < entries2.length; i3++) {
    var key2 = entries2[i3];
    input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
  }
  return input;
}
var decodeUriComponent$2 = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent$1(encodedURI);
  }
};
const index$F = /* @__PURE__ */ getDefaultExportFromCjs(decodeUriComponent$2);
const decodeUriComponent$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$F
}, [decodeUriComponent$2]);
const require$$1$E = /* @__PURE__ */ getAugmentedNamespace(decodeUriComponent$3);
(function(exports2) {
  const strictUriEncode2 = require$$0$1c;
  const decodeComponent = require$$1$E;
  const splitOnFirst2 = require$$2$q;
  const filterObject = require$$3$h;
  const isNullOrUndefined = (value) => value === null || value === void 0;
  const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case "index":
        return (key2) => (result, value) => {
          const index2 = result.length;
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode5(key2, options), "[", index2, "]"].join("")];
          }
          return [
            ...result,
            [encode5(key2, options), "[", encode5(index2, options), "]=", encode5(value, options)].join("")
          ];
        };
      case "bracket":
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode5(key2, options), "[]"].join("")];
          }
          return [...result, [encode5(key2, options), "[]=", encode5(value, options)].join("")];
        };
      case "colon-list-separator":
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode5(key2, options), ":list="].join("")];
          }
          return [...result, [encode5(key2, options), ":list=", encode5(value, options)].join("")];
        };
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          value = value === null ? "" : value;
          if (result.length === 0) {
            return [[encode5(key2, options), keyValueSep, encode5(value, options)].join("")];
          }
          return [[result, encode5(value, options)].join(options.arrayFormatSeparator)];
        };
      }
      default:
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, encode5(key2, options)];
          }
          return [...result, [encode5(key2, options), "=", encode5(value, options)].join("")];
        };
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case "index":
        return (key2, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key2);
          key2 = key2.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = {};
          }
          accumulator[key2][result[1]] = value;
        };
      case "bracket":
        return (key2, value, accumulator) => {
          result = /(\[\])$/.exec(key2);
          key2 = key2.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = [value];
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
      case "colon-list-separator":
        return (key2, value, accumulator) => {
          result = /(:list)$/.exec(key2);
          key2 = key2.replace(/:list$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = [value];
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
      case "comma":
      case "separator":
        return (key2, value, accumulator) => {
          const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
          accumulator[key2] = newValue;
        };
      case "bracket-separator":
        return (key2, value, accumulator) => {
          const isArray2 = /(\[\])$/.test(key2);
          key2 = key2.replace(/\[\]$/, "");
          if (!isArray2) {
            accumulator[key2] = value ? decode2(value, options) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
          if (accumulator[key2] === void 0) {
            accumulator[key2] = arrayValue;
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], arrayValue);
        };
      default:
        return (key2, value, accumulator) => {
          if (accumulator[key2] === void 0) {
            accumulator[key2] = value;
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode5(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode2(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a3, b4) => Number(a3) - Number(b4)).map((key2) => input[key2]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash2 = url.slice(hashStart);
    }
    return hash2;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function parse2(query2, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);
    const ret = /* @__PURE__ */ Object.create(null);
    if (typeof query2 !== "string") {
      return ret;
    }
    query2 = query2.trim().replace(/^[?#&]/, "");
    if (!query2) {
      return ret;
    }
    for (const param of query2.split("&")) {
      if (param === "") {
        continue;
      }
      let [key2, value] = splitOnFirst2(options.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
      formatter(decode2(key2, options), value, ret);
    }
    for (const key2 of Object.keys(ret)) {
      const value = ret[key2];
      if (typeof value === "object" && value !== null) {
        for (const k3 of Object.keys(value)) {
          value[k3] = parseValue(value[k3], options);
        }
      } else {
        ret[key2] = parseValue(value, options);
      }
    }
    if (options.sort === false) {
      return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
      const value = ret[key2];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key2] = keysSorter(value);
      } else {
        result[key2] = value;
      }
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  exports2.extract = extract;
  exports2.parse = parse2;
  exports2.stringify = (object2, options) => {
    if (!object2) {
      return "";
    }
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object2[key2]) || options.skipEmptyString && object2[key2] === "";
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key2 of Object.keys(object2)) {
      if (!shouldFilter(key2)) {
        objectCopy[key2] = object2[key2];
      }
    }
    const keys2 = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys2.sort(options.sort);
    }
    return keys2.map((key2) => {
      const value = object2[key2];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode5(key2, options);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === "bracket-separator") {
          return encode5(key2, options) + "[]";
        }
        return value.reduce(formatter(key2), []).join("&");
      }
      return encode5(key2, options) + "=" + encode5(value, options);
    }).filter((x2) => x2.length > 0).join("&");
  };
  exports2.parseUrl = (url, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url_, hash2] = splitOnFirst2(url, "#");
    return Object.assign(
      {
        url: url_.split("?")[0] || "",
        query: parse2(extract(url), options)
      },
      options && options.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options) } : {}
    );
  };
  exports2.stringifyUrl = (object2, options) => {
    options = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options);
    const url = removeHash(object2.url).split("?")[0] || "";
    const queryFromUrl = exports2.extract(object2.url);
    const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
    const query2 = Object.assign(parsedQueryFromUrl, object2.query);
    let queryString2 = exports2.stringify(query2, options);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash2 = getHash(object2.url);
    if (object2.fragmentIdentifier) {
      hash2 = `#${options[encodeFragmentIdentifier] ? encode5(object2.fragmentIdentifier, options) : object2.fragmentIdentifier}`;
    }
    return `${url}${queryString2}${hash2}`;
  };
  exports2.pick = (input, filter2, options) => {
    options = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options);
    const { url, query: query2, fragmentIdentifier } = exports2.parseUrl(input, options);
    return exports2.stringifyUrl({
      url,
      query: filterObject(query2, filter2),
      fragmentIdentifier
    }, options);
  };
  exports2.exclude = (input, filter2, options) => {
    const exclusionFilter = Array.isArray(filter2) ? (key2) => !filter2.includes(key2) : (key2, value) => !filter2(key2, value);
    return exports2.pick(input, exclusionFilter, options);
  };
})(queryString$1);
function L$4(e2, n4) {
  return e2.includes(":") ? [e2] : n4.chains || [];
}
const J = "base10", p$5 = "base16", F$5 = "base64pad", H$4 = "utf8", Q$5 = 0, _$4 = 1, Dn = 0, Pe$1 = 1, Z$2 = 12, X$2 = 32;
function kn() {
  const e2 = x25519.generateKeyPair();
  return { privateKey: toString$3(e2.secretKey, p$5), publicKey: toString$3(e2.publicKey, p$5) };
}
function Vn$1() {
  const e2 = random$2.randomBytes(X$2);
  return toString$3(e2, p$5);
}
function Mn(e2, n4) {
  const t2 = x25519.sharedKey(fromString$1(e2, p$5), fromString$1(n4, p$5), true), r2 = new HKDF_1(sha256$4.SHA256, t2).expand(X$2);
  return toString$3(r2, p$5);
}
function Kn(e2) {
  const n4 = sha256$4.hash(fromString$1(e2, p$5));
  return toString$3(n4, p$5);
}
function Ln(e2) {
  const n4 = sha256$4.hash(fromString$1(e2, H$4));
  return toString$3(n4, p$5);
}
function Re$1(e2) {
  return fromString$1(`${e2}`, J);
}
function $$3(e2) {
  return Number(toString$3(e2, J));
}
function xn(e2) {
  const n4 = Re$1(typeof e2.type < "u" ? e2.type : Q$5);
  if ($$3(n4) === _$4 && typeof e2.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t2 = typeof e2.senderPublicKey < "u" ? fromString$1(e2.senderPublicKey, p$5) : void 0, r2 = typeof e2.iv < "u" ? fromString$1(e2.iv, p$5) : random$2.randomBytes(Z$2), o2 = new chacha20poly1305.ChaCha20Poly1305(fromString$1(e2.symKey, p$5)).seal(r2, fromString$1(e2.message, H$4));
  return Te$1({ type: n4, sealed: o2, iv: r2, senderPublicKey: t2 });
}
function Fn(e2) {
  const n4 = new chacha20poly1305.ChaCha20Poly1305(fromString$1(e2.symKey, p$5)), { sealed: t2, iv: r2 } = ee$2(e2.encoded), o2 = n4.open(r2, t2);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString$3(o2, H$4);
}
function Te$1(e2) {
  if ($$3(e2.type) === _$4) {
    if (typeof e2.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString$3(concat$3([e2.type, e2.senderPublicKey, e2.iv, e2.sealed]), F$5);
  }
  return toString$3(concat$3([e2.type, e2.iv, e2.sealed]), F$5);
}
function ee$2(e2) {
  const n4 = fromString$1(e2, F$5), t2 = n4.slice(Dn, Pe$1), r2 = Pe$1;
  if ($$3(t2) === _$4) {
    const d3 = r2 + X$2, l2 = d3 + Z$2, c2 = n4.slice(r2, d3), u3 = n4.slice(d3, l2), a3 = n4.slice(l2);
    return { type: t2, sealed: a3, iv: u3, senderPublicKey: c2 };
  }
  const o2 = r2 + Z$2, s3 = n4.slice(r2, o2), i3 = n4.slice(o2);
  return { type: t2, sealed: i3, iv: s3 };
}
function Hn(e2, n4) {
  const t2 = ee$2(e2);
  return Ae$1({ type: $$3(t2.type), senderPublicKey: typeof t2.senderPublicKey < "u" ? toString$3(t2.senderPublicKey, p$5) : void 0, receiverPublicKey: n4?.receiverPublicKey });
}
function Ae$1(e2) {
  const n4 = e2?.type || Q$5;
  if (n4 === _$4) {
    if (typeof e2?.senderPublicKey > "u")
      throw new Error("missing sender public key");
    if (typeof e2?.receiverPublicKey > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n4, senderPublicKey: e2?.senderPublicKey, receiverPublicKey: e2?.receiverPublicKey };
}
function qn(e2) {
  return e2.type === _$4 && typeof e2.senderPublicKey == "string" && typeof e2.receiverPublicKey == "string";
}
var Bn = Object.defineProperty, Ue$2 = Object.getOwnPropertySymbols, Gn = Object.prototype.hasOwnProperty, Wn = Object.prototype.propertyIsEnumerable, _e = (e2, n4, t2) => n4 in e2 ? Bn(e2, n4, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[n4] = t2, Ce$1 = (e2, n4) => {
  for (var t2 in n4 || (n4 = {}))
    Gn.call(n4, t2) && _e(e2, t2, n4[t2]);
  if (Ue$2)
    for (var t2 of Ue$2(n4))
      Wn.call(n4, t2) && _e(e2, t2, n4[t2]);
  return e2;
};
const je$2 = "ReactNative", m$5 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, De$2 = "js";
function te$2() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function C$3() {
  return !getDocument_1$1() && !!getNavigator_1$1() && navigator.product === je$2;
}
function D$5() {
  return !te$2() && !!getNavigator_1$1() && !!getDocument_1$1();
}
function T$4() {
  return C$3() ? m$5.reactNative : te$2() ? m$5.node : D$5() ? m$5.browser : m$5.unknown;
}
function Jn() {
  var e2;
  try {
    return C$3() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e2 = global.Application) == null ? void 0 : e2.applicationId : void 0;
  } catch {
    return;
  }
}
function ke$2(e2, n4) {
  let t2 = queryString$1.parse(e2);
  return t2 = Ce$1(Ce$1({}, t2), n4), e2 = queryString$1.stringify(t2), e2;
}
function Qn() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function Ve$2() {
  if (T$4() === m$5.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t2, Version: r2 } = global.Platform;
    return [t2, r2].join("-");
  }
  const e2 = detect();
  if (e2 === null)
    return "unknown";
  const n4 = e2.os ? e2.os.replace(" ", "").toLowerCase() : "unknown";
  return e2.type === "browser" ? [n4, e2.name, e2.version].join("-") : [n4, e2.version].join("-");
}
function Me$2() {
  var e2;
  const n4 = T$4();
  return n4 === m$5.browser ? [n4, ((e2 = getLocation_1$1()) == null ? void 0 : e2.host) || "unknown"].join(":") : n4;
}
function Ke$2(e2, n4, t2) {
  const r2 = Ve$2(), o2 = Me$2();
  return [[e2, n4].join("-"), [De$2, t2].join("-"), r2, o2].join("/");
}
function Xn({ protocol: e2, version: n4, relayUrl: t2, sdkVersion: r2, auth: o2, projectId: s3, useOnCloseEvent: i3, bundleId: d3 }) {
  const l2 = t2.split("?"), c2 = Ke$2(e2, n4, r2), u3 = { auth: o2, ua: c2, projectId: s3, useOnCloseEvent: i3 || void 0, origin: d3 || void 0 }, a3 = ke$2(l2[1] || "", u3);
  return l2[0] + "?" + a3;
}
function O$5(e2, n4) {
  return e2.filter((t2) => n4.includes(t2)).length === e2.length;
}
function rt$1(e2) {
  return Object.fromEntries(e2.entries());
}
function ot$1(e2) {
  return new Map(Object.entries(e2));
}
function at$1(e2 = cjs$d.FIVE_MINUTES, n4) {
  const t2 = cjs$d.toMiliseconds(e2 || cjs$d.FIVE_MINUTES);
  let r2, o2, s3;
  return { resolve: (i3) => {
    s3 && r2 && (clearTimeout(s3), r2(i3));
  }, reject: (i3) => {
    s3 && o2 && (clearTimeout(s3), o2(i3));
  }, done: () => new Promise((i3, d3) => {
    s3 = setTimeout(() => {
      d3(new Error(n4));
    }, t2), r2 = i3, o2 = d3;
  }) };
}
function ut$1(e2, n4, t2) {
  return new Promise(async (r2, o2) => {
    const s3 = setTimeout(() => o2(new Error(t2)), n4);
    try {
      const i3 = await e2;
      r2(i3);
    } catch (i3) {
      o2(i3);
    }
    clearTimeout(s3);
  });
}
function re$6(e2, n4) {
  if (typeof n4 == "string" && n4.startsWith(`${e2}:`))
    return n4;
  if (e2.toLowerCase() === "topic") {
    if (typeof n4 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n4}`;
  } else if (e2.toLowerCase() === "id") {
    if (typeof n4 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n4}`;
  }
  throw new Error(`Unknown expirer target type: ${e2}`);
}
function lt$7(e2) {
  return re$6("topic", e2);
}
function dt$1(e2) {
  return re$6("id", e2);
}
function ft$4(e2) {
  const [n4, t2] = e2.split(":"), r2 = { id: void 0, topic: void 0 };
  if (n4 === "topic" && typeof t2 == "string")
    r2.topic = t2;
  else if (n4 === "id" && Number.isInteger(Number(t2)))
    r2.id = Number(t2);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n4}:${t2}`);
  return r2;
}
function pt$1(e2, n4) {
  return cjs$d.fromMiliseconds((n4 || Date.now()) + cjs$d.toMiliseconds(e2));
}
function mt$1(e2) {
  return Date.now() >= cjs$d.toMiliseconds(e2);
}
function yt$1(e2, n4) {
  return `${e2}${n4 ? `:${n4}` : ""}`;
}
async function ht$1({ id: e2, topic: n4, wcDeepLink: t2 }) {
  try {
    if (!t2)
      return;
    const r2 = typeof t2 == "string" ? JSON.parse(t2) : t2;
    let o2 = r2?.href;
    if (typeof o2 != "string")
      return;
    o2.endsWith("/") && (o2 = o2.slice(0, -1));
    const s3 = `${o2}/wc?requestId=${e2}&sessionTopic=${n4}`, i3 = T$4();
    i3 === m$5.browser ? s3.startsWith("https://") ? window.open(s3, "_blank", "noreferrer noopener") : window.open(s3, "_self", "noreferrer noopener") : i3 === m$5.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s3);
  } catch (r2) {
    console.error(r2);
  }
}
async function gt$8(e2, n4) {
  try {
    return await e2.getItem(n4) || (D$5() ? localStorage.getItem(n4) : void 0);
  } catch (t2) {
    console.error(t2);
  }
}
const He$2 = "irn";
function vt$1(e2) {
  return e2?.relay || { protocol: He$2 };
}
function Et$1(e2) {
  const n4 = RELAY_JSONRPC[e2];
  if (typeof n4 > "u")
    throw new Error(`Relay Protocol not supported: ${e2}`);
  return n4;
}
var bt$1 = Object.defineProperty, qe$2 = Object.getOwnPropertySymbols, Nt$1 = Object.prototype.hasOwnProperty, Ot$1 = Object.prototype.propertyIsEnumerable, Be$2 = (e2, n4, t2) => n4 in e2 ? bt$1(e2, n4, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[n4] = t2, St$1 = (e2, n4) => {
  for (var t2 in n4 || (n4 = {}))
    Nt$1.call(n4, t2) && Be$2(e2, t2, n4[t2]);
  if (qe$2)
    for (var t2 of qe$2(n4))
      Ot$1.call(n4, t2) && Be$2(e2, t2, n4[t2]);
  return e2;
};
function Ge$2(e2, n4 = "-") {
  const t2 = {}, r2 = "relay" + n4;
  return Object.keys(e2).forEach((o2) => {
    if (o2.startsWith(r2)) {
      const s3 = o2.replace(r2, ""), i3 = e2[o2];
      t2[s3] = i3;
    }
  }), t2;
}
function wt$1(e2) {
  e2 = e2.includes("wc://") ? e2.replace("wc://", "") : e2, e2 = e2.includes("wc:") ? e2.replace("wc:", "") : e2;
  const n4 = e2.indexOf(":"), t2 = e2.indexOf("?") !== -1 ? e2.indexOf("?") : void 0, r2 = e2.substring(0, n4), o2 = e2.substring(n4 + 1, t2).split("@"), s3 = typeof t2 < "u" ? e2.substring(t2) : "", i3 = queryString$1.parse(s3);
  return { protocol: r2, topic: We$2(o2[0]), version: parseInt(o2[1], 10), symKey: i3.symKey, relay: Ge$2(i3) };
}
function We$2(e2) {
  return e2.startsWith("//") ? e2.substring(2) : e2;
}
function ze$1(e2, n4 = "-") {
  const t2 = "relay", r2 = {};
  return Object.keys(e2).forEach((o2) => {
    const s3 = t2 + n4 + o2;
    e2[o2] && (r2[s3] = e2[o2]);
  }), r2;
}
function It$1(e2) {
  return `${e2.protocol}:${e2.topic}@${e2.version}?` + queryString$1.stringify(St$1({ symKey: e2.symKey }, ze$1(e2.relay)));
}
function A$5(e2) {
  const n4 = [];
  return e2.forEach((t2) => {
    const [r2, o2] = t2.split(":");
    n4.push(`${r2}:${o2}`);
  }), n4;
}
function Qe$2(e2) {
  const n4 = [];
  return Object.values(e2).forEach((t2) => {
    n4.push(...A$5(t2.accounts));
  }), n4;
}
function Ze$2(e2, n4) {
  const t2 = [];
  return Object.values(e2).forEach((r2) => {
    A$5(r2.accounts).includes(n4) && t2.push(...r2.methods);
  }), t2;
}
function Xe$2(e2, n4) {
  const t2 = [];
  return Object.values(e2).forEach((r2) => {
    A$5(r2.accounts).includes(n4) && t2.push(...r2.events);
  }), t2;
}
function jt$1(e2, n4) {
  const t2 = ln(e2, n4);
  if (t2)
    throw new Error(t2.message);
  const r2 = {};
  for (const [o2, s3] of Object.entries(e2))
    r2[o2] = { methods: s3.methods, events: s3.events, chains: s3.accounts.map((i3) => `${i3.split(":")[0]}:${i3.split(":")[1]}`) };
  return r2;
}
const nn$1 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, tn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N$4(e2, n4) {
  const { message: t2, code: r2 } = tn[e2];
  return { message: n4 ? `${t2} ${n4}` : t2, code: r2 };
}
function U$4(e2, n4) {
  const { message: t2, code: r2 } = nn$1[e2];
  return { message: n4 ? `${t2} ${n4}` : t2, code: r2 };
}
function k$4(e2, n4) {
  return Array.isArray(e2) ? typeof n4 < "u" && e2.length ? e2.every(n4) : true : false;
}
function B$6(e2) {
  return Object.getPrototypeOf(e2) === Object.prototype && Object.keys(e2).length;
}
function w$4(e2) {
  return typeof e2 > "u";
}
function h$4(e2, n4) {
  return n4 && w$4(e2) ? true : typeof e2 == "string" && !!e2.trim().length;
}
function G$2(e2, n4) {
  return n4 && w$4(e2) ? true : typeof e2 == "number" && !isNaN(e2);
}
function Dt$1(e2, n4) {
  const { requiredNamespaces: t2 } = n4, r2 = Object.keys(e2.namespaces), o2 = Object.keys(t2);
  let s3 = true;
  return O$5(o2, r2) ? (r2.forEach((i3) => {
    const { accounts: d3, methods: l2, events: c2 } = e2.namespaces[i3], u3 = A$5(d3), a3 = t2[i3];
    (!O$5(L$4(i3, a3), u3) || !O$5(a3.methods, l2) || !O$5(a3.events, c2)) && (s3 = false);
  }), s3) : false;
}
function V$4(e2) {
  return h$4(e2, false) && e2.includes(":") ? e2.split(":").length === 2 : false;
}
function rn(e2) {
  if (h$4(e2, false) && e2.includes(":")) {
    const n4 = e2.split(":");
    if (n4.length === 3) {
      const t2 = n4[0] + ":" + n4[1];
      return !!n4[2] && V$4(t2);
    }
  }
  return false;
}
function kt$1(e2) {
  if (h$4(e2, false))
    try {
      return typeof new URL(e2) < "u";
    } catch {
      return false;
    }
  return false;
}
function Vt$1(e2) {
  var n4;
  return (n4 = e2?.proposer) == null ? void 0 : n4.publicKey;
}
function Mt$1(e2) {
  return e2?.topic;
}
function Kt$1(e2, n4) {
  let t2 = null;
  return h$4(e2?.publicKey, false) || (t2 = N$4("MISSING_OR_INVALID", `${n4} controller public key should be a string`)), t2;
}
function ie$1(e2) {
  let n4 = true;
  return k$4(e2) ? e2.length && (n4 = e2.every((t2) => h$4(t2, false))) : n4 = false, n4;
}
function on(e2, n4, t2) {
  let r2 = null;
  return k$4(n4) && n4.length ? n4.forEach((o2) => {
    r2 || V$4(o2) || (r2 = U$4("UNSUPPORTED_CHAINS", `${t2}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : V$4(e2) || (r2 = U$4("UNSUPPORTED_CHAINS", `${t2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function sn(e2, n4, t2) {
  let r2 = null;
  return Object.entries(e2).forEach(([o2, s3]) => {
    if (r2)
      return;
    const i3 = on(o2, L$4(o2, s3), `${n4} ${t2}`);
    i3 && (r2 = i3);
  }), r2;
}
function cn(e2, n4) {
  let t2 = null;
  return k$4(e2) ? e2.forEach((r2) => {
    t2 || rn(r2) || (t2 = U$4("UNSUPPORTED_ACCOUNTS", `${n4}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : t2 = U$4("UNSUPPORTED_ACCOUNTS", `${n4}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t2;
}
function an(e2, n4) {
  let t2 = null;
  return Object.values(e2).forEach((r2) => {
    if (t2)
      return;
    const o2 = cn(r2?.accounts, `${n4} namespace`);
    o2 && (t2 = o2);
  }), t2;
}
function un(e2, n4) {
  let t2 = null;
  return ie$1(e2?.methods) ? ie$1(e2?.events) || (t2 = U$4("UNSUPPORTED_EVENTS", `${n4}, events should be an array of strings or empty array for no events`)) : t2 = U$4("UNSUPPORTED_METHODS", `${n4}, methods should be an array of strings or empty array for no methods`), t2;
}
function ce$3(e2, n4) {
  let t2 = null;
  return Object.values(e2).forEach((r2) => {
    if (t2)
      return;
    const o2 = un(r2, `${n4}, namespace`);
    o2 && (t2 = o2);
  }), t2;
}
function Lt$1(e2, n4, t2) {
  let r2 = null;
  if (e2 && B$6(e2)) {
    const o2 = ce$3(e2, n4);
    o2 && (r2 = o2);
    const s3 = sn(e2, n4, t2);
    s3 && (r2 = s3);
  } else
    r2 = N$4("MISSING_OR_INVALID", `${n4}, ${t2} should be an object with data`);
  return r2;
}
function ln(e2, n4) {
  let t2 = null;
  if (e2 && B$6(e2)) {
    const r2 = ce$3(e2, n4);
    r2 && (t2 = r2);
    const o2 = an(e2, n4);
    o2 && (t2 = o2);
  } else
    t2 = N$4("MISSING_OR_INVALID", `${n4}, namespaces should be an object with data`);
  return t2;
}
function dn(e2) {
  return h$4(e2.protocol, true);
}
function xt$1(e2, n4) {
  let t2 = false;
  return n4 && !e2 ? t2 = true : e2 && k$4(e2) && e2.length && e2.forEach((r2) => {
    t2 = dn(r2);
  }), t2;
}
function Ft$1(e2) {
  return typeof e2 == "number";
}
function Ht$1(e2) {
  return typeof e2 < "u" && typeof e2 !== null;
}
function qt$1(e2) {
  return !(!e2 || typeof e2 != "object" || !e2.code || !G$2(e2.code, false) || !e2.message || !h$4(e2.message, false));
}
function Bt$1(e2) {
  return !(w$4(e2) || !h$4(e2.method, false));
}
function Gt$1(e2) {
  return !(w$4(e2) || w$4(e2.result) && w$4(e2.error) || !G$2(e2.id, false) || !h$4(e2.jsonrpc, false));
}
function Wt(e2) {
  return !(w$4(e2) || !h$4(e2.name, false));
}
function zt$1(e2, n4) {
  return !(!V$4(n4) || !Qe$2(e2).includes(n4));
}
function Yt$1(e2, n4, t2) {
  return h$4(t2, false) ? Ze$2(e2, n4).includes(t2) : false;
}
function Jt$1(e2, n4, t2) {
  return h$4(t2, false) ? Xe$2(e2, n4).includes(t2) : false;
}
function fn(e2, n4, t2) {
  let r2 = null;
  const o2 = Qt(e2), s3 = Zt(n4), i3 = Object.keys(o2), d3 = Object.keys(s3), l2 = pn(Object.keys(e2)), c2 = pn(Object.keys(n4)), u3 = l2.filter((a3) => !c2.includes(a3));
  return u3.length && (r2 = N$4("NON_CONFORMING_NAMESPACES", `${t2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u3.toString()}
      Received: ${Object.keys(n4).toString()}`)), O$5(i3, d3) || (r2 = N$4("NON_CONFORMING_NAMESPACES", `${t2} namespaces chains don't satisfy required namespaces.
      Required: ${i3.toString()}
      Approved: ${d3.toString()}`)), Object.keys(n4).forEach((a3) => {
    if (!a3.includes(":") || r2)
      return;
    const b4 = A$5(n4[a3].accounts);
    b4.includes(a3) || (r2 = N$4("NON_CONFORMING_NAMESPACES", `${t2} namespaces accounts don't satisfy namespace accounts for ${a3}
        Required: ${a3}
        Approved: ${b4.toString()}`));
  }), i3.forEach((a3) => {
    r2 || (O$5(o2[a3].methods, s3[a3].methods) ? O$5(o2[a3].events, s3[a3].events) || (r2 = N$4("NON_CONFORMING_NAMESPACES", `${t2} namespaces events don't satisfy namespace events for ${a3}`)) : r2 = N$4("NON_CONFORMING_NAMESPACES", `${t2} namespaces methods don't satisfy namespace methods for ${a3}`));
  }), r2;
}
function Qt(e2) {
  const n4 = {};
  return Object.keys(e2).forEach((t2) => {
    var r2;
    t2.includes(":") ? n4[t2] = e2[t2] : (r2 = e2[t2].chains) == null || r2.forEach((o2) => {
      n4[o2] = { methods: e2[t2].methods, events: e2[t2].events };
    });
  }), n4;
}
function pn(e2) {
  return [...new Set(e2.map((n4) => n4.includes(":") ? n4.split(":")[0] : n4))];
}
function Zt(e2) {
  const n4 = {};
  return Object.keys(e2).forEach((t2) => {
    if (t2.includes(":"))
      n4[t2] = e2[t2];
    else {
      const r2 = A$5(e2[t2].accounts);
      r2?.forEach((o2) => {
        n4[o2] = { accounts: e2[t2].accounts.filter((s3) => s3.includes(`${o2}:`)), methods: e2[t2].methods, events: e2[t2].events };
      });
    }
  }), n4;
}
function Xt(e2, n4) {
  return G$2(e2, false) && e2 <= n4.max && e2 >= n4.min;
}
function er$1() {
  const e2 = T$4();
  return new Promise((n4) => {
    switch (e2) {
      case m$5.browser:
        n4(mn());
        break;
      case m$5.reactNative:
        n4(yn());
        break;
      case m$5.node:
        n4(hn());
        break;
      default:
        n4(true);
    }
  });
}
function mn() {
  return D$5() && navigator?.onLine;
}
async function yn() {
  if (C$3() && typeof global < "u" && global != null && global.NetInfo) {
    const e2 = await (global == null ? void 0 : global.NetInfo.fetch());
    return e2?.isConnected;
  }
  return true;
}
function hn() {
  return true;
}
function nr$1(e2) {
  switch (T$4()) {
    case m$5.browser:
      gn(e2);
      break;
    case m$5.reactNative:
      vn(e2);
      break;
  }
}
function gn(e2) {
  !C$3() && D$5() && (window.addEventListener("online", () => e2(true)), window.addEventListener("offline", () => e2(false)));
}
function vn(e2) {
  C$3() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener((n4) => e2(n4?.isConnected));
}
const ae$2 = {};
let tr$1 = class tr2 {
  static get(n4) {
    return ae$2[n4];
  }
  static set(n4, t2) {
    ae$2[n4] = t2;
  }
  static delete(n4) {
    delete ae$2[n4];
  }
};
const PARSE_ERROR = "PARSE_ERROR";
const INVALID_REQUEST = "INVALID_REQUEST";
const METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
const INVALID_PARAMS = "INVALID_PARAMS";
const INTERNAL_ERROR = "INTERNAL_ERROR";
const SERVER_ERROR = "SERVER_ERROR";
const RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
const STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
const DEFAULT_ERROR = SERVER_ERROR;
function isReservedErrorCode(code2) {
  return RESERVED_ERROR_CODES.includes(code2);
}
function getError$1(type2) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type2)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type2];
}
function getErrorByCode(code2) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e2) => e2.code === code2);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function parseConnectionError(e2, url, type2) {
  return e2.message.includes("getaddrinfo ENOTFOUND") || e2.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type2} RPC url at ${url}`) : e2;
}
var cjs$3 = {};
var crypto$1 = {};
var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto)
    return crypto$1;
  hasRequiredCrypto = 1;
  Object.defineProperty(crypto$1, "__esModule", { value: true });
  crypto$1.isBrowserCryptoAvailable = crypto$1.getSubtleCrypto = crypto$1.getBrowerCrypto = void 0;
  function getBrowerCrypto() {
    return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
  }
  crypto$1.getBrowerCrypto = getBrowerCrypto;
  function getSubtleCrypto() {
    const browserCrypto = getBrowerCrypto();
    return browserCrypto.subtle || browserCrypto.webkitSubtle;
  }
  crypto$1.getSubtleCrypto = getSubtleCrypto;
  function isBrowserCryptoAvailable() {
    return !!getBrowerCrypto() && !!getSubtleCrypto();
  }
  crypto$1.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  return crypto$1;
}
var env = {};
var hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv)
    return env;
  hasRequiredEnv = 1;
  Object.defineProperty(env, "__esModule", { value: true });
  env.isBrowser = env.isNode = env.isReactNative = void 0;
  function isReactNative() {
    return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
  }
  env.isReactNative = isReactNative;
  function isNode2() {
    return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
  }
  env.isNode = isNode2;
  function isBrowser() {
    return !isReactNative() && !isNode2();
  }
  env.isBrowser = isBrowser;
  return env;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  const tslib_12 = require$$0$1e;
  tslib_12.__exportStar(requireCrypto(), exports2);
  tslib_12.__exportStar(requireEnv(), exports2);
})(cjs$3);
function payloadId(entropy = 3) {
  const date2 = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date2 + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id2) {
  return {
    id: id2 || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id2, result) {
  return {
    id: id2,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id2, error, data2) {
  return {
    id: id2,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data2)
  };
}
function formatErrorMessage(error, data2) {
  if (typeof error === "undefined") {
    return getError$1(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError$1(SERVER_ERROR)), { message: error });
  }
  if (typeof data2 !== "undefined") {
    error.data = data2;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}
class IEvents {
}
class IBaseJsonRpcProvider extends IEvents {
  constructor() {
    super();
  }
}
class IJsonRpcProvider extends IBaseJsonRpcProvider {
  constructor(connection) {
    super();
  }
}
const HTTP_REGEX = "^https?:";
const WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex2) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex2).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
class JsonRpcProvider extends IJsonRpcProvider {
  constructor(connection) {
    super(connection);
    this.events = new eventsExports.EventEmitter();
    this.hasRegisteredEventListeners = false;
    this.connection = this.setConnection(connection);
    if (this.connection.connected) {
      this.registerEventListeners();
    }
  }
  async connect(connection = this.connection) {
    await this.open(connection);
  }
  async disconnect() {
    await this.close();
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async request(request, context) {
    return this.requestStrict(formatJsonRpcRequest(request.method, request.params || [], request.id || getBigIntRpcId().toString()), context);
  }
  async requestStrict(request, context) {
    return new Promise(async (resolve, reject) => {
      if (!this.connection.connected) {
        try {
          await this.open();
        } catch (e2) {
          reject(e2);
        }
      }
      this.events.on(`${request.id}`, (response) => {
        if (isJsonRpcError(response)) {
          reject(response.error);
        } else {
          resolve(response.result);
        }
      });
      try {
        await this.connection.send(request, context);
      } catch (e2) {
        reject(e2);
      }
    });
  }
  setConnection(connection = this.connection) {
    return connection;
  }
  onPayload(payload) {
    this.events.emit("payload", payload);
    if (isJsonRpcResponse(payload)) {
      this.events.emit(`${payload.id}`, payload);
    } else {
      this.events.emit("message", {
        type: payload.method,
        data: payload.params
      });
    }
  }
  onClose(event) {
    if (event && event.code === 3e3) {
      this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${event.code} ${event.reason ? `(${event.reason})` : ""}`));
    }
    this.events.emit("disconnect");
  }
  async open(connection = this.connection) {
    if (this.connection === connection && this.connection.connected)
      return;
    if (this.connection.connected)
      this.close();
    if (typeof connection === "string") {
      await this.connection.open(connection);
      connection = this.connection;
    }
    this.connection = this.setConnection(connection);
    await this.connection.open();
    this.registerEventListeners();
    this.events.emit("connect");
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    if (this.hasRegisteredEventListeners)
      return;
    this.connection.on("payload", (payload) => this.onPayload(payload));
    this.connection.on("close", (event) => this.onClose(event));
    this.connection.on("error", (error) => this.events.emit("error", error));
    this.connection.on("register_error", (error) => this.onClose());
    this.hasRegisteredEventListeners = true;
  }
}
var browser$7;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$7;
  hasRequiredBrowser = 1;
  browser$7 = function() {
    throw new Error(
      "ws does not work in the browser. Browser clients must use the native WebSocket object"
    );
  };
  return browser$7;
}
const w$3 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : requireBrowser(), b$4 = () => typeof WebSocket < "u" || typeof global < "u" && typeof window.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", a$2 = (c2) => c2.split("?")[0], h$3 = 10, S$5 = w$3();
let f$4 = class f3 {
  constructor(e2) {
    if (this.url = e2, this.events = new eventsExports.EventEmitter(), this.registering = false, !isWsUrl(e2))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    this.url = e2;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e2, t2) {
    this.events.on(e2, t2);
  }
  once(e2, t2) {
    this.events.once(e2, t2);
  }
  off(e2, t2) {
    this.events.off(e2, t2);
  }
  removeListener(e2, t2) {
    this.events.removeListener(e2, t2);
  }
  async open(e2 = this.url) {
    await this.register(e2);
  }
  async close() {
    return new Promise((e2, t2) => {
      if (typeof this.socket > "u") {
        t2(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n4) => {
        this.onClose(n4), e2();
      }, this.socket.close();
    });
  }
  async send(e2) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e2));
    } catch (t2) {
      this.onError(e2.id, t2);
    }
  }
  register(e2 = this.url) {
    if (!isWsUrl(e2))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    if (this.registering) {
      const t2 = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t2 || this.events.listenerCount("open") >= t2) && this.events.setMaxListeners(t2 + 1), new Promise((n4, o2) => {
        this.events.once("register_error", (s3) => {
          this.resetMaxListeners(), o2(s3);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return o2(new Error("WebSocket connection is missing or invalid"));
          n4(this.socket);
        });
      });
    }
    return this.url = e2, this.registering = true, new Promise((t2, n4) => {
      const o2 = new URLSearchParams(e2).get("origin"), s3 = cjs$3.isReactNative() ? { headers: { origin: o2 } } : { rejectUnauthorized: !isLocalhostUrl(e2) }, i3 = new S$5(e2, [], s3);
      b$4() ? i3.onerror = (r2) => {
        const l2 = r2;
        n4(this.emitError(l2.error));
      } : i3.on("error", (r2) => {
        n4(this.emitError(r2));
      }), i3.onopen = () => {
        this.onOpen(i3), t2(i3);
      };
    });
  }
  onOpen(e2) {
    e2.onmessage = (t2) => this.onPayload(t2), e2.onclose = (t2) => this.onClose(t2), this.socket = e2, this.registering = false, this.events.emit("open");
  }
  onClose(e2) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e2);
  }
  onPayload(e2) {
    if (typeof e2.data > "u")
      return;
    const t2 = typeof e2.data == "string" ? safeJsonParse(e2.data) : e2.data;
    this.events.emit("payload", t2);
  }
  onError(e2, t2) {
    const n4 = this.parseError(t2), o2 = n4.message || n4.toString(), s3 = formatJsonRpcError(e2, o2);
    this.events.emit("payload", s3);
  }
  parseError(e2, t2 = this.url) {
    return parseConnectionError(e2, a$2(t2), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h$3 && this.events.setMaxListeners(h$3);
  }
  emitError(e2) {
    const t2 = this.parseError(new Error(e2?.message || `WebSocket connection failed for host: ${a$2(this.url)}`));
    return this.events.emit("register_error", t2), t2;
  }
};
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(module2, exports2) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter(array2, predicate) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
    while (++index2 < length2) {
      var value = array2[index2];
      if (predicate(value, index2, array2)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush(array2, values) {
    var index2 = -1, length2 = values.length, offset = array2.length;
    while (++index2 < length2) {
      array2[offset + index2] = values[index2];
    }
    return array2;
  }
  function arraySome(array2, predicate) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index2 < length2) {
      if (predicate(array2[index2], index2, array2)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes(n4, iteratee) {
    var index2 = -1, result = Array(n4);
    while (++index2 < n4) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary(func2) {
    return function(value) {
      return func2(value);
    };
  }
  function cacheHas(cache, key2) {
    return cache.has(key2);
  }
  function getValue(object2, key2) {
    return object2 == null ? void 0 : object2[key2];
  }
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key2) {
      result[++index2] = [key2, value];
    });
    return result;
  }
  function overArg(func2, transform2) {
    return function(arg) {
      return func2(transform2(arg));
    };
  }
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root2["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable2 = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root2, "DataView"), Map2 = getNative(root2, "Map"), Promise2 = getNative(root2, "Promise"), Set2 = getNative(root2, "Set"), WeakMap2 = getNative(root2, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash2(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key2) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result = data2[key2];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data2, key2) ? data2[key2] : void 0;
  }
  function hashHas(key2) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key2] !== void 0 : hasOwnProperty2.call(data2, key2);
  }
  function hashSet(key2, value) {
    var data2 = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data2[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash2.prototype.clear = hashClear;
  Hash2.prototype["delete"] = hashDelete;
  Hash2.prototype.get = hashGet;
  Hash2.prototype.has = hashHas;
  Hash2.prototype.set = hashSet;
  function ListCache(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete(key2) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key2) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet(key2, value) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
    if (index2 < 0) {
      ++this.size;
      data2.push([key2, value]);
    } else {
      data2[index2][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    var data2 = getMapData(this, key2), size2 = data2.size;
    data2.set(key2, value);
    this.size += data2.size == size2 ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index2 = -1, length2 = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index2 < length2) {
      this.add(values[index2]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries2) {
    var data2 = this.__data__ = new ListCache(entries2);
    this.size = data2.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key2) {
    var data2 = this.__data__, result = data2["delete"](key2);
    this.size = data2.size;
    return result;
  }
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  function stackSet(key2, value) {
    var data2 = this.__data__;
    if (data2 instanceof ListCache) {
      var pairs2 = data2.__data__;
      if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key2, value]);
        this.size = ++data2.size;
        return this;
      }
      data2 = this.__data__ = new MapCache(pairs2);
    }
    data2.set(key2, value);
    this.size = data2.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer3(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key2 in value) {
      if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
      isIndex(key2, length2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function assocIndexOf(array2, key2) {
    var length2 = array2.length;
    while (length2--) {
      if (eq5(array2[length2][0], key2)) {
        return length2;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
    var result = keysFunc(object2);
    return isArray2(object2) ? result : arrayPush(result, symbolsFunc(object2));
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer3(object2)) {
      if (!isBuffer3(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern2 = isFunction2(value) ? reIsNative : reIsHostCtor;
    return pattern2.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeys(object2) {
    if (!isPrototype(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key2 in Object(object2)) {
      if (hasOwnProperty2.call(object2, key2) && key2 != "constructor") {
        result.push(key2);
      }
    }
    return result;
  }
  function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array2);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index2 = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array2, other);
    stack.set(other, array2);
    while (++index2 < arrLength) {
      var arrValue = array2[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen2) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen2.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array2);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
          return false;
        }
        object2 = object2.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq5(+object2, +other);
      case errorTag:
        return object2.name == other.name && object2.message == other.message;
      case regexpTag:
      case stringTag:
        return object2 == other + "";
      case mapTag:
        var convert2 = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert2 || (convert2 = setToArray);
        if (object2.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object2);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object2, other);
        var result = equalArrays(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object2);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object2) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key2 = objProps[index2];
      if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2))) {
        return false;
      }
    }
    var stacked = stack.get(object2);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object2, other);
    stack.set(other, object2);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key2 = objProps[index2];
      var objValue = object2[key2], othValue = other[key2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key2, other, object2, stack) : customizer(objValue, othValue, key2, object2, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key2 == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object2.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object2);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object2) {
    return baseGetAllKeys(object2, keys2, getSymbols);
  }
  function getMapData(map2, key2) {
    var data2 = map2.__data__;
    return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
  }
  function getNative(object2, key2) {
    var value = getValue(object2, key2);
    return baseIsNative(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
    if (object2 == null) {
      return [];
    }
    object2 = Object(object2);
    return arrayFilter(nativeGetSymbols(object2), function(symbol2) {
      return propertyIsEnumerable2.call(object2, symbol2);
    });
  };
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex(value, length2) {
    length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
    return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func2) {
    return !!maskSrcKey && maskSrcKey in func2;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function toSource(func2) {
    if (func2 != null) {
      try {
        return funcToString.call(func2);
      } catch (e2) {
      }
      try {
        return func2 + "";
      } catch (e2) {
      }
    }
    return "";
  }
  function eq5(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  var isBuffer3 = nativeIsBuffer || stubFalse;
  function isEqual3(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys2(object2) {
    return isArrayLike2(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module2.exports = isEqual3;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
const Gi$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isequalExports);
function unfetch_module(e2, n4) {
  return n4 = n4 || {}, new Promise(function(t2, r2) {
    var s3 = new XMLHttpRequest(), o2 = [], u3 = [], i3 = {}, a3 = function() {
      return { ok: 2 == (s3.status / 100 | 0), statusText: s3.statusText, status: s3.status, url: s3.responseURL, text: function() {
        return Promise.resolve(s3.responseText);
      }, json: function() {
        return Promise.resolve(s3.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([s3.response]));
      }, clone: a3, headers: { keys: function() {
        return o2;
      }, entries: function() {
        return u3;
      }, get: function(e3) {
        return i3[e3.toLowerCase()];
      }, has: function(e3) {
        return e3.toLowerCase() in i3;
      } } };
    };
    for (var l2 in s3.open(n4.method || "get", e2, true), s3.onload = function() {
      s3.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e3, n5, t3) {
        o2.push(n5 = n5.toLowerCase()), u3.push([n5, t3]), i3[n5] = i3[n5] ? i3[n5] + "," + t3 : t3;
      }), t2(a3());
    }, s3.onerror = r2, s3.withCredentials = "include" == n4.credentials, n4.headers)
      s3.setRequestHeader(l2, n4.headers[l2]);
    s3.send(n4.body || null);
  });
}
const unfetch_module$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: unfetch_module
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$17 = /* @__PURE__ */ getAugmentedNamespace(unfetch_module$1);
var browser$6 = self.fetch || (self.fetch = require$$0$17.default || require$$0$17);
const Yi$1 = /* @__PURE__ */ getDefaultExportFromCjs(browser$6);
function Hi$1(r2, e2) {
  if (r2.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t2 = new Uint8Array(256), i3 = 0; i3 < t2.length; i3++)
    t2[i3] = 255;
  for (var s3 = 0; s3 < r2.length; s3++) {
    var n4 = r2.charAt(s3), o2 = n4.charCodeAt(0);
    if (t2[o2] !== 255)
      throw new TypeError(n4 + " is ambiguous");
    t2[o2] = s3;
  }
  var a3 = r2.length, h5 = r2.charAt(0), l2 = Math.log(a3) / Math.log(256), d3 = Math.log(256) / Math.log(a3);
  function p3(u3) {
    if (u3 instanceof Uint8Array || (ArrayBuffer.isView(u3) ? u3 = new Uint8Array(u3.buffer, u3.byteOffset, u3.byteLength) : Array.isArray(u3) && (u3 = Uint8Array.from(u3))), !(u3 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u3.length === 0)
      return "";
    for (var m2 = 0, z2 = 0, I3 = 0, _3 = u3.length; I3 !== _3 && u3[I3] === 0; )
      I3++, m2++;
    for (var S3 = (_3 - I3) * d3 + 1 >>> 0, f4 = new Uint8Array(S3); I3 !== _3; ) {
      for (var T2 = u3[I3], A2 = 0, C2 = S3 - 1; (T2 !== 0 || A2 < z2) && C2 !== -1; C2--, A2++)
        T2 += 256 * f4[C2] >>> 0, f4[C2] = T2 % a3 >>> 0, T2 = T2 / a3 >>> 0;
      if (T2 !== 0)
        throw new Error("Non-zero carry");
      z2 = A2, I3++;
    }
    for (var x2 = S3 - z2; x2 !== S3 && f4[x2] === 0; )
      x2++;
    for (var q2 = h5.repeat(m2); x2 < S3; ++x2)
      q2 += r2.charAt(f4[x2]);
    return q2;
  }
  function y3(u3) {
    if (typeof u3 != "string")
      throw new TypeError("Expected String");
    if (u3.length === 0)
      return new Uint8Array();
    var m2 = 0;
    if (u3[m2] !== " ") {
      for (var z2 = 0, I3 = 0; u3[m2] === h5; )
        z2++, m2++;
      for (var _3 = (u3.length - m2) * l2 + 1 >>> 0, S3 = new Uint8Array(_3); u3[m2]; ) {
        var f4 = t2[u3.charCodeAt(m2)];
        if (f4 === 255)
          return;
        for (var T2 = 0, A2 = _3 - 1; (f4 !== 0 || T2 < I3) && A2 !== -1; A2--, T2++)
          f4 += a3 * S3[A2] >>> 0, S3[A2] = f4 % 256 >>> 0, f4 = f4 / 256 >>> 0;
        if (f4 !== 0)
          throw new Error("Non-zero carry");
        I3 = T2, m2++;
      }
      if (u3[m2] !== " ") {
        for (var C2 = _3 - I3; C2 !== _3 && S3[C2] === 0; )
          C2++;
        for (var x2 = new Uint8Array(z2 + (_3 - C2)), q2 = z2; C2 !== _3; )
          x2[q2++] = S3[C2++];
        return x2;
      }
    }
  }
  function M3(u3) {
    var m2 = y3(u3);
    if (m2)
      return m2;
    throw new Error(`Non-${e2} character`);
  }
  return { encode: p3, decodeUnsafe: y3, decode: M3 };
}
var Ji$1 = Hi$1, Xi$1 = Ji$1;
const Ne$1 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array")
    return r2;
  if (r2 instanceof ArrayBuffer)
    return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2))
    return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Wi$2 = (r2) => new TextEncoder().encode(r2), Qi$1 = (r2) => new TextDecoder().decode(r2);
let Zi$1 = class Zi2 {
  constructor(e2, t2, i3) {
    this.name = e2, this.prefix = t2, this.baseEncode = i3;
  }
  encode(e2) {
    if (e2 instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e2)}`;
    throw Error("Unknown type, must be binary type");
  }
};
class es {
  constructor(e2, t2, i3) {
    if (this.name = e2, this.prefix = t2, t2.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t2.codePointAt(0), this.baseDecode = i3;
  }
  decode(e2) {
    if (typeof e2 == "string") {
      if (e2.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e2.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e2) {
    return Ue$1(this, e2);
  }
}
class ts {
  constructor(e2) {
    this.decoders = e2;
  }
  or(e2) {
    return Ue$1(this, e2);
  }
  decode(e2) {
    const t2 = e2[0], i3 = this.decoders[t2];
    if (i3)
      return i3.decode(e2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const Ue$1 = (r2, e2) => new ts({ ...r2.decoders || { [r2.prefix]: r2 }, ...e2.decoders || { [e2.prefix]: e2 } });
let is$2 = class is2 {
  constructor(e2, t2, i3, s3) {
    this.name = e2, this.prefix = t2, this.baseEncode = i3, this.baseDecode = s3, this.encoder = new Zi$1(e2, t2, i3), this.decoder = new es(e2, t2, s3);
  }
  encode(e2) {
    return this.encoder.encode(e2);
  }
  decode(e2) {
    return this.decoder.decode(e2);
  }
};
const W$8 = ({ name: r2, prefix: e2, encode: t2, decode: i3 }) => new is$2(r2, e2, t2, i3), B$5 = ({ prefix: r2, name: e2, alphabet: t2 }) => {
  const { encode: i3, decode: s3 } = Xi$1(t2, e2);
  return W$8({ prefix: r2, name: e2, encode: i3, decode: (n4) => Ne$1(s3(n4)) });
}, ss = (r2, e2, t2, i3) => {
  const s3 = {};
  for (let d3 = 0; d3 < e2.length; ++d3)
    s3[e2[d3]] = d3;
  let n4 = r2.length;
  for (; r2[n4 - 1] === "="; )
    --n4;
  const o2 = new Uint8Array(n4 * t2 / 8 | 0);
  let a3 = 0, h5 = 0, l2 = 0;
  for (let d3 = 0; d3 < n4; ++d3) {
    const p3 = s3[r2[d3]];
    if (p3 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    h5 = h5 << t2 | p3, a3 += t2, a3 >= 8 && (a3 -= 8, o2[l2++] = 255 & h5 >> a3);
  }
  if (a3 >= t2 || 255 & h5 << 8 - a3)
    throw new SyntaxError("Unexpected end of data");
  return o2;
}, rs = (r2, e2, t2) => {
  const i3 = e2[e2.length - 1] === "=", s3 = (1 << t2) - 1;
  let n4 = "", o2 = 0, a3 = 0;
  for (let h5 = 0; h5 < r2.length; ++h5)
    for (a3 = a3 << 8 | r2[h5], o2 += 8; o2 > t2; )
      o2 -= t2, n4 += e2[s3 & a3 >> o2];
  if (o2 && (n4 += e2[s3 & a3 << t2 - o2]), i3)
    for (; n4.length * t2 & 7; )
      n4 += "=";
  return n4;
}, g$5 = ({ name: r2, prefix: e2, bitsPerChar: t2, alphabet: i3 }) => W$8({ prefix: e2, name: r2, encode(s3) {
  return rs(s3, i3, t2);
}, decode(s3) {
  return ss(s3, i3, t2, r2);
} }), ns = W$8({ prefix: "\0", name: "identity", encode: (r2) => Qi$1(r2), decode: (r2) => Wi$2(r2) });
var os = Object.freeze({ __proto__: null, identity: ns });
const as$1 = g$5({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var hs$1 = Object.freeze({ __proto__: null, base2: as$1 });
const cs$2 = g$5({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var us$1 = Object.freeze({ __proto__: null, base8: cs$2 });
const ls$1 = B$5({ prefix: "9", name: "base10", alphabet: "0123456789" });
var ds$1 = Object.freeze({ __proto__: null, base10: ls$1 });
const gs$1 = g$5({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), ps$1 = g$5({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ds = Object.freeze({ __proto__: null, base16: gs$1, base16upper: ps$1 });
const ys = g$5({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), ms$1 = g$5({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), bs = g$5({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), fs = g$5({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), Es = g$5({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), ws = g$5({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), vs = g$5({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), Is = g$5({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), Cs = g$5({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Rs = Object.freeze({ __proto__: null, base32: ys, base32upper: ms$1, base32pad: bs, base32padupper: fs, base32hex: Es, base32hexupper: ws, base32hexpad: vs, base32hexpadupper: Is, base32z: Cs });
const _s = B$5({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), Ss = B$5({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Ts = Object.freeze({ __proto__: null, base36: _s, base36upper: Ss });
const Ps = B$5({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), xs = B$5({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Os = Object.freeze({ __proto__: null, base58btc: Ps, base58flickr: xs });
const As = g$5({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), zs = g$5({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), Ns = g$5({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), Us = g$5({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ls = Object.freeze({ __proto__: null, base64: As, base64pad: zs, base64url: Ns, base64urlpad: Us });
const Le$1 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), Fs = Le$1.reduce((r2, e2, t2) => (r2[t2] = e2, r2), []), $s = Le$1.reduce((r2, e2, t2) => (r2[e2.codePointAt(0)] = t2, r2), []);
function Ms(r2) {
  return r2.reduce((e2, t2) => (e2 += Fs[t2], e2), "");
}
function ks(r2) {
  const e2 = [];
  for (const t2 of r2) {
    const i3 = $s[t2.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${t2}`);
    e2.push(i3);
  }
  return new Uint8Array(e2);
}
const Ks = W$8({ prefix: "🚀", name: "base256emoji", encode: Ms, decode: ks });
var Bs = Object.freeze({ __proto__: null, base256emoji: Ks }), Vs = $e$1, Fe$1 = 128, js$3 = 127, qs = ~js$3, Gs = Math.pow(2, 31);
function $e$1(r2, e2, t2) {
  e2 = e2 || [], t2 = t2 || 0;
  for (var i3 = t2; r2 >= Gs; )
    e2[t2++] = r2 & 255 | Fe$1, r2 /= 128;
  for (; r2 & qs; )
    e2[t2++] = r2 & 255 | Fe$1, r2 >>>= 7;
  return e2[t2] = r2 | 0, $e$1.bytes = t2 - i3 + 1, e2;
}
var Ys = he$2, Hs = 128, Me$1 = 127;
function he$2(r2, i3) {
  var t2 = 0, i3 = i3 || 0, s3 = 0, n4 = i3, o2, a3 = r2.length;
  do {
    if (n4 >= a3)
      throw he$2.bytes = 0, new RangeError("Could not decode varint");
    o2 = r2[n4++], t2 += s3 < 28 ? (o2 & Me$1) << s3 : (o2 & Me$1) * Math.pow(2, s3), s3 += 7;
  } while (o2 >= Hs);
  return he$2.bytes = n4 - i3, t2;
}
var Js = Math.pow(2, 7), Xs = Math.pow(2, 14), Ws = Math.pow(2, 21), Qs = Math.pow(2, 28), Zs = Math.pow(2, 35), er = Math.pow(2, 42), tr = Math.pow(2, 49), ir = Math.pow(2, 56), sr = Math.pow(2, 63), rr = function(r2) {
  return r2 < Js ? 1 : r2 < Xs ? 2 : r2 < Ws ? 3 : r2 < Qs ? 4 : r2 < Zs ? 5 : r2 < er ? 6 : r2 < tr ? 7 : r2 < ir ? 8 : r2 < sr ? 9 : 10;
}, nr = { encode: Vs, decode: Ys, encodingLength: rr }, ke$1 = nr;
const Ke$1 = (r2, e2, t2 = 0) => (ke$1.encode(r2, e2, t2), e2), Be$1 = (r2) => ke$1.encodingLength(r2), ce$2 = (r2, e2) => {
  const t2 = e2.byteLength, i3 = Be$1(r2), s3 = i3 + Be$1(t2), n4 = new Uint8Array(s3 + t2);
  return Ke$1(r2, n4, 0), Ke$1(t2, n4, i3), n4.set(e2, s3), new or(r2, t2, e2, n4);
};
class or {
  constructor(e2, t2, i3, s3) {
    this.code = e2, this.size = t2, this.digest = i3, this.bytes = s3;
  }
}
const Ve$1 = ({ name: r2, code: e2, encode: t2 }) => new ar(r2, e2, t2);
class ar {
  constructor(e2, t2, i3) {
    this.name = e2, this.code = t2, this.encode = i3;
  }
  digest(e2) {
    if (e2 instanceof Uint8Array) {
      const t2 = this.encode(e2);
      return t2 instanceof Uint8Array ? ce$2(this.code, t2) : t2.then((i3) => ce$2(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
}
const je$1 = (r2) => async (e2) => new Uint8Array(await crypto.subtle.digest(r2, e2)), hr$1 = Ve$1({ name: "sha2-256", code: 18, encode: je$1("SHA-256") }), cr$1 = Ve$1({ name: "sha2-512", code: 19, encode: je$1("SHA-512") });
var ur = Object.freeze({ __proto__: null, sha256: hr$1, sha512: cr$1 });
const qe$1 = 0, lr$1 = "identity", Ge$1 = Ne$1, dr = (r2) => ce$2(qe$1, Ge$1(r2)), gr = { code: qe$1, name: lr$1, encode: Ge$1, digest: dr };
var pr = Object.freeze({ __proto__: null, identity: gr });
new TextEncoder(), new TextDecoder();
const Ye$1 = { ...os, ...hs$1, ...us$1, ...ds$1, ...Ds, ...Rs, ...Ts, ...Os, ...Ls, ...Bs };
({ ...ur, ...pr });
function He$1(r2) {
  return globalThis.Buffer != null ? new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength) : r2;
}
function Dr(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? He$1(globalThis.Buffer.allocUnsafe(r2)) : new Uint8Array(r2);
}
function Je$1(r2, e2, t2, i3) {
  return { name: r2, prefix: e2, encoder: { name: r2, prefix: e2, encode: t2 }, decoder: { decode: i3 } };
}
const Xe$1 = Je$1("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1))), ue$2 = Je$1("ascii", "a", (r2) => {
  let e2 = "a";
  for (let t2 = 0; t2 < r2.length; t2++)
    e2 += String.fromCharCode(r2[t2]);
  return e2;
}, (r2) => {
  r2 = r2.substring(1);
  const e2 = Dr(r2.length);
  for (let t2 = 0; t2 < r2.length; t2++)
    e2[t2] = r2.charCodeAt(t2);
  return e2;
}), yr = { utf8: Xe$1, "utf-8": Xe$1, hex: Ye$1.base16, latin1: ue$2, ascii: ue$2, binary: ue$2, ...Ye$1 };
function mr(r2, e2 = "utf8") {
  const t2 = yr[e2];
  if (!t2)
    throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? He$1(globalThis.Buffer.from(r2, "utf-8")) : t2.decoder.decode(`${t2.prefix}${r2}`);
}
const le$2 = "wc", We$1 = 2, Q$4 = "core", O$4 = `${le$2}@2:${Q$4}:`, Qe$1 = { name: Q$4, logger: "error" }, Ze$1 = { database: ":memory:" }, et = "crypto", de$2 = "client_ed25519_seed", tt = cjs$d.ONE_DAY, it = "keychain", st = "0.3", rt = "messages", nt = "0.3", ot = cjs$d.SIX_HOURS, at = "publisher", ht = "irn", ct = "error", ge$2 = "wss://relay.walletconnect.com", pe$2 = "wss://relay.walletconnect.org", ut = "relayer", D$4 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, lt$6 = "_subscription", P$5 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, dt = cjs$d.ONE_SECOND, gt$7 = "2.11.0", pt = 1e4, Dt = "0.3", yt = "WALLETCONNECT_CLIENT_ID", w$2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, mt = "subscription", bt = "0.3", ft$3 = cjs$d.FIVE_SECONDS * 1e3, Et = "pairing", wt = "0.3", F$4 = { wc_pairingDelete: { req: { ttl: cjs$d.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: cjs$d.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: cjs$d.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: cjs$d.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: cjs$d.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: cjs$d.ONE_DAY, prompt: false, tag: 0 } } }, V$3 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, R$2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, vt = "history", It = "0.3", Ct$1 = "expirer", v$5 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, Rt = "0.3", Z$1 = "verify-api", $$2 = "https://verify.walletconnect.com", ee$1 = "https://verify.walletconnect.org", _t = [$$2, ee$1], St = "echo", Tt = "https://echo.walletconnect.com";
class Pt {
  constructor(e2, t2) {
    this.core = e2, this.logger = t2, this.keychain = /* @__PURE__ */ new Map(), this.name = it, this.version = st, this.initialized = false, this.storagePrefix = O$4, this.init = async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }, this.has = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.set = async (i3, s3) => {
      this.isInitialized(), this.keychain.set(i3, s3), await this.persist();
    }, this.get = (i3) => {
      this.isInitialized();
      const s3 = this.keychain.get(i3);
      if (typeof s3 > "u") {
        const { message: n4 } = N$4("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(n4);
      }
      return s3;
    }, this.del = async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }, this.core = e2, this.logger = cjs$7.generateChildLogger(t2, this.name);
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e2) {
    await this.core.storage.setItem(this.storageKey, rt$1(e2));
  }
  async getKeyChain() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? ot$1(e2) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N$4("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
}
class xt {
  constructor(e2, t2, i3) {
    this.core = e2, this.logger = t2, this.name = et, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s3) => (this.isInitialized(), this.keychain.has(s3)), this.getClientId = async () => {
      this.isInitialized();
      const s3 = await this.getClientSeed(), n4 = generateKeyPair(s3);
      return encodeIss(n4.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s3 = kn();
      return this.setPrivateKey(s3.publicKey, s3.privateKey);
    }, this.signJWT = async (s3) => {
      this.isInitialized();
      const n4 = await this.getClientSeed(), o2 = generateKeyPair(n4), a3 = Vn$1(), h5 = tt;
      return await signJWT(a3, s3, h5, o2);
    }, this.generateSharedKey = (s3, n4, o2) => {
      this.isInitialized();
      const a3 = this.getPrivateKey(s3), h5 = Mn(a3, n4);
      return this.setSymKey(h5, o2);
    }, this.setSymKey = async (s3, n4) => {
      this.isInitialized();
      const o2 = n4 || Kn(s3);
      return await this.keychain.set(o2, s3), o2;
    }, this.deleteKeyPair = async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }, this.deleteSymKey = async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }, this.encode = async (s3, n4, o2) => {
      this.isInitialized();
      const a3 = Ae$1(o2), h5 = safeJsonStringify(n4);
      if (qn(a3)) {
        const y3 = a3.senderPublicKey, M3 = a3.receiverPublicKey;
        s3 = await this.generateSharedKey(y3, M3);
      }
      const l2 = this.getSymKey(s3), { type: d3, senderPublicKey: p3 } = a3;
      return xn({ type: d3, symKey: l2, message: h5, senderPublicKey: p3 });
    }, this.decode = async (s3, n4, o2) => {
      this.isInitialized();
      const a3 = Hn(n4, o2);
      if (qn(a3)) {
        const h5 = a3.receiverPublicKey, l2 = a3.senderPublicKey;
        s3 = await this.generateSharedKey(h5, l2);
      }
      try {
        const h5 = this.getSymKey(s3), l2 = Fn({ symKey: h5, encoded: n4 });
        return safeJsonParse(l2);
      } catch (h5) {
        this.logger.error(`Failed to decode message from topic: '${s3}', clientId: '${await this.getClientId()}'`), this.logger.error(h5);
      }
    }, this.getPayloadType = (s3) => {
      const n4 = ee$2(s3);
      return $$3(n4.type);
    }, this.getPayloadSenderPublicKey = (s3) => {
      const n4 = ee$2(s3);
      return n4.senderPublicKey ? toString$3(n4.senderPublicKey, p$5) : void 0;
    }, this.core = e2, this.logger = cjs$7.generateChildLogger(t2, this.name), this.keychain = i3 || new Pt(this.core, this.logger);
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  async setPrivateKey(e2, t2) {
    return await this.keychain.set(e2, t2), e2;
  }
  getPrivateKey(e2) {
    return this.keychain.get(e2);
  }
  async getClientSeed() {
    let e2 = "";
    try {
      e2 = this.keychain.get(de$2);
    } catch {
      e2 = Vn$1(), await this.keychain.set(de$2, e2);
    }
    return mr(e2, "base16");
  }
  getSymKey(e2) {
    return this.keychain.get(e2);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N$4("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
}
class Ot extends a$3 {
  constructor(e2, t2) {
    super(e2, t2), this.logger = e2, this.core = t2, this.messages = /* @__PURE__ */ new Map(), this.name = rt, this.version = nt, this.initialized = false, this.storagePrefix = O$4, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i3, s3) => {
      this.isInitialized();
      const n4 = Ln(s3);
      let o2 = this.messages.get(i3);
      return typeof o2 > "u" && (o2 = {}), typeof o2[n4] < "u" || (o2[n4] = s3, this.messages.set(i3, o2), await this.persist()), n4;
    }, this.get = (i3) => {
      this.isInitialized();
      let s3 = this.messages.get(i3);
      return typeof s3 > "u" && (s3 = {}), s3;
    }, this.has = (i3, s3) => {
      this.isInitialized();
      const n4 = this.get(i3), o2 = Ln(s3);
      return typeof n4[o2] < "u";
    }, this.del = async (i3) => {
      this.isInitialized(), this.messages.delete(i3), await this.persist();
    }, this.logger = cjs$7.generateChildLogger(e2, this.name), this.core = t2;
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e2) {
    await this.core.storage.setItem(this.storageKey, rt$1(e2));
  }
  async getRelayerMessages() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? ot$1(e2) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N$4("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
}
class vr extends u$4 {
  constructor(e2, t2) {
    super(e2, t2), this.relayer = e2, this.logger = t2, this.events = new eventsExports.EventEmitter(), this.name = at, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = cjs$d.toMiliseconds(cjs$d.TEN_SECONDS), this.needsTransportRestart = false, this.publish = async (i3, s3, n4) => {
      var o2;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s3, opts: n4 } });
      try {
        const a3 = n4?.ttl || ot, h5 = vt$1(n4), l2 = n4?.prompt || false, d3 = n4?.tag || 0, p3 = n4?.id || getBigIntRpcId().toString(), y3 = { topic: i3, message: s3, opts: { ttl: a3, relay: h5, prompt: l2, tag: d3, id: p3 } }, M3 = setTimeout(() => this.queue.set(p3, y3), this.publishTimeout);
        try {
          await await ut$1(this.rpcPublish(i3, s3, a3, h5, l2, d3, p3), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(p3), this.relayer.events.emit(D$4.publish, y3);
        } catch (u3) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = true, (o2 = n4?.internal) != null && o2.throwOnFailedPublish)
            throw this.removeRequestFromQueue(p3), u3;
          return;
        } finally {
          clearTimeout(M3);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s3, opts: n4 } });
      } catch (a3) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(a3), a3;
      }
    }, this.on = (i3, s3) => {
      this.events.on(i3, s3);
    }, this.once = (i3, s3) => {
      this.events.once(i3, s3);
    }, this.off = (i3, s3) => {
      this.events.off(i3, s3);
    }, this.removeListener = (i3, s3) => {
      this.events.removeListener(i3, s3);
    }, this.relayer = e2, this.logger = cjs$7.generateChildLogger(t2, this.name), this.registerEventListeners();
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  rpcPublish(e2, t2, i3, s3, n4, o2, a3) {
    var h5, l2, d3, p3;
    const y3 = { method: Et$1(s3.protocol).publish, params: { topic: e2, message: t2, ttl: i3, prompt: n4, tag: o2 }, id: a3 };
    return w$4((h5 = y3.params) == null ? void 0 : h5.prompt) && ((l2 = y3.params) == null || delete l2.prompt), w$4((d3 = y3.params) == null ? void 0 : d3.tag) && ((p3 = y3.params) == null || delete p3.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: y3 }), this.relayer.request(y3);
  }
  removeRequestFromQueue(e2) {
    this.queue.delete(e2);
  }
  checkQueue() {
    this.queue.forEach(async (e2) => {
      const { topic: t2, message: i3, opts: s3 } = e2;
      await this.publish(t2, i3, s3);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(cjs$8.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(D$4.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D$4.message_ack, (e2) => {
      this.removeRequestFromQueue(e2.id.toString());
    });
  }
}
class Ir {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e2, t2) => {
      const i3 = this.get(e2);
      this.exists(e2, t2) || this.map.set(e2, [...i3, t2]);
    }, this.get = (e2) => this.map.get(e2) || [], this.exists = (e2, t2) => this.get(e2).includes(t2), this.delete = (e2, t2) => {
      if (typeof t2 > "u") {
        this.map.delete(e2);
        return;
      }
      if (!this.map.has(e2))
        return;
      const i3 = this.get(e2);
      if (!this.exists(e2, t2))
        return;
      const s3 = i3.filter((n4) => n4 !== t2);
      if (!s3.length) {
        this.map.delete(e2);
        return;
      }
      this.map.set(e2, s3);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var Cr = Object.defineProperty, Rr = Object.defineProperties, _r = Object.getOwnPropertyDescriptors, At = Object.getOwnPropertySymbols, Sr = Object.prototype.hasOwnProperty, Tr = Object.prototype.propertyIsEnumerable, zt = (r2, e2, t2) => e2 in r2 ? Cr(r2, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : r2[e2] = t2, j$3 = (r2, e2) => {
  for (var t2 in e2 || (e2 = {}))
    Sr.call(e2, t2) && zt(r2, t2, e2[t2]);
  if (At)
    for (var t2 of At(e2))
      Tr.call(e2, t2) && zt(r2, t2, e2[t2]);
  return r2;
}, De$1 = (r2, e2) => Rr(r2, _r(e2));
class Nt extends d$3 {
  constructor(e2, t2) {
    super(e2, t2), this.relayer = e2, this.logger = t2, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Ir(), this.events = new eventsExports.EventEmitter(), this.name = mt, this.version = bt, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O$4, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i3, s3) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s3 } });
      try {
        const n4 = vt$1(s3), o2 = { topic: i3, relay: n4 };
        this.pending.set(i3, o2);
        const a3 = await this.rpcSubscribe(i3, n4);
        return this.onSubscribe(a3, o2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s3 } }), a3;
      } catch (n4) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n4), n4;
      }
    }, this.unsubscribe = async (i3, s3) => {
      await this.restartToComplete(), this.isInitialized(), typeof s3?.id < "u" ? await this.unsubscribeById(i3, s3.id, s3) : await this.unsubscribeByTopic(i3, s3);
    }, this.isSubscribed = async (i3) => this.topics.includes(i3) ? true : await new Promise((s3, n4) => {
      const o2 = new cjs$d.Watch();
      o2.start(this.pendingSubscriptionWatchLabel);
      const a3 = setInterval(() => {
        !this.pending.has(i3) && this.topics.includes(i3) && (clearInterval(a3), o2.stop(this.pendingSubscriptionWatchLabel), s3(true)), o2.elapsed(this.pendingSubscriptionWatchLabel) >= ft$3 && (clearInterval(a3), o2.stop(this.pendingSubscriptionWatchLabel), n4(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => false), this.on = (i3, s3) => {
      this.events.on(i3, s3);
    }, this.once = (i3, s3) => {
      this.events.once(i3, s3);
    }, this.off = (i3, s3) => {
      this.events.off(i3, s3);
    }, this.removeListener = (i3, s3) => {
      this.events.removeListener(i3, s3);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e2, this.logger = cjs$7.generateChildLogger(t2, this.name), this.clientId = "";
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e2, t2) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e2).topic === t2;
    } catch {
    }
    return i3;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e2, t2) {
    const i3 = this.topicMap.get(e2);
    await Promise.all(i3.map(async (s3) => await this.unsubscribeById(e2, s3, t2)));
  }
  async unsubscribeById(e2, t2, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t2, opts: i3 } });
    try {
      const s3 = vt$1(i3);
      await this.rpcUnsubscribe(e2, t2, s3);
      const n4 = U$4("USER_DISCONNECTED", `${this.name}, ${e2}`);
      await this.onUnsubscribe(e2, t2, n4), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t2, opts: i3 } });
    } catch (s3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s3), s3;
    }
  }
  async rpcSubscribe(e2, t2) {
    const i3 = { method: Et$1(t2.protocol).subscribe, params: { topic: e2 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await ut$1(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D$4.connection_stalled);
    }
    return Ln(e2 + this.clientId);
  }
  async rpcBatchSubscribe(e2) {
    if (!e2.length)
      return;
    const t2 = e2[0].relay, i3 = { method: Et$1(t2.protocol).batchSubscribe, params: { topics: e2.map((s3) => s3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      return await await ut$1(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D$4.connection_stalled);
    }
  }
  rpcUnsubscribe(e2, t2, i3) {
    const s3 = { method: Et$1(i3.protocol).unsubscribe, params: { topic: e2, id: t2 } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s3 }), this.relayer.request(s3);
  }
  onSubscribe(e2, t2) {
    this.setSubscription(e2, De$1(j$3({}, t2), { id: e2 })), this.pending.delete(t2.topic);
  }
  onBatchSubscribe(e2) {
    e2.length && e2.forEach((t2) => {
      this.setSubscription(t2.id, j$3({}, t2)), this.pending.delete(t2.topic);
    });
  }
  async onUnsubscribe(e2, t2, i3) {
    this.events.removeAllListeners(t2), this.hasSubscription(t2, e2) && this.deleteSubscription(t2, i3), await this.relayer.messages.del(e2);
  }
  async setRelayerSubscriptions(e2) {
    await this.relayer.core.storage.setItem(this.storageKey, e2);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e2, t2) {
    this.subscriptions.has(e2) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e2, subscription: t2 }), this.addSubscription(e2, t2));
  }
  addSubscription(e2, t2) {
    this.subscriptions.set(e2, j$3({}, t2)), this.topicMap.set(t2.topic, e2), this.events.emit(w$2.created, t2);
  }
  getSubscription(e2) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e2 });
    const t2 = this.subscriptions.get(e2);
    if (!t2) {
      const { message: i3 } = N$4("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(i3);
    }
    return t2;
  }
  deleteSubscription(e2, t2) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e2, reason: t2 });
    const i3 = this.getSubscription(e2);
    this.subscriptions.delete(e2), this.topicMap.delete(i3.topic, e2), this.events.emit(w$2.deleted, De$1(j$3({}, i3), { reason: t2 }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(w$2.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e2 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t2 = 0; t2 < e2; t2++) {
        const i3 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i3);
      }
    }
    this.events.emit(w$2.resubscribed);
  }
  async restore() {
    try {
      const e2 = await this.getRelayerSubscriptions();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.subscriptions.size) {
        const { message: t2 } = N$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t2);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e2);
    }
  }
  async batchSubscribe(e2) {
    if (!e2.length)
      return;
    const t2 = await this.rpcBatchSubscribe(e2);
    k$4(t2) && this.onBatchSubscribe(t2.map((i3, s3) => De$1(j$3({}, e2[s3]), { id: i3 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e2 = [];
    this.pending.forEach((t2) => {
      e2.push(t2);
    }), await this.batchSubscribe(e2);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(cjs$8.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D$4.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D$4.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(w$2.created, async (e2) => {
      const t2 = w$2.created;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e2 }), await this.persist();
    }), this.events.on(w$2.deleted, async (e2) => {
      const t2 = w$2.deleted;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e2 }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N$4("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e2) => {
      const t2 = setInterval(() => {
        this.restartInProgress || (clearInterval(t2), e2());
      }, this.pollingInterval);
    });
  }
}
var Pr = Object.defineProperty, Ut = Object.getOwnPropertySymbols, xr = Object.prototype.hasOwnProperty, Or = Object.prototype.propertyIsEnumerable, Lt = (r2, e2, t2) => e2 in r2 ? Pr(r2, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : r2[e2] = t2, Ar = (r2, e2) => {
  for (var t2 in e2 || (e2 = {}))
    xr.call(e2, t2) && Lt(r2, t2, e2[t2]);
  if (Ut)
    for (var t2 of Ut(e2))
      Or.call(e2, t2) && Lt(r2, t2, e2[t2]);
  return r2;
};
class Ft extends g$6 {
  constructor(e2) {
    super(e2), this.protocol = "wc", this.version = 2, this.events = new eventsExports.EventEmitter(), this.name = ut, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = false, this.request = async (t2) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t2);
      } catch (i3) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i3), i3;
      }
    }, this.onPayloadHandler = (t2) => {
      this.onProviderPayload(t2);
    }, this.onConnectHandler = () => {
      this.events.emit(D$4.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t2) => {
      this.logger.error(t2), this.events.emit(D$4.error, t2), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(P$5.payload, this.onPayloadHandler), this.provider.on(P$5.connect, this.onConnectHandler), this.provider.on(P$5.disconnect, this.onDisconnectHandler), this.provider.on(P$5.error, this.onProviderErrorHandler);
    }, this.core = e2.core, this.logger = typeof e2.logger < "u" && typeof e2.logger != "string" ? cjs$7.generateChildLogger(e2.logger, this.name) : cjs$7.pino(cjs$7.getDefaultLoggerOptions({ level: e2.logger || ct })), this.messages = new Ot(this.logger, e2.core), this.subscriber = new Nt(this, this.logger), this.publisher = new vr(this, this.logger), this.relayUrl = e2?.relayUrl || ge$2, this.projectId = e2.projectId, this.bundleId = Jn(), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${pe$2}...`), await this.restartTransport(pe$2);
    }
    this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, pt);
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e2, t2, i3) {
    this.isInitialized(), await this.publisher.publish(e2, t2, i3), await this.recordMessageEvent({ topic: e2, message: t2, publishedAt: Date.now() });
  }
  async subscribe(e2, t2) {
    var i3;
    this.isInitialized();
    let s3 = ((i3 = this.subscriber.topicMap.get(e2)) == null ? void 0 : i3[0]) || "";
    if (s3)
      return s3;
    let n4;
    const o2 = (a3) => {
      a3.topic === e2 && (this.subscriber.off(w$2.created, o2), n4());
    };
    return await Promise.all([new Promise((a3) => {
      n4 = a3, this.subscriber.on(w$2.created, o2);
    }), new Promise(async (a3) => {
      s3 = await this.subscriber.subscribe(e2, t2), a3();
    })]), s3;
  }
  async unsubscribe(e2, t2) {
    this.isInitialized(), await this.subscriber.unsubscribe(e2, t2);
  }
  on(e2, t2) {
    this.events.on(e2, t2);
  }
  once(e2, t2) {
    this.events.once(e2, t2);
  }
  off(e2, t2) {
    this.events.off(e2, t2);
  }
  removeListener(e2, t2) {
    this.events.removeListener(e2, t2);
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, this.hasExperiencedNetworkDisruption && this.connected ? await ut$1(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e2) {
    if (this.transportExplicitlyClosed = false, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e2 && e2 !== this.relayUrl && (this.relayUrl = e2, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = true;
      try {
        await Promise.all([new Promise((t2) => {
          if (!this.initialized)
            return t2();
          this.subscriber.once(w$2.resubscribed, () => {
            t2();
          });
        }), new Promise(async (t2, i3) => {
          try {
            await ut$1(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (s3) {
            i3(s3);
            return;
          }
          t2();
        })]);
      } catch (t2) {
        this.logger.error(t2);
        const i3 = t2;
        if (!this.isConnectionStalled(i3.message))
          throw t2;
        this.provider.events.emit(P$5.disconnect);
      } finally {
        this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false;
      }
    }
  }
  async restartTransport(e2) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e2 || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await er$1())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e2) {
    return this.staleConnectionErrors.some((t2) => e2.includes(t2));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e2 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new f$4(Xn({ sdkVersion: gt$7, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e2, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e2) {
    const { topic: t2, message: i3 } = e2;
    await this.messages.set(t2, i3);
  }
  async shouldIgnoreMessageEvent(e2) {
    const { topic: t2, message: i3 } = e2;
    if (!i3 || i3.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i3}`), true;
    if (!await this.subscriber.isSubscribed(t2))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t2}`), true;
    const s3 = this.messages.has(t2, i3);
    return s3 && this.logger.debug(`Ignoring duplicate message: ${i3}`), s3;
  }
  async onProviderPayload(e2) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e2 }), isJsonRpcRequest(e2)) {
      if (!e2.method.endsWith(lt$6))
        return;
      const t2 = e2.params, { topic: i3, message: s3, publishedAt: n4 } = t2.data, o2 = { topic: i3, message: s3, publishedAt: n4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ar({ type: "event", event: t2.id }, o2)), this.events.emit(t2.id, o2), await this.acknowledgePayload(e2), await this.onMessageEvent(o2);
    } else
      isJsonRpcResponse(e2) && this.events.emit(D$4.message_ack, e2);
  }
  async onMessageEvent(e2) {
    await this.shouldIgnoreMessageEvent(e2) || (this.events.emit(D$4.message, e2), await this.recordMessageEvent(e2));
  }
  async acknowledgePayload(e2) {
    const t2 = formatJsonRpcResult(e2.id, true);
    await this.provider.connection.send(t2);
  }
  unregisterProviderListeners() {
    this.provider.off(P$5.payload, this.onPayloadHandler), this.provider.off(P$5.connect, this.onConnectHandler), this.provider.off(P$5.disconnect, this.onDisconnectHandler), this.provider.off(P$5.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D$4.connection_stalled, () => {
      this.restartTransport().catch((t2) => this.logger.error(t2));
    });
    let e2 = await er$1();
    nr$1(async (t2) => {
      this.initialized && e2 !== t2 && (e2 = t2, t2 ? await this.restartTransport().catch((i3) => this.logger.error(i3)) : (this.hasExperiencedNetworkDisruption = true, await this.transportClose().catch((i3) => this.logger.error(i3))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D$4.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e2) => this.logger.error(e2));
    }, cjs$d.toMiliseconds(dt)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N$4("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e2) => {
          const t2 = setInterval(() => {
            this.connected && (clearInterval(t2), e2());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
}
var zr = Object.defineProperty, $t = Object.getOwnPropertySymbols, Nr = Object.prototype.hasOwnProperty, Ur = Object.prototype.propertyIsEnumerable, Mt = (r2, e2, t2) => e2 in r2 ? zr(r2, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : r2[e2] = t2, kt = (r2, e2) => {
  for (var t2 in e2 || (e2 = {}))
    Nr.call(e2, t2) && Mt(r2, t2, e2[t2]);
  if ($t)
    for (var t2 of $t(e2))
      Ur.call(e2, t2) && Mt(r2, t2, e2[t2]);
  return r2;
};
class Kt extends p$6 {
  constructor(e2, t2, i3, s3 = O$4, n4 = void 0) {
    super(e2, t2, i3, s3), this.core = e2, this.logger = t2, this.name = i3, this.map = /* @__PURE__ */ new Map(), this.version = Dt, this.cached = [], this.initialized = false, this.storagePrefix = O$4, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o2) => {
        this.getKey && o2 !== null && !w$4(o2) ? this.map.set(this.getKey(o2), o2) : Vt$1(o2) ? this.map.set(o2.id, o2) : Mt$1(o2) && this.map.set(o2.topic, o2);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (o2, a3) => {
      this.isInitialized(), this.map.has(o2) ? await this.update(o2, a3) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o2, value: a3 }), this.map.set(o2, a3), await this.persist());
    }, this.get = (o2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o2 }), this.getData(o2)), this.getAll = (o2) => (this.isInitialized(), o2 ? this.values.filter((a3) => Object.keys(o2).every((h5) => Gi$1(a3[h5], o2[h5]))) : this.values), this.update = async (o2, a3) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o2, update: a3 });
      const h5 = kt(kt({}, this.getData(o2)), a3);
      this.map.set(o2, h5), await this.persist();
    }, this.delete = async (o2, a3) => {
      this.isInitialized(), this.map.has(o2) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o2, reason: a3 }), this.map.delete(o2), await this.persist());
    }, this.logger = cjs$7.generateChildLogger(t2, this.name), this.storagePrefix = s3, this.getKey = n4;
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e2) {
    const t2 = this.map.get(e2);
    if (!t2) {
      const { message: i3 } = N$4("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t2;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e2 = await this.getDataStore();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.map.size) {
        const { message: t2 } = N$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N$4("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
}
class Bt {
  constructor(e2, t2) {
    this.core = e2, this.logger = t2, this.name = Et, this.version = wt, this.events = new $g$1(), this.initialized = false, this.storagePrefix = O$4, this.ignoredPayloadTypes = [_$4], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }, this.create = async () => {
      this.isInitialized();
      const i3 = Vn$1(), s3 = await this.core.crypto.setSymKey(i3), n4 = pt$1(cjs$d.FIVE_MINUTES), o2 = { protocol: ht }, a3 = { topic: s3, expiry: n4, relay: o2, active: false }, h5 = It$1({ protocol: this.core.protocol, version: this.core.version, topic: s3, symKey: i3, relay: o2 });
      return await this.pairings.set(s3, a3), await this.core.relayer.subscribe(s3), this.core.expirer.set(s3, n4), { topic: s3, uri: h5 };
    }, this.pair = async (i3) => {
      this.isInitialized(), this.isValidPair(i3);
      const { topic: s3, symKey: n4, relay: o2 } = wt$1(i3.uri);
      let a3;
      if (this.pairings.keys.includes(s3) && (a3 = this.pairings.get(s3), a3.active))
        throw new Error(`Pairing already exists: ${s3}. Please try again with a new connection URI.`);
      const h5 = pt$1(cjs$d.FIVE_MINUTES), l2 = { topic: s3, relay: o2, expiry: h5, active: false };
      return await this.pairings.set(s3, l2), this.core.expirer.set(s3, h5), i3.activatePairing && await this.activate({ topic: s3 }), this.events.emit(V$3.create, l2), this.core.crypto.keychain.has(s3) || (await this.core.crypto.setSymKey(n4, s3), await this.core.relayer.subscribe(s3, { relay: o2 })), l2;
    }, this.activate = async ({ topic: i3 }) => {
      this.isInitialized();
      const s3 = pt$1(cjs$d.THIRTY_DAYS);
      await this.pairings.update(i3, { active: true, expiry: s3 }), this.core.expirer.set(i3, s3);
    }, this.ping = async (i3) => {
      this.isInitialized(), await this.isValidPing(i3);
      const { topic: s3 } = i3;
      if (this.pairings.keys.includes(s3)) {
        const n4 = await this.sendRequest(s3, "wc_pairingPing", {}), { done: o2, resolve: a3, reject: h5 } = at$1();
        this.events.once(yt$1("pairing_ping", n4), ({ error: l2 }) => {
          l2 ? h5(l2) : a3();
        }), await o2();
      }
    }, this.updateExpiry = async ({ topic: i3, expiry: s3 }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s3 });
    }, this.updateMetadata = async ({ topic: i3, metadata: s3 }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s3 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s3 } = i3;
      this.pairings.keys.includes(s3) && (await this.sendRequest(s3, "wc_pairingDelete", U$4("USER_DISCONNECTED")), await this.deletePairing(s3));
    }, this.sendRequest = async (i3, s3, n4) => {
      const o2 = formatJsonRpcRequest(s3, n4), a3 = await this.core.crypto.encode(i3, o2), h5 = F$4[s3].req;
      return this.core.history.set(i3, o2), this.core.relayer.publish(i3, a3, h5), o2.id;
    }, this.sendResult = async (i3, s3, n4) => {
      const o2 = formatJsonRpcResult(i3, n4), a3 = await this.core.crypto.encode(s3, o2), h5 = await this.core.history.get(s3, i3), l2 = F$4[h5.request.method].res;
      await this.core.relayer.publish(s3, a3, l2), await this.core.history.resolve(o2);
    }, this.sendError = async (i3, s3, n4) => {
      const o2 = formatJsonRpcError(i3, n4), a3 = await this.core.crypto.encode(s3, o2), h5 = await this.core.history.get(s3, i3), l2 = F$4[h5.request.method] ? F$4[h5.request.method].res : F$4.unregistered_method.res;
      await this.core.relayer.publish(s3, a3, l2), await this.core.history.resolve(o2);
    }, this.deletePairing = async (i3, s3) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, U$4("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s3 ? Promise.resolve() : this.core.expirer.del(i3)]);
    }, this.cleanup = async () => {
      const i3 = this.pairings.getAll().filter((s3) => mt$1(s3.expiry));
      await Promise.all(i3.map((s3) => this.deletePairing(s3.topic)));
    }, this.onRelayEventRequest = (i3) => {
      const { topic: s3, payload: n4 } = i3;
      switch (n4.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s3, n4);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s3, n4);
        default:
          return this.onUnknownRpcMethodRequest(s3, n4);
      }
    }, this.onRelayEventResponse = async (i3) => {
      const { topic: s3, payload: n4 } = i3, o2 = (await this.core.history.get(s3, n4.id)).request.method;
      switch (o2) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s3, n4);
        default:
          return this.onUnknownRpcMethodResponse(o2);
      }
    }, this.onPairingPingRequest = async (i3, s3) => {
      const { id: n4 } = s3;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(n4, i3, true), this.events.emit(V$3.ping, { id: n4, topic: i3 });
      } catch (o2) {
        await this.sendError(n4, i3, o2), this.logger.error(o2);
      }
    }, this.onPairingPingResponse = (i3, s3) => {
      const { id: n4 } = s3;
      setTimeout(() => {
        isJsonRpcResult(s3) ? this.events.emit(yt$1("pairing_ping", n4), {}) : isJsonRpcError(s3) && this.events.emit(yt$1("pairing_ping", n4), { error: s3.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i3, s3) => {
      const { id: n4 } = s3;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit(V$3.delete, { id: n4, topic: i3 });
      } catch (o2) {
        await this.sendError(n4, i3, o2), this.logger.error(o2);
      }
    }, this.onUnknownRpcMethodRequest = async (i3, s3) => {
      const { id: n4, method: o2 } = s3;
      try {
        if (this.registeredMethods.includes(o2))
          return;
        const a3 = U$4("WC_METHOD_UNSUPPORTED", o2);
        await this.sendError(n4, i3, a3), this.logger.error(a3);
      } catch (a3) {
        await this.sendError(n4, i3, a3), this.logger.error(a3);
      }
    }, this.onUnknownRpcMethodResponse = (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(U$4("WC_METHOD_UNSUPPORTED", i3));
    }, this.isValidPair = (i3) => {
      var s3;
      if (!Ht$1(i3)) {
        const { message: o2 } = N$4("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw new Error(o2);
      }
      if (!kt$1(i3.uri)) {
        const { message: o2 } = N$4("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw new Error(o2);
      }
      const n4 = wt$1(i3.uri);
      if (!((s3 = n4?.relay) != null && s3.protocol)) {
        const { message: o2 } = N$4("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw new Error(o2);
      }
      if (!(n4 != null && n4.symKey)) {
        const { message: o2 } = N$4("MISSING_OR_INVALID", "pair() uri#symKey");
        throw new Error(o2);
      }
    }, this.isValidPing = async (i3) => {
      if (!Ht$1(i3)) {
        const { message: n4 } = N$4("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(n4);
      }
      const { topic: s3 } = i3;
      await this.isValidPairingTopic(s3);
    }, this.isValidDisconnect = async (i3) => {
      if (!Ht$1(i3)) {
        const { message: n4 } = N$4("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(n4);
      }
      const { topic: s3 } = i3;
      await this.isValidPairingTopic(s3);
    }, this.isValidPairingTopic = async (i3) => {
      if (!h$4(i3, false)) {
        const { message: s3 } = N$4("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s3);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s3 } = N$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s3);
      }
      if (mt$1(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s3 } = N$4("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s3);
      }
    }, this.core = e2, this.logger = cjs$7.generateChildLogger(t2, this.name), this.pairings = new Kt(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N$4("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D$4.message, async (e2) => {
      const { topic: t2, message: i3 } = e2;
      if (!this.pairings.keys.includes(t2) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3)))
        return;
      const s3 = await this.core.crypto.decode(t2, i3);
      try {
        isJsonRpcRequest(s3) ? (this.core.history.set(t2, s3), this.onRelayEventRequest({ topic: t2, payload: s3 })) : isJsonRpcResponse(s3) && (await this.core.history.resolve(s3), await this.onRelayEventResponse({ topic: t2, payload: s3 }), this.core.history.delete(t2, s3.id));
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(v$5.expired, async (e2) => {
      const { topic: t2 } = ft$4(e2.target);
      t2 && this.pairings.keys.includes(t2) && (await this.deletePairing(t2, true), this.events.emit(V$3.expire, { topic: t2 }));
    });
  }
}
class Vt extends h$5 {
  constructor(e2, t2) {
    super(e2, t2), this.core = e2, this.logger = t2, this.records = /* @__PURE__ */ new Map(), this.events = new eventsExports.EventEmitter(), this.name = vt, this.version = It, this.cached = [], this.initialized = false, this.storagePrefix = O$4, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i3, s3, n4) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s3, chainId: n4 }), this.records.has(s3.id))
        return;
      const o2 = { id: s3.id, topic: i3, request: { method: s3.method, params: s3.params || null }, chainId: n4, expiry: pt$1(cjs$d.THIRTY_DAYS) };
      this.records.set(o2.id, o2), this.events.emit(R$2.created, o2);
    }, this.resolve = async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id))
        return;
      const s3 = await this.getRecord(i3.id);
      typeof s3.response > "u" && (s3.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s3.id, s3), this.events.emit(R$2.updated, s3));
    }, this.get = async (i3, s3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s3 }), await this.getRecord(s3)), this.delete = (i3, s3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s3 }), this.values.forEach((n4) => {
        if (n4.topic === i3) {
          if (typeof s3 < "u" && n4.id !== s3)
            return;
          this.records.delete(n4.id), this.events.emit(R$2.deleted, n4);
        }
      });
    }, this.exists = async (i3, s3) => (this.isInitialized(), this.records.has(s3) ? (await this.getRecord(s3)).topic === i3 : false), this.on = (i3, s3) => {
      this.events.on(i3, s3);
    }, this.once = (i3, s3) => {
      this.events.once(i3, s3);
    }, this.off = (i3, s3) => {
      this.events.off(i3, s3);
    }, this.removeListener = (i3, s3) => {
      this.events.removeListener(i3, s3);
    }, this.logger = cjs$7.generateChildLogger(t2, this.name);
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e2 = [];
    return this.values.forEach((t2) => {
      if (typeof t2.response < "u")
        return;
      const i3 = { topic: t2.topic, request: formatJsonRpcRequest(t2.request.method, t2.request.params, t2.id), chainId: t2.chainId };
      return e2.push(i3);
    }), e2;
  }
  async setJsonRpcRecords(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e2) {
    this.isInitialized();
    const t2 = this.records.get(e2);
    if (!t2) {
      const { message: i3 } = N$4("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(i3);
    }
    return t2;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R$2.sync);
  }
  async restore() {
    try {
      const e2 = await this.getJsonRpcRecords();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.records.size) {
        const { message: t2 } = N$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e2);
    }
  }
  registerEventListeners() {
    this.events.on(R$2.created, (e2) => {
      const t2 = R$2.created;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e2 }), this.persist();
    }), this.events.on(R$2.updated, (e2) => {
      const t2 = R$2.updated;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e2 }), this.persist();
    }), this.events.on(R$2.deleted, (e2) => {
      const t2 = R$2.deleted;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e2 }), this.persist();
    }), this.core.heartbeat.on(cjs$8.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e2) => {
        cjs$d.toMiliseconds(e2.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e2.id}`), this.delete(e2.topic, e2.id));
      });
    } catch (e2) {
      this.logger.warn(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N$4("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
}
class jt extends E$4 {
  constructor(e2, t2) {
    super(e2, t2), this.core = e2, this.logger = t2, this.expirations = /* @__PURE__ */ new Map(), this.events = new eventsExports.EventEmitter(), this.name = Ct$1, this.version = Rt, this.cached = [], this.initialized = false, this.storagePrefix = O$4, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i3) => {
      try {
        const s3 = this.formatTarget(i3);
        return typeof this.getExpiration(s3) < "u";
      } catch {
        return false;
      }
    }, this.set = (i3, s3) => {
      this.isInitialized();
      const n4 = this.formatTarget(i3), o2 = { target: n4, expiry: s3 };
      this.expirations.set(n4, o2), this.checkExpiry(n4, o2), this.events.emit(v$5.created, { target: n4, expiration: o2 });
    }, this.get = (i3) => {
      this.isInitialized();
      const s3 = this.formatTarget(i3);
      return this.getExpiration(s3);
    }, this.del = (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s3 = this.formatTarget(i3), n4 = this.getExpiration(s3);
        this.expirations.delete(s3), this.events.emit(v$5.deleted, { target: s3, expiration: n4 });
      }
    }, this.on = (i3, s3) => {
      this.events.on(i3, s3);
    }, this.once = (i3, s3) => {
      this.events.once(i3, s3);
    }, this.off = (i3, s3) => {
      this.events.off(i3, s3);
    }, this.removeListener = (i3, s3) => {
      this.events.removeListener(i3, s3);
    }, this.logger = cjs$7.generateChildLogger(t2, this.name);
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e2) {
    if (typeof e2 == "string")
      return lt$7(e2);
    if (typeof e2 == "number")
      return dt$1(e2);
    const { message: t2 } = N$4("UNKNOWN_TYPE", `Target type: ${typeof e2}`);
    throw new Error(t2);
  }
  async setExpirations(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(v$5.sync);
  }
  async restore() {
    try {
      const e2 = await this.getExpirations();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.expirations.size) {
        const { message: t2 } = N$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e2);
    }
  }
  getExpiration(e2) {
    const t2 = this.expirations.get(e2);
    if (!t2) {
      const { message: i3 } = N$4("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t2;
  }
  checkExpiry(e2, t2) {
    const { expiry: i3 } = t2;
    cjs$d.toMiliseconds(i3) - Date.now() <= 0 && this.expire(e2, t2);
  }
  expire(e2, t2) {
    this.expirations.delete(e2), this.events.emit(v$5.expired, { target: e2, expiration: t2 });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e2, t2) => this.checkExpiry(t2, e2));
  }
  registerEventListeners() {
    this.core.heartbeat.on(cjs$8.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(v$5.created, (e2) => {
      const t2 = v$5.created;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e2 }), this.persist();
    }), this.events.on(v$5.expired, (e2) => {
      const t2 = v$5.expired;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e2 }), this.persist();
    }), this.events.on(v$5.deleted, (e2) => {
      const t2 = v$5.deleted;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e2 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N$4("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
}
class qt extends y$4 {
  constructor(e2, t2) {
    super(e2, t2), this.projectId = e2, this.logger = t2, this.name = Z$1, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async (i3) => {
      if (this.verifyDisabled || C$3() || !D$5())
        return;
      const s3 = this.getVerifyUrl(i3?.verifyUrl);
      this.verifyUrl !== s3 && this.removeIframe(), this.verifyUrl = s3;
      try {
        await this.createIframe();
      } catch (n4) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n4);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = ee$1;
        try {
          await this.createIframe();
        } catch (n4) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n4), this.verifyDisabled = true;
        }
      }
    }, this.register = async (i3) => {
      this.initialized ? this.sendPost(i3.attestationId) : (this.addToQueue(i3.attestationId), await this.init());
    }, this.resolve = async (i3) => {
      if (this.isDevEnv)
        return "";
      const s3 = this.getVerifyUrl(i3?.verifyUrl);
      let n4;
      try {
        n4 = await this.fetchAttestation(i3.attestationId, s3);
      } catch (o2) {
        this.logger.info(`failed to resolve attestation: ${i3.attestationId} from url: ${s3}`), this.logger.info(o2), n4 = await this.fetchAttestation(i3.attestationId, ee$1);
      }
      return n4;
    }, this.fetchAttestation = async (i3, s3) => {
      this.logger.info(`resolving attestation: ${i3} from url: ${s3}`);
      const n4 = this.startAbortTimer(cjs$d.ONE_SECOND * 2), o2 = await fetch(`${s3}/attestation/${i3}`, { signal: this.abortController.signal });
      return clearTimeout(n4), o2.status === 200 ? await o2.json() : void 0;
    }, this.addToQueue = (i3) => {
      this.queue.push(i3);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i3) => this.sendPost(i3)), this.queue = []);
    }, this.sendPost = (i3) => {
      var s3;
      try {
        if (!this.iframe)
          return;
        (s3 = this.iframe.contentWindow) == null || s3.postMessage(i3, "*"), this.logger.info(`postMessage sent: ${i3} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i3;
      const s3 = (n4) => {
        n4.data === "verify_ready" && (this.initialized = true, this.processQueue(), window.removeEventListener("message", s3), i3());
      };
      await Promise.race([new Promise((n4) => {
        if (document.getElementById(Z$1))
          return n4();
        window.addEventListener("message", s3);
        const o2 = document.createElement("iframe");
        o2.id = Z$1, o2.src = `${this.verifyUrl}/${this.projectId}`, o2.style.display = "none", document.body.append(o2), this.iframe = o2, i3 = n4;
      }), new Promise((n4, o2) => setTimeout(() => {
        window.removeEventListener("message", s3), o2("verify iframe load timeout");
      }, cjs$d.toMiliseconds(cjs$d.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
    }, this.getVerifyUrl = (i3) => {
      let s3 = i3 || $$2;
      return _t.includes(s3) || (this.logger.info(`verify url: ${s3}, not included in trusted list, assigning default: ${$$2}`), s3 = $$2), s3;
    }, this.logger = cjs$7.generateChildLogger(t2, this.name), this.verifyUrl = $$2, this.abortController = new AbortController(), this.isDevEnv = te$2() && {}.IS_VITEST;
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  startAbortTimer(e2) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), cjs$d.toMiliseconds(e2));
  }
}
class Gt extends v$6 {
  constructor(e2, t2) {
    super(e2, t2), this.projectId = e2, this.logger = t2, this.context = St, this.registerDeviceToken = async (i3) => {
      const { clientId: s3, token: n4, notificationType: o2, enableEncrypted: a3 = false } = i3, h5 = `${Tt}/${this.projectId}/clients`;
      await Yi$1(h5, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s3, type: o2, token: n4, always_raw: a3 }) });
    }, this.logger = cjs$7.generateChildLogger(t2, this.context);
  }
}
var Lr = Object.defineProperty, Yt = Object.getOwnPropertySymbols, Fr = Object.prototype.hasOwnProperty, $r = Object.prototype.propertyIsEnumerable, Ht = (r2, e2, t2) => e2 in r2 ? Lr(r2, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : r2[e2] = t2, Jt = (r2, e2) => {
  for (var t2 in e2 || (e2 = {}))
    Fr.call(e2, t2) && Ht(r2, t2, e2[t2]);
  if (Yt)
    for (var t2 of Yt(e2))
      $r.call(e2, t2) && Ht(r2, t2, e2[t2]);
  return r2;
};
let te$1 = class te2 extends n$1 {
  constructor(e2) {
    super(e2), this.protocol = le$2, this.version = We$1, this.name = Q$4, this.events = new eventsExports.EventEmitter(), this.initialized = false, this.on = (i3, s3) => this.events.on(i3, s3), this.once = (i3, s3) => this.events.once(i3, s3), this.off = (i3, s3) => this.events.off(i3, s3), this.removeListener = (i3, s3) => this.events.removeListener(i3, s3), this.projectId = e2?.projectId, this.relayUrl = e2?.relayUrl || ge$2, this.customStoragePrefix = e2 != null && e2.customStoragePrefix ? `:${e2.customStoragePrefix}` : "";
    const t2 = typeof e2?.logger < "u" && typeof e2?.logger != "string" ? e2.logger : cjs$7.pino(cjs$7.getDefaultLoggerOptions({ level: e2?.logger || Qe$1.logger }));
    this.logger = cjs$7.generateChildLogger(t2, this.name), this.heartbeat = new cjs$8.HeartBeat(), this.crypto = new xt(this, this.logger, e2?.keychain), this.history = new Vt(this, this.logger), this.expirer = new jt(this, this.logger), this.storage = e2 != null && e2.storage ? e2.storage : new h$6(Jt(Jt({}, Ze$1), e2?.storageOptions)), this.relayer = new Ft({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Bt(this, this.logger), this.verify = new qt(this.projectId || "", this.logger), this.echoClient = new Gt(this.projectId || "", this.logger);
  }
  static async init(e2) {
    const t2 = new te2(e2);
    await t2.initialize();
    const i3 = await t2.crypto.getClientId();
    return await t2.storage.setItem(yt, i3), t2;
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e2) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e2), this.logger.error(e2.message), e2;
    }
  }
};
const Mr = te$1;
const X$1 = "wc", F$3 = 2, H$3 = "client", G$1 = `${X$1}@${F$3}:${H$3}:`, M$4 = { name: H$3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" }, W$7 = "WALLETCONNECT_DEEPLINK_CHOICE", ne$1 = "proposal", oe$2 = "Proposal expired", ae$1 = "session", A$4 = cjs$d.SEVEN_DAYS, ce$1 = "engine", V$2 = { wc_sessionPropose: { req: { ttl: cjs$d.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: cjs$d.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: cjs$d.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: cjs$d.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: cjs$d.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: cjs$d.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: cjs$d.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: cjs$d.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: cjs$d.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: cjs$d.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: cjs$d.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: cjs$d.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: cjs$d.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: cjs$d.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: cjs$d.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: cjs$d.THIRTY_SECONDS, prompt: false, tag: 1115 } } }, U$3 = { min: cjs$d.FIVE_MINUTES, max: cjs$d.SEVEN_DAYS }, I$3 = { idle: "IDLE", active: "ACTIVE" }, le$1 = "request", pe$1 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var as = Object.defineProperty, cs$1 = Object.defineProperties, ls = Object.getOwnPropertyDescriptors, he$1 = Object.getOwnPropertySymbols, ps = Object.prototype.hasOwnProperty, hs = Object.prototype.propertyIsEnumerable, de$1 = (m2, r2, e2) => r2 in m2 ? as(m2, r2, { enumerable: true, configurable: true, writable: true, value: e2 }) : m2[r2] = e2, g$4 = (m2, r2) => {
  for (var e2 in r2 || (r2 = {}))
    ps.call(r2, e2) && de$1(m2, e2, r2[e2]);
  if (he$1)
    for (var e2 of he$1(r2))
      hs.call(r2, e2) && de$1(m2, e2, r2[e2]);
  return m2;
}, b$3 = (m2, r2) => cs$1(m2, ls(r2));
class ds extends w$5 {
  constructor(r2) {
    super(r2), this.name = ce$1, this.events = new $g$1(), this.initialized = false, this.ignoredPayloadTypes = [_$4], this.requestQueue = { state: I$3.idle, queue: [] }, this.sessionRequestQueue = { state: I$3.idle, queue: [] }, this.requestQueueDelay = cjs$d.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(V$2) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, cjs$d.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (e2) => {
      await this.isInitialized();
      const s3 = b$3(g$4({}, e2), { requiredNamespaces: e2.requiredNamespaces || {}, optionalNamespaces: e2.optionalNamespaces || {} });
      await this.isValidConnect(s3);
      const { pairingTopic: t2, requiredNamespaces: i3, optionalNamespaces: n4, sessionProperties: o2, relays: a3 } = s3;
      let c2 = t2, p3, d3 = false;
      if (c2 && (d3 = this.client.core.pairing.pairings.get(c2).active), !c2 || !d3) {
        const { topic: v4, uri: S3 } = await this.client.core.pairing.create();
        c2 = v4, p3 = S3;
      }
      const h5 = await this.client.core.crypto.generateKeyPair(), R3 = g$4({ requiredNamespaces: i3, optionalNamespaces: n4, relays: a3 ?? [{ protocol: ht }], proposer: { publicKey: h5, metadata: this.client.metadata } }, o2 && { sessionProperties: o2 }), { reject: w3, resolve: T2, done: K3 } = at$1(cjs$d.FIVE_MINUTES, oe$2);
      if (this.events.once(yt$1("session_connect"), async ({ error: v4, session: S3 }) => {
        if (v4)
          w3(v4);
        else if (S3) {
          S3.self.publicKey = h5;
          const B2 = b$3(g$4({}, S3), { requiredNamespaces: S3.requiredNamespaces, optionalNamespaces: S3.optionalNamespaces });
          await this.client.session.set(S3.topic, B2), await this.setExpiry(S3.topic, S3.expiry), c2 && await this.client.core.pairing.updateMetadata({ topic: c2, metadata: S3.peer.metadata }), T2(B2);
        }
      }), !c2) {
        const { message: v4 } = N$4("NO_MATCHING_KEY", `connect() pairing topic: ${c2}`);
        throw new Error(v4);
      }
      const L3 = await this.sendRequest({ topic: c2, method: "wc_sessionPropose", params: R3 }), ge2 = pt$1(cjs$d.FIVE_MINUTES);
      return await this.setProposal(L3, g$4({ id: L3, expiry: ge2 }, R3)), { uri: p3, approval: K3 };
    }, this.pair = async (e2) => (await this.isInitialized(), await this.client.core.pairing.pair(e2)), this.approve = async (e2) => {
      await this.isInitialized(), await this.isValidApprove(e2);
      const { id: s3, relayProtocol: t2, namespaces: i3, sessionProperties: n4 } = e2, o2 = this.client.proposal.get(s3);
      let { pairingTopic: a3, proposer: c2, requiredNamespaces: p3, optionalNamespaces: d3 } = o2;
      a3 = a3 || "", B$6(p3) || (p3 = jt$1(i3, "approve()"));
      const h5 = await this.client.core.crypto.generateKeyPair(), R3 = c2.publicKey, w3 = await this.client.core.crypto.generateSharedKey(h5, R3);
      a3 && s3 && (await this.client.core.pairing.updateMetadata({ topic: a3, metadata: c2.metadata }), await this.sendResult({ id: s3, topic: a3, result: { relay: { protocol: t2 ?? "irn" }, responderPublicKey: h5 } }), await this.client.proposal.delete(s3, U$4("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a3 }));
      const T2 = g$4({ relay: { protocol: t2 ?? "irn" }, namespaces: i3, requiredNamespaces: p3, optionalNamespaces: d3, pairingTopic: a3, controller: { publicKey: h5, metadata: this.client.metadata }, expiry: pt$1(A$4) }, n4 && { sessionProperties: n4 });
      await this.client.core.relayer.subscribe(w3), await this.sendRequest({ topic: w3, method: "wc_sessionSettle", params: T2, throwOnFailedPublish: true });
      const K3 = b$3(g$4({}, T2), { topic: w3, pairingTopic: a3, acknowledged: false, self: T2.controller, peer: { publicKey: c2.publicKey, metadata: c2.metadata }, controller: h5 });
      return await this.client.session.set(w3, K3), await this.setExpiry(w3, pt$1(A$4)), { topic: w3, acknowledged: () => new Promise((L3) => setTimeout(() => L3(this.client.session.get(w3)), 500)) };
    }, this.reject = async (e2) => {
      await this.isInitialized(), await this.isValidReject(e2);
      const { id: s3, reason: t2 } = e2, { pairingTopic: i3 } = this.client.proposal.get(s3);
      i3 && (await this.sendError(s3, i3, t2), await this.client.proposal.delete(s3, U$4("USER_DISCONNECTED")));
    }, this.update = async (e2) => {
      await this.isInitialized(), await this.isValidUpdate(e2);
      const { topic: s3, namespaces: t2 } = e2, i3 = await this.sendRequest({ topic: s3, method: "wc_sessionUpdate", params: { namespaces: t2 } }), { done: n4, resolve: o2, reject: a3 } = at$1();
      return this.events.once(yt$1("session_update", i3), ({ error: c2 }) => {
        c2 ? a3(c2) : o2();
      }), await this.client.session.update(s3, { namespaces: t2 }), { acknowledged: n4 };
    }, this.extend = async (e2) => {
      await this.isInitialized(), await this.isValidExtend(e2);
      const { topic: s3 } = e2, t2 = await this.sendRequest({ topic: s3, method: "wc_sessionExtend", params: {} }), { done: i3, resolve: n4, reject: o2 } = at$1();
      return this.events.once(yt$1("session_extend", t2), ({ error: a3 }) => {
        a3 ? o2(a3) : n4();
      }), await this.setExpiry(s3, pt$1(A$4)), { acknowledged: i3 };
    }, this.request = async (e2) => {
      await this.isInitialized(), await this.isValidRequest(e2);
      const { chainId: s3, request: t2, topic: i3, expiry: n4 } = e2, o2 = payloadId(), { done: a3, resolve: c2, reject: p3 } = at$1(n4, "Request expired. Please try again.");
      return this.events.once(yt$1("session_request", o2), ({ error: d3, result: h5 }) => {
        d3 ? p3(d3) : c2(h5);
      }), await Promise.all([new Promise(async (d3) => {
        await this.sendRequest({ clientRpcId: o2, topic: i3, method: "wc_sessionRequest", params: { request: t2, chainId: s3 }, expiry: n4, throwOnFailedPublish: true }).catch((h5) => p3(h5)), this.client.events.emit("session_request_sent", { topic: i3, request: t2, chainId: s3, id: o2 }), d3();
      }), new Promise(async (d3) => {
        const h5 = await gt$8(this.client.core.storage, W$7);
        ht$1({ id: o2, topic: i3, wcDeepLink: h5 }), d3();
      }), a3()]).then((d3) => d3[2]);
    }, this.respond = async (e2) => {
      await this.isInitialized(), await this.isValidRespond(e2);
      const { topic: s3, response: t2 } = e2, { id: i3 } = t2;
      isJsonRpcResult(t2) ? await this.sendResult({ id: i3, topic: s3, result: t2.result, throwOnFailedPublish: true }) : isJsonRpcError(t2) && await this.sendError(i3, s3, t2.error), this.cleanupAfterResponse(e2);
    }, this.ping = async (e2) => {
      await this.isInitialized(), await this.isValidPing(e2);
      const { topic: s3 } = e2;
      if (this.client.session.keys.includes(s3)) {
        const t2 = await this.sendRequest({ topic: s3, method: "wc_sessionPing", params: {} }), { done: i3, resolve: n4, reject: o2 } = at$1();
        this.events.once(yt$1("session_ping", t2), ({ error: a3 }) => {
          a3 ? o2(a3) : n4();
        }), await i3();
      } else
        this.client.core.pairing.pairings.keys.includes(s3) && await this.client.core.pairing.ping({ topic: s3 });
    }, this.emit = async (e2) => {
      await this.isInitialized(), await this.isValidEmit(e2);
      const { topic: s3, event: t2, chainId: i3 } = e2;
      await this.sendRequest({ topic: s3, method: "wc_sessionEvent", params: { event: t2, chainId: i3 } });
    }, this.disconnect = async (e2) => {
      await this.isInitialized(), await this.isValidDisconnect(e2);
      const { topic: s3 } = e2;
      this.client.session.keys.includes(s3) ? (await this.sendRequest({ topic: s3, method: "wc_sessionDelete", params: U$4("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession(s3)) : await this.client.core.pairing.disconnect({ topic: s3 });
    }, this.find = (e2) => (this.isInitialized(), this.client.session.getAll().filter((s3) => Dt$1(s3, e2))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (e2) => {
      if (e2.pairingTopic)
        try {
          const s3 = this.client.core.pairing.pairings.get(e2.pairingTopic), t2 = this.client.core.pairing.pairings.getAll().filter((i3) => {
            var n4, o2;
            return ((n4 = i3.peerMetadata) == null ? void 0 : n4.url) && ((o2 = i3.peerMetadata) == null ? void 0 : o2.url) === e2.peer.metadata.url && i3.topic && i3.topic !== s3.topic;
          });
          if (t2.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${t2.length} duplicate pairing(s)`), await Promise.all(t2.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (s3) {
          this.client.logger.error(s3);
        }
    }, this.deleteSession = async (e2, s3) => {
      const { self: t2 } = this.client.session.get(e2);
      await this.client.core.relayer.unsubscribe(e2), this.client.session.delete(e2, U$4("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(t2.publicKey) && await this.client.core.crypto.deleteKeyPair(t2.publicKey), this.client.core.crypto.keychain.has(e2) && await this.client.core.crypto.deleteSymKey(e2), s3 || this.client.core.expirer.del(e2), this.client.core.storage.removeItem(W$7).catch((i3) => this.client.logger.warn(i3)), this.getPendingSessionRequests().forEach((i3) => {
        i3.topic === e2 && this.deletePendingSessionRequest(i3.id, U$4("USER_DISCONNECTED"));
      });
    }, this.deleteProposal = async (e2, s3) => {
      await Promise.all([this.client.proposal.delete(e2, U$4("USER_DISCONNECTED")), s3 ? Promise.resolve() : this.client.core.expirer.del(e2)]);
    }, this.deletePendingSessionRequest = async (e2, s3, t2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e2, s3), t2 ? Promise.resolve() : this.client.core.expirer.del(e2)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e2), t2 && (this.sessionRequestQueue.state = I$3.idle);
    }, this.setExpiry = async (e2, s3) => {
      this.client.session.keys.includes(e2) && await this.client.session.update(e2, { expiry: s3 }), this.client.core.expirer.set(e2, s3);
    }, this.setProposal = async (e2, s3) => {
      await this.client.proposal.set(e2, s3), this.client.core.expirer.set(e2, s3.expiry);
    }, this.setPendingSessionRequest = async (e2) => {
      const s3 = V$2.wc_sessionRequest.req.ttl, { id: t2, topic: i3, params: n4, verifyContext: o2 } = e2;
      await this.client.pendingRequest.set(t2, { id: t2, topic: i3, params: n4, verifyContext: o2 }), s3 && this.client.core.expirer.set(t2, pt$1(s3));
    }, this.sendRequest = async (e2) => {
      const { topic: s3, method: t2, params: i3, expiry: n4, relayRpcId: o2, clientRpcId: a3, throwOnFailedPublish: c2 } = e2, p3 = formatJsonRpcRequest(t2, i3, a3);
      if (D$5() && pe$1.includes(t2)) {
        const R3 = Ln(JSON.stringify(p3));
        this.client.core.verify.register({ attestationId: R3 });
      }
      const d3 = await this.client.core.crypto.encode(s3, p3), h5 = V$2[t2].req;
      return n4 && (h5.ttl = n4), o2 && (h5.id = o2), this.client.core.history.set(s3, p3), c2 ? (h5.internal = b$3(g$4({}, h5.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s3, d3, h5)) : this.client.core.relayer.publish(s3, d3, h5).catch((R3) => this.client.logger.error(R3)), p3.id;
    }, this.sendResult = async (e2) => {
      const { id: s3, topic: t2, result: i3, throwOnFailedPublish: n4 } = e2, o2 = formatJsonRpcResult(s3, i3), a3 = await this.client.core.crypto.encode(t2, o2), c2 = await this.client.core.history.get(t2, s3), p3 = V$2[c2.request.method].res;
      n4 ? (p3.internal = b$3(g$4({}, p3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t2, a3, p3)) : this.client.core.relayer.publish(t2, a3, p3).catch((d3) => this.client.logger.error(d3)), await this.client.core.history.resolve(o2);
    }, this.sendError = async (e2, s3, t2) => {
      const i3 = formatJsonRpcError(e2, t2), n4 = await this.client.core.crypto.encode(s3, i3), o2 = await this.client.core.history.get(s3, e2), a3 = V$2[o2.request.method].res;
      this.client.core.relayer.publish(s3, n4, a3), await this.client.core.history.resolve(i3);
    }, this.cleanup = async () => {
      const e2 = [], s3 = [];
      this.client.session.getAll().forEach((t2) => {
        mt$1(t2.expiry) && e2.push(t2.topic);
      }), this.client.proposal.getAll().forEach((t2) => {
        mt$1(t2.expiry) && s3.push(t2.id);
      }), await Promise.all([...e2.map((t2) => this.deleteSession(t2)), ...s3.map((t2) => this.deleteProposal(t2))]);
    }, this.onRelayEventRequest = async (e2) => {
      this.requestQueue.queue.push(e2), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === I$3.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = I$3.active;
        const e2 = this.requestQueue.queue.shift();
        if (e2)
          try {
            this.processRequest(e2), await new Promise((s3) => setTimeout(s3, 300));
          } catch (s3) {
            this.client.logger.warn(s3);
          }
      }
      this.requestQueue.state = I$3.idle;
    }, this.processRequest = (e2) => {
      const { topic: s3, payload: t2 } = e2, i3 = t2.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(s3, t2);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(s3, t2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(s3, t2);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(s3, t2);
        case "wc_sessionPing":
          return this.onSessionPingRequest(s3, t2);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(s3, t2);
        case "wc_sessionRequest":
          return this.onSessionRequest(s3, t2);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(s3, t2);
        default:
          return this.client.logger.info(`Unsupported request method ${i3}`);
      }
    }, this.onRelayEventResponse = async (e2) => {
      const { topic: s3, payload: t2 } = e2, i3 = (await this.client.core.history.get(s3, t2.id)).request.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(s3, t2);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(s3, t2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(s3, t2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(s3, t2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(s3, t2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(s3, t2);
        default:
          return this.client.logger.info(`Unsupported response method ${i3}`);
      }
    }, this.onRelayEventUnknownPayload = (e2) => {
      const { topic: s3 } = e2, { message: t2 } = N$4("MISSING_OR_INVALID", `Decoded payload on topic ${s3} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(t2);
    }, this.onSessionProposeRequest = async (e2, s3) => {
      const { params: t2, id: i3 } = s3;
      try {
        this.isValidConnect(g$4({}, s3.params));
        const n4 = pt$1(cjs$d.FIVE_MINUTES), o2 = g$4({ id: i3, pairingTopic: e2, expiry: n4 }, t2);
        await this.setProposal(i3, o2);
        const a3 = Ln(JSON.stringify(s3)), c2 = await this.getVerifyContext(a3, o2.proposer.metadata);
        this.client.events.emit("session_proposal", { id: i3, params: o2, verifyContext: c2 });
      } catch (n4) {
        await this.sendError(i3, e2, n4), this.client.logger.error(n4);
      }
    }, this.onSessionProposeResponse = async (e2, s3) => {
      const { id: t2 } = s3;
      if (isJsonRpcResult(s3)) {
        const { result: i3 } = s3;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i3 });
        const n4 = this.client.proposal.get(t2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n4 });
        const o2 = n4.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o2 });
        const a3 = i3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a3 });
        const c2 = await this.client.core.crypto.generateSharedKey(o2, a3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: c2 });
        const p3 = await this.client.core.relayer.subscribe(c2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p3 }), await this.client.core.pairing.activate({ topic: e2 });
      } else
        isJsonRpcError(s3) && (await this.client.proposal.delete(t2, U$4("USER_DISCONNECTED")), this.events.emit(yt$1("session_connect"), { error: s3.error }));
    }, this.onSessionSettleRequest = async (e2, s3) => {
      const { id: t2, params: i3 } = s3;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: n4, controller: o2, expiry: a3, namespaces: c2, requiredNamespaces: p3, optionalNamespaces: d3, sessionProperties: h5, pairingTopic: R3 } = s3.params, w3 = g$4({ topic: e2, relay: n4, expiry: a3, namespaces: c2, acknowledged: true, pairingTopic: R3, requiredNamespaces: p3, optionalNamespaces: d3, controller: o2.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o2.publicKey, metadata: o2.metadata } }, h5 && { sessionProperties: h5 });
        await this.sendResult({ id: s3.id, topic: e2, result: true }), this.events.emit(yt$1("session_connect"), { session: w3 }), this.cleanupDuplicatePairings(w3);
      } catch (n4) {
        await this.sendError(t2, e2, n4), this.client.logger.error(n4);
      }
    }, this.onSessionSettleResponse = async (e2, s3) => {
      const { id: t2 } = s3;
      isJsonRpcResult(s3) ? (await this.client.session.update(e2, { acknowledged: true }), this.events.emit(yt$1("session_approve", t2), {})) : isJsonRpcError(s3) && (await this.client.session.delete(e2, U$4("USER_DISCONNECTED")), this.events.emit(yt$1("session_approve", t2), { error: s3.error }));
    }, this.onSessionUpdateRequest = async (e2, s3) => {
      const { params: t2, id: i3 } = s3;
      try {
        const n4 = `${e2}_session_update`, o2 = tr$1.get(n4);
        if (o2 && this.isRequestOutOfSync(o2, i3)) {
          this.client.logger.info(`Discarding out of sync request - ${i3}`);
          return;
        }
        this.isValidUpdate(g$4({ topic: e2 }, t2)), await this.client.session.update(e2, { namespaces: t2.namespaces }), await this.sendResult({ id: i3, topic: e2, result: true }), this.client.events.emit("session_update", { id: i3, topic: e2, params: t2 }), tr$1.set(n4, i3);
      } catch (n4) {
        await this.sendError(i3, e2, n4), this.client.logger.error(n4);
      }
    }, this.isRequestOutOfSync = (e2, s3) => parseInt(s3.toString().slice(0, -3)) <= parseInt(e2.toString().slice(0, -3)), this.onSessionUpdateResponse = (e2, s3) => {
      const { id: t2 } = s3;
      isJsonRpcResult(s3) ? this.events.emit(yt$1("session_update", t2), {}) : isJsonRpcError(s3) && this.events.emit(yt$1("session_update", t2), { error: s3.error });
    }, this.onSessionExtendRequest = async (e2, s3) => {
      const { id: t2 } = s3;
      try {
        this.isValidExtend({ topic: e2 }), await this.setExpiry(e2, pt$1(A$4)), await this.sendResult({ id: t2, topic: e2, result: true }), this.client.events.emit("session_extend", { id: t2, topic: e2 });
      } catch (i3) {
        await this.sendError(t2, e2, i3), this.client.logger.error(i3);
      }
    }, this.onSessionExtendResponse = (e2, s3) => {
      const { id: t2 } = s3;
      isJsonRpcResult(s3) ? this.events.emit(yt$1("session_extend", t2), {}) : isJsonRpcError(s3) && this.events.emit(yt$1("session_extend", t2), { error: s3.error });
    }, this.onSessionPingRequest = async (e2, s3) => {
      const { id: t2 } = s3;
      try {
        this.isValidPing({ topic: e2 }), await this.sendResult({ id: t2, topic: e2, result: true }), this.client.events.emit("session_ping", { id: t2, topic: e2 });
      } catch (i3) {
        await this.sendError(t2, e2, i3), this.client.logger.error(i3);
      }
    }, this.onSessionPingResponse = (e2, s3) => {
      const { id: t2 } = s3;
      setTimeout(() => {
        isJsonRpcResult(s3) ? this.events.emit(yt$1("session_ping", t2), {}) : isJsonRpcError(s3) && this.events.emit(yt$1("session_ping", t2), { error: s3.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e2, s3) => {
      const { id: t2 } = s3;
      try {
        this.isValidDisconnect({ topic: e2, reason: s3.params }), await Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(D$4.publish, async () => {
            i3(await this.deleteSession(e2));
          });
        }), this.sendResult({ id: t2, topic: e2, result: true })]), this.client.events.emit("session_delete", { id: t2, topic: e2 });
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }, this.onSessionRequest = async (e2, s3) => {
      const { id: t2, params: i3 } = s3;
      try {
        this.isValidRequest(g$4({ topic: e2 }, i3));
        const n4 = Ln(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", i3, t2))), o2 = this.client.session.get(e2), a3 = await this.getVerifyContext(n4, o2.peer.metadata), c2 = { id: t2, topic: e2, params: i3, verifyContext: a3 };
        await this.setPendingSessionRequest(c2), this.addSessionRequestToSessionRequestQueue(c2), this.processSessionRequestQueue();
      } catch (n4) {
        await this.sendError(t2, e2, n4), this.client.logger.error(n4);
      }
    }, this.onSessionRequestResponse = (e2, s3) => {
      const { id: t2 } = s3;
      isJsonRpcResult(s3) ? this.events.emit(yt$1("session_request", t2), { result: s3.result }) : isJsonRpcError(s3) && this.events.emit(yt$1("session_request", t2), { error: s3.error });
    }, this.onSessionEventRequest = async (e2, s3) => {
      const { id: t2, params: i3 } = s3;
      try {
        const n4 = `${e2}_session_event_${i3.event.name}`, o2 = tr$1.get(n4);
        if (o2 && this.isRequestOutOfSync(o2, t2)) {
          this.client.logger.info(`Discarding out of sync request - ${t2}`);
          return;
        }
        this.isValidEmit(g$4({ topic: e2 }, i3)), this.client.events.emit("session_event", { id: t2, topic: e2, params: i3 }), tr$1.set(n4, t2);
      } catch (n4) {
        await this.sendError(t2, e2, n4), this.client.logger.error(n4);
      }
    }, this.addSessionRequestToSessionRequestQueue = (e2) => {
      this.sessionRequestQueue.queue.push(e2);
    }, this.cleanupAfterResponse = (e2) => {
      this.deletePendingSessionRequest(e2.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = I$3.idle, this.processSessionRequestQueue();
      }, cjs$d.toMiliseconds(this.requestQueueDelay));
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === I$3.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e2 = this.sessionRequestQueue.queue[0];
      if (!e2) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = I$3.active, this.client.events.emit("session_request", e2);
      } catch (s3) {
        this.client.logger.error(s3);
      }
    }, this.onPairingCreated = (e2) => {
      if (e2.active)
        return;
      const s3 = this.client.proposal.getAll().find((t2) => t2.pairingTopic === e2.topic);
      s3 && this.onSessionProposeRequest(e2.topic, formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: s3.requiredNamespaces, optionalNamespaces: s3.optionalNamespaces, relays: s3.relays, proposer: s3.proposer, sessionProperties: s3.sessionProperties }, s3.id));
    }, this.isValidConnect = async (e2) => {
      if (!Ht$1(e2)) {
        const { message: a3 } = N$4("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e2)}`);
        throw new Error(a3);
      }
      const { pairingTopic: s3, requiredNamespaces: t2, optionalNamespaces: i3, sessionProperties: n4, relays: o2 } = e2;
      if (w$4(s3) || await this.isValidPairingTopic(s3), !xt$1(o2, true)) {
        const { message: a3 } = N$4("MISSING_OR_INVALID", `connect() relays: ${o2}`);
        throw new Error(a3);
      }
      !w$4(t2) && B$6(t2) !== 0 && this.validateNamespaces(t2, "requiredNamespaces"), !w$4(i3) && B$6(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), w$4(n4) || this.validateSessionProps(n4, "sessionProperties");
    }, this.validateNamespaces = (e2, s3) => {
      const t2 = Lt$1(e2, "connect()", s3);
      if (t2)
        throw new Error(t2.message);
    }, this.isValidApprove = async (e2) => {
      if (!Ht$1(e2))
        throw new Error(N$4("MISSING_OR_INVALID", `approve() params: ${e2}`).message);
      const { id: s3, namespaces: t2, relayProtocol: i3, sessionProperties: n4 } = e2;
      await this.isValidProposalId(s3);
      const o2 = this.client.proposal.get(s3), a3 = ln(t2, "approve()");
      if (a3)
        throw new Error(a3.message);
      const c2 = fn(o2.requiredNamespaces, t2, "approve()");
      if (c2)
        throw new Error(c2.message);
      if (!h$4(i3, true)) {
        const { message: p3 } = N$4("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(p3);
      }
      w$4(n4) || this.validateSessionProps(n4, "sessionProperties");
    }, this.isValidReject = async (e2) => {
      if (!Ht$1(e2)) {
        const { message: i3 } = N$4("MISSING_OR_INVALID", `reject() params: ${e2}`);
        throw new Error(i3);
      }
      const { id: s3, reason: t2 } = e2;
      if (await this.isValidProposalId(s3), !qt$1(t2)) {
        const { message: i3 } = N$4("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t2)}`);
        throw new Error(i3);
      }
    }, this.isValidSessionSettleRequest = (e2) => {
      if (!Ht$1(e2)) {
        const { message: c2 } = N$4("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e2}`);
        throw new Error(c2);
      }
      const { relay: s3, controller: t2, namespaces: i3, expiry: n4 } = e2;
      if (!dn(s3)) {
        const { message: c2 } = N$4("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c2);
      }
      const o2 = Kt$1(t2, "onSessionSettleRequest()");
      if (o2)
        throw new Error(o2.message);
      const a3 = ln(i3, "onSessionSettleRequest()");
      if (a3)
        throw new Error(a3.message);
      if (mt$1(n4)) {
        const { message: c2 } = N$4("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c2);
      }
    }, this.isValidUpdate = async (e2) => {
      if (!Ht$1(e2)) {
        const { message: a3 } = N$4("MISSING_OR_INVALID", `update() params: ${e2}`);
        throw new Error(a3);
      }
      const { topic: s3, namespaces: t2 } = e2;
      await this.isValidSessionTopic(s3);
      const i3 = this.client.session.get(s3), n4 = ln(t2, "update()");
      if (n4)
        throw new Error(n4.message);
      const o2 = fn(i3.requiredNamespaces, t2, "update()");
      if (o2)
        throw new Error(o2.message);
    }, this.isValidExtend = async (e2) => {
      if (!Ht$1(e2)) {
        const { message: t2 } = N$4("MISSING_OR_INVALID", `extend() params: ${e2}`);
        throw new Error(t2);
      }
      const { topic: s3 } = e2;
      await this.isValidSessionTopic(s3);
    }, this.isValidRequest = async (e2) => {
      if (!Ht$1(e2)) {
        const { message: a3 } = N$4("MISSING_OR_INVALID", `request() params: ${e2}`);
        throw new Error(a3);
      }
      const { topic: s3, request: t2, chainId: i3, expiry: n4 } = e2;
      await this.isValidSessionTopic(s3);
      const { namespaces: o2 } = this.client.session.get(s3);
      if (!zt$1(o2, i3)) {
        const { message: a3 } = N$4("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a3);
      }
      if (!Bt$1(t2)) {
        const { message: a3 } = N$4("MISSING_OR_INVALID", `request() ${JSON.stringify(t2)}`);
        throw new Error(a3);
      }
      if (!Yt$1(o2, i3, t2.method)) {
        const { message: a3 } = N$4("MISSING_OR_INVALID", `request() method: ${t2.method}`);
        throw new Error(a3);
      }
      if (n4 && !Xt(n4, U$3)) {
        const { message: a3 } = N$4("MISSING_OR_INVALID", `request() expiry: ${n4}. Expiry must be a number (in seconds) between ${U$3.min} and ${U$3.max}`);
        throw new Error(a3);
      }
    }, this.isValidRespond = async (e2) => {
      var s3;
      if (!Ht$1(e2)) {
        const { message: n4 } = N$4("MISSING_OR_INVALID", `respond() params: ${e2}`);
        throw new Error(n4);
      }
      const { topic: t2, response: i3 } = e2;
      try {
        await this.isValidSessionTopic(t2);
      } catch (n4) {
        throw (s3 = e2?.response) != null && s3.id && this.cleanupAfterResponse(e2), n4;
      }
      if (!Gt$1(i3)) {
        const { message: n4 } = N$4("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(n4);
      }
    }, this.isValidPing = async (e2) => {
      if (!Ht$1(e2)) {
        const { message: t2 } = N$4("MISSING_OR_INVALID", `ping() params: ${e2}`);
        throw new Error(t2);
      }
      const { topic: s3 } = e2;
      await this.isValidSessionOrPairingTopic(s3);
    }, this.isValidEmit = async (e2) => {
      if (!Ht$1(e2)) {
        const { message: o2 } = N$4("MISSING_OR_INVALID", `emit() params: ${e2}`);
        throw new Error(o2);
      }
      const { topic: s3, event: t2, chainId: i3 } = e2;
      await this.isValidSessionTopic(s3);
      const { namespaces: n4 } = this.client.session.get(s3);
      if (!zt$1(n4, i3)) {
        const { message: o2 } = N$4("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(o2);
      }
      if (!Wt(t2)) {
        const { message: o2 } = N$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t2)}`);
        throw new Error(o2);
      }
      if (!Jt$1(n4, i3, t2.name)) {
        const { message: o2 } = N$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t2)}`);
        throw new Error(o2);
      }
    }, this.isValidDisconnect = async (e2) => {
      if (!Ht$1(e2)) {
        const { message: t2 } = N$4("MISSING_OR_INVALID", `disconnect() params: ${e2}`);
        throw new Error(t2);
      }
      const { topic: s3 } = e2;
      await this.isValidSessionOrPairingTopic(s3);
    }, this.getVerifyContext = async (e2, s3) => {
      const t2 = { verified: { verifyUrl: s3.verifyUrl || $$2, validation: "UNKNOWN", origin: s3.url || "" } };
      try {
        const i3 = await this.client.core.verify.resolve({ attestationId: e2, verifyUrl: s3.verifyUrl });
        i3 && (t2.verified.origin = i3.origin, t2.verified.isScam = i3.isScam, t2.verified.validation = i3.origin === new URL(s3.url).origin ? "VALID" : "INVALID");
      } catch (i3) {
        this.client.logger.info(i3);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(t2)}`), t2;
    }, this.validateSessionProps = (e2, s3) => {
      Object.values(e2).forEach((t2) => {
        if (!h$4(t2, false)) {
          const { message: i3 } = N$4("MISSING_OR_INVALID", `${s3} must be in Record<string, string> format. Received: ${JSON.stringify(t2)}`);
          throw new Error(i3);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: r2 } = N$4("NOT_INITIALIZED", this.name);
      throw new Error(r2);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D$4.message, async (r2) => {
      const { topic: e2, message: s3 } = r2;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s3)))
        return;
      const t2 = await this.client.core.crypto.decode(e2, s3);
      try {
        isJsonRpcRequest(t2) ? (this.client.core.history.set(e2, t2), this.onRelayEventRequest({ topic: e2, payload: t2 })) : isJsonRpcResponse(t2) ? (await this.client.core.history.resolve(t2), await this.onRelayEventResponse({ topic: e2, payload: t2 }), this.client.core.history.delete(e2, t2.id)) : this.onRelayEventUnknownPayload({ topic: e2, payload: t2 });
      } catch (i3) {
        this.client.logger.error(i3);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(v$5.expired, async (r2) => {
      const { topic: e2, id: s3 } = ft$4(r2.target);
      if (s3 && this.client.pendingRequest.keys.includes(s3))
        return await this.deletePendingSessionRequest(s3, N$4("EXPIRED"), true);
      e2 ? this.client.session.keys.includes(e2) && (await this.deleteSession(e2, true), this.client.events.emit("session_expire", { topic: e2 })) : s3 && (await this.deleteProposal(s3, true), this.client.events.emit("proposal_expire", { id: s3 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V$3.create, (r2) => this.onPairingCreated(r2));
  }
  isValidPairingTopic(r2) {
    if (!h$4(r2, false)) {
      const { message: e2 } = N$4("MISSING_OR_INVALID", `pairing topic should be a string: ${r2}`);
      throw new Error(e2);
    }
    if (!this.client.core.pairing.pairings.keys.includes(r2)) {
      const { message: e2 } = N$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r2}`);
      throw new Error(e2);
    }
    if (mt$1(this.client.core.pairing.pairings.get(r2).expiry)) {
      const { message: e2 } = N$4("EXPIRED", `pairing topic: ${r2}`);
      throw new Error(e2);
    }
  }
  async isValidSessionTopic(r2) {
    if (!h$4(r2, false)) {
      const { message: e2 } = N$4("MISSING_OR_INVALID", `session topic should be a string: ${r2}`);
      throw new Error(e2);
    }
    if (!this.client.session.keys.includes(r2)) {
      const { message: e2 } = N$4("NO_MATCHING_KEY", `session topic doesn't exist: ${r2}`);
      throw new Error(e2);
    }
    if (mt$1(this.client.session.get(r2).expiry)) {
      await this.deleteSession(r2);
      const { message: e2 } = N$4("EXPIRED", `session topic: ${r2}`);
      throw new Error(e2);
    }
  }
  async isValidSessionOrPairingTopic(r2) {
    if (this.client.session.keys.includes(r2))
      await this.isValidSessionTopic(r2);
    else if (this.client.core.pairing.pairings.keys.includes(r2))
      this.isValidPairingTopic(r2);
    else if (h$4(r2, false)) {
      const { message: e2 } = N$4("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r2}`);
      throw new Error(e2);
    } else {
      const { message: e2 } = N$4("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r2}`);
      throw new Error(e2);
    }
  }
  async isValidProposalId(r2) {
    if (!Ft$1(r2)) {
      const { message: e2 } = N$4("MISSING_OR_INVALID", `proposal id should be a number: ${r2}`);
      throw new Error(e2);
    }
    if (!this.client.proposal.keys.includes(r2)) {
      const { message: e2 } = N$4("NO_MATCHING_KEY", `proposal id doesn't exist: ${r2}`);
      throw new Error(e2);
    }
    if (mt$1(this.client.proposal.get(r2).expiry)) {
      await this.deleteProposal(r2);
      const { message: e2 } = N$4("EXPIRED", `proposal id: ${r2}`);
      throw new Error(e2);
    }
  }
}
class us extends Kt {
  constructor(r2, e2) {
    super(r2, e2, ne$1, G$1), this.core = r2, this.logger = e2;
  }
}
let ue$1 = class ue2 extends Kt {
  constructor(r2, e2) {
    super(r2, e2, ae$1, G$1), this.core = r2, this.logger = e2;
  }
};
class gs extends Kt {
  constructor(r2, e2) {
    super(r2, e2, le$1, G$1, (s3) => s3.id), this.core = r2, this.logger = e2;
  }
}
let Q$3 = class Q2 extends b$5 {
  constructor(r2) {
    super(r2), this.protocol = X$1, this.version = F$3, this.name = M$4.name, this.events = new eventsExports.EventEmitter(), this.on = (s3, t2) => this.events.on(s3, t2), this.once = (s3, t2) => this.events.once(s3, t2), this.off = (s3, t2) => this.events.off(s3, t2), this.removeListener = (s3, t2) => this.events.removeListener(s3, t2), this.removeAllListeners = (s3) => this.events.removeAllListeners(s3), this.connect = async (s3) => {
      try {
        return await this.engine.connect(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.pair = async (s3) => {
      try {
        return await this.engine.pair(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.approve = async (s3) => {
      try {
        return await this.engine.approve(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.reject = async (s3) => {
      try {
        return await this.engine.reject(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.update = async (s3) => {
      try {
        return await this.engine.update(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.extend = async (s3) => {
      try {
        return await this.engine.extend(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.request = async (s3) => {
      try {
        return await this.engine.request(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.respond = async (s3) => {
      try {
        return await this.engine.respond(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.ping = async (s3) => {
      try {
        return await this.engine.ping(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.emit = async (s3) => {
      try {
        return await this.engine.emit(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.disconnect = async (s3) => {
      try {
        return await this.engine.disconnect(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.find = (s3) => {
      try {
        return this.engine.find(s3);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }, this.name = r2?.name || M$4.name, this.metadata = r2?.metadata || Qn();
    const e2 = typeof r2?.logger < "u" && typeof r2?.logger != "string" ? r2.logger : cjs$7.pino(cjs$7.getDefaultLoggerOptions({ level: r2?.logger || M$4.logger }));
    this.core = r2?.core || new Mr(r2), this.logger = cjs$7.generateChildLogger(e2, this.name), this.session = new ue$1(this.core, this.logger), this.proposal = new us(this.core, this.logger), this.pendingRequest = new gs(this.core, this.logger), this.engine = new ds(this);
  }
  static async init(r2) {
    const e2 = new Q2(r2);
    return await e2.initialize(), e2;
  }
  get context() {
    return cjs$7.getLoggerContext(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (r2) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r2.message), r2;
    }
  }
};
var cjs$2 = {};
Object.defineProperty(cjs$2, "__esModule", { value: true });
var getLocalStorage_1 = cjs$2.getLocalStorage = getLocalStorageOrThrow_1 = cjs$2.getLocalStorageOrThrow = getCrypto_1 = cjs$2.getCrypto = getCryptoOrThrow_1 = cjs$2.getCryptoOrThrow = getLocation_1 = cjs$2.getLocation = getLocationOrThrow_1 = cjs$2.getLocationOrThrow = getNavigator_1 = cjs$2.getNavigator = getNavigatorOrThrow_1 = cjs$2.getNavigatorOrThrow = getDocument_1 = cjs$2.getDocument = getDocumentOrThrow_1 = cjs$2.getDocumentOrThrow = getFromWindowOrThrow_1 = cjs$2.getFromWindowOrThrow = getFromWindow_1 = cjs$2.getFromWindow = void 0;
function getFromWindow(name2) {
  let res = void 0;
  if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
    res = window[name2];
  }
  return res;
}
var getFromWindow_1 = cjs$2.getFromWindow = getFromWindow;
function getFromWindowOrThrow(name2) {
  const res = getFromWindow(name2);
  if (!res) {
    throw new Error(`${name2} is not defined in Window`);
  }
  return res;
}
var getFromWindowOrThrow_1 = cjs$2.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
var getDocumentOrThrow_1 = cjs$2.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
var getDocument_1 = cjs$2.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
var getNavigatorOrThrow_1 = cjs$2.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
var getNavigator_1 = cjs$2.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
var getLocationOrThrow_1 = cjs$2.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
var getLocation_1 = cjs$2.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
var getCryptoOrThrow_1 = cjs$2.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
var getCrypto_1 = cjs$2.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
var getLocalStorageOrThrow_1 = cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
getLocalStorage_1 = cjs$2.getLocalStorage = getLocalStorage;
const cjs$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: cjs$2,
  get getCrypto() {
    return getCrypto_1;
  },
  get getCryptoOrThrow() {
    return getCryptoOrThrow_1;
  },
  get getDocument() {
    return getDocument_1;
  },
  get getDocumentOrThrow() {
    return getDocumentOrThrow_1;
  },
  get getFromWindow() {
    return getFromWindow_1;
  },
  get getFromWindowOrThrow() {
    return getFromWindowOrThrow_1;
  },
  get getLocalStorage() {
    return getLocalStorage_1;
  },
  get getLocalStorageOrThrow() {
    return getLocalStorageOrThrow_1;
  },
  get getLocation() {
    return getLocation_1;
  },
  get getLocationOrThrow() {
    return getLocationOrThrow_1;
  },
  get getNavigator() {
    return getNavigator_1;
  },
  get getNavigatorOrThrow() {
    return getNavigatorOrThrow_1;
  }
}, [cjs$2]);
var cjs = {};
const require$$0$16 = /* @__PURE__ */ getAugmentedNamespace(cjs$1);
Object.defineProperty(cjs, "__esModule", { value: true });
cjs.getWindowMetadata = void 0;
const window_getters_1 = require$$0$16;
function getWindowMetadata() {
  let doc;
  let loc;
  try {
    doc = window_getters_1.getDocumentOrThrow();
    loc = window_getters_1.getLocationOrThrow();
  } catch (e2) {
    return null;
  }
  function getIcons() {
    const links2 = doc.getElementsByTagName("link");
    const icons2 = [];
    for (let i3 = 0; i3 < links2.length; i3++) {
      const link = links2[i3];
      const rel = link.getAttribute("rel");
      if (rel) {
        if (rel.toLowerCase().indexOf("icon") > -1) {
          const href = link.getAttribute("href");
          if (href) {
            if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
              let absoluteHref = loc.protocol + "//" + loc.host;
              if (href.indexOf("/") === 0) {
                absoluteHref += href;
              } else {
                const path = loc.pathname.split("/");
                path.pop();
                const finalPath = path.join("/");
                absoluteHref += finalPath + "/" + href;
              }
              icons2.push(absoluteHref);
            } else if (href.indexOf("//") === 0) {
              const absoluteUrl = loc.protocol + href;
              icons2.push(absoluteUrl);
            } else {
              icons2.push(href);
            }
          }
        }
      }
    }
    return icons2;
  }
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc.getElementsByTagName("meta");
    for (let i3 = 0; i3 < metaTags.length; i3++) {
      const tag = metaTags[i3];
      const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
        if (attr) {
          return args.includes(attr);
        }
        return false;
      });
      if (attributes.length && attributes) {
        const content = tag.getAttribute("content");
        if (content) {
          return content;
        }
      }
    }
    return "";
  }
  function getName() {
    let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    if (!name3) {
      name3 = doc.title;
    }
    return name3;
  }
  function getDescription() {
    const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
    return description2;
  }
  const name2 = getName();
  const description = getDescription();
  const url = loc.origin;
  const icons = getIcons();
  const meta = {
    description,
    url,
    icons,
    name: name2
  };
  return meta;
}
cjs.getWindowMetadata = getWindowMetadata;
var queryString = {};
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components, split) {
  try {
    return [decodeURIComponent(components.join(""))];
  } catch (err) {
  }
  if (components.length === 1) {
    return components;
  }
  split = split || 1;
  var left = components.slice(0, split);
  var right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode$a(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher) || [];
    for (var i3 = 1; i3 < tokens.length; i3++) {
      input = decodeComponents(tokens, i3).join("");
      tokens = input.match(singleMatcher) || [];
    }
    return input;
  }
}
function customDecodeURIComponent(input) {
  var replaceMap = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  };
  var match = multiMatcher.exec(input);
  while (match) {
    try {
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode$a(match[0]);
      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }
    match = multiMatcher.exec(input);
  }
  replaceMap["%C2"] = "�";
  var entries2 = Object.keys(replaceMap);
  for (var i3 = 0; i3 < entries2.length; i3++) {
    var key2 = entries2[i3];
    input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
  }
  return input;
}
var decodeUriComponent = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent(encodedURI);
  }
};
const index$E = /* @__PURE__ */ getDefaultExportFromCjs(decodeUriComponent);
const decodeUriComponent$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$E
}, [decodeUriComponent]);
const require$$1$D = /* @__PURE__ */ getAugmentedNamespace(decodeUriComponent$1);
(function(exports2) {
  const strictUriEncode2 = require$$0$1c;
  const decodeComponent = require$$1$D;
  const splitOnFirst2 = require$$2$q;
  const filterObject = require$$3$h;
  const isNullOrUndefined = (value) => value === null || value === void 0;
  const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case "index":
        return (key2) => (result, value) => {
          const index2 = result.length;
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode5(key2, options), "[", index2, "]"].join("")];
          }
          return [
            ...result,
            [encode5(key2, options), "[", encode5(index2, options), "]=", encode5(value, options)].join("")
          ];
        };
      case "bracket":
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode5(key2, options), "[]"].join("")];
          }
          return [...result, [encode5(key2, options), "[]=", encode5(value, options)].join("")];
        };
      case "colon-list-separator":
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode5(key2, options), ":list="].join("")];
          }
          return [...result, [encode5(key2, options), ":list=", encode5(value, options)].join("")];
        };
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          value = value === null ? "" : value;
          if (result.length === 0) {
            return [[encode5(key2, options), keyValueSep, encode5(value, options)].join("")];
          }
          return [[result, encode5(value, options)].join(options.arrayFormatSeparator)];
        };
      }
      default:
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, encode5(key2, options)];
          }
          return [...result, [encode5(key2, options), "=", encode5(value, options)].join("")];
        };
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case "index":
        return (key2, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key2);
          key2 = key2.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = {};
          }
          accumulator[key2][result[1]] = value;
        };
      case "bracket":
        return (key2, value, accumulator) => {
          result = /(\[\])$/.exec(key2);
          key2 = key2.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = [value];
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
      case "colon-list-separator":
        return (key2, value, accumulator) => {
          result = /(:list)$/.exec(key2);
          key2 = key2.replace(/:list$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = [value];
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
      case "comma":
      case "separator":
        return (key2, value, accumulator) => {
          const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
          accumulator[key2] = newValue;
        };
      case "bracket-separator":
        return (key2, value, accumulator) => {
          const isArray2 = /(\[\])$/.test(key2);
          key2 = key2.replace(/\[\]$/, "");
          if (!isArray2) {
            accumulator[key2] = value ? decode2(value, options) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
          if (accumulator[key2] === void 0) {
            accumulator[key2] = arrayValue;
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], arrayValue);
        };
      default:
        return (key2, value, accumulator) => {
          if (accumulator[key2] === void 0) {
            accumulator[key2] = value;
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode5(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode2(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a3, b4) => Number(a3) - Number(b4)).map((key2) => input[key2]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash2 = url.slice(hashStart);
    }
    return hash2;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function parse2(query2, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);
    const ret = /* @__PURE__ */ Object.create(null);
    if (typeof query2 !== "string") {
      return ret;
    }
    query2 = query2.trim().replace(/^[?#&]/, "");
    if (!query2) {
      return ret;
    }
    for (const param of query2.split("&")) {
      if (param === "") {
        continue;
      }
      let [key2, value] = splitOnFirst2(options.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
      formatter(decode2(key2, options), value, ret);
    }
    for (const key2 of Object.keys(ret)) {
      const value = ret[key2];
      if (typeof value === "object" && value !== null) {
        for (const k3 of Object.keys(value)) {
          value[k3] = parseValue(value[k3], options);
        }
      } else {
        ret[key2] = parseValue(value, options);
      }
    }
    if (options.sort === false) {
      return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
      const value = ret[key2];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key2] = keysSorter(value);
      } else {
        result[key2] = value;
      }
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  exports2.extract = extract;
  exports2.parse = parse2;
  exports2.stringify = (object2, options) => {
    if (!object2) {
      return "";
    }
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object2[key2]) || options.skipEmptyString && object2[key2] === "";
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key2 of Object.keys(object2)) {
      if (!shouldFilter(key2)) {
        objectCopy[key2] = object2[key2];
      }
    }
    const keys2 = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys2.sort(options.sort);
    }
    return keys2.map((key2) => {
      const value = object2[key2];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode5(key2, options);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === "bracket-separator") {
          return encode5(key2, options) + "[]";
        }
        return value.reduce(formatter(key2), []).join("&");
      }
      return encode5(key2, options) + "=" + encode5(value, options);
    }).filter((x2) => x2.length > 0).join("&");
  };
  exports2.parseUrl = (url, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url_, hash2] = splitOnFirst2(url, "#");
    return Object.assign(
      {
        url: url_.split("?")[0] || "",
        query: parse2(extract(url), options)
      },
      options && options.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options) } : {}
    );
  };
  exports2.stringifyUrl = (object2, options) => {
    options = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options);
    const url = removeHash(object2.url).split("?")[0] || "";
    const queryFromUrl = exports2.extract(object2.url);
    const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
    const query2 = Object.assign(parsedQueryFromUrl, object2.query);
    let queryString2 = exports2.stringify(query2, options);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash2 = getHash(object2.url);
    if (object2.fragmentIdentifier) {
      hash2 = `#${options[encodeFragmentIdentifier] ? encode5(object2.fragmentIdentifier, options) : object2.fragmentIdentifier}`;
    }
    return `${url}${queryString2}${hash2}`;
  };
  exports2.pick = (input, filter2, options) => {
    options = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options);
    const { url, query: query2, fragmentIdentifier } = exports2.parseUrl(input, options);
    return exports2.stringifyUrl({
      url,
      query: filterObject(query2, filter2),
      fragmentIdentifier
    }, options);
  };
  exports2.exclude = (input, filter2, options) => {
    const exclusionFilter = Array.isArray(filter2) ? (key2) => !filter2.includes(key2) : (key2, value) => !filter2(key2, value);
    return exports2.pick(input, exclusionFilter, options);
  };
})(queryString);
const K$5 = ":";
function ve$1(e2) {
  const [n4, t2] = e2.split(K$5);
  return { namespace: n4, reference: t2 };
}
function S$4(e2 = [], n4 = []) {
  return [.../* @__PURE__ */ new Set([...e2, ...n4])];
}
function oe$1(e2) {
  return e2.includes(":");
}
function en(e2) {
  return oe$1(e2) ? e2.split(":")[0] : e2;
}
const nn = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
function U$2(e2, n4) {
  const { message: t2, code: r2 } = nn[e2];
  return { message: n4 ? `${t2} ${n4}` : t2, code: r2 };
}
function k$3(e2, n4) {
  return Array.isArray(e2) ? typeof n4 < "u" && e2.length ? e2.every(n4) : true : false;
}
function B$4(e2) {
  return Object.getPrototypeOf(e2) === Object.prototype && Object.keys(e2).length;
}
var browserPonyfill = { exports: {} };
(function(module2, exports2) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F2() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F2.prototype = global2;
    return new F2();
  }();
  (function(self2) {
    (function(exports3) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e2) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name2) {
        if (typeof name2 !== "string") {
          name2 = String(name2);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name2.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator2 = {
          next: function() {
            var value = items.shift();
            return { done: value === void 0, value };
          }
        };
        if (support.iterable) {
          iterator2[Symbol.iterator] = function() {
            return iterator2;
          };
        }
        return iterator2;
      }
      function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
          headers.forEach(function(value, name2) {
            this.append(name2, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name2) {
            this.append(name2, headers[name2]);
          }, this);
        }
      }
      Headers.prototype.append = function(name2, value) {
        name2 = normalizeName(name2);
        value = normalizeValue(value);
        var oldValue = this.map[name2];
        this.map[name2] = oldValue ? oldValue + ", " + value : value;
      };
      Headers.prototype["delete"] = function(name2) {
        delete this.map[normalizeName(name2)];
      };
      Headers.prototype.get = function(name2) {
        name2 = normalizeName(name2);
        return this.has(name2) ? this.map[name2] : null;
      };
      Headers.prototype.has = function(name2) {
        return this.map.hasOwnProperty(normalizeName(name2));
      };
      Headers.prototype.set = function(name2, value) {
        this.map[normalizeName(name2)] = normalizeValue(value);
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name2 in this.map) {
          if (this.map.hasOwnProperty(name2)) {
            callback.call(thisArg, this.map[name2], name2, this);
          }
        }
      };
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name2) {
          items.push(name2);
        });
        return iteratorFor(items);
      };
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name2) {
          items.push([name2, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader2) {
        return new Promise(function(resolve, reject) {
          reader2.onload = function() {
            resolve(reader2.result);
          };
          reader2.onerror = function() {
            reject(reader2.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader2 = new FileReader();
        var promise = fileReaderReady(reader2);
        reader2.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader2 = new FileReader();
        var promise = fileReaderReady(reader2);
        reader2.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf2) {
        var view = new Uint8Array(buf2);
        var chars = new Array(view.length);
        for (var i3 = 0; i3 < view.length; i3++) {
          chars[i3] = String.fromCharCode(view[i3]);
        }
        return chars.join("");
      }
      function bufferClone(buf2) {
        if (buf2.slice) {
          return buf2.slice(0);
        } else {
          var view = new Uint8Array(buf2.byteLength);
          view.set(new Uint8Array(buf2));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode2);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode2(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes2) {
          if (bytes2) {
            var split = bytes2.split("=");
            var name2 = split.shift().replace(/\+/g, " ");
            var value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name2), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key2 = parts.shift().trim();
          if (key2) {
            var value = parts.join(":").trim();
            headers.append(key2, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response2(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response2.prototype);
      Response2.prototype.clone = function() {
        return new Response2(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response2.error = function() {
        var response = new Response2(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response2.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response2(null, { status, headers: { location: url } });
      };
      exports3.DOMException = self2.DOMException;
      try {
        new exports3.DOMException();
      } catch (err) {
        exports3.DOMException = function(message, name2) {
          this.message = message;
          this.name = name2;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports3.DOMException.prototype = Object.create(Error.prototype);
        exports3.DOMException.prototype.constructor = exports3.DOMException;
      }
      function fetch2(input, init3) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init3);
          if (request.signal && request.signal.aborted) {
            return reject(new exports3.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response2(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports3.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name2) {
            xhr.setRequestHeader(name2, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers;
        self2.Request = Request;
        self2.Response = Response2;
      }
      exports3.Headers = Headers;
      exports3.Request = Request;
      exports3.Response = Response2;
      exports3.fetch = fetch2;
      Object.defineProperty(exports3, "__esModule", { value: true });
      return exports3;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports2 = ctx.fetch;
  exports2.default = ctx.fetch;
  exports2.fetch = ctx.fetch;
  exports2.Headers = ctx.Headers;
  exports2.Request = ctx.Request;
  exports2.Response = ctx.Response;
  module2.exports = exports2;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports;
const fetch$2 = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfillExports);
const DEFAULT_HTTP_HEADERS = {
  Accept: "application/json",
  "Content-Type": "application/json"
};
const DEFAULT_HTTP_METHOD = "POST";
const DEFAULT_FETCH_OPTS = {
  headers: DEFAULT_HTTP_HEADERS,
  method: DEFAULT_HTTP_METHOD
};
const EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
class HttpConnection {
  constructor(url, disableProviderPing = false) {
    this.url = url;
    this.disableProviderPing = disableProviderPing;
    this.events = new eventsExports.EventEmitter();
    this.isAvailable = false;
    this.registering = false;
    if (!isHttpUrl(url)) {
      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
    }
    this.url = url;
    this.disableProviderPing = disableProviderPing;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(url = this.url) {
    await this.register(url);
  }
  async close() {
    if (!this.isAvailable) {
      throw new Error("Connection already closed");
    }
    this.onClose();
  }
  async send(payload, context) {
    if (!this.isAvailable) {
      await this.register();
    }
    try {
      const body = safeJsonStringify(payload);
      const res = await fetch$2(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
      const data2 = await res.json();
      this.onPayload({ data: data2 });
    } catch (e2) {
      this.onError(payload.id, e2);
    }
  }
  async register(url = this.url) {
    if (!isHttpUrl(url)) {
      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
    }
    if (this.registering) {
      const currentMaxListeners = this.events.getMaxListeners();
      if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
        this.events.setMaxListeners(currentMaxListeners + 1);
      }
      return new Promise((resolve, reject) => {
        this.events.once("register_error", (error) => {
          this.resetMaxListeners();
          reject(error);
        });
        this.events.once("open", () => {
          this.resetMaxListeners();
          if (typeof this.isAvailable === "undefined") {
            return reject(new Error("HTTP connection is missing or invalid"));
          }
          resolve();
        });
      });
    }
    this.url = url;
    this.registering = true;
    try {
      if (!this.disableProviderPing) {
        const body = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await fetch$2(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
      }
      this.onOpen();
    } catch (e2) {
      const error = this.parseError(e2);
      this.events.emit("register_error", error);
      this.onClose();
      throw error;
    }
  }
  onOpen() {
    this.isAvailable = true;
    this.registering = false;
    this.events.emit("open");
  }
  onClose() {
    this.isAvailable = false;
    this.registering = false;
    this.events.emit("close");
  }
  onPayload(e2) {
    if (typeof e2.data === "undefined")
      return;
    const payload = typeof e2.data === "string" ? safeJsonParse(e2.data) : e2.data;
    this.events.emit("payload", payload);
  }
  onError(id2, e2) {
    const error = this.parseError(e2);
    const message = error.message || error.toString();
    const payload = formatJsonRpcError(id2, message);
    this.events.emit("payload", payload);
  }
  parseError(e2, url = this.url) {
    return parseConnectionError(e2, url, "HTTP");
  }
  resetMaxListeners() {
    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
    }
  }
}
const Ia$1 = "error", Wg$1 = "wss://relay.walletconnect.com", Fg$1 = "wc", Mg$1 = "universal_provider", xa = `${Fg$1}@2:${Mg$1}:`, qg$1 = "https://rpc.walletconnect.com/v1/", Vn = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var ge$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ui$1 = { exports: {} };
/**
* @license
* Lodash <https://lodash.com/>
* Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
* Released under MIT license <https://lodash.com/license>
* Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
*/
(function(C2, u3) {
  (function() {
    var i3, d3 = "4.17.21", P2 = 200, O2 = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", $2 = "Expected a function", En = "Invalid `variable` option passed into `_.template`", zt2 = "__lodash_hash_undefined__", pr2 = 500, It2 = "__lodash_placeholder__", Ln2 = 1, Fn2 = 2, xt2 = 4, Et2 = 1, ve2 = 2, vn2 = 1, ct2 = 2, qi2 = 4, Dn2 = 8, yt2 = 16, Hn2 = 32, St2 = 64, Mn2 = 128, Kt2 = 256, dr2 = 512, La2 = 30, Da2 = "...", Ha2 = 800, Na2 = 16, Bi2 = 1, $a = 2, Ua2 = 3, ht2 = 1 / 0, kn2 = 9007199254740991, Wa2 = 17976931348623157e292, _e2 = 0 / 0, Nn = 4294967295, Fa2 = Nn - 1, Ma2 = Nn >>> 1, qa2 = [["ary", Mn2], ["bind", vn2], ["bindKey", ct2], ["curry", Dn2], ["curryRight", yt2], ["flip", dr2], ["partial", Hn2], ["partialRight", St2], ["rearg", Kt2]], Ot2 = "[object Arguments]", me2 = "[object Array]", Ba2 = "[object AsyncFunction]", Yt2 = "[object Boolean]", Zt2 = "[object Date]", Ga2 = "[object DOMException]", we2 = "[object Error]", Pe2 = "[object Function]", Gi2 = "[object GeneratorFunction]", yn2 = "[object Map]", Jt2 = "[object Number]", za2 = "[object Null]", qn2 = "[object Object]", zi2 = "[object Promise]", Ka2 = "[object Proxy]", Xt2 = "[object RegExp]", Sn = "[object Set]", Qt2 = "[object String]", Ae2 = "[object Symbol]", Ya2 = "[object Undefined]", Vt2 = "[object WeakMap]", Za2 = "[object WeakSet]", kt2 = "[object ArrayBuffer]", Rt2 = "[object DataView]", gr2 = "[object Float32Array]", vr2 = "[object Float64Array]", _r2 = "[object Int8Array]", mr2 = "[object Int16Array]", wr = "[object Int32Array]", Pr2 = "[object Uint8Array]", Ar2 = "[object Uint8ClampedArray]", Cr2 = "[object Uint16Array]", Ir2 = "[object Uint32Array]", Ja2 = /\b__p \+= '';/g, Xa2 = /\b(__p \+=) '' \+/g, Qa2 = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Ki2 = /&(?:amp|lt|gt|quot|#39);/g, Yi2 = /[&<>"']/g, Va2 = RegExp(Ki2.source), ka2 = RegExp(Yi2.source), ja2 = /<%-([\s\S]+?)%>/g, no = /<%([\s\S]+?)%>/g, Zi3 = /<%=([\s\S]+?)%>/g, to = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, eo = /^\w*$/, ro = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, xr2 = /[\\^$.*+?()[\]{}|]/g, io = RegExp(xr2.source), Er = /^\s+/, so = /\s/, uo = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ao = /\{\n\/\* \[wrapped with (.+)\] \*/, oo = /,? & /, fo = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, co = /[()=,{}\[\]\/\s]/, ho = /\\(\\)?/g, lo = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ji2 = /\w*$/, po = /^[-+]0x[0-9a-f]+$/i, go = /^0b[01]+$/i, vo = /^\[object .+?Constructor\]$/, _o = /^0o[0-7]+$/i, mo = /^(?:0|[1-9]\d*)$/, wo = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ce2 = /($^)/, Po = /['\n\r\u2028\u2029\\]/g, Ie2 = "\\ud800-\\udfff", Ao = "\\u0300-\\u036f", Co = "\\ufe20-\\ufe2f", Io = "\\u20d0-\\u20ff", Xi2 = Ao + Co + Io, Qi2 = "\\u2700-\\u27bf", Vi2 = "a-z\\xdf-\\xf6\\xf8-\\xff", xo = "\\xac\\xb1\\xd7\\xf7", Eo = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", yo = "\\u2000-\\u206f", So = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ki2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", ji2 = "\\ufe0e\\ufe0f", ns2 = xo + Eo + yo + So, yr2 = "['’]", Oo = "[" + Ie2 + "]", ts2 = "[" + ns2 + "]", xe2 = "[" + Xi2 + "]", es2 = "\\d+", Ro = "[" + Qi2 + "]", rs2 = "[" + Vi2 + "]", is3 = "[^" + Ie2 + ns2 + es2 + Qi2 + Vi2 + ki2 + "]", Sr2 = "\\ud83c[\\udffb-\\udfff]", bo = "(?:" + xe2 + "|" + Sr2 + ")", ss2 = "[^" + Ie2 + "]", Or2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", Rr2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", bt2 = "[" + ki2 + "]", us2 = "\\u200d", as2 = "(?:" + rs2 + "|" + is3 + ")", To = "(?:" + bt2 + "|" + is3 + ")", os2 = "(?:" + yr2 + "(?:d|ll|m|re|s|t|ve))?", fs2 = "(?:" + yr2 + "(?:D|LL|M|RE|S|T|VE))?", cs2 = bo + "?", hs2 = "[" + ji2 + "]?", Lo = "(?:" + us2 + "(?:" + [ss2, Or2, Rr2].join("|") + ")" + hs2 + cs2 + ")*", Do = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Ho = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ls2 = hs2 + cs2 + Lo, No = "(?:" + [Ro, Or2, Rr2].join("|") + ")" + ls2, $o = "(?:" + [ss2 + xe2 + "?", xe2, Or2, Rr2, Oo].join("|") + ")", Uo = RegExp(yr2, "g"), Wo = RegExp(xe2, "g"), br = RegExp(Sr2 + "(?=" + Sr2 + ")|" + $o + ls2, "g"), Fo = RegExp([bt2 + "?" + rs2 + "+" + os2 + "(?=" + [ts2, bt2, "$"].join("|") + ")", To + "+" + fs2 + "(?=" + [ts2, bt2 + as2, "$"].join("|") + ")", bt2 + "?" + as2 + "+" + os2, bt2 + "+" + fs2, Ho, Do, es2, No].join("|"), "g"), Mo = RegExp("[" + us2 + Ie2 + Xi2 + ji2 + "]"), qo = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Bo = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Go = -1, B2 = {};
    B2[gr2] = B2[vr2] = B2[_r2] = B2[mr2] = B2[wr] = B2[Pr2] = B2[Ar2] = B2[Cr2] = B2[Ir2] = true, B2[Ot2] = B2[me2] = B2[kt2] = B2[Yt2] = B2[Rt2] = B2[Zt2] = B2[we2] = B2[Pe2] = B2[yn2] = B2[Jt2] = B2[qn2] = B2[Xt2] = B2[Sn] = B2[Qt2] = B2[Vt2] = false;
    var q2 = {};
    q2[Ot2] = q2[me2] = q2[kt2] = q2[Rt2] = q2[Yt2] = q2[Zt2] = q2[gr2] = q2[vr2] = q2[_r2] = q2[mr2] = q2[wr] = q2[yn2] = q2[Jt2] = q2[qn2] = q2[Xt2] = q2[Sn] = q2[Qt2] = q2[Ae2] = q2[Pr2] = q2[Ar2] = q2[Cr2] = q2[Ir2] = true, q2[we2] = q2[Pe2] = q2[Vt2] = false;
    var zo = { À: "A", Á: "A", Â: "A", Ã: "A", Ä: "A", Å: "A", à: "a", á: "a", â: "a", ã: "a", ä: "a", å: "a", Ç: "C", ç: "c", Ð: "D", ð: "d", È: "E", É: "E", Ê: "E", Ë: "E", è: "e", é: "e", ê: "e", ë: "e", Ì: "I", Í: "I", Î: "I", Ï: "I", ì: "i", í: "i", î: "i", ï: "i", Ñ: "N", ñ: "n", Ò: "O", Ó: "O", Ô: "O", Õ: "O", Ö: "O", Ø: "O", ò: "o", ó: "o", ô: "o", õ: "o", ö: "o", ø: "o", Ù: "U", Ú: "U", Û: "U", Ü: "U", ù: "u", ú: "u", û: "u", ü: "u", Ý: "Y", ý: "y", ÿ: "y", Æ: "Ae", æ: "ae", Þ: "Th", þ: "th", ß: "ss", Ā: "A", Ă: "A", Ą: "A", ā: "a", ă: "a", ą: "a", Ć: "C", Ĉ: "C", Ċ: "C", Č: "C", ć: "c", ĉ: "c", ċ: "c", č: "c", Ď: "D", Đ: "D", ď: "d", đ: "d", Ē: "E", Ĕ: "E", Ė: "E", Ę: "E", Ě: "E", ē: "e", ĕ: "e", ė: "e", ę: "e", ě: "e", Ĝ: "G", Ğ: "G", Ġ: "G", Ģ: "G", ĝ: "g", ğ: "g", ġ: "g", ģ: "g", Ĥ: "H", Ħ: "H", ĥ: "h", ħ: "h", Ĩ: "I", Ī: "I", Ĭ: "I", Į: "I", İ: "I", ĩ: "i", ī: "i", ĭ: "i", į: "i", ı: "i", Ĵ: "J", ĵ: "j", Ķ: "K", ķ: "k", ĸ: "k", Ĺ: "L", Ļ: "L", Ľ: "L", Ŀ: "L", Ł: "L", ĺ: "l", ļ: "l", ľ: "l", ŀ: "l", ł: "l", Ń: "N", Ņ: "N", Ň: "N", Ŋ: "N", ń: "n", ņ: "n", ň: "n", ŋ: "n", Ō: "O", Ŏ: "O", Ő: "O", ō: "o", ŏ: "o", ő: "o", Ŕ: "R", Ŗ: "R", Ř: "R", ŕ: "r", ŗ: "r", ř: "r", Ś: "S", Ŝ: "S", Ş: "S", Š: "S", ś: "s", ŝ: "s", ş: "s", š: "s", Ţ: "T", Ť: "T", Ŧ: "T", ţ: "t", ť: "t", ŧ: "t", Ũ: "U", Ū: "U", Ŭ: "U", Ů: "U", Ű: "U", Ų: "U", ũ: "u", ū: "u", ŭ: "u", ů: "u", ű: "u", ų: "u", Ŵ: "W", ŵ: "w", Ŷ: "Y", ŷ: "y", Ÿ: "Y", Ź: "Z", Ż: "Z", Ž: "Z", ź: "z", ż: "z", ž: "z", Ĳ: "IJ", ĳ: "ij", Œ: "Oe", œ: "oe", ŉ: "'n", ſ: "s" }, Ko = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Yo = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, Zo = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Jo = parseFloat, Xo = parseInt, ps2 = typeof ge$1 == "object" && ge$1 && ge$1.Object === Object && ge$1, Qo = typeof self == "object" && self && self.Object === Object && self, k3 = ps2 || Qo || Function("return this")(), Tr2 = u3 && !u3.nodeType && u3, lt2 = Tr2 && true && C2 && !C2.nodeType && C2, ds2 = lt2 && lt2.exports === Tr2, Lr2 = ds2 && ps2.process, _n = function() {
      try {
        var h5 = lt2 && lt2.require && lt2.require("util").types;
        return h5 || Lr2 && Lr2.binding && Lr2.binding("util");
      } catch {
      }
    }(), gs2 = _n && _n.isArrayBuffer, vs2 = _n && _n.isDate, _s2 = _n && _n.isMap, ms2 = _n && _n.isRegExp, ws2 = _n && _n.isSet, Ps2 = _n && _n.isTypedArray;
    function cn2(h5, g3, p3) {
      switch (p3.length) {
        case 0:
          return h5.call(g3);
        case 1:
          return h5.call(g3, p3[0]);
        case 2:
          return h5.call(g3, p3[0], p3[1]);
        case 3:
          return h5.call(g3, p3[0], p3[1], p3[2]);
      }
      return h5.apply(g3, p3);
    }
    function Vo(h5, g3, p3, A2) {
      for (var S3 = -1, U2 = h5 == null ? 0 : h5.length; ++S3 < U2; ) {
        var X2 = h5[S3];
        g3(A2, X2, p3(X2), h5);
      }
      return A2;
    }
    function mn2(h5, g3) {
      for (var p3 = -1, A2 = h5 == null ? 0 : h5.length; ++p3 < A2 && g3(h5[p3], p3, h5) !== false; )
        ;
      return h5;
    }
    function ko(h5, g3) {
      for (var p3 = h5 == null ? 0 : h5.length; p3-- && g3(h5[p3], p3, h5) !== false; )
        ;
      return h5;
    }
    function As2(h5, g3) {
      for (var p3 = -1, A2 = h5 == null ? 0 : h5.length; ++p3 < A2; )
        if (!g3(h5[p3], p3, h5))
          return false;
      return true;
    }
    function jn(h5, g3) {
      for (var p3 = -1, A2 = h5 == null ? 0 : h5.length, S3 = 0, U2 = []; ++p3 < A2; ) {
        var X2 = h5[p3];
        g3(X2, p3, h5) && (U2[S3++] = X2);
      }
      return U2;
    }
    function Ee2(h5, g3) {
      var p3 = h5 == null ? 0 : h5.length;
      return !!p3 && Tt2(h5, g3, 0) > -1;
    }
    function Dr2(h5, g3, p3) {
      for (var A2 = -1, S3 = h5 == null ? 0 : h5.length; ++A2 < S3; )
        if (p3(g3, h5[A2]))
          return true;
      return false;
    }
    function G2(h5, g3) {
      for (var p3 = -1, A2 = h5 == null ? 0 : h5.length, S3 = Array(A2); ++p3 < A2; )
        S3[p3] = g3(h5[p3], p3, h5);
      return S3;
    }
    function nt2(h5, g3) {
      for (var p3 = -1, A2 = g3.length, S3 = h5.length; ++p3 < A2; )
        h5[S3 + p3] = g3[p3];
      return h5;
    }
    function Hr(h5, g3, p3, A2) {
      var S3 = -1, U2 = h5 == null ? 0 : h5.length;
      for (A2 && U2 && (p3 = h5[++S3]); ++S3 < U2; )
        p3 = g3(p3, h5[S3], S3, h5);
      return p3;
    }
    function jo(h5, g3, p3, A2) {
      var S3 = h5 == null ? 0 : h5.length;
      for (A2 && S3 && (p3 = h5[--S3]); S3--; )
        p3 = g3(p3, h5[S3], S3, h5);
      return p3;
    }
    function Nr2(h5, g3) {
      for (var p3 = -1, A2 = h5 == null ? 0 : h5.length; ++p3 < A2; )
        if (g3(h5[p3], p3, h5))
          return true;
      return false;
    }
    var nf2 = $r2("length");
    function tf2(h5) {
      return h5.split("");
    }
    function ef2(h5) {
      return h5.match(fo) || [];
    }
    function Cs2(h5, g3, p3) {
      var A2;
      return p3(h5, function(S3, U2, X2) {
        if (g3(S3, U2, X2))
          return A2 = U2, false;
      }), A2;
    }
    function ye2(h5, g3, p3, A2) {
      for (var S3 = h5.length, U2 = p3 + (A2 ? 1 : -1); A2 ? U2-- : ++U2 < S3; )
        if (g3(h5[U2], U2, h5))
          return U2;
      return -1;
    }
    function Tt2(h5, g3, p3) {
      return g3 === g3 ? gf2(h5, g3, p3) : ye2(h5, Is2, p3);
    }
    function rf2(h5, g3, p3, A2) {
      for (var S3 = p3 - 1, U2 = h5.length; ++S3 < U2; )
        if (A2(h5[S3], g3))
          return S3;
      return -1;
    }
    function Is2(h5) {
      return h5 !== h5;
    }
    function xs2(h5, g3) {
      var p3 = h5 == null ? 0 : h5.length;
      return p3 ? Wr(h5, g3) / p3 : _e2;
    }
    function $r2(h5) {
      return function(g3) {
        return g3 == null ? i3 : g3[h5];
      };
    }
    function Ur2(h5) {
      return function(g3) {
        return h5 == null ? i3 : h5[g3];
      };
    }
    function Es2(h5, g3, p3, A2, S3) {
      return S3(h5, function(U2, X2, M3) {
        p3 = A2 ? (A2 = false, U2) : g3(p3, U2, X2, M3);
      }), p3;
    }
    function sf2(h5, g3) {
      var p3 = h5.length;
      for (h5.sort(g3); p3--; )
        h5[p3] = h5[p3].value;
      return h5;
    }
    function Wr(h5, g3) {
      for (var p3, A2 = -1, S3 = h5.length; ++A2 < S3; ) {
        var U2 = g3(h5[A2]);
        U2 !== i3 && (p3 = p3 === i3 ? U2 : p3 + U2);
      }
      return p3;
    }
    function Fr2(h5, g3) {
      for (var p3 = -1, A2 = Array(h5); ++p3 < h5; )
        A2[p3] = g3(p3);
      return A2;
    }
    function uf2(h5, g3) {
      return G2(g3, function(p3) {
        return [p3, h5[p3]];
      });
    }
    function ys2(h5) {
      return h5 && h5.slice(0, bs2(h5) + 1).replace(Er, "");
    }
    function hn2(h5) {
      return function(g3) {
        return h5(g3);
      };
    }
    function Mr2(h5, g3) {
      return G2(g3, function(p3) {
        return h5[p3];
      });
    }
    function jt2(h5, g3) {
      return h5.has(g3);
    }
    function Ss2(h5, g3) {
      for (var p3 = -1, A2 = h5.length; ++p3 < A2 && Tt2(g3, h5[p3], 0) > -1; )
        ;
      return p3;
    }
    function Os2(h5, g3) {
      for (var p3 = h5.length; p3-- && Tt2(g3, h5[p3], 0) > -1; )
        ;
      return p3;
    }
    function af2(h5, g3) {
      for (var p3 = h5.length, A2 = 0; p3--; )
        h5[p3] === g3 && ++A2;
      return A2;
    }
    var of2 = Ur2(zo), ff2 = Ur2(Ko);
    function cf2(h5) {
      return "\\" + Zo[h5];
    }
    function hf2(h5, g3) {
      return h5 == null ? i3 : h5[g3];
    }
    function Lt2(h5) {
      return Mo.test(h5);
    }
    function lf2(h5) {
      return qo.test(h5);
    }
    function pf2(h5) {
      for (var g3, p3 = []; !(g3 = h5.next()).done; )
        p3.push(g3.value);
      return p3;
    }
    function qr(h5) {
      var g3 = -1, p3 = Array(h5.size);
      return h5.forEach(function(A2, S3) {
        p3[++g3] = [S3, A2];
      }), p3;
    }
    function Rs2(h5, g3) {
      return function(p3) {
        return h5(g3(p3));
      };
    }
    function tt2(h5, g3) {
      for (var p3 = -1, A2 = h5.length, S3 = 0, U2 = []; ++p3 < A2; ) {
        var X2 = h5[p3];
        (X2 === g3 || X2 === It2) && (h5[p3] = It2, U2[S3++] = p3);
      }
      return U2;
    }
    function Se2(h5) {
      var g3 = -1, p3 = Array(h5.size);
      return h5.forEach(function(A2) {
        p3[++g3] = A2;
      }), p3;
    }
    function df2(h5) {
      var g3 = -1, p3 = Array(h5.size);
      return h5.forEach(function(A2) {
        p3[++g3] = [A2, A2];
      }), p3;
    }
    function gf2(h5, g3, p3) {
      for (var A2 = p3 - 1, S3 = h5.length; ++A2 < S3; )
        if (h5[A2] === g3)
          return A2;
      return -1;
    }
    function vf2(h5, g3, p3) {
      for (var A2 = p3 + 1; A2--; )
        if (h5[A2] === g3)
          return A2;
      return A2;
    }
    function Dt2(h5) {
      return Lt2(h5) ? mf2(h5) : nf2(h5);
    }
    function On(h5) {
      return Lt2(h5) ? wf2(h5) : tf2(h5);
    }
    function bs2(h5) {
      for (var g3 = h5.length; g3-- && so.test(h5.charAt(g3)); )
        ;
      return g3;
    }
    var _f = Ur2(Yo);
    function mf2(h5) {
      for (var g3 = br.lastIndex = 0; br.test(h5); )
        ++g3;
      return g3;
    }
    function wf2(h5) {
      return h5.match(br) || [];
    }
    function Pf2(h5) {
      return h5.match(Fo) || [];
    }
    var Af2 = function h5(g3) {
      g3 = g3 == null ? k3 : Ht2.defaults(k3.Object(), g3, Ht2.pick(k3, Bo));
      var p3 = g3.Array, A2 = g3.Date, S3 = g3.Error, U2 = g3.Function, X2 = g3.Math, M3 = g3.Object, Br = g3.RegExp, Cf2 = g3.String, wn = g3.TypeError, Oe2 = p3.prototype, If2 = U2.prototype, Nt2 = M3.prototype, Re2 = g3["__core-js_shared__"], be2 = If2.toString, F2 = Nt2.hasOwnProperty, xf2 = 0, Ts2 = function() {
        var n4 = /[^.]+$/.exec(Re2 && Re2.keys && Re2.keys.IE_PROTO || "");
        return n4 ? "Symbol(src)_1." + n4 : "";
      }(), Te2 = Nt2.toString, Ef2 = be2.call(M3), yf2 = k3._, Sf2 = Br("^" + be2.call(F2).replace(xr2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Le2 = ds2 ? g3.Buffer : i3, et2 = g3.Symbol, De2 = g3.Uint8Array, Ls2 = Le2 ? Le2.allocUnsafe : i3, He2 = Rs2(M3.getPrototypeOf, M3), Ds2 = M3.create, Hs2 = Nt2.propertyIsEnumerable, Ne2 = Oe2.splice, Ns2 = et2 ? et2.isConcatSpreadable : i3, ne2 = et2 ? et2.iterator : i3, pt2 = et2 ? et2.toStringTag : i3, $e2 = function() {
        try {
          var n4 = mt2(M3, "defineProperty");
          return n4({}, "", {}), n4;
        } catch {
        }
      }(), Of2 = g3.clearTimeout !== k3.clearTimeout && g3.clearTimeout, Rf2 = A2 && A2.now !== k3.Date.now && A2.now, bf2 = g3.setTimeout !== k3.setTimeout && g3.setTimeout, Ue2 = X2.ceil, We2 = X2.floor, Gr = M3.getOwnPropertySymbols, Tf2 = Le2 ? Le2.isBuffer : i3, $s2 = g3.isFinite, Lf2 = Oe2.join, Df2 = Rs2(M3.keys, M3), Q3 = X2.max, nn2 = X2.min, Hf2 = A2.now, Nf2 = g3.parseInt, Us2 = X2.random, $f2 = Oe2.reverse, zr2 = mt2(g3, "DataView"), te3 = mt2(g3, "Map"), Kr = mt2(g3, "Promise"), $t2 = mt2(g3, "Set"), ee2 = mt2(g3, "WeakMap"), re2 = mt2(M3, "create"), Fe2 = ee2 && new ee2(), Ut2 = {}, Uf2 = wt2(zr2), Wf2 = wt2(te3), Ff2 = wt2(Kr), Mf2 = wt2($t2), qf2 = wt2(ee2), Me2 = et2 ? et2.prototype : i3, ie2 = Me2 ? Me2.valueOf : i3, Ws2 = Me2 ? Me2.toString : i3;
      function a3(n4) {
        if (Y2(n4) && !R3(n4) && !(n4 instanceof H3)) {
          if (n4 instanceof Pn)
            return n4;
          if (F2.call(n4, "__wrapped__"))
            return Fu(n4);
        }
        return new Pn(n4);
      }
      var Wt2 = function() {
        function n4() {
        }
        return function(t2) {
          if (!K3(t2))
            return {};
          if (Ds2)
            return Ds2(t2);
          n4.prototype = t2;
          var e2 = new n4();
          return n4.prototype = i3, e2;
        };
      }();
      function qe2() {
      }
      function Pn(n4, t2) {
        this.__wrapped__ = n4, this.__actions__ = [], this.__chain__ = !!t2, this.__index__ = 0, this.__values__ = i3;
      }
      a3.templateSettings = { escape: ja2, evaluate: no, interpolate: Zi3, variable: "", imports: { _: a3 } }, a3.prototype = qe2.prototype, a3.prototype.constructor = a3, Pn.prototype = Wt2(qe2.prototype), Pn.prototype.constructor = Pn;
      function H3(n4) {
        this.__wrapped__ = n4, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = Nn, this.__views__ = [];
      }
      function Bf2() {
        var n4 = new H3(this.__wrapped__);
        return n4.__actions__ = un2(this.__actions__), n4.__dir__ = this.__dir__, n4.__filtered__ = this.__filtered__, n4.__iteratees__ = un2(this.__iteratees__), n4.__takeCount__ = this.__takeCount__, n4.__views__ = un2(this.__views__), n4;
      }
      function Gf2() {
        if (this.__filtered__) {
          var n4 = new H3(this);
          n4.__dir__ = -1, n4.__filtered__ = true;
        } else
          n4 = this.clone(), n4.__dir__ *= -1;
        return n4;
      }
      function zf2() {
        var n4 = this.__wrapped__.value(), t2 = this.__dir__, e2 = R3(n4), r2 = t2 < 0, s3 = e2 ? n4.length : 0, o2 = eh2(0, s3, this.__views__), f4 = o2.start, c2 = o2.end, l2 = c2 - f4, v4 = r2 ? c2 : f4 - 1, _3 = this.__iteratees__, m2 = _3.length, w3 = 0, I3 = nn2(l2, this.__takeCount__);
        if (!e2 || !r2 && s3 == l2 && I3 == l2)
          return ou(n4, this.__actions__);
        var E3 = [];
        n:
          for (; l2-- && w3 < I3; ) {
            v4 += t2;
            for (var T2 = -1, y3 = n4[v4]; ++T2 < m2; ) {
              var D2 = _3[T2], N10 = D2.iteratee, dn2 = D2.type, sn2 = N10(y3);
              if (dn2 == $a)
                y3 = sn2;
              else if (!sn2) {
                if (dn2 == Bi2)
                  continue n;
                break n;
              }
            }
            E3[w3++] = y3;
          }
        return E3;
      }
      H3.prototype = Wt2(qe2.prototype), H3.prototype.constructor = H3;
      function dt2(n4) {
        var t2 = -1, e2 = n4 == null ? 0 : n4.length;
        for (this.clear(); ++t2 < e2; ) {
          var r2 = n4[t2];
          this.set(r2[0], r2[1]);
        }
      }
      function Kf2() {
        this.__data__ = re2 ? re2(null) : {}, this.size = 0;
      }
      function Yf2(n4) {
        var t2 = this.has(n4) && delete this.__data__[n4];
        return this.size -= t2 ? 1 : 0, t2;
      }
      function Zf2(n4) {
        var t2 = this.__data__;
        if (re2) {
          var e2 = t2[n4];
          return e2 === zt2 ? i3 : e2;
        }
        return F2.call(t2, n4) ? t2[n4] : i3;
      }
      function Jf2(n4) {
        var t2 = this.__data__;
        return re2 ? t2[n4] !== i3 : F2.call(t2, n4);
      }
      function Xf2(n4, t2) {
        var e2 = this.__data__;
        return this.size += this.has(n4) ? 0 : 1, e2[n4] = re2 && t2 === i3 ? zt2 : t2, this;
      }
      dt2.prototype.clear = Kf2, dt2.prototype.delete = Yf2, dt2.prototype.get = Zf2, dt2.prototype.has = Jf2, dt2.prototype.set = Xf2;
      function Bn2(n4) {
        var t2 = -1, e2 = n4 == null ? 0 : n4.length;
        for (this.clear(); ++t2 < e2; ) {
          var r2 = n4[t2];
          this.set(r2[0], r2[1]);
        }
      }
      function Qf2() {
        this.__data__ = [], this.size = 0;
      }
      function Vf2(n4) {
        var t2 = this.__data__, e2 = Be2(t2, n4);
        if (e2 < 0)
          return false;
        var r2 = t2.length - 1;
        return e2 == r2 ? t2.pop() : Ne2.call(t2, e2, 1), --this.size, true;
      }
      function kf2(n4) {
        var t2 = this.__data__, e2 = Be2(t2, n4);
        return e2 < 0 ? i3 : t2[e2][1];
      }
      function jf2(n4) {
        return Be2(this.__data__, n4) > -1;
      }
      function nc2(n4, t2) {
        var e2 = this.__data__, r2 = Be2(e2, n4);
        return r2 < 0 ? (++this.size, e2.push([n4, t2])) : e2[r2][1] = t2, this;
      }
      Bn2.prototype.clear = Qf2, Bn2.prototype.delete = Vf2, Bn2.prototype.get = kf2, Bn2.prototype.has = jf2, Bn2.prototype.set = nc2;
      function Gn2(n4) {
        var t2 = -1, e2 = n4 == null ? 0 : n4.length;
        for (this.clear(); ++t2 < e2; ) {
          var r2 = n4[t2];
          this.set(r2[0], r2[1]);
        }
      }
      function tc2() {
        this.size = 0, this.__data__ = { hash: new dt2(), map: new (te3 || Bn2)(), string: new dt2() };
      }
      function ec2(n4) {
        var t2 = nr2(this, n4).delete(n4);
        return this.size -= t2 ? 1 : 0, t2;
      }
      function rc2(n4) {
        return nr2(this, n4).get(n4);
      }
      function ic2(n4) {
        return nr2(this, n4).has(n4);
      }
      function sc2(n4, t2) {
        var e2 = nr2(this, n4), r2 = e2.size;
        return e2.set(n4, t2), this.size += e2.size == r2 ? 0 : 1, this;
      }
      Gn2.prototype.clear = tc2, Gn2.prototype.delete = ec2, Gn2.prototype.get = rc2, Gn2.prototype.has = ic2, Gn2.prototype.set = sc2;
      function gt2(n4) {
        var t2 = -1, e2 = n4 == null ? 0 : n4.length;
        for (this.__data__ = new Gn2(); ++t2 < e2; )
          this.add(n4[t2]);
      }
      function uc2(n4) {
        return this.__data__.set(n4, zt2), this;
      }
      function ac2(n4) {
        return this.__data__.has(n4);
      }
      gt2.prototype.add = gt2.prototype.push = uc2, gt2.prototype.has = ac2;
      function Rn(n4) {
        var t2 = this.__data__ = new Bn2(n4);
        this.size = t2.size;
      }
      function oc2() {
        this.__data__ = new Bn2(), this.size = 0;
      }
      function fc2(n4) {
        var t2 = this.__data__, e2 = t2.delete(n4);
        return this.size = t2.size, e2;
      }
      function cc2(n4) {
        return this.__data__.get(n4);
      }
      function hc2(n4) {
        return this.__data__.has(n4);
      }
      function lc2(n4, t2) {
        var e2 = this.__data__;
        if (e2 instanceof Bn2) {
          var r2 = e2.__data__;
          if (!te3 || r2.length < P2 - 1)
            return r2.push([n4, t2]), this.size = ++e2.size, this;
          e2 = this.__data__ = new Gn2(r2);
        }
        return e2.set(n4, t2), this.size = e2.size, this;
      }
      Rn.prototype.clear = oc2, Rn.prototype.delete = fc2, Rn.prototype.get = cc2, Rn.prototype.has = hc2, Rn.prototype.set = lc2;
      function Fs2(n4, t2) {
        var e2 = R3(n4), r2 = !e2 && Pt2(n4), s3 = !e2 && !r2 && at2(n4), o2 = !e2 && !r2 && !s3 && Bt2(n4), f4 = e2 || r2 || s3 || o2, c2 = f4 ? Fr2(n4.length, Cf2) : [], l2 = c2.length;
        for (var v4 in n4)
          (t2 || F2.call(n4, v4)) && !(f4 && (v4 == "length" || s3 && (v4 == "offset" || v4 == "parent") || o2 && (v4 == "buffer" || v4 == "byteLength" || v4 == "byteOffset") || Zn(v4, l2))) && c2.push(v4);
        return c2;
      }
      function Ms2(n4) {
        var t2 = n4.length;
        return t2 ? n4[ei2(0, t2 - 1)] : i3;
      }
      function pc2(n4, t2) {
        return tr3(un2(n4), vt2(t2, 0, n4.length));
      }
      function dc2(n4) {
        return tr3(un2(n4));
      }
      function Yr(n4, t2, e2) {
        (e2 !== i3 && !bn2(n4[t2], e2) || e2 === i3 && !(t2 in n4)) && zn(n4, t2, e2);
      }
      function se2(n4, t2, e2) {
        var r2 = n4[t2];
        (!(F2.call(n4, t2) && bn2(r2, e2)) || e2 === i3 && !(t2 in n4)) && zn(n4, t2, e2);
      }
      function Be2(n4, t2) {
        for (var e2 = n4.length; e2--; )
          if (bn2(n4[e2][0], t2))
            return e2;
        return -1;
      }
      function gc2(n4, t2, e2, r2) {
        return rt2(n4, function(s3, o2, f4) {
          t2(r2, s3, e2(s3), f4);
        }), r2;
      }
      function qs2(n4, t2) {
        return n4 && Un2(t2, V3(t2), n4);
      }
      function vc2(n4, t2) {
        return n4 && Un2(t2, on3(t2), n4);
      }
      function zn(n4, t2, e2) {
        t2 == "__proto__" && $e2 ? $e2(n4, t2, { configurable: true, enumerable: true, value: e2, writable: true }) : n4[t2] = e2;
      }
      function Zr(n4, t2) {
        for (var e2 = -1, r2 = t2.length, s3 = p3(r2), o2 = n4 == null; ++e2 < r2; )
          s3[e2] = o2 ? i3 : Si2(n4, t2[e2]);
        return s3;
      }
      function vt2(n4, t2, e2) {
        return n4 === n4 && (e2 !== i3 && (n4 = n4 <= e2 ? n4 : e2), t2 !== i3 && (n4 = n4 >= t2 ? n4 : t2)), n4;
      }
      function An(n4, t2, e2, r2, s3, o2) {
        var f4, c2 = t2 & Ln2, l2 = t2 & Fn2, v4 = t2 & xt2;
        if (e2 && (f4 = s3 ? e2(n4, r2, s3, o2) : e2(n4)), f4 !== i3)
          return f4;
        if (!K3(n4))
          return n4;
        var _3 = R3(n4);
        if (_3) {
          if (f4 = ih2(n4), !c2)
            return un2(n4, f4);
        } else {
          var m2 = tn2(n4), w3 = m2 == Pe2 || m2 == Gi2;
          if (at2(n4))
            return hu(n4, c2);
          if (m2 == qn2 || m2 == Ot2 || w3 && !s3) {
            if (f4 = l2 || w3 ? {} : bu(n4), !c2)
              return l2 ? Zc2(n4, vc2(f4, n4)) : Yc2(n4, qs2(f4, n4));
          } else {
            if (!q2[m2])
              return s3 ? n4 : {};
            f4 = sh2(n4, m2, c2);
          }
        }
        o2 || (o2 = new Rn());
        var I3 = o2.get(n4);
        if (I3)
          return I3;
        o2.set(n4, f4), sa2(n4) ? n4.forEach(function(y3) {
          f4.add(An(y3, t2, e2, y3, n4, o2));
        }) : ra2(n4) && n4.forEach(function(y3, D2) {
          f4.set(D2, An(y3, t2, e2, D2, n4, o2));
        });
        var E3 = v4 ? l2 ? pi2 : li2 : l2 ? on3 : V3, T2 = _3 ? i3 : E3(n4);
        return mn2(T2 || n4, function(y3, D2) {
          T2 && (D2 = y3, y3 = n4[D2]), se2(f4, D2, An(y3, t2, e2, D2, n4, o2));
        }), f4;
      }
      function _c(n4) {
        var t2 = V3(n4);
        return function(e2) {
          return Bs2(e2, n4, t2);
        };
      }
      function Bs2(n4, t2, e2) {
        var r2 = e2.length;
        if (n4 == null)
          return !r2;
        for (n4 = M3(n4); r2--; ) {
          var s3 = e2[r2], o2 = t2[s3], f4 = n4[s3];
          if (f4 === i3 && !(s3 in n4) || !o2(f4))
            return false;
        }
        return true;
      }
      function Gs2(n4, t2, e2) {
        if (typeof n4 != "function")
          throw new wn($2);
        return le2(function() {
          n4.apply(i3, e2);
        }, t2);
      }
      function ue3(n4, t2, e2, r2) {
        var s3 = -1, o2 = Ee2, f4 = true, c2 = n4.length, l2 = [], v4 = t2.length;
        if (!c2)
          return l2;
        e2 && (t2 = G2(t2, hn2(e2))), r2 ? (o2 = Dr2, f4 = false) : t2.length >= P2 && (o2 = jt2, f4 = false, t2 = new gt2(t2));
        n:
          for (; ++s3 < c2; ) {
            var _3 = n4[s3], m2 = e2 == null ? _3 : e2(_3);
            if (_3 = r2 || _3 !== 0 ? _3 : 0, f4 && m2 === m2) {
              for (var w3 = v4; w3--; )
                if (t2[w3] === m2)
                  continue n;
              l2.push(_3);
            } else
              o2(t2, m2, r2) || l2.push(_3);
          }
        return l2;
      }
      var rt2 = vu($n), zs2 = vu(Xr, true);
      function mc2(n4, t2) {
        var e2 = true;
        return rt2(n4, function(r2, s3, o2) {
          return e2 = !!t2(r2, s3, o2), e2;
        }), e2;
      }
      function Ge2(n4, t2, e2) {
        for (var r2 = -1, s3 = n4.length; ++r2 < s3; ) {
          var o2 = n4[r2], f4 = t2(o2);
          if (f4 != null && (c2 === i3 ? f4 === f4 && !pn2(f4) : e2(f4, c2)))
            var c2 = f4, l2 = o2;
        }
        return l2;
      }
      function wc2(n4, t2, e2, r2) {
        var s3 = n4.length;
        for (e2 = b4(e2), e2 < 0 && (e2 = -e2 > s3 ? 0 : s3 + e2), r2 = r2 === i3 || r2 > s3 ? s3 : b4(r2), r2 < 0 && (r2 += s3), r2 = e2 > r2 ? 0 : aa2(r2); e2 < r2; )
          n4[e2++] = t2;
        return n4;
      }
      function Ks2(n4, t2) {
        var e2 = [];
        return rt2(n4, function(r2, s3, o2) {
          t2(r2, s3, o2) && e2.push(r2);
        }), e2;
      }
      function j2(n4, t2, e2, r2, s3) {
        var o2 = -1, f4 = n4.length;
        for (e2 || (e2 = ah2), s3 || (s3 = []); ++o2 < f4; ) {
          var c2 = n4[o2];
          t2 > 0 && e2(c2) ? t2 > 1 ? j2(c2, t2 - 1, e2, r2, s3) : nt2(s3, c2) : r2 || (s3[s3.length] = c2);
        }
        return s3;
      }
      var Jr = _u(), Ys2 = _u(true);
      function $n(n4, t2) {
        return n4 && Jr(n4, t2, V3);
      }
      function Xr(n4, t2) {
        return n4 && Ys2(n4, t2, V3);
      }
      function ze2(n4, t2) {
        return jn(t2, function(e2) {
          return Jn2(n4[e2]);
        });
      }
      function _t2(n4, t2) {
        t2 = st2(t2, n4);
        for (var e2 = 0, r2 = t2.length; n4 != null && e2 < r2; )
          n4 = n4[Wn2(t2[e2++])];
        return e2 && e2 == r2 ? n4 : i3;
      }
      function Zs2(n4, t2, e2) {
        var r2 = t2(n4);
        return R3(n4) ? r2 : nt2(r2, e2(n4));
      }
      function en2(n4) {
        return n4 == null ? n4 === i3 ? Ya2 : za2 : pt2 && pt2 in M3(n4) ? th2(n4) : dh2(n4);
      }
      function Qr(n4, t2) {
        return n4 > t2;
      }
      function Pc2(n4, t2) {
        return n4 != null && F2.call(n4, t2);
      }
      function Ac2(n4, t2) {
        return n4 != null && t2 in M3(n4);
      }
      function Cc2(n4, t2, e2) {
        return n4 >= nn2(t2, e2) && n4 < Q3(t2, e2);
      }
      function Vr(n4, t2, e2) {
        for (var r2 = e2 ? Dr2 : Ee2, s3 = n4[0].length, o2 = n4.length, f4 = o2, c2 = p3(o2), l2 = 1 / 0, v4 = []; f4--; ) {
          var _3 = n4[f4];
          f4 && t2 && (_3 = G2(_3, hn2(t2))), l2 = nn2(_3.length, l2), c2[f4] = !e2 && (t2 || s3 >= 120 && _3.length >= 120) ? new gt2(f4 && _3) : i3;
        }
        _3 = n4[0];
        var m2 = -1, w3 = c2[0];
        n:
          for (; ++m2 < s3 && v4.length < l2; ) {
            var I3 = _3[m2], E3 = t2 ? t2(I3) : I3;
            if (I3 = e2 || I3 !== 0 ? I3 : 0, !(w3 ? jt2(w3, E3) : r2(v4, E3, e2))) {
              for (f4 = o2; --f4; ) {
                var T2 = c2[f4];
                if (!(T2 ? jt2(T2, E3) : r2(n4[f4], E3, e2)))
                  continue n;
              }
              w3 && w3.push(E3), v4.push(I3);
            }
          }
        return v4;
      }
      function Ic2(n4, t2, e2, r2) {
        return $n(n4, function(s3, o2, f4) {
          t2(r2, e2(s3), o2, f4);
        }), r2;
      }
      function ae2(n4, t2, e2) {
        t2 = st2(t2, n4), n4 = Hu(n4, t2);
        var r2 = n4 == null ? n4 : n4[Wn2(In(t2))];
        return r2 == null ? i3 : cn2(r2, n4, e2);
      }
      function Js2(n4) {
        return Y2(n4) && en2(n4) == Ot2;
      }
      function xc2(n4) {
        return Y2(n4) && en2(n4) == kt2;
      }
      function Ec2(n4) {
        return Y2(n4) && en2(n4) == Zt2;
      }
      function oe2(n4, t2, e2, r2, s3) {
        return n4 === t2 ? true : n4 == null || t2 == null || !Y2(n4) && !Y2(t2) ? n4 !== n4 && t2 !== t2 : yc2(n4, t2, e2, r2, oe2, s3);
      }
      function yc2(n4, t2, e2, r2, s3, o2) {
        var f4 = R3(n4), c2 = R3(t2), l2 = f4 ? me2 : tn2(n4), v4 = c2 ? me2 : tn2(t2);
        l2 = l2 == Ot2 ? qn2 : l2, v4 = v4 == Ot2 ? qn2 : v4;
        var _3 = l2 == qn2, m2 = v4 == qn2, w3 = l2 == v4;
        if (w3 && at2(n4)) {
          if (!at2(t2))
            return false;
          f4 = true, _3 = false;
        }
        if (w3 && !_3)
          return o2 || (o2 = new Rn()), f4 || Bt2(n4) ? Su(n4, t2, e2, r2, s3, o2) : jc2(n4, t2, l2, e2, r2, s3, o2);
        if (!(e2 & Et2)) {
          var I3 = _3 && F2.call(n4, "__wrapped__"), E3 = m2 && F2.call(t2, "__wrapped__");
          if (I3 || E3) {
            var T2 = I3 ? n4.value() : n4, y3 = E3 ? t2.value() : t2;
            return o2 || (o2 = new Rn()), s3(T2, y3, e2, r2, o2);
          }
        }
        return w3 ? (o2 || (o2 = new Rn()), nh2(n4, t2, e2, r2, s3, o2)) : false;
      }
      function Sc2(n4) {
        return Y2(n4) && tn2(n4) == yn2;
      }
      function kr(n4, t2, e2, r2) {
        var s3 = e2.length, o2 = s3, f4 = !r2;
        if (n4 == null)
          return !o2;
        for (n4 = M3(n4); s3--; ) {
          var c2 = e2[s3];
          if (f4 && c2[2] ? c2[1] !== n4[c2[0]] : !(c2[0] in n4))
            return false;
        }
        for (; ++s3 < o2; ) {
          c2 = e2[s3];
          var l2 = c2[0], v4 = n4[l2], _3 = c2[1];
          if (f4 && c2[2]) {
            if (v4 === i3 && !(l2 in n4))
              return false;
          } else {
            var m2 = new Rn();
            if (r2)
              var w3 = r2(v4, _3, l2, n4, t2, m2);
            if (!(w3 === i3 ? oe2(_3, v4, Et2 | ve2, r2, m2) : w3))
              return false;
          }
        }
        return true;
      }
      function Xs2(n4) {
        if (!K3(n4) || fh2(n4))
          return false;
        var t2 = Jn2(n4) ? Sf2 : vo;
        return t2.test(wt2(n4));
      }
      function Oc2(n4) {
        return Y2(n4) && en2(n4) == Xt2;
      }
      function Rc2(n4) {
        return Y2(n4) && tn2(n4) == Sn;
      }
      function bc2(n4) {
        return Y2(n4) && ar2(n4.length) && !!B2[en2(n4)];
      }
      function Qs2(n4) {
        return typeof n4 == "function" ? n4 : n4 == null ? fn2 : typeof n4 == "object" ? R3(n4) ? js2(n4[0], n4[1]) : ks2(n4) : ma2(n4);
      }
      function jr(n4) {
        if (!he2(n4))
          return Df2(n4);
        var t2 = [];
        for (var e2 in M3(n4))
          F2.call(n4, e2) && e2 != "constructor" && t2.push(e2);
        return t2;
      }
      function Tc2(n4) {
        if (!K3(n4))
          return ph2(n4);
        var t2 = he2(n4), e2 = [];
        for (var r2 in n4)
          r2 == "constructor" && (t2 || !F2.call(n4, r2)) || e2.push(r2);
        return e2;
      }
      function ni2(n4, t2) {
        return n4 < t2;
      }
      function Vs2(n4, t2) {
        var e2 = -1, r2 = an2(n4) ? p3(n4.length) : [];
        return rt2(n4, function(s3, o2, f4) {
          r2[++e2] = t2(s3, o2, f4);
        }), r2;
      }
      function ks2(n4) {
        var t2 = gi2(n4);
        return t2.length == 1 && t2[0][2] ? Lu(t2[0][0], t2[0][1]) : function(e2) {
          return e2 === n4 || kr(e2, n4, t2);
        };
      }
      function js2(n4, t2) {
        return _i(n4) && Tu(t2) ? Lu(Wn2(n4), t2) : function(e2) {
          var r2 = Si2(e2, n4);
          return r2 === i3 && r2 === t2 ? Oi2(e2, n4) : oe2(t2, r2, Et2 | ve2);
        };
      }
      function Ke2(n4, t2, e2, r2, s3) {
        n4 !== t2 && Jr(t2, function(o2, f4) {
          if (s3 || (s3 = new Rn()), K3(o2))
            Lc2(n4, t2, f4, e2, Ke2, r2, s3);
          else {
            var c2 = r2 ? r2(wi2(n4, f4), o2, f4 + "", n4, t2, s3) : i3;
            c2 === i3 && (c2 = o2), Yr(n4, f4, c2);
          }
        }, on3);
      }
      function Lc2(n4, t2, e2, r2, s3, o2, f4) {
        var c2 = wi2(n4, e2), l2 = wi2(t2, e2), v4 = f4.get(l2);
        if (v4) {
          Yr(n4, e2, v4);
          return;
        }
        var _3 = o2 ? o2(c2, l2, e2 + "", n4, t2, f4) : i3, m2 = _3 === i3;
        if (m2) {
          var w3 = R3(l2), I3 = !w3 && at2(l2), E3 = !w3 && !I3 && Bt2(l2);
          _3 = l2, w3 || I3 || E3 ? R3(c2) ? _3 = c2 : Z2(c2) ? _3 = un2(c2) : I3 ? (m2 = false, _3 = hu(l2, true)) : E3 ? (m2 = false, _3 = lu(l2, true)) : _3 = [] : pe2(l2) || Pt2(l2) ? (_3 = c2, Pt2(c2) ? _3 = oa2(c2) : (!K3(c2) || Jn2(c2)) && (_3 = bu(l2))) : m2 = false;
        }
        m2 && (f4.set(l2, _3), s3(_3, l2, r2, o2, f4), f4.delete(l2)), Yr(n4, e2, _3);
      }
      function nu(n4, t2) {
        var e2 = n4.length;
        if (e2)
          return t2 += t2 < 0 ? e2 : 0, Zn(t2, e2) ? n4[t2] : i3;
      }
      function tu(n4, t2, e2) {
        t2.length ? t2 = G2(t2, function(o2) {
          return R3(o2) ? function(f4) {
            return _t2(f4, o2.length === 1 ? o2[0] : o2);
          } : o2;
        }) : t2 = [fn2];
        var r2 = -1;
        t2 = G2(t2, hn2(x2()));
        var s3 = Vs2(n4, function(o2, f4, c2) {
          var l2 = G2(t2, function(v4) {
            return v4(o2);
          });
          return { criteria: l2, index: ++r2, value: o2 };
        });
        return sf2(s3, function(o2, f4) {
          return Kc2(o2, f4, e2);
        });
      }
      function Dc2(n4, t2) {
        return eu(n4, t2, function(e2, r2) {
          return Oi2(n4, r2);
        });
      }
      function eu(n4, t2, e2) {
        for (var r2 = -1, s3 = t2.length, o2 = {}; ++r2 < s3; ) {
          var f4 = t2[r2], c2 = _t2(n4, f4);
          e2(c2, f4) && fe2(o2, st2(f4, n4), c2);
        }
        return o2;
      }
      function Hc2(n4) {
        return function(t2) {
          return _t2(t2, n4);
        };
      }
      function ti2(n4, t2, e2, r2) {
        var s3 = r2 ? rf2 : Tt2, o2 = -1, f4 = t2.length, c2 = n4;
        for (n4 === t2 && (t2 = un2(t2)), e2 && (c2 = G2(n4, hn2(e2))); ++o2 < f4; )
          for (var l2 = 0, v4 = t2[o2], _3 = e2 ? e2(v4) : v4; (l2 = s3(c2, _3, l2, r2)) > -1; )
            c2 !== n4 && Ne2.call(c2, l2, 1), Ne2.call(n4, l2, 1);
        return n4;
      }
      function ru(n4, t2) {
        for (var e2 = n4 ? t2.length : 0, r2 = e2 - 1; e2--; ) {
          var s3 = t2[e2];
          if (e2 == r2 || s3 !== o2) {
            var o2 = s3;
            Zn(s3) ? Ne2.call(n4, s3, 1) : si2(n4, s3);
          }
        }
        return n4;
      }
      function ei2(n4, t2) {
        return n4 + We2(Us2() * (t2 - n4 + 1));
      }
      function Nc2(n4, t2, e2, r2) {
        for (var s3 = -1, o2 = Q3(Ue2((t2 - n4) / (e2 || 1)), 0), f4 = p3(o2); o2--; )
          f4[r2 ? o2 : ++s3] = n4, n4 += e2;
        return f4;
      }
      function ri2(n4, t2) {
        var e2 = "";
        if (!n4 || t2 < 1 || t2 > kn2)
          return e2;
        do
          t2 % 2 && (e2 += n4), t2 = We2(t2 / 2), t2 && (n4 += n4);
        while (t2);
        return e2;
      }
      function L3(n4, t2) {
        return Pi2(Du(n4, t2, fn2), n4 + "");
      }
      function $c2(n4) {
        return Ms2(Gt2(n4));
      }
      function Uc2(n4, t2) {
        var e2 = Gt2(n4);
        return tr3(e2, vt2(t2, 0, e2.length));
      }
      function fe2(n4, t2, e2, r2) {
        if (!K3(n4))
          return n4;
        t2 = st2(t2, n4);
        for (var s3 = -1, o2 = t2.length, f4 = o2 - 1, c2 = n4; c2 != null && ++s3 < o2; ) {
          var l2 = Wn2(t2[s3]), v4 = e2;
          if (l2 === "__proto__" || l2 === "constructor" || l2 === "prototype")
            return n4;
          if (s3 != f4) {
            var _3 = c2[l2];
            v4 = r2 ? r2(_3, l2, c2) : i3, v4 === i3 && (v4 = K3(_3) ? _3 : Zn(t2[s3 + 1]) ? [] : {});
          }
          se2(c2, l2, v4), c2 = c2[l2];
        }
        return n4;
      }
      var iu = Fe2 ? function(n4, t2) {
        return Fe2.set(n4, t2), n4;
      } : fn2, Wc2 = $e2 ? function(n4, t2) {
        return $e2(n4, "toString", { configurable: true, enumerable: false, value: bi2(t2), writable: true });
      } : fn2;
      function Fc2(n4) {
        return tr3(Gt2(n4));
      }
      function Cn(n4, t2, e2) {
        var r2 = -1, s3 = n4.length;
        t2 < 0 && (t2 = -t2 > s3 ? 0 : s3 + t2), e2 = e2 > s3 ? s3 : e2, e2 < 0 && (e2 += s3), s3 = t2 > e2 ? 0 : e2 - t2 >>> 0, t2 >>>= 0;
        for (var o2 = p3(s3); ++r2 < s3; )
          o2[r2] = n4[r2 + t2];
        return o2;
      }
      function Mc2(n4, t2) {
        var e2;
        return rt2(n4, function(r2, s3, o2) {
          return e2 = t2(r2, s3, o2), !e2;
        }), !!e2;
      }
      function Ye2(n4, t2, e2) {
        var r2 = 0, s3 = n4 == null ? r2 : n4.length;
        if (typeof t2 == "number" && t2 === t2 && s3 <= Ma2) {
          for (; r2 < s3; ) {
            var o2 = r2 + s3 >>> 1, f4 = n4[o2];
            f4 !== null && !pn2(f4) && (e2 ? f4 <= t2 : f4 < t2) ? r2 = o2 + 1 : s3 = o2;
          }
          return s3;
        }
        return ii2(n4, t2, fn2, e2);
      }
      function ii2(n4, t2, e2, r2) {
        var s3 = 0, o2 = n4 == null ? 0 : n4.length;
        if (o2 === 0)
          return 0;
        t2 = e2(t2);
        for (var f4 = t2 !== t2, c2 = t2 === null, l2 = pn2(t2), v4 = t2 === i3; s3 < o2; ) {
          var _3 = We2((s3 + o2) / 2), m2 = e2(n4[_3]), w3 = m2 !== i3, I3 = m2 === null, E3 = m2 === m2, T2 = pn2(m2);
          if (f4)
            var y3 = r2 || E3;
          else
            v4 ? y3 = E3 && (r2 || w3) : c2 ? y3 = E3 && w3 && (r2 || !I3) : l2 ? y3 = E3 && w3 && !I3 && (r2 || !T2) : I3 || T2 ? y3 = false : y3 = r2 ? m2 <= t2 : m2 < t2;
          y3 ? s3 = _3 + 1 : o2 = _3;
        }
        return nn2(o2, Fa2);
      }
      function su(n4, t2) {
        for (var e2 = -1, r2 = n4.length, s3 = 0, o2 = []; ++e2 < r2; ) {
          var f4 = n4[e2], c2 = t2 ? t2(f4) : f4;
          if (!e2 || !bn2(c2, l2)) {
            var l2 = c2;
            o2[s3++] = f4 === 0 ? 0 : f4;
          }
        }
        return o2;
      }
      function uu(n4) {
        return typeof n4 == "number" ? n4 : pn2(n4) ? _e2 : +n4;
      }
      function ln2(n4) {
        if (typeof n4 == "string")
          return n4;
        if (R3(n4))
          return G2(n4, ln2) + "";
        if (pn2(n4))
          return Ws2 ? Ws2.call(n4) : "";
        var t2 = n4 + "";
        return t2 == "0" && 1 / n4 == -ht2 ? "-0" : t2;
      }
      function it2(n4, t2, e2) {
        var r2 = -1, s3 = Ee2, o2 = n4.length, f4 = true, c2 = [], l2 = c2;
        if (e2)
          f4 = false, s3 = Dr2;
        else if (o2 >= P2) {
          var v4 = t2 ? null : Vc2(n4);
          if (v4)
            return Se2(v4);
          f4 = false, s3 = jt2, l2 = new gt2();
        } else
          l2 = t2 ? [] : c2;
        n:
          for (; ++r2 < o2; ) {
            var _3 = n4[r2], m2 = t2 ? t2(_3) : _3;
            if (_3 = e2 || _3 !== 0 ? _3 : 0, f4 && m2 === m2) {
              for (var w3 = l2.length; w3--; )
                if (l2[w3] === m2)
                  continue n;
              t2 && l2.push(m2), c2.push(_3);
            } else
              s3(l2, m2, e2) || (l2 !== c2 && l2.push(m2), c2.push(_3));
          }
        return c2;
      }
      function si2(n4, t2) {
        return t2 = st2(t2, n4), n4 = Hu(n4, t2), n4 == null || delete n4[Wn2(In(t2))];
      }
      function au(n4, t2, e2, r2) {
        return fe2(n4, t2, e2(_t2(n4, t2)), r2);
      }
      function Ze2(n4, t2, e2, r2) {
        for (var s3 = n4.length, o2 = r2 ? s3 : -1; (r2 ? o2-- : ++o2 < s3) && t2(n4[o2], o2, n4); )
          ;
        return e2 ? Cn(n4, r2 ? 0 : o2, r2 ? o2 + 1 : s3) : Cn(n4, r2 ? o2 + 1 : 0, r2 ? s3 : o2);
      }
      function ou(n4, t2) {
        var e2 = n4;
        return e2 instanceof H3 && (e2 = e2.value()), Hr(t2, function(r2, s3) {
          return s3.func.apply(s3.thisArg, nt2([r2], s3.args));
        }, e2);
      }
      function ui2(n4, t2, e2) {
        var r2 = n4.length;
        if (r2 < 2)
          return r2 ? it2(n4[0]) : [];
        for (var s3 = -1, o2 = p3(r2); ++s3 < r2; )
          for (var f4 = n4[s3], c2 = -1; ++c2 < r2; )
            c2 != s3 && (o2[s3] = ue3(o2[s3] || f4, n4[c2], t2, e2));
        return it2(j2(o2, 1), t2, e2);
      }
      function fu(n4, t2, e2) {
        for (var r2 = -1, s3 = n4.length, o2 = t2.length, f4 = {}; ++r2 < s3; ) {
          var c2 = r2 < o2 ? t2[r2] : i3;
          e2(f4, n4[r2], c2);
        }
        return f4;
      }
      function ai2(n4) {
        return Z2(n4) ? n4 : [];
      }
      function oi2(n4) {
        return typeof n4 == "function" ? n4 : fn2;
      }
      function st2(n4, t2) {
        return R3(n4) ? n4 : _i(n4, t2) ? [n4] : Wu(W2(n4));
      }
      var qc2 = L3;
      function ut2(n4, t2, e2) {
        var r2 = n4.length;
        return e2 = e2 === i3 ? r2 : e2, !t2 && e2 >= r2 ? n4 : Cn(n4, t2, e2);
      }
      var cu = Of2 || function(n4) {
        return k3.clearTimeout(n4);
      };
      function hu(n4, t2) {
        if (t2)
          return n4.slice();
        var e2 = n4.length, r2 = Ls2 ? Ls2(e2) : new n4.constructor(e2);
        return n4.copy(r2), r2;
      }
      function fi2(n4) {
        var t2 = new n4.constructor(n4.byteLength);
        return new De2(t2).set(new De2(n4)), t2;
      }
      function Bc2(n4, t2) {
        var e2 = t2 ? fi2(n4.buffer) : n4.buffer;
        return new n4.constructor(e2, n4.byteOffset, n4.byteLength);
      }
      function Gc2(n4) {
        var t2 = new n4.constructor(n4.source, Ji2.exec(n4));
        return t2.lastIndex = n4.lastIndex, t2;
      }
      function zc2(n4) {
        return ie2 ? M3(ie2.call(n4)) : {};
      }
      function lu(n4, t2) {
        var e2 = t2 ? fi2(n4.buffer) : n4.buffer;
        return new n4.constructor(e2, n4.byteOffset, n4.length);
      }
      function pu(n4, t2) {
        if (n4 !== t2) {
          var e2 = n4 !== i3, r2 = n4 === null, s3 = n4 === n4, o2 = pn2(n4), f4 = t2 !== i3, c2 = t2 === null, l2 = t2 === t2, v4 = pn2(t2);
          if (!c2 && !v4 && !o2 && n4 > t2 || o2 && f4 && l2 && !c2 && !v4 || r2 && f4 && l2 || !e2 && l2 || !s3)
            return 1;
          if (!r2 && !o2 && !v4 && n4 < t2 || v4 && e2 && s3 && !r2 && !o2 || c2 && e2 && s3 || !f4 && s3 || !l2)
            return -1;
        }
        return 0;
      }
      function Kc2(n4, t2, e2) {
        for (var r2 = -1, s3 = n4.criteria, o2 = t2.criteria, f4 = s3.length, c2 = e2.length; ++r2 < f4; ) {
          var l2 = pu(s3[r2], o2[r2]);
          if (l2) {
            if (r2 >= c2)
              return l2;
            var v4 = e2[r2];
            return l2 * (v4 == "desc" ? -1 : 1);
          }
        }
        return n4.index - t2.index;
      }
      function du(n4, t2, e2, r2) {
        for (var s3 = -1, o2 = n4.length, f4 = e2.length, c2 = -1, l2 = t2.length, v4 = Q3(o2 - f4, 0), _3 = p3(l2 + v4), m2 = !r2; ++c2 < l2; )
          _3[c2] = t2[c2];
        for (; ++s3 < f4; )
          (m2 || s3 < o2) && (_3[e2[s3]] = n4[s3]);
        for (; v4--; )
          _3[c2++] = n4[s3++];
        return _3;
      }
      function gu(n4, t2, e2, r2) {
        for (var s3 = -1, o2 = n4.length, f4 = -1, c2 = e2.length, l2 = -1, v4 = t2.length, _3 = Q3(o2 - c2, 0), m2 = p3(_3 + v4), w3 = !r2; ++s3 < _3; )
          m2[s3] = n4[s3];
        for (var I3 = s3; ++l2 < v4; )
          m2[I3 + l2] = t2[l2];
        for (; ++f4 < c2; )
          (w3 || s3 < o2) && (m2[I3 + e2[f4]] = n4[s3++]);
        return m2;
      }
      function un2(n4, t2) {
        var e2 = -1, r2 = n4.length;
        for (t2 || (t2 = p3(r2)); ++e2 < r2; )
          t2[e2] = n4[e2];
        return t2;
      }
      function Un2(n4, t2, e2, r2) {
        var s3 = !e2;
        e2 || (e2 = {});
        for (var o2 = -1, f4 = t2.length; ++o2 < f4; ) {
          var c2 = t2[o2], l2 = r2 ? r2(e2[c2], n4[c2], c2, e2, n4) : i3;
          l2 === i3 && (l2 = n4[c2]), s3 ? zn(e2, c2, l2) : se2(e2, c2, l2);
        }
        return e2;
      }
      function Yc2(n4, t2) {
        return Un2(n4, vi2(n4), t2);
      }
      function Zc2(n4, t2) {
        return Un2(n4, Ou(n4), t2);
      }
      function Je2(n4, t2) {
        return function(e2, r2) {
          var s3 = R3(e2) ? Vo : gc2, o2 = t2 ? t2() : {};
          return s3(e2, n4, x2(r2, 2), o2);
        };
      }
      function Ft2(n4) {
        return L3(function(t2, e2) {
          var r2 = -1, s3 = e2.length, o2 = s3 > 1 ? e2[s3 - 1] : i3, f4 = s3 > 2 ? e2[2] : i3;
          for (o2 = n4.length > 3 && typeof o2 == "function" ? (s3--, o2) : i3, f4 && rn2(e2[0], e2[1], f4) && (o2 = s3 < 3 ? i3 : o2, s3 = 1), t2 = M3(t2); ++r2 < s3; ) {
            var c2 = e2[r2];
            c2 && n4(t2, c2, r2, o2);
          }
          return t2;
        });
      }
      function vu(n4, t2) {
        return function(e2, r2) {
          if (e2 == null)
            return e2;
          if (!an2(e2))
            return n4(e2, r2);
          for (var s3 = e2.length, o2 = t2 ? s3 : -1, f4 = M3(e2); (t2 ? o2-- : ++o2 < s3) && r2(f4[o2], o2, f4) !== false; )
            ;
          return e2;
        };
      }
      function _u(n4) {
        return function(t2, e2, r2) {
          for (var s3 = -1, o2 = M3(t2), f4 = r2(t2), c2 = f4.length; c2--; ) {
            var l2 = f4[n4 ? c2 : ++s3];
            if (e2(o2[l2], l2, o2) === false)
              break;
          }
          return t2;
        };
      }
      function Jc2(n4, t2, e2) {
        var r2 = t2 & vn2, s3 = ce2(n4);
        function o2() {
          var f4 = this && this !== k3 && this instanceof o2 ? s3 : n4;
          return f4.apply(r2 ? e2 : this, arguments);
        }
        return o2;
      }
      function mu(n4) {
        return function(t2) {
          t2 = W2(t2);
          var e2 = Lt2(t2) ? On(t2) : i3, r2 = e2 ? e2[0] : t2.charAt(0), s3 = e2 ? ut2(e2, 1).join("") : t2.slice(1);
          return r2[n4]() + s3;
        };
      }
      function Mt2(n4) {
        return function(t2) {
          return Hr(va2(ga(t2).replace(Uo, "")), n4, "");
        };
      }
      function ce2(n4) {
        return function() {
          var t2 = arguments;
          switch (t2.length) {
            case 0:
              return new n4();
            case 1:
              return new n4(t2[0]);
            case 2:
              return new n4(t2[0], t2[1]);
            case 3:
              return new n4(t2[0], t2[1], t2[2]);
            case 4:
              return new n4(t2[0], t2[1], t2[2], t2[3]);
            case 5:
              return new n4(t2[0], t2[1], t2[2], t2[3], t2[4]);
            case 6:
              return new n4(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]);
            case 7:
              return new n4(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6]);
          }
          var e2 = Wt2(n4.prototype), r2 = n4.apply(e2, t2);
          return K3(r2) ? r2 : e2;
        };
      }
      function Xc2(n4, t2, e2) {
        var r2 = ce2(n4);
        function s3() {
          for (var o2 = arguments.length, f4 = p3(o2), c2 = o2, l2 = qt2(s3); c2--; )
            f4[c2] = arguments[c2];
          var v4 = o2 < 3 && f4[0] !== l2 && f4[o2 - 1] !== l2 ? [] : tt2(f4, l2);
          if (o2 -= v4.length, o2 < e2)
            return Iu(n4, t2, Xe2, s3.placeholder, i3, f4, v4, i3, i3, e2 - o2);
          var _3 = this && this !== k3 && this instanceof s3 ? r2 : n4;
          return cn2(_3, this, f4);
        }
        return s3;
      }
      function wu(n4) {
        return function(t2, e2, r2) {
          var s3 = M3(t2);
          if (!an2(t2)) {
            var o2 = x2(e2, 3);
            t2 = V3(t2), e2 = function(c2) {
              return o2(s3[c2], c2, s3);
            };
          }
          var f4 = n4(t2, e2, r2);
          return f4 > -1 ? s3[o2 ? t2[f4] : f4] : i3;
        };
      }
      function Pu(n4) {
        return Yn(function(t2) {
          var e2 = t2.length, r2 = e2, s3 = Pn.prototype.thru;
          for (n4 && t2.reverse(); r2--; ) {
            var o2 = t2[r2];
            if (typeof o2 != "function")
              throw new wn($2);
            if (s3 && !f4 && je2(o2) == "wrapper")
              var f4 = new Pn([], true);
          }
          for (r2 = f4 ? r2 : e2; ++r2 < e2; ) {
            o2 = t2[r2];
            var c2 = je2(o2), l2 = c2 == "wrapper" ? di2(o2) : i3;
            l2 && mi2(l2[0]) && l2[1] == (Mn2 | Dn2 | Hn2 | Kt2) && !l2[4].length && l2[9] == 1 ? f4 = f4[je2(l2[0])].apply(f4, l2[3]) : f4 = o2.length == 1 && mi2(o2) ? f4[c2]() : f4.thru(o2);
          }
          return function() {
            var v4 = arguments, _3 = v4[0];
            if (f4 && v4.length == 1 && R3(_3))
              return f4.plant(_3).value();
            for (var m2 = 0, w3 = e2 ? t2[m2].apply(this, v4) : _3; ++m2 < e2; )
              w3 = t2[m2].call(this, w3);
            return w3;
          };
        });
      }
      function Xe2(n4, t2, e2, r2, s3, o2, f4, c2, l2, v4) {
        var _3 = t2 & Mn2, m2 = t2 & vn2, w3 = t2 & ct2, I3 = t2 & (Dn2 | yt2), E3 = t2 & dr2, T2 = w3 ? i3 : ce2(n4);
        function y3() {
          for (var D2 = arguments.length, N10 = p3(D2), dn2 = D2; dn2--; )
            N10[dn2] = arguments[dn2];
          if (I3)
            var sn2 = qt2(y3), gn2 = af2(N10, sn2);
          if (r2 && (N10 = du(N10, r2, s3, I3)), o2 && (N10 = gu(N10, o2, f4, I3)), D2 -= gn2, I3 && D2 < v4) {
            var J2 = tt2(N10, sn2);
            return Iu(n4, t2, Xe2, y3.placeholder, e2, N10, J2, c2, l2, v4 - D2);
          }
          var Tn = m2 ? e2 : this, Qn2 = w3 ? Tn[n4] : n4;
          return D2 = N10.length, c2 ? N10 = gh2(N10, c2) : E3 && D2 > 1 && N10.reverse(), _3 && l2 < D2 && (N10.length = l2), this && this !== k3 && this instanceof y3 && (Qn2 = T2 || ce2(Qn2)), Qn2.apply(Tn, N10);
        }
        return y3;
      }
      function Au(n4, t2) {
        return function(e2, r2) {
          return Ic2(e2, n4, t2(r2), {});
        };
      }
      function Qe2(n4, t2) {
        return function(e2, r2) {
          var s3;
          if (e2 === i3 && r2 === i3)
            return t2;
          if (e2 !== i3 && (s3 = e2), r2 !== i3) {
            if (s3 === i3)
              return r2;
            typeof e2 == "string" || typeof r2 == "string" ? (e2 = ln2(e2), r2 = ln2(r2)) : (e2 = uu(e2), r2 = uu(r2)), s3 = n4(e2, r2);
          }
          return s3;
        };
      }
      function ci2(n4) {
        return Yn(function(t2) {
          return t2 = G2(t2, hn2(x2())), L3(function(e2) {
            var r2 = this;
            return n4(t2, function(s3) {
              return cn2(s3, r2, e2);
            });
          });
        });
      }
      function Ve2(n4, t2) {
        t2 = t2 === i3 ? " " : ln2(t2);
        var e2 = t2.length;
        if (e2 < 2)
          return e2 ? ri2(t2, n4) : t2;
        var r2 = ri2(t2, Ue2(n4 / Dt2(t2)));
        return Lt2(t2) ? ut2(On(r2), 0, n4).join("") : r2.slice(0, n4);
      }
      function Qc2(n4, t2, e2, r2) {
        var s3 = t2 & vn2, o2 = ce2(n4);
        function f4() {
          for (var c2 = -1, l2 = arguments.length, v4 = -1, _3 = r2.length, m2 = p3(_3 + l2), w3 = this && this !== k3 && this instanceof f4 ? o2 : n4; ++v4 < _3; )
            m2[v4] = r2[v4];
          for (; l2--; )
            m2[v4++] = arguments[++c2];
          return cn2(w3, s3 ? e2 : this, m2);
        }
        return f4;
      }
      function Cu(n4) {
        return function(t2, e2, r2) {
          return r2 && typeof r2 != "number" && rn2(t2, e2, r2) && (e2 = r2 = i3), t2 = Xn2(t2), e2 === i3 ? (e2 = t2, t2 = 0) : e2 = Xn2(e2), r2 = r2 === i3 ? t2 < e2 ? 1 : -1 : Xn2(r2), Nc2(t2, e2, r2, n4);
        };
      }
      function ke2(n4) {
        return function(t2, e2) {
          return typeof t2 == "string" && typeof e2 == "string" || (t2 = xn2(t2), e2 = xn2(e2)), n4(t2, e2);
        };
      }
      function Iu(n4, t2, e2, r2, s3, o2, f4, c2, l2, v4) {
        var _3 = t2 & Dn2, m2 = _3 ? f4 : i3, w3 = _3 ? i3 : f4, I3 = _3 ? o2 : i3, E3 = _3 ? i3 : o2;
        t2 |= _3 ? Hn2 : St2, t2 &= ~(_3 ? St2 : Hn2), t2 & qi2 || (t2 &= ~(vn2 | ct2));
        var T2 = [n4, t2, s3, I3, m2, E3, w3, c2, l2, v4], y3 = e2.apply(i3, T2);
        return mi2(n4) && Nu(y3, T2), y3.placeholder = r2, $u(y3, n4, t2);
      }
      function hi2(n4) {
        var t2 = X2[n4];
        return function(e2, r2) {
          if (e2 = xn2(e2), r2 = r2 == null ? 0 : nn2(b4(r2), 292), r2 && $s2(e2)) {
            var s3 = (W2(e2) + "e").split("e"), o2 = t2(s3[0] + "e" + (+s3[1] + r2));
            return s3 = (W2(o2) + "e").split("e"), +(s3[0] + "e" + (+s3[1] - r2));
          }
          return t2(e2);
        };
      }
      var Vc2 = $t2 && 1 / Se2(new $t2([, -0]))[1] == ht2 ? function(n4) {
        return new $t2(n4);
      } : Di2;
      function xu(n4) {
        return function(t2) {
          var e2 = tn2(t2);
          return e2 == yn2 ? qr(t2) : e2 == Sn ? df2(t2) : uf2(t2, n4(t2));
        };
      }
      function Kn2(n4, t2, e2, r2, s3, o2, f4, c2) {
        var l2 = t2 & ct2;
        if (!l2 && typeof n4 != "function")
          throw new wn($2);
        var v4 = r2 ? r2.length : 0;
        if (v4 || (t2 &= ~(Hn2 | St2), r2 = s3 = i3), f4 = f4 === i3 ? f4 : Q3(b4(f4), 0), c2 = c2 === i3 ? c2 : b4(c2), v4 -= s3 ? s3.length : 0, t2 & St2) {
          var _3 = r2, m2 = s3;
          r2 = s3 = i3;
        }
        var w3 = l2 ? i3 : di2(n4), I3 = [n4, t2, e2, r2, s3, _3, m2, o2, f4, c2];
        if (w3 && lh2(I3, w3), n4 = I3[0], t2 = I3[1], e2 = I3[2], r2 = I3[3], s3 = I3[4], c2 = I3[9] = I3[9] === i3 ? l2 ? 0 : n4.length : Q3(I3[9] - v4, 0), !c2 && t2 & (Dn2 | yt2) && (t2 &= ~(Dn2 | yt2)), !t2 || t2 == vn2)
          var E3 = Jc2(n4, t2, e2);
        else
          t2 == Dn2 || t2 == yt2 ? E3 = Xc2(n4, t2, c2) : (t2 == Hn2 || t2 == (vn2 | Hn2)) && !s3.length ? E3 = Qc2(n4, t2, e2, r2) : E3 = Xe2.apply(i3, I3);
        var T2 = w3 ? iu : Nu;
        return $u(T2(E3, I3), n4, t2);
      }
      function Eu(n4, t2, e2, r2) {
        return n4 === i3 || bn2(n4, Nt2[e2]) && !F2.call(r2, e2) ? t2 : n4;
      }
      function yu(n4, t2, e2, r2, s3, o2) {
        return K3(n4) && K3(t2) && (o2.set(t2, n4), Ke2(n4, t2, i3, yu, o2), o2.delete(t2)), n4;
      }
      function kc2(n4) {
        return pe2(n4) ? i3 : n4;
      }
      function Su(n4, t2, e2, r2, s3, o2) {
        var f4 = e2 & Et2, c2 = n4.length, l2 = t2.length;
        if (c2 != l2 && !(f4 && l2 > c2))
          return false;
        var v4 = o2.get(n4), _3 = o2.get(t2);
        if (v4 && _3)
          return v4 == t2 && _3 == n4;
        var m2 = -1, w3 = true, I3 = e2 & ve2 ? new gt2() : i3;
        for (o2.set(n4, t2), o2.set(t2, n4); ++m2 < c2; ) {
          var E3 = n4[m2], T2 = t2[m2];
          if (r2)
            var y3 = f4 ? r2(T2, E3, m2, t2, n4, o2) : r2(E3, T2, m2, n4, t2, o2);
          if (y3 !== i3) {
            if (y3)
              continue;
            w3 = false;
            break;
          }
          if (I3) {
            if (!Nr2(t2, function(D2, N10) {
              if (!jt2(I3, N10) && (E3 === D2 || s3(E3, D2, e2, r2, o2)))
                return I3.push(N10);
            })) {
              w3 = false;
              break;
            }
          } else if (!(E3 === T2 || s3(E3, T2, e2, r2, o2))) {
            w3 = false;
            break;
          }
        }
        return o2.delete(n4), o2.delete(t2), w3;
      }
      function jc2(n4, t2, e2, r2, s3, o2, f4) {
        switch (e2) {
          case Rt2:
            if (n4.byteLength != t2.byteLength || n4.byteOffset != t2.byteOffset)
              return false;
            n4 = n4.buffer, t2 = t2.buffer;
          case kt2:
            return !(n4.byteLength != t2.byteLength || !o2(new De2(n4), new De2(t2)));
          case Yt2:
          case Zt2:
          case Jt2:
            return bn2(+n4, +t2);
          case we2:
            return n4.name == t2.name && n4.message == t2.message;
          case Xt2:
          case Qt2:
            return n4 == t2 + "";
          case yn2:
            var c2 = qr;
          case Sn:
            var l2 = r2 & Et2;
            if (c2 || (c2 = Se2), n4.size != t2.size && !l2)
              return false;
            var v4 = f4.get(n4);
            if (v4)
              return v4 == t2;
            r2 |= ve2, f4.set(n4, t2);
            var _3 = Su(c2(n4), c2(t2), r2, s3, o2, f4);
            return f4.delete(n4), _3;
          case Ae2:
            if (ie2)
              return ie2.call(n4) == ie2.call(t2);
        }
        return false;
      }
      function nh2(n4, t2, e2, r2, s3, o2) {
        var f4 = e2 & Et2, c2 = li2(n4), l2 = c2.length, v4 = li2(t2), _3 = v4.length;
        if (l2 != _3 && !f4)
          return false;
        for (var m2 = l2; m2--; ) {
          var w3 = c2[m2];
          if (!(f4 ? w3 in t2 : F2.call(t2, w3)))
            return false;
        }
        var I3 = o2.get(n4), E3 = o2.get(t2);
        if (I3 && E3)
          return I3 == t2 && E3 == n4;
        var T2 = true;
        o2.set(n4, t2), o2.set(t2, n4);
        for (var y3 = f4; ++m2 < l2; ) {
          w3 = c2[m2];
          var D2 = n4[w3], N10 = t2[w3];
          if (r2)
            var dn2 = f4 ? r2(N10, D2, w3, t2, n4, o2) : r2(D2, N10, w3, n4, t2, o2);
          if (!(dn2 === i3 ? D2 === N10 || s3(D2, N10, e2, r2, o2) : dn2)) {
            T2 = false;
            break;
          }
          y3 || (y3 = w3 == "constructor");
        }
        if (T2 && !y3) {
          var sn2 = n4.constructor, gn2 = t2.constructor;
          sn2 != gn2 && "constructor" in n4 && "constructor" in t2 && !(typeof sn2 == "function" && sn2 instanceof sn2 && typeof gn2 == "function" && gn2 instanceof gn2) && (T2 = false);
        }
        return o2.delete(n4), o2.delete(t2), T2;
      }
      function Yn(n4) {
        return Pi2(Du(n4, i3, Bu), n4 + "");
      }
      function li2(n4) {
        return Zs2(n4, V3, vi2);
      }
      function pi2(n4) {
        return Zs2(n4, on3, Ou);
      }
      var di2 = Fe2 ? function(n4) {
        return Fe2.get(n4);
      } : Di2;
      function je2(n4) {
        for (var t2 = n4.name + "", e2 = Ut2[t2], r2 = F2.call(Ut2, t2) ? e2.length : 0; r2--; ) {
          var s3 = e2[r2], o2 = s3.func;
          if (o2 == null || o2 == n4)
            return s3.name;
        }
        return t2;
      }
      function qt2(n4) {
        var t2 = F2.call(a3, "placeholder") ? a3 : n4;
        return t2.placeholder;
      }
      function x2() {
        var n4 = a3.iteratee || Ti2;
        return n4 = n4 === Ti2 ? Qs2 : n4, arguments.length ? n4(arguments[0], arguments[1]) : n4;
      }
      function nr2(n4, t2) {
        var e2 = n4.__data__;
        return oh2(t2) ? e2[typeof t2 == "string" ? "string" : "hash"] : e2.map;
      }
      function gi2(n4) {
        for (var t2 = V3(n4), e2 = t2.length; e2--; ) {
          var r2 = t2[e2], s3 = n4[r2];
          t2[e2] = [r2, s3, Tu(s3)];
        }
        return t2;
      }
      function mt2(n4, t2) {
        var e2 = hf2(n4, t2);
        return Xs2(e2) ? e2 : i3;
      }
      function th2(n4) {
        var t2 = F2.call(n4, pt2), e2 = n4[pt2];
        try {
          n4[pt2] = i3;
          var r2 = true;
        } catch {
        }
        var s3 = Te2.call(n4);
        return r2 && (t2 ? n4[pt2] = e2 : delete n4[pt2]), s3;
      }
      var vi2 = Gr ? function(n4) {
        return n4 == null ? [] : (n4 = M3(n4), jn(Gr(n4), function(t2) {
          return Hs2.call(n4, t2);
        }));
      } : Hi2, Ou = Gr ? function(n4) {
        for (var t2 = []; n4; )
          nt2(t2, vi2(n4)), n4 = He2(n4);
        return t2;
      } : Hi2, tn2 = en2;
      (zr2 && tn2(new zr2(new ArrayBuffer(1))) != Rt2 || te3 && tn2(new te3()) != yn2 || Kr && tn2(Kr.resolve()) != zi2 || $t2 && tn2(new $t2()) != Sn || ee2 && tn2(new ee2()) != Vt2) && (tn2 = function(n4) {
        var t2 = en2(n4), e2 = t2 == qn2 ? n4.constructor : i3, r2 = e2 ? wt2(e2) : "";
        if (r2)
          switch (r2) {
            case Uf2:
              return Rt2;
            case Wf2:
              return yn2;
            case Ff2:
              return zi2;
            case Mf2:
              return Sn;
            case qf2:
              return Vt2;
          }
        return t2;
      });
      function eh2(n4, t2, e2) {
        for (var r2 = -1, s3 = e2.length; ++r2 < s3; ) {
          var o2 = e2[r2], f4 = o2.size;
          switch (o2.type) {
            case "drop":
              n4 += f4;
              break;
            case "dropRight":
              t2 -= f4;
              break;
            case "take":
              t2 = nn2(t2, n4 + f4);
              break;
            case "takeRight":
              n4 = Q3(n4, t2 - f4);
              break;
          }
        }
        return { start: n4, end: t2 };
      }
      function rh2(n4) {
        var t2 = n4.match(ao);
        return t2 ? t2[1].split(oo) : [];
      }
      function Ru(n4, t2, e2) {
        t2 = st2(t2, n4);
        for (var r2 = -1, s3 = t2.length, o2 = false; ++r2 < s3; ) {
          var f4 = Wn2(t2[r2]);
          if (!(o2 = n4 != null && e2(n4, f4)))
            break;
          n4 = n4[f4];
        }
        return o2 || ++r2 != s3 ? o2 : (s3 = n4 == null ? 0 : n4.length, !!s3 && ar2(s3) && Zn(f4, s3) && (R3(n4) || Pt2(n4)));
      }
      function ih2(n4) {
        var t2 = n4.length, e2 = new n4.constructor(t2);
        return t2 && typeof n4[0] == "string" && F2.call(n4, "index") && (e2.index = n4.index, e2.input = n4.input), e2;
      }
      function bu(n4) {
        return typeof n4.constructor == "function" && !he2(n4) ? Wt2(He2(n4)) : {};
      }
      function sh2(n4, t2, e2) {
        var r2 = n4.constructor;
        switch (t2) {
          case kt2:
            return fi2(n4);
          case Yt2:
          case Zt2:
            return new r2(+n4);
          case Rt2:
            return Bc2(n4, e2);
          case gr2:
          case vr2:
          case _r2:
          case mr2:
          case wr:
          case Pr2:
          case Ar2:
          case Cr2:
          case Ir2:
            return lu(n4, e2);
          case yn2:
            return new r2();
          case Jt2:
          case Qt2:
            return new r2(n4);
          case Xt2:
            return Gc2(n4);
          case Sn:
            return new r2();
          case Ae2:
            return zc2(n4);
        }
      }
      function uh2(n4, t2) {
        var e2 = t2.length;
        if (!e2)
          return n4;
        var r2 = e2 - 1;
        return t2[r2] = (e2 > 1 ? "& " : "") + t2[r2], t2 = t2.join(e2 > 2 ? ", " : " "), n4.replace(uo, `{
/* [wrapped with ` + t2 + `] */
`);
      }
      function ah2(n4) {
        return R3(n4) || Pt2(n4) || !!(Ns2 && n4 && n4[Ns2]);
      }
      function Zn(n4, t2) {
        var e2 = typeof n4;
        return t2 = t2 ?? kn2, !!t2 && (e2 == "number" || e2 != "symbol" && mo.test(n4)) && n4 > -1 && n4 % 1 == 0 && n4 < t2;
      }
      function rn2(n4, t2, e2) {
        if (!K3(e2))
          return false;
        var r2 = typeof t2;
        return (r2 == "number" ? an2(e2) && Zn(t2, e2.length) : r2 == "string" && t2 in e2) ? bn2(e2[t2], n4) : false;
      }
      function _i(n4, t2) {
        if (R3(n4))
          return false;
        var e2 = typeof n4;
        return e2 == "number" || e2 == "symbol" || e2 == "boolean" || n4 == null || pn2(n4) ? true : eo.test(n4) || !to.test(n4) || t2 != null && n4 in M3(t2);
      }
      function oh2(n4) {
        var t2 = typeof n4;
        return t2 == "string" || t2 == "number" || t2 == "symbol" || t2 == "boolean" ? n4 !== "__proto__" : n4 === null;
      }
      function mi2(n4) {
        var t2 = je2(n4), e2 = a3[t2];
        if (typeof e2 != "function" || !(t2 in H3.prototype))
          return false;
        if (n4 === e2)
          return true;
        var r2 = di2(e2);
        return !!r2 && n4 === r2[0];
      }
      function fh2(n4) {
        return !!Ts2 && Ts2 in n4;
      }
      var ch2 = Re2 ? Jn2 : Ni2;
      function he2(n4) {
        var t2 = n4 && n4.constructor, e2 = typeof t2 == "function" && t2.prototype || Nt2;
        return n4 === e2;
      }
      function Tu(n4) {
        return n4 === n4 && !K3(n4);
      }
      function Lu(n4, t2) {
        return function(e2) {
          return e2 == null ? false : e2[n4] === t2 && (t2 !== i3 || n4 in M3(e2));
        };
      }
      function hh2(n4) {
        var t2 = sr2(n4, function(r2) {
          return e2.size === pr2 && e2.clear(), r2;
        }), e2 = t2.cache;
        return t2;
      }
      function lh2(n4, t2) {
        var e2 = n4[1], r2 = t2[1], s3 = e2 | r2, o2 = s3 < (vn2 | ct2 | Mn2), f4 = r2 == Mn2 && e2 == Dn2 || r2 == Mn2 && e2 == Kt2 && n4[7].length <= t2[8] || r2 == (Mn2 | Kt2) && t2[7].length <= t2[8] && e2 == Dn2;
        if (!(o2 || f4))
          return n4;
        r2 & vn2 && (n4[2] = t2[2], s3 |= e2 & vn2 ? 0 : qi2);
        var c2 = t2[3];
        if (c2) {
          var l2 = n4[3];
          n4[3] = l2 ? du(l2, c2, t2[4]) : c2, n4[4] = l2 ? tt2(n4[3], It2) : t2[4];
        }
        return c2 = t2[5], c2 && (l2 = n4[5], n4[5] = l2 ? gu(l2, c2, t2[6]) : c2, n4[6] = l2 ? tt2(n4[5], It2) : t2[6]), c2 = t2[7], c2 && (n4[7] = c2), r2 & Mn2 && (n4[8] = n4[8] == null ? t2[8] : nn2(n4[8], t2[8])), n4[9] == null && (n4[9] = t2[9]), n4[0] = t2[0], n4[1] = s3, n4;
      }
      function ph2(n4) {
        var t2 = [];
        if (n4 != null)
          for (var e2 in M3(n4))
            t2.push(e2);
        return t2;
      }
      function dh2(n4) {
        return Te2.call(n4);
      }
      function Du(n4, t2, e2) {
        return t2 = Q3(t2 === i3 ? n4.length - 1 : t2, 0), function() {
          for (var r2 = arguments, s3 = -1, o2 = Q3(r2.length - t2, 0), f4 = p3(o2); ++s3 < o2; )
            f4[s3] = r2[t2 + s3];
          s3 = -1;
          for (var c2 = p3(t2 + 1); ++s3 < t2; )
            c2[s3] = r2[s3];
          return c2[t2] = e2(f4), cn2(n4, this, c2);
        };
      }
      function Hu(n4, t2) {
        return t2.length < 2 ? n4 : _t2(n4, Cn(t2, 0, -1));
      }
      function gh2(n4, t2) {
        for (var e2 = n4.length, r2 = nn2(t2.length, e2), s3 = un2(n4); r2--; ) {
          var o2 = t2[r2];
          n4[r2] = Zn(o2, e2) ? s3[o2] : i3;
        }
        return n4;
      }
      function wi2(n4, t2) {
        if (!(t2 === "constructor" && typeof n4[t2] == "function") && t2 != "__proto__")
          return n4[t2];
      }
      var Nu = Uu(iu), le2 = bf2 || function(n4, t2) {
        return k3.setTimeout(n4, t2);
      }, Pi2 = Uu(Wc2);
      function $u(n4, t2, e2) {
        var r2 = t2 + "";
        return Pi2(n4, uh2(r2, vh2(rh2(r2), e2)));
      }
      function Uu(n4) {
        var t2 = 0, e2 = 0;
        return function() {
          var r2 = Hf2(), s3 = Na2 - (r2 - e2);
          if (e2 = r2, s3 > 0) {
            if (++t2 >= Ha2)
              return arguments[0];
          } else
            t2 = 0;
          return n4.apply(i3, arguments);
        };
      }
      function tr3(n4, t2) {
        var e2 = -1, r2 = n4.length, s3 = r2 - 1;
        for (t2 = t2 === i3 ? r2 : t2; ++e2 < t2; ) {
          var o2 = ei2(e2, s3), f4 = n4[o2];
          n4[o2] = n4[e2], n4[e2] = f4;
        }
        return n4.length = t2, n4;
      }
      var Wu = hh2(function(n4) {
        var t2 = [];
        return n4.charCodeAt(0) === 46 && t2.push(""), n4.replace(ro, function(e2, r2, s3, o2) {
          t2.push(s3 ? o2.replace(ho, "$1") : r2 || e2);
        }), t2;
      });
      function Wn2(n4) {
        if (typeof n4 == "string" || pn2(n4))
          return n4;
        var t2 = n4 + "";
        return t2 == "0" && 1 / n4 == -ht2 ? "-0" : t2;
      }
      function wt2(n4) {
        if (n4 != null) {
          try {
            return be2.call(n4);
          } catch {
          }
          try {
            return n4 + "";
          } catch {
          }
        }
        return "";
      }
      function vh2(n4, t2) {
        return mn2(qa2, function(e2) {
          var r2 = "_." + e2[0];
          t2 & e2[1] && !Ee2(n4, r2) && n4.push(r2);
        }), n4.sort();
      }
      function Fu(n4) {
        if (n4 instanceof H3)
          return n4.clone();
        var t2 = new Pn(n4.__wrapped__, n4.__chain__);
        return t2.__actions__ = un2(n4.__actions__), t2.__index__ = n4.__index__, t2.__values__ = n4.__values__, t2;
      }
      function _h(n4, t2, e2) {
        (e2 ? rn2(n4, t2, e2) : t2 === i3) ? t2 = 1 : t2 = Q3(b4(t2), 0);
        var r2 = n4 == null ? 0 : n4.length;
        if (!r2 || t2 < 1)
          return [];
        for (var s3 = 0, o2 = 0, f4 = p3(Ue2(r2 / t2)); s3 < r2; )
          f4[o2++] = Cn(n4, s3, s3 += t2);
        return f4;
      }
      function mh2(n4) {
        for (var t2 = -1, e2 = n4 == null ? 0 : n4.length, r2 = 0, s3 = []; ++t2 < e2; ) {
          var o2 = n4[t2];
          o2 && (s3[r2++] = o2);
        }
        return s3;
      }
      function wh2() {
        var n4 = arguments.length;
        if (!n4)
          return [];
        for (var t2 = p3(n4 - 1), e2 = arguments[0], r2 = n4; r2--; )
          t2[r2 - 1] = arguments[r2];
        return nt2(R3(e2) ? un2(e2) : [e2], j2(t2, 1));
      }
      var Ph2 = L3(function(n4, t2) {
        return Z2(n4) ? ue3(n4, j2(t2, 1, Z2, true)) : [];
      }), Ah2 = L3(function(n4, t2) {
        var e2 = In(t2);
        return Z2(e2) && (e2 = i3), Z2(n4) ? ue3(n4, j2(t2, 1, Z2, true), x2(e2, 2)) : [];
      }), Ch2 = L3(function(n4, t2) {
        var e2 = In(t2);
        return Z2(e2) && (e2 = i3), Z2(n4) ? ue3(n4, j2(t2, 1, Z2, true), i3, e2) : [];
      });
      function Ih2(n4, t2, e2) {
        var r2 = n4 == null ? 0 : n4.length;
        return r2 ? (t2 = e2 || t2 === i3 ? 1 : b4(t2), Cn(n4, t2 < 0 ? 0 : t2, r2)) : [];
      }
      function xh2(n4, t2, e2) {
        var r2 = n4 == null ? 0 : n4.length;
        return r2 ? (t2 = e2 || t2 === i3 ? 1 : b4(t2), t2 = r2 - t2, Cn(n4, 0, t2 < 0 ? 0 : t2)) : [];
      }
      function Eh2(n4, t2) {
        return n4 && n4.length ? Ze2(n4, x2(t2, 3), true, true) : [];
      }
      function yh2(n4, t2) {
        return n4 && n4.length ? Ze2(n4, x2(t2, 3), true) : [];
      }
      function Sh2(n4, t2, e2, r2) {
        var s3 = n4 == null ? 0 : n4.length;
        return s3 ? (e2 && typeof e2 != "number" && rn2(n4, t2, e2) && (e2 = 0, r2 = s3), wc2(n4, t2, e2, r2)) : [];
      }
      function Mu(n4, t2, e2) {
        var r2 = n4 == null ? 0 : n4.length;
        if (!r2)
          return -1;
        var s3 = e2 == null ? 0 : b4(e2);
        return s3 < 0 && (s3 = Q3(r2 + s3, 0)), ye2(n4, x2(t2, 3), s3);
      }
      function qu(n4, t2, e2) {
        var r2 = n4 == null ? 0 : n4.length;
        if (!r2)
          return -1;
        var s3 = r2 - 1;
        return e2 !== i3 && (s3 = b4(e2), s3 = e2 < 0 ? Q3(r2 + s3, 0) : nn2(s3, r2 - 1)), ye2(n4, x2(t2, 3), s3, true);
      }
      function Bu(n4) {
        var t2 = n4 == null ? 0 : n4.length;
        return t2 ? j2(n4, 1) : [];
      }
      function Oh2(n4) {
        var t2 = n4 == null ? 0 : n4.length;
        return t2 ? j2(n4, ht2) : [];
      }
      function Rh2(n4, t2) {
        var e2 = n4 == null ? 0 : n4.length;
        return e2 ? (t2 = t2 === i3 ? 1 : b4(t2), j2(n4, t2)) : [];
      }
      function bh2(n4) {
        for (var t2 = -1, e2 = n4 == null ? 0 : n4.length, r2 = {}; ++t2 < e2; ) {
          var s3 = n4[t2];
          r2[s3[0]] = s3[1];
        }
        return r2;
      }
      function Gu(n4) {
        return n4 && n4.length ? n4[0] : i3;
      }
      function Th2(n4, t2, e2) {
        var r2 = n4 == null ? 0 : n4.length;
        if (!r2)
          return -1;
        var s3 = e2 == null ? 0 : b4(e2);
        return s3 < 0 && (s3 = Q3(r2 + s3, 0)), Tt2(n4, t2, s3);
      }
      function Lh2(n4) {
        var t2 = n4 == null ? 0 : n4.length;
        return t2 ? Cn(n4, 0, -1) : [];
      }
      var Dh2 = L3(function(n4) {
        var t2 = G2(n4, ai2);
        return t2.length && t2[0] === n4[0] ? Vr(t2) : [];
      }), Hh2 = L3(function(n4) {
        var t2 = In(n4), e2 = G2(n4, ai2);
        return t2 === In(e2) ? t2 = i3 : e2.pop(), e2.length && e2[0] === n4[0] ? Vr(e2, x2(t2, 2)) : [];
      }), Nh2 = L3(function(n4) {
        var t2 = In(n4), e2 = G2(n4, ai2);
        return t2 = typeof t2 == "function" ? t2 : i3, t2 && e2.pop(), e2.length && e2[0] === n4[0] ? Vr(e2, i3, t2) : [];
      });
      function $h2(n4, t2) {
        return n4 == null ? "" : Lf2.call(n4, t2);
      }
      function In(n4) {
        var t2 = n4 == null ? 0 : n4.length;
        return t2 ? n4[t2 - 1] : i3;
      }
      function Uh2(n4, t2, e2) {
        var r2 = n4 == null ? 0 : n4.length;
        if (!r2)
          return -1;
        var s3 = r2;
        return e2 !== i3 && (s3 = b4(e2), s3 = s3 < 0 ? Q3(r2 + s3, 0) : nn2(s3, r2 - 1)), t2 === t2 ? vf2(n4, t2, s3) : ye2(n4, Is2, s3, true);
      }
      function Wh2(n4, t2) {
        return n4 && n4.length ? nu(n4, b4(t2)) : i3;
      }
      var Fh2 = L3(zu);
      function zu(n4, t2) {
        return n4 && n4.length && t2 && t2.length ? ti2(n4, t2) : n4;
      }
      function Mh2(n4, t2, e2) {
        return n4 && n4.length && t2 && t2.length ? ti2(n4, t2, x2(e2, 2)) : n4;
      }
      function qh2(n4, t2, e2) {
        return n4 && n4.length && t2 && t2.length ? ti2(n4, t2, i3, e2) : n4;
      }
      var Bh2 = Yn(function(n4, t2) {
        var e2 = n4 == null ? 0 : n4.length, r2 = Zr(n4, t2);
        return ru(n4, G2(t2, function(s3) {
          return Zn(s3, e2) ? +s3 : s3;
        }).sort(pu)), r2;
      });
      function Gh2(n4, t2) {
        var e2 = [];
        if (!(n4 && n4.length))
          return e2;
        var r2 = -1, s3 = [], o2 = n4.length;
        for (t2 = x2(t2, 3); ++r2 < o2; ) {
          var f4 = n4[r2];
          t2(f4, r2, n4) && (e2.push(f4), s3.push(r2));
        }
        return ru(n4, s3), e2;
      }
      function Ai2(n4) {
        return n4 == null ? n4 : $f2.call(n4);
      }
      function zh2(n4, t2, e2) {
        var r2 = n4 == null ? 0 : n4.length;
        return r2 ? (e2 && typeof e2 != "number" && rn2(n4, t2, e2) ? (t2 = 0, e2 = r2) : (t2 = t2 == null ? 0 : b4(t2), e2 = e2 === i3 ? r2 : b4(e2)), Cn(n4, t2, e2)) : [];
      }
      function Kh2(n4, t2) {
        return Ye2(n4, t2);
      }
      function Yh2(n4, t2, e2) {
        return ii2(n4, t2, x2(e2, 2));
      }
      function Zh2(n4, t2) {
        var e2 = n4 == null ? 0 : n4.length;
        if (e2) {
          var r2 = Ye2(n4, t2);
          if (r2 < e2 && bn2(n4[r2], t2))
            return r2;
        }
        return -1;
      }
      function Jh2(n4, t2) {
        return Ye2(n4, t2, true);
      }
      function Xh2(n4, t2, e2) {
        return ii2(n4, t2, x2(e2, 2), true);
      }
      function Qh2(n4, t2) {
        var e2 = n4 == null ? 0 : n4.length;
        if (e2) {
          var r2 = Ye2(n4, t2, true) - 1;
          if (bn2(n4[r2], t2))
            return r2;
        }
        return -1;
      }
      function Vh2(n4) {
        return n4 && n4.length ? su(n4) : [];
      }
      function kh2(n4, t2) {
        return n4 && n4.length ? su(n4, x2(t2, 2)) : [];
      }
      function jh2(n4) {
        var t2 = n4 == null ? 0 : n4.length;
        return t2 ? Cn(n4, 1, t2) : [];
      }
      function nl2(n4, t2, e2) {
        return n4 && n4.length ? (t2 = e2 || t2 === i3 ? 1 : b4(t2), Cn(n4, 0, t2 < 0 ? 0 : t2)) : [];
      }
      function tl2(n4, t2, e2) {
        var r2 = n4 == null ? 0 : n4.length;
        return r2 ? (t2 = e2 || t2 === i3 ? 1 : b4(t2), t2 = r2 - t2, Cn(n4, t2 < 0 ? 0 : t2, r2)) : [];
      }
      function el2(n4, t2) {
        return n4 && n4.length ? Ze2(n4, x2(t2, 3), false, true) : [];
      }
      function rl2(n4, t2) {
        return n4 && n4.length ? Ze2(n4, x2(t2, 3)) : [];
      }
      var il2 = L3(function(n4) {
        return it2(j2(n4, 1, Z2, true));
      }), sl2 = L3(function(n4) {
        var t2 = In(n4);
        return Z2(t2) && (t2 = i3), it2(j2(n4, 1, Z2, true), x2(t2, 2));
      }), ul2 = L3(function(n4) {
        var t2 = In(n4);
        return t2 = typeof t2 == "function" ? t2 : i3, it2(j2(n4, 1, Z2, true), i3, t2);
      });
      function al2(n4) {
        return n4 && n4.length ? it2(n4) : [];
      }
      function ol2(n4, t2) {
        return n4 && n4.length ? it2(n4, x2(t2, 2)) : [];
      }
      function fl2(n4, t2) {
        return t2 = typeof t2 == "function" ? t2 : i3, n4 && n4.length ? it2(n4, i3, t2) : [];
      }
      function Ci2(n4) {
        if (!(n4 && n4.length))
          return [];
        var t2 = 0;
        return n4 = jn(n4, function(e2) {
          if (Z2(e2))
            return t2 = Q3(e2.length, t2), true;
        }), Fr2(t2, function(e2) {
          return G2(n4, $r2(e2));
        });
      }
      function Ku(n4, t2) {
        if (!(n4 && n4.length))
          return [];
        var e2 = Ci2(n4);
        return t2 == null ? e2 : G2(e2, function(r2) {
          return cn2(t2, i3, r2);
        });
      }
      var cl2 = L3(function(n4, t2) {
        return Z2(n4) ? ue3(n4, t2) : [];
      }), hl2 = L3(function(n4) {
        return ui2(jn(n4, Z2));
      }), ll2 = L3(function(n4) {
        var t2 = In(n4);
        return Z2(t2) && (t2 = i3), ui2(jn(n4, Z2), x2(t2, 2));
      }), pl2 = L3(function(n4) {
        var t2 = In(n4);
        return t2 = typeof t2 == "function" ? t2 : i3, ui2(jn(n4, Z2), i3, t2);
      }), dl2 = L3(Ci2);
      function gl2(n4, t2) {
        return fu(n4 || [], t2 || [], se2);
      }
      function vl2(n4, t2) {
        return fu(n4 || [], t2 || [], fe2);
      }
      var _l = L3(function(n4) {
        var t2 = n4.length, e2 = t2 > 1 ? n4[t2 - 1] : i3;
        return e2 = typeof e2 == "function" ? (n4.pop(), e2) : i3, Ku(n4, e2);
      });
      function Yu(n4) {
        var t2 = a3(n4);
        return t2.__chain__ = true, t2;
      }
      function ml2(n4, t2) {
        return t2(n4), n4;
      }
      function er2(n4, t2) {
        return t2(n4);
      }
      var wl2 = Yn(function(n4) {
        var t2 = n4.length, e2 = t2 ? n4[0] : 0, r2 = this.__wrapped__, s3 = function(o2) {
          return Zr(o2, n4);
        };
        return t2 > 1 || this.__actions__.length || !(r2 instanceof H3) || !Zn(e2) ? this.thru(s3) : (r2 = r2.slice(e2, +e2 + (t2 ? 1 : 0)), r2.__actions__.push({ func: er2, args: [s3], thisArg: i3 }), new Pn(r2, this.__chain__).thru(function(o2) {
          return t2 && !o2.length && o2.push(i3), o2;
        }));
      });
      function Pl() {
        return Yu(this);
      }
      function Al() {
        return new Pn(this.value(), this.__chain__);
      }
      function Cl() {
        this.__values__ === i3 && (this.__values__ = ua2(this.value()));
        var n4 = this.__index__ >= this.__values__.length, t2 = n4 ? i3 : this.__values__[this.__index__++];
        return { done: n4, value: t2 };
      }
      function Il() {
        return this;
      }
      function xl(n4) {
        for (var t2, e2 = this; e2 instanceof qe2; ) {
          var r2 = Fu(e2);
          r2.__index__ = 0, r2.__values__ = i3, t2 ? s3.__wrapped__ = r2 : t2 = r2;
          var s3 = r2;
          e2 = e2.__wrapped__;
        }
        return s3.__wrapped__ = n4, t2;
      }
      function El() {
        var n4 = this.__wrapped__;
        if (n4 instanceof H3) {
          var t2 = n4;
          return this.__actions__.length && (t2 = new H3(this)), t2 = t2.reverse(), t2.__actions__.push({ func: er2, args: [Ai2], thisArg: i3 }), new Pn(t2, this.__chain__);
        }
        return this.thru(Ai2);
      }
      function yl() {
        return ou(this.__wrapped__, this.__actions__);
      }
      var Sl = Je2(function(n4, t2, e2) {
        F2.call(n4, e2) ? ++n4[e2] : zn(n4, e2, 1);
      });
      function Ol(n4, t2, e2) {
        var r2 = R3(n4) ? As2 : mc2;
        return e2 && rn2(n4, t2, e2) && (t2 = i3), r2(n4, x2(t2, 3));
      }
      function Rl(n4, t2) {
        var e2 = R3(n4) ? jn : Ks2;
        return e2(n4, x2(t2, 3));
      }
      var bl2 = wu(Mu), Tl = wu(qu);
      function Ll(n4, t2) {
        return j2(rr2(n4, t2), 1);
      }
      function Dl(n4, t2) {
        return j2(rr2(n4, t2), ht2);
      }
      function Hl(n4, t2, e2) {
        return e2 = e2 === i3 ? 1 : b4(e2), j2(rr2(n4, t2), e2);
      }
      function Zu(n4, t2) {
        var e2 = R3(n4) ? mn2 : rt2;
        return e2(n4, x2(t2, 3));
      }
      function Ju(n4, t2) {
        var e2 = R3(n4) ? ko : zs2;
        return e2(n4, x2(t2, 3));
      }
      var Nl = Je2(function(n4, t2, e2) {
        F2.call(n4, e2) ? n4[e2].push(t2) : zn(n4, e2, [t2]);
      });
      function $l(n4, t2, e2, r2) {
        n4 = an2(n4) ? n4 : Gt2(n4), e2 = e2 && !r2 ? b4(e2) : 0;
        var s3 = n4.length;
        return e2 < 0 && (e2 = Q3(s3 + e2, 0)), or2(n4) ? e2 <= s3 && n4.indexOf(t2, e2) > -1 : !!s3 && Tt2(n4, t2, e2) > -1;
      }
      var Ul = L3(function(n4, t2, e2) {
        var r2 = -1, s3 = typeof t2 == "function", o2 = an2(n4) ? p3(n4.length) : [];
        return rt2(n4, function(f4) {
          o2[++r2] = s3 ? cn2(t2, f4, e2) : ae2(f4, t2, e2);
        }), o2;
      }), Wl = Je2(function(n4, t2, e2) {
        zn(n4, e2, t2);
      });
      function rr2(n4, t2) {
        var e2 = R3(n4) ? G2 : Vs2;
        return e2(n4, x2(t2, 3));
      }
      function Fl(n4, t2, e2, r2) {
        return n4 == null ? [] : (R3(t2) || (t2 = t2 == null ? [] : [t2]), e2 = r2 ? i3 : e2, R3(e2) || (e2 = e2 == null ? [] : [e2]), tu(n4, t2, e2));
      }
      var Ml = Je2(function(n4, t2, e2) {
        n4[e2 ? 0 : 1].push(t2);
      }, function() {
        return [[], []];
      });
      function ql2(n4, t2, e2) {
        var r2 = R3(n4) ? Hr : Es2, s3 = arguments.length < 3;
        return r2(n4, x2(t2, 4), e2, s3, rt2);
      }
      function Bl2(n4, t2, e2) {
        var r2 = R3(n4) ? jo : Es2, s3 = arguments.length < 3;
        return r2(n4, x2(t2, 4), e2, s3, zs2);
      }
      function Gl(n4, t2) {
        var e2 = R3(n4) ? jn : Ks2;
        return e2(n4, ur2(x2(t2, 3)));
      }
      function zl(n4) {
        var t2 = R3(n4) ? Ms2 : $c2;
        return t2(n4);
      }
      function Kl(n4, t2, e2) {
        (e2 ? rn2(n4, t2, e2) : t2 === i3) ? t2 = 1 : t2 = b4(t2);
        var r2 = R3(n4) ? pc2 : Uc2;
        return r2(n4, t2);
      }
      function Yl(n4) {
        var t2 = R3(n4) ? dc2 : Fc2;
        return t2(n4);
      }
      function Zl(n4) {
        if (n4 == null)
          return 0;
        if (an2(n4))
          return or2(n4) ? Dt2(n4) : n4.length;
        var t2 = tn2(n4);
        return t2 == yn2 || t2 == Sn ? n4.size : jr(n4).length;
      }
      function Jl(n4, t2, e2) {
        var r2 = R3(n4) ? Nr2 : Mc2;
        return e2 && rn2(n4, t2, e2) && (t2 = i3), r2(n4, x2(t2, 3));
      }
      var Xl = L3(function(n4, t2) {
        if (n4 == null)
          return [];
        var e2 = t2.length;
        return e2 > 1 && rn2(n4, t2[0], t2[1]) ? t2 = [] : e2 > 2 && rn2(t2[0], t2[1], t2[2]) && (t2 = [t2[0]]), tu(n4, j2(t2, 1), []);
      }), ir2 = Rf2 || function() {
        return k3.Date.now();
      };
      function Ql(n4, t2) {
        if (typeof t2 != "function")
          throw new wn($2);
        return n4 = b4(n4), function() {
          if (--n4 < 1)
            return t2.apply(this, arguments);
        };
      }
      function Xu(n4, t2, e2) {
        return t2 = e2 ? i3 : t2, t2 = n4 && t2 == null ? n4.length : t2, Kn2(n4, Mn2, i3, i3, i3, i3, t2);
      }
      function Qu(n4, t2) {
        var e2;
        if (typeof t2 != "function")
          throw new wn($2);
        return n4 = b4(n4), function() {
          return --n4 > 0 && (e2 = t2.apply(this, arguments)), n4 <= 1 && (t2 = i3), e2;
        };
      }
      var Ii2 = L3(function(n4, t2, e2) {
        var r2 = vn2;
        if (e2.length) {
          var s3 = tt2(e2, qt2(Ii2));
          r2 |= Hn2;
        }
        return Kn2(n4, r2, t2, e2, s3);
      }), Vu = L3(function(n4, t2, e2) {
        var r2 = vn2 | ct2;
        if (e2.length) {
          var s3 = tt2(e2, qt2(Vu));
          r2 |= Hn2;
        }
        return Kn2(t2, r2, n4, e2, s3);
      });
      function ku(n4, t2, e2) {
        t2 = e2 ? i3 : t2;
        var r2 = Kn2(n4, Dn2, i3, i3, i3, i3, i3, t2);
        return r2.placeholder = ku.placeholder, r2;
      }
      function ju(n4, t2, e2) {
        t2 = e2 ? i3 : t2;
        var r2 = Kn2(n4, yt2, i3, i3, i3, i3, i3, t2);
        return r2.placeholder = ju.placeholder, r2;
      }
      function na(n4, t2, e2) {
        var r2, s3, o2, f4, c2, l2, v4 = 0, _3 = false, m2 = false, w3 = true;
        if (typeof n4 != "function")
          throw new wn($2);
        t2 = xn2(t2) || 0, K3(e2) && (_3 = !!e2.leading, m2 = "maxWait" in e2, o2 = m2 ? Q3(xn2(e2.maxWait) || 0, t2) : o2, w3 = "trailing" in e2 ? !!e2.trailing : w3);
        function I3(J2) {
          var Tn = r2, Qn2 = s3;
          return r2 = s3 = i3, v4 = J2, f4 = n4.apply(Qn2, Tn), f4;
        }
        function E3(J2) {
          return v4 = J2, c2 = le2(D2, t2), _3 ? I3(J2) : f4;
        }
        function T2(J2) {
          var Tn = J2 - l2, Qn2 = J2 - v4, wa2 = t2 - Tn;
          return m2 ? nn2(wa2, o2 - Qn2) : wa2;
        }
        function y3(J2) {
          var Tn = J2 - l2, Qn2 = J2 - v4;
          return l2 === i3 || Tn >= t2 || Tn < 0 || m2 && Qn2 >= o2;
        }
        function D2() {
          var J2 = ir2();
          if (y3(J2))
            return N10(J2);
          c2 = le2(D2, T2(J2));
        }
        function N10(J2) {
          return c2 = i3, w3 && r2 ? I3(J2) : (r2 = s3 = i3, f4);
        }
        function dn2() {
          c2 !== i3 && cu(c2), v4 = 0, r2 = l2 = s3 = c2 = i3;
        }
        function sn2() {
          return c2 === i3 ? f4 : N10(ir2());
        }
        function gn2() {
          var J2 = ir2(), Tn = y3(J2);
          if (r2 = arguments, s3 = this, l2 = J2, Tn) {
            if (c2 === i3)
              return E3(l2);
            if (m2)
              return cu(c2), c2 = le2(D2, t2), I3(l2);
          }
          return c2 === i3 && (c2 = le2(D2, t2)), f4;
        }
        return gn2.cancel = dn2, gn2.flush = sn2, gn2;
      }
      var Vl = L3(function(n4, t2) {
        return Gs2(n4, 1, t2);
      }), kl2 = L3(function(n4, t2, e2) {
        return Gs2(n4, xn2(t2) || 0, e2);
      });
      function jl2(n4) {
        return Kn2(n4, dr2);
      }
      function sr2(n4, t2) {
        if (typeof n4 != "function" || t2 != null && typeof t2 != "function")
          throw new wn($2);
        var e2 = function() {
          var r2 = arguments, s3 = t2 ? t2.apply(this, r2) : r2[0], o2 = e2.cache;
          if (o2.has(s3))
            return o2.get(s3);
          var f4 = n4.apply(this, r2);
          return e2.cache = o2.set(s3, f4) || o2, f4;
        };
        return e2.cache = new (sr2.Cache || Gn2)(), e2;
      }
      sr2.Cache = Gn2;
      function ur2(n4) {
        if (typeof n4 != "function")
          throw new wn($2);
        return function() {
          var t2 = arguments;
          switch (t2.length) {
            case 0:
              return !n4.call(this);
            case 1:
              return !n4.call(this, t2[0]);
            case 2:
              return !n4.call(this, t2[0], t2[1]);
            case 3:
              return !n4.call(this, t2[0], t2[1], t2[2]);
          }
          return !n4.apply(this, t2);
        };
      }
      function np(n4) {
        return Qu(2, n4);
      }
      var tp = qc2(function(n4, t2) {
        t2 = t2.length == 1 && R3(t2[0]) ? G2(t2[0], hn2(x2())) : G2(j2(t2, 1), hn2(x2()));
        var e2 = t2.length;
        return L3(function(r2) {
          for (var s3 = -1, o2 = nn2(r2.length, e2); ++s3 < o2; )
            r2[s3] = t2[s3].call(this, r2[s3]);
          return cn2(n4, this, r2);
        });
      }), xi2 = L3(function(n4, t2) {
        var e2 = tt2(t2, qt2(xi2));
        return Kn2(n4, Hn2, i3, t2, e2);
      }), ta2 = L3(function(n4, t2) {
        var e2 = tt2(t2, qt2(ta2));
        return Kn2(n4, St2, i3, t2, e2);
      }), ep = Yn(function(n4, t2) {
        return Kn2(n4, Kt2, i3, i3, i3, t2);
      });
      function rp(n4, t2) {
        if (typeof n4 != "function")
          throw new wn($2);
        return t2 = t2 === i3 ? t2 : b4(t2), L3(n4, t2);
      }
      function ip(n4, t2) {
        if (typeof n4 != "function")
          throw new wn($2);
        return t2 = t2 == null ? 0 : Q3(b4(t2), 0), L3(function(e2) {
          var r2 = e2[t2], s3 = ut2(e2, 0, t2);
          return r2 && nt2(s3, r2), cn2(n4, this, s3);
        });
      }
      function sp(n4, t2, e2) {
        var r2 = true, s3 = true;
        if (typeof n4 != "function")
          throw new wn($2);
        return K3(e2) && (r2 = "leading" in e2 ? !!e2.leading : r2, s3 = "trailing" in e2 ? !!e2.trailing : s3), na(n4, t2, { leading: r2, maxWait: t2, trailing: s3 });
      }
      function up(n4) {
        return Xu(n4, 1);
      }
      function ap(n4, t2) {
        return xi2(oi2(t2), n4);
      }
      function op() {
        if (!arguments.length)
          return [];
        var n4 = arguments[0];
        return R3(n4) ? n4 : [n4];
      }
      function fp(n4) {
        return An(n4, xt2);
      }
      function cp(n4, t2) {
        return t2 = typeof t2 == "function" ? t2 : i3, An(n4, xt2, t2);
      }
      function hp(n4) {
        return An(n4, Ln2 | xt2);
      }
      function lp(n4, t2) {
        return t2 = typeof t2 == "function" ? t2 : i3, An(n4, Ln2 | xt2, t2);
      }
      function pp(n4, t2) {
        return t2 == null || Bs2(n4, t2, V3(t2));
      }
      function bn2(n4, t2) {
        return n4 === t2 || n4 !== n4 && t2 !== t2;
      }
      var dp = ke2(Qr), gp = ke2(function(n4, t2) {
        return n4 >= t2;
      }), Pt2 = Js2(function() {
        return arguments;
      }()) ? Js2 : function(n4) {
        return Y2(n4) && F2.call(n4, "callee") && !Hs2.call(n4, "callee");
      }, R3 = p3.isArray, vp = gs2 ? hn2(gs2) : xc2;
      function an2(n4) {
        return n4 != null && ar2(n4.length) && !Jn2(n4);
      }
      function Z2(n4) {
        return Y2(n4) && an2(n4);
      }
      function _p(n4) {
        return n4 === true || n4 === false || Y2(n4) && en2(n4) == Yt2;
      }
      var at2 = Tf2 || Ni2, mp = vs2 ? hn2(vs2) : Ec2;
      function wp(n4) {
        return Y2(n4) && n4.nodeType === 1 && !pe2(n4);
      }
      function Pp(n4) {
        if (n4 == null)
          return true;
        if (an2(n4) && (R3(n4) || typeof n4 == "string" || typeof n4.splice == "function" || at2(n4) || Bt2(n4) || Pt2(n4)))
          return !n4.length;
        var t2 = tn2(n4);
        if (t2 == yn2 || t2 == Sn)
          return !n4.size;
        if (he2(n4))
          return !jr(n4).length;
        for (var e2 in n4)
          if (F2.call(n4, e2))
            return false;
        return true;
      }
      function Ap(n4, t2) {
        return oe2(n4, t2);
      }
      function Cp(n4, t2, e2) {
        e2 = typeof e2 == "function" ? e2 : i3;
        var r2 = e2 ? e2(n4, t2) : i3;
        return r2 === i3 ? oe2(n4, t2, i3, e2) : !!r2;
      }
      function Ei2(n4) {
        if (!Y2(n4))
          return false;
        var t2 = en2(n4);
        return t2 == we2 || t2 == Ga2 || typeof n4.message == "string" && typeof n4.name == "string" && !pe2(n4);
      }
      function Ip(n4) {
        return typeof n4 == "number" && $s2(n4);
      }
      function Jn2(n4) {
        if (!K3(n4))
          return false;
        var t2 = en2(n4);
        return t2 == Pe2 || t2 == Gi2 || t2 == Ba2 || t2 == Ka2;
      }
      function ea2(n4) {
        return typeof n4 == "number" && n4 == b4(n4);
      }
      function ar2(n4) {
        return typeof n4 == "number" && n4 > -1 && n4 % 1 == 0 && n4 <= kn2;
      }
      function K3(n4) {
        var t2 = typeof n4;
        return n4 != null && (t2 == "object" || t2 == "function");
      }
      function Y2(n4) {
        return n4 != null && typeof n4 == "object";
      }
      var ra2 = _s2 ? hn2(_s2) : Sc2;
      function xp(n4, t2) {
        return n4 === t2 || kr(n4, t2, gi2(t2));
      }
      function Ep(n4, t2, e2) {
        return e2 = typeof e2 == "function" ? e2 : i3, kr(n4, t2, gi2(t2), e2);
      }
      function yp(n4) {
        return ia2(n4) && n4 != +n4;
      }
      function Sp(n4) {
        if (ch2(n4))
          throw new S3(O2);
        return Xs2(n4);
      }
      function Op2(n4) {
        return n4 === null;
      }
      function Rp(n4) {
        return n4 == null;
      }
      function ia2(n4) {
        return typeof n4 == "number" || Y2(n4) && en2(n4) == Jt2;
      }
      function pe2(n4) {
        if (!Y2(n4) || en2(n4) != qn2)
          return false;
        var t2 = He2(n4);
        if (t2 === null)
          return true;
        var e2 = F2.call(t2, "constructor") && t2.constructor;
        return typeof e2 == "function" && e2 instanceof e2 && be2.call(e2) == Ef2;
      }
      var yi2 = ms2 ? hn2(ms2) : Oc2;
      function bp(n4) {
        return ea2(n4) && n4 >= -kn2 && n4 <= kn2;
      }
      var sa2 = ws2 ? hn2(ws2) : Rc2;
      function or2(n4) {
        return typeof n4 == "string" || !R3(n4) && Y2(n4) && en2(n4) == Qt2;
      }
      function pn2(n4) {
        return typeof n4 == "symbol" || Y2(n4) && en2(n4) == Ae2;
      }
      var Bt2 = Ps2 ? hn2(Ps2) : bc2;
      function Tp(n4) {
        return n4 === i3;
      }
      function Lp(n4) {
        return Y2(n4) && tn2(n4) == Vt2;
      }
      function Dp(n4) {
        return Y2(n4) && en2(n4) == Za2;
      }
      var Hp = ke2(ni2), Np = ke2(function(n4, t2) {
        return n4 <= t2;
      });
      function ua2(n4) {
        if (!n4)
          return [];
        if (an2(n4))
          return or2(n4) ? On(n4) : un2(n4);
        if (ne2 && n4[ne2])
          return pf2(n4[ne2]());
        var t2 = tn2(n4), e2 = t2 == yn2 ? qr : t2 == Sn ? Se2 : Gt2;
        return e2(n4);
      }
      function Xn2(n4) {
        if (!n4)
          return n4 === 0 ? n4 : 0;
        if (n4 = xn2(n4), n4 === ht2 || n4 === -ht2) {
          var t2 = n4 < 0 ? -1 : 1;
          return t2 * Wa2;
        }
        return n4 === n4 ? n4 : 0;
      }
      function b4(n4) {
        var t2 = Xn2(n4), e2 = t2 % 1;
        return t2 === t2 ? e2 ? t2 - e2 : t2 : 0;
      }
      function aa2(n4) {
        return n4 ? vt2(b4(n4), 0, Nn) : 0;
      }
      function xn2(n4) {
        if (typeof n4 == "number")
          return n4;
        if (pn2(n4))
          return _e2;
        if (K3(n4)) {
          var t2 = typeof n4.valueOf == "function" ? n4.valueOf() : n4;
          n4 = K3(t2) ? t2 + "" : t2;
        }
        if (typeof n4 != "string")
          return n4 === 0 ? n4 : +n4;
        n4 = ys2(n4);
        var e2 = go.test(n4);
        return e2 || _o.test(n4) ? Xo(n4.slice(2), e2 ? 2 : 8) : po.test(n4) ? _e2 : +n4;
      }
      function oa2(n4) {
        return Un2(n4, on3(n4));
      }
      function $p(n4) {
        return n4 ? vt2(b4(n4), -kn2, kn2) : n4 === 0 ? n4 : 0;
      }
      function W2(n4) {
        return n4 == null ? "" : ln2(n4);
      }
      var Up = Ft2(function(n4, t2) {
        if (he2(t2) || an2(t2)) {
          Un2(t2, V3(t2), n4);
          return;
        }
        for (var e2 in t2)
          F2.call(t2, e2) && se2(n4, e2, t2[e2]);
      }), fa2 = Ft2(function(n4, t2) {
        Un2(t2, on3(t2), n4);
      }), fr = Ft2(function(n4, t2, e2, r2) {
        Un2(t2, on3(t2), n4, r2);
      }), Wp = Ft2(function(n4, t2, e2, r2) {
        Un2(t2, V3(t2), n4, r2);
      }), Fp = Yn(Zr);
      function Mp(n4, t2) {
        var e2 = Wt2(n4);
        return t2 == null ? e2 : qs2(e2, t2);
      }
      var qp = L3(function(n4, t2) {
        n4 = M3(n4);
        var e2 = -1, r2 = t2.length, s3 = r2 > 2 ? t2[2] : i3;
        for (s3 && rn2(t2[0], t2[1], s3) && (r2 = 1); ++e2 < r2; )
          for (var o2 = t2[e2], f4 = on3(o2), c2 = -1, l2 = f4.length; ++c2 < l2; ) {
            var v4 = f4[c2], _3 = n4[v4];
            (_3 === i3 || bn2(_3, Nt2[v4]) && !F2.call(n4, v4)) && (n4[v4] = o2[v4]);
          }
        return n4;
      }), Bp = L3(function(n4) {
        return n4.push(i3, yu), cn2(ca2, i3, n4);
      });
      function Gp(n4, t2) {
        return Cs2(n4, x2(t2, 3), $n);
      }
      function zp(n4, t2) {
        return Cs2(n4, x2(t2, 3), Xr);
      }
      function Kp(n4, t2) {
        return n4 == null ? n4 : Jr(n4, x2(t2, 3), on3);
      }
      function Yp(n4, t2) {
        return n4 == null ? n4 : Ys2(n4, x2(t2, 3), on3);
      }
      function Zp(n4, t2) {
        return n4 && $n(n4, x2(t2, 3));
      }
      function Jp(n4, t2) {
        return n4 && Xr(n4, x2(t2, 3));
      }
      function Xp(n4) {
        return n4 == null ? [] : ze2(n4, V3(n4));
      }
      function Qp(n4) {
        return n4 == null ? [] : ze2(n4, on3(n4));
      }
      function Si2(n4, t2, e2) {
        var r2 = n4 == null ? i3 : _t2(n4, t2);
        return r2 === i3 ? e2 : r2;
      }
      function Vp(n4, t2) {
        return n4 != null && Ru(n4, t2, Pc2);
      }
      function Oi2(n4, t2) {
        return n4 != null && Ru(n4, t2, Ac2);
      }
      var kp = Au(function(n4, t2, e2) {
        t2 != null && typeof t2.toString != "function" && (t2 = Te2.call(t2)), n4[t2] = e2;
      }, bi2(fn2)), jp = Au(function(n4, t2, e2) {
        t2 != null && typeof t2.toString != "function" && (t2 = Te2.call(t2)), F2.call(n4, t2) ? n4[t2].push(e2) : n4[t2] = [e2];
      }, x2), nd2 = L3(ae2);
      function V3(n4) {
        return an2(n4) ? Fs2(n4) : jr(n4);
      }
      function on3(n4) {
        return an2(n4) ? Fs2(n4, true) : Tc2(n4);
      }
      function td2(n4, t2) {
        var e2 = {};
        return t2 = x2(t2, 3), $n(n4, function(r2, s3, o2) {
          zn(e2, t2(r2, s3, o2), r2);
        }), e2;
      }
      function ed2(n4, t2) {
        var e2 = {};
        return t2 = x2(t2, 3), $n(n4, function(r2, s3, o2) {
          zn(e2, s3, t2(r2, s3, o2));
        }), e2;
      }
      var rd2 = Ft2(function(n4, t2, e2) {
        Ke2(n4, t2, e2);
      }), ca2 = Ft2(function(n4, t2, e2, r2) {
        Ke2(n4, t2, e2, r2);
      }), id2 = Yn(function(n4, t2) {
        var e2 = {};
        if (n4 == null)
          return e2;
        var r2 = false;
        t2 = G2(t2, function(o2) {
          return o2 = st2(o2, n4), r2 || (r2 = o2.length > 1), o2;
        }), Un2(n4, pi2(n4), e2), r2 && (e2 = An(e2, Ln2 | Fn2 | xt2, kc2));
        for (var s3 = t2.length; s3--; )
          si2(e2, t2[s3]);
        return e2;
      });
      function sd2(n4, t2) {
        return ha2(n4, ur2(x2(t2)));
      }
      var ud2 = Yn(function(n4, t2) {
        return n4 == null ? {} : Dc2(n4, t2);
      });
      function ha2(n4, t2) {
        if (n4 == null)
          return {};
        var e2 = G2(pi2(n4), function(r2) {
          return [r2];
        });
        return t2 = x2(t2), eu(n4, e2, function(r2, s3) {
          return t2(r2, s3[0]);
        });
      }
      function ad2(n4, t2, e2) {
        t2 = st2(t2, n4);
        var r2 = -1, s3 = t2.length;
        for (s3 || (s3 = 1, n4 = i3); ++r2 < s3; ) {
          var o2 = n4 == null ? i3 : n4[Wn2(t2[r2])];
          o2 === i3 && (r2 = s3, o2 = e2), n4 = Jn2(o2) ? o2.call(n4) : o2;
        }
        return n4;
      }
      function od2(n4, t2, e2) {
        return n4 == null ? n4 : fe2(n4, t2, e2);
      }
      function fd2(n4, t2, e2, r2) {
        return r2 = typeof r2 == "function" ? r2 : i3, n4 == null ? n4 : fe2(n4, t2, e2, r2);
      }
      var la2 = xu(V3), pa2 = xu(on3);
      function cd2(n4, t2, e2) {
        var r2 = R3(n4), s3 = r2 || at2(n4) || Bt2(n4);
        if (t2 = x2(t2, 4), e2 == null) {
          var o2 = n4 && n4.constructor;
          s3 ? e2 = r2 ? new o2() : [] : K3(n4) ? e2 = Jn2(o2) ? Wt2(He2(n4)) : {} : e2 = {};
        }
        return (s3 ? mn2 : $n)(n4, function(f4, c2, l2) {
          return t2(e2, f4, c2, l2);
        }), e2;
      }
      function hd2(n4, t2) {
        return n4 == null ? true : si2(n4, t2);
      }
      function ld2(n4, t2, e2) {
        return n4 == null ? n4 : au(n4, t2, oi2(e2));
      }
      function pd2(n4, t2, e2, r2) {
        return r2 = typeof r2 == "function" ? r2 : i3, n4 == null ? n4 : au(n4, t2, oi2(e2), r2);
      }
      function Gt2(n4) {
        return n4 == null ? [] : Mr2(n4, V3(n4));
      }
      function dd2(n4) {
        return n4 == null ? [] : Mr2(n4, on3(n4));
      }
      function gd2(n4, t2, e2) {
        return e2 === i3 && (e2 = t2, t2 = i3), e2 !== i3 && (e2 = xn2(e2), e2 = e2 === e2 ? e2 : 0), t2 !== i3 && (t2 = xn2(t2), t2 = t2 === t2 ? t2 : 0), vt2(xn2(n4), t2, e2);
      }
      function vd2(n4, t2, e2) {
        return t2 = Xn2(t2), e2 === i3 ? (e2 = t2, t2 = 0) : e2 = Xn2(e2), n4 = xn2(n4), Cc2(n4, t2, e2);
      }
      function _d(n4, t2, e2) {
        if (e2 && typeof e2 != "boolean" && rn2(n4, t2, e2) && (t2 = e2 = i3), e2 === i3 && (typeof t2 == "boolean" ? (e2 = t2, t2 = i3) : typeof n4 == "boolean" && (e2 = n4, n4 = i3)), n4 === i3 && t2 === i3 ? (n4 = 0, t2 = 1) : (n4 = Xn2(n4), t2 === i3 ? (t2 = n4, n4 = 0) : t2 = Xn2(t2)), n4 > t2) {
          var r2 = n4;
          n4 = t2, t2 = r2;
        }
        if (e2 || n4 % 1 || t2 % 1) {
          var s3 = Us2();
          return nn2(n4 + s3 * (t2 - n4 + Jo("1e-" + ((s3 + "").length - 1))), t2);
        }
        return ei2(n4, t2);
      }
      var md2 = Mt2(function(n4, t2, e2) {
        return t2 = t2.toLowerCase(), n4 + (e2 ? da2(t2) : t2);
      });
      function da2(n4) {
        return Ri2(W2(n4).toLowerCase());
      }
      function ga(n4) {
        return n4 = W2(n4), n4 && n4.replace(wo, of2).replace(Wo, "");
      }
      function wd2(n4, t2, e2) {
        n4 = W2(n4), t2 = ln2(t2);
        var r2 = n4.length;
        e2 = e2 === i3 ? r2 : vt2(b4(e2), 0, r2);
        var s3 = e2;
        return e2 -= t2.length, e2 >= 0 && n4.slice(e2, s3) == t2;
      }
      function Pd2(n4) {
        return n4 = W2(n4), n4 && ka2.test(n4) ? n4.replace(Yi2, ff2) : n4;
      }
      function Ad2(n4) {
        return n4 = W2(n4), n4 && io.test(n4) ? n4.replace(xr2, "\\$&") : n4;
      }
      var Cd2 = Mt2(function(n4, t2, e2) {
        return n4 + (e2 ? "-" : "") + t2.toLowerCase();
      }), Id2 = Mt2(function(n4, t2, e2) {
        return n4 + (e2 ? " " : "") + t2.toLowerCase();
      }), xd2 = mu("toLowerCase");
      function Ed2(n4, t2, e2) {
        n4 = W2(n4), t2 = b4(t2);
        var r2 = t2 ? Dt2(n4) : 0;
        if (!t2 || r2 >= t2)
          return n4;
        var s3 = (t2 - r2) / 2;
        return Ve2(We2(s3), e2) + n4 + Ve2(Ue2(s3), e2);
      }
      function yd2(n4, t2, e2) {
        n4 = W2(n4), t2 = b4(t2);
        var r2 = t2 ? Dt2(n4) : 0;
        return t2 && r2 < t2 ? n4 + Ve2(t2 - r2, e2) : n4;
      }
      function Sd2(n4, t2, e2) {
        n4 = W2(n4), t2 = b4(t2);
        var r2 = t2 ? Dt2(n4) : 0;
        return t2 && r2 < t2 ? Ve2(t2 - r2, e2) + n4 : n4;
      }
      function Od2(n4, t2, e2) {
        return e2 || t2 == null ? t2 = 0 : t2 && (t2 = +t2), Nf2(W2(n4).replace(Er, ""), t2 || 0);
      }
      function Rd2(n4, t2, e2) {
        return (e2 ? rn2(n4, t2, e2) : t2 === i3) ? t2 = 1 : t2 = b4(t2), ri2(W2(n4), t2);
      }
      function bd2() {
        var n4 = arguments, t2 = W2(n4[0]);
        return n4.length < 3 ? t2 : t2.replace(n4[1], n4[2]);
      }
      var Td2 = Mt2(function(n4, t2, e2) {
        return n4 + (e2 ? "_" : "") + t2.toLowerCase();
      });
      function Ld2(n4, t2, e2) {
        return e2 && typeof e2 != "number" && rn2(n4, t2, e2) && (t2 = e2 = i3), e2 = e2 === i3 ? Nn : e2 >>> 0, e2 ? (n4 = W2(n4), n4 && (typeof t2 == "string" || t2 != null && !yi2(t2)) && (t2 = ln2(t2), !t2 && Lt2(n4)) ? ut2(On(n4), 0, e2) : n4.split(t2, e2)) : [];
      }
      var Dd2 = Mt2(function(n4, t2, e2) {
        return n4 + (e2 ? " " : "") + Ri2(t2);
      });
      function Hd2(n4, t2, e2) {
        return n4 = W2(n4), e2 = e2 == null ? 0 : vt2(b4(e2), 0, n4.length), t2 = ln2(t2), n4.slice(e2, e2 + t2.length) == t2;
      }
      function Nd2(n4, t2, e2) {
        var r2 = a3.templateSettings;
        e2 && rn2(n4, t2, e2) && (t2 = i3), n4 = W2(n4), t2 = fr({}, t2, r2, Eu);
        var s3 = fr({}, t2.imports, r2.imports, Eu), o2 = V3(s3), f4 = Mr2(s3, o2), c2, l2, v4 = 0, _3 = t2.interpolate || Ce2, m2 = "__p += '", w3 = Br((t2.escape || Ce2).source + "|" + _3.source + "|" + (_3 === Zi3 ? lo : Ce2).source + "|" + (t2.evaluate || Ce2).source + "|$", "g"), I3 = "//# sourceURL=" + (F2.call(t2, "sourceURL") ? (t2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Go + "]") + `
`;
        n4.replace(w3, function(y3, D2, N10, dn2, sn2, gn2) {
          return N10 || (N10 = dn2), m2 += n4.slice(v4, gn2).replace(Po, cf2), D2 && (c2 = true, m2 += `' +
__e(` + D2 + `) +
'`), sn2 && (l2 = true, m2 += `';
` + sn2 + `;
__p += '`), N10 && (m2 += `' +
((__t = (` + N10 + `)) == null ? '' : __t) +
'`), v4 = gn2 + y3.length, y3;
        }), m2 += `';
`;
        var E3 = F2.call(t2, "variable") && t2.variable;
        if (!E3)
          m2 = `with (obj) {
` + m2 + `
}
`;
        else if (co.test(E3))
          throw new S3(En);
        m2 = (l2 ? m2.replace(Ja2, "") : m2).replace(Xa2, "$1").replace(Qa2, "$1;"), m2 = "function(" + (E3 || "obj") + `) {
` + (E3 ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (c2 ? ", __e = _.escape" : "") + (l2 ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + m2 + `return __p
}`;
        var T2 = _a2(function() {
          return U2(o2, I3 + "return " + m2).apply(i3, f4);
        });
        if (T2.source = m2, Ei2(T2))
          throw T2;
        return T2;
      }
      function $d2(n4) {
        return W2(n4).toLowerCase();
      }
      function Ud2(n4) {
        return W2(n4).toUpperCase();
      }
      function Wd2(n4, t2, e2) {
        if (n4 = W2(n4), n4 && (e2 || t2 === i3))
          return ys2(n4);
        if (!n4 || !(t2 = ln2(t2)))
          return n4;
        var r2 = On(n4), s3 = On(t2), o2 = Ss2(r2, s3), f4 = Os2(r2, s3) + 1;
        return ut2(r2, o2, f4).join("");
      }
      function Fd2(n4, t2, e2) {
        if (n4 = W2(n4), n4 && (e2 || t2 === i3))
          return n4.slice(0, bs2(n4) + 1);
        if (!n4 || !(t2 = ln2(t2)))
          return n4;
        var r2 = On(n4), s3 = Os2(r2, On(t2)) + 1;
        return ut2(r2, 0, s3).join("");
      }
      function Md2(n4, t2, e2) {
        if (n4 = W2(n4), n4 && (e2 || t2 === i3))
          return n4.replace(Er, "");
        if (!n4 || !(t2 = ln2(t2)))
          return n4;
        var r2 = On(n4), s3 = Ss2(r2, On(t2));
        return ut2(r2, s3).join("");
      }
      function qd2(n4, t2) {
        var e2 = La2, r2 = Da2;
        if (K3(t2)) {
          var s3 = "separator" in t2 ? t2.separator : s3;
          e2 = "length" in t2 ? b4(t2.length) : e2, r2 = "omission" in t2 ? ln2(t2.omission) : r2;
        }
        n4 = W2(n4);
        var o2 = n4.length;
        if (Lt2(n4)) {
          var f4 = On(n4);
          o2 = f4.length;
        }
        if (e2 >= o2)
          return n4;
        var c2 = e2 - Dt2(r2);
        if (c2 < 1)
          return r2;
        var l2 = f4 ? ut2(f4, 0, c2).join("") : n4.slice(0, c2);
        if (s3 === i3)
          return l2 + r2;
        if (f4 && (c2 += l2.length - c2), yi2(s3)) {
          if (n4.slice(c2).search(s3)) {
            var v4, _3 = l2;
            for (s3.global || (s3 = Br(s3.source, W2(Ji2.exec(s3)) + "g")), s3.lastIndex = 0; v4 = s3.exec(_3); )
              var m2 = v4.index;
            l2 = l2.slice(0, m2 === i3 ? c2 : m2);
          }
        } else if (n4.indexOf(ln2(s3), c2) != c2) {
          var w3 = l2.lastIndexOf(s3);
          w3 > -1 && (l2 = l2.slice(0, w3));
        }
        return l2 + r2;
      }
      function Bd2(n4) {
        return n4 = W2(n4), n4 && Va2.test(n4) ? n4.replace(Ki2, _f) : n4;
      }
      var Gd2 = Mt2(function(n4, t2, e2) {
        return n4 + (e2 ? " " : "") + t2.toUpperCase();
      }), Ri2 = mu("toUpperCase");
      function va2(n4, t2, e2) {
        return n4 = W2(n4), t2 = e2 ? i3 : t2, t2 === i3 ? lf2(n4) ? Pf2(n4) : ef2(n4) : n4.match(t2) || [];
      }
      var _a2 = L3(function(n4, t2) {
        try {
          return cn2(n4, i3, t2);
        } catch (e2) {
          return Ei2(e2) ? e2 : new S3(e2);
        }
      }), zd2 = Yn(function(n4, t2) {
        return mn2(t2, function(e2) {
          e2 = Wn2(e2), zn(n4, e2, Ii2(n4[e2], n4));
        }), n4;
      });
      function Kd2(n4) {
        var t2 = n4 == null ? 0 : n4.length, e2 = x2();
        return n4 = t2 ? G2(n4, function(r2) {
          if (typeof r2[1] != "function")
            throw new wn($2);
          return [e2(r2[0]), r2[1]];
        }) : [], L3(function(r2) {
          for (var s3 = -1; ++s3 < t2; ) {
            var o2 = n4[s3];
            if (cn2(o2[0], this, r2))
              return cn2(o2[1], this, r2);
          }
        });
      }
      function Yd2(n4) {
        return _c(An(n4, Ln2));
      }
      function bi2(n4) {
        return function() {
          return n4;
        };
      }
      function Zd2(n4, t2) {
        return n4 == null || n4 !== n4 ? t2 : n4;
      }
      var Jd2 = Pu(), Xd2 = Pu(true);
      function fn2(n4) {
        return n4;
      }
      function Ti2(n4) {
        return Qs2(typeof n4 == "function" ? n4 : An(n4, Ln2));
      }
      function Qd2(n4) {
        return ks2(An(n4, Ln2));
      }
      function Vd2(n4, t2) {
        return js2(n4, An(t2, Ln2));
      }
      var kd2 = L3(function(n4, t2) {
        return function(e2) {
          return ae2(e2, n4, t2);
        };
      }), jd2 = L3(function(n4, t2) {
        return function(e2) {
          return ae2(n4, e2, t2);
        };
      });
      function Li2(n4, t2, e2) {
        var r2 = V3(t2), s3 = ze2(t2, r2);
        e2 == null && !(K3(t2) && (s3.length || !r2.length)) && (e2 = t2, t2 = n4, n4 = this, s3 = ze2(t2, V3(t2)));
        var o2 = !(K3(e2) && "chain" in e2) || !!e2.chain, f4 = Jn2(n4);
        return mn2(s3, function(c2) {
          var l2 = t2[c2];
          n4[c2] = l2, f4 && (n4.prototype[c2] = function() {
            var v4 = this.__chain__;
            if (o2 || v4) {
              var _3 = n4(this.__wrapped__), m2 = _3.__actions__ = un2(this.__actions__);
              return m2.push({ func: l2, args: arguments, thisArg: n4 }), _3.__chain__ = v4, _3;
            }
            return l2.apply(n4, nt2([this.value()], arguments));
          });
        }), n4;
      }
      function ng2() {
        return k3._ === this && (k3._ = yf2), this;
      }
      function Di2() {
      }
      function tg2(n4) {
        return n4 = b4(n4), L3(function(t2) {
          return nu(t2, n4);
        });
      }
      var eg2 = ci2(G2), rg2 = ci2(As2), ig2 = ci2(Nr2);
      function ma2(n4) {
        return _i(n4) ? $r2(Wn2(n4)) : Hc2(n4);
      }
      function sg2(n4) {
        return function(t2) {
          return n4 == null ? i3 : _t2(n4, t2);
        };
      }
      var ug2 = Cu(), ag2 = Cu(true);
      function Hi2() {
        return [];
      }
      function Ni2() {
        return false;
      }
      function og2() {
        return {};
      }
      function fg2() {
        return "";
      }
      function cg2() {
        return true;
      }
      function hg2(n4, t2) {
        if (n4 = b4(n4), n4 < 1 || n4 > kn2)
          return [];
        var e2 = Nn, r2 = nn2(n4, Nn);
        t2 = x2(t2), n4 -= Nn;
        for (var s3 = Fr2(r2, t2); ++e2 < n4; )
          t2(e2);
        return s3;
      }
      function lg2(n4) {
        return R3(n4) ? G2(n4, Wn2) : pn2(n4) ? [n4] : un2(Wu(W2(n4)));
      }
      function pg2(n4) {
        var t2 = ++xf2;
        return W2(n4) + t2;
      }
      var dg2 = Qe2(function(n4, t2) {
        return n4 + t2;
      }, 0), gg2 = hi2("ceil"), vg2 = Qe2(function(n4, t2) {
        return n4 / t2;
      }, 1), _g = hi2("floor");
      function mg2(n4) {
        return n4 && n4.length ? Ge2(n4, fn2, Qr) : i3;
      }
      function wg2(n4, t2) {
        return n4 && n4.length ? Ge2(n4, x2(t2, 2), Qr) : i3;
      }
      function Pg2(n4) {
        return xs2(n4, fn2);
      }
      function Ag2(n4, t2) {
        return xs2(n4, x2(t2, 2));
      }
      function Cg2(n4) {
        return n4 && n4.length ? Ge2(n4, fn2, ni2) : i3;
      }
      function Ig2(n4, t2) {
        return n4 && n4.length ? Ge2(n4, x2(t2, 2), ni2) : i3;
      }
      var xg2 = Qe2(function(n4, t2) {
        return n4 * t2;
      }, 1), Eg2 = hi2("round"), yg2 = Qe2(function(n4, t2) {
        return n4 - t2;
      }, 0);
      function Sg2(n4) {
        return n4 && n4.length ? Wr(n4, fn2) : 0;
      }
      function Og2(n4, t2) {
        return n4 && n4.length ? Wr(n4, x2(t2, 2)) : 0;
      }
      return a3.after = Ql, a3.ary = Xu, a3.assign = Up, a3.assignIn = fa2, a3.assignInWith = fr, a3.assignWith = Wp, a3.at = Fp, a3.before = Qu, a3.bind = Ii2, a3.bindAll = zd2, a3.bindKey = Vu, a3.castArray = op, a3.chain = Yu, a3.chunk = _h, a3.compact = mh2, a3.concat = wh2, a3.cond = Kd2, a3.conforms = Yd2, a3.constant = bi2, a3.countBy = Sl, a3.create = Mp, a3.curry = ku, a3.curryRight = ju, a3.debounce = na, a3.defaults = qp, a3.defaultsDeep = Bp, a3.defer = Vl, a3.delay = kl2, a3.difference = Ph2, a3.differenceBy = Ah2, a3.differenceWith = Ch2, a3.drop = Ih2, a3.dropRight = xh2, a3.dropRightWhile = Eh2, a3.dropWhile = yh2, a3.fill = Sh2, a3.filter = Rl, a3.flatMap = Ll, a3.flatMapDeep = Dl, a3.flatMapDepth = Hl, a3.flatten = Bu, a3.flattenDeep = Oh2, a3.flattenDepth = Rh2, a3.flip = jl2, a3.flow = Jd2, a3.flowRight = Xd2, a3.fromPairs = bh2, a3.functions = Xp, a3.functionsIn = Qp, a3.groupBy = Nl, a3.initial = Lh2, a3.intersection = Dh2, a3.intersectionBy = Hh2, a3.intersectionWith = Nh2, a3.invert = kp, a3.invertBy = jp, a3.invokeMap = Ul, a3.iteratee = Ti2, a3.keyBy = Wl, a3.keys = V3, a3.keysIn = on3, a3.map = rr2, a3.mapKeys = td2, a3.mapValues = ed2, a3.matches = Qd2, a3.matchesProperty = Vd2, a3.memoize = sr2, a3.merge = rd2, a3.mergeWith = ca2, a3.method = kd2, a3.methodOf = jd2, a3.mixin = Li2, a3.negate = ur2, a3.nthArg = tg2, a3.omit = id2, a3.omitBy = sd2, a3.once = np, a3.orderBy = Fl, a3.over = eg2, a3.overArgs = tp, a3.overEvery = rg2, a3.overSome = ig2, a3.partial = xi2, a3.partialRight = ta2, a3.partition = Ml, a3.pick = ud2, a3.pickBy = ha2, a3.property = ma2, a3.propertyOf = sg2, a3.pull = Fh2, a3.pullAll = zu, a3.pullAllBy = Mh2, a3.pullAllWith = qh2, a3.pullAt = Bh2, a3.range = ug2, a3.rangeRight = ag2, a3.rearg = ep, a3.reject = Gl, a3.remove = Gh2, a3.rest = rp, a3.reverse = Ai2, a3.sampleSize = Kl, a3.set = od2, a3.setWith = fd2, a3.shuffle = Yl, a3.slice = zh2, a3.sortBy = Xl, a3.sortedUniq = Vh2, a3.sortedUniqBy = kh2, a3.split = Ld2, a3.spread = ip, a3.tail = jh2, a3.take = nl2, a3.takeRight = tl2, a3.takeRightWhile = el2, a3.takeWhile = rl2, a3.tap = ml2, a3.throttle = sp, a3.thru = er2, a3.toArray = ua2, a3.toPairs = la2, a3.toPairsIn = pa2, a3.toPath = lg2, a3.toPlainObject = oa2, a3.transform = cd2, a3.unary = up, a3.union = il2, a3.unionBy = sl2, a3.unionWith = ul2, a3.uniq = al2, a3.uniqBy = ol2, a3.uniqWith = fl2, a3.unset = hd2, a3.unzip = Ci2, a3.unzipWith = Ku, a3.update = ld2, a3.updateWith = pd2, a3.values = Gt2, a3.valuesIn = dd2, a3.without = cl2, a3.words = va2, a3.wrap = ap, a3.xor = hl2, a3.xorBy = ll2, a3.xorWith = pl2, a3.zip = dl2, a3.zipObject = gl2, a3.zipObjectDeep = vl2, a3.zipWith = _l, a3.entries = la2, a3.entriesIn = pa2, a3.extend = fa2, a3.extendWith = fr, Li2(a3, a3), a3.add = dg2, a3.attempt = _a2, a3.camelCase = md2, a3.capitalize = da2, a3.ceil = gg2, a3.clamp = gd2, a3.clone = fp, a3.cloneDeep = hp, a3.cloneDeepWith = lp, a3.cloneWith = cp, a3.conformsTo = pp, a3.deburr = ga, a3.defaultTo = Zd2, a3.divide = vg2, a3.endsWith = wd2, a3.eq = bn2, a3.escape = Pd2, a3.escapeRegExp = Ad2, a3.every = Ol, a3.find = bl2, a3.findIndex = Mu, a3.findKey = Gp, a3.findLast = Tl, a3.findLastIndex = qu, a3.findLastKey = zp, a3.floor = _g, a3.forEach = Zu, a3.forEachRight = Ju, a3.forIn = Kp, a3.forInRight = Yp, a3.forOwn = Zp, a3.forOwnRight = Jp, a3.get = Si2, a3.gt = dp, a3.gte = gp, a3.has = Vp, a3.hasIn = Oi2, a3.head = Gu, a3.identity = fn2, a3.includes = $l, a3.indexOf = Th2, a3.inRange = vd2, a3.invoke = nd2, a3.isArguments = Pt2, a3.isArray = R3, a3.isArrayBuffer = vp, a3.isArrayLike = an2, a3.isArrayLikeObject = Z2, a3.isBoolean = _p, a3.isBuffer = at2, a3.isDate = mp, a3.isElement = wp, a3.isEmpty = Pp, a3.isEqual = Ap, a3.isEqualWith = Cp, a3.isError = Ei2, a3.isFinite = Ip, a3.isFunction = Jn2, a3.isInteger = ea2, a3.isLength = ar2, a3.isMap = ra2, a3.isMatch = xp, a3.isMatchWith = Ep, a3.isNaN = yp, a3.isNative = Sp, a3.isNil = Rp, a3.isNull = Op2, a3.isNumber = ia2, a3.isObject = K3, a3.isObjectLike = Y2, a3.isPlainObject = pe2, a3.isRegExp = yi2, a3.isSafeInteger = bp, a3.isSet = sa2, a3.isString = or2, a3.isSymbol = pn2, a3.isTypedArray = Bt2, a3.isUndefined = Tp, a3.isWeakMap = Lp, a3.isWeakSet = Dp, a3.join = $h2, a3.kebabCase = Cd2, a3.last = In, a3.lastIndexOf = Uh2, a3.lowerCase = Id2, a3.lowerFirst = xd2, a3.lt = Hp, a3.lte = Np, a3.max = mg2, a3.maxBy = wg2, a3.mean = Pg2, a3.meanBy = Ag2, a3.min = Cg2, a3.minBy = Ig2, a3.stubArray = Hi2, a3.stubFalse = Ni2, a3.stubObject = og2, a3.stubString = fg2, a3.stubTrue = cg2, a3.multiply = xg2, a3.nth = Wh2, a3.noConflict = ng2, a3.noop = Di2, a3.now = ir2, a3.pad = Ed2, a3.padEnd = yd2, a3.padStart = Sd2, a3.parseInt = Od2, a3.random = _d, a3.reduce = ql2, a3.reduceRight = Bl2, a3.repeat = Rd2, a3.replace = bd2, a3.result = ad2, a3.round = Eg2, a3.runInContext = h5, a3.sample = zl, a3.size = Zl, a3.snakeCase = Td2, a3.some = Jl, a3.sortedIndex = Kh2, a3.sortedIndexBy = Yh2, a3.sortedIndexOf = Zh2, a3.sortedLastIndex = Jh2, a3.sortedLastIndexBy = Xh2, a3.sortedLastIndexOf = Qh2, a3.startCase = Dd2, a3.startsWith = Hd2, a3.subtract = yg2, a3.sum = Sg2, a3.sumBy = Og2, a3.template = Nd2, a3.times = hg2, a3.toFinite = Xn2, a3.toInteger = b4, a3.toLength = aa2, a3.toLower = $d2, a3.toNumber = xn2, a3.toSafeInteger = $p, a3.toString = W2, a3.toUpper = Ud2, a3.trim = Wd2, a3.trimEnd = Fd2, a3.trimStart = Md2, a3.truncate = qd2, a3.unescape = Bd2, a3.uniqueId = pg2, a3.upperCase = Gd2, a3.upperFirst = Ri2, a3.each = Zu, a3.eachRight = Ju, a3.first = Gu, Li2(a3, function() {
        var n4 = {};
        return $n(a3, function(t2, e2) {
          F2.call(a3.prototype, e2) || (n4[e2] = t2);
        }), n4;
      }(), { chain: false }), a3.VERSION = d3, mn2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(n4) {
        a3[n4].placeholder = a3;
      }), mn2(["drop", "take"], function(n4, t2) {
        H3.prototype[n4] = function(e2) {
          e2 = e2 === i3 ? 1 : Q3(b4(e2), 0);
          var r2 = this.__filtered__ && !t2 ? new H3(this) : this.clone();
          return r2.__filtered__ ? r2.__takeCount__ = nn2(e2, r2.__takeCount__) : r2.__views__.push({ size: nn2(e2, Nn), type: n4 + (r2.__dir__ < 0 ? "Right" : "") }), r2;
        }, H3.prototype[n4 + "Right"] = function(e2) {
          return this.reverse()[n4](e2).reverse();
        };
      }), mn2(["filter", "map", "takeWhile"], function(n4, t2) {
        var e2 = t2 + 1, r2 = e2 == Bi2 || e2 == Ua2;
        H3.prototype[n4] = function(s3) {
          var o2 = this.clone();
          return o2.__iteratees__.push({ iteratee: x2(s3, 3), type: e2 }), o2.__filtered__ = o2.__filtered__ || r2, o2;
        };
      }), mn2(["head", "last"], function(n4, t2) {
        var e2 = "take" + (t2 ? "Right" : "");
        H3.prototype[n4] = function() {
          return this[e2](1).value()[0];
        };
      }), mn2(["initial", "tail"], function(n4, t2) {
        var e2 = "drop" + (t2 ? "" : "Right");
        H3.prototype[n4] = function() {
          return this.__filtered__ ? new H3(this) : this[e2](1);
        };
      }), H3.prototype.compact = function() {
        return this.filter(fn2);
      }, H3.prototype.find = function(n4) {
        return this.filter(n4).head();
      }, H3.prototype.findLast = function(n4) {
        return this.reverse().find(n4);
      }, H3.prototype.invokeMap = L3(function(n4, t2) {
        return typeof n4 == "function" ? new H3(this) : this.map(function(e2) {
          return ae2(e2, n4, t2);
        });
      }), H3.prototype.reject = function(n4) {
        return this.filter(ur2(x2(n4)));
      }, H3.prototype.slice = function(n4, t2) {
        n4 = b4(n4);
        var e2 = this;
        return e2.__filtered__ && (n4 > 0 || t2 < 0) ? new H3(e2) : (n4 < 0 ? e2 = e2.takeRight(-n4) : n4 && (e2 = e2.drop(n4)), t2 !== i3 && (t2 = b4(t2), e2 = t2 < 0 ? e2.dropRight(-t2) : e2.take(t2 - n4)), e2);
      }, H3.prototype.takeRightWhile = function(n4) {
        return this.reverse().takeWhile(n4).reverse();
      }, H3.prototype.toArray = function() {
        return this.take(Nn);
      }, $n(H3.prototype, function(n4, t2) {
        var e2 = /^(?:filter|find|map|reject)|While$/.test(t2), r2 = /^(?:head|last)$/.test(t2), s3 = a3[r2 ? "take" + (t2 == "last" ? "Right" : "") : t2], o2 = r2 || /^find/.test(t2);
        s3 && (a3.prototype[t2] = function() {
          var f4 = this.__wrapped__, c2 = r2 ? [1] : arguments, l2 = f4 instanceof H3, v4 = c2[0], _3 = l2 || R3(f4), m2 = function(D2) {
            var N10 = s3.apply(a3, nt2([D2], c2));
            return r2 && w3 ? N10[0] : N10;
          };
          _3 && e2 && typeof v4 == "function" && v4.length != 1 && (l2 = _3 = false);
          var w3 = this.__chain__, I3 = !!this.__actions__.length, E3 = o2 && !w3, T2 = l2 && !I3;
          if (!o2 && _3) {
            f4 = T2 ? f4 : new H3(this);
            var y3 = n4.apply(f4, c2);
            return y3.__actions__.push({ func: er2, args: [m2], thisArg: i3 }), new Pn(y3, w3);
          }
          return E3 && T2 ? n4.apply(this, c2) : (y3 = this.thru(m2), E3 ? r2 ? y3.value()[0] : y3.value() : y3);
        });
      }), mn2(["pop", "push", "shift", "sort", "splice", "unshift"], function(n4) {
        var t2 = Oe2[n4], e2 = /^(?:push|sort|unshift)$/.test(n4) ? "tap" : "thru", r2 = /^(?:pop|shift)$/.test(n4);
        a3.prototype[n4] = function() {
          var s3 = arguments;
          if (r2 && !this.__chain__) {
            var o2 = this.value();
            return t2.apply(R3(o2) ? o2 : [], s3);
          }
          return this[e2](function(f4) {
            return t2.apply(R3(f4) ? f4 : [], s3);
          });
        };
      }), $n(H3.prototype, function(n4, t2) {
        var e2 = a3[t2];
        if (e2) {
          var r2 = e2.name + "";
          F2.call(Ut2, r2) || (Ut2[r2] = []), Ut2[r2].push({ name: t2, func: e2 });
        }
      }), Ut2[Xe2(i3, ct2).name] = [{ name: "wrapper", func: i3 }], H3.prototype.clone = Bf2, H3.prototype.reverse = Gf2, H3.prototype.value = zf2, a3.prototype.at = wl2, a3.prototype.chain = Pl, a3.prototype.commit = Al, a3.prototype.next = Cl, a3.prototype.plant = xl, a3.prototype.reverse = El, a3.prototype.toJSON = a3.prototype.valueOf = a3.prototype.value = yl, a3.prototype.first = a3.prototype.head, ne2 && (a3.prototype[ne2] = Il), a3;
    }, Ht2 = Af2();
    lt2 ? ((lt2.exports = Ht2)._ = Ht2, Tr2._ = Ht2) : k3._ = Ht2;
  }).call(ge$1);
})(Ui$1, Ui$1.exports);
var Bg$1 = Object.defineProperty, Gg$1 = Object.defineProperties, zg$1 = Object.getOwnPropertyDescriptors, Ea$1 = Object.getOwnPropertySymbols, Kg$1 = Object.prototype.hasOwnProperty, Yg$1 = Object.prototype.propertyIsEnumerable, ya$1 = (C2, u3, i3) => u3 in C2 ? Bg$1(C2, u3, { enumerable: true, configurable: true, writable: true, value: i3 }) : C2[u3] = i3, cr = (C2, u3) => {
  for (var i3 in u3 || (u3 = {}))
    Kg$1.call(u3, i3) && ya$1(C2, i3, u3[i3]);
  if (Ea$1)
    for (var i3 of Ea$1(u3))
      Yg$1.call(u3, i3) && ya$1(C2, i3, u3[i3]);
  return C2;
}, Zg$1 = (C2, u3) => Gg$1(C2, zg$1(u3));
function ft$2(C2, u3, i3) {
  var d3;
  const P2 = ve$1(C2);
  return ((d3 = u3.rpcMap) == null ? void 0 : d3[P2.reference]) || `${qg$1}?chainId=${P2.namespace}:${P2.reference}&projectId=${i3}`;
}
function Ct(C2) {
  return C2.includes(":") ? C2.split(":")[1] : C2;
}
function Sa$1(C2) {
  return C2.map((u3) => `${u3.split(":")[0]}:${u3.split(":")[1]}`);
}
function Jg$1(C2, u3) {
  const i3 = Object.keys(u3.namespaces).filter((P2) => P2.includes(C2));
  if (!i3.length)
    return [];
  const d3 = [];
  return i3.forEach((P2) => {
    const O2 = u3.namespaces[P2].accounts;
    d3.push(...O2);
  }), d3;
}
function Xg$1(C2 = {}, u3 = {}) {
  const i3 = Oa$1(C2), d3 = Oa$1(u3);
  return Ui$1.exports.merge(i3, d3);
}
function Oa$1(C2) {
  var u3, i3, d3, P2;
  const O2 = {};
  if (!B$4(C2))
    return O2;
  for (const [$2, En] of Object.entries(C2)) {
    const zt2 = oe$1($2) ? [$2] : En.chains, pr2 = En.methods || [], It2 = En.events || [], Ln2 = En.rpcMap || {}, Fn2 = en($2);
    O2[Fn2] = Zg$1(cr(cr({}, O2[Fn2]), En), { chains: S$4(zt2, (u3 = O2[Fn2]) == null ? void 0 : u3.chains), methods: S$4(pr2, (i3 = O2[Fn2]) == null ? void 0 : i3.methods), events: S$4(It2, (d3 = O2[Fn2]) == null ? void 0 : d3.events), rpcMap: cr(cr({}, Ln2), (P2 = O2[Fn2]) == null ? void 0 : P2.rpcMap) });
  }
  return O2;
}
function Qg$1(C2) {
  return C2.includes(":") ? C2.split(":")[2] : C2;
}
function Vg$1(C2) {
  const u3 = {};
  for (const [i3, d3] of Object.entries(C2)) {
    const P2 = d3.methods || [], O2 = d3.events || [], $2 = d3.accounts || [], En = oe$1(i3) ? [i3] : d3.chains ? d3.chains : Sa$1(d3.accounts);
    u3[i3] = { chains: En, methods: P2, events: O2, accounts: $2 };
  }
  return u3;
}
function Wi$1(C2) {
  return typeof C2 == "number" ? C2 : C2.includes("0x") ? parseInt(C2, 16) : C2.includes(":") ? Number(C2.split(":")[1]) : Number(C2);
}
const Ra$1 = {}, z$4 = (C2) => Ra$1[C2], Fi$1 = (C2, u3) => {
  Ra$1[C2] = u3;
};
let kg$1 = class kg2 {
  constructor(u3) {
    this.name = "polkadot", this.namespace = u3.namespace, this.events = z$4("events"), this.client = z$4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn.DEFAULT_CHAIN_CHANGED, `${this.name}:${u3}`);
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const P2 = Ct(i3);
      u3[P2] = this.createHttpProvider(P2, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft$2(u3, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new HttpConnection(d3, z$4("disableProviderPing")));
  }
};
let jg$1 = class jg2 {
  constructor(u3) {
    this.name = "eip155", this.namespace = u3.namespace, this.events = z$4("events"), this.client = z$4("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(u3) {
    switch (u3.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(u3);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
    }
    return this.namespace.methods.includes(u3.request.method) ? await this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(parseInt(u3), i3), this.chainId = parseInt(u3), this.events.emit(Vn.DEFAULT_CHAIN_CHANGED, `${this.name}:${u3}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId.toString();
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft$2(`${this.name}:${u3}`, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new HttpConnection(d3, z$4("disableProviderPing")));
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const P2 = parseInt(Ct(i3));
      u3[P2] = this.createHttpProvider(P2, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const u3 = this.chainId, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  async handleSwitchChain(u3) {
    var i3, d3;
    let P2 = u3.request.params ? (i3 = u3.request.params[0]) == null ? void 0 : i3.chainId : "0x0";
    P2 = P2.startsWith("0x") ? P2 : `0x${P2}`;
    const O2 = parseInt(P2, 16);
    if (this.isChainApproved(O2))
      this.setDefaultChain(`${O2}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
      await this.client.request({ topic: u3.topic, request: { method: u3.request.method, params: [{ chainId: P2 }] }, chainId: (d3 = this.namespace.chains) == null ? void 0 : d3[0] }), this.setDefaultChain(`${O2}`);
    else
      throw new Error(`Failed to switch to chain 'eip155:${O2}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(u3) {
    return this.namespace.chains.includes(`${this.name}:${u3}`);
  }
};
class nv {
  constructor(u3) {
    this.name = "solana", this.namespace = u3.namespace, this.events = z$4("events"), this.client = z$4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn.DEFAULT_CHAIN_CHANGED, `${this.name}:${u3}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const P2 = Ct(i3);
      u3[P2] = this.createHttpProvider(P2, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft$2(u3, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new HttpConnection(d3, z$4("disableProviderPing")));
  }
}
class tv {
  constructor(u3) {
    this.name = "cosmos", this.namespace = u3.namespace, this.events = z$4("events"), this.client = z$4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const P2 = Ct(i3);
      u3[P2] = this.createHttpProvider(P2, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft$2(u3, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new HttpConnection(d3, z$4("disableProviderPing")));
  }
}
class ev {
  constructor(u3) {
    this.name = "cip34", this.namespace = u3.namespace, this.events = z$4("events"), this.client = z$4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      const d3 = this.getCardanoRPCUrl(i3), P2 = Ct(i3);
      u3[P2] = this.createHttpProvider(P2, d3);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  getCardanoRPCUrl(u3) {
    const i3 = this.namespace.rpcMap;
    if (i3)
      return i3[u3];
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || this.getCardanoRPCUrl(u3);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new HttpConnection(d3, z$4("disableProviderPing")));
  }
}
class rv {
  constructor(u3) {
    this.name = "elrond", this.namespace = u3.namespace, this.events = z$4("events"), this.client = z$4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn.DEFAULT_CHAIN_CHANGED, `${this.name}:${u3}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const P2 = Ct(i3);
      u3[P2] = this.createHttpProvider(P2, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft$2(u3, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new HttpConnection(d3, z$4("disableProviderPing")));
  }
}
class iv {
  constructor(u3) {
    this.name = "multiversx", this.namespace = u3.namespace, this.events = z$4("events"), this.client = z$4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn.DEFAULT_CHAIN_CHANGED, `${this.name}:${u3}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const P2 = Ct(i3);
      u3[P2] = this.createHttpProvider(P2, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft$2(u3, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new HttpConnection(d3, z$4("disableProviderPing")));
  }
}
class sv {
  constructor(u3) {
    this.name = "near", this.namespace = u3.namespace, this.events = z$4("events"), this.client = z$4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    if (this.chainId = u3, !this.httpProviders[u3]) {
      const d3 = i3 || ft$2(`${this.name}:${u3}`, this.namespace);
      if (!d3)
        throw new Error(`No RPC url provided for chainId: ${u3}`);
      this.setHttpProvider(u3, d3);
    }
    this.events.emit(Vn.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      u3[i3] = this.createHttpProvider(i3, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft$2(u3, this.namespace);
    return typeof d3 > "u" ? void 0 : new JsonRpcProvider(new HttpConnection(d3, z$4("disableProviderPing")));
  }
}
var uv = Object.defineProperty, av = Object.defineProperties, ov = Object.getOwnPropertyDescriptors, ba = Object.getOwnPropertySymbols, fv = Object.prototype.hasOwnProperty, cv = Object.prototype.propertyIsEnumerable, Ta$1 = (C2, u3, i3) => u3 in C2 ? uv(C2, u3, { enumerable: true, configurable: true, writable: true, value: i3 }) : C2[u3] = i3, hr = (C2, u3) => {
  for (var i3 in u3 || (u3 = {}))
    fv.call(u3, i3) && Ta$1(C2, i3, u3[i3]);
  if (ba)
    for (var i3 of ba(u3))
      cv.call(u3, i3) && Ta$1(C2, i3, u3[i3]);
  return C2;
}, Mi$1 = (C2, u3) => av(C2, ov(u3));
class lr {
  constructor(u3) {
    this.events = new $g$1(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = false, this.maxPairingAttempts = 10, this.disableProviderPing = false, this.providerOpts = u3, this.logger = typeof u3?.logger < "u" && typeof u3?.logger != "string" ? u3.logger : cjs$7.pino(cjs$7.getDefaultLoggerOptions({ level: u3?.logger || Ia$1 })), this.disableProviderPing = u3?.disableProviderPing || false;
  }
  static async init(u3) {
    const i3 = new lr(u3);
    return await i3.initialize(), i3;
  }
  async request(u3, i3) {
    const [d3, P2] = this.validateChain(i3);
    if (!this.session)
      throw new Error("Please call connect() before request()");
    return await this.getProvider(d3).request({ request: hr({}, u3), chainId: `${d3}:${P2}`, topic: this.session.topic });
  }
  sendAsync(u3, i3, d3) {
    const P2 = (/* @__PURE__ */ new Date()).getTime();
    this.request(u3, d3).then((O2) => i3(null, formatJsonRpcResult(P2, O2))).catch((O2) => i3(O2, void 0));
  }
  async enable() {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var u3;
    if (!this.session)
      throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (u3 = this.session) == null ? void 0 : u3.topic, reason: U$2("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(u3) {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    if (this.setNamespaces(u3), await this.cleanupPendingPairings(), !u3.skipPairing)
      return await this.pair(u3.pairingTopic);
  }
  on(u3, i3) {
    this.events.on(u3, i3);
  }
  once(u3, i3) {
    this.events.once(u3, i3);
  }
  removeListener(u3, i3) {
    this.events.removeListener(u3, i3);
  }
  off(u3, i3) {
    this.events.off(u3, i3);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(u3) {
    this.shouldAbortPairingAttempt = false;
    let i3 = 0;
    do {
      if (this.shouldAbortPairingAttempt)
        throw new Error("Pairing aborted");
      if (i3 >= this.maxPairingAttempts)
        throw new Error("Max auto pairing attempts reached");
      const { uri: d3, approval: P2 } = await this.client.connect({ pairingTopic: u3, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      d3 && (this.uri = d3, this.events.emit("display_uri", d3)), await P2().then((O2) => {
        this.session = O2, this.namespaces || (this.namespaces = Vg$1(O2.namespaces), this.persist("namespaces", this.namespaces));
      }).catch((O2) => {
        if (O2.message !== oe$2)
          throw O2;
        i3++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(u3, i3) {
    try {
      if (!this.session)
        return;
      const [d3, P2] = this.validateChain(u3);
      this.getProvider(d3).setDefaultChain(P2, i3);
    } catch (d3) {
      if (!/Please call connect/.test(d3.message))
        throw d3;
    }
  }
  async cleanupPendingPairings(u3 = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const i3 = this.client.pairing.getAll();
    if (k$3(i3)) {
      for (const d3 of i3)
        u3.deletePairings ? this.client.core.expirer.set(d3.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(d3.topic);
      this.logger.info(`Inactive pairings cleared: ${i3.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = true;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const u3 = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[u3]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await Q$3.init({ logger: this.providerOpts.logger || Ia$1, relayUrl: this.providerOpts.relayUrl || Wg$1, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    if (!this.session)
      throw new Error("Session not initialized. Please call connect() before enable()");
    const u3 = [...new Set(Object.keys(this.session.namespaces).map((i3) => en(i3)))];
    Fi$1("client", this.client), Fi$1("events", this.events), Fi$1("disableProviderPing", this.disableProviderPing), u3.forEach((i3) => {
      if (!this.session)
        return;
      const d3 = Jg$1(i3, this.session), P2 = Sa$1(d3), O2 = Xg$1(this.namespaces, this.optionalNamespaces), $2 = Mi$1(hr({}, O2[i3]), { accounts: d3, chains: P2 });
      switch (i3) {
        case "eip155":
          this.rpcProviders[i3] = new jg$1({ namespace: $2 });
          break;
        case "solana":
          this.rpcProviders[i3] = new nv({ namespace: $2 });
          break;
        case "cosmos":
          this.rpcProviders[i3] = new tv({ namespace: $2 });
          break;
        case "polkadot":
          this.rpcProviders[i3] = new kg$1({ namespace: $2 });
          break;
        case "cip34":
          this.rpcProviders[i3] = new ev({ namespace: $2 });
          break;
        case "elrond":
          this.rpcProviders[i3] = new rv({ namespace: $2 });
          break;
        case "multiversx":
          this.rpcProviders[i3] = new iv({ namespace: $2 });
          break;
        case "near":
          this.rpcProviders[i3] = new sv({ namespace: $2 });
          break;
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u")
      throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (u3) => {
      this.events.emit("session_ping", u3);
    }), this.client.on("session_event", (u3) => {
      const { params: i3 } = u3, { event: d3 } = i3;
      if (d3.name === "accountsChanged") {
        const P2 = d3.data;
        P2 && k$3(P2) && this.events.emit("accountsChanged", P2.map(Qg$1));
      } else if (d3.name === "chainChanged") {
        const P2 = i3.chainId, O2 = i3.event.data, $2 = en(P2), En = Wi$1(P2) !== Wi$1(O2) ? `${$2}:${Wi$1(O2)}` : P2;
        this.onChainChanged(En);
      } else
        this.events.emit(d3.name, d3.data);
      this.events.emit("session_event", u3);
    }), this.client.on("session_update", ({ topic: u3, params: i3 }) => {
      var d3;
      const { namespaces: P2 } = i3, O2 = (d3 = this.client) == null ? void 0 : d3.session.get(u3);
      this.session = Mi$1(hr({}, O2), { namespaces: P2 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: u3, params: i3 });
    }), this.client.on("session_delete", async (u3) => {
      await this.cleanup(), this.events.emit("session_delete", u3), this.events.emit("disconnect", Mi$1(hr({}, U$2("USER_DISCONNECTED")), { data: u3.topic }));
    }), this.on(Vn.DEFAULT_CHAIN_CHANGED, (u3) => {
      this.onChainChanged(u3, true);
    });
  }
  getProvider(u3) {
    if (!this.rpcProviders[u3])
      throw new Error(`Provider not found: ${u3}`);
    return this.rpcProviders[u3];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((u3) => {
      var i3;
      this.getProvider(u3).updateNamespace((i3 = this.session) == null ? void 0 : i3.namespaces[u3]);
    });
  }
  setNamespaces(u3) {
    const { namespaces: i3, optionalNamespaces: d3, sessionProperties: P2 } = u3;
    i3 && Object.keys(i3).length && (this.namespaces = i3), d3 && Object.keys(d3).length && (this.optionalNamespaces = d3), this.sessionProperties = P2, this.persist("namespaces", i3), this.persist("optionalNamespaces", d3);
  }
  validateChain(u3) {
    const [i3, d3] = u3?.split(":") || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length)
      return [i3, d3];
    if (i3 && !Object.keys(this.namespaces || {}).map(($2) => en($2)).includes(i3))
      throw new Error(`Namespace '${i3}' is not configured. Please call connect() first with namespace config.`);
    if (i3 && d3)
      return [i3, d3];
    const P2 = en(Object.keys(this.namespaces)[0]), O2 = this.rpcProviders[P2].getDefaultChain();
    return [P2, O2];
  }
  async requestAccounts() {
    const [u3] = this.validateChain();
    return await this.getProvider(u3).requestAccounts();
  }
  onChainChanged(u3, i3 = false) {
    var d3;
    if (!this.namespaces)
      return;
    const [P2, O2] = this.validateChain(u3);
    i3 || this.getProvider(P2).setDefaultChain(O2), ((d3 = this.namespaces[P2]) != null ? d3 : this.namespaces[`${P2}:${O2}`]).defaultChain = O2, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", O2);
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: true });
  }
  persist(u3, i3) {
    this.client.core.storage.setItem(`${xa}/${u3}`, i3);
  }
  async getFromStore(u3) {
    return await this.client.core.storage.getItem(`${xa}/${u3}`);
  }
}
const hv = lr;
const P$4 = "wc", S$3 = "ethereum_provider", $$1 = `${P$4}@2:${S$3}:`, j$2 = "https://rpc.walletconnect.com/v1/", u$3 = ["eth_sendTransaction", "personal_sign"], E$3 = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"], m$4 = ["chainChanged", "accountsChanged"], _$3 = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var N$3 = Object.defineProperty, q$3 = Object.defineProperties, D$3 = Object.getOwnPropertyDescriptors, y$3 = Object.getOwnPropertySymbols, U$1 = Object.prototype.hasOwnProperty, Q$2 = Object.prototype.propertyIsEnumerable, O$3 = (a3, t2, s3) => t2 in a3 ? N$3(a3, t2, { enumerable: true, configurable: true, writable: true, value: s3 }) : a3[t2] = s3, p$4 = (a3, t2) => {
  for (var s3 in t2 || (t2 = {}))
    U$1.call(t2, s3) && O$3(a3, s3, t2[s3]);
  if (y$3)
    for (var s3 of y$3(t2))
      Q$2.call(t2, s3) && O$3(a3, s3, t2[s3]);
  return a3;
}, M$3 = (a3, t2) => q$3(a3, D$3(t2));
function g$3(a3) {
  return Number(a3[0].split(":")[1]);
}
function f$3(a3) {
  return `0x${a3.toString(16)}`;
}
function L$3(a3) {
  const { chains: t2, optionalChains: s3, methods: i3, optionalMethods: n4, events: e2, optionalEvents: h5, rpcMap: c2 } = a3;
  if (!k$6(t2))
    throw new Error("Invalid chains");
  const o2 = { chains: t2, methods: i3 || u$3, events: e2 || m$4, rpcMap: p$4({}, t2.length ? { [g$3(t2)]: c2[g$3(t2)] } : {}) }, r2 = e2?.filter((l2) => !m$4.includes(l2)), d3 = i3?.filter((l2) => !u$3.includes(l2));
  if (!s3 && !h5 && !n4 && !(r2 != null && r2.length) && !(d3 != null && d3.length))
    return { required: t2.length ? o2 : void 0 };
  const C2 = r2?.length && d3?.length || !s3, I3 = { chains: [...new Set(C2 ? o2.chains.concat(s3 || []) : s3)], methods: [...new Set(o2.methods.concat(n4 != null && n4.length ? n4 : E$3))], events: [...new Set(o2.events.concat(h5 != null && h5.length ? h5 : _$3))], rpcMap: c2 };
  return { required: t2.length ? o2 : void 0, optional: s3.length ? I3 : void 0 };
}
let v$4 = class v3 {
  constructor() {
    this.events = new eventsExports.EventEmitter(), this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = $$1, this.on = (t2, s3) => (this.events.on(t2, s3), this), this.once = (t2, s3) => (this.events.once(t2, s3), this), this.removeListener = (t2, s3) => (this.events.removeListener(t2, s3), this), this.off = (t2, s3) => (this.events.off(t2, s3), this), this.parseAccount = (t2) => this.isCompatibleChainId(t2) ? this.parseAccountId(t2).address : t2, this.signer = {}, this.rpc = {};
  }
  static async init(t2) {
    const s3 = new v3();
    return await s3.initialize(t2), s3;
  }
  async request(t2) {
    return await this.signer.request(t2, this.formatChainId(this.chainId));
  }
  sendAsync(t2, s3) {
    this.signer.sendAsync(t2, s3, this.formatChainId(this.chainId));
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : false;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : false;
  }
  async enable() {
    return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
  }
  async connect(t2) {
    if (!this.signer.client)
      throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(t2);
    const { required: s3, optional: i3 } = L$3(this.rpc);
    try {
      const n4 = await new Promise(async (h5, c2) => {
        var o2;
        this.rpc.showQrModal && ((o2 = this.modal) == null || o2.subscribeModal((r2) => {
          !r2.open && !this.signer.session && (this.signer.abortPairingAttempt(), c2(new Error("Connection request reset. Please try again.")));
        })), await this.signer.connect(M$3(p$4({ namespaces: p$4({}, s3 && { [this.namespace]: s3 }) }, i3 && { optionalNamespaces: { [this.namespace]: i3 } }), { pairingTopic: t2?.pairingTopic })).then((r2) => {
          h5(r2);
        }).catch((r2) => {
          c2(new Error(r2.message));
        });
      });
      if (!n4)
        return;
      const e2 = Un(n4.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : e2), this.setAccounts(e2), this.events.emit("connect", { chainId: f$3(this.chainId) });
    } catch (n4) {
      throw this.signer.logger.error(n4), n4;
    } finally {
      this.modal && this.modal.closeModal();
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset();
  }
  get isWalletConnect() {
    return true;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (t2) => {
      const { params: s3 } = t2, { event: i3 } = s3;
      i3.name === "accountsChanged" ? (this.accounts = this.parseAccounts(i3.data), this.events.emit("accountsChanged", this.accounts)) : i3.name === "chainChanged" ? this.setChainId(this.formatChainId(i3.data)) : this.events.emit(i3.name, i3.data), this.events.emit("session_event", t2);
    }), this.signer.on("chainChanged", (t2) => {
      const s3 = parseInt(t2);
      this.chainId = s3, this.events.emit("chainChanged", f$3(this.chainId)), this.persist();
    }), this.signer.on("session_update", (t2) => {
      this.events.emit("session_update", t2);
    }), this.signer.on("session_delete", (t2) => {
      this.reset(), this.events.emit("session_delete", t2), this.events.emit("disconnect", M$3(p$4({}, U$5("USER_DISCONNECTED")), { data: t2.topic, name: "USER_DISCONNECTED" }));
    }), this.signer.on("display_uri", (t2) => {
      var s3, i3;
      this.rpc.showQrModal && ((s3 = this.modal) == null || s3.closeModal(), (i3 = this.modal) == null || i3.openModal({ uri: t2 })), this.events.emit("display_uri", t2);
    });
  }
  switchEthereumChain(t2) {
    this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t2.toString(16) }] });
  }
  isCompatibleChainId(t2) {
    return typeof t2 == "string" ? t2.startsWith(`${this.namespace}:`) : false;
  }
  formatChainId(t2) {
    return `${this.namespace}:${t2}`;
  }
  parseChainId(t2) {
    return Number(t2.split(":")[1]);
  }
  setChainIds(t2) {
    const s3 = t2.filter((i3) => this.isCompatibleChainId(i3)).map((i3) => this.parseChainId(i3));
    s3.length && (this.chainId = s3[0], this.events.emit("chainChanged", f$3(this.chainId)), this.persist());
  }
  setChainId(t2) {
    if (this.isCompatibleChainId(t2)) {
      const s3 = this.parseChainId(t2);
      this.chainId = s3, this.switchEthereumChain(s3);
    }
  }
  parseAccountId(t2) {
    const [s3, i3, n4] = t2.split(":");
    return { chainId: `${s3}:${i3}`, address: n4 };
  }
  setAccounts(t2) {
    this.accounts = t2.filter((s3) => this.parseChainId(this.parseAccountId(s3).chainId) === this.chainId).map((s3) => this.parseAccountId(s3).address), this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(t2) {
    var s3, i3;
    const n4 = (s3 = t2?.chains) != null ? s3 : [], e2 = (i3 = t2?.optionalChains) != null ? i3 : [], h5 = n4.concat(e2);
    if (!h5.length)
      throw new Error("No chains specified in either `chains` or `optionalChains`");
    const c2 = n4.length ? t2?.methods || u$3 : [], o2 = n4.length ? t2?.events || m$4 : [], r2 = t2?.optionalMethods || [], d3 = t2?.optionalEvents || [], C2 = t2?.rpcMap || this.buildRpcMap(h5, t2.projectId), I3 = t2?.qrModalOptions || void 0;
    return { chains: n4?.map((l2) => this.formatChainId(l2)), optionalChains: e2.map((l2) => this.formatChainId(l2)), methods: c2, events: o2, optionalMethods: r2, optionalEvents: d3, rpcMap: C2, showQrModal: !!(t2 != null && t2.showQrModal), qrModalOptions: I3, projectId: t2.projectId, metadata: t2.metadata };
  }
  buildRpcMap(t2, s3) {
    const i3 = {};
    return t2.forEach((n4) => {
      i3[n4] = this.getRpcUrl(n4, s3);
    }), i3;
  }
  async initialize(t2) {
    if (this.rpc = this.getRpcConfig(t2), this.chainId = this.rpc.chains.length ? g$3(this.rpc.chains) : g$3(this.rpc.optionalChains), this.signer = await hv.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata, disableProviderPing: t2.disableProviderPing, relayUrl: t2.relayUrl, storageOptions: t2.storageOptions }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
      let s3;
      try {
        const { WalletConnectModal: i3 } = await __vitePreload(() => import("./index-742f1f4c.js").then((n4) => n4.i), true ? [] : void 0);
        s3 = i3;
      } catch {
        throw new Error("To use QR modal, please install @walletconnect/modal package");
      }
      if (s3)
        try {
          this.modal = new s3(p$4({ projectId: this.rpc.projectId }, this.rpc.qrModalOptions));
        } catch (i3) {
          throw this.signer.logger.error(i3), new Error("Could not generate WalletConnectModal Instance");
        }
    }
  }
  loadConnectOpts(t2) {
    if (!t2)
      return;
    const { chains: s3, optionalChains: i3, rpcMap: n4 } = t2;
    s3 && k$6(s3) && (this.rpc.chains = s3.map((e2) => this.formatChainId(e2)), s3.forEach((e2) => {
      this.rpc.rpcMap[e2] = n4?.[e2] || this.getRpcUrl(e2);
    })), i3 && k$6(i3) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i3?.map((e2) => this.formatChainId(e2)), i3.forEach((e2) => {
      this.rpc.rpcMap[e2] = n4?.[e2] || this.getRpcUrl(e2);
    }));
  }
  getRpcUrl(t2, s3) {
    var i3;
    return ((i3 = this.rpc.rpcMap) == null ? void 0 : i3[t2]) || `${j$2}?chainId=eip155:${t2}&projectId=${s3 || this.rpc.projectId}`;
  }
  async loadPersistedSession() {
    if (!this.session)
      return;
    const t2 = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), s3 = this.session.namespaces[`${this.namespace}:${t2}`] ? this.session.namespaces[`${this.namespace}:${t2}`] : this.session.namespaces[this.namespace];
    this.setChainIds(t2 ? [this.formatChainId(t2)] : s3?.accounts), this.setAccounts(s3?.accounts);
  }
  reset() {
    this.chainId = 1, this.accounts = [];
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
  }
  parseAccounts(t2) {
    return typeof t2 == "string" || t2 instanceof String ? [this.parseAccount(t2)] : t2.map((s3) => this.parseAccount(s3));
  }
};
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
const EthersConstantsUtil = {
  WALLET_ID: "@w3m/wallet_id",
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3
};
const EthersHelpersUtil = {
  getCaipDefaultChain(chain) {
    if (!chain) {
      return void 0;
    }
    return {
      id: `${ConstantsUtil.EIP155}:${chain.chainId}`,
      name: chain.name,
      imageId: PresetsUtil.EIP155NetworkImageIds[chain.chainId]
    };
  },
  hexStringToNumber(value) {
    const string2 = value.startsWith("0x") ? value.slice(2) : value;
    const number2 = parseInt(string2, 16);
    return number2;
  },
  numberToHexString(value) {
    return `0x${value.toString(16)}`;
  },
  async getUserInfo(provider) {
    const [address, chainId] = await Promise.all([
      EthersHelpersUtil.getAddress(provider),
      EthersHelpersUtil.getChainId(provider)
    ]);
    return { chainId, address };
  },
  async getChainId(provider) {
    const chainId = await provider.request({ method: "eth_chainId" });
    return Number(chainId);
  },
  async getAddress(provider) {
    const [address] = await provider.request({ method: "eth_accounts" });
    return address;
  },
  async addEthereumChain(provider, chain) {
    await provider.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: EthersHelpersUtil.numberToHexString(chain.chainId),
          rpcUrls: [chain.rpcUrl],
          chainName: chain.name,
          nativeCurrency: {
            name: chain.currency,
            decimals: 18,
            symbol: chain.currency
          },
          blockExplorerUrls: [chain.explorerUrl],
          iconUrls: [PresetsUtil.EIP155NetworkImageIds[chain.chainId]]
        }
      ]
    });
  }
};
const state$3 = proxy({
  provider: void 0,
  providerType: void 0,
  address: void 0,
  chainId: void 0,
  isConnected: false
});
const EthersStoreUtil = {
  state: state$3,
  subscribeKey(key2, callback) {
    return subscribeKey(state$3, key2, callback);
  },
  subscribe(callback) {
    return subscribe(state$3, () => callback(state$3));
  },
  setProvider(provider) {
    if (provider) {
      state$3.provider = ref(provider);
    }
  },
  setProviderType(providerType) {
    state$3.providerType = providerType;
  },
  setAddress(address) {
    state$3.address = address;
  },
  setChainId(chainId) {
    state$3.chainId = chainId;
  },
  setIsConnected(isConnected) {
    state$3.isConnected = isConnected;
  },
  setError(error) {
    state$3.error = error;
  },
  reset() {
    state$3.provider = void 0;
    state$3.address = void 0;
    state$3.chainId = void 0;
    state$3.providerType = void 0;
    state$3.isConnected = false;
    state$3.error = void 0;
  }
};
class Web3Modal extends Web3ModalScaffold {
  constructor(options) {
    const { ethersConfig, siweConfig, chains, defaultChain, tokens, chainImages, _sdkVersion, ...w3mOptions } = options;
    if (!ethersConfig) {
      throw new Error("web3modal:constructor - ethersConfig is undefined");
    }
    if (!w3mOptions.projectId) {
      throw new Error("web3modal:constructor - projectId is undefined");
    }
    const networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => {
        const chainId = HelpersUtil.caipNetworkIdToNumber(caipNetwork?.id);
        if (chainId) {
          try {
            await this.switchNetwork(chainId);
          } catch (error) {
            EthersStoreUtil.setError(error);
          }
        }
      },
      getApprovedCaipNetworksData: async () => new Promise(async (resolve) => {
        const walletChoice = localStorage.getItem(EthersConstantsUtil.WALLET_ID);
        if (walletChoice?.includes(ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID)) {
          const provider = await this.getWalletConnectProvider();
          if (!provider) {
            throw new Error("networkControllerClient:getApprovedCaipNetworks - provider is undefined");
          }
          const ns2 = provider.signer?.session?.namespaces;
          const nsMethods = ns2?.[ConstantsUtil.EIP155]?.methods;
          const nsChains = ns2?.[ConstantsUtil.EIP155]?.chains;
          const result = {
            supportsAllNetworks: nsMethods?.includes(ConstantsUtil.ADD_CHAIN_METHOD) ?? false,
            approvedCaipNetworkIds: nsChains
          };
          resolve(result);
        } else {
          const result = {
            approvedCaipNetworkIds: void 0,
            supportsAllNetworks: true
          };
          resolve(result);
        }
      })
    };
    const connectionControllerClient = {
      connectWalletConnect: async (onUri) => {
        const WalletConnectProvider = await this.getWalletConnectProvider();
        if (!WalletConnectProvider) {
          throw new Error("connectionControllerClient:getWalletConnectUri - provider is undefined");
        }
        WalletConnectProvider.on("display_uri", (uri) => {
          onUri(uri);
        });
        await WalletConnectProvider.connect();
        await this.setWalletConnectProvider();
      },
      connectExternal: async ({ id: id2, info, provider }) => {
        if (id2 === ConstantsUtil.INJECTED_CONNECTOR_ID) {
          const InjectedProvider = ethersConfig.injected;
          if (!InjectedProvider) {
            throw new Error("connectionControllerClient:connectInjected - provider is undefined");
          }
          try {
            await InjectedProvider.request({ method: "eth_requestAccounts" });
            this.setInjectedProvider(ethersConfig);
          } catch (error) {
            EthersStoreUtil.setError(error);
          }
        } else if (id2 === ConstantsUtil.EIP6963_CONNECTOR_ID && info && provider) {
          try {
            await provider.request({ method: "eth_requestAccounts" });
          } catch (error) {
            EthersStoreUtil.setError(error);
          }
          this.setEIP6963Provider(provider, info.name);
        } else if (id2 === ConstantsUtil.COINBASE_CONNECTOR_ID) {
          const CoinbaseProvider = ethersConfig.coinbase;
          if (!CoinbaseProvider) {
            throw new Error("connectionControllerClient:connectCoinbase - connector is undefined");
          }
          try {
            this.setCoinbaseProvider(ethersConfig);
            await CoinbaseProvider.request({ method: "eth_requestAccounts" });
          } catch (error) {
            EthersStoreUtil.setError(error);
          }
        }
      },
      checkInstalled(ids) {
        if (!ids) {
          return Boolean(window.ethereum);
        }
        if (ethersConfig.injected) {
          if (!window?.ethereum) {
            return false;
          }
        }
        return ids.some((id2) => Boolean(window.ethereum?.[String(id2)]));
      },
      disconnect: async () => {
        const provider = EthersStoreUtil.state.provider;
        const providerType = EthersStoreUtil.state.providerType;
        localStorage.removeItem(EthersConstantsUtil.WALLET_ID);
        EthersStoreUtil.reset();
        if (siweConfig?.options?.signOutOnDisconnect) {
          await siweConfig.signOut();
        }
        if (providerType === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID) {
          const WalletConnectProvider = provider;
          await WalletConnectProvider.disconnect();
        } else if (provider) {
          provider.emit("disconnect");
        }
      },
      signMessage: async (message) => {
        const provider = EthersStoreUtil.state.provider;
        if (!provider) {
          throw new Error("connectionControllerClient:signMessage - provider is undefined");
        }
        const signature2 = await provider.request({
          method: "personal_sign",
          params: [message, this.getAddress()]
        });
        return signature2;
      }
    };
    super({
      networkControllerClient,
      connectionControllerClient,
      siweControllerClient: siweConfig,
      defaultChain: EthersHelpersUtil.getCaipDefaultChain(defaultChain),
      tokens: HelpersUtil.getCaipTokens(tokens),
      _sdkVersion: _sdkVersion ?? `html-ethers5-${ConstantsUtil.VERSION}`,
      ...w3mOptions
    });
    this.hasSyncedConnectedAccount = false;
    this.EIP6963Providers = [];
    this.options = void 0;
    this.options = options;
    this.metadata = ethersConfig.metadata;
    this.projectId = w3mOptions.projectId;
    this.chains = chains;
    this.createProvider();
    EthersStoreUtil.subscribeKey("address", () => {
      this.syncAccount();
    });
    EthersStoreUtil.subscribeKey("chainId", () => {
      this.syncNetwork(chainImages);
    });
    this.syncRequestedNetworks(chains, chainImages);
    this.syncConnectors(ethersConfig);
    if (ethersConfig.EIP6963) {
      if (typeof window !== "undefined") {
        this.listenConnectors(ethersConfig.EIP6963);
        this.checkActive6963Provider();
      }
    }
    if (ethersConfig.injected) {
      this.checkActiveInjectedProvider(ethersConfig);
    }
    if (ethersConfig.coinbase) {
      this.checkActiveCoinbaseProvider(ethersConfig);
    }
  }
  getState() {
    const state2 = super.getState();
    return {
      ...state2,
      selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(state2.selectedNetworkId)
    };
  }
  subscribeState(callback) {
    return super.subscribeState((state2) => callback({
      ...state2,
      selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(state2.selectedNetworkId)
    }));
  }
  setAddress(address) {
    const originalAddress = address ? getAddress(address) : void 0;
    EthersStoreUtil.setAddress(originalAddress);
  }
  getAddress() {
    const { address } = EthersStoreUtil.state;
    return address ? getAddress(address) : address;
  }
  getError() {
    return EthersStoreUtil.state.error;
  }
  getChainId() {
    return EthersStoreUtil.state.chainId;
  }
  getIsConnected() {
    return EthersStoreUtil.state.isConnected;
  }
  getWalletProvider() {
    return EthersStoreUtil.state.provider;
  }
  getWalletProviderType() {
    return EthersStoreUtil.state.providerType;
  }
  subscribeProvider(callback) {
    return EthersStoreUtil.subscribe(callback);
  }
  async disconnect() {
    const { provider, providerType } = EthersStoreUtil.state;
    localStorage.removeItem(EthersConstantsUtil.WALLET_ID);
    EthersStoreUtil.reset();
    if (providerType === "injected" || providerType === "eip6963") {
      provider?.emit("disconnect");
    } else {
      await provider.disconnect();
    }
  }
  createProvider() {
    if (!this.walletConnectProviderInitPromise && typeof window !== "undefined") {
      this.walletConnectProviderInitPromise = this.initWalletConnectProvider();
    }
    return this.walletConnectProviderInitPromise;
  }
  async initWalletConnectProvider() {
    const walletConnectProviderOptions = {
      projectId: this.projectId,
      showQrModal: false,
      rpcMap: this.chains ? this.chains.reduce((map2, chain) => {
        map2[chain.chainId] = chain.rpcUrl;
        return map2;
      }, {}) : {},
      optionalChains: [...this.chains.map((chain) => chain.chainId)],
      metadata: {
        name: this.metadata ? this.metadata.name : "",
        description: this.metadata ? this.metadata.description : "",
        url: this.metadata ? this.metadata.url : "",
        icons: this.metadata ? this.metadata.icons : [""]
      }
    };
    this.walletConnectProvider = await v$4.init(walletConnectProviderOptions);
    await this.checkActiveWalletConnectProvider();
  }
  async getWalletConnectProvider() {
    if (!this.walletConnectProvider) {
      try {
        await this.createProvider();
      } catch (error) {
        EthersStoreUtil.setError(error);
      }
    }
    return this.walletConnectProvider;
  }
  syncRequestedNetworks(chains, chainImages) {
    const requestedCaipNetworks = chains?.map((chain) => ({
      id: `${ConstantsUtil.EIP155}:${chain.chainId}`,
      name: chain.name,
      imageId: PresetsUtil.EIP155NetworkImageIds[chain.chainId],
      imageUrl: chainImages?.[chain.chainId]
    }));
    this.setRequestedCaipNetworks(requestedCaipNetworks ?? []);
  }
  async checkActiveWalletConnectProvider() {
    const WalletConnectProvider = await this.getWalletConnectProvider();
    const walletId = localStorage.getItem(EthersConstantsUtil.WALLET_ID);
    if (WalletConnectProvider) {
      if (walletId === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID) {
        await this.setWalletConnectProvider();
      }
    }
  }
  checkActiveInjectedProvider(config2) {
    const InjectedProvider = config2.injected;
    const walletId = localStorage.getItem(EthersConstantsUtil.WALLET_ID);
    if (InjectedProvider) {
      if (walletId === ConstantsUtil.INJECTED_CONNECTOR_ID) {
        this.setInjectedProvider(config2);
        this.watchInjected(config2);
      }
    }
  }
  checkActiveCoinbaseProvider(config2) {
    const CoinbaseProvider = config2.coinbase;
    const walletId = localStorage.getItem(EthersConstantsUtil.WALLET_ID);
    if (CoinbaseProvider) {
      if (walletId === ConstantsUtil.COINBASE_CONNECTOR_ID) {
        if (CoinbaseProvider._addresses && CoinbaseProvider._addresses?.length > 0) {
          this.setCoinbaseProvider(config2);
          this.watchCoinbase(config2);
        } else {
          localStorage.removeItem(EthersConstantsUtil.WALLET_ID);
          EthersStoreUtil.reset();
        }
      }
    }
  }
  checkActive6963Provider() {
    const currentActiveWallet = window?.localStorage.getItem(EthersConstantsUtil.WALLET_ID);
    if (currentActiveWallet) {
      const currentProvider = this.EIP6963Providers.find((provider) => provider.name === currentActiveWallet);
      if (currentProvider) {
        this.setEIP6963Provider(currentProvider.provider, currentProvider.name);
      }
    }
  }
  async setWalletConnectProvider() {
    window?.localStorage.setItem(EthersConstantsUtil.WALLET_ID, ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID);
    const WalletConnectProvider = await this.getWalletConnectProvider();
    if (WalletConnectProvider) {
      EthersStoreUtil.setChainId(WalletConnectProvider.chainId);
      EthersStoreUtil.setProviderType("walletConnect");
      EthersStoreUtil.setProvider(WalletConnectProvider);
      EthersStoreUtil.setIsConnected(true);
      this.setAddress(WalletConnectProvider.accounts?.[0]);
      this.watchWalletConnect();
    }
  }
  async setInjectedProvider(config2) {
    window?.localStorage.setItem(EthersConstantsUtil.WALLET_ID, ConstantsUtil.INJECTED_CONNECTOR_ID);
    const InjectedProvider = config2.injected;
    if (InjectedProvider) {
      const { address, chainId } = await EthersHelpersUtil.getUserInfo(InjectedProvider);
      if (address && chainId) {
        EthersStoreUtil.setChainId(chainId);
        EthersStoreUtil.setProviderType("injected");
        EthersStoreUtil.setProvider(config2.injected);
        EthersStoreUtil.setIsConnected(true);
        this.setAddress(address);
        this.watchCoinbase(config2);
      }
    }
  }
  async setEIP6963Provider(provider, name2) {
    window?.localStorage.setItem(EthersConstantsUtil.WALLET_ID, name2);
    if (provider) {
      const { address, chainId } = await EthersHelpersUtil.getUserInfo(provider);
      if (address && chainId) {
        EthersStoreUtil.setChainId(chainId);
        EthersStoreUtil.setProviderType("eip6963");
        EthersStoreUtil.setProvider(provider);
        EthersStoreUtil.setIsConnected(true);
        this.setAddress(address);
        this.watchEIP6963(provider);
      }
    }
  }
  async setCoinbaseProvider(config2) {
    window?.localStorage.setItem(EthersConstantsUtil.WALLET_ID, ConstantsUtil.COINBASE_CONNECTOR_ID);
    const CoinbaseProvider = config2.coinbase;
    if (CoinbaseProvider) {
      const { address, chainId } = await EthersHelpersUtil.getUserInfo(CoinbaseProvider);
      if (address && chainId) {
        EthersStoreUtil.setChainId(chainId);
        EthersStoreUtil.setProviderType("coinbaseWallet");
        EthersStoreUtil.setProvider(config2.coinbase);
        EthersStoreUtil.setIsConnected(true);
        this.setAddress(address);
        this.watchCoinbase(config2);
      }
    }
  }
  async watchWalletConnect() {
    const WalletConnectProvider = await this.getWalletConnectProvider();
    function disconnectHandler() {
      localStorage.removeItem(EthersConstantsUtil.WALLET_ID);
      EthersStoreUtil.reset();
      WalletConnectProvider?.removeListener("disconnect", disconnectHandler);
      WalletConnectProvider?.removeListener("accountsChanged", accountsChangedHandler);
      WalletConnectProvider?.removeListener("chainChanged", chainChangedHandler);
    }
    function chainChangedHandler(chainId) {
      if (chainId) {
        const chain = EthersHelpersUtil.hexStringToNumber(chainId);
        EthersStoreUtil.setChainId(chain);
      }
    }
    const accountsChangedHandler = async (accounts) => {
      if (accounts.length > 0) {
        await this.setWalletConnectProvider();
      }
    };
    if (WalletConnectProvider) {
      WalletConnectProvider.on("disconnect", disconnectHandler);
      WalletConnectProvider.on("accountsChanged", accountsChangedHandler);
      WalletConnectProvider.on("chainChanged", chainChangedHandler);
    }
  }
  watchInjected(config2) {
    const InjectedProvider = config2.injected;
    function disconnectHandler() {
      localStorage.removeItem(EthersConstantsUtil.WALLET_ID);
      EthersStoreUtil.reset();
      InjectedProvider?.removeListener("disconnect", disconnectHandler);
      InjectedProvider?.removeListener("accountsChanged", accountsChangedHandler);
      InjectedProvider?.removeListener("chainChanged", chainChangedHandler);
    }
    function accountsChangedHandler(accounts) {
      const currentAccount = accounts?.[0];
      if (currentAccount) {
        EthersStoreUtil.setAddress(getAddress(currentAccount));
      } else {
        localStorage.removeItem(EthersConstantsUtil.WALLET_ID);
        EthersStoreUtil.reset();
      }
    }
    function chainChangedHandler(chainId) {
      if (chainId) {
        const chain = typeof chainId === "string" ? EthersHelpersUtil.hexStringToNumber(chainId) : Number(chainId);
        EthersStoreUtil.setChainId(chain);
      }
    }
    if (InjectedProvider) {
      InjectedProvider.on("disconnect", disconnectHandler);
      InjectedProvider.on("accountsChanged", accountsChangedHandler);
      InjectedProvider.on("chainChanged", chainChangedHandler);
    }
  }
  watchEIP6963(provider) {
    function disconnectHandler() {
      localStorage.removeItem(EthersConstantsUtil.WALLET_ID);
      EthersStoreUtil.reset();
      provider.removeListener("disconnect", disconnectHandler);
      provider.removeListener("accountsChanged", accountsChangedHandler);
      provider.removeListener("chainChanged", chainChangedHandler);
    }
    function accountsChangedHandler(accounts) {
      const currentAccount = accounts?.[0];
      if (currentAccount) {
        EthersStoreUtil.setAddress(getAddress(currentAccount));
      } else {
        localStorage.removeItem(EthersConstantsUtil.WALLET_ID);
        EthersStoreUtil.reset();
      }
    }
    function chainChangedHandler(chainId) {
      if (chainId) {
        const chain = typeof chainId === "string" ? EthersHelpersUtil.hexStringToNumber(chainId) : Number(chainId);
        EthersStoreUtil.setChainId(chain);
      }
    }
    provider.on("disconnect", disconnectHandler);
    provider.on("accountsChanged", accountsChangedHandler);
    provider.on("chainChanged", chainChangedHandler);
  }
  watchCoinbase(config2) {
    const CoinbaseProvider = config2.coinbase;
    const walletId = localStorage.getItem(EthersConstantsUtil.WALLET_ID);
    function disconnectHandler() {
      localStorage.removeItem(EthersConstantsUtil.WALLET_ID);
      EthersStoreUtil.reset();
      CoinbaseProvider?.removeListener("disconnect", disconnectHandler);
      CoinbaseProvider?.removeListener("accountsChanged", accountsChangedHandler);
      CoinbaseProvider?.removeListener("chainChanged", chainChangedHandler);
    }
    function accountsChangedHandler(accounts) {
      if (accounts.length === 0) {
        localStorage.removeItem(EthersConstantsUtil.WALLET_ID);
        EthersStoreUtil.reset();
      } else {
        EthersStoreUtil.setAddress(accounts[0]);
      }
    }
    function chainChangedHandler(chainId) {
      if (chainId && walletId === ConstantsUtil.COINBASE_CONNECTOR_ID) {
        const chain = Number(chainId);
        EthersStoreUtil.setChainId(chain);
      }
    }
    if (CoinbaseProvider) {
      CoinbaseProvider.on("disconnect", disconnectHandler);
      CoinbaseProvider.on("accountsChanged", accountsChangedHandler);
      CoinbaseProvider.on("chainChanged", chainChangedHandler);
    }
  }
  async syncAccount() {
    const address = EthersStoreUtil.state.address;
    const chainId = EthersStoreUtil.state.chainId;
    const isConnected = EthersStoreUtil.state.isConnected;
    this.resetAccount();
    if (isConnected && address && chainId) {
      const caipAddress = `${ConstantsUtil.EIP155}:${chainId}:${address}`;
      this.setIsConnected(isConnected);
      this.setCaipAddress(caipAddress);
      await Promise.all([
        this.syncProfile(address),
        this.syncBalance(address),
        this.getApprovedCaipNetworksData()
      ]);
      this.hasSyncedConnectedAccount = true;
    } else if (!isConnected && this.hasSyncedConnectedAccount) {
      this.resetWcConnection();
      this.resetNetwork();
    }
  }
  async syncNetwork(chainImages) {
    const address = EthersStoreUtil.state.address;
    const chainId = EthersStoreUtil.state.chainId;
    const isConnected = EthersStoreUtil.state.isConnected;
    if (this.chains) {
      const chain = this.chains.find((c2) => c2.chainId === chainId);
      if (chain) {
        const caipChainId = `${ConstantsUtil.EIP155}:${chain.chainId}`;
        this.setCaipNetwork({
          id: caipChainId,
          name: chain.name,
          imageId: PresetsUtil.EIP155NetworkImageIds[chain.chainId],
          imageUrl: chainImages?.[chain.chainId]
        });
        if (isConnected && address) {
          const caipAddress = `${ConstantsUtil.EIP155}:${chainId}:${address}`;
          this.setCaipAddress(caipAddress);
          if (chain.explorerUrl) {
            const url = `${chain.explorerUrl}/address/${address}`;
            this.setAddressExplorerUrl(url);
          } else {
            this.setAddressExplorerUrl(void 0);
          }
          if (this.hasSyncedConnectedAccount) {
            await this.syncBalance(address);
          }
        }
      }
    }
  }
  async syncProfile(address) {
    const chainId = EthersStoreUtil.state.chainId;
    if (chainId === 1) {
      const ensProvider = new InfuraProvider("mainnet");
      const name2 = await ensProvider.lookupAddress(address);
      const avatar = await ensProvider.getAvatar(address);
      if (name2) {
        this.setProfileName(name2);
      }
      if (avatar) {
        this.setProfileImage(avatar);
      }
    } else {
      this.setProfileName(null);
      this.setProfileImage(null);
    }
  }
  async syncBalance(address) {
    const chainId = EthersStoreUtil.state.chainId;
    if (chainId && this.chains) {
      const chain = this.chains.find((c2) => c2.chainId === chainId);
      if (chain) {
        const JsonRpcProvider3 = new JsonRpcProvider$1(chain.rpcUrl, {
          chainId,
          name: chain.name
        });
        if (JsonRpcProvider3) {
          const balance = await JsonRpcProvider3.getBalance(address);
          const formattedBalance = formatEther(balance);
          this.setBalance(formattedBalance, chain.currency);
        }
      }
    }
  }
  async switchNetwork(chainId) {
    const provider = EthersStoreUtil.state.provider;
    const providerType = EthersStoreUtil.state.providerType;
    if (this.chains) {
      const chain = this.chains.find((c2) => c2.chainId === chainId);
      if (providerType === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID && chain) {
        const WalletConnectProvider = provider;
        if (WalletConnectProvider) {
          try {
            await WalletConnectProvider.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: EthersHelpersUtil.numberToHexString(chain.chainId) }]
            });
            EthersStoreUtil.setChainId(chainId);
          } catch (switchError) {
            if (switchError.code === EthersConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === EthersConstantsUtil.ERROR_CODE_DEFAULT || switchError?.data?.originalError?.code === EthersConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
              await EthersHelpersUtil.addEthereumChain(WalletConnectProvider, chain);
            } else {
              throw new Error("Chain is not supported");
            }
          }
        }
      } else if (providerType === ConstantsUtil.INJECTED_CONNECTOR_ID && chain) {
        const InjectedProvider = provider;
        if (InjectedProvider) {
          try {
            await InjectedProvider.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: EthersHelpersUtil.numberToHexString(chain.chainId) }]
            });
            EthersStoreUtil.setChainId(chain.chainId);
          } catch (switchError) {
            if (switchError.code === EthersConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === EthersConstantsUtil.ERROR_CODE_DEFAULT || switchError?.data?.originalError?.code === EthersConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
              await EthersHelpersUtil.addEthereumChain(InjectedProvider, chain);
            } else {
              throw new Error("Chain is not supported");
            }
          }
        }
      } else if (providerType === ConstantsUtil.EIP6963_CONNECTOR_ID && chain) {
        const EIP6963Provider = provider;
        if (EIP6963Provider) {
          try {
            await EIP6963Provider.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: EthersHelpersUtil.numberToHexString(chain.chainId) }]
            });
            EthersStoreUtil.setChainId(chain.chainId);
          } catch (switchError) {
            if (switchError.code === EthersConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === EthersConstantsUtil.ERROR_CODE_DEFAULT || switchError?.data?.originalError?.code === EthersConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
              await EthersHelpersUtil.addEthereumChain(EIP6963Provider, chain);
            } else {
              throw new Error("Chain is not supported");
            }
          }
        }
      } else if (providerType === ConstantsUtil.COINBASE_CONNECTOR_ID && chain) {
        const CoinbaseProvider = provider;
        if (CoinbaseProvider) {
          try {
            await CoinbaseProvider.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: EthersHelpersUtil.numberToHexString(chain.chainId) }]
            });
            EthersStoreUtil.setChainId(chain.chainId);
          } catch (switchError) {
            if (switchError.code === EthersConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === EthersConstantsUtil.ERROR_CODE_DEFAULT || switchError?.data?.originalError?.code === EthersConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
              await EthersHelpersUtil.addEthereumChain(CoinbaseProvider, chain);
            }
          }
        }
      }
    }
  }
  syncConnectors(config2) {
    const w3mConnectors = [];
    const connectorType = PresetsUtil.ConnectorTypesMap[ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID];
    {
      w3mConnectors.push({
        id: ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID,
        explorerId: PresetsUtil.ConnectorExplorerIds[ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID],
        imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID],
        imageUrl: this.options?.connectorImages?.[ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID],
        name: PresetsUtil.ConnectorNamesMap[ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID],
        type: connectorType
      });
    }
    if (config2.injected) {
      const injectedConnectorType = PresetsUtil.ConnectorTypesMap[ConstantsUtil.INJECTED_CONNECTOR_ID];
      {
        w3mConnectors.push({
          id: ConstantsUtil.INJECTED_CONNECTOR_ID,
          explorerId: PresetsUtil.ConnectorExplorerIds[ConstantsUtil.INJECTED_CONNECTOR_ID],
          imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.INJECTED_CONNECTOR_ID],
          imageUrl: this.options?.connectorImages?.[ConstantsUtil.INJECTED_CONNECTOR_ID],
          name: PresetsUtil.ConnectorNamesMap[ConstantsUtil.INJECTED_CONNECTOR_ID],
          type: injectedConnectorType
        });
      }
    }
    if (config2.coinbase) {
      w3mConnectors.push({
        id: ConstantsUtil.COINBASE_CONNECTOR_ID,
        explorerId: PresetsUtil.ConnectorExplorerIds[ConstantsUtil.COINBASE_CONNECTOR_ID],
        imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.COINBASE_CONNECTOR_ID],
        imageUrl: this.options?.connectorImages?.[ConstantsUtil.COINBASE_CONNECTOR_ID],
        name: PresetsUtil.ConnectorNamesMap[ConstantsUtil.COINBASE_CONNECTOR_ID],
        type: "EXTERNAL"
      });
    }
    this.setConnectors(w3mConnectors);
  }
  eip6963EventHandler(event) {
    if (event.detail) {
      const { info, provider } = event.detail;
      const connectors = this.getConnectors();
      const existingConnector = connectors.find((c2) => c2.name === info.name);
      if (!existingConnector) {
        const type2 = PresetsUtil.ConnectorTypesMap[ConstantsUtil.EIP6963_CONNECTOR_ID];
        {
          this.addConnector({
            id: ConstantsUtil.EIP6963_CONNECTOR_ID,
            type: type2,
            imageUrl: info.icon ?? this.options?.connectorImages?.[ConstantsUtil.EIP6963_CONNECTOR_ID],
            name: info.name,
            provider,
            info
          });
          const eip6963ProviderObj = {
            name: info.name,
            provider
          };
          this.EIP6963Providers.push(eip6963ProviderObj);
        }
      }
    }
  }
  listenConnectors(enableEIP6963) {
    if (typeof window !== "undefined" && enableEIP6963) {
      const handler = this.eip6963EventHandler.bind(this);
      window.addEventListener(ConstantsUtil.EIP6963_ANNOUNCE_EVENT, handler);
      window.dispatchEvent(new Event(ConstantsUtil.EIP6963_REQUEST_EVENT));
    }
  }
}
var buffer$5 = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base642 = require$$0$1b;
  const ieee7542 = require$$1$G;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr2 = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr2, proto);
      return arr2.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf2 = new Uint8Array(length2);
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    const b4 = fromObject(value);
    if (b4)
      return b4;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc3(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc3(size2, fill, encoding);
  };
  function allocUnsafe2(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length2 = byteLength2(string2, encoding) | 0;
    let buf2 = createBuffer(length2);
    const actual = buf2.write(string2, encoding);
    if (actual !== length2) {
      buf2 = buf2.slice(0, actual);
    }
    return buf2;
  }
  function fromArrayLike(array2) {
    const length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
    const buf2 = createBuffer(length2);
    for (let i3 = 0; i3 < length2; i3 += 1) {
      buf2[i3] = array2[i3] & 255;
    }
    return buf2;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array2, byteOffset, length2) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf2;
    if (byteOffset === void 0 && length2 === void 0) {
      buf2 = new Uint8Array(array2);
    } else if (length2 === void 0) {
      buf2 = new Uint8Array(array2, byteOffset);
    } else {
      buf2 = new Uint8Array(array2, byteOffset, length2);
    }
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf2 = createBuffer(len2);
      if (buf2.length === 0) {
        return buf2;
      }
      obj.copy(buf2, 0, 0, len2);
      return buf2;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer3(b4) {
    return b4 != null && b4._isBuffer === true && b4 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a3, b4) {
    if (isInstance(a3, Uint8Array))
      a3 = Buffer2.from(a3, a3.offset, a3.byteLength);
    if (isInstance(b4, Uint8Array))
      b4 = Buffer2.from(b4, b4.offset, b4.byteLength);
    if (!Buffer2.isBuffer(a3) || !Buffer2.isBuffer(b4)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a3 === b4)
      return 0;
    let x2 = a3.length;
    let y3 = b4.length;
    for (let i3 = 0, len2 = Math.min(x2, y3); i3 < len2; ++i3) {
      if (a3[i3] !== b4[i3]) {
        x2 = a3[i3];
        y3 = b4[i3];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i3;
    if (length2 === void 0) {
      length2 = 0;
      for (i3 = 0; i3 < list.length; ++i3) {
        length2 += list[i3].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length2);
    let pos = 0;
    for (i3 = 0; i3 < list.length; ++i3) {
      let buf2 = list[i3];
      if (isInstance(buf2, Uint8Array)) {
        if (pos + buf2.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf2))
            buf2 = Buffer2.from(buf2);
          buf2.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf2,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf2.copy(buffer2, pos);
      }
      pos += buf2.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end2) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice2(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b4, n4, m2) {
    const i3 = b4[n4];
    b4[n4] = b4[m2];
    b4[m2] = i3;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i3 = 0; i3 < len2; i3 += 2) {
      swap(this, i3, i3 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i3 = 0; i3 < len2; i3 += 4) {
      swap(this, i3, i3 + 3);
      swap(this, i3 + 1, i3 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i3 = 0; i3 < len2; i3 += 8) {
      swap(this, i3, i3 + 7);
      swap(this, i3 + 1, i3 + 6);
      swap(this, i3 + 2, i3 + 5);
      swap(this, i3 + 3, i3 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    const length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice2(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b4) {
    if (!Buffer2.isBuffer(b4))
      throw new TypeError("Argument must be a Buffer");
    if (this === b4)
      return true;
    return Buffer2.compare(this, b4) === 0;
  };
  Buffer2.prototype.inspect = function inspect5() {
    let str = "";
    const max2 = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y3 = end2 - start;
    const len2 = Math.min(x2, y3);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end2);
    for (let i3 = 0; i3 < len2; ++i3) {
      if (thisCopy[i3] !== targetCopy[i3]) {
        x2 = thisCopy[i3];
        y3 = targetCopy[i3];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr2.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr2.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf2, i4) {
      if (indexSize === 1) {
        return buf2[i4];
      } else {
        return buf2.readUInt16BE(i4 * indexSize);
      }
    }
    let i3;
    if (dir) {
      let foundIndex = -1;
      for (i3 = byteOffset; i3 < arrLength; i3++) {
        if (read2(arr2, i3) === read2(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i3;
          if (i3 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i3 -= i3 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i3 = byteOffset; i3 >= 0; i3--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read2(arr2, i3 + j2) !== read2(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i3;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf2, string2, offset, length2) {
    offset = Number(offset) || 0;
    const remaining = buf2.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i3;
    for (i3 = 0; i3 < length2; ++i3) {
      const parsed = parseInt(string2.substr(i3 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i3;
      buf2[offset + i3] = parsed;
    }
    return i3;
  }
  function utf8Write(buf2, string2, offset, length2) {
    return blitBuffer(utf8ToBytes2(string2, buf2.length - offset), buf2, offset, length2);
  }
  function asciiWrite(buf2, string2, offset, length2) {
    return blitBuffer(asciiToBytes(string2), buf2, offset, length2);
  }
  function base64Write(buf2, string2, offset, length2) {
    return blitBuffer(base64ToBytes(string2), buf2, offset, length2);
  }
  function ucs2Write(buf2, string2, offset, length2) {
    return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length2);
  }
  Buffer2.prototype.write = function write4(string2, offset, length2, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length2);
        case "base64":
          return base64Write(this, string2, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf2, start, end2) {
    if (start === 0 && end2 === buf2.length) {
      return base642.fromByteArray(buf2);
    } else {
      return base642.fromByteArray(buf2.slice(start, end2));
    }
  }
  function utf8Slice2(buf2, start, end2) {
    end2 = Math.min(buf2.length, end2);
    const res = [];
    let i3 = start;
    while (i3 < end2) {
      const firstByte = buf2[i3];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i3 + bytesPerSequence <= end2) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[i3 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[i3 + 1];
            thirdByte = buf2[i3 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[i3 + 1];
            thirdByte = buf2[i3 + 2];
            fourthByte = buf2[i3 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i3 += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  const MAX_ARGUMENTS_LENGTH2 = 4096;
  function decodeCodePointsArray2(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i3 = 0;
    while (i3 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH2)
      );
    }
    return res;
  }
  function asciiSlice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i3 = start; i3 < end2; ++i3) {
      ret += String.fromCharCode(buf2[i3] & 127);
    }
    return ret;
  }
  function latin1Slice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i3 = start; i3 < end2; ++i3) {
      ret += String.fromCharCode(buf2[i3]);
    }
    return ret;
  }
  function hexSlice(buf2, start, end2) {
    const len2 = buf2.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len2)
      end2 = len2;
    let out = "";
    for (let i3 = start; i3 < end2; ++i3) {
      out += hexSliceLookupTable[buf2[i3]];
    }
    return out;
  }
  function utf16leSlice(buf2, start, end2) {
    const bytes2 = buf2.slice(start, end2);
    let res = "";
    for (let i3 = 0; i3 < bytes2.length - 1; i3 += 2) {
      res += String.fromCharCode(bytes2[i3] + bytes2[i3 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice3(start, end2) {
    const len2 = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len2 : ~~end2;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end2 < 0) {
      end2 += len2;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len2) {
      end2 = len2;
    }
    if (end2 < start)
      end2 = start;
    const newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length2) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul5 = 1;
    let i3 = 0;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      val += this[offset + i3] * mul5;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul5 = 1;
    while (byteLength3 > 0 && (mul5 *= 256)) {
      val += this[offset + --byteLength3] * mul5;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul5 = 1;
    let i3 = 0;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      val += this[offset + i3] * mul5;
    }
    mul5 *= 128;
    if (val >= mul5)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i3 = byteLength3;
    let mul5 = 1;
    let val = this[offset + --i3];
    while (i3 > 0 && (mul5 *= 256)) {
      val += this[offset + --i3] * mul5;
    }
    mul5 *= 128;
    if (val >= mul5)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first2 << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, false, 52, 8);
  };
  function checkInt(buf2, value, offset, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul5 = 1;
    let i3 = 0;
    this[offset] = value & 255;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      this[offset + i3] = value / mul5 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i3 = byteLength3 - 1;
    let mul5 = 1;
    this[offset + i3] = value & 255;
    while (--i3 >= 0 && (mul5 *= 256)) {
      this[offset + i3] = value / mul5 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf2, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf2, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf2, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf2, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf2[offset + 7] = lo;
    lo = lo >> 8;
    buf2[offset + 6] = lo;
    lo = lo >> 8;
    buf2[offset + 5] = lo;
    lo = lo >> 8;
    buf2[offset + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i3 = 0;
    let mul5 = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i3] = (value / mul5 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i3 = byteLength3 - 1;
    let mul5 = 1;
    let sub = 0;
    this[offset + i3] = value & 255;
    while (--i3 >= 0 && (mul5 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i3] = (value / mul5 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf2, value, offset, ext, max2, min2) {
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 4);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 8);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    const len2 = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end2),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end2, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding = end2;
        end2 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    let i3;
    if (typeof val === "number") {
      for (i3 = start; i3 < end2; ++i3) {
        this[i3] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i3 = 0; i3 < end2 - start; ++i3) {
        this[i3 + start] = bytes2[i3 % len2];
      }
    }
    return this;
  };
  const errors2 = {};
  function E3(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E3(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E3(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E3(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i3 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i3 >= start + 4; i3 -= 3) {
      res = `_${val.slice(i3 - 3, i3)}${res}`;
    }
    return `${val.slice(0, i3)}${res}`;
  }
  function checkBounds(buf2, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf2[offset] === void 0 || buf2[offset + byteLength3] === void 0) {
      boundsError(offset, buf2.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf2, offset, byteLength3) {
    if (value > max2 || value < min2) {
      const n4 = typeof min2 === "bigint" ? "n" : "";
      let range2;
      if (byteLength3 > 3) {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n4} and < 2${n4} ** ${(byteLength3 + 1) * 8}${n4}`;
        } else {
          range2 = `>= -(2${n4} ** ${(byteLength3 + 1) * 8 - 1}${n4}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n4}`;
        }
      } else {
        range2 = `>= ${min2}${n4} and <= ${max2}${n4}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf2, offset, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length2, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors2.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length2 < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      type2 || "offset",
      `>= ${type2 ? 1 : 0} and <= ${length2}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i3 = 0; i3 < length2; ++i3) {
      codePoint = string2.charCodeAt(i3);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i3 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i3 = 0; i3 < str.length; ++i3) {
      byteArray.push(str.charCodeAt(i3) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo;
    const byteArray = [];
    for (let i3 = 0; i3 < str.length; ++i3) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i3);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length2) {
    let i3;
    for (i3 = 0; i3 < length2; ++i3) {
      if (i3 + offset >= dst.length || i3 >= src2.length)
        break;
      dst[i3 + offset] = src2[i3];
    }
    return i3;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table = new Array(256);
    for (let i3 = 0; i3 < 16; ++i3) {
      const i16 = i3 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet2[i3] + alphabet2[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$5);
if (typeof window !== "undefined") {
  if (!window.Buffer) {
    window.Buffer = buffer$5.Buffer;
  }
  if (!window.global) {
    window.global = window;
  }
  if (!window.process) {
    window.process = {};
  }
  if (!window.process?.env) {
    window.process = { env: {} };
  }
}
var dist$b = {};
var CoinbaseWalletSDK$2 = {};
var walletLogo$2 = {};
Object.defineProperty(walletLogo$2, "__esModule", { value: true });
var walletLogo_2 = walletLogo$2.walletLogo = void 0;
const walletLogo = (type2, width) => {
  let height;
  switch (type2) {
    case "standard":
      height = width;
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
    case "circle":
      height = width;
      return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
    case "text":
      height = (0.1 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogo":
      height = (0.25 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    case "textLight":
      height = (0.1 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogoLight":
      height = (0.25 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    default:
      height = width;
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
  }
};
walletLogo_2 = walletLogo$2.walletLogo = walletLogo;
const walletLogo$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: walletLogo$2,
  get walletLogo() {
    return walletLogo_2;
  }
}, [walletLogo$2]);
const require$$0$15 = /* @__PURE__ */ getAugmentedNamespace(walletLogo$1);
var constants$6 = {};
Object.defineProperty(constants$6, "__esModule", { value: true });
var LINK_API_URL = constants$6.LINK_API_URL = void 0;
LINK_API_URL = constants$6.LINK_API_URL = "https://www.walletlink.org";
const constants$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get LINK_API_URL() {
    return LINK_API_URL;
  },
  default: constants$6
}, [constants$6]);
const require$$1$C = /* @__PURE__ */ getAugmentedNamespace(constants$5);
var ScopedLocalStorage$2 = {};
Object.defineProperty(ScopedLocalStorage$2, "__esModule", { value: true });
var ScopedLocalStorage_2 = ScopedLocalStorage$2.ScopedLocalStorage = void 0;
class ScopedLocalStorage {
  constructor(scope) {
    this.scope = scope;
  }
  setItem(key2, value) {
    localStorage.setItem(this.scopedKey(key2), value);
  }
  getItem(key2) {
    return localStorage.getItem(this.scopedKey(key2));
  }
  removeItem(key2) {
    localStorage.removeItem(this.scopedKey(key2));
  }
  clear() {
    const prefix = this.scopedKey("");
    const keysToRemove = [];
    for (let i3 = 0; i3 < localStorage.length; i3++) {
      const key2 = localStorage.key(i3);
      if (typeof key2 === "string" && key2.startsWith(prefix)) {
        keysToRemove.push(key2);
      }
    }
    keysToRemove.forEach((key2) => localStorage.removeItem(key2));
  }
  scopedKey(key2) {
    return `${this.scope}:${key2}`;
  }
}
ScopedLocalStorage_2 = ScopedLocalStorage$2.ScopedLocalStorage = ScopedLocalStorage;
const ScopedLocalStorage$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get ScopedLocalStorage() {
    return ScopedLocalStorage_2;
  },
  default: ScopedLocalStorage$2
}, [ScopedLocalStorage$2]);
const require$$2$o = /* @__PURE__ */ getAugmentedNamespace(ScopedLocalStorage$1);
var buffer$4 = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base642 = require$$0$1b;
  const ieee7542 = require$$1$G;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr2 = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr2, proto);
      return arr2.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf2 = new Uint8Array(length2);
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    const b4 = fromObject(value);
    if (b4)
      return b4;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc3(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc3(size2, fill, encoding);
  };
  function allocUnsafe2(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length2 = byteLength2(string2, encoding) | 0;
    let buf2 = createBuffer(length2);
    const actual = buf2.write(string2, encoding);
    if (actual !== length2) {
      buf2 = buf2.slice(0, actual);
    }
    return buf2;
  }
  function fromArrayLike(array2) {
    const length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
    const buf2 = createBuffer(length2);
    for (let i3 = 0; i3 < length2; i3 += 1) {
      buf2[i3] = array2[i3] & 255;
    }
    return buf2;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array2, byteOffset, length2) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf2;
    if (byteOffset === void 0 && length2 === void 0) {
      buf2 = new Uint8Array(array2);
    } else if (length2 === void 0) {
      buf2 = new Uint8Array(array2, byteOffset);
    } else {
      buf2 = new Uint8Array(array2, byteOffset, length2);
    }
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf2 = createBuffer(len2);
      if (buf2.length === 0) {
        return buf2;
      }
      obj.copy(buf2, 0, 0, len2);
      return buf2;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer3(b4) {
    return b4 != null && b4._isBuffer === true && b4 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a3, b4) {
    if (isInstance(a3, Uint8Array))
      a3 = Buffer2.from(a3, a3.offset, a3.byteLength);
    if (isInstance(b4, Uint8Array))
      b4 = Buffer2.from(b4, b4.offset, b4.byteLength);
    if (!Buffer2.isBuffer(a3) || !Buffer2.isBuffer(b4)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a3 === b4)
      return 0;
    let x2 = a3.length;
    let y3 = b4.length;
    for (let i3 = 0, len2 = Math.min(x2, y3); i3 < len2; ++i3) {
      if (a3[i3] !== b4[i3]) {
        x2 = a3[i3];
        y3 = b4[i3];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i3;
    if (length2 === void 0) {
      length2 = 0;
      for (i3 = 0; i3 < list.length; ++i3) {
        length2 += list[i3].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length2);
    let pos = 0;
    for (i3 = 0; i3 < list.length; ++i3) {
      let buf2 = list[i3];
      if (isInstance(buf2, Uint8Array)) {
        if (pos + buf2.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf2))
            buf2 = Buffer2.from(buf2);
          buf2.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf2,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf2.copy(buffer2, pos);
      }
      pos += buf2.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end2) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice2(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b4, n4, m2) {
    const i3 = b4[n4];
    b4[n4] = b4[m2];
    b4[m2] = i3;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i3 = 0; i3 < len2; i3 += 2) {
      swap(this, i3, i3 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i3 = 0; i3 < len2; i3 += 4) {
      swap(this, i3, i3 + 3);
      swap(this, i3 + 1, i3 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i3 = 0; i3 < len2; i3 += 8) {
      swap(this, i3, i3 + 7);
      swap(this, i3 + 1, i3 + 6);
      swap(this, i3 + 2, i3 + 5);
      swap(this, i3 + 3, i3 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    const length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice2(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b4) {
    if (!Buffer2.isBuffer(b4))
      throw new TypeError("Argument must be a Buffer");
    if (this === b4)
      return true;
    return Buffer2.compare(this, b4) === 0;
  };
  Buffer2.prototype.inspect = function inspect5() {
    let str = "";
    const max2 = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y3 = end2 - start;
    const len2 = Math.min(x2, y3);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end2);
    for (let i3 = 0; i3 < len2; ++i3) {
      if (thisCopy[i3] !== targetCopy[i3]) {
        x2 = thisCopy[i3];
        y3 = targetCopy[i3];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr2.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr2.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf2, i4) {
      if (indexSize === 1) {
        return buf2[i4];
      } else {
        return buf2.readUInt16BE(i4 * indexSize);
      }
    }
    let i3;
    if (dir) {
      let foundIndex = -1;
      for (i3 = byteOffset; i3 < arrLength; i3++) {
        if (read2(arr2, i3) === read2(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i3;
          if (i3 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i3 -= i3 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i3 = byteOffset; i3 >= 0; i3--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read2(arr2, i3 + j2) !== read2(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i3;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf2, string2, offset, length2) {
    offset = Number(offset) || 0;
    const remaining = buf2.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i3;
    for (i3 = 0; i3 < length2; ++i3) {
      const parsed = parseInt(string2.substr(i3 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i3;
      buf2[offset + i3] = parsed;
    }
    return i3;
  }
  function utf8Write(buf2, string2, offset, length2) {
    return blitBuffer(utf8ToBytes2(string2, buf2.length - offset), buf2, offset, length2);
  }
  function asciiWrite(buf2, string2, offset, length2) {
    return blitBuffer(asciiToBytes(string2), buf2, offset, length2);
  }
  function base64Write(buf2, string2, offset, length2) {
    return blitBuffer(base64ToBytes(string2), buf2, offset, length2);
  }
  function ucs2Write(buf2, string2, offset, length2) {
    return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length2);
  }
  Buffer2.prototype.write = function write4(string2, offset, length2, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length2);
        case "base64":
          return base64Write(this, string2, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf2, start, end2) {
    if (start === 0 && end2 === buf2.length) {
      return base642.fromByteArray(buf2);
    } else {
      return base642.fromByteArray(buf2.slice(start, end2));
    }
  }
  function utf8Slice2(buf2, start, end2) {
    end2 = Math.min(buf2.length, end2);
    const res = [];
    let i3 = start;
    while (i3 < end2) {
      const firstByte = buf2[i3];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i3 + bytesPerSequence <= end2) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[i3 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[i3 + 1];
            thirdByte = buf2[i3 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[i3 + 1];
            thirdByte = buf2[i3 + 2];
            fourthByte = buf2[i3 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i3 += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  const MAX_ARGUMENTS_LENGTH2 = 4096;
  function decodeCodePointsArray2(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i3 = 0;
    while (i3 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH2)
      );
    }
    return res;
  }
  function asciiSlice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i3 = start; i3 < end2; ++i3) {
      ret += String.fromCharCode(buf2[i3] & 127);
    }
    return ret;
  }
  function latin1Slice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i3 = start; i3 < end2; ++i3) {
      ret += String.fromCharCode(buf2[i3]);
    }
    return ret;
  }
  function hexSlice(buf2, start, end2) {
    const len2 = buf2.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len2)
      end2 = len2;
    let out = "";
    for (let i3 = start; i3 < end2; ++i3) {
      out += hexSliceLookupTable[buf2[i3]];
    }
    return out;
  }
  function utf16leSlice(buf2, start, end2) {
    const bytes2 = buf2.slice(start, end2);
    let res = "";
    for (let i3 = 0; i3 < bytes2.length - 1; i3 += 2) {
      res += String.fromCharCode(bytes2[i3] + bytes2[i3 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice3(start, end2) {
    const len2 = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len2 : ~~end2;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end2 < 0) {
      end2 += len2;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len2) {
      end2 = len2;
    }
    if (end2 < start)
      end2 = start;
    const newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length2) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul5 = 1;
    let i3 = 0;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      val += this[offset + i3] * mul5;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul5 = 1;
    while (byteLength3 > 0 && (mul5 *= 256)) {
      val += this[offset + --byteLength3] * mul5;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul5 = 1;
    let i3 = 0;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      val += this[offset + i3] * mul5;
    }
    mul5 *= 128;
    if (val >= mul5)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i3 = byteLength3;
    let mul5 = 1;
    let val = this[offset + --i3];
    while (i3 > 0 && (mul5 *= 256)) {
      val += this[offset + --i3] * mul5;
    }
    mul5 *= 128;
    if (val >= mul5)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first2 << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, false, 52, 8);
  };
  function checkInt(buf2, value, offset, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul5 = 1;
    let i3 = 0;
    this[offset] = value & 255;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      this[offset + i3] = value / mul5 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i3 = byteLength3 - 1;
    let mul5 = 1;
    this[offset + i3] = value & 255;
    while (--i3 >= 0 && (mul5 *= 256)) {
      this[offset + i3] = value / mul5 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf2, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf2, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf2, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf2, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf2[offset + 7] = lo;
    lo = lo >> 8;
    buf2[offset + 6] = lo;
    lo = lo >> 8;
    buf2[offset + 5] = lo;
    lo = lo >> 8;
    buf2[offset + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i3 = 0;
    let mul5 = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i3] = (value / mul5 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i3 = byteLength3 - 1;
    let mul5 = 1;
    let sub = 0;
    this[offset + i3] = value & 255;
    while (--i3 >= 0 && (mul5 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i3] = (value / mul5 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf2, value, offset, ext, max2, min2) {
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 4);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 8);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    const len2 = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end2),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end2, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding = end2;
        end2 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    let i3;
    if (typeof val === "number") {
      for (i3 = start; i3 < end2; ++i3) {
        this[i3] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i3 = 0; i3 < end2 - start; ++i3) {
        this[i3 + start] = bytes2[i3 % len2];
      }
    }
    return this;
  };
  const errors2 = {};
  function E3(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E3(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E3(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E3(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i3 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i3 >= start + 4; i3 -= 3) {
      res = `_${val.slice(i3 - 3, i3)}${res}`;
    }
    return `${val.slice(0, i3)}${res}`;
  }
  function checkBounds(buf2, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf2[offset] === void 0 || buf2[offset + byteLength3] === void 0) {
      boundsError(offset, buf2.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf2, offset, byteLength3) {
    if (value > max2 || value < min2) {
      const n4 = typeof min2 === "bigint" ? "n" : "";
      let range2;
      if (byteLength3 > 3) {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n4} and < 2${n4} ** ${(byteLength3 + 1) * 8}${n4}`;
        } else {
          range2 = `>= -(2${n4} ** ${(byteLength3 + 1) * 8 - 1}${n4}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n4}`;
        }
      } else {
        range2 = `>= ${min2}${n4} and <= ${max2}${n4}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf2, offset, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length2, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors2.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length2 < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      type2 || "offset",
      `>= ${type2 ? 1 : 0} and <= ${length2}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i3 = 0; i3 < length2; ++i3) {
      codePoint = string2.charCodeAt(i3);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i3 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i3 = 0; i3 < str.length; ++i3) {
      byteArray.push(str.charCodeAt(i3) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo;
    const byteArray = [];
    for (let i3 = 0; i3 < str.length; ++i3) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i3);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length2) {
    let i3;
    for (i3 = 0; i3 < length2; ++i3) {
      if (i3 + offset >= dst.length || i3 >= src2.length)
        break;
      dst[i3 + offset] = src2[i3];
    }
    return i3;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table = new Array(256);
    for (let i3 = 0; i3 < 16; ++i3) {
      const i16 = i3 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet2[i3] + alphabet2[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$4);
var CoinbaseWalletProvider$2 = {};
var safeEventEmitter$1 = {};
Object.defineProperty(safeEventEmitter$1, "__esModule", { value: true });
const events_1 = require$$0$1a;
function safeApply(handler, context, args) {
  try {
    Reflect.apply(handler, context, args);
  } catch (err) {
    setTimeout(() => {
      throw err;
    });
  }
}
function arrayClone(arr2) {
  const n4 = arr2.length;
  const copy2 = new Array(n4);
  for (let i3 = 0; i3 < n4; i3 += 1) {
    copy2[i3] = arr2[i3];
  }
  return copy2;
}
let SafeEventEmitter$2 = class SafeEventEmitter2 extends events_1.EventEmitter {
  emit(type2, ...args) {
    let doError = type2 === "error";
    const events2 = this._events;
    if (events2 !== void 0) {
      doError = doError && events2.error === void 0;
    } else if (!doError) {
      return false;
    }
    if (doError) {
      let er2;
      if (args.length > 0) {
        [er2] = args;
      }
      if (er2 instanceof Error) {
        throw er2;
      }
      const err = new Error(`Unhandled error.${er2 ? ` (${er2.message})` : ""}`);
      err.context = er2;
      throw err;
    }
    const handler = events2[type2];
    if (handler === void 0) {
      return false;
    }
    if (typeof handler === "function") {
      safeApply(handler, this, args);
    } else {
      const len2 = handler.length;
      const listeners2 = arrayClone(handler);
      for (let i3 = 0; i3 < len2; i3 += 1) {
        safeApply(listeners2[i3], this, args);
      }
    }
    return true;
  }
};
var _default$d = safeEventEmitter$1.default = SafeEventEmitter$2;
const safeEventEmitter = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$d
}, [safeEventEmitter$1]);
const require$$0$14 = /* @__PURE__ */ getAugmentedNamespace(safeEventEmitter);
const require$$1$B = /* @__PURE__ */ getAugmentedNamespace(bn);
var DiagnosticLogger$1 = {};
Object.defineProperty(DiagnosticLogger$1, "__esModule", { value: true });
var EVENTS = DiagnosticLogger$1.EVENTS = void 0;
EVENTS = DiagnosticLogger$1.EVENTS = {
  STARTED_CONNECTING: "walletlink_sdk.started.connecting",
  CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
  DISCONNECTED: "walletlink_sdk.disconnected",
  METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
  LINKED: "walletlink_sdk.linked",
  FAILURE: "walletlink_sdk.generic_failure",
  SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
  ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
  SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
  UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
  SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
  GENERAL_ERROR: "walletlink_sdk.general_error",
  WEB3_REQUEST: "walletlink_sdk.web3.request",
  WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
  WEB3_RESPONSE: "walletlink_sdk.web3.response",
  UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
};
const DiagnosticLogger = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get EVENTS() {
    return EVENTS;
  },
  default: DiagnosticLogger$1
}, [DiagnosticLogger$1]);
const require$$3$g = /* @__PURE__ */ getAugmentedNamespace(DiagnosticLogger);
var errors$6 = {};
var dist$a = {};
var classes$3 = {};
var fastSafeStringify = stringify$5;
stringify$5.default = stringify$5;
stringify$5.stable = deterministicStringify;
stringify$5.stableStringify = deterministicStringify;
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = "[Circular]";
var arr = [];
var replacerStack = [];
function defaultOptions$3() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function stringify$5(obj, replacer, spacer, options) {
  if (typeof options === "undefined") {
    options = defaultOptions$3();
  }
  decirc(obj, "", 0, [], void 0, 0, options);
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer);
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
    }
  } catch (_3) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function setReplace(replace2, val, k3, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k3);
  if (propertyDescriptor.get !== void 0) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k3, { value: replace2 });
      arr.push([parent, k3, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k3, replace2]);
    }
  } else {
    parent[k3] = replace2;
    arr.push([parent, k3, val]);
  }
}
function decirc(val, k3, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i3;
  if (typeof val === "object" && val !== null) {
    for (i3 = 0; i3 < stack.length; i3++) {
      if (stack[i3] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k3, parent);
        return;
      }
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k3, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k3, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i3 = 0; i3 < val.length; i3++) {
        decirc(val[i3], i3, i3, stack, val, depth, options);
      }
    } else {
      var keys2 = Object.keys(val);
      for (i3 = 0; i3 < keys2.length; i3++) {
        var key2 = keys2[i3];
        decirc(val[key2], key2, i3, stack, val, depth, options);
      }
    }
    stack.pop();
  }
}
function compareFunction(a3, b4) {
  if (a3 < b4) {
    return -1;
  }
  if (a3 > b4) {
    return 1;
  }
  return 0;
}
function deterministicStringify(obj, replacer, spacer, options) {
  if (typeof options === "undefined") {
    options = defaultOptions$3();
  }
  var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer);
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
    }
  } catch (_3) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function deterministicDecirc(val, k3, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i3;
  if (typeof val === "object" && val !== null) {
    for (i3 = 0; i3 < stack.length; i3++) {
      if (stack[i3] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k3, parent);
        return;
      }
    }
    try {
      if (typeof val.toJSON === "function") {
        return;
      }
    } catch (_3) {
      return;
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k3, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k3, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i3 = 0; i3 < val.length; i3++) {
        deterministicDecirc(val[i3], i3, i3, stack, val, depth, options);
      }
    } else {
      var tmp = {};
      var keys2 = Object.keys(val).sort(compareFunction);
      for (i3 = 0; i3 < keys2.length; i3++) {
        var key2 = keys2[i3];
        deterministicDecirc(val[key2], key2, i3, stack, val, depth, options);
        tmp[key2] = val[key2];
      }
      if (typeof parent !== "undefined") {
        arr.push([parent, k3, val]);
        parent[k3] = tmp;
      } else {
        return tmp;
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k3, v4) {
    return v4;
  };
  return function(key2, val) {
    if (replacerStack.length > 0) {
      for (var i3 = 0; i3 < replacerStack.length; i3++) {
        var part = replacerStack[i3];
        if (part[1] === key2 && part[0] === val) {
          val = part[2];
          replacerStack.splice(i3, 1);
          break;
        }
      }
    }
    return replacer.call(this, key2, val);
  };
}
const index$D = /* @__PURE__ */ getDefaultExportFromCjs(fastSafeStringify);
const fastSafeStringify$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$D
}, [fastSafeStringify]);
const require$$0$13 = /* @__PURE__ */ getAugmentedNamespace(fastSafeStringify$1);
Object.defineProperty(classes$3, "__esModule", { value: true });
var EthereumProviderError_1$1 = classes$3.EthereumProviderError = EthereumRpcError_1$1 = classes$3.EthereumRpcError = void 0;
const fast_safe_stringify_1$1 = require$$0$13;
let EthereumRpcError$1 = class EthereumRpcError2 extends Error {
  constructor(code2, message, data2) {
    if (!Number.isInteger(code2)) {
      throw new Error('"code" must be an integer.');
    }
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a nonempty string.');
    }
    super(message);
    this.code = code2;
    if (data2 !== void 0) {
      this.data = data2;
    }
  }
  /**
   * Returns a plain object with all public class properties.
   */
  serialize() {
    const serialized = {
      code: this.code,
      message: this.message
    };
    if (this.data !== void 0) {
      serialized.data = this.data;
    }
    if (this.stack) {
      serialized.stack = this.stack;
    }
    return serialized;
  }
  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   */
  toString() {
    return fast_safe_stringify_1$1.default(this.serialize(), stringifyReplacer$2, 2);
  }
};
var EthereumRpcError_1$1 = classes$3.EthereumRpcError = EthereumRpcError$1;
let EthereumProviderError$1 = class EthereumProviderError2 extends EthereumRpcError$1 {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(code2, message, data2) {
    if (!isValidEthProviderCode$1(code2)) {
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    }
    super(code2, message, data2);
  }
};
EthereumProviderError_1$1 = classes$3.EthereumProviderError = EthereumProviderError$1;
function isValidEthProviderCode$1(code2) {
  return Number.isInteger(code2) && code2 >= 1e3 && code2 <= 4999;
}
function stringifyReplacer$2(_3, value) {
  if (value === "[Circular]") {
    return void 0;
  }
  return value;
}
const classes$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get EthereumProviderError() {
    return EthereumProviderError_1$1;
  },
  get EthereumRpcError() {
    return EthereumRpcError_1$1;
  },
  default: classes$3
}, [classes$3]);
const require$$0$12 = /* @__PURE__ */ getAugmentedNamespace(classes$2);
var utils$a = {};
var errorConstants$3 = {};
Object.defineProperty(errorConstants$3, "__esModule", { value: true });
var errorValues$1 = errorConstants$3.errorValues = errorCodes$1 = errorConstants$3.errorCodes = void 0;
var errorCodes$1 = errorConstants$3.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
errorValues$1 = errorConstants$3.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  "4001": {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  "4100": {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  "4200": {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  "4900": {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  "4901": {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
const errorConstants$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: errorConstants$3,
  get errorCodes() {
    return errorCodes$1;
  },
  get errorValues() {
    return errorValues$1;
  }
}, [errorConstants$3]);
const require$$3$f = /* @__PURE__ */ getAugmentedNamespace(errorConstants$2);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.serializeError = exports2.isValidCode = exports2.getMessageFromCode = exports2.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const error_constants_12 = require$$3$f;
  const classes_12 = require$$0$12;
  const FALLBACK_ERROR_CODE = error_constants_12.errorCodes.rpc.internal;
  const FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
  const FALLBACK_ERROR = {
    code: FALLBACK_ERROR_CODE,
    message: getMessageFromCode(FALLBACK_ERROR_CODE)
  };
  exports2.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function getMessageFromCode(code2, fallbackMessage = FALLBACK_MESSAGE) {
    if (Number.isInteger(code2)) {
      const codeString = code2.toString();
      if (hasKey(error_constants_12.errorValues, codeString)) {
        return error_constants_12.errorValues[codeString].message;
      }
      if (isJsonRpcServerError(code2)) {
        return exports2.JSON_RPC_SERVER_ERROR_MESSAGE;
      }
    }
    return fallbackMessage;
  }
  exports2.getMessageFromCode = getMessageFromCode;
  function isValidCode(code2) {
    if (!Number.isInteger(code2)) {
      return false;
    }
    const codeString = code2.toString();
    if (error_constants_12.errorValues[codeString]) {
      return true;
    }
    if (isJsonRpcServerError(code2)) {
      return true;
    }
    return false;
  }
  exports2.isValidCode = isValidCode;
  function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
    var _a2, _b;
    if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
      throw new Error("Must provide fallback error with integer number code and string message.");
    }
    if (error instanceof classes_12.EthereumRpcError) {
      return error.serialize();
    }
    const serialized = {};
    if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
      const _error = error;
      serialized.code = _error.code;
      if (_error.message && typeof _error.message === "string") {
        serialized.message = _error.message;
        if (hasKey(_error, "data")) {
          serialized.data = _error.data;
        }
      } else {
        serialized.message = getMessageFromCode(serialized.code);
        serialized.data = { originalError: assignOriginalError(error) };
      }
    } else {
      serialized.code = fallbackError.code;
      const message = (_a2 = error) === null || _a2 === void 0 ? void 0 : _a2.message;
      serialized.message = message && typeof message === "string" ? message : fallbackError.message;
      serialized.data = { originalError: assignOriginalError(error) };
    }
    const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
    if (shouldIncludeStack && error && stack && typeof stack === "string") {
      serialized.stack = stack;
    }
    return serialized;
  }
  exports2.serializeError = serializeError;
  function isJsonRpcServerError(code2) {
    return code2 >= -32099 && code2 <= -32e3;
  }
  function assignOriginalError(error) {
    if (error && typeof error === "object" && !Array.isArray(error)) {
      return Object.assign({}, error);
    }
    return error;
  }
  function hasKey(obj, key2) {
    return Object.prototype.hasOwnProperty.call(obj, key2);
  }
})(utils$a);
const utils$8 = /* @__PURE__ */ getDefaultExportFromCjs(utils$a);
const utils$9 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$8
}, [utils$a]);
const require$$1$A = /* @__PURE__ */ getAugmentedNamespace(utils$9);
var errors$5 = {};
Object.defineProperty(errors$5, "__esModule", { value: true });
var ethErrors$1 = errors$5.ethErrors = void 0;
const classes_1$1 = require$$0$12;
const utils_1$1 = require$$1$A;
const error_constants_1$1 = require$$3$f;
ethErrors$1 = errors$5.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: (arg) => getEthJsonRpcError$1(error_constants_1$1.errorCodes.rpc.parse, arg),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: (arg) => getEthJsonRpcError$1(error_constants_1$1.errorCodes.rpc.invalidRequest, arg),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: (arg) => getEthJsonRpcError$1(error_constants_1$1.errorCodes.rpc.invalidParams, arg),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: (arg) => getEthJsonRpcError$1(error_constants_1$1.errorCodes.rpc.methodNotFound, arg),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: (arg) => getEthJsonRpcError$1(error_constants_1$1.errorCodes.rpc.internal, arg),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      }
      const { code: code2 } = opts;
      if (!Number.isInteger(code2) || code2 > -32005 || code2 < -32099) {
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      }
      return getEthJsonRpcError$1(code2, opts);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: (arg) => getEthJsonRpcError$1(error_constants_1$1.errorCodes.rpc.invalidInput, arg),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: (arg) => getEthJsonRpcError$1(error_constants_1$1.errorCodes.rpc.resourceNotFound, arg),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: (arg) => getEthJsonRpcError$1(error_constants_1$1.errorCodes.rpc.resourceUnavailable, arg),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: (arg) => getEthJsonRpcError$1(error_constants_1$1.errorCodes.rpc.transactionRejected, arg),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: (arg) => getEthJsonRpcError$1(error_constants_1$1.errorCodes.rpc.methodNotSupported, arg),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: (arg) => getEthJsonRpcError$1(error_constants_1$1.errorCodes.rpc.limitExceeded, arg)
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: (arg) => {
      return getEthProviderError$1(error_constants_1$1.errorCodes.provider.userRejectedRequest, arg);
    },
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: (arg) => {
      return getEthProviderError$1(error_constants_1$1.errorCodes.provider.unauthorized, arg);
    },
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: (arg) => {
      return getEthProviderError$1(error_constants_1$1.errorCodes.provider.unsupportedMethod, arg);
    },
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: (arg) => {
      return getEthProviderError$1(error_constants_1$1.errorCodes.provider.disconnected, arg);
    },
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: (arg) => {
      return getEthProviderError$1(error_constants_1$1.errorCodes.provider.chainDisconnected, arg);
    },
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      }
      const { code: code2, message, data: data2 } = opts;
      if (!message || typeof message !== "string") {
        throw new Error('"message" must be a nonempty string');
      }
      return new classes_1$1.EthereumProviderError(code2, message, data2);
    }
  }
};
function getEthJsonRpcError$1(code2, arg) {
  const [message, data2] = parseOpts$1(arg);
  return new classes_1$1.EthereumRpcError(code2, message || utils_1$1.getMessageFromCode(code2), data2);
}
function getEthProviderError$1(code2, arg) {
  const [message, data2] = parseOpts$1(arg);
  return new classes_1$1.EthereumProviderError(code2, message || utils_1$1.getMessageFromCode(code2), data2);
}
function parseOpts$1(arg) {
  if (arg) {
    if (typeof arg === "string") {
      return [arg];
    } else if (typeof arg === "object" && !Array.isArray(arg)) {
      const { message, data: data2 } = arg;
      if (message && typeof message !== "string") {
        throw new Error("Must specify string message.");
      }
      return [message || void 0, data2];
    }
  }
  return [];
}
const errors$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: errors$5,
  get ethErrors() {
    return ethErrors$1;
  }
}, [errors$5]);
const require$$2$n = /* @__PURE__ */ getAugmentedNamespace(errors$4);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getMessageFromCode = exports2.serializeError = exports2.EthereumProviderError = exports2.EthereumRpcError = exports2.ethErrors = exports2.errorCodes = void 0;
  const classes_12 = require$$0$12;
  Object.defineProperty(exports2, "EthereumRpcError", { enumerable: true, get: function() {
    return classes_12.EthereumRpcError;
  } });
  Object.defineProperty(exports2, "EthereumProviderError", { enumerable: true, get: function() {
    return classes_12.EthereumProviderError;
  } });
  const utils_12 = require$$1$A;
  Object.defineProperty(exports2, "serializeError", { enumerable: true, get: function() {
    return utils_12.serializeError;
  } });
  Object.defineProperty(exports2, "getMessageFromCode", { enumerable: true, get: function() {
    return utils_12.getMessageFromCode;
  } });
  const errors_12 = require$$2$n;
  Object.defineProperty(exports2, "ethErrors", { enumerable: true, get: function() {
    return errors_12.ethErrors;
  } });
  const error_constants_12 = require$$3$f;
  Object.defineProperty(exports2, "errorCodes", { enumerable: true, get: function() {
    return error_constants_12.errorCodes;
  } });
})(dist$a);
const index$C = /* @__PURE__ */ getDefaultExportFromCjs(dist$a);
const dist$9 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$C
}, [dist$a]);
const require$$0$11 = /* @__PURE__ */ getAugmentedNamespace(dist$9);
var Web3Response$1 = {};
var Web3Method$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Web3Method = void 0;
  (function(Web3Method2) {
    Web3Method2["requestEthereumAccounts"] = "requestEthereumAccounts";
    Web3Method2["signEthereumMessage"] = "signEthereumMessage";
    Web3Method2["signEthereumTransaction"] = "signEthereumTransaction";
    Web3Method2["submitEthereumTransaction"] = "submitEthereumTransaction";
    Web3Method2["ethereumAddressFromSignedMessage"] = "ethereumAddressFromSignedMessage";
    Web3Method2["scanQRCode"] = "scanQRCode";
    Web3Method2["generic"] = "generic";
    Web3Method2["childRequestEthereumAccounts"] = "childRequestEthereumAccounts";
    Web3Method2["addEthereumChain"] = "addEthereumChain";
    Web3Method2["switchEthereumChain"] = "switchEthereumChain";
    Web3Method2["makeEthereumJSONRPCRequest"] = "makeEthereumJSONRPCRequest";
    Web3Method2["watchAsset"] = "watchAsset";
    Web3Method2["selectProvider"] = "selectProvider";
  })(exports2.Web3Method || (exports2.Web3Method = {}));
})(Web3Method$2);
const Web3Method = /* @__PURE__ */ getDefaultExportFromCjs(Web3Method$2);
const Web3Method$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: Web3Method
}, [Web3Method$2]);
const require$$11$4 = /* @__PURE__ */ getAugmentedNamespace(Web3Method$1);
Object.defineProperty(Web3Response$1, "__esModule", { value: true });
var EthereumAddressFromSignedMessageResponse_1 = Web3Response$1.EthereumAddressFromSignedMessageResponse = SubmitEthereumTransactionResponse_1 = Web3Response$1.SubmitEthereumTransactionResponse = SignEthereumTransactionResponse_1 = Web3Response$1.SignEthereumTransactionResponse = SignEthereumMessageResponse_1 = Web3Response$1.SignEthereumMessageResponse = isRequestEthereumAccountsResponse_1 = Web3Response$1.isRequestEthereumAccountsResponse = SelectProviderResponse_1 = Web3Response$1.SelectProviderResponse = WatchAssetReponse_1 = Web3Response$1.WatchAssetReponse = RequestEthereumAccountsResponse_1 = Web3Response$1.RequestEthereumAccountsResponse = SwitchEthereumChainResponse_1 = Web3Response$1.SwitchEthereumChainResponse = AddEthereumChainResponse_1 = Web3Response$1.AddEthereumChainResponse = isErrorResponse_1 = Web3Response$1.isErrorResponse = void 0;
const Web3Method_1$2 = require$$11$4;
function isErrorResponse(response) {
  var _a2, _b;
  return ((_a2 = response) === null || _a2 === void 0 ? void 0 : _a2.method) !== void 0 && ((_b = response) === null || _b === void 0 ? void 0 : _b.errorMessage) !== void 0;
}
var isErrorResponse_1 = Web3Response$1.isErrorResponse = isErrorResponse;
function AddEthereumChainResponse(addResponse) {
  return {
    method: Web3Method_1$2.Web3Method.addEthereumChain,
    result: addResponse
  };
}
var AddEthereumChainResponse_1 = Web3Response$1.AddEthereumChainResponse = AddEthereumChainResponse;
function SwitchEthereumChainResponse(switchResponse) {
  return {
    method: Web3Method_1$2.Web3Method.switchEthereumChain,
    result: switchResponse
  };
}
var SwitchEthereumChainResponse_1 = Web3Response$1.SwitchEthereumChainResponse = SwitchEthereumChainResponse;
function RequestEthereumAccountsResponse(addresses) {
  return { method: Web3Method_1$2.Web3Method.requestEthereumAccounts, result: addresses };
}
var RequestEthereumAccountsResponse_1 = Web3Response$1.RequestEthereumAccountsResponse = RequestEthereumAccountsResponse;
function WatchAssetReponse(success) {
  return { method: Web3Method_1$2.Web3Method.watchAsset, result: success };
}
var WatchAssetReponse_1 = Web3Response$1.WatchAssetReponse = WatchAssetReponse;
function SelectProviderResponse(selectedProviderKey) {
  return { method: Web3Method_1$2.Web3Method.selectProvider, result: selectedProviderKey };
}
var SelectProviderResponse_1 = Web3Response$1.SelectProviderResponse = SelectProviderResponse;
function isRequestEthereumAccountsResponse(res) {
  return res && res.method === Web3Method_1$2.Web3Method.requestEthereumAccounts;
}
var isRequestEthereumAccountsResponse_1 = Web3Response$1.isRequestEthereumAccountsResponse = isRequestEthereumAccountsResponse;
function SignEthereumMessageResponse(signature2) {
  return { method: Web3Method_1$2.Web3Method.signEthereumMessage, result: signature2 };
}
var SignEthereumMessageResponse_1 = Web3Response$1.SignEthereumMessageResponse = SignEthereumMessageResponse;
function SignEthereumTransactionResponse(signedData) {
  return { method: Web3Method_1$2.Web3Method.signEthereumTransaction, result: signedData };
}
var SignEthereumTransactionResponse_1 = Web3Response$1.SignEthereumTransactionResponse = SignEthereumTransactionResponse;
function SubmitEthereumTransactionResponse(txHash) {
  return { method: Web3Method_1$2.Web3Method.submitEthereumTransaction, result: txHash };
}
var SubmitEthereumTransactionResponse_1 = Web3Response$1.SubmitEthereumTransactionResponse = SubmitEthereumTransactionResponse;
function EthereumAddressFromSignedMessageResponse(address) {
  return {
    method: Web3Method_1$2.Web3Method.ethereumAddressFromSignedMessage,
    result: address
  };
}
EthereumAddressFromSignedMessageResponse_1 = Web3Response$1.EthereumAddressFromSignedMessageResponse = EthereumAddressFromSignedMessageResponse;
const Web3Response = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get AddEthereumChainResponse() {
    return AddEthereumChainResponse_1;
  },
  get EthereumAddressFromSignedMessageResponse() {
    return EthereumAddressFromSignedMessageResponse_1;
  },
  get RequestEthereumAccountsResponse() {
    return RequestEthereumAccountsResponse_1;
  },
  get SelectProviderResponse() {
    return SelectProviderResponse_1;
  },
  get SignEthereumMessageResponse() {
    return SignEthereumMessageResponse_1;
  },
  get SignEthereumTransactionResponse() {
    return SignEthereumTransactionResponse_1;
  },
  get SubmitEthereumTransactionResponse() {
    return SubmitEthereumTransactionResponse_1;
  },
  get SwitchEthereumChainResponse() {
    return SwitchEthereumChainResponse_1;
  },
  get WatchAssetReponse() {
    return WatchAssetReponse_1;
  },
  default: Web3Response$1,
  get isErrorResponse() {
    return isErrorResponse_1;
  },
  get isRequestEthereumAccountsResponse() {
    return isRequestEthereumAccountsResponse_1;
  }
}, [Web3Response$1]);
const require$$14$2 = /* @__PURE__ */ getAugmentedNamespace(Web3Response);
var version$3 = {};
Object.defineProperty(version$3, "__esModule", { value: true });
var LIB_VERSION = version$3.LIB_VERSION = void 0;
LIB_VERSION = version$3.LIB_VERSION = "3.7.2";
const version$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get LIB_VERSION() {
    return LIB_VERSION;
  },
  default: version$3
}, [version$3]);
const require$$8$4 = /* @__PURE__ */ getAugmentedNamespace(version$2);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getErrorCode = exports2.serializeError = exports2.standardErrors = exports2.standardErrorMessage = exports2.standardErrorCodes = void 0;
  const eth_rpc_errors_12 = require$$0$11;
  const Web3Response_12 = require$$14$2;
  const version_12 = require$$8$4;
  exports2.standardErrorCodes = Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_12.errorCodes), { provider: Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_12.errorCodes.provider), { unsupportedChain: 4902 })) }));
  function standardErrorMessage(code2) {
    return code2 !== void 0 ? (0, eth_rpc_errors_12.getMessageFromCode)(code2) : "Unknown error";
  }
  exports2.standardErrorMessage = standardErrorMessage;
  exports2.standardErrors = Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_12.ethErrors), { provider: Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_12.ethErrors.provider), { unsupportedChain: (chainId = "") => eth_rpc_errors_12.ethErrors.provider.custom({
    code: exports2.standardErrorCodes.provider.unsupportedChain,
    message: `Unrecognized chain ID ${chainId}. Try adding the chain using wallet_addEthereumChain first.`
  }) })) }));
  function serializeError(error, requestOrMethod) {
    const serialized = (0, eth_rpc_errors_12.serializeError)(getErrorObject(error), {
      shouldIncludeStack: true
    });
    const docUrl = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
    docUrl.searchParams.set("version", version_12.LIB_VERSION);
    docUrl.searchParams.set("code", serialized.code.toString());
    const method = getMethod2(serialized.data, requestOrMethod);
    if (method) {
      docUrl.searchParams.set("method", method);
    }
    docUrl.searchParams.set("message", serialized.message);
    return Object.assign(Object.assign({}, serialized), { docUrl: docUrl.href });
  }
  exports2.serializeError = serializeError;
  function getErrorObject(error) {
    if (typeof error === "string") {
      return {
        message: error,
        code: exports2.standardErrorCodes.rpc.internal
      };
    } else if ((0, Web3Response_12.isErrorResponse)(error)) {
      return Object.assign(Object.assign({}, error), { message: error.errorMessage, code: error.errorCode, data: { method: error.method, result: error.result } });
    } else {
      return error;
    }
  }
  function getMethod2(serializedData, request) {
    var _a2;
    const methodInData = (_a2 = serializedData) === null || _a2 === void 0 ? void 0 : _a2.method;
    if (methodInData) {
      return methodInData;
    }
    if (request === void 0) {
      return void 0;
    } else if (typeof request === "string") {
      return request;
    } else if (!Array.isArray(request)) {
      return request.method;
    } else if (request.length > 0) {
      return request[0].method;
    } else {
      return void 0;
    }
  }
  function getErrorCode(error) {
    var _a2;
    if (typeof error === "number") {
      return error;
    } else if (isErrorWithCode(error)) {
      return (_a2 = error.code) !== null && _a2 !== void 0 ? _a2 : error.errorCode;
    }
    return void 0;
  }
  exports2.getErrorCode = getErrorCode;
  function isErrorWithCode(error) {
    return typeof error === "object" && error !== null && (typeof error.code === "number" || typeof error.errorCode === "number");
  }
})(errors$6);
const errors$2 = /* @__PURE__ */ getDefaultExportFromCjs(errors$6);
const errors$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: errors$2
}, [errors$6]);
const require$$5$c = /* @__PURE__ */ getAugmentedNamespace(errors$3);
var Session$2 = {};
var sha_js$1 = { exports: {} };
var safeBuffer$1 = { exports: {} };
const require$$2$m = /* @__PURE__ */ getAugmentedNamespace(buffer$6);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module2, exports2) {
  var buffer2 = require$$2$m;
  var Buffer2 = buffer2.Buffer;
  function copyProps(src2, dst) {
    for (var key2 in src2) {
      dst[key2] = src2[key2];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer2;
  } else {
    copyProps(buffer2, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length2) {
    return Buffer2(arg, encodingOrOffset, length2);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length2);
  };
  SafeBuffer.alloc = function(size2, fill, encoding) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf2 = Buffer2(size2);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf2.fill(fill, encoding);
      } else {
        buf2.fill(fill);
      }
    } else {
      buf2.fill(0);
    }
    return buf2;
  };
  SafeBuffer.allocUnsafe = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size2);
  };
  SafeBuffer.allocUnsafeSlow = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size2);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports;
const index$B = /* @__PURE__ */ getDefaultExportFromCjs(safeBufferExports);
const safeBuffer = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$B
}, [safeBufferExports]);
const require$$0$10 = /* @__PURE__ */ getAugmentedNamespace(safeBuffer);
var Buffer$7 = require$$0$10.Buffer;
function Hash$6(blockSize, finalSize) {
  this._block = Buffer$7.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}
Hash$6.prototype.update = function(data2, enc) {
  if (typeof data2 === "string") {
    enc = enc || "utf8";
    data2 = Buffer$7.from(data2, enc);
  }
  var block2 = this._block;
  var blockSize = this._blockSize;
  var length2 = data2.length;
  var accum = this._len;
  for (var offset = 0; offset < length2; ) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length2 - offset, blockSize - assigned);
    for (var i3 = 0; i3 < remainder; i3++) {
      block2[assigned + i3] = data2[offset + i3];
    }
    accum += remainder;
    offset += remainder;
    if (accum % blockSize === 0) {
      this._update(block2);
    }
  }
  this._len += length2;
  return this;
};
Hash$6.prototype.digest = function(enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 128;
  this._block.fill(0, rem + 1);
  if (rem >= this._finalSize) {
    this._update(this._block);
    this._block.fill(0);
  }
  var bits = this._len * 8;
  if (bits <= 4294967295) {
    this._block.writeUInt32BE(bits, this._blockSize - 4);
  } else {
    var lowBits = (bits & 4294967295) >>> 0;
    var highBits = (bits - lowBits) / 4294967296;
    this._block.writeUInt32BE(highBits, this._blockSize - 8);
    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }
  this._update(this._block);
  var hash2 = this._hash();
  return enc ? hash2.toString(enc) : hash2;
};
Hash$6.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash = Hash$6;
const hash$1 = /* @__PURE__ */ getDefaultExportFromCjs(hash);
const hash$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: hash$1
}, [hash]);
const require$$2$l = /* @__PURE__ */ getAugmentedNamespace(hash$2);
var inherits$5 = require$$1$Q;
var Hash$5 = require$$2$l;
var Buffer$6 = require$$0$10.Buffer;
var K$4 = [
  1518500249,
  1859775393,
  2400959708 | 0,
  3395469782 | 0
];
var W$6 = new Array(80);
function Sha() {
  this.init();
  this._w = W$6;
  Hash$5.call(this, 64, 56);
}
inherits$5(Sha, Hash$5);
Sha.prototype.init = function() {
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
  return this;
};
function rotl5$1(num) {
  return num << 5 | num >>> 27;
}
function rotl30$1(num) {
  return num << 30 | num >>> 2;
}
function ft$1(s3, b4, c2, d3) {
  if (s3 === 0)
    return b4 & c2 | ~b4 & d3;
  if (s3 === 2)
    return b4 & c2 | b4 & d3 | c2 & d3;
  return b4 ^ c2 ^ d3;
}
Sha.prototype._update = function(M3) {
  var W2 = this._w;
  var a3 = this._a | 0;
  var b4 = this._b | 0;
  var c2 = this._c | 0;
  var d3 = this._d | 0;
  var e2 = this._e | 0;
  for (var i3 = 0; i3 < 16; ++i3)
    W2[i3] = M3.readInt32BE(i3 * 4);
  for (; i3 < 80; ++i3)
    W2[i3] = W2[i3 - 3] ^ W2[i3 - 8] ^ W2[i3 - 14] ^ W2[i3 - 16];
  for (var j2 = 0; j2 < 80; ++j2) {
    var s3 = ~~(j2 / 20);
    var t2 = rotl5$1(a3) + ft$1(s3, b4, c2, d3) + e2 + W2[j2] + K$4[s3] | 0;
    e2 = d3;
    d3 = c2;
    c2 = rotl30$1(b4);
    b4 = a3;
    a3 = t2;
  }
  this._a = a3 + this._a | 0;
  this._b = b4 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d3 + this._d | 0;
  this._e = e2 + this._e | 0;
};
Sha.prototype._hash = function() {
  var H3 = Buffer$6.allocUnsafe(20);
  H3.writeInt32BE(this._a | 0, 0);
  H3.writeInt32BE(this._b | 0, 4);
  H3.writeInt32BE(this._c | 0, 8);
  H3.writeInt32BE(this._d | 0, 12);
  H3.writeInt32BE(this._e | 0, 16);
  return H3;
};
var sha = Sha;
const sha$1 = /* @__PURE__ */ getDefaultExportFromCjs(sha);
const sha$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sha$1
}, [sha]);
const require$$0$$ = /* @__PURE__ */ getAugmentedNamespace(sha$2);
var inherits$4 = require$$1$Q;
var Hash$4 = require$$2$l;
var Buffer$5 = require$$0$10.Buffer;
var K$3 = [
  1518500249,
  1859775393,
  2400959708 | 0,
  3395469782 | 0
];
var W$5 = new Array(80);
function Sha1() {
  this.init();
  this._w = W$5;
  Hash$4.call(this, 64, 56);
}
inherits$4(Sha1, Hash$4);
Sha1.prototype.init = function() {
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
  return this;
};
function rotl1(num) {
  return num << 1 | num >>> 31;
}
function rotl5(num) {
  return num << 5 | num >>> 27;
}
function rotl30(num) {
  return num << 30 | num >>> 2;
}
function ft(s3, b4, c2, d3) {
  if (s3 === 0)
    return b4 & c2 | ~b4 & d3;
  if (s3 === 2)
    return b4 & c2 | b4 & d3 | c2 & d3;
  return b4 ^ c2 ^ d3;
}
Sha1.prototype._update = function(M3) {
  var W2 = this._w;
  var a3 = this._a | 0;
  var b4 = this._b | 0;
  var c2 = this._c | 0;
  var d3 = this._d | 0;
  var e2 = this._e | 0;
  for (var i3 = 0; i3 < 16; ++i3)
    W2[i3] = M3.readInt32BE(i3 * 4);
  for (; i3 < 80; ++i3)
    W2[i3] = rotl1(W2[i3 - 3] ^ W2[i3 - 8] ^ W2[i3 - 14] ^ W2[i3 - 16]);
  for (var j2 = 0; j2 < 80; ++j2) {
    var s3 = ~~(j2 / 20);
    var t2 = rotl5(a3) + ft(s3, b4, c2, d3) + e2 + W2[j2] + K$3[s3] | 0;
    e2 = d3;
    d3 = c2;
    c2 = rotl30(b4);
    b4 = a3;
    a3 = t2;
  }
  this._a = a3 + this._a | 0;
  this._b = b4 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d3 + this._d | 0;
  this._e = e2 + this._e | 0;
};
Sha1.prototype._hash = function() {
  var H3 = Buffer$5.allocUnsafe(20);
  H3.writeInt32BE(this._a | 0, 0);
  H3.writeInt32BE(this._b | 0, 4);
  H3.writeInt32BE(this._c | 0, 8);
  H3.writeInt32BE(this._d | 0, 12);
  H3.writeInt32BE(this._e | 0, 16);
  return H3;
};
var sha1 = Sha1;
const sha1$1 = /* @__PURE__ */ getDefaultExportFromCjs(sha1);
const sha1$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sha1$1
}, [sha1]);
const require$$1$z = /* @__PURE__ */ getAugmentedNamespace(sha1$2);
var inherits$3 = require$$1$Q;
var Hash$3 = require$$2$l;
var Buffer$4 = require$$0$10.Buffer;
var K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
var W$4 = new Array(64);
function Sha256$1() {
  this.init();
  this._w = W$4;
  Hash$3.call(this, 64, 56);
}
inherits$3(Sha256$1, Hash$3);
Sha256$1.prototype.init = function() {
  this._a = 1779033703;
  this._b = 3144134277;
  this._c = 1013904242;
  this._d = 2773480762;
  this._e = 1359893119;
  this._f = 2600822924;
  this._g = 528734635;
  this._h = 1541459225;
  return this;
};
function ch$1(x2, y3, z2) {
  return z2 ^ x2 & (y3 ^ z2);
}
function maj$1(x2, y3, z2) {
  return x2 & y3 | z2 & (x2 | y3);
}
function sigma0$1(x2) {
  return (x2 >>> 2 | x2 << 30) ^ (x2 >>> 13 | x2 << 19) ^ (x2 >>> 22 | x2 << 10);
}
function sigma1$1(x2) {
  return (x2 >>> 6 | x2 << 26) ^ (x2 >>> 11 | x2 << 21) ^ (x2 >>> 25 | x2 << 7);
}
function gamma0(x2) {
  return (x2 >>> 7 | x2 << 25) ^ (x2 >>> 18 | x2 << 14) ^ x2 >>> 3;
}
function gamma1(x2) {
  return (x2 >>> 17 | x2 << 15) ^ (x2 >>> 19 | x2 << 13) ^ x2 >>> 10;
}
Sha256$1.prototype._update = function(M3) {
  var W2 = this._w;
  var a3 = this._a | 0;
  var b4 = this._b | 0;
  var c2 = this._c | 0;
  var d3 = this._d | 0;
  var e2 = this._e | 0;
  var f4 = this._f | 0;
  var g3 = this._g | 0;
  var h5 = this._h | 0;
  for (var i3 = 0; i3 < 16; ++i3)
    W2[i3] = M3.readInt32BE(i3 * 4);
  for (; i3 < 64; ++i3)
    W2[i3] = gamma1(W2[i3 - 2]) + W2[i3 - 7] + gamma0(W2[i3 - 15]) + W2[i3 - 16] | 0;
  for (var j2 = 0; j2 < 64; ++j2) {
    var T1 = h5 + sigma1$1(e2) + ch$1(e2, f4, g3) + K$2[j2] + W2[j2] | 0;
    var T2 = sigma0$1(a3) + maj$1(a3, b4, c2) | 0;
    h5 = g3;
    g3 = f4;
    f4 = e2;
    e2 = d3 + T1 | 0;
    d3 = c2;
    c2 = b4;
    b4 = a3;
    a3 = T1 + T2 | 0;
  }
  this._a = a3 + this._a | 0;
  this._b = b4 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d3 + this._d | 0;
  this._e = e2 + this._e | 0;
  this._f = f4 + this._f | 0;
  this._g = g3 + this._g | 0;
  this._h = h5 + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var H3 = Buffer$4.allocUnsafe(32);
  H3.writeInt32BE(this._a, 0);
  H3.writeInt32BE(this._b, 4);
  H3.writeInt32BE(this._c, 8);
  H3.writeInt32BE(this._d, 12);
  H3.writeInt32BE(this._e, 16);
  H3.writeInt32BE(this._f, 20);
  H3.writeInt32BE(this._g, 24);
  H3.writeInt32BE(this._h, 28);
  return H3;
};
var sha256 = Sha256$1;
const sha256$1 = /* @__PURE__ */ getDefaultExportFromCjs(sha256);
const sha256$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sha256$1
}, [sha256]);
const require$$3$e = /* @__PURE__ */ getAugmentedNamespace(sha256$2);
var inherits$2 = require$$1$Q;
var Sha256 = require$$3$e;
var Hash$2 = require$$2$l;
var Buffer$3 = require$$0$10.Buffer;
var W$3 = new Array(64);
function Sha224() {
  this.init();
  this._w = W$3;
  Hash$2.call(this, 64, 56);
}
inherits$2(Sha224, Sha256);
Sha224.prototype.init = function() {
  this._a = 3238371032;
  this._b = 914150663;
  this._c = 812702999;
  this._d = 4144912697;
  this._e = 4290775857;
  this._f = 1750603025;
  this._g = 1694076839;
  this._h = 3204075428;
  return this;
};
Sha224.prototype._hash = function() {
  var H3 = Buffer$3.allocUnsafe(28);
  H3.writeInt32BE(this._a, 0);
  H3.writeInt32BE(this._b, 4);
  H3.writeInt32BE(this._c, 8);
  H3.writeInt32BE(this._d, 12);
  H3.writeInt32BE(this._e, 16);
  H3.writeInt32BE(this._f, 20);
  H3.writeInt32BE(this._g, 24);
  return H3;
};
var sha224 = Sha224;
const sha224$1 = /* @__PURE__ */ getDefaultExportFromCjs(sha224);
const sha224$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sha224$1
}, [sha224]);
const require$$2$k = /* @__PURE__ */ getAugmentedNamespace(sha224$2);
var inherits$1 = require$$1$Q;
var Hash$1 = require$$2$l;
var Buffer$2 = require$$0$10.Buffer;
var K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
var W$2 = new Array(160);
function Sha512() {
  this.init();
  this._w = W$2;
  Hash$1.call(this, 128, 112);
}
inherits$1(Sha512, Hash$1);
Sha512.prototype.init = function() {
  this._ah = 1779033703;
  this._bh = 3144134277;
  this._ch = 1013904242;
  this._dh = 2773480762;
  this._eh = 1359893119;
  this._fh = 2600822924;
  this._gh = 528734635;
  this._hh = 1541459225;
  this._al = 4089235720;
  this._bl = 2227873595;
  this._cl = 4271175723;
  this._dl = 1595750129;
  this._el = 2917565137;
  this._fl = 725511199;
  this._gl = 4215389547;
  this._hl = 327033209;
  return this;
};
function Ch$1(x2, y3, z2) {
  return z2 ^ x2 & (y3 ^ z2);
}
function maj(x2, y3, z2) {
  return x2 & y3 | z2 & (x2 | y3);
}
function sigma0(x2, xl) {
  return (x2 >>> 28 | xl << 4) ^ (xl >>> 2 | x2 << 30) ^ (xl >>> 7 | x2 << 25);
}
function sigma1(x2, xl) {
  return (x2 >>> 14 | xl << 18) ^ (x2 >>> 18 | xl << 14) ^ (xl >>> 9 | x2 << 23);
}
function Gamma0(x2, xl) {
  return (x2 >>> 1 | xl << 31) ^ (x2 >>> 8 | xl << 24) ^ x2 >>> 7;
}
function Gamma0l(x2, xl) {
  return (x2 >>> 1 | xl << 31) ^ (x2 >>> 8 | xl << 24) ^ (x2 >>> 7 | xl << 25);
}
function Gamma1(x2, xl) {
  return (x2 >>> 19 | xl << 13) ^ (xl >>> 29 | x2 << 3) ^ x2 >>> 6;
}
function Gamma1l(x2, xl) {
  return (x2 >>> 19 | xl << 13) ^ (xl >>> 29 | x2 << 3) ^ (x2 >>> 6 | xl << 26);
}
function getCarry(a3, b4) {
  return a3 >>> 0 < b4 >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(M3) {
  var W2 = this._w;
  var ah2 = this._ah | 0;
  var bh2 = this._bh | 0;
  var ch2 = this._ch | 0;
  var dh2 = this._dh | 0;
  var eh2 = this._eh | 0;
  var fh2 = this._fh | 0;
  var gh2 = this._gh | 0;
  var hh2 = this._hh | 0;
  var al2 = this._al | 0;
  var bl2 = this._bl | 0;
  var cl2 = this._cl | 0;
  var dl2 = this._dl | 0;
  var el2 = this._el | 0;
  var fl2 = this._fl | 0;
  var gl2 = this._gl | 0;
  var hl2 = this._hl | 0;
  for (var i3 = 0; i3 < 32; i3 += 2) {
    W2[i3] = M3.readInt32BE(i3 * 4);
    W2[i3 + 1] = M3.readInt32BE(i3 * 4 + 4);
  }
  for (; i3 < 160; i3 += 2) {
    var xh2 = W2[i3 - 15 * 2];
    var xl = W2[i3 - 15 * 2 + 1];
    var gamma02 = Gamma0(xh2, xl);
    var gamma0l = Gamma0l(xl, xh2);
    xh2 = W2[i3 - 2 * 2];
    xl = W2[i3 - 2 * 2 + 1];
    var gamma12 = Gamma1(xh2, xl);
    var gamma1l = Gamma1l(xl, xh2);
    var Wi7h = W2[i3 - 7 * 2];
    var Wi7l = W2[i3 - 7 * 2 + 1];
    var Wi16h = W2[i3 - 16 * 2];
    var Wi16l = W2[i3 - 16 * 2 + 1];
    var Wil = gamma0l + Wi7l | 0;
    var Wih = gamma02 + Wi7h + getCarry(Wil, gamma0l) | 0;
    Wil = Wil + gamma1l | 0;
    Wih = Wih + gamma12 + getCarry(Wil, gamma1l) | 0;
    Wil = Wil + Wi16l | 0;
    Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
    W2[i3] = Wih;
    W2[i3 + 1] = Wil;
  }
  for (var j2 = 0; j2 < 160; j2 += 2) {
    Wih = W2[j2];
    Wil = W2[j2 + 1];
    var majh = maj(ah2, bh2, ch2);
    var majl = maj(al2, bl2, cl2);
    var sigma0h = sigma0(ah2, al2);
    var sigma0l = sigma0(al2, ah2);
    var sigma1h = sigma1(eh2, el2);
    var sigma1l = sigma1(el2, eh2);
    var Kih = K$1[j2];
    var Kil = K$1[j2 + 1];
    var chh = Ch$1(eh2, fh2, gh2);
    var chl = Ch$1(el2, fl2, gl2);
    var t1l = hl2 + sigma1l | 0;
    var t1h = hh2 + sigma1h + getCarry(t1l, hl2) | 0;
    t1l = t1l + chl | 0;
    t1h = t1h + chh + getCarry(t1l, chl) | 0;
    t1l = t1l + Kil | 0;
    t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
    t1l = t1l + Wil | 0;
    t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
    var t2l = sigma0l + majl | 0;
    var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
    hh2 = gh2;
    hl2 = gl2;
    gh2 = fh2;
    gl2 = fl2;
    fh2 = eh2;
    fl2 = el2;
    el2 = dl2 + t1l | 0;
    eh2 = dh2 + t1h + getCarry(el2, dl2) | 0;
    dh2 = ch2;
    dl2 = cl2;
    ch2 = bh2;
    cl2 = bl2;
    bh2 = ah2;
    bl2 = al2;
    al2 = t1l + t2l | 0;
    ah2 = t1h + t2h + getCarry(al2, t1l) | 0;
  }
  this._al = this._al + al2 | 0;
  this._bl = this._bl + bl2 | 0;
  this._cl = this._cl + cl2 | 0;
  this._dl = this._dl + dl2 | 0;
  this._el = this._el + el2 | 0;
  this._fl = this._fl + fl2 | 0;
  this._gl = this._gl + gl2 | 0;
  this._hl = this._hl + hl2 | 0;
  this._ah = this._ah + ah2 + getCarry(this._al, al2) | 0;
  this._bh = this._bh + bh2 + getCarry(this._bl, bl2) | 0;
  this._ch = this._ch + ch2 + getCarry(this._cl, cl2) | 0;
  this._dh = this._dh + dh2 + getCarry(this._dl, dl2) | 0;
  this._eh = this._eh + eh2 + getCarry(this._el, el2) | 0;
  this._fh = this._fh + fh2 + getCarry(this._fl, fl2) | 0;
  this._gh = this._gh + gh2 + getCarry(this._gl, gl2) | 0;
  this._hh = this._hh + hh2 + getCarry(this._hl, hl2) | 0;
};
Sha512.prototype._hash = function() {
  var H3 = Buffer$2.allocUnsafe(64);
  function writeInt64BE2(h5, l2, offset) {
    H3.writeInt32BE(h5, offset);
    H3.writeInt32BE(l2, offset + 4);
  }
  writeInt64BE2(this._ah, this._al, 0);
  writeInt64BE2(this._bh, this._bl, 8);
  writeInt64BE2(this._ch, this._cl, 16);
  writeInt64BE2(this._dh, this._dl, 24);
  writeInt64BE2(this._eh, this._el, 32);
  writeInt64BE2(this._fh, this._fl, 40);
  writeInt64BE2(this._gh, this._gl, 48);
  writeInt64BE2(this._hh, this._hl, 56);
  return H3;
};
var sha512 = Sha512;
const sha512$1 = /* @__PURE__ */ getDefaultExportFromCjs(sha512);
const sha512$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sha512$1
}, [sha512]);
const require$$5$b = /* @__PURE__ */ getAugmentedNamespace(sha512$2);
var inherits = require$$1$Q;
var SHA512 = require$$5$b;
var Hash = require$$2$l;
var Buffer$1 = require$$0$10.Buffer;
var W$1 = new Array(160);
function Sha384() {
  this.init();
  this._w = W$1;
  Hash.call(this, 128, 112);
}
inherits(Sha384, SHA512);
Sha384.prototype.init = function() {
  this._ah = 3418070365;
  this._bh = 1654270250;
  this._ch = 2438529370;
  this._dh = 355462360;
  this._eh = 1731405415;
  this._fh = 2394180231;
  this._gh = 3675008525;
  this._hh = 1203062813;
  this._al = 3238371032;
  this._bl = 914150663;
  this._cl = 812702999;
  this._dl = 4144912697;
  this._el = 4290775857;
  this._fl = 1750603025;
  this._gl = 1694076839;
  this._hl = 3204075428;
  return this;
};
Sha384.prototype._hash = function() {
  var H3 = Buffer$1.allocUnsafe(48);
  function writeInt64BE2(h5, l2, offset) {
    H3.writeInt32BE(h5, offset);
    H3.writeInt32BE(l2, offset + 4);
  }
  writeInt64BE2(this._ah, this._al, 0);
  writeInt64BE2(this._bh, this._bl, 8);
  writeInt64BE2(this._ch, this._cl, 16);
  writeInt64BE2(this._dh, this._dl, 24);
  writeInt64BE2(this._eh, this._el, 32);
  writeInt64BE2(this._fh, this._fl, 40);
  return H3;
};
var sha384 = Sha384;
const sha384$1 = /* @__PURE__ */ getDefaultExportFromCjs(sha384);
const sha384$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sha384$1
}, [sha384]);
const require$$4$c = /* @__PURE__ */ getAugmentedNamespace(sha384$2);
var exports = sha_js$1.exports = function SHA(algorithm) {
  algorithm = algorithm.toLowerCase();
  var Algorithm = exports[algorithm];
  if (!Algorithm)
    throw new Error(algorithm + " is not supported (we accept pull requests)");
  return new Algorithm();
};
exports.sha = require$$0$$;
exports.sha1 = require$$1$z;
exports.sha224 = require$$2$k;
exports.sha256 = require$$3$e;
exports.sha384 = require$$4$c;
exports.sha512 = require$$5$b;
var sha_jsExports = sha_js$1.exports;
const index$A = /* @__PURE__ */ getDefaultExportFromCjs(sha_jsExports);
const sha_js = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$A
}, [sha_jsExports]);
const require$$0$_ = /* @__PURE__ */ getAugmentedNamespace(sha_js);
var util$b = {};
var shams = function hasSymbols2() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
const shams$1 = /* @__PURE__ */ getDefaultExportFromCjs(shams);
const shams$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: shams$1
}, [shams]);
const require$$0$Z = /* @__PURE__ */ getAugmentedNamespace(shams$2);
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = require$$0$Z;
var hasSymbols$2 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
const index$z = /* @__PURE__ */ getDefaultExportFromCjs(hasSymbols$2);
const hasSymbols$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$z
}, [hasSymbols$2]);
const require$$0$Y = /* @__PURE__ */ getAugmentedNamespace(hasSymbols$3);
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice$2 = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind2(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice$2.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        args.concat(slice$2.call(arguments))
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(
        that,
        args.concat(slice$2.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i3 = 0; i3 < boundLength; i3++) {
    boundArgs.push("$" + i3);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
const implementation$2 = /* @__PURE__ */ getDefaultExportFromCjs(implementation$1);
const implementation$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: implementation$2
}, [implementation$1]);
const require$$0$X = /* @__PURE__ */ getAugmentedNamespace(implementation$3);
var implementation = require$$0$X;
var functionBind = Function.prototype.bind || implementation;
const index$y = /* @__PURE__ */ getDefaultExportFromCjs(functionBind);
const functionBind$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$y
}, [functionBind]);
const require$$0$W = /* @__PURE__ */ getAugmentedNamespace(functionBind$1);
var bind$2 = require$$0$W;
var src$2 = bind$2.call(Function.call, Object.prototype.hasOwnProperty);
const index$x = /* @__PURE__ */ getDefaultExportFromCjs(src$2);
const src$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$x
}, [src$2]);
const require$$2$j = /* @__PURE__ */ getAugmentedNamespace(src$3);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError$1 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e2) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$1 = require$$0$Y();
var getProto = Object.getPrototypeOf || function(x2) {
  return x2.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$1 ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn2 = doEval2("%AsyncGeneratorFunction%");
    if (fn2) {
      value = fn2.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind$1 = require$$0$W;
var hasOwn$2 = require$$2$j;
var $concat$1 = bind$1.call(Function.call, Array.prototype.concat);
var $spliceApply = bind$1.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind$1.call(Function.call, String.prototype.replace);
var $strSlice = bind$1.call(Function.call, String.prototype.slice);
var $exec = bind$1.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string2) {
  var first2 = $strSlice(string2, 0, 1);
  var last2 = $strSlice(string2, -1);
  if (first2 === "%" && last2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last2 === "%" && first2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$1(string2, rePropName, function(match, number2, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number2 || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$2(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$2(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic2(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/g, name2) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i3 = 1, isOwn = true; i3 < parts.length; i3 += 1) {
    var part = parts[i3];
    var first2 = $strSlice(part, 0, 1);
    var last2 = $strSlice(part, -1);
    if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$2(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i3 + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$2(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
const index$w = /* @__PURE__ */ getDefaultExportFromCjs(getIntrinsic);
const getIntrinsic$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$w
}, [getIntrinsic]);
const require$$0$V = /* @__PURE__ */ getAugmentedNamespace(getIntrinsic$1);
var callBind$2 = { exports: {} };
(function(module2) {
  var bind3 = require$$0$W;
  var GetIntrinsic3 = require$$0$V;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty = null;
    }
  }
  module2.exports = function callBind2(originalFunction) {
    var func2 = $reflectApply(bind3, $call, arguments);
    if ($gOPD2 && $defineProperty) {
      var desc = $gOPD2(func2, "length");
      if (desc.configurable) {
        $defineProperty(
          func2,
          "length",
          { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
        );
      }
    }
    return func2;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$2);
var callBindExports = callBind$2.exports;
const index$v = /* @__PURE__ */ getDefaultExportFromCjs(callBindExports);
const callBind$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$v
}, [callBindExports]);
const require$$1$y = /* @__PURE__ */ getAugmentedNamespace(callBind$1);
var GetIntrinsic$1 = require$$0$V;
var callBind = require$$1$y;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic$1(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
const callBound$2 = /* @__PURE__ */ getDefaultExportFromCjs(callBound$1);
const callBound$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: callBound$2
}, [callBound$1]);
const require$$1$x = /* @__PURE__ */ getAugmentedNamespace(callBound$3);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
  return O2.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int2 = num < 0 ? -$floor(-num) : $floor(num);
    if (int2 !== num) {
      var intStr = String(int2);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var utilInspect = require$$0$1v;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen2) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$6(obj) ? "[Array]" : "[Object]";
  }
  var indent2 = getIndent(opts, depth);
  if (typeof seen2 === "undefined") {
    seen2 = [];
  } else if (indexOf(seen2, obj) >= 0) {
    return "[Circular]";
  }
  function inspect5(value, from2, noIndent) {
    if (from2) {
      seen2 = $arrSlice.call(seen2);
      seen2.push(from2);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen2);
    }
    return inspect_(value, opts, depth + 1, seen2);
  }
  if (typeof obj === "function" && !isRegExp$1(obj)) {
    var name2 = nameOf(obj);
    var keys2 = arrObjKeys(obj, inspect5);
    return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s3 = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i3 = 0; i3 < attrs.length; i3++) {
      s3 += " " + attrs[i3].name + "=" + wrapQuotes(quote(attrs[i3].value), "double", opts);
    }
    s3 += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s3 += "...";
    }
    s3 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s3;
  }
  if (isArray$6(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs2 = arrObjKeys(obj, inspect5);
    if (indent2 && !singleLineValues(xs2)) {
      return "[" + indentedJoin(xs2, indent2) + "]";
    }
    return "[ " + $join.call(xs2, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect5);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect5(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    mapForEach.call(obj, function(value, key2) {
      mapParts.push(inspect5(key2, obj, true) + " => " + inspect5(value, obj));
    });
    return collectionOf("Map", mapSize.call(obj), mapParts, indent2);
  }
  if (isSet(obj)) {
    var setParts = [];
    setForEach.call(obj, function(value) {
      setParts.push(inspect5(value, obj));
    });
    return collectionOf("Set", setSize.call(obj), setParts, indent2);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect5(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect5(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString(obj)) {
    return markBoxed(inspect5(String(obj)));
  }
  if (!isDate$1(obj) && !isRegExp$1(obj)) {
    var ys2 = arrObjKeys(obj, inspect5);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys2.length === 0) {
      return tag + "{}";
    }
    if (indent2) {
      return tag + "{" + indentedJoin(ys2, indent2) + "}";
    }
    return tag + "{ " + $join.call(ys2, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s3, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s3 + quoteChar;
}
function quote(s3) {
  return $replace.call(String(s3), /"/g, "&quot;");
}
function isArray$6(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate$1(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
var hasOwn$1 = Object.prototype.hasOwnProperty || function(key2) {
  return key2 in this;
};
function has$3(obj, key2) {
  return hasOwn$1.call(obj, key2);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f4) {
  if (f4.name) {
    return f4.name;
  }
  var m2 = $match.call(functionToString.call(f4), /^function\s*([\w$]+)/);
  if (m2) {
    return m2[1];
  }
  return null;
}
function indexOf(xs2, x2) {
  if (xs2.indexOf) {
    return xs2.indexOf(x2);
  }
  for (var i3 = 0, l2 = xs2.length; i3 < l2; i3++) {
    if (xs2[i3] === x2) {
      return i3;
    }
  }
  return -1;
}
function isMap(x2) {
  if (!mapSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    mapSize.call(x2);
    try {
      setSize.call(x2);
    } catch (s3) {
      return true;
    }
    return x2 instanceof Map;
  } catch (e2) {
  }
  return false;
}
function isWeakMap(x2) {
  if (!weakMapHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x2, weakMapHas);
    try {
      weakSetHas.call(x2, weakSetHas);
    } catch (s3) {
      return true;
    }
    return x2 instanceof WeakMap;
  } catch (e2) {
  }
  return false;
}
function isWeakRef(x2) {
  if (!weakRefDeref || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x2);
    return true;
  } catch (e2) {
  }
  return false;
}
function isSet(x2) {
  if (!setSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    setSize.call(x2);
    try {
      mapSize.call(x2);
    } catch (m2) {
      return true;
    }
    return x2 instanceof Set;
  } catch (e2) {
  }
  return false;
}
function isWeakSet(x2) {
  if (!weakSetHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x2, weakSetHas);
    try {
      weakMapHas.call(x2, weakMapHas);
    } catch (s3) {
      return true;
    }
    return x2 instanceof WeakSet;
  } catch (e2) {
  }
  return false;
}
function isElement(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
    return true;
  }
  return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s3 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s3, "single", opts);
}
function lowbyte(c2) {
  var n4 = c2.charCodeAt(0);
  var x2 = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n4];
  if (x2) {
    return "\\" + x2;
  }
  return "\\x" + (n4 < 16 ? "0" : "") + $toUpperCase.call(n4.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type2) {
  return type2 + " { ? }";
}
function collectionOf(type2, size2, entries2, indent2) {
  var joinedEntries = indent2 ? indentedJoin(entries2, indent2) : $join.call(entries2, ", ");
  return type2 + " (" + size2 + ") {" + joinedEntries + "}";
}
function singleLineValues(xs2) {
  for (var i3 = 0; i3 < xs2.length; i3++) {
    if (indexOf(xs2[i3], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs2, indent2) {
  if (xs2.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent2.prev + indent2.base;
  return lineJoiner + $join.call(xs2, "," + lineJoiner) + "\n" + indent2.prev;
}
function arrObjKeys(obj, inspect5) {
  var isArr = isArray$6(obj);
  var xs2 = [];
  if (isArr) {
    xs2.length = obj.length;
    for (var i3 = 0; i3 < obj.length; i3++) {
      xs2[i3] = has$3(obj, i3) ? inspect5(obj[i3], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k3 = 0; k3 < syms.length; k3++) {
      symMap["$" + syms[k3]] = syms[k3];
    }
  }
  for (var key2 in obj) {
    if (!has$3(obj, key2)) {
      continue;
    }
    if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key2)) {
      xs2.push(inspect5(key2, obj) + ": " + inspect5(obj[key2], obj));
    } else {
      xs2.push(key2 + ": " + inspect5(obj[key2], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j2 = 0; j2 < syms.length; j2++) {
      if (isEnumerable.call(obj, syms[j2])) {
        xs2.push("[" + inspect5(syms[j2]) + "]: " + inspect5(obj[syms[j2]], obj));
      }
    }
  }
  return xs2;
}
const index$u = /* @__PURE__ */ getDefaultExportFromCjs(objectInspect);
const objectInspect$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$u
}, [objectInspect]);
const require$$2$i = /* @__PURE__ */ getAugmentedNamespace(objectInspect$1);
var GetIntrinsic = require$$0$V;
var callBound = require$$1$x;
var inspect$1 = require$$2$i;
var $TypeError = GetIntrinsic("%TypeError%");
var $WeakMap = GetIntrinsic("%WeakMap%", true);
var $Map = GetIntrinsic("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key2) {
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key2) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key2) {
  var node2 = listGetNode(objects, key2);
  return node2 && node2.value;
};
var listSet = function(objects, key2, value) {
  var node2 = listGetNode(objects, key2);
  if (node2) {
    node2.value = value;
  } else {
    objects.next = {
      // eslint-disable-line no-param-reassign
      key: key2,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key2) {
  return !!listGetNode(objects, key2);
};
var sideChannel = function getSideChannel2() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key2) {
      if (!channel.has(key2)) {
        throw new $TypeError("Side channel does not contain " + inspect$1(key2));
      }
    },
    get: function(key2) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key2);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key2);
        }
      } else {
        if ($o) {
          return listGet($o, key2);
        }
      }
    },
    has: function(key2) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key2);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key2);
        }
      } else {
        if ($o) {
          return listHas($o, key2);
        }
      }
      return false;
    },
    set: function(key2, value) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key2, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key2, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key2, value);
      }
    }
  };
  return channel;
};
const index$t = /* @__PURE__ */ getDefaultExportFromCjs(sideChannel);
const sideChannel$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$t
}, [sideChannel]);
const require$$0$U = /* @__PURE__ */ getAugmentedNamespace(sideChannel$1);
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
const formats$4 = /* @__PURE__ */ getDefaultExportFromCjs(formats$3);
const formats$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formats$4
}, [formats$3]);
const require$$2$h = /* @__PURE__ */ getAugmentedNamespace(formats$5);
var formats$2 = require$$2$h;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$5 = Array.isArray;
var hexTable = function() {
  var array2 = [];
  for (var i3 = 0; i3 < 256; ++i3) {
    array2.push("%" + ((i3 < 16 ? "0" : "") + i3.toString(16)).toUpperCase());
  }
  return array2;
}();
var compactQueue = function compactQueue2(queue2) {
  while (queue2.length > 1) {
    var item = queue2.pop();
    var obj = item.obj[item.prop];
    if (isArray$5(obj)) {
      var compacted = [];
      for (var j2 = 0; j2 < obj.length; ++j2) {
        if (typeof obj[j2] !== "undefined") {
          compacted.push(obj[j2]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i3 = 0; i3 < source.length; ++i3) {
    if (typeof source[i3] !== "undefined") {
      obj[i3] = source[i3];
    }
  }
  return obj;
};
var merge$3 = function merge2(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$5(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$5(target) && !isArray$5(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$5(target) && isArray$5(source)) {
    source.forEach(function(item, i3) {
      if (has$2.call(target, i3)) {
        var targetItem = target[i3];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i3] = merge2(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i3] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key2) {
    var value = source[key2];
    if (has$2.call(acc, key2)) {
      acc[key2] = merge2(acc[key2], value, options);
    } else {
      acc[key2] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign$3 = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key2) {
    acc[key2] = source[key2];
    return acc;
  }, target);
};
var decode$9 = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e2) {
    return strWithoutPlus;
  }
};
var encode$a = function encode4(str, defaultEncoder, charset, kind, format) {
  if (str.length === 0) {
    return str;
  }
  var string2 = str;
  if (typeof str === "symbol") {
    string2 = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string2 = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i3 = 0; i3 < string2.length; ++i3) {
    var c2 = string2.charCodeAt(i3);
    if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format === formats$2.RFC1738 && (c2 === 40 || c2 === 41)) {
      out += string2.charAt(i3);
      continue;
    }
    if (c2 < 128) {
      out = out + hexTable[c2];
      continue;
    }
    if (c2 < 2048) {
      out = out + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
      continue;
    }
    if (c2 < 55296 || c2 >= 57344) {
      out = out + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
      continue;
    }
    i3 += 1;
    c2 = 65536 + ((c2 & 1023) << 10 | string2.charCodeAt(i3) & 1023);
    out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
  }
  return out;
};
var compact$1 = function compact2(value) {
  var queue2 = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i3 = 0; i3 < queue2.length; ++i3) {
    var item = queue2[i3];
    var obj = item.obj[item.prop];
    var keys2 = Object.keys(obj);
    for (var j2 = 0; j2 < keys2.length; ++j2) {
      var key2 = keys2[j2];
      var val = obj[key2];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue2.push({ obj, prop: key2 });
        refs.push(val);
      }
    }
  }
  compactQueue(queue2);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer$2 = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a3, b4) {
  return [].concat(a3, b4);
};
var maybeMap = function maybeMap2(val, fn2) {
  if (isArray$5(val)) {
    var mapped = [];
    for (var i3 = 0; i3 < val.length; i3 += 1) {
      mapped.push(fn2(val[i3]));
    }
    return mapped;
  }
  return fn2(val);
};
var utils$5 = {
  arrayToObject,
  assign: assign$3,
  combine,
  compact: compact$1,
  decode: decode$9,
  encode: encode$a,
  isBuffer: isBuffer$2,
  isRegExp,
  maybeMap,
  merge: merge$3
};
const utils$6 = /* @__PURE__ */ getDefaultExportFromCjs(utils$5);
const utils$7 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$6
}, [utils$5]);
const require$$0$T = /* @__PURE__ */ getAugmentedNamespace(utils$7);
var getSideChannel = require$$0$U;
var utils$4 = require$$0$T;
var formats$1 = require$$2$h;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key2) {
    return prefix + "[" + key2 + "]";
  },
  repeat: function repeat2(prefix) {
    return prefix;
  }
};
var isArray$4 = Array.isArray;
var push$1 = Array.prototype.push;
var pushToArray = function(arr2, valueOrArray) {
  push$1.apply(arr2, isArray$4(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$2 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$4.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date2) {
    return toISO.call(date2);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v4) {
  return typeof v4 === "string" || typeof v4 === "number" || typeof v4 === "boolean" || typeof v4 === "symbol" || typeof v4 === "bigint";
};
var sentinel = {};
var stringify$2 = function stringify2(object2, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter2, sort2, allowDots, serializeDate2, format, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object2;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object2);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter2 === "function") {
    obj = filter2(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$4(obj)) {
    obj = utils$4.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$2.encoder, charset, "key", format) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$4.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$2.encoder, charset, "key", format);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$2.encoder, charset, "value", format))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$4(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = utils$4.maybeMap(obj, encoder);
    }
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$4(filter2)) {
    objKeys = filter2;
  } else {
    var keys2 = Object.keys(obj);
    objKeys = sort2 ? keys2.sort(sort2) : keys2;
  }
  var adjustedPrefix = commaRoundTrip && isArray$4(obj) && obj.length === 1 ? prefix + "[]" : prefix;
  for (var j2 = 0; j2 < objKeys.length; ++j2) {
    var key2 = objKeys[j2];
    var value = typeof key2 === "object" && typeof key2.value !== "undefined" ? key2.value : obj[key2];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$4(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key2) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key2 : "[" + key2 + "]");
    sideChannel2.set(object2, step);
    var valueSideChannel = getSideChannel();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify2(
      value,
      keyPrefix,
      generateArrayPrefix,
      commaRoundTrip,
      strictNullHandling,
      skipNulls,
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray$4(obj) ? null : encoder,
      filter2,
      sort2,
      allowDots,
      serializeDate2,
      format,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$2;
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$2.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  var formatter = formats$1.formatters[format];
  var filter2 = defaults$2.filter;
  if (typeof opts.filter === "function" || isArray$4(opts.filter)) {
    filter2 = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$2.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$2.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$2.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$2.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$2.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$2.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$2.encodeValuesOnly,
    filter: filter2,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$2.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$2.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$2.strictNullHandling
  };
};
var stringify_1 = function(object2, opts) {
  var obj = object2;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter2;
  if (typeof options.filter === "function") {
    filter2 = options.filter;
    obj = filter2("", obj);
  } else if (isArray$4(options.filter)) {
    filter2 = options.filter;
    objKeys = filter2;
  }
  var keys2 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel();
  for (var i3 = 0; i3 < objKeys.length; ++i3) {
    var key2 = objKeys[i3];
    if (options.skipNulls && obj[key2] === null) {
      continue;
    }
    pushToArray(keys2, stringify$2(
      obj[key2],
      key2,
      generateArrayPrefix,
      commaRoundTrip,
      options.strictNullHandling,
      options.skipNulls,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel2
    ));
  }
  var joined = keys2.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
const stringify$3 = /* @__PURE__ */ getDefaultExportFromCjs(stringify_1);
const stringify$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: stringify$3
}, [stringify_1]);
const require$$0$S = /* @__PURE__ */ getAugmentedNamespace(stringify$4);
var utils$3 = require$$0$T;
var has = Object.prototype.hasOwnProperty;
var isArray$3 = Array.isArray;
var defaults$1 = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils$3.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = { __proto__: null };
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i3;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i3 = 0; i3 < parts.length; ++i3) {
      if (parts[i3].indexOf("utf8=") === 0) {
        if (parts[i3] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i3] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i3;
        i3 = parts.length;
      }
    }
  }
  for (i3 = 0; i3 < parts.length; ++i3) {
    if (i3 === skipIndex) {
      continue;
    }
    var part = parts[i3];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key2, val;
    if (pos === -1) {
      key2 = options.decoder(part, defaults$1.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key2 = options.decoder(part.slice(0, pos), defaults$1.decoder, charset, "key");
      val = utils$3.maybeMap(
        parseArrayValue(part.slice(pos + 1), options),
        function(encodedVal) {
          return options.decoder(encodedVal, defaults$1.decoder, charset, "value");
        }
      );
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray$3(val) ? [val] : val;
    }
    if (has.call(obj, key2)) {
      obj[key2] = utils$3.combine(obj[key2], val);
    } else {
      obj[key2] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i3 = chain.length - 1; i3 >= 0; --i3) {
    var obj;
    var root2 = chain[i3];
    if (root2 === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var index2 = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
        obj = [];
        obj[index2] = leaf;
      } else if (cleanRoot !== "__proto__") {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key2 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key2);
  var parent = segment ? key2.slice(0, segment.index) : key2;
  var keys2 = [];
  if (parent) {
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(parent);
  }
  var i3 = 0;
  while (options.depth > 0 && (segment = child.exec(key2)) !== null && i3 < options.depth) {
    i3 += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(segment[1]);
  }
  if (segment) {
    keys2.push("[" + key2.slice(segment.index) + "]");
  }
  return parseObject(keys2, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults$1.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults$1.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults$1.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults$1.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults$1.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults$1.decoder,
    delimiter: typeof opts.delimiter === "string" || utils$3.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults$1.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults$1.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults$1.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var parse$a = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys2 = Object.keys(tempObj);
  for (var i3 = 0; i3 < keys2.length; ++i3) {
    var key2 = keys2[i3];
    var newObj = parseKeys(key2, tempObj[key2], options, typeof str === "string");
    obj = utils$3.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils$3.compact(obj);
};
const parse$b = /* @__PURE__ */ getDefaultExportFromCjs(parse$a);
const parse$c = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: parse$b
}, [parse$a]);
const require$$1$w = /* @__PURE__ */ getAugmentedNamespace(parse$c);
var stringify$1 = require$$0$S;
var parse$9 = require$$1$w;
var formats = require$$2$h;
var lib$2 = {
  formats,
  parse: parse$9,
  stringify: stringify$1
};
const index$s = /* @__PURE__ */ getDefaultExportFromCjs(lib$2);
const lib$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$s
}, [lib$2]);
const require$$1$v = /* @__PURE__ */ getAugmentedNamespace(lib$3);
var types$5 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ProviderType = exports2.RegExpString = exports2.IntNumber = exports2.BigIntString = exports2.AddressString = exports2.HexString = exports2.OpaqueType = void 0;
  function OpaqueType() {
    return (value) => value;
  }
  exports2.OpaqueType = OpaqueType;
  exports2.HexString = OpaqueType();
  exports2.AddressString = OpaqueType();
  exports2.BigIntString = OpaqueType();
  function IntNumber(num) {
    return Math.floor(num);
  }
  exports2.IntNumber = IntNumber;
  exports2.RegExpString = OpaqueType();
  (function(ProviderType) {
    ProviderType["CoinbaseWallet"] = "CoinbaseWallet";
    ProviderType["MetaMask"] = "MetaMask";
    ProviderType["Unselected"] = "";
  })(exports2.ProviderType || (exports2.ProviderType = {}));
})(types$5);
const types$3 = /* @__PURE__ */ getDefaultExportFromCjs(types$5);
const types$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: types$3
}, [types$5]);
const require$$6$a = /* @__PURE__ */ getAugmentedNamespace(types$4);
var __importDefault$d = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(util$b, "__esModule", { value: true });
var isInIFrame_1 = util$b.isInIFrame = createQrUrl_1 = util$b.createQrUrl = getFavicon_1 = util$b.getFavicon = range_1 = util$b.range = isBigNumber_1 = util$b.isBigNumber = ensureParsedJSONObject_1 = util$b.ensureParsedJSONObject = ensureBN_1 = util$b.ensureBN = ensureRegExpString_1 = util$b.ensureRegExpString = ensureIntNumber_1 = util$b.ensureIntNumber = ensureBuffer_1 = util$b.ensureBuffer = ensureAddressString_1 = util$b.ensureAddressString = ensureEvenLengthHexString_1 = util$b.ensureEvenLengthHexString = ensureHexString_1 = util$b.ensureHexString = isHexString_1 = util$b.isHexString = prepend0x_1 = util$b.prepend0x = strip0x_1 = util$b.strip0x = has0xPrefix_1 = util$b.has0xPrefix = hexStringFromIntNumber_1 = util$b.hexStringFromIntNumber = intNumberFromHexString_1 = util$b.intNumberFromHexString = bigIntStringFromBN_1 = util$b.bigIntStringFromBN = hexStringFromBuffer_1 = util$b.hexStringFromBuffer = hexStringToUint8Array_1 = util$b.hexStringToUint8Array = uint8ArrayToHex_1 = util$b.uint8ArrayToHex = randomBytesHex_1 = util$b.randomBytesHex = void 0;
const bn_js_1$1 = __importDefault$d(require$$1$B);
const qs_1 = require$$1$v;
const errors_1$3 = require$$5$c;
const types_1$3 = require$$6$a;
const INT_STRING_REGEX = /^[0-9]*$/;
const HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
function randomBytesHex(length2) {
  return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length2)));
}
var randomBytesHex_1 = util$b.randomBytesHex = randomBytesHex;
function uint8ArrayToHex(value) {
  return [...value].map((b4) => b4.toString(16).padStart(2, "0")).join("");
}
var uint8ArrayToHex_1 = util$b.uint8ArrayToHex = uint8ArrayToHex;
function hexStringToUint8Array(hexString) {
  return new Uint8Array(hexString.match(/.{1,2}/g).map((byte2) => parseInt(byte2, 16)));
}
var hexStringToUint8Array_1 = util$b.hexStringToUint8Array = hexStringToUint8Array;
function hexStringFromBuffer(buf2, includePrefix = false) {
  const hex2 = buf2.toString("hex");
  return (0, types_1$3.HexString)(includePrefix ? "0x" + hex2 : hex2);
}
var hexStringFromBuffer_1 = util$b.hexStringFromBuffer = hexStringFromBuffer;
function bigIntStringFromBN(bn2) {
  return (0, types_1$3.BigIntString)(bn2.toString(10));
}
var bigIntStringFromBN_1 = util$b.bigIntStringFromBN = bigIntStringFromBN;
function intNumberFromHexString(hex2) {
  return (0, types_1$3.IntNumber)(new bn_js_1$1.default(ensureEvenLengthHexString(hex2, false), 16).toNumber());
}
var intNumberFromHexString_1 = util$b.intNumberFromHexString = intNumberFromHexString;
function hexStringFromIntNumber(num) {
  return (0, types_1$3.HexString)("0x" + new bn_js_1$1.default(num).toString(16));
}
var hexStringFromIntNumber_1 = util$b.hexStringFromIntNumber = hexStringFromIntNumber;
function has0xPrefix(str) {
  return str.startsWith("0x") || str.startsWith("0X");
}
var has0xPrefix_1 = util$b.has0xPrefix = has0xPrefix;
function strip0x(hex2) {
  if (has0xPrefix(hex2)) {
    return hex2.slice(2);
  }
  return hex2;
}
var strip0x_1 = util$b.strip0x = strip0x;
function prepend0x(hex2) {
  if (has0xPrefix(hex2)) {
    return "0x" + hex2.slice(2);
  }
  return "0x" + hex2;
}
var prepend0x_1 = util$b.prepend0x = prepend0x;
function isHexString$1(hex2) {
  if (typeof hex2 !== "string") {
    return false;
  }
  const s3 = strip0x(hex2).toLowerCase();
  return HEXADECIMAL_STRING_REGEX.test(s3);
}
var isHexString_1 = util$b.isHexString = isHexString$1;
function ensureHexString(hex2, includePrefix = false) {
  if (typeof hex2 === "string") {
    const s3 = strip0x(hex2).toLowerCase();
    if (HEXADECIMAL_STRING_REGEX.test(s3)) {
      return (0, types_1$3.HexString)(includePrefix ? "0x" + s3 : s3);
    }
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`"${String(hex2)}" is not a hexadecimal string`);
}
var ensureHexString_1 = util$b.ensureHexString = ensureHexString;
function ensureEvenLengthHexString(hex2, includePrefix = false) {
  let h5 = ensureHexString(hex2, false);
  if (h5.length % 2 === 1) {
    h5 = (0, types_1$3.HexString)("0" + h5);
  }
  return includePrefix ? (0, types_1$3.HexString)("0x" + h5) : h5;
}
var ensureEvenLengthHexString_1 = util$b.ensureEvenLengthHexString = ensureEvenLengthHexString;
function ensureAddressString(str) {
  if (typeof str === "string") {
    const s3 = strip0x(str).toLowerCase();
    if (isHexString$1(s3) && s3.length === 40) {
      return (0, types_1$3.AddressString)(prepend0x(s3));
    }
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(str)}`);
}
var ensureAddressString_1 = util$b.ensureAddressString = ensureAddressString;
function ensureBuffer(str) {
  if (buffer$4.Buffer.isBuffer(str)) {
    return str;
  }
  if (typeof str === "string") {
    if (isHexString$1(str)) {
      const s3 = ensureEvenLengthHexString(str, false);
      return buffer$4.Buffer.from(s3, "hex");
    } else {
      return buffer$4.Buffer.from(str, "utf8");
    }
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Not binary data: ${String(str)}`);
}
var ensureBuffer_1 = util$b.ensureBuffer = ensureBuffer;
function ensureIntNumber(num) {
  if (typeof num === "number" && Number.isInteger(num)) {
    return (0, types_1$3.IntNumber)(num);
  }
  if (typeof num === "string") {
    if (INT_STRING_REGEX.test(num)) {
      return (0, types_1$3.IntNumber)(Number(num));
    }
    if (isHexString$1(num)) {
      return (0, types_1$3.IntNumber)(new bn_js_1$1.default(ensureEvenLengthHexString(num, false), 16).toNumber());
    }
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Not an integer: ${String(num)}`);
}
var ensureIntNumber_1 = util$b.ensureIntNumber = ensureIntNumber;
function ensureRegExpString(regExp) {
  if (regExp instanceof RegExp) {
    return (0, types_1$3.RegExpString)(regExp.toString());
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(regExp)}`);
}
var ensureRegExpString_1 = util$b.ensureRegExpString = ensureRegExpString;
function ensureBN(val) {
  if (val !== null && (bn_js_1$1.default.isBN(val) || isBigNumber(val))) {
    return new bn_js_1$1.default(val.toString(10), 10);
  }
  if (typeof val === "number") {
    return new bn_js_1$1.default(ensureIntNumber(val));
  }
  if (typeof val === "string") {
    if (INT_STRING_REGEX.test(val)) {
      return new bn_js_1$1.default(val, 10);
    }
    if (isHexString$1(val)) {
      return new bn_js_1$1.default(ensureEvenLengthHexString(val, false), 16);
    }
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Not an integer: ${String(val)}`);
}
var ensureBN_1 = util$b.ensureBN = ensureBN;
function ensureParsedJSONObject(val) {
  if (typeof val === "string") {
    return JSON.parse(val);
  }
  if (typeof val === "object") {
    return val;
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(val)}`);
}
var ensureParsedJSONObject_1 = util$b.ensureParsedJSONObject = ensureParsedJSONObject;
function isBigNumber(val) {
  if (val == null || typeof val.constructor !== "function") {
    return false;
  }
  const { constructor } = val;
  return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
}
var isBigNumber_1 = util$b.isBigNumber = isBigNumber;
function range$2(start, stop) {
  return Array.from({ length: stop - start }, (_3, i3) => start + i3);
}
var range_1 = util$b.range = range$2;
function getFavicon() {
  const el2 = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');
  const { protocol, host: host2 } = document.location;
  const href = el2 ? el2.getAttribute("href") : null;
  if (!href || href.startsWith("javascript:")) {
    return null;
  }
  if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("data:")) {
    return href;
  }
  if (href.startsWith("//")) {
    return protocol + href;
  }
  return `${protocol}//${host2}${href}`;
}
var getFavicon_1 = util$b.getFavicon = getFavicon;
function createQrUrl(sessionId, sessionSecret, serverUrl, isParentConnection, version2, chainId) {
  const sessionIdKey = isParentConnection ? "parent-id" : "id";
  const query2 = (0, qs_1.stringify)({
    [sessionIdKey]: sessionId,
    secret: sessionSecret,
    server: serverUrl,
    v: version2,
    chainId
  });
  const qrUrl = `${serverUrl}/#/link?${query2}`;
  return qrUrl;
}
var createQrUrl_1 = util$b.createQrUrl = createQrUrl;
function isInIFrame() {
  try {
    return window.frameElement !== null;
  } catch (e2) {
    return false;
  }
}
isInIFrame_1 = util$b.isInIFrame = isInIFrame;
const util$a = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get bigIntStringFromBN() {
    return bigIntStringFromBN_1;
  },
  get createQrUrl() {
    return createQrUrl_1;
  },
  default: util$b,
  get ensureAddressString() {
    return ensureAddressString_1;
  },
  get ensureBN() {
    return ensureBN_1;
  },
  get ensureBuffer() {
    return ensureBuffer_1;
  },
  get ensureEvenLengthHexString() {
    return ensureEvenLengthHexString_1;
  },
  get ensureHexString() {
    return ensureHexString_1;
  },
  get ensureIntNumber() {
    return ensureIntNumber_1;
  },
  get ensureParsedJSONObject() {
    return ensureParsedJSONObject_1;
  },
  get ensureRegExpString() {
    return ensureRegExpString_1;
  },
  get getFavicon() {
    return getFavicon_1;
  },
  get has0xPrefix() {
    return has0xPrefix_1;
  },
  get hexStringFromBuffer() {
    return hexStringFromBuffer_1;
  },
  get hexStringFromIntNumber() {
    return hexStringFromIntNumber_1;
  },
  get hexStringToUint8Array() {
    return hexStringToUint8Array_1;
  },
  get intNumberFromHexString() {
    return intNumberFromHexString_1;
  },
  get isBigNumber() {
    return isBigNumber_1;
  },
  get isHexString() {
    return isHexString_1;
  },
  get isInIFrame() {
    return isInIFrame_1;
  },
  get prepend0x() {
    return prepend0x_1;
  },
  get randomBytesHex() {
    return randomBytesHex_1;
  },
  get range() {
    return range_1;
  },
  get strip0x() {
    return strip0x_1;
  },
  get uint8ArrayToHex() {
    return uint8ArrayToHex_1;
  }
}, [util$b]);
const require$$7$4 = /* @__PURE__ */ getAugmentedNamespace(util$a);
Object.defineProperty(Session$2, "__esModule", { value: true });
var Session_2 = Session$2.Session = void 0;
const sha_js_1 = require$$0$_;
const util_1$7 = require$$7$4;
const STORAGE_KEY_SESSION_ID = "session:id";
const STORAGE_KEY_SESSION_SECRET = "session:secret";
const STORAGE_KEY_SESSION_LINKED = "session:linked";
class Session {
  constructor(storage, id2, secret, linked) {
    this._storage = storage;
    this._id = id2 || (0, util_1$7.randomBytesHex)(16);
    this._secret = secret || (0, util_1$7.randomBytesHex)(32);
    this._key = new sha_js_1.sha256().update(`${this._id}, ${this._secret} WalletLink`).digest("hex");
    this._linked = !!linked;
  }
  static load(storage) {
    const id2 = storage.getItem(STORAGE_KEY_SESSION_ID);
    const linked = storage.getItem(STORAGE_KEY_SESSION_LINKED);
    const secret = storage.getItem(STORAGE_KEY_SESSION_SECRET);
    if (id2 && secret) {
      return new Session(storage, id2, secret, linked === "1");
    }
    return null;
  }
  /**
   * Takes in a session ID and returns the sha256 hash of it.
   * @param sessionId session ID
   */
  static hash(sessionId) {
    return new sha_js_1.sha256().update(sessionId).digest("hex");
  }
  get id() {
    return this._id;
  }
  get secret() {
    return this._secret;
  }
  get key() {
    return this._key;
  }
  get linked() {
    return this._linked;
  }
  set linked(val) {
    this._linked = val;
    this.persistLinked();
  }
  save() {
    this._storage.setItem(STORAGE_KEY_SESSION_ID, this._id);
    this._storage.setItem(STORAGE_KEY_SESSION_SECRET, this._secret);
    this.persistLinked();
    return this;
  }
  persistLinked() {
    this._storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
  }
}
Session_2 = Session$2.Session = Session;
const Session$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get Session() {
    return Session_2;
  },
  default: Session$2
}, [Session$2]);
const require$$9$4 = /* @__PURE__ */ getAugmentedNamespace(Session$1);
var WalletSDKRelayAbstract$2 = {};
Object.defineProperty(WalletSDKRelayAbstract$2, "__esModule", { value: true });
var WalletSDKRelayAbstract_2 = WalletSDKRelayAbstract$2.WalletSDKRelayAbstract = APP_VERSION_KEY = WalletSDKRelayAbstract$2.APP_VERSION_KEY = LOCAL_STORAGE_ADDRESSES_KEY = WalletSDKRelayAbstract$2.LOCAL_STORAGE_ADDRESSES_KEY = WALLET_USER_NAME_KEY = WalletSDKRelayAbstract$2.WALLET_USER_NAME_KEY = void 0;
const errors_1$2 = require$$5$c;
var WALLET_USER_NAME_KEY = WalletSDKRelayAbstract$2.WALLET_USER_NAME_KEY = "walletUsername";
var LOCAL_STORAGE_ADDRESSES_KEY = WalletSDKRelayAbstract$2.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
var APP_VERSION_KEY = WalletSDKRelayAbstract$2.APP_VERSION_KEY = "AppVersion";
class WalletSDKRelayAbstract {
  async makeEthereumJSONRPCRequest(request, jsonRpcUrl) {
    if (!jsonRpcUrl)
      throw new Error("Error: No jsonRpcUrl provided");
    return window.fetch(jsonRpcUrl, {
      method: "POST",
      body: JSON.stringify(request),
      mode: "cors",
      headers: { "Content-Type": "application/json" }
    }).then((res) => res.json()).then((json2) => {
      if (!json2) {
        throw errors_1$2.standardErrors.rpc.parse({});
      }
      const response = json2;
      const { error } = response;
      if (error) {
        throw (0, errors_1$2.serializeError)(error, request.method);
      }
      return response;
    });
  }
}
WalletSDKRelayAbstract_2 = WalletSDKRelayAbstract$2.WalletSDKRelayAbstract = WalletSDKRelayAbstract;
const WalletSDKRelayAbstract$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get APP_VERSION_KEY() {
    return APP_VERSION_KEY;
  },
  get LOCAL_STORAGE_ADDRESSES_KEY() {
    return LOCAL_STORAGE_ADDRESSES_KEY;
  },
  get WALLET_USER_NAME_KEY() {
    return WALLET_USER_NAME_KEY;
  },
  get WalletSDKRelayAbstract() {
    return WalletSDKRelayAbstract_2;
  },
  default: WalletSDKRelayAbstract$2
}, [WalletSDKRelayAbstract$2]);
const require$$10$4 = /* @__PURE__ */ getAugmentedNamespace(WalletSDKRelayAbstract$1);
var readableBrowser$2 = { exports: {} };
var streamBrowser = require$$0$1a.EventEmitter;
const streamBrowser$1 = /* @__PURE__ */ getDefaultExportFromCjs(streamBrowser);
const streamBrowser$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: streamBrowser$1
}, [streamBrowser]);
const require$$1$u = /* @__PURE__ */ getAugmentedNamespace(streamBrowser$2);
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object2, enumerableOnly) {
    var keys2 = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        });
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3] != null ? arguments[i3] : {};
      if (i3 % 2) {
        ownKeys(Object(source), true).forEach(function(key2) {
          _defineProperty2(target, key2, source[key2]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
    }
    return target;
  }
  function _defineProperty2(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _classCallCheck(instance2, Constructor) {
    if (!(instance2 instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties2(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties2(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties2(Constructor, staticProps);
    return Constructor;
  }
  var _require = require$$2$m, Buffer2 = _require.Buffer;
  var _require2 = require$$0$1v, inspect5 = _require2.inspect;
  var custom2 = inspect5 && inspect5.custom || "inspect";
  function copyBuffer(src2, target, offset) {
    Buffer2.prototype.copy.call(src2, target, offset);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList2() {
      _classCallCheck(this, BufferList2);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass2(BufferList2, [{
      key: "push",
      value: function push3(v4) {
        var entry = {
          data: v4,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift2(v4) {
        var entry = {
          data: v4,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear2() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s3) {
        if (this.length === 0)
          return "";
        var p3 = this.head;
        var ret = "" + p3.data;
        while (p3 = p3.next) {
          ret += s3 + p3.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat2(n4) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n4 >>> 0);
        var p3 = this.head;
        var i3 = 0;
        while (p3) {
          copyBuffer(p3.data, ret, i3);
          i3 += p3.data.length;
          p3 = p3.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume2(n4, hasStrings) {
        var ret;
        if (n4 < this.head.data.length) {
          ret = this.head.data.slice(0, n4);
          this.head.data = this.head.data.slice(n4);
        } else if (n4 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n4) : this._getBuffer(n4);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first2() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n4) {
        var p3 = this.head;
        var c2 = 1;
        var ret = p3.data;
        n4 -= ret.length;
        while (p3 = p3.next) {
          var str = p3.data;
          var nb2 = n4 > str.length ? str.length : n4;
          if (nb2 === str.length)
            ret += str;
          else
            ret += str.slice(0, n4);
          n4 -= nb2;
          if (n4 === 0) {
            if (nb2 === str.length) {
              ++c2;
              if (p3.next)
                this.head = p3.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p3;
              p3.data = str.slice(nb2);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n4) {
        var ret = Buffer2.allocUnsafe(n4);
        var p3 = this.head;
        var c2 = 1;
        p3.data.copy(ret);
        n4 -= p3.data.length;
        while (p3 = p3.next) {
          var buf2 = p3.data;
          var nb2 = n4 > buf2.length ? buf2.length : n4;
          buf2.copy(ret, ret.length - n4, 0, nb2);
          n4 -= nb2;
          if (n4 === 0) {
            if (nb2 === buf2.length) {
              ++c2;
              if (p3.next)
                this.head = p3.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p3;
              p3.data = buf2.slice(nb2);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom2,
      value: function value(_3, options) {
        return inspect5(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList2;
  }();
  return buffer_list;
}
function destroy(err, cb2) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb2) {
      cb2(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function(err2) {
    if (!cb2 && err2) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb2) {
      process.nextTick(emitCloseNT, _this);
      cb2(err2);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err) {
  emitErrorNT(self2, err);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose)
    return;
  if (self2._readableState && !self2._readableState.emitClose)
    return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err) {
  self2.emit("error", err);
}
function errorOrDestroy(stream2, err) {
  var rState = stream2._readableState;
  var wState = stream2._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy)
    stream2.destroy(err);
  else
    stream2.emit("error", err);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
};
const destroy$1 = /* @__PURE__ */ getDefaultExportFromCjs(destroy_1);
const destroy$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: destroy$1
}, [destroy_1]);
const require$$5$a = /* @__PURE__ */ getAugmentedNamespace(destroy$2);
var errorsBrowser$1 = {};
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code2, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /* @__PURE__ */ function(_Base) {
    _inheritsLoose(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base);
  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code2;
  codes[code2] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len2 = expected.length;
    expected = expected.map(function(i3) {
      return String(i3);
    });
    if (len2 > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len2 - 1).join(", "), ", or ") + expected[len2 - 1];
    } else if (len2 === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
function endsWith$1(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes(str, search, start) {
  if (typeof start !== "number") {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
  return 'The value "' + value + '" is invalid for option "' + name2 + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg;
  if (endsWith$1(name2, " argument")) {
    msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type2 = includes(name2, ".") ? "property" : "argument";
    msg = 'The "'.concat(name2, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
  return "The " + name2 + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name2) {
  return "Cannot call " + name2 + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
var codes_1 = errorsBrowser$1.codes = codes;
const errorsBrowser = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  codes: codes_1,
  default: errorsBrowser$1
}, [errorsBrowser$1]);
const require$$0$R = /* @__PURE__ */ getAugmentedNamespace(errorsBrowser);
var ERR_INVALID_OPT_VALUE = require$$0$R.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex2, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex2 ? options[duplexKey] : null;
}
function getHighWaterMark(state2, options, duplexKey, isDuplex2) {
  var hwm = highWaterMarkFrom(options, isDuplex2, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name2 = isDuplex2 ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name2, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark
};
const state$1 = /* @__PURE__ */ getDefaultExportFromCjs(state);
const state$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: state$1
}, [state]);
const require$$6$9 = /* @__PURE__ */ getAugmentedNamespace(state$2);
var browser$3 = deprecate;
function deprecate(fn2, msg) {
  if (config$1("noDeprecation")) {
    return fn2;
  }
  var warned = false;
  function deprecated2() {
    if (!warned) {
      if (config$1("throwDeprecation")) {
        throw new Error(msg);
      } else if (config$1("traceDeprecation")) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn2.apply(this, arguments);
  }
  return deprecated2;
}
function config$1(name2) {
  try {
    if (!commonjsGlobal.localStorage)
      return false;
  } catch (_3) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name2];
  if (null == val)
    return false;
  return String(val).toLowerCase() === "true";
}
const browser$4 = /* @__PURE__ */ getDefaultExportFromCjs(browser$3);
const browser$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: browser$4
}, [browser$3]);
const require$$0$Q = /* @__PURE__ */ getAugmentedNamespace(browser$5);
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex2;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require$$0$Q
  };
  var Stream = require$$1$u;
  var Buffer2 = require$$2$m.Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require$$5$a;
  var _require = require$$6$9, getHighWaterMark2 = _require.getHighWaterMark;
  var _require$codes2 = require$$0$R.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK2 = _require$codes2.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes2.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED2 = _require$codes2.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes2.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes2.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes2.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  require$$1$Q(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream2, isDuplex2) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex2 !== "boolean")
      isDuplex2 = stream2 instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex2)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options, "writableHighWaterMark", isDuplex2);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er2) {
      onwrite(stream2, er2);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_3) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object2) {
        if (realHasInstance.call(this, object2))
          return true;
        if (this !== Writable)
          return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex2 = Duplex2 || require_stream_duplex();
    var isDuplex2 = this instanceof Duplex2;
    if (!isDuplex2 && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex2);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream2, cb2) {
    var er2 = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy2(stream2, er2);
    process.nextTick(cb2, er2);
  }
  function validChunk(stream2, state2, chunk, cb2) {
    var er2;
    if (chunk === null) {
      er2 = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er2) {
      errorOrDestroy2(stream2, er2);
      process.nextTick(cb2, er2);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb2) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb2 = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state2.defaultEncoding;
    if (typeof cb2 !== "function")
      cb2 = nop;
    if (state2.ending)
      writeAfterEnd(this, cb2);
    else if (isBuf || validChunk(this, state2, chunk, cb2)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb2);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
        clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb2) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len2 = state2.objectMode ? 1 : chunk.length;
    state2.length += len2;
    var ret = state2.length < state2.highWaterMark;
    if (!ret)
      state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last2 = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb2,
        next: null
      };
      if (last2) {
        last2.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len2, chunk, encoding, cb2);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len2, chunk, encoding, cb2) {
    state2.writelen = len2;
    state2.writecb = cb2;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed)
      state2.onwrite(new ERR_STREAM_DESTROYED2("write"));
    else if (writev)
      stream2._writev(chunk, state2.onwrite);
    else
      stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync, er2, cb2) {
    --state2.pendingcb;
    if (sync) {
      process.nextTick(cb2, er2);
      process.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy2(stream2, er2);
    } else {
      cb2(er2);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy2(stream2, er2);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er2) {
    var state2 = stream2._writableState;
    var sync = state2.sync;
    var cb2 = state2.writecb;
    if (typeof cb2 !== "function")
      throw new ERR_MULTIPLE_CALLBACK2();
    onwriteStateUpdate(state2);
    if (er2)
      onwriteError(stream2, state2, sync, er2, cb2);
    else {
      var finished = needFinish(state2) || stream2.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync) {
        process.nextTick(afterWrite, stream2, state2, finished, cb2);
      } else {
        afterWrite(stream2, state2, finished, cb2);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb2) {
    if (!finished)
      onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb2();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l2 = state2.bufferedRequestCount;
      var buffer2 = new Array(l2);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count2 = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count2] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count2 += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb2 = entry.callback;
        var len2 = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len2, chunk, encoding, cb2);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null)
        state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb2) {
    cb2(new ERR_METHOD_NOT_IMPLEMENTED2("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb2) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb2 = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb2 = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending)
      endWritable(this, state2, cb2);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy2(stream2, err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish2(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish2(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream2._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream2.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb2) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb2) {
      if (state2.finished)
        process.nextTick(cb2);
      else
        stream2.once("finish", cb2);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb2 = entry.callback;
      state2.pendingcb--;
      cb2(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set2(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb2) {
    cb2(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys3 = [];
    for (var key2 in obj) {
      keys3.push(key2);
    }
    return keys3;
  };
  _stream_duplex = Duplex2;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  require$$1$Q(Duplex2, Readable);
  {
    var keys2 = objectKeys(Writable.prototype);
    for (var v4 = 0; v4 < keys2.length; v4++) {
      var method = keys2[v4];
      if (!Duplex2.prototype[method])
        Duplex2.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex2(options) {
    if (!(this instanceof Duplex2))
      return new Duplex2(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set2(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder)
    return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = require$$0$10.Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb2;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb2 = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb2 = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb2 = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb2);
  }
  StringDecoder.prototype.write = function(buf2) {
    if (buf2.length === 0)
      return "";
    var r2;
    var i3;
    if (this.lastNeed) {
      r2 = this.fillLast(buf2);
      if (r2 === void 0)
        return "";
      i3 = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i3 = 0;
    }
    if (i3 < buf2.length)
      return r2 ? r2 + this.text(buf2, i3) : this.text(buf2, i3);
    return r2 || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf2) {
    if (this.lastNeed <= buf2.length) {
      buf2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf2.length);
    this.lastNeed -= buf2.length;
  };
  function utf8CheckByte(byte2) {
    if (byte2 <= 127)
      return 0;
    else if (byte2 >> 5 === 6)
      return 2;
    else if (byte2 >> 4 === 14)
      return 3;
    else if (byte2 >> 3 === 30)
      return 4;
    return byte2 >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf2, i3) {
    var j2 = buf2.length - 1;
    if (j2 < i3)
      return 0;
    var nb2 = utf8CheckByte(buf2[j2]);
    if (nb2 >= 0) {
      if (nb2 > 0)
        self2.lastNeed = nb2 - 1;
      return nb2;
    }
    if (--j2 < i3 || nb2 === -2)
      return 0;
    nb2 = utf8CheckByte(buf2[j2]);
    if (nb2 >= 0) {
      if (nb2 > 0)
        self2.lastNeed = nb2 - 2;
      return nb2;
    }
    if (--j2 < i3 || nb2 === -2)
      return 0;
    nb2 = utf8CheckByte(buf2[j2]);
    if (nb2 >= 0) {
      if (nb2 > 0) {
        if (nb2 === 2)
          nb2 = 0;
        else
          self2.lastNeed = nb2 - 3;
      }
      return nb2;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf2, p3) {
    if ((buf2[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf2.length > 1) {
      if ((buf2[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf2.length > 2) {
        if ((buf2[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf2) {
    var p3 = this.lastTotal - this.lastNeed;
    var r2 = utf8CheckExtraBytes(this, buf2);
    if (r2 !== void 0)
      return r2;
    if (this.lastNeed <= buf2.length) {
      buf2.copy(this.lastChar, p3, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf2.copy(this.lastChar, p3, 0, buf2.length);
    this.lastNeed -= buf2.length;
  }
  function utf8Text(buf2, i3) {
    var total = utf8CheckIncomplete(this, buf2, i3);
    if (!this.lastNeed)
      return buf2.toString("utf8", i3);
    this.lastTotal = total;
    var end2 = buf2.length - (total - this.lastNeed);
    buf2.copy(this.lastChar, 0, end2);
    return buf2.toString("utf8", i3, end2);
  }
  function utf8End(buf2) {
    var r2 = buf2 && buf2.length ? this.write(buf2) : "";
    if (this.lastNeed)
      return r2 + "�";
    return r2;
  }
  function utf16Text(buf2, i3) {
    if ((buf2.length - i3) % 2 === 0) {
      var r2 = buf2.toString("utf16le", i3);
      if (r2) {
        var c2 = r2.charCodeAt(r2.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf2[buf2.length - 2];
          this.lastChar[1] = buf2[buf2.length - 1];
          return r2.slice(0, -1);
        }
      }
      return r2;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf2[buf2.length - 1];
    return buf2.toString("utf16le", i3, buf2.length - 1);
  }
  function utf16End(buf2) {
    var r2 = buf2 && buf2.length ? this.write(buf2) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r2 + this.lastChar.toString("utf16le", 0, end2);
    }
    return r2;
  }
  function base64Text(buf2, i3) {
    var n4 = (buf2.length - i3) % 3;
    if (n4 === 0)
      return buf2.toString("base64", i3);
    this.lastNeed = 3 - n4;
    this.lastTotal = 3;
    if (n4 === 1) {
      this.lastChar[0] = buf2[buf2.length - 1];
    } else {
      this.lastChar[0] = buf2[buf2.length - 2];
      this.lastChar[1] = buf2[buf2.length - 1];
    }
    return buf2.toString("base64", i3, buf2.length - n4);
  }
  function base64End(buf2) {
    var r2 = buf2 && buf2.length ? this.write(buf2) : "";
    if (this.lastNeed)
      return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r2;
  }
  function simpleWrite(buf2) {
    return buf2.toString(this.encoding);
  }
  function simpleEnd(buf2) {
    return buf2 && buf2.length ? this.write(buf2) : "";
  }
  return string_decoder;
}
var ERR_STREAM_PREMATURE_CLOSE = require$$0$R.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$6() {
}
function isRequest$1(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function eos$1(stream2, opts, callback) {
  if (typeof opts === "function")
    return eos$1(stream2, null, opts);
  if (!opts)
    opts = {};
  callback = once$1(callback || noop$6);
  var readable = opts.readable || opts.readable !== false && stream2.readable;
  var writable = opts.writable || opts.writable !== false && stream2.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream2.writable)
      onfinish();
  };
  var writableEnded = stream2._writableState && stream2._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable)
      callback.call(stream2);
  };
  var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
  var onend = function onend2() {
    readable = false;
    readableEnded = true;
    if (!writable)
      callback.call(stream2);
  };
  var onerror = function onerror2(err) {
    callback.call(stream2, err);
  };
  var onclose = function onclose2() {
    var err;
    if (readable && !readableEnded) {
      if (!stream2._readableState || !stream2._readableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err);
    }
    if (writable && !writableEnded) {
      if (!stream2._writableState || !stream2._writableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err);
    }
  };
  var onrequest = function onrequest2() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req)
      onrequest();
    else
      stream2.on("request", onrequest);
  } else if (writable && !stream2._writableState) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  stream2.on("end", onend);
  stream2.on("finish", onfinish);
  if (opts.error !== false)
    stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req)
      stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("end", onend);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
const endOfStream$1 = /* @__PURE__ */ getDefaultExportFromCjs(endOfStream);
const endOfStream$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: endOfStream$1
}, [endOfStream]);
const require$$5$9 = /* @__PURE__ */ getAugmentedNamespace(endOfStream$2);
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty2(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var finished = require$$5$9;
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done2) {
    return {
      value,
      done: done2
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data2, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
    var _Object$create;
    var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty2(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty2(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data2 = iterator2[kStream].read();
        if (data2) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve(createIterResult(data2, false));
        } else {
          iterator2[kLastResolve] = resolve;
          iterator2[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator2[kLastPromise] = null;
    finished(stream2, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator2[kLastReject];
        if (reject !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          reject(err);
        }
        iterator2[kError] = err;
        return;
      }
      var resolve = iterator2[kLastResolve];
      if (resolve !== null) {
        iterator2[kLastPromise] = null;
        iterator2[kLastResolve] = null;
        iterator2[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator2[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator2));
    return iterator2;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser)
    return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex2;
  Readable.ReadableState = ReadableState;
  require$$0$1a.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = require$$1$u;
  var Buffer2 = require$$2$m.Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require$$0$1v;
  var debug2;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function debug3() {
    };
  }
  var BufferList2 = requireBuffer_list();
  var destroyImpl = require$$5$a;
  var _require = require$$6$9, getHighWaterMark2 = _require.getHighWaterMark;
  var _require$codes2 = require$$0$R.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes2.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from2;
  require$$1$Q(Readable, Stream);
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener2(emitter, event, fn2) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn2);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn2);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn2);
    else
      emitter._events[event] = [fn2, emitter._events[event]];
  }
  function ReadableState(options, stream2, isDuplex2) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex2 !== "boolean")
      isDuplex2 = stream2 instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex2)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options, "readableHighWaterMark", isDuplex2);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex2 = Duplex2 || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex2 = this instanceof Duplex2;
    this._readableState = new ReadableState(options, this, isDuplex2);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set2(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb2) {
    cb2(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    debug2("readableAddChunk", chunk);
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er2;
      if (!skipChunkCheck)
        er2 = chunkInvalid(state2, chunk);
      if (er2) {
        errorOrDestroy2(stream2, er2);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted)
            errorOrDestroy2(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy2(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0)
              addChunk(stream2, state2, chunk, false);
            else
              maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream2, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream2.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront)
        state2.buffer.unshift(chunk);
      else
        state2.buffer.push(chunk);
      if (state2.needReadable)
        emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er2;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er2;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p3 = this._readableState.buffer.head;
    var content = "";
    while (p3 !== null) {
      content += decoder.write(p3.data);
      p3 = p3.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n4) {
    if (n4 >= MAX_HWM) {
      n4 = MAX_HWM;
    } else {
      n4--;
      n4 |= n4 >>> 1;
      n4 |= n4 >>> 2;
      n4 |= n4 >>> 4;
      n4 |= n4 >>> 8;
      n4 |= n4 >>> 16;
      n4++;
    }
    return n4;
  }
  function howMuchToRead(n4, state2) {
    if (n4 <= 0 || state2.length === 0 && state2.ended)
      return 0;
    if (state2.objectMode)
      return 1;
    if (n4 !== n4) {
      if (state2.flowing && state2.length)
        return state2.buffer.head.data.length;
      else
        return state2.length;
    }
    if (n4 > state2.highWaterMark)
      state2.highWaterMark = computeNewHighWaterMark(n4);
    if (n4 <= state2.length)
      return n4;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n4) {
    debug2("read", n4);
    n4 = parseInt(n4, 10);
    var state2 = this._readableState;
    var nOrig = n4;
    if (n4 !== 0)
      state2.emittedReadable = false;
    if (n4 === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n4 = howMuchToRead(n4, state2);
    if (n4 === 0 && state2.ended) {
      if (state2.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n4 < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0)
        state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading)
        n4 = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n4 > 0)
      ret = fromList(n4, state2);
    else
      ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n4 = 0;
    } else {
      state2.length -= n4;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended)
        state2.needReadable = true;
      if (nOrig !== n4 && state2.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    debug2("onEofChunk");
    if (state2.ended)
      return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream2);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream2);
      }
    }
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process.nextTick(emitReadable_, stream2);
    }
  }
  function emitReadable_(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream2.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len2 = state2.length;
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len2 === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n4) {
    errorOrDestroy2(this, new ERR_METHOD_NOT_IMPLEMENTED2("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted)
      process.nextTick(endFn);
    else
      src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug2("onunpipe");
      if (readable === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      var ret = dest.write(chunk);
      debug2("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src2.pause();
      }
    }
    function onerror(er2) {
      debug2("onerror", er2);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy2(dest, er2);
    }
    prependListener2(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain)
        state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0)
      return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes)
        return this;
      if (!dest)
        dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len2 = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i3 = 0; i3 < len2; i3++) {
        dests[i3].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1)
      return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1)
      state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev2, fn2) {
    var res = Stream.prototype.on.call(this, ev2, fn2);
    var state2 = this._readableState;
    if (ev2 === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false)
        this.resume();
    } else if (ev2 === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug2("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev2, fn2) {
    var res = Stream.prototype.removeListener.call(this, ev2, fn2);
    if (ev2 === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev2) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev2 === "readable" || ev2 === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    debug2("resume", state2.reading);
    if (!state2.reading) {
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading)
      stream2.read(0);
  }
  Readable.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder)
        chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state2.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i3 in stream2) {
      if (this[i3] === void 0 && typeof stream2[i3] === "function") {
        this[i3] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream2[method].apply(stream2, arguments);
          };
        }(i3);
      }
    }
    for (var n4 = 0; n4 < kProxyEvents.length; n4++) {
      stream2.on(kProxyEvents[n4], this.emit.bind(this, kProxyEvents[n4]));
    }
    this._read = function(n5) {
      debug2("wrapped _read", n5);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.flowing;
    },
    set: function set2(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.length;
    }
  });
  function fromList(n4, state2) {
    if (state2.length === 0)
      return null;
    var ret;
    if (state2.objectMode)
      ret = state2.buffer.shift();
    else if (!n4 || n4 >= state2.length) {
      if (state2.decoder)
        ret = state2.buffer.join("");
      else if (state2.buffer.length === 1)
        ret = state2.buffer.first();
      else
        ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n4, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    debug2("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
      if (state2.autoDestroy) {
        var wState = stream2._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream2.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from2 === void 0) {
        from2 = requireFromBrowser();
      }
      return from2(Readable, iterable, opts);
    };
  }
  function indexOf2(xs2, x2) {
    for (var i3 = 0, l2 = xs2.length; i3 < l2; i3++) {
      if (xs2[i3] === x2)
        return i3;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$3;
var _require$codes$1 = require$$0$R.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require_stream_duplex();
require$$1$Q(Transform$3, Duplex);
function afterTransform(er2, data2) {
  var ts2 = this._transformState;
  ts2.transforming = false;
  var cb2 = ts2.writecb;
  if (cb2 === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts2.writechunk = null;
  ts2.writecb = null;
  if (data2 != null)
    this.push(data2);
  cb2(er2);
  var rs2 = this._readableState;
  rs2.reading = false;
  if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
    this._read(rs2.highWaterMark);
  }
}
function Transform$3(options) {
  if (!(this instanceof Transform$3))
    return new Transform$3(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.on("prefinish", prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er2, data2) {
      done(_this, er2, data2);
    });
  } else {
    done(this, null, null);
  }
}
Transform$3.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$3.prototype._transform = function(chunk, encoding, cb2) {
  cb2(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$3.prototype._write = function(chunk, encoding, cb2) {
  var ts2 = this._transformState;
  ts2.writecb = cb2;
  ts2.writechunk = chunk;
  ts2.writeencoding = encoding;
  if (!ts2.transforming) {
    var rs2 = this._readableState;
    if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
      this._read(rs2.highWaterMark);
  }
};
Transform$3.prototype._read = function(n4) {
  var ts2 = this._transformState;
  if (ts2.writechunk !== null && !ts2.transforming) {
    ts2.transforming = true;
    this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
  } else {
    ts2.needTransform = true;
  }
};
Transform$3.prototype._destroy = function(err, cb2) {
  Duplex.prototype._destroy.call(this, err, function(err2) {
    cb2(err2);
  });
};
function done(stream2, er2, data2) {
  if (er2)
    return stream2.emit("error", er2);
  if (data2 != null)
    stream2.push(data2);
  if (stream2._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream2._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream2.push(null);
}
const _stream_transform$1 = /* @__PURE__ */ getDefaultExportFromCjs(_stream_transform);
const _stream_transform$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _stream_transform$1
}, [_stream_transform]);
const require$$3$d = /* @__PURE__ */ getAugmentedNamespace(_stream_transform$2);
var _stream_passthrough = PassThrough;
var Transform$2 = require$$3$d;
require$$1$Q(PassThrough, Transform$2);
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform$2.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb2) {
  cb2(null, chunk);
};
const _stream_passthrough$1 = /* @__PURE__ */ getDefaultExportFromCjs(_stream_passthrough);
const _stream_passthrough$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _stream_passthrough$1
}, [_stream_passthrough]);
const require$$4$b = /* @__PURE__ */ getAugmentedNamespace(_stream_passthrough$2);
var eos;
function once(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = require$$0$R.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop$5(err) {
  if (err)
    throw err;
}
function isRequest(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function destroyer(stream2, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  if (eos === void 0)
    eos = require$$5$9;
  eos(stream2, {
    readable: reading,
    writable: writing
  }, function(err) {
    if (err)
      return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err) {
    if (closed)
      return;
    if (destroyed)
      return;
    destroyed = true;
    if (isRequest(stream2))
      return stream2.abort();
    if (typeof stream2.destroy === "function")
      return stream2.destroy();
    callback(err || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn2) {
  fn2();
}
function pipe$3(from2, to) {
  return from2.pipe(to);
}
function popCallback(streams) {
  if (!streams.length)
    return noop$5;
  if (typeof streams[streams.length - 1] !== "function")
    return noop$5;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0]))
    streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error;
  var destroys = streams.map(function(stream2, i3) {
    var reading = i3 < streams.length - 1;
    var writing = i3 > 0;
    return destroyer(stream2, reading, writing, function(err) {
      if (!error)
        error = err;
      if (err)
        destroys.forEach(call);
      if (reading)
        return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe$3);
}
var pipeline_1 = pipeline;
const pipeline$1 = /* @__PURE__ */ getDefaultExportFromCjs(pipeline_1);
const pipeline$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: pipeline$1
}, [pipeline_1]);
const require$$6$8 = /* @__PURE__ */ getAugmentedNamespace(pipeline$2);
(function(module2, exports2) {
  exports2 = module2.exports = require_stream_readable();
  exports2.Stream = exports2;
  exports2.Readable = exports2;
  exports2.Writable = require_stream_writable();
  exports2.Duplex = require_stream_duplex();
  exports2.Transform = require$$3$d;
  exports2.PassThrough = require$$4$b;
  exports2.finished = require$$5$9;
  exports2.pipeline = require$$6$8;
})(readableBrowser$2, readableBrowser$2.exports);
var readableBrowserExports = readableBrowser$2.exports;
const readableBrowser = /* @__PURE__ */ getDefaultExportFromCjs(readableBrowserExports);
const readableBrowser$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: readableBrowser
}, [readableBrowserExports]);
const require$$0$P = /* @__PURE__ */ getAugmentedNamespace(readableBrowser$1);
const { Transform: Transform$1 } = require$$0$P;
var keccak$4 = (KeccakState) => class Keccak2 extends Transform$1 {
  constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
    super(options);
    this._rate = rate;
    this._capacity = capacity;
    this._delimitedSuffix = delimitedSuffix;
    this._hashBitLength = hashBitLength;
    this._options = options;
    this._state = new KeccakState();
    this._state.initialize(rate, capacity);
    this._finalized = false;
  }
  _transform(chunk, encoding, callback) {
    let error = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }
    callback(error);
  }
  _flush(callback) {
    let error = null;
    try {
      this.push(this.digest());
    } catch (err) {
      error = err;
    }
    callback(error);
  }
  update(data2, encoding) {
    if (!buffer$4.Buffer.isBuffer(data2) && typeof data2 !== "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Digest already called");
    if (!buffer$4.Buffer.isBuffer(data2))
      data2 = buffer$4.Buffer.from(data2, encoding);
    this._state.absorb(data2);
    return this;
  }
  digest(encoding) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    if (this._delimitedSuffix)
      this._state.absorbLastFewBits(this._delimitedSuffix);
    let digest9 = this._state.squeeze(this._hashBitLength / 8);
    if (encoding !== void 0)
      digest9 = digest9.toString(encoding);
    this._resetState();
    return digest9;
  }
  // remove result from memory
  _resetState() {
    this._state.initialize(this._rate, this._capacity);
    return this;
  }
  // because sometimes we need hash right now and little later
  _clone() {
    const clone2 = new Keccak2(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
    this._state.copy(clone2._state);
    clone2._finalized = this._finalized;
    return clone2;
  }
};
const keccak$5 = /* @__PURE__ */ getDefaultExportFromCjs(keccak$4);
const keccak$6 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: keccak$5
}, [keccak$4]);
const require$$0$O = /* @__PURE__ */ getAugmentedNamespace(keccak$6);
const { Transform } = require$$0$P;
var shake = (KeccakState) => class Shake extends Transform {
  constructor(rate, capacity, delimitedSuffix, options) {
    super(options);
    this._rate = rate;
    this._capacity = capacity;
    this._delimitedSuffix = delimitedSuffix;
    this._options = options;
    this._state = new KeccakState();
    this._state.initialize(rate, capacity);
    this._finalized = false;
  }
  _transform(chunk, encoding, callback) {
    let error = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }
    callback(error);
  }
  _flush() {
  }
  _read(size2) {
    this.push(this.squeeze(size2));
  }
  update(data2, encoding) {
    if (!buffer$4.Buffer.isBuffer(data2) && typeof data2 !== "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Squeeze already called");
    if (!buffer$4.Buffer.isBuffer(data2))
      data2 = buffer$4.Buffer.from(data2, encoding);
    this._state.absorb(data2);
    return this;
  }
  squeeze(dataByteLength, encoding) {
    if (!this._finalized) {
      this._finalized = true;
      this._state.absorbLastFewBits(this._delimitedSuffix);
    }
    let data2 = this._state.squeeze(dataByteLength);
    if (encoding !== void 0)
      data2 = data2.toString(encoding);
    return data2;
  }
  _resetState() {
    this._state.initialize(this._rate, this._capacity);
    return this;
  }
  _clone() {
    const clone2 = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
    this._state.copy(clone2._state);
    clone2._finalized = this._finalized;
    return clone2;
  }
};
const shake$1 = /* @__PURE__ */ getDefaultExportFromCjs(shake);
const shake$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: shake$1
}, [shake]);
const require$$1$t = /* @__PURE__ */ getAugmentedNamespace(shake$2);
const createKeccak = require$$0$O;
const createShake = require$$1$t;
var api = function(KeccakState) {
  const Keccak2 = createKeccak(KeccakState);
  const Shake = createShake(KeccakState);
  return function(algorithm, options) {
    const hash2 = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
    switch (hash2) {
      case "keccak224":
        return new Keccak2(1152, 448, null, 224, options);
      case "keccak256":
        return new Keccak2(1088, 512, null, 256, options);
      case "keccak384":
        return new Keccak2(832, 768, null, 384, options);
      case "keccak512":
        return new Keccak2(576, 1024, null, 512, options);
      case "sha3-224":
        return new Keccak2(1152, 448, 6, 224, options);
      case "sha3-256":
        return new Keccak2(1088, 512, 6, 256, options);
      case "sha3-384":
        return new Keccak2(832, 768, 6, 384, options);
      case "sha3-512":
        return new Keccak2(576, 1024, 6, 512, options);
      case "shake128":
        return new Shake(1344, 256, 31, options);
      case "shake256":
        return new Shake(1088, 512, 31, options);
      default:
        throw new Error("Invald algorithm: " + algorithm);
    }
  };
};
const index$r = /* @__PURE__ */ getDefaultExportFromCjs(api);
const api$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$r
}, [api]);
const require$$0$N = /* @__PURE__ */ getAugmentedNamespace(api$1);
var keccakStateUnroll$1 = {};
const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
var p1600 = keccakStateUnroll$1.p1600 = function(s3) {
  for (let round = 0; round < 24; ++round) {
    const lo0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
    const hi0 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
    const lo1 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
    const hi1 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
    const lo2 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
    const hi2 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
    const lo3 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
    const hi3 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
    const lo4 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
    const hi4 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
    let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
    let hi5 = hi4 ^ (hi1 << 1 | lo1 >>> 31);
    const t1slo0 = s3[0] ^ lo;
    const t1shi0 = s3[1] ^ hi5;
    const t1slo5 = s3[10] ^ lo;
    const t1shi5 = s3[11] ^ hi5;
    const t1slo10 = s3[20] ^ lo;
    const t1shi10 = s3[21] ^ hi5;
    const t1slo15 = s3[30] ^ lo;
    const t1shi15 = s3[31] ^ hi5;
    const t1slo20 = s3[40] ^ lo;
    const t1shi20 = s3[41] ^ hi5;
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
    hi5 = hi0 ^ (hi2 << 1 | lo2 >>> 31);
    const t1slo1 = s3[2] ^ lo;
    const t1shi1 = s3[3] ^ hi5;
    const t1slo6 = s3[12] ^ lo;
    const t1shi6 = s3[13] ^ hi5;
    const t1slo11 = s3[22] ^ lo;
    const t1shi11 = s3[23] ^ hi5;
    const t1slo16 = s3[32] ^ lo;
    const t1shi16 = s3[33] ^ hi5;
    const t1slo21 = s3[42] ^ lo;
    const t1shi21 = s3[43] ^ hi5;
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
    hi5 = hi1 ^ (hi3 << 1 | lo3 >>> 31);
    const t1slo2 = s3[4] ^ lo;
    const t1shi2 = s3[5] ^ hi5;
    const t1slo7 = s3[14] ^ lo;
    const t1shi7 = s3[15] ^ hi5;
    const t1slo12 = s3[24] ^ lo;
    const t1shi12 = s3[25] ^ hi5;
    const t1slo17 = s3[34] ^ lo;
    const t1shi17 = s3[35] ^ hi5;
    const t1slo22 = s3[44] ^ lo;
    const t1shi22 = s3[45] ^ hi5;
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
    hi5 = hi2 ^ (hi4 << 1 | lo4 >>> 31);
    const t1slo3 = s3[6] ^ lo;
    const t1shi3 = s3[7] ^ hi5;
    const t1slo8 = s3[16] ^ lo;
    const t1shi8 = s3[17] ^ hi5;
    const t1slo13 = s3[26] ^ lo;
    const t1shi13 = s3[27] ^ hi5;
    const t1slo18 = s3[36] ^ lo;
    const t1shi18 = s3[37] ^ hi5;
    const t1slo23 = s3[46] ^ lo;
    const t1shi23 = s3[47] ^ hi5;
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
    hi5 = hi3 ^ (hi0 << 1 | lo0 >>> 31);
    const t1slo4 = s3[8] ^ lo;
    const t1shi4 = s3[9] ^ hi5;
    const t1slo9 = s3[18] ^ lo;
    const t1shi9 = s3[19] ^ hi5;
    const t1slo14 = s3[28] ^ lo;
    const t1shi14 = s3[29] ^ hi5;
    const t1slo19 = s3[38] ^ lo;
    const t1shi19 = s3[39] ^ hi5;
    const t1slo24 = s3[48] ^ lo;
    const t1shi24 = s3[49] ^ hi5;
    const t2slo0 = t1slo0;
    const t2shi0 = t1shi0;
    const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
    const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
    const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
    const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
    const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
    const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
    const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
    const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
    const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
    const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
    const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
    const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
    const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
    const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
    const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
    const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
    const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
    const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
    const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
    const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
    const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
    const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
    const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
    const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
    const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
    const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
    const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
    const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
    const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
    const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
    const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
    const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
    const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
    const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
    const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
    const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
    const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
    const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
    const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
    const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
    const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
    const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
    const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
    const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
    const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
    const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
    const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
    const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
    s3[0] = t2slo0 ^ ~t2slo1 & t2slo2;
    s3[1] = t2shi0 ^ ~t2shi1 & t2shi2;
    s3[10] = t2slo5 ^ ~t2slo6 & t2slo7;
    s3[11] = t2shi5 ^ ~t2shi6 & t2shi7;
    s3[20] = t2slo10 ^ ~t2slo11 & t2slo12;
    s3[21] = t2shi10 ^ ~t2shi11 & t2shi12;
    s3[30] = t2slo15 ^ ~t2slo16 & t2slo17;
    s3[31] = t2shi15 ^ ~t2shi16 & t2shi17;
    s3[40] = t2slo20 ^ ~t2slo21 & t2slo22;
    s3[41] = t2shi20 ^ ~t2shi21 & t2shi22;
    s3[2] = t2slo1 ^ ~t2slo2 & t2slo3;
    s3[3] = t2shi1 ^ ~t2shi2 & t2shi3;
    s3[12] = t2slo6 ^ ~t2slo7 & t2slo8;
    s3[13] = t2shi6 ^ ~t2shi7 & t2shi8;
    s3[22] = t2slo11 ^ ~t2slo12 & t2slo13;
    s3[23] = t2shi11 ^ ~t2shi12 & t2shi13;
    s3[32] = t2slo16 ^ ~t2slo17 & t2slo18;
    s3[33] = t2shi16 ^ ~t2shi17 & t2shi18;
    s3[42] = t2slo21 ^ ~t2slo22 & t2slo23;
    s3[43] = t2shi21 ^ ~t2shi22 & t2shi23;
    s3[4] = t2slo2 ^ ~t2slo3 & t2slo4;
    s3[5] = t2shi2 ^ ~t2shi3 & t2shi4;
    s3[14] = t2slo7 ^ ~t2slo8 & t2slo9;
    s3[15] = t2shi7 ^ ~t2shi8 & t2shi9;
    s3[24] = t2slo12 ^ ~t2slo13 & t2slo14;
    s3[25] = t2shi12 ^ ~t2shi13 & t2shi14;
    s3[34] = t2slo17 ^ ~t2slo18 & t2slo19;
    s3[35] = t2shi17 ^ ~t2shi18 & t2shi19;
    s3[44] = t2slo22 ^ ~t2slo23 & t2slo24;
    s3[45] = t2shi22 ^ ~t2shi23 & t2shi24;
    s3[6] = t2slo3 ^ ~t2slo4 & t2slo0;
    s3[7] = t2shi3 ^ ~t2shi4 & t2shi0;
    s3[16] = t2slo8 ^ ~t2slo9 & t2slo5;
    s3[17] = t2shi8 ^ ~t2shi9 & t2shi5;
    s3[26] = t2slo13 ^ ~t2slo14 & t2slo10;
    s3[27] = t2shi13 ^ ~t2shi14 & t2shi10;
    s3[36] = t2slo18 ^ ~t2slo19 & t2slo15;
    s3[37] = t2shi18 ^ ~t2shi19 & t2shi15;
    s3[46] = t2slo23 ^ ~t2slo24 & t2slo20;
    s3[47] = t2shi23 ^ ~t2shi24 & t2shi20;
    s3[8] = t2slo4 ^ ~t2slo0 & t2slo1;
    s3[9] = t2shi4 ^ ~t2shi0 & t2shi1;
    s3[18] = t2slo9 ^ ~t2slo5 & t2slo6;
    s3[19] = t2shi9 ^ ~t2shi5 & t2shi6;
    s3[28] = t2slo14 ^ ~t2slo10 & t2slo11;
    s3[29] = t2shi14 ^ ~t2shi10 & t2shi11;
    s3[38] = t2slo19 ^ ~t2slo15 & t2slo16;
    s3[39] = t2shi19 ^ ~t2shi15 & t2shi16;
    s3[48] = t2slo24 ^ ~t2slo20 & t2slo21;
    s3[49] = t2shi24 ^ ~t2shi20 & t2shi21;
    s3[0] ^= P1600_ROUND_CONSTANTS[round * 2];
    s3[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
  }
};
const keccakStateUnroll = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: keccakStateUnroll$1,
  p1600
}, [keccakStateUnroll$1]);
const require$$0$M = /* @__PURE__ */ getAugmentedNamespace(keccakStateUnroll);
const keccakState = require$$0$M;
function Keccak() {
  this.state = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  this.blockSize = null;
  this.count = 0;
  this.squeezing = false;
}
Keccak.prototype.initialize = function(rate, capacity) {
  for (let i3 = 0; i3 < 50; ++i3)
    this.state[i3] = 0;
  this.blockSize = rate / 8;
  this.count = 0;
  this.squeezing = false;
};
Keccak.prototype.absorb = function(data2) {
  for (let i3 = 0; i3 < data2.length; ++i3) {
    this.state[~~(this.count / 4)] ^= data2[i3] << 8 * (this.count % 4);
    this.count += 1;
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }
};
Keccak.prototype.absorbLastFewBits = function(bits) {
  this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
  if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
    keccakState.p1600(this.state);
  this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
  keccakState.p1600(this.state);
  this.count = 0;
  this.squeezing = true;
};
Keccak.prototype.squeeze = function(length2) {
  if (!this.squeezing)
    this.absorbLastFewBits(1);
  const output = buffer$4.Buffer.alloc(length2);
  for (let i3 = 0; i3 < length2; ++i3) {
    output[i3] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
    this.count += 1;
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }
  return output;
};
Keccak.prototype.copy = function(dest) {
  for (let i3 = 0; i3 < 50; ++i3)
    dest.state[i3] = this.state[i3];
  dest.blockSize = this.blockSize;
  dest.count = this.count;
  dest.squeezing = this.squeezing;
};
var keccak$1 = Keccak;
const keccak$2 = /* @__PURE__ */ getDefaultExportFromCjs(keccak$1);
const keccak$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: keccak$2
}, [keccak$1]);
const require$$1$s = /* @__PURE__ */ getAugmentedNamespace(keccak$3);
var js = require$$0$N(require$$1$s);
const js$1 = /* @__PURE__ */ getDefaultExportFromCjs(js);
const js$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: js$1
}, [js]);
const require$$0$L = /* @__PURE__ */ getAugmentedNamespace(js$2);
const createKeccakHash = require$$0$L;
const BN$1 = require$$1$B;
function zeros(bytes2) {
  return buffer$4.Buffer.allocUnsafe(bytes2).fill(0);
}
function setLength(msg, length2, right) {
  const buf2 = zeros(length2);
  msg = toBuffer(msg);
  if (right) {
    if (msg.length < length2) {
      msg.copy(buf2);
      return buf2;
    }
    return msg.slice(0, length2);
  } else {
    if (msg.length < length2) {
      msg.copy(buf2, length2 - msg.length);
      return buf2;
    }
    return msg.slice(-length2);
  }
}
function setLengthRight(msg, length2) {
  return setLength(msg, length2, true);
}
function toBuffer(v4) {
  if (!buffer$4.Buffer.isBuffer(v4)) {
    if (Array.isArray(v4)) {
      v4 = buffer$4.Buffer.from(v4);
    } else if (typeof v4 === "string") {
      if (isHexString(v4)) {
        v4 = buffer$4.Buffer.from(padToEven(stripHexPrefix(v4)), "hex");
      } else {
        v4 = buffer$4.Buffer.from(v4);
      }
    } else if (typeof v4 === "number") {
      v4 = intToBuffer(v4);
    } else if (v4 === null || v4 === void 0) {
      v4 = buffer$4.Buffer.allocUnsafe(0);
    } else if (BN$1.isBN(v4)) {
      v4 = v4.toArrayLike(buffer$4.Buffer);
    } else if (v4.toArray) {
      v4 = buffer$4.Buffer.from(v4.toArray());
    } else {
      throw new Error("invalid type");
    }
  }
  return v4;
}
function bufferToHex(buf2) {
  buf2 = toBuffer(buf2);
  return "0x" + buf2.toString("hex");
}
function keccak(a3, bits) {
  a3 = toBuffer(a3);
  if (!bits)
    bits = 256;
  return createKeccakHash("keccak" + bits).update(a3).digest();
}
function padToEven(str) {
  return str.length % 2 ? "0" + str : str;
}
function isHexString(str) {
  return typeof str === "string" && str.match(/^0x[0-9A-Fa-f]*$/);
}
function stripHexPrefix(str) {
  if (typeof str === "string" && str.startsWith("0x")) {
    return str.slice(2);
  }
  return str;
}
var util$7 = {
  zeros,
  setLength,
  setLengthRight,
  isHexString,
  stripHexPrefix,
  toBuffer,
  bufferToHex,
  keccak
};
const util$8 = /* @__PURE__ */ getDefaultExportFromCjs(util$7);
const util$9 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: util$8
}, [util$7]);
const require$$0$K = /* @__PURE__ */ getAugmentedNamespace(util$9);
const util$6 = require$$0$K;
const BN = require$$1$B;
function elementaryName(name2) {
  if (name2.startsWith("int[")) {
    return "int256" + name2.slice(3);
  } else if (name2 === "int") {
    return "int256";
  } else if (name2.startsWith("uint[")) {
    return "uint256" + name2.slice(4);
  } else if (name2 === "uint") {
    return "uint256";
  } else if (name2.startsWith("fixed[")) {
    return "fixed128x128" + name2.slice(5);
  } else if (name2 === "fixed") {
    return "fixed128x128";
  } else if (name2.startsWith("ufixed[")) {
    return "ufixed128x128" + name2.slice(6);
  } else if (name2 === "ufixed") {
    return "ufixed128x128";
  }
  return name2;
}
function parseTypeN(type2) {
  return parseInt(/^\D+(\d+)$/.exec(type2)[1], 10);
}
function parseTypeNxM(type2) {
  var tmp = /^\D+(\d+)x(\d+)$/.exec(type2);
  return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
}
function parseTypeArray(type2) {
  var tmp = type2.match(/(.*)\[(.*?)\]$/);
  if (tmp) {
    return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
  }
  return null;
}
function parseNumber(arg) {
  var type2 = typeof arg;
  if (type2 === "string") {
    if (util$6.isHexString(arg)) {
      return new BN(util$6.stripHexPrefix(arg), 16);
    } else {
      return new BN(arg, 10);
    }
  } else if (type2 === "number") {
    return new BN(arg);
  } else if (arg.toArray) {
    return arg;
  } else {
    throw new Error("Argument is not a number");
  }
}
function encodeSingle(type2, arg) {
  var size2, num, ret, i3;
  if (type2 === "address") {
    return encodeSingle("uint160", parseNumber(arg));
  } else if (type2 === "bool") {
    return encodeSingle("uint8", arg ? 1 : 0);
  } else if (type2 === "string") {
    return encodeSingle("bytes", new buffer$4.Buffer(arg, "utf8"));
  } else if (isArray$2(type2)) {
    if (typeof arg.length === "undefined") {
      throw new Error("Not an array?");
    }
    size2 = parseTypeArray(type2);
    if (size2 !== "dynamic" && size2 !== 0 && arg.length > size2) {
      throw new Error("Elements exceed array size: " + size2);
    }
    ret = [];
    type2 = type2.slice(0, type2.lastIndexOf("["));
    if (typeof arg === "string") {
      arg = JSON.parse(arg);
    }
    for (i3 in arg) {
      ret.push(encodeSingle(type2, arg[i3]));
    }
    if (size2 === "dynamic") {
      var length2 = encodeSingle("uint256", arg.length);
      ret.unshift(length2);
    }
    return buffer$4.Buffer.concat(ret);
  } else if (type2 === "bytes") {
    arg = new buffer$4.Buffer(arg);
    ret = buffer$4.Buffer.concat([encodeSingle("uint256", arg.length), arg]);
    if (arg.length % 32 !== 0) {
      ret = buffer$4.Buffer.concat([ret, util$6.zeros(32 - arg.length % 32)]);
    }
    return ret;
  } else if (type2.startsWith("bytes")) {
    size2 = parseTypeN(type2);
    if (size2 < 1 || size2 > 32) {
      throw new Error("Invalid bytes<N> width: " + size2);
    }
    return util$6.setLengthRight(arg, 32);
  } else if (type2.startsWith("uint")) {
    size2 = parseTypeN(type2);
    if (size2 % 8 || size2 < 8 || size2 > 256) {
      throw new Error("Invalid uint<N> width: " + size2);
    }
    num = parseNumber(arg);
    if (num.bitLength() > size2) {
      throw new Error("Supplied uint exceeds width: " + size2 + " vs " + num.bitLength());
    }
    if (num < 0) {
      throw new Error("Supplied uint is negative");
    }
    return num.toArrayLike(buffer$4.Buffer, "be", 32);
  } else if (type2.startsWith("int")) {
    size2 = parseTypeN(type2);
    if (size2 % 8 || size2 < 8 || size2 > 256) {
      throw new Error("Invalid int<N> width: " + size2);
    }
    num = parseNumber(arg);
    if (num.bitLength() > size2) {
      throw new Error("Supplied int exceeds width: " + size2 + " vs " + num.bitLength());
    }
    return num.toTwos(256).toArrayLike(buffer$4.Buffer, "be", 32);
  } else if (type2.startsWith("ufixed")) {
    size2 = parseTypeNxM(type2);
    num = parseNumber(arg);
    if (num < 0) {
      throw new Error("Supplied ufixed is negative");
    }
    return encodeSingle("uint256", num.mul(new BN(2).pow(new BN(size2[1]))));
  } else if (type2.startsWith("fixed")) {
    size2 = parseTypeNxM(type2);
    return encodeSingle("int256", parseNumber(arg).mul(new BN(2).pow(new BN(size2[1]))));
  }
  throw new Error("Unsupported or invalid type: " + type2);
}
function isDynamic(type2) {
  return type2 === "string" || type2 === "bytes" || parseTypeArray(type2) === "dynamic";
}
function isArray$2(type2) {
  return type2.lastIndexOf("]") === type2.length - 1;
}
function rawEncode(types2, values) {
  var output = [];
  var data2 = [];
  var headLength = 32 * types2.length;
  for (var i3 in types2) {
    var type2 = elementaryName(types2[i3]);
    var value = values[i3];
    var cur = encodeSingle(type2, value);
    if (isDynamic(type2)) {
      output.push(encodeSingle("uint256", headLength));
      data2.push(cur);
      headLength += cur.length;
    } else {
      output.push(cur);
    }
  }
  return buffer$4.Buffer.concat(output.concat(data2));
}
function solidityPack(types2, values) {
  if (types2.length !== values.length) {
    throw new Error("Number of types are not matching the values");
  }
  var size2, num;
  var ret = [];
  for (var i3 = 0; i3 < types2.length; i3++) {
    var type2 = elementaryName(types2[i3]);
    var value = values[i3];
    if (type2 === "bytes") {
      ret.push(value);
    } else if (type2 === "string") {
      ret.push(new buffer$4.Buffer(value, "utf8"));
    } else if (type2 === "bool") {
      ret.push(new buffer$4.Buffer(value ? "01" : "00", "hex"));
    } else if (type2 === "address") {
      ret.push(util$6.setLength(value, 20));
    } else if (type2.startsWith("bytes")) {
      size2 = parseTypeN(type2);
      if (size2 < 1 || size2 > 32) {
        throw new Error("Invalid bytes<N> width: " + size2);
      }
      ret.push(util$6.setLengthRight(value, size2));
    } else if (type2.startsWith("uint")) {
      size2 = parseTypeN(type2);
      if (size2 % 8 || size2 < 8 || size2 > 256) {
        throw new Error("Invalid uint<N> width: " + size2);
      }
      num = parseNumber(value);
      if (num.bitLength() > size2) {
        throw new Error("Supplied uint exceeds width: " + size2 + " vs " + num.bitLength());
      }
      ret.push(num.toArrayLike(buffer$4.Buffer, "be", size2 / 8));
    } else if (type2.startsWith("int")) {
      size2 = parseTypeN(type2);
      if (size2 % 8 || size2 < 8 || size2 > 256) {
        throw new Error("Invalid int<N> width: " + size2);
      }
      num = parseNumber(value);
      if (num.bitLength() > size2) {
        throw new Error("Supplied int exceeds width: " + size2 + " vs " + num.bitLength());
      }
      ret.push(num.toTwos(size2).toArrayLike(buffer$4.Buffer, "be", size2 / 8));
    } else {
      throw new Error("Unsupported or invalid type: " + type2);
    }
  }
  return buffer$4.Buffer.concat(ret);
}
function soliditySHA3(types2, values) {
  return util$6.keccak(solidityPack(types2, values));
}
var abi$1 = {
  rawEncode,
  solidityPack,
  soliditySHA3
};
const abi$2 = /* @__PURE__ */ getDefaultExportFromCjs(abi$1);
const abi$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: abi$2
}, [abi$1]);
const require$$1$r = /* @__PURE__ */ getAugmentedNamespace(abi$3);
const util$5 = require$$0$K;
const abi = require$$1$r;
const TYPED_MESSAGE_SCHEMA = {
  type: "object",
  properties: {
    types: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: {
          type: "object",
          properties: {
            name: { type: "string" },
            type: { type: "string" }
          },
          required: ["name", "type"]
        }
      }
    },
    primaryType: { type: "string" },
    domain: { type: "object" },
    message: { type: "object" }
  },
  required: ["types", "primaryType", "domain", "message"]
};
const TypedDataUtils = {
  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData(primaryType, data2, types2, useV4 = true) {
    const encodedTypes = ["bytes32"];
    const encodedValues = [this.hashType(primaryType, types2)];
    if (useV4) {
      const encodeField = (name2, type2, value) => {
        if (types2[type2] !== void 0) {
          return ["bytes32", value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util$5.keccak(this.encodeData(type2, value, types2, useV4))];
        }
        if (value === void 0)
          throw new Error(`missing value for field ${name2} of type ${type2}`);
        if (type2 === "bytes") {
          return ["bytes32", util$5.keccak(value)];
        }
        if (type2 === "string") {
          if (typeof value === "string") {
            value = buffer$4.Buffer.from(value, "utf8");
          }
          return ["bytes32", util$5.keccak(value)];
        }
        if (type2.lastIndexOf("]") === type2.length - 1) {
          const parsedType = type2.slice(0, type2.lastIndexOf("["));
          const typeValuePairs = value.map((item) => encodeField(name2, parsedType, item));
          return ["bytes32", util$5.keccak(abi.rawEncode(
            typeValuePairs.map(([type3]) => type3),
            typeValuePairs.map(([, value2]) => value2)
          ))];
        }
        return [type2, value];
      };
      for (const field of types2[primaryType]) {
        const [type2, value] = encodeField(field.name, field.type, data2[field.name]);
        encodedTypes.push(type2);
        encodedValues.push(value);
      }
    } else {
      for (const field of types2[primaryType]) {
        let value = data2[field.name];
        if (value !== void 0) {
          if (field.type === "bytes") {
            encodedTypes.push("bytes32");
            value = util$5.keccak(value);
            encodedValues.push(value);
          } else if (field.type === "string") {
            encodedTypes.push("bytes32");
            if (typeof value === "string") {
              value = buffer$4.Buffer.from(value, "utf8");
            }
            value = util$5.keccak(value);
            encodedValues.push(value);
          } else if (types2[field.type] !== void 0) {
            encodedTypes.push("bytes32");
            value = util$5.keccak(this.encodeData(field.type, value, types2, useV4));
            encodedValues.push(value);
          } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
            throw new Error("Arrays currently unimplemented in encodeData");
          } else {
            encodedTypes.push(field.type);
            encodedValues.push(value);
          }
        }
      }
    }
    return abi.rawEncode(encodedTypes, encodedValues);
  },
  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType(primaryType, types2) {
    let result = "";
    let deps = this.findTypeDependencies(primaryType, types2).filter((dep2) => dep2 !== primaryType);
    deps = [primaryType].concat(deps.sort());
    for (const type2 of deps) {
      const children = types2[type2];
      if (!children) {
        throw new Error("No type definition specified: " + type2);
      }
      result += type2 + "(" + types2[type2].map(({ name: name2, type: type3 }) => type3 + " " + name2).join(",") + ")";
    }
    return result;
  },
  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies(primaryType, types2, results = []) {
    primaryType = primaryType.match(/^\w*/)[0];
    if (results.includes(primaryType) || types2[primaryType] === void 0) {
      return results;
    }
    results.push(primaryType);
    for (const field of types2[primaryType]) {
      for (const dep2 of this.findTypeDependencies(field.type, types2, results)) {
        !results.includes(dep2) && results.push(dep2);
      }
    }
    return results;
  },
  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {Buffer} - Hash of an object
   */
  hashStruct(primaryType, data2, types2, useV4 = true) {
    return util$5.keccak(this.encodeData(primaryType, data2, types2, useV4));
  },
  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType(primaryType, types2) {
    return util$5.keccak(this.encodeType(primaryType, types2));
  },
  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData(data2) {
    const sanitizedData = {};
    for (const key2 in TYPED_MESSAGE_SCHEMA.properties) {
      data2[key2] && (sanitizedData[key2] = data2[key2]);
    }
    if (sanitizedData.types) {
      sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
    }
    return sanitizedData;
  },
  /**
   * Returns the hash of a typed message as per EIP-712 for signing
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - sha3 hash for signing
   */
  hash(typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData);
    const parts = [buffer$4.Buffer.from("1901", "hex")];
    parts.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
    if (sanitizedData.primaryType !== "EIP712Domain") {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
    }
    return util$5.keccak(buffer$4.Buffer.concat(parts));
  }
};
var ethEip712Util = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,
  hashForSignTypedDataLegacy: function(msgParams) {
    return typedSignatureHashLegacy(msgParams.data);
  },
  hashForSignTypedData_v3: function(msgParams) {
    return TypedDataUtils.hash(msgParams.data, false);
  },
  hashForSignTypedData_v4: function(msgParams) {
    return TypedDataUtils.hash(msgParams.data);
  }
};
function typedSignatureHashLegacy(typedData) {
  const error = new Error("Expect argument to be non-empty array");
  if (typeof typedData !== "object" || !typedData.length)
    throw error;
  const data2 = typedData.map(function(e2) {
    return e2.type === "bytes" ? util$5.toBuffer(e2.value) : e2.value;
  });
  const types2 = typedData.map(function(e2) {
    return e2.type;
  });
  const schema = typedData.map(function(e2) {
    if (!e2.name)
      throw error;
    return e2.type + " " + e2.name;
  });
  return abi.soliditySHA3(
    ["bytes32", "bytes32"],
    [
      abi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
      abi.soliditySHA3(types2, data2)
    ]
  );
}
const index$q = /* @__PURE__ */ getDefaultExportFromCjs(ethEip712Util);
const ethEip712Util$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$q
}, [ethEip712Util]);
const require$$9$3 = /* @__PURE__ */ getAugmentedNamespace(ethEip712Util$1);
var FilterPolyfill$2 = {};
Object.defineProperty(FilterPolyfill$2, "__esModule", { value: true });
var filterFromParam_1 = FilterPolyfill$2.filterFromParam = FilterPolyfill_2 = FilterPolyfill$2.FilterPolyfill = void 0;
const types_1$2 = require$$6$a;
const util_1$6 = require$$7$4;
const TIMEOUT = 5 * 60 * 1e3;
const JSONRPC_TEMPLATE = {
  jsonrpc: "2.0",
  id: 0
};
class FilterPolyfill {
  constructor(provider) {
    this.logFilters = /* @__PURE__ */ new Map();
    this.blockFilters = /* @__PURE__ */ new Set();
    this.pendingTransactionFilters = /* @__PURE__ */ new Set();
    this.cursors = /* @__PURE__ */ new Map();
    this.timeouts = /* @__PURE__ */ new Map();
    this.nextFilterId = (0, types_1$2.IntNumber)(1);
    this.provider = provider;
  }
  async newFilter(param) {
    const filter2 = filterFromParam(param);
    const id2 = this.makeFilterId();
    const cursor = await this.setInitialCursorPosition(id2, filter2.fromBlock);
    console.log(`Installing new log filter(${id2}):`, filter2, "initial cursor position:", cursor);
    this.logFilters.set(id2, filter2);
    this.setFilterTimeout(id2);
    return (0, util_1$6.hexStringFromIntNumber)(id2);
  }
  async newBlockFilter() {
    const id2 = this.makeFilterId();
    const cursor = await this.setInitialCursorPosition(id2, "latest");
    console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
    this.blockFilters.add(id2);
    this.setFilterTimeout(id2);
    return (0, util_1$6.hexStringFromIntNumber)(id2);
  }
  async newPendingTransactionFilter() {
    const id2 = this.makeFilterId();
    const cursor = await this.setInitialCursorPosition(id2, "latest");
    console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
    this.pendingTransactionFilters.add(id2);
    this.setFilterTimeout(id2);
    return (0, util_1$6.hexStringFromIntNumber)(id2);
  }
  uninstallFilter(filterId) {
    const id2 = (0, util_1$6.intNumberFromHexString)(filterId);
    console.log(`Uninstalling filter (${id2})`);
    this.deleteFilter(id2);
    return true;
  }
  getFilterChanges(filterId) {
    const id2 = (0, util_1$6.intNumberFromHexString)(filterId);
    if (this.timeouts.has(id2)) {
      this.setFilterTimeout(id2);
    }
    if (this.logFilters.has(id2)) {
      return this.getLogFilterChanges(id2);
    } else if (this.blockFilters.has(id2)) {
      return this.getBlockFilterChanges(id2);
    } else if (this.pendingTransactionFilters.has(id2)) {
      return this.getPendingTransactionFilterChanges(id2);
    }
    return Promise.resolve(filterNotFoundError());
  }
  async getFilterLogs(filterId) {
    const id2 = (0, util_1$6.intNumberFromHexString)(filterId);
    const filter2 = this.logFilters.get(id2);
    if (!filter2) {
      return filterNotFoundError();
    }
    return this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [paramFromFilter(filter2)] }));
  }
  makeFilterId() {
    return (0, types_1$2.IntNumber)(++this.nextFilterId);
  }
  sendAsyncPromise(request) {
    return new Promise((resolve, reject) => {
      this.provider.sendAsync(request, (err, response) => {
        if (err) {
          return reject(err);
        }
        if (Array.isArray(response) || response == null) {
          return reject(new Error(`unexpected response received: ${JSON.stringify(response)}`));
        }
        resolve(response);
      });
    });
  }
  deleteFilter(id2) {
    console.log(`Deleting filter (${id2})`);
    this.logFilters.delete(id2);
    this.blockFilters.delete(id2);
    this.pendingTransactionFilters.delete(id2);
    this.cursors.delete(id2);
    this.timeouts.delete(id2);
  }
  async getLogFilterChanges(id2) {
    const filter2 = this.logFilters.get(id2);
    const cursorPosition = this.cursors.get(id2);
    if (!cursorPosition || !filter2) {
      return filterNotFoundError();
    }
    const currentBlockHeight = await this.getCurrentBlockHeight();
    const toBlock = filter2.toBlock === "latest" ? currentBlockHeight : filter2.toBlock;
    if (cursorPosition > currentBlockHeight) {
      return emptyResult();
    }
    if (cursorPosition > filter2.toBlock) {
      return emptyResult();
    }
    console.log(`Fetching logs from ${cursorPosition} to ${toBlock} for filter ${id2}`);
    const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [
      paramFromFilter(Object.assign(Object.assign({}, filter2), { fromBlock: cursorPosition, toBlock }))
    ] }));
    if (Array.isArray(response.result)) {
      const blocks = response.result.map((log3) => (0, util_1$6.intNumberFromHexString)(log3.blockNumber || "0x0"));
      const highestBlock = Math.max(...blocks);
      if (highestBlock && highestBlock > cursorPosition) {
        const newCursorPosition = (0, types_1$2.IntNumber)(highestBlock + 1);
        console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
        this.cursors.set(id2, newCursorPosition);
      }
    }
    return response;
  }
  async getBlockFilterChanges(id2) {
    const cursorPosition = this.cursors.get(id2);
    if (!cursorPosition) {
      return filterNotFoundError();
    }
    const currentBlockHeight = await this.getCurrentBlockHeight();
    if (cursorPosition > currentBlockHeight) {
      return emptyResult();
    }
    console.log(`Fetching blocks from ${cursorPosition} to ${currentBlockHeight} for filter (${id2})`);
    const blocks = (await Promise.all(
      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
      (0, util_1$6.range)(cursorPosition, currentBlockHeight + 1).map((i3) => this.getBlockHashByNumber((0, types_1$2.IntNumber)(i3)))
    )).filter((hash2) => !!hash2);
    const newCursorPosition = (0, types_1$2.IntNumber)(cursorPosition + blocks.length);
    console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
    this.cursors.set(id2, newCursorPosition);
    return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: blocks });
  }
  async getPendingTransactionFilterChanges(_id) {
    return Promise.resolve(emptyResult());
  }
  async setInitialCursorPosition(id2, startBlock) {
    const currentBlockHeight = await this.getCurrentBlockHeight();
    const initialCursorPosition = typeof startBlock === "number" && startBlock > currentBlockHeight ? startBlock : currentBlockHeight;
    this.cursors.set(id2, initialCursorPosition);
    return initialCursorPosition;
  }
  setFilterTimeout(id2) {
    const existing = this.timeouts.get(id2);
    if (existing) {
      window.clearTimeout(existing);
    }
    const timeout2 = window.setTimeout(() => {
      console.log(`Filter (${id2}) timed out`);
      this.deleteFilter(id2);
    }, TIMEOUT);
    this.timeouts.set(id2, timeout2);
  }
  async getCurrentBlockHeight() {
    const { result } = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_blockNumber", params: [] }));
    return (0, util_1$6.intNumberFromHexString)((0, util_1$6.ensureHexString)(result));
  }
  async getBlockHashByNumber(blockNumber) {
    const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getBlockByNumber", params: [(0, util_1$6.hexStringFromIntNumber)(blockNumber), false] }));
    if (response.result && typeof response.result.hash === "string") {
      return (0, util_1$6.ensureHexString)(response.result.hash);
    }
    return null;
  }
}
var FilterPolyfill_2 = FilterPolyfill$2.FilterPolyfill = FilterPolyfill;
function filterFromParam(param) {
  return {
    fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),
    toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),
    addresses: param.address === void 0 ? null : Array.isArray(param.address) ? param.address : [param.address],
    topics: param.topics || []
  };
}
filterFromParam_1 = FilterPolyfill$2.filterFromParam = filterFromParam;
function paramFromFilter(filter2) {
  const param = {
    fromBlock: hexBlockHeightFromIntBlockHeight(filter2.fromBlock),
    toBlock: hexBlockHeightFromIntBlockHeight(filter2.toBlock),
    topics: filter2.topics
  };
  if (filter2.addresses !== null) {
    param.address = filter2.addresses;
  }
  return param;
}
function intBlockHeightFromHexBlockHeight(value) {
  if (value === void 0 || value === "latest" || value === "pending") {
    return "latest";
  } else if (value === "earliest") {
    return (0, types_1$2.IntNumber)(0);
  } else if ((0, util_1$6.isHexString)(value)) {
    return (0, util_1$6.intNumberFromHexString)(value);
  }
  throw new Error(`Invalid block option: ${String(value)}`);
}
function hexBlockHeightFromIntBlockHeight(value) {
  if (value === "latest") {
    return value;
  }
  return (0, util_1$6.hexStringFromIntNumber)(value);
}
function filterNotFoundError() {
  return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { error: { code: -32e3, message: "filter not found" } });
}
function emptyResult() {
  return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: [] });
}
const FilterPolyfill$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get FilterPolyfill() {
    return FilterPolyfill_2;
  },
  default: FilterPolyfill$2,
  get filterFromParam() {
    return filterFromParam_1;
  }
}, [FilterPolyfill$2]);
const require$$10$3 = /* @__PURE__ */ getAugmentedNamespace(FilterPolyfill$1);
var JSONRPC$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.JSONRPCMethod = void 0;
  (function(JSONRPCMethod) {
    JSONRPCMethod["eth_accounts"] = "eth_accounts";
    JSONRPCMethod["eth_coinbase"] = "eth_coinbase";
    JSONRPCMethod["net_version"] = "net_version";
    JSONRPCMethod["eth_chainId"] = "eth_chainId";
    JSONRPCMethod["eth_uninstallFilter"] = "eth_uninstallFilter";
    JSONRPCMethod["eth_requestAccounts"] = "eth_requestAccounts";
    JSONRPCMethod["eth_sign"] = "eth_sign";
    JSONRPCMethod["eth_ecRecover"] = "eth_ecRecover";
    JSONRPCMethod["personal_sign"] = "personal_sign";
    JSONRPCMethod["personal_ecRecover"] = "personal_ecRecover";
    JSONRPCMethod["eth_signTransaction"] = "eth_signTransaction";
    JSONRPCMethod["eth_sendRawTransaction"] = "eth_sendRawTransaction";
    JSONRPCMethod["eth_sendTransaction"] = "eth_sendTransaction";
    JSONRPCMethod["eth_signTypedData_v1"] = "eth_signTypedData_v1";
    JSONRPCMethod["eth_signTypedData_v2"] = "eth_signTypedData_v2";
    JSONRPCMethod["eth_signTypedData_v3"] = "eth_signTypedData_v3";
    JSONRPCMethod["eth_signTypedData_v4"] = "eth_signTypedData_v4";
    JSONRPCMethod["eth_signTypedData"] = "eth_signTypedData";
    JSONRPCMethod["cbWallet_arbitrary"] = "walletlink_arbitrary";
    JSONRPCMethod["wallet_addEthereumChain"] = "wallet_addEthereumChain";
    JSONRPCMethod["wallet_switchEthereumChain"] = "wallet_switchEthereumChain";
    JSONRPCMethod["wallet_watchAsset"] = "wallet_watchAsset";
    JSONRPCMethod["eth_subscribe"] = "eth_subscribe";
    JSONRPCMethod["eth_unsubscribe"] = "eth_unsubscribe";
    JSONRPCMethod["eth_newFilter"] = "eth_newFilter";
    JSONRPCMethod["eth_newBlockFilter"] = "eth_newBlockFilter";
    JSONRPCMethod["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
    JSONRPCMethod["eth_getFilterChanges"] = "eth_getFilterChanges";
    JSONRPCMethod["eth_getFilterLogs"] = "eth_getFilterLogs";
  })(exports2.JSONRPCMethod || (exports2.JSONRPCMethod = {}));
})(JSONRPC$2);
const JSONRPC = /* @__PURE__ */ getDefaultExportFromCjs(JSONRPC$2);
const JSONRPC$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: JSONRPC
}, [JSONRPC$2]);
const require$$11$3 = /* @__PURE__ */ getAugmentedNamespace(JSONRPC$1);
var SubscriptionManager$2 = {};
var dist$8 = {};
var PollingBlockTracker$2 = {};
var jsonRpcRandomId = IdIterator;
function IdIterator(opts) {
  opts = opts || {};
  var max2 = opts.max || Number.MAX_SAFE_INTEGER;
  var idCounter2 = typeof opts.start !== "undefined" ? opts.start : Math.floor(Math.random() * max2);
  return function createRandomId2() {
    idCounter2 = idCounter2 % max2;
    return idCounter2++;
  };
}
const index$p = /* @__PURE__ */ getDefaultExportFromCjs(jsonRpcRandomId);
const jsonRpcRandomId$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$p
}, [jsonRpcRandomId]);
const require$$1$q = /* @__PURE__ */ getAugmentedNamespace(jsonRpcRandomId$1);
const processFn$1 = (fn2, opts) => function() {
  const P2 = opts.promiseModule;
  const args = new Array(arguments.length);
  for (let i3 = 0; i3 < arguments.length; i3++) {
    args[i3] = arguments[i3];
  }
  return new P2((resolve, reject) => {
    if (opts.errorFirst) {
      args.push(function(err, result) {
        if (opts.multiArgs) {
          const results = new Array(arguments.length - 1);
          for (let i3 = 1; i3 < arguments.length; i3++) {
            results[i3 - 1] = arguments[i3];
          }
          if (err) {
            results.unshift(err);
            reject(results);
          } else {
            resolve(results);
          }
        } else if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    } else {
      args.push(function(result) {
        if (opts.multiArgs) {
          const results = new Array(arguments.length - 1);
          for (let i3 = 0; i3 < arguments.length; i3++) {
            results[i3] = arguments[i3];
          }
          resolve(results);
        } else {
          resolve(result);
        }
      });
    }
    fn2.apply(this, args);
  });
};
var pify$3 = (obj, opts) => {
  opts = Object.assign({
    exclude: [/.+(Sync|Stream)$/],
    errorFirst: true,
    promiseModule: Promise
  }, opts);
  const filter2 = (key2) => {
    const match = (pattern2) => typeof pattern2 === "string" ? key2 === pattern2 : pattern2.test(key2);
    return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
  };
  let ret;
  if (typeof obj === "function") {
    ret = function() {
      if (opts.excludeMain) {
        return obj.apply(this, arguments);
      }
      return processFn$1(obj, opts).apply(this, arguments);
    };
  } else {
    ret = Object.create(Object.getPrototypeOf(obj));
  }
  for (const key2 in obj) {
    const x2 = obj[key2];
    ret[key2] = typeof x2 === "function" && filter2(key2) ? processFn$1(x2, opts) : x2;
  }
  return ret;
};
const index$o = /* @__PURE__ */ getDefaultExportFromCjs(pify$3);
const pify$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$o
}, [pify$3]);
const require$$1$p = /* @__PURE__ */ getAugmentedNamespace(pify$4);
var BaseBlockTracker$2 = {};
var __importDefault$c = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(BaseBlockTracker$2, "__esModule", { value: true });
var BaseBlockTracker_2 = BaseBlockTracker$2.BaseBlockTracker = void 0;
const safe_event_emitter_1$2 = __importDefault$c(require$$0$14);
const sec$1 = 1e3;
const calculateSum = (accumulator, currentValue) => accumulator + currentValue;
const blockTrackerEvents = ["sync", "latest"];
class BaseBlockTracker extends safe_event_emitter_1$2.default {
  constructor(opts) {
    super();
    this._blockResetDuration = opts.blockResetDuration || 20 * sec$1;
    this._currentBlock = null;
    this._isRunning = false;
    this._onNewListener = this._onNewListener.bind(this);
    this._onRemoveListener = this._onRemoveListener.bind(this);
    this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
    this._setupInternalEvents();
  }
  async destroy() {
    this._cancelBlockResetTimeout();
    await this._maybeEnd();
    super.removeAllListeners();
  }
  isRunning() {
    return this._isRunning;
  }
  getCurrentBlock() {
    return this._currentBlock;
  }
  async getLatestBlock() {
    if (this._currentBlock) {
      return this._currentBlock;
    }
    const latestBlock = await new Promise((resolve) => this.once("latest", resolve));
    return latestBlock;
  }
  // dont allow module consumer to remove our internal event listeners
  removeAllListeners(eventName) {
    if (eventName) {
      super.removeAllListeners(eventName);
    } else {
      super.removeAllListeners();
    }
    this._setupInternalEvents();
    this._onRemoveListener();
    return this;
  }
  _setupInternalEvents() {
    this.removeListener("newListener", this._onNewListener);
    this.removeListener("removeListener", this._onRemoveListener);
    this.on("newListener", this._onNewListener);
    this.on("removeListener", this._onRemoveListener);
  }
  _onNewListener(eventName) {
    if (blockTrackerEvents.includes(eventName)) {
      this._maybeStart();
    }
  }
  _onRemoveListener() {
    if (this._getBlockTrackerEventCount() > 0) {
      return;
    }
    this._maybeEnd();
  }
  async _maybeStart() {
    if (this._isRunning) {
      return;
    }
    this._isRunning = true;
    this._cancelBlockResetTimeout();
    await this._start();
    this.emit("_started");
  }
  async _maybeEnd() {
    if (!this._isRunning) {
      return;
    }
    this._isRunning = false;
    this._setupBlockResetTimeout();
    await this._end();
    this.emit("_ended");
  }
  _getBlockTrackerEventCount() {
    return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);
  }
  _newPotentialLatest(newBlock) {
    const currentBlock = this._currentBlock;
    if (currentBlock && hexToInt$4(newBlock) <= hexToInt$4(currentBlock)) {
      return;
    }
    this._setCurrentBlock(newBlock);
  }
  _setCurrentBlock(newBlock) {
    const oldBlock = this._currentBlock;
    this._currentBlock = newBlock;
    this.emit("latest", newBlock);
    this.emit("sync", { oldBlock, newBlock });
  }
  _setupBlockResetTimeout() {
    this._cancelBlockResetTimeout();
    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
    if (this._blockResetTimeout.unref) {
      this._blockResetTimeout.unref();
    }
  }
  _cancelBlockResetTimeout() {
    if (this._blockResetTimeout) {
      clearTimeout(this._blockResetTimeout);
    }
  }
  _resetCurrentBlock() {
    this._currentBlock = null;
  }
}
BaseBlockTracker_2 = BaseBlockTracker$2.BaseBlockTracker = BaseBlockTracker;
function hexToInt$4(hexInt) {
  return Number.parseInt(hexInt, 16);
}
const BaseBlockTracker$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get BaseBlockTracker() {
    return BaseBlockTracker_2;
  },
  default: BaseBlockTracker$2
}, [BaseBlockTracker$2]);
const require$$1$o = /* @__PURE__ */ getAugmentedNamespace(BaseBlockTracker$1);
var loggingUtils$2 = {};
var dist$7 = {};
var assert$4 = {};
class StructError extends TypeError {
  constructor(failure, failures) {
    let cached;
    const { message, explanation, ...rest } = failure;
    const { path } = failure;
    const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
    super(explanation ?? msg);
    if (explanation != null)
      this.cause = msg;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      return cached ?? (cached = [failure, ...failures()]);
    };
  }
}
function isIterable$3(x2) {
  return isObject$2(x2) && typeof x2[Symbol.iterator] === "function";
}
function isObject$2(x2) {
  return typeof x2 === "object" && x2 != null;
}
function isPlainObject(x2) {
  if (Object.prototype.toString.call(x2) !== "[object Object]") {
    return false;
  }
  const prototype2 = Object.getPrototypeOf(x2);
  return prototype2 === null || prototype2 === Object.prototype;
}
function print$1(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
  const { done: done2, value } = input.next();
  return done2 ? void 0 : value;
}
function toFailure(result, context, struct2, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type: type2 } = struct2;
  const { refinement, message = `Expected a value of type \`${type2}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print$1(value)}\`` } = result;
  return {
    value,
    type: type2,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct2, value) {
  if (!isIterable$3(result)) {
    result = [result];
  }
  for (const r2 of result) {
    const failure = toFailure(r2, context, struct2, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct2, options = {}) {
  const { path = [], branch = [value], coerce: coerce2 = false, mask: mask2 = false } = options;
  const ctx = { path, branch };
  if (coerce2) {
    value = struct2.coercer(value, ctx);
    if (mask2 && struct2.type !== "type" && isObject$2(struct2.schema) && isObject$2(value) && !Array.isArray(value)) {
      for (const key2 in value) {
        if (struct2.schema[key2] === void 0) {
          delete value[key2];
        }
      }
    }
  }
  let status = "valid";
  for (const failure of struct2.validator(value, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, void 0];
  }
  for (let [k3, v4, s3] of struct2.entries(value, ctx)) {
    const ts2 = run(v4, s3, {
      path: k3 === void 0 ? path : [...path, k3],
      branch: k3 === void 0 ? branch : [...branch, v4],
      coerce: coerce2,
      mask: mask2,
      message: options.message
    });
    for (const t2 of ts2) {
      if (t2[0]) {
        status = t2[0].refinement != null ? "not_refined" : "not_valid";
        yield [t2[0], void 0];
      } else if (coerce2) {
        v4 = t2[1];
        if (k3 === void 0) {
          value = v4;
        } else if (value instanceof Map) {
          value.set(k3, v4);
        } else if (value instanceof Set) {
          value.add(v4);
        } else if (isObject$2(value)) {
          if (v4 !== void 0 || k3 in value)
            value[k3] = v4;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct2.refiner(value, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, void 0];
    }
  }
  if (status === "valid") {
    yield [void 0, value];
  }
}
class Struct {
  constructor(props) {
    const { type: type2, schema, validator, refiner, coercer = (value) => value, entries: entries2 = function* () {
    } } = props;
    this.type = type2;
    this.schema = schema;
    this.entries = entries2;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(value, message) {
    return assert$3(value, this, message);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(value, message) {
    return create$5(value, this, message);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(value) {
    return is$1(value, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(value, message) {
    return mask(value, this, message);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(value, options = {}) {
    return validate$1(value, this, options);
  }
}
function assert$3(value, struct2, message) {
  const result = validate$1(value, struct2, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create$5(value, struct2, message) {
  const result = validate$1(value, struct2, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct2, message) {
  const result = validate$1(value, struct2, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is$1(value, struct2) {
  const result = validate$1(value, struct2);
  return !result[0];
}
function validate$1(value, struct2, options = {}) {
  const tuples = run(value, struct2, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t2 of tuples) {
        if (t2[0]) {
          yield t2[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v4 = tuple2[1];
    return [void 0, v4];
  }
}
function assign$2(...Structs) {
  const isType = Structs[0].type === "type";
  const schemas = Structs.map((s3) => s3.schema);
  const schema = Object.assign({}, ...schemas);
  return isType ? type(schema) : object(schema);
}
function define(name2, validator) {
  return new Struct({ type: name2, schema: null, validator });
}
function deprecated(struct2, log3) {
  return new Struct({
    ...struct2,
    refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx),
    validator(value, ctx) {
      if (value === void 0) {
        return true;
      } else {
        log3(value, ctx);
        return struct2.validator(value, ctx);
      }
    }
  });
}
function dynamic(fn2) {
  return new Struct({
    type: "dynamic",
    schema: null,
    *entries(value, ctx) {
      const struct2 = fn2(value, ctx);
      yield* struct2.entries(value, ctx);
    },
    validator(value, ctx) {
      const struct2 = fn2(value, ctx);
      return struct2.validator(value, ctx);
    },
    coercer(value, ctx) {
      const struct2 = fn2(value, ctx);
      return struct2.coercer(value, ctx);
    },
    refiner(value, ctx) {
      const struct2 = fn2(value, ctx);
      return struct2.refiner(value, ctx);
    }
  });
}
function lazy(fn2) {
  let struct2;
  return new Struct({
    type: "lazy",
    schema: null,
    *entries(value, ctx) {
      struct2 ?? (struct2 = fn2());
      yield* struct2.entries(value, ctx);
    },
    validator(value, ctx) {
      struct2 ?? (struct2 = fn2());
      return struct2.validator(value, ctx);
    },
    coercer(value, ctx) {
      struct2 ?? (struct2 = fn2());
      return struct2.coercer(value, ctx);
    },
    refiner(value, ctx) {
      struct2 ?? (struct2 = fn2());
      return struct2.refiner(value, ctx);
    }
  });
}
function omit(struct2, keys2) {
  const { schema } = struct2;
  const subschema = { ...schema };
  for (const key2 of keys2) {
    delete subschema[key2];
  }
  switch (struct2.type) {
    case "type":
      return type(subschema);
    default:
      return object(subschema);
  }
}
function partial(struct2) {
  const schema = struct2 instanceof Struct ? { ...struct2.schema } : { ...struct2 };
  for (const key2 in schema) {
    schema[key2] = optional(schema[key2]);
  }
  return object(schema);
}
function pick(struct2, keys2) {
  const { schema } = struct2;
  const subschema = {};
  for (const key2 of keys2) {
    subschema[key2] = schema[key2];
  }
  return object(subschema);
}
function struct(name2, validator) {
  console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`.");
  return define(name2, validator);
}
function any() {
  return define("any", () => true);
}
function array(Element2) {
  return new Struct({
    type: "array",
    schema: Element2,
    *entries(value) {
      if (Element2 && Array.isArray(value)) {
        for (const [i3, v4] of value.entries()) {
          yield [i3, v4, Element2];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print$1(value)}`;
    }
  });
}
function bigint() {
  return define("bigint", (value) => {
    return typeof value === "bigint";
  });
}
function boolean() {
  return define("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function date() {
  return define("date", (value) => {
    return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print$1(value)}`;
  });
}
function enums(values) {
  const schema = {};
  const description = values.map((v4) => print$1(v4)).join();
  for (const key2 of values) {
    schema[key2] = key2;
  }
  return new Struct({
    type: "enums",
    schema,
    validator(value) {
      return values.includes(value) || `Expected one of \`${description}\`, but received: ${print$1(value)}`;
    }
  });
}
function func() {
  return define("func", (value) => {
    return typeof value === "function" || `Expected a function, but received: ${print$1(value)}`;
  });
}
function instance(Class) {
  return define("instance", (value) => {
    return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print$1(value)}`;
  });
}
function integer() {
  return define("integer", (value) => {
    return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print$1(value)}`;
  });
}
function intersection(Structs) {
  return new Struct({
    type: "intersection",
    schema: null,
    *entries(value, ctx) {
      for (const S3 of Structs) {
        yield* S3.entries(value, ctx);
      }
    },
    *validator(value, ctx) {
      for (const S3 of Structs) {
        yield* S3.validator(value, ctx);
      }
    },
    *refiner(value, ctx) {
      for (const S3 of Structs) {
        yield* S3.refiner(value, ctx);
      }
    }
  });
}
function literal(constant) {
  const description = print$1(constant);
  const t2 = typeof constant;
  return new Struct({
    type: "literal",
    schema: t2 === "string" || t2 === "number" || t2 === "boolean" ? constant : null,
    validator(value) {
      return value === constant || `Expected the literal \`${description}\`, but received: ${print$1(value)}`;
    }
  });
}
function map$3(Key, Value) {
  return new Struct({
    type: "map",
    schema: null,
    *entries(value) {
      if (Key && Value && value instanceof Map) {
        for (const [k3, v4] of value.entries()) {
          yield [k3, k3, Key];
          yield [k3, v4, Value];
        }
      }
    },
    coercer(value) {
      return value instanceof Map ? new Map(value) : value;
    },
    validator(value) {
      return value instanceof Map || `Expected a \`Map\` object, but received: ${print$1(value)}`;
    }
  });
}
function never$1() {
  return define("never", () => false);
}
function nullable(struct2) {
  return new Struct({
    ...struct2,
    validator: (value, ctx) => value === null || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct2.refiner(value, ctx)
  });
}
function number$2() {
  return define("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print$1(value)}`;
  });
}
function object(schema) {
  const knowns = schema ? Object.keys(schema) : [];
  const Never = never$1();
  return new Struct({
    type: "object",
    schema: schema ? schema : null,
    *entries(value) {
      if (schema && isObject$2(value)) {
        const unknowns = new Set(Object.keys(value));
        for (const key2 of knowns) {
          unknowns.delete(key2);
          yield [key2, value[key2], schema[key2]];
        }
        for (const key2 of unknowns) {
          yield [key2, value[key2], Never];
        }
      }
    },
    validator(value) {
      return isObject$2(value) || `Expected an object, but received: ${print$1(value)}`;
    },
    coercer(value) {
      return isObject$2(value) ? { ...value } : value;
    }
  });
}
function optional(struct2) {
  return new Struct({
    ...struct2,
    validator: (value, ctx) => value === void 0 || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx)
  });
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject$2(value)) {
        for (const k3 in value) {
          const v4 = value[k3];
          yield [k3, k3, Key];
          yield [k3, v4, Value];
        }
      }
    },
    validator(value) {
      return isObject$2(value) || `Expected an object, but received: ${print$1(value)}`;
    }
  });
}
function regexp() {
  return define("regexp", (value) => {
    return value instanceof RegExp;
  });
}
function set(Element2) {
  return new Struct({
    type: "set",
    schema: null,
    *entries(value) {
      if (Element2 && value instanceof Set) {
        for (const v4 of value) {
          yield [v4, v4, Element2];
        }
      }
    },
    coercer(value) {
      return value instanceof Set ? new Set(value) : value;
    },
    validator(value) {
      return value instanceof Set || `Expected a \`Set\` object, but received: ${print$1(value)}`;
    }
  });
}
function string() {
  return define("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print$1(value)}`;
  });
}
function tuple(Structs) {
  const Never = never$1();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length2 = Math.max(Structs.length, value.length);
        for (let i3 = 0; i3 < length2; i3++) {
          yield [i3, value[i3], Structs[i3] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array, but received: ${print$1(value)}`;
    }
  });
}
function type(schema) {
  const keys2 = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject$2(value)) {
        for (const k3 of keys2) {
          yield [k3, value[k3], schema[k3]];
        }
      }
    },
    validator(value) {
      return isObject$2(value) || `Expected an object, but received: ${print$1(value)}`;
    },
    coercer(value) {
      return isObject$2(value) ? { ...value } : value;
    }
  });
}
function union(Structs) {
  const description = Structs.map((s3) => s3.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    coercer(value) {
      for (const S3 of Structs) {
        const [error, coerced] = S3.validate(value, { coerce: true });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const S3 of Structs) {
        const [...tuples] = run(value, S3, ctx);
        const [first2] = tuples;
        if (!first2[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print$1(value)}`,
        ...failures
      ];
    }
  });
}
function unknown() {
  return define("unknown", () => true);
}
function coerce$4(struct2, condition, coercer) {
  return new Struct({
    ...struct2,
    coercer: (value, ctx) => {
      return is$1(value, condition) ? struct2.coercer(coercer(value, ctx), ctx) : struct2.coercer(value, ctx);
    }
  });
}
function defaulted(struct2, fallback, options = {}) {
  return coerce$4(struct2, unknown(), (x2) => {
    const f4 = typeof fallback === "function" ? fallback() : fallback;
    if (x2 === void 0) {
      return f4;
    }
    if (!options.strict && isPlainObject(x2) && isPlainObject(f4)) {
      const ret = { ...x2 };
      let changed = false;
      for (const key2 in f4) {
        if (ret[key2] === void 0) {
          ret[key2] = f4[key2];
          changed = true;
        }
      }
      if (changed) {
        return ret;
      }
    }
    return x2;
  });
}
function trimmed(struct2) {
  return coerce$4(struct2, string(), (x2) => x2.trim());
}
function empty$2(struct2) {
  return refine(struct2, "empty", (value) => {
    const size2 = getSize(value);
    return size2 === 0 || `Expected an empty ${struct2.type} but received one with a size of \`${size2}\``;
  });
}
function getSize(value) {
  if (value instanceof Map || value instanceof Set) {
    return value.size;
  } else {
    return value.length;
  }
}
function max$1(struct2, threshold, options = {}) {
  const { exclusive } = options;
  return refine(struct2, "max", (value) => {
    return exclusive ? value < threshold : value <= threshold || `Expected a ${struct2.type} less than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
  });
}
function min$1(struct2, threshold, options = {}) {
  const { exclusive } = options;
  return refine(struct2, "min", (value) => {
    return exclusive ? value > threshold : value >= threshold || `Expected a ${struct2.type} greater than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
  });
}
function nonempty(struct2) {
  return refine(struct2, "nonempty", (value) => {
    const size2 = getSize(value);
    return size2 > 0 || `Expected a nonempty ${struct2.type} but received an empty one`;
  });
}
function pattern(struct2, regexp2) {
  return refine(struct2, "pattern", (value) => {
    return regexp2.test(value) || `Expected a ${struct2.type} matching \`/${regexp2.source}/\` but received "${value}"`;
  });
}
function size(struct2, min2, max2 = min2) {
  const expected = `Expected a ${struct2.type}`;
  const of2 = min2 === max2 ? `of \`${min2}\`` : `between \`${min2}\` and \`${max2}\``;
  return refine(struct2, "size", (value) => {
    if (typeof value === "number" || value instanceof Date) {
      return min2 <= value && value <= max2 || `${expected} ${of2} but received \`${value}\``;
    } else if (value instanceof Map || value instanceof Set) {
      const { size: size2 } = value;
      return min2 <= size2 && size2 <= max2 || `${expected} with a size ${of2} but received one with a size of \`${size2}\``;
    } else {
      const { length: length2 } = value;
      return min2 <= length2 && length2 <= max2 || `${expected} with a length ${of2} but received one with a length of \`${length2}\``;
    }
  });
}
function refine(struct2, name2, refiner) {
  return new Struct({
    ...struct2,
    *refiner(value, ctx) {
      yield* struct2.refiner(value, ctx);
      const result = refiner(value, ctx);
      const failures = toFailures(result, ctx, struct2, value);
      for (const failure of failures) {
        yield { ...failure, refinement: name2 };
      }
    }
  });
}
const dist$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct,
  StructError,
  any,
  array,
  assert: assert$3,
  assign: assign$2,
  bigint,
  boolean,
  coerce: coerce$4,
  create: create$5,
  date,
  defaulted,
  define,
  deprecated,
  dynamic,
  empty: empty$2,
  enums,
  func,
  instance,
  integer,
  intersection,
  is: is$1,
  lazy,
  literal,
  map: map$3,
  mask,
  max: max$1,
  min: min$1,
  never: never$1,
  nonempty,
  nullable,
  number: number$2,
  object,
  omit,
  optional,
  partial,
  pattern,
  pick,
  record,
  refine,
  regexp,
  set,
  size,
  string,
  struct,
  trimmed,
  tuple,
  type,
  union,
  unknown,
  validate: validate$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$n = /* @__PURE__ */ getAugmentedNamespace(dist$6);
Object.defineProperty(assert$4, "__esModule", { value: true });
var assertExhaustive_1 = assert$4.assertExhaustive = assertStruct_1 = assert$4.assertStruct = assert_2 = assert$4.assert = AssertionError_1 = assert$4.AssertionError = void 0;
const superstruct_1$3 = require$$1$n;
function isErrorWithMessage(error) {
  return typeof error === "object" && error !== null && "message" in error;
}
function isConstructable(fn2) {
  var _a2, _b;
  return Boolean(typeof ((_b = (_a2 = fn2 === null || fn2 === void 0 ? void 0 : fn2.prototype) === null || _a2 === void 0 ? void 0 : _a2.constructor) === null || _b === void 0 ? void 0 : _b.name) === "string");
}
function getErrorMessage(error) {
  const message = isErrorWithMessage(error) ? error.message : String(error);
  if (message.endsWith(".")) {
    return message.slice(0, -1);
  }
  return message;
}
function getError(ErrorWrapper, message) {
  if (isConstructable(ErrorWrapper)) {
    return new ErrorWrapper({
      message
    });
  }
  return ErrorWrapper({
    message
  });
}
class AssertionError extends Error {
  constructor(options) {
    super(options.message);
    this.code = "ERR_ASSERTION";
  }
}
var AssertionError_1 = assert$4.AssertionError = AssertionError;
function assert$1(value, message = "Assertion failed.", ErrorWrapper = AssertionError) {
  if (!value) {
    if (message instanceof Error) {
      throw message;
    }
    throw getError(ErrorWrapper, message);
  }
}
var assert_2 = assert$4.assert = assert$1;
function assertStruct(value, struct2, errorPrefix = "Assertion failed", ErrorWrapper = AssertionError) {
  try {
    (0, superstruct_1$3.assert)(value, struct2);
  } catch (error) {
    throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
  }
}
var assertStruct_1 = assert$4.assertStruct = assertStruct;
function assertExhaustive(_object) {
  throw new Error("Invalid branch reached. Should be detected during compilation.");
}
assertExhaustive_1 = assert$4.assertExhaustive = assertExhaustive;
const assert$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get AssertionError() {
    return AssertionError_1;
  },
  get assert() {
    return assert_2;
  },
  get assertExhaustive() {
    return assertExhaustive_1;
  },
  get assertStruct() {
    return assertStruct_1;
  },
  default: assert$4
}, [assert$4]);
const require$$0$J = /* @__PURE__ */ getAugmentedNamespace(assert$2);
var base64$5 = {};
Object.defineProperty(base64$5, "__esModule", { value: true });
var base64_2 = base64$5.base64 = void 0;
const superstruct_1$2 = require$$1$n;
const assert_1$3 = require$$0$J;
const base64$3 = (struct2, options = {}) => {
  var _a2, _b;
  const paddingRequired = (_a2 = options.paddingRequired) !== null && _a2 !== void 0 ? _a2 : false;
  const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : "base64";
  let letters;
  if (characterSet === "base64") {
    letters = String.raw`[A-Za-z0-9+\/]`;
  } else {
    (0, assert_1$3.assert)(characterSet === "base64url");
    letters = String.raw`[-_A-Za-z0-9]`;
  }
  let re2;
  if (paddingRequired) {
    re2 = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, "u");
  } else {
    re2 = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, "u");
  }
  return (0, superstruct_1$2.pattern)(struct2, re2);
};
base64_2 = base64$5.base64 = base64$3;
const base64$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get base64() {
    return base64_2;
  },
  default: base64$5
}, [base64$5]);
const require$$1$m = /* @__PURE__ */ getAugmentedNamespace(base64$4);
var bytes$1 = {};
var hex$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.remove0x = exports2.add0x = exports2.assertIsStrictHexString = exports2.assertIsHexString = exports2.isStrictHexString = exports2.isHexString = exports2.StrictHexStruct = exports2.HexStruct = void 0;
  const superstruct_12 = require$$1$n;
  const assert_12 = require$$0$J;
  exports2.HexStruct = (0, superstruct_12.pattern)((0, superstruct_12.string)(), /^(?:0x)?[0-9a-f]+$/iu);
  exports2.StrictHexStruct = (0, superstruct_12.pattern)((0, superstruct_12.string)(), /^0x[0-9a-f]+$/iu);
  function isHexString2(value) {
    return (0, superstruct_12.is)(value, exports2.HexStruct);
  }
  exports2.isHexString = isHexString2;
  function isStrictHexString(value) {
    return (0, superstruct_12.is)(value, exports2.StrictHexStruct);
  }
  exports2.isStrictHexString = isStrictHexString;
  function assertIsHexString(value) {
    (0, assert_12.assert)(isHexString2(value), "Value must be a hexadecimal string.");
  }
  exports2.assertIsHexString = assertIsHexString;
  function assertIsStrictHexString(value) {
    (0, assert_12.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
  }
  exports2.assertIsStrictHexString = assertIsStrictHexString;
  function add0x(hexadecimal) {
    if (hexadecimal.startsWith("0x")) {
      return hexadecimal;
    }
    if (hexadecimal.startsWith("0X")) {
      return `0x${hexadecimal.substring(2)}`;
    }
    return `0x${hexadecimal}`;
  }
  exports2.add0x = add0x;
  function remove0x(hexadecimal) {
    if (hexadecimal.startsWith("0x") || hexadecimal.startsWith("0X")) {
      return hexadecimal.substring(2);
    }
    return hexadecimal;
  }
  exports2.remove0x = remove0x;
})(hex$2);
const hex = /* @__PURE__ */ getDefaultExportFromCjs(hex$2);
const hex$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: hex
}, [hex$2]);
const require$$6$7 = /* @__PURE__ */ getAugmentedNamespace(hex$1);
Object.defineProperty(bytes$1, "__esModule", { value: true });
var createDataView_1 = bytes$1.createDataView = concatBytes_1 = bytes$1.concatBytes = valueToBytes_1 = bytes$1.valueToBytes = stringToBytes_1 = bytes$1.stringToBytes = numberToBytes_1 = bytes$1.numberToBytes = signedBigIntToBytes_1 = bytes$1.signedBigIntToBytes = bigIntToBytes_1 = bytes$1.bigIntToBytes = hexToBytes_1 = bytes$1.hexToBytes = bytesToString_1 = bytes$1.bytesToString = bytesToNumber_1 = bytes$1.bytesToNumber = bytesToSignedBigInt_1 = bytes$1.bytesToSignedBigInt = bytesToBigInt_1 = bytes$1.bytesToBigInt = bytesToHex_1 = bytes$1.bytesToHex = assertIsBytes_1 = bytes$1.assertIsBytes = isBytes_1 = bytes$1.isBytes = void 0;
const assert_1$2 = require$$0$J;
const hex_1$2 = require$$6$7;
const HEX_MINIMUM_NUMBER_CHARACTER = 48;
const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
const HEX_CHARACTER_OFFSET = 87;
function getPrecomputedHexValuesBuilder() {
  const lookupTable = [];
  return () => {
    if (lookupTable.length === 0) {
      for (let i3 = 0; i3 < 256; i3++) {
        lookupTable.push(i3.toString(16).padStart(2, "0"));
      }
    }
    return lookupTable;
  };
}
const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
function isBytes$2(value) {
  return value instanceof Uint8Array;
}
var isBytes_1 = bytes$1.isBytes = isBytes$2;
function assertIsBytes(value) {
  (0, assert_1$2.assert)(isBytes$2(value), "Value must be a Uint8Array.");
}
var assertIsBytes_1 = bytes$1.assertIsBytes = assertIsBytes;
function bytesToHex(bytes2) {
  assertIsBytes(bytes2);
  if (bytes2.length === 0) {
    return "0x";
  }
  const lookupTable = getPrecomputedHexValues();
  const hexadecimal = new Array(bytes2.length);
  for (let i3 = 0; i3 < bytes2.length; i3++) {
    hexadecimal[i3] = lookupTable[bytes2[i3]];
  }
  return (0, hex_1$2.add0x)(hexadecimal.join(""));
}
var bytesToHex_1 = bytes$1.bytesToHex = bytesToHex;
function bytesToBigInt(bytes2) {
  assertIsBytes(bytes2);
  const hexadecimal = bytesToHex(bytes2);
  return BigInt(hexadecimal);
}
var bytesToBigInt_1 = bytes$1.bytesToBigInt = bytesToBigInt;
function bytesToSignedBigInt(bytes2) {
  assertIsBytes(bytes2);
  let value = BigInt(0);
  for (const byte2 of bytes2) {
    value = (value << BigInt(8)) + BigInt(byte2);
  }
  return BigInt.asIntN(bytes2.length * 8, value);
}
var bytesToSignedBigInt_1 = bytes$1.bytesToSignedBigInt = bytesToSignedBigInt;
function bytesToNumber(bytes2) {
  assertIsBytes(bytes2);
  const bigint2 = bytesToBigInt(bytes2);
  (0, assert_1$2.assert)(bigint2 <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead.");
  return Number(bigint2);
}
var bytesToNumber_1 = bytes$1.bytesToNumber = bytesToNumber;
function bytesToString(bytes2) {
  assertIsBytes(bytes2);
  return new TextDecoder().decode(bytes2);
}
var bytesToString_1 = bytes$1.bytesToString = bytesToString;
function hexToBytes(value) {
  var _a2;
  if (((_a2 = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a2 === void 0 ? void 0 : _a2.call(value)) === "0x") {
    return new Uint8Array();
  }
  (0, hex_1$2.assertIsHexString)(value);
  const strippedValue = (0, hex_1$2.remove0x)(value).toLowerCase();
  const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
  const bytes2 = new Uint8Array(normalizedValue.length / 2);
  for (let i3 = 0; i3 < bytes2.length; i3++) {
    const c1 = normalizedValue.charCodeAt(i3 * 2);
    const c2 = normalizedValue.charCodeAt(i3 * 2 + 1);
    const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
    const n22 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
    bytes2[i3] = n1 * 16 + n22;
  }
  return bytes2;
}
var hexToBytes_1 = bytes$1.hexToBytes = hexToBytes;
function bigIntToBytes(value) {
  (0, assert_1$2.assert)(typeof value === "bigint", "Value must be a bigint.");
  (0, assert_1$2.assert)(value >= BigInt(0), "Value must be a non-negative bigint.");
  const hexadecimal = value.toString(16);
  return hexToBytes(hexadecimal);
}
var bigIntToBytes_1 = bytes$1.bigIntToBytes = bigIntToBytes;
function bigIntFits(value, bytes2) {
  (0, assert_1$2.assert)(bytes2 > 0);
  const mask2 = value >> BigInt(31);
  return !((~value & mask2) + (value & ~mask2) >> BigInt(bytes2 * 8 + ~0));
}
function signedBigIntToBytes(value, byteLength2) {
  (0, assert_1$2.assert)(typeof value === "bigint", "Value must be a bigint.");
  (0, assert_1$2.assert)(typeof byteLength2 === "number", "Byte length must be a number.");
  (0, assert_1$2.assert)(byteLength2 > 0, "Byte length must be greater than 0.");
  (0, assert_1$2.assert)(bigIntFits(value, byteLength2), "Byte length is too small to represent the given value.");
  let numberValue = value;
  const bytes2 = new Uint8Array(byteLength2);
  for (let i3 = 0; i3 < bytes2.length; i3++) {
    bytes2[i3] = Number(BigInt.asUintN(8, numberValue));
    numberValue >>= BigInt(8);
  }
  return bytes2.reverse();
}
var signedBigIntToBytes_1 = bytes$1.signedBigIntToBytes = signedBigIntToBytes;
function numberToBytes(value) {
  (0, assert_1$2.assert)(typeof value === "number", "Value must be a number.");
  (0, assert_1$2.assert)(value >= 0, "Value must be a non-negative number.");
  (0, assert_1$2.assert)(Number.isSafeInteger(value), "Value is not a safe integer. Use `bigIntToBytes` instead.");
  const hexadecimal = value.toString(16);
  return hexToBytes(hexadecimal);
}
var numberToBytes_1 = bytes$1.numberToBytes = numberToBytes;
function stringToBytes(value) {
  (0, assert_1$2.assert)(typeof value === "string", "Value must be a string.");
  return new TextEncoder().encode(value);
}
var stringToBytes_1 = bytes$1.stringToBytes = stringToBytes;
function valueToBytes(value) {
  if (typeof value === "bigint") {
    return bigIntToBytes(value);
  }
  if (typeof value === "number") {
    return numberToBytes(value);
  }
  if (typeof value === "string") {
    if (value.startsWith("0x")) {
      return hexToBytes(value);
    }
    return stringToBytes(value);
  }
  if (isBytes$2(value)) {
    return value;
  }
  throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
var valueToBytes_1 = bytes$1.valueToBytes = valueToBytes;
function concatBytes(values) {
  const normalizedValues = new Array(values.length);
  let byteLength2 = 0;
  for (let i3 = 0; i3 < values.length; i3++) {
    const value = valueToBytes(values[i3]);
    normalizedValues[i3] = value;
    byteLength2 += value.length;
  }
  const bytes2 = new Uint8Array(byteLength2);
  for (let i3 = 0, offset = 0; i3 < normalizedValues.length; i3++) {
    bytes2.set(normalizedValues[i3], offset);
    offset += normalizedValues[i3].length;
  }
  return bytes2;
}
var concatBytes_1 = bytes$1.concatBytes = concatBytes;
function createDataView(bytes2) {
  if (typeof buffer$7.Buffer !== "undefined" && bytes2 instanceof buffer$7.Buffer) {
    const buffer2 = bytes2.buffer.slice(bytes2.byteOffset, bytes2.byteOffset + bytes2.byteLength);
    return new DataView(buffer2);
  }
  return new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
}
createDataView_1 = bytes$1.createDataView = createDataView;
const bytes = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get assertIsBytes() {
    return assertIsBytes_1;
  },
  get bigIntToBytes() {
    return bigIntToBytes_1;
  },
  get bytesToBigInt() {
    return bytesToBigInt_1;
  },
  get bytesToHex() {
    return bytesToHex_1;
  },
  get bytesToNumber() {
    return bytesToNumber_1;
  },
  get bytesToSignedBigInt() {
    return bytesToSignedBigInt_1;
  },
  get bytesToString() {
    return bytesToString_1;
  },
  get concatBytes() {
    return concatBytes_1;
  },
  get createDataView() {
    return createDataView_1;
  },
  default: bytes$1,
  get hexToBytes() {
    return hexToBytes_1;
  },
  get isBytes() {
    return isBytes_1;
  },
  get numberToBytes() {
    return numberToBytes_1;
  },
  get signedBigIntToBytes() {
    return signedBigIntToBytes_1;
  },
  get stringToBytes() {
    return stringToBytes_1;
  },
  get valueToBytes() {
    return valueToBytes_1;
  }
}, [bytes$1]);
const require$$2$g = /* @__PURE__ */ getAugmentedNamespace(bytes);
var checksum$1 = {};
Object.defineProperty(checksum$1, "__esModule", { value: true });
var ChecksumStruct = checksum$1.ChecksumStruct = void 0;
const superstruct_1$1 = require$$1$n;
const base64_1 = require$$1$m;
ChecksumStruct = checksum$1.ChecksumStruct = (0, superstruct_1$1.size)((0, base64_1.base64)((0, superstruct_1$1.string)(), { paddingRequired: true }), 44, 44);
const checksum = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get ChecksumStruct() {
    return ChecksumStruct;
  },
  default: checksum$1
}, [checksum$1]);
const require$$3$c = /* @__PURE__ */ getAugmentedNamespace(checksum);
var coercers$1 = {};
Object.defineProperty(coercers$1, "__esModule", { value: true });
var createHex_1 = coercers$1.createHex = createBytes_1 = coercers$1.createBytes = createBigInt_1 = coercers$1.createBigInt = createNumber_1 = coercers$1.createNumber = void 0;
const superstruct_1 = require$$1$n;
const assert_1$1 = require$$0$J;
const bytes_1 = require$$2$g;
const hex_1$1 = require$$6$7;
const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1$1.StrictHexStruct]);
const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
(0, superstruct_1.union)([hex_1$1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1$1.StrictHexStruct]), bytes_1.hexToBytes);
const HexCoercer = (0, superstruct_1.coerce)(hex_1$1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
function createNumber(value) {
  try {
    const result = (0, superstruct_1.create)(value, NumberCoercer);
    (0, assert_1$1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
    return result;
  } catch (error) {
    if (error instanceof superstruct_1.StructError) {
      throw new Error(`Expected a number-like value, got "${value}".`);
    }
    throw error;
  }
}
var createNumber_1 = coercers$1.createNumber = createNumber;
function createBigInt(value) {
  try {
    return (0, superstruct_1.create)(value, BigIntCoercer);
  } catch (error) {
    if (error instanceof superstruct_1.StructError) {
      throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
    }
    throw error;
  }
}
var createBigInt_1 = coercers$1.createBigInt = createBigInt;
function createBytes(value) {
  if (typeof value === "string" && value.toLowerCase() === "0x") {
    return new Uint8Array();
  }
  try {
    return (0, superstruct_1.create)(value, BytesCoercer);
  } catch (error) {
    if (error instanceof superstruct_1.StructError) {
      throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
    }
    throw error;
  }
}
var createBytes_1 = coercers$1.createBytes = createBytes;
function createHex(value) {
  if (value instanceof Uint8Array && value.length === 0 || typeof value === "string" && value.toLowerCase() === "0x") {
    return "0x";
  }
  try {
    return (0, superstruct_1.create)(value, HexCoercer);
  } catch (error) {
    if (error instanceof superstruct_1.StructError) {
      throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
    }
    throw error;
  }
}
createHex_1 = coercers$1.createHex = createHex;
const coercers = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createBigInt() {
    return createBigInt_1;
  },
  get createBytes() {
    return createBytes_1;
  },
  get createHex() {
    return createHex_1;
  },
  get createNumber() {
    return createNumber_1;
  },
  default: coercers$1
}, [coercers$1]);
const require$$4$a = /* @__PURE__ */ getAugmentedNamespace(coercers);
var collections$1 = {};
var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state2, value, kind, f4) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f4)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f4 : !state2.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state2.set(receiver, value), value;
};
var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state2, kind, f4) {
  if (kind === "a" && !f4)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f4 : !state2.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state2.get(receiver);
};
var _FrozenMap_map, _FrozenSet_set;
Object.defineProperty(collections$1, "__esModule", { value: true });
var FrozenSet_1 = collections$1.FrozenSet = FrozenMap_1 = collections$1.FrozenMap = void 0;
class FrozenMap {
  constructor(entries2) {
    _FrozenMap_map.set(this, void 0);
    __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries2), "f");
    Object.freeze(this);
  }
  get size() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
  }
  [(_FrozenMap_map = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
  }
  entries() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
  }
  forEach(callbackfn, thisArg) {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key2, _map) => callbackfn.call(thisArg, value, key2, this));
  }
  get(key2) {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key2);
  }
  has(key2) {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key2);
  }
  keys() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
  }
  values() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([key2, value]) => `${String(key2)} => ${String(value)}`).join(", ")} ` : ""}}`;
  }
}
var FrozenMap_1 = collections$1.FrozenMap = FrozenMap;
class FrozenSet {
  constructor(values) {
    _FrozenSet_set.set(this, void 0);
    __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
    Object.freeze(this);
  }
  get size() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
  }
  [(_FrozenSet_set = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
  }
  entries() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
  }
  forEach(callbackfn, thisArg) {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
  }
  has(value) {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
  }
  keys() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
  }
  values() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((member) => String(member)).join(", ")} ` : ""}}`;
  }
}
FrozenSet_1 = collections$1.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);
const collections = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get FrozenMap() {
    return FrozenMap_1;
  },
  get FrozenSet() {
    return FrozenSet_1;
  },
  default: collections$1
}, [collections$1]);
const require$$5$8 = /* @__PURE__ */ getAugmentedNamespace(collections);
var json$2 = {};
var misc$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.calculateNumberSize = exports2.calculateStringSize = exports2.isASCII = exports2.isPlainObject = exports2.ESCAPE_CHARACTERS_REGEXP = exports2.JsonSize = exports2.hasProperty = exports2.isObject = exports2.isNullOrUndefined = exports2.isNonEmptyArray = void 0;
  function isNonEmptyArray2(value) {
    return Array.isArray(value) && value.length > 0;
  }
  exports2.isNonEmptyArray = isNonEmptyArray2;
  function isNullOrUndefined(value) {
    return value === null || value === void 0;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isObject2(value) {
    return Boolean(value) && typeof value === "object" && !Array.isArray(value);
  }
  exports2.isObject = isObject2;
  const hasProperty = (objectToCheck, name2) => Object.hasOwnProperty.call(objectToCheck, name2);
  exports2.hasProperty = hasProperty;
  (function(JsonSize) {
    JsonSize[JsonSize["Null"] = 4] = "Null";
    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    JsonSize[JsonSize["True"] = 4] = "True";
    JsonSize[JsonSize["False"] = 5] = "False";
    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    JsonSize[JsonSize["Date"] = 24] = "Date";
  })(exports2.JsonSize || (exports2.JsonSize = {}));
  exports2.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
  function isPlainObject2(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    try {
      let proto = value;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(value) === proto;
    } catch (_3) {
      return false;
    }
  }
  exports2.isPlainObject = isPlainObject2;
  function isASCII(character) {
    return character.charCodeAt(0) <= 127;
  }
  exports2.isASCII = isASCII;
  function calculateStringSize(value) {
    var _a2;
    const size2 = value.split("").reduce((total, character) => {
      if (isASCII(character)) {
        return total + 1;
      }
      return total + 2;
    }, 0);
    return size2 + ((_a2 = value.match(exports2.ESCAPE_CHARACTERS_REGEXP)) !== null && _a2 !== void 0 ? _a2 : []).length;
  }
  exports2.calculateStringSize = calculateStringSize;
  function calculateNumberSize(value) {
    return value.toString().length;
  }
  exports2.calculateNumberSize = calculateNumberSize;
})(misc$2);
const misc = /* @__PURE__ */ getDefaultExportFromCjs(misc$2);
const misc$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: misc
}, [misc$2]);
const require$$9$2 = /* @__PURE__ */ getAugmentedNamespace(misc$1);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.validateJsonAndGetSize = exports2.getJsonRpcIdValidator = exports2.assertIsJsonRpcError = exports2.isJsonRpcError = exports2.assertIsJsonRpcFailure = exports2.isJsonRpcFailure = exports2.assertIsJsonRpcSuccess = exports2.isJsonRpcSuccess = exports2.assertIsJsonRpcResponse = exports2.isJsonRpcResponse = exports2.assertIsPendingJsonRpcResponse = exports2.isPendingJsonRpcResponse = exports2.JsonRpcResponseStruct = exports2.JsonRpcFailureStruct = exports2.JsonRpcSuccessStruct = exports2.PendingJsonRpcResponseStruct = exports2.assertIsJsonRpcRequest = exports2.isJsonRpcRequest = exports2.assertIsJsonRpcNotification = exports2.isJsonRpcNotification = exports2.JsonRpcNotificationStruct = exports2.JsonRpcRequestStruct = exports2.JsonRpcParamsStruct = exports2.JsonRpcErrorStruct = exports2.JsonRpcIdStruct = exports2.JsonRpcVersionStruct = exports2.jsonrpc2 = exports2.isValidJson = exports2.JsonStruct = void 0;
  const superstruct_12 = require$$1$n;
  const assert_12 = require$$0$J;
  const misc_1 = require$$9$2;
  exports2.JsonStruct = (0, superstruct_12.define)("Json", (value) => {
    const [isValid3] = validateJsonAndGetSize(value, true);
    if (!isValid3) {
      return "Expected a valid JSON-serializable value";
    }
    return true;
  });
  function isValidJson(value) {
    return (0, superstruct_12.is)(value, exports2.JsonStruct);
  }
  exports2.isValidJson = isValidJson;
  exports2.jsonrpc2 = "2.0";
  exports2.JsonRpcVersionStruct = (0, superstruct_12.literal)(exports2.jsonrpc2);
  exports2.JsonRpcIdStruct = (0, superstruct_12.nullable)((0, superstruct_12.union)([(0, superstruct_12.number)(), (0, superstruct_12.string)()]));
  exports2.JsonRpcErrorStruct = (0, superstruct_12.object)({
    code: (0, superstruct_12.integer)(),
    message: (0, superstruct_12.string)(),
    data: (0, superstruct_12.optional)(exports2.JsonStruct),
    stack: (0, superstruct_12.optional)((0, superstruct_12.string)())
  });
  exports2.JsonRpcParamsStruct = (0, superstruct_12.optional)((0, superstruct_12.union)([(0, superstruct_12.record)((0, superstruct_12.string)(), exports2.JsonStruct), (0, superstruct_12.array)(exports2.JsonStruct)]));
  exports2.JsonRpcRequestStruct = (0, superstruct_12.object)({
    id: exports2.JsonRpcIdStruct,
    jsonrpc: exports2.JsonRpcVersionStruct,
    method: (0, superstruct_12.string)(),
    params: exports2.JsonRpcParamsStruct
  });
  exports2.JsonRpcNotificationStruct = (0, superstruct_12.omit)(exports2.JsonRpcRequestStruct, ["id"]);
  function isJsonRpcNotification(value) {
    return (0, superstruct_12.is)(value, exports2.JsonRpcNotificationStruct);
  }
  exports2.isJsonRpcNotification = isJsonRpcNotification;
  function assertIsJsonRpcNotification(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", ErrorWrapper);
  }
  exports2.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
  function isJsonRpcRequest2(value) {
    return (0, superstruct_12.is)(value, exports2.JsonRpcRequestStruct);
  }
  exports2.isJsonRpcRequest = isJsonRpcRequest2;
  function assertIsJsonRpcRequest(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcRequestStruct, "Invalid JSON-RPC request", ErrorWrapper);
  }
  exports2.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
  exports2.PendingJsonRpcResponseStruct = (0, superstruct_12.object)({
    id: exports2.JsonRpcIdStruct,
    jsonrpc: exports2.JsonRpcVersionStruct,
    result: (0, superstruct_12.optional)((0, superstruct_12.unknown)()),
    error: (0, superstruct_12.optional)(exports2.JsonRpcErrorStruct)
  });
  exports2.JsonRpcSuccessStruct = (0, superstruct_12.object)({
    id: exports2.JsonRpcIdStruct,
    jsonrpc: exports2.JsonRpcVersionStruct,
    result: exports2.JsonStruct
  });
  exports2.JsonRpcFailureStruct = (0, superstruct_12.object)({
    id: exports2.JsonRpcIdStruct,
    jsonrpc: exports2.JsonRpcVersionStruct,
    error: exports2.JsonRpcErrorStruct
  });
  exports2.JsonRpcResponseStruct = (0, superstruct_12.union)([
    exports2.JsonRpcSuccessStruct,
    exports2.JsonRpcFailureStruct
  ]);
  function isPendingJsonRpcResponse(response) {
    return (0, superstruct_12.is)(response, exports2.PendingJsonRpcResponseStruct);
  }
  exports2.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
  function assertIsPendingJsonRpcResponse(response, ErrorWrapper) {
    (0, assert_12.assertStruct)(response, exports2.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", ErrorWrapper);
  }
  exports2.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
  function isJsonRpcResponse2(response) {
    return (0, superstruct_12.is)(response, exports2.JsonRpcResponseStruct);
  }
  exports2.isJsonRpcResponse = isJsonRpcResponse2;
  function assertIsJsonRpcResponse(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcResponseStruct, "Invalid JSON-RPC response", ErrorWrapper);
  }
  exports2.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
  function isJsonRpcSuccess(value) {
    return (0, superstruct_12.is)(value, exports2.JsonRpcSuccessStruct);
  }
  exports2.isJsonRpcSuccess = isJsonRpcSuccess;
  function assertIsJsonRpcSuccess(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", ErrorWrapper);
  }
  exports2.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
  function isJsonRpcFailure(value) {
    return (0, superstruct_12.is)(value, exports2.JsonRpcFailureStruct);
  }
  exports2.isJsonRpcFailure = isJsonRpcFailure;
  function assertIsJsonRpcFailure(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", ErrorWrapper);
  }
  exports2.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
  function isJsonRpcError2(value) {
    return (0, superstruct_12.is)(value, exports2.JsonRpcErrorStruct);
  }
  exports2.isJsonRpcError = isJsonRpcError2;
  function assertIsJsonRpcError(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcErrorStruct, "Invalid JSON-RPC error", ErrorWrapper);
  }
  exports2.assertIsJsonRpcError = assertIsJsonRpcError;
  function getJsonRpcIdValidator(options) {
    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
    const isValidJsonRpcId = (id2) => {
      return Boolean(typeof id2 === "number" && (permitFractions || Number.isInteger(id2)) || typeof id2 === "string" && (permitEmptyString || id2.length > 0) || permitNull && id2 === null);
    };
    return isValidJsonRpcId;
  }
  exports2.getJsonRpcIdValidator = getJsonRpcIdValidator;
  function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
    const seenObjects = /* @__PURE__ */ new Set();
    function getJsonSerializableInfo(value, skipSizing) {
      if (value === void 0) {
        return [false, 0];
      } else if (value === null) {
        return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
      }
      const typeOfValue = typeof value;
      try {
        if (typeOfValue === "function") {
          return [false, 0];
        } else if (typeOfValue === "string" || value instanceof String) {
          return [
            true,
            skipSizing ? 0 : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2
          ];
        } else if (typeOfValue === "boolean" || value instanceof Boolean) {
          if (skipSizing) {
            return [true, 0];
          }
          return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
        } else if (typeOfValue === "number" || value instanceof Number) {
          if (skipSizing) {
            return [true, 0];
          }
          return [true, (0, misc_1.calculateNumberSize)(value)];
        } else if (value instanceof Date) {
          if (skipSizing) {
            return [true, 0];
          }
          return [
            true,
            // Note: Invalid dates will serialize to null
            isNaN(value.getDate()) ? misc_1.JsonSize.Null : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2
          ];
        }
      } catch (_3) {
        return [false, 0];
      }
      if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {
        return [false, 0];
      }
      if (seenObjects.has(value)) {
        return [false, 0];
      }
      seenObjects.add(value);
      try {
        return [
          true,
          Object.entries(value).reduce(
            (sum, [key2, nestedValue], idx, arr2) => {
              let [valid2, size2] = getJsonSerializableInfo(nestedValue, skipSizing);
              if (!valid2) {
                throw new Error("JSON validation did not pass. Validation process stopped.");
              }
              seenObjects.delete(value);
              if (skipSizing) {
                return 0;
              }
              const keySize = Array.isArray(value) ? 0 : key2.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
              const separator = idx < arr2.length - 1 ? misc_1.JsonSize.Comma : 0;
              return sum + keySize + size2 + separator;
            },
            // Starts at 2 because the serialized JSON string data (plain text)
            // will minimally contain {}/[]
            skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2
          )
        ];
      } catch (_3) {
        return [false, 0];
      }
    }
    return getJsonSerializableInfo(jsObject, skipSizingProcess);
  }
  exports2.validateJsonAndGetSize = validateJsonAndGetSize;
})(json$2);
const json = /* @__PURE__ */ getDefaultExportFromCjs(json$2);
const json$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: json
}, [json$2]);
const require$$7$3 = /* @__PURE__ */ getAugmentedNamespace(json$1);
var logging$1 = {};
var browser$2 = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s3 = 1e3;
  var m2 = s3 * 60;
  var h5 = m2 * 60;
  var d3 = h5 * 24;
  var w3 = d3 * 7;
  var y3 = d3 * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n4 = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n4 * y3;
      case "weeks":
      case "week":
      case "w":
        return n4 * w3;
      case "days":
      case "day":
      case "d":
        return n4 * d3;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n4 * h5;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n4 * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n4 * s3;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n4;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d3) {
      return Math.round(ms2 / d3) + "d";
    }
    if (msAbs >= h5) {
      return Math.round(ms2 / h5) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s3) {
      return Math.round(ms2 / s3) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d3) {
      return plural(ms2, msAbs, d3, "day");
    }
    if (msAbs >= h5) {
      return plural(ms2, msAbs, h5, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s3) {
      return plural(ms2, msAbs, s3, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n4, name2) {
    var isPlural = msAbs >= n4 * 1.5;
    return Math.round(ms2 / n4) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms;
}
function setup(env2) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = requireMs();
  createDebug.destroy = destroy2;
  Object.keys(env2).forEach((key2) => {
    createDebug[key2] = env2[key2];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash2 = 0;
    for (let i3 = 0; i3 < namespace.length; i3++) {
      hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i3);
      hash2 |= 0;
    }
    return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        if (match === "%%") {
          return "%";
        }
        index2++;
        const formatter = createDebug.formatters[format];
        if (typeof formatter === "function") {
          const val = args[index2];
          match = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace);
    debug2.extend = extend2;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v4) => {
        enableOverride = v4;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend2(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i3;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len2 = split.length;
    for (i3 = 0; i3 < len2; i3++) {
      if (!split[i3]) {
        continue;
      }
      namespaces = split[i3].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name2) {
    if (name2[name2.length - 1] === "*") {
      return true;
    }
    let i3;
    let len2;
    for (i3 = 0, len2 = createDebug.skips.length; i3 < len2; i3++) {
      if (createDebug.skips[i3].test(name2)) {
        return false;
      }
    }
    for (i3 = 0, len2 = createDebug.names.length; i3 < len2; i3++) {
      if (createDebug.names[i3].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp2) {
    return regexp2.toString().substring(2, regexp2.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy2() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common = setup;
const common$1 = /* @__PURE__ */ getDefaultExportFromCjs(common);
const common$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: common$1
}, [common]);
const require$$0$I = /* @__PURE__ */ getAugmentedNamespace(common$2);
(function(module2, exports2) {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c2 = "color: " + this.color;
    args.splice(1, 0, c2, "color: inherit");
    let index2 = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index2++;
      if (match === "%c") {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c2);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r2;
    try {
      r2 = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r2 && typeof process !== "undefined" && "env" in process) {
      r2 = {}.DEBUG;
    }
    return r2;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require$$0$I(exports2);
  const { formatters } = module2.exports;
  formatters.j = function(v4) {
    try {
      return JSON.stringify(v4);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
})(browser$2, browser$2.exports);
var browserExports = browser$2.exports;
const browser = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
const browser$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: browser
}, [browserExports]);
const require$$0$H = /* @__PURE__ */ getAugmentedNamespace(browser$1);
var __importDefault$b = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(logging$1, "__esModule", { value: true });
var createModuleLogger_1 = logging$1.createModuleLogger = createProjectLogger_1 = logging$1.createProjectLogger = void 0;
const debug_1$1 = __importDefault$b(require$$0$H);
const globalLogger = (0, debug_1$1.default)("metamask");
function createProjectLogger(projectName) {
  return globalLogger.extend(projectName);
}
var createProjectLogger_1 = logging$1.createProjectLogger = createProjectLogger;
function createModuleLogger(projectLogger, moduleName2) {
  return projectLogger.extend(moduleName2);
}
createModuleLogger_1 = logging$1.createModuleLogger = createModuleLogger;
const logging = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createModuleLogger() {
    return createModuleLogger_1;
  },
  get createProjectLogger() {
    return createProjectLogger_1;
  },
  default: logging$1
}, [logging$1]);
const require$$8$3 = /* @__PURE__ */ getAugmentedNamespace(logging);
var number$1 = {};
Object.defineProperty(number$1, "__esModule", { value: true });
var hexToBigInt_1 = number$1.hexToBigInt = hexToNumber_1 = number$1.hexToNumber = bigIntToHex_1 = number$1.bigIntToHex = numberToHex_1 = number$1.numberToHex = void 0;
const assert_1 = require$$0$J;
const hex_1 = require$$6$7;
const numberToHex = (value) => {
  (0, assert_1.assert)(typeof value === "number", "Value must be a number.");
  (0, assert_1.assert)(value >= 0, "Value must be a non-negative number.");
  (0, assert_1.assert)(Number.isSafeInteger(value), "Value is not a safe integer. Use `bigIntToHex` instead.");
  return (0, hex_1.add0x)(value.toString(16));
};
var numberToHex_1 = number$1.numberToHex = numberToHex;
const bigIntToHex = (value) => {
  (0, assert_1.assert)(typeof value === "bigint", "Value must be a bigint.");
  (0, assert_1.assert)(value >= 0, "Value must be a non-negative bigint.");
  return (0, hex_1.add0x)(value.toString(16));
};
var bigIntToHex_1 = number$1.bigIntToHex = bigIntToHex;
const hexToNumber = (value) => {
  (0, hex_1.assertIsHexString)(value);
  const numberValue = parseInt(value, 16);
  (0, assert_1.assert)(Number.isSafeInteger(numberValue), "Value is not a safe integer. Use `hexToBigInt` instead.");
  return numberValue;
};
var hexToNumber_1 = number$1.hexToNumber = hexToNumber;
const hexToBigInt = (value) => {
  (0, hex_1.assertIsHexString)(value);
  return BigInt((0, hex_1.add0x)(value));
};
hexToBigInt_1 = number$1.hexToBigInt = hexToBigInt;
const number = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get bigIntToHex() {
    return bigIntToHex_1;
  },
  default: number$1,
  get hexToBigInt() {
    return hexToBigInt_1;
  },
  get hexToNumber() {
    return hexToNumber_1;
  },
  get numberToHex() {
    return numberToHex_1;
  }
}, [number$1]);
const require$$10$2 = /* @__PURE__ */ getAugmentedNamespace(number);
var opaque$1 = {};
Object.defineProperty(opaque$1, "__esModule", { value: true });
const opaque = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: opaque$1
}, [opaque$1]);
const require$$11$2 = /* @__PURE__ */ getAugmentedNamespace(opaque);
var time$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.timeSince = exports2.inMilliseconds = exports2.Duration = void 0;
  (function(Duration) {
    Duration[Duration["Millisecond"] = 1] = "Millisecond";
    Duration[Duration["Second"] = 1e3] = "Second";
    Duration[Duration["Minute"] = 6e4] = "Minute";
    Duration[Duration["Hour"] = 36e5] = "Hour";
    Duration[Duration["Day"] = 864e5] = "Day";
    Duration[Duration["Week"] = 6048e5] = "Week";
    Duration[Duration["Year"] = 31536e6] = "Year";
  })(exports2.Duration || (exports2.Duration = {}));
  const isNonNegativeInteger = (number2) => Number.isInteger(number2) && number2 >= 0;
  const assertIsNonNegativeInteger = (number2, name2) => {
    if (!isNonNegativeInteger(number2)) {
      throw new Error(`"${name2}" must be a non-negative integer. Received: "${number2}".`);
    }
  };
  function inMilliseconds(count2, duration) {
    assertIsNonNegativeInteger(count2, "count");
    return count2 * duration;
  }
  exports2.inMilliseconds = inMilliseconds;
  function timeSince(timestamp2) {
    assertIsNonNegativeInteger(timestamp2, "timestamp");
    return Date.now() - timestamp2;
  }
  exports2.timeSince = timeSince;
})(time$2);
const time = /* @__PURE__ */ getDefaultExportFromCjs(time$2);
const time$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: time
}, [time$2]);
const require$$12$4 = /* @__PURE__ */ getAugmentedNamespace(time$1);
var versions$2 = {};
var re$5 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$2 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const constants$3 = /* @__PURE__ */ getDefaultExportFromCjs(constants$2);
const constants$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: constants$3
}, [constants$2]);
const require$$1$l = /* @__PURE__ */ getAugmentedNamespace(constants$4);
const debug$1 = typeof process === "object" && process.env && "" ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$1;
const debug$2 = /* @__PURE__ */ getDefaultExportFromCjs(debug_1);
const debug$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: debug$2
}, [debug_1]);
const require$$3$b = /* @__PURE__ */ getAugmentedNamespace(debug$3);
(function(module2, exports2) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2 } = require$$1$l;
  const debug2 = require$$3$b;
  exports2 = module2.exports = {};
  const re2 = exports2.re = [];
  const src2 = exports2.src = [];
  const t2 = exports2.t = {};
  let R3 = 0;
  const createToken2 = (name2, value, isGlobal) => {
    const index2 = R3++;
    debug2(name2, index2, value);
    t2[name2] = index2;
    src2[index2] = value;
    re2[index2] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken2("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken2("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken2("MAINVERSION", `(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})`);
  createToken2("MAINVERSIONLOOSE", `(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken2("PRERELEASEIDENTIFIER", `(?:${src2[t2.NUMERICIDENTIFIER]}|${src2[t2.NONNUMERICIDENTIFIER]})`);
  createToken2("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t2.NUMERICIDENTIFIERLOOSE]}|${src2[t2.NONNUMERICIDENTIFIER]})`);
  createToken2("PRERELEASE", `(?:-(${src2[t2.PRERELEASEIDENTIFIER]}(?:\\.${src2[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken2("PRERELEASELOOSE", `(?:-?(${src2[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken2("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken2("BUILD", `(?:\\+(${src2[t2.BUILDIDENTIFIER]}(?:\\.${src2[t2.BUILDIDENTIFIER]})*))`);
  createToken2("FULLPLAIN", `v?${src2[t2.MAINVERSION]}${src2[t2.PRERELEASE]}?${src2[t2.BUILD]}?`);
  createToken2("FULL", `^${src2[t2.FULLPLAIN]}$`);
  createToken2("LOOSEPLAIN", `[v=\\s]*${src2[t2.MAINVERSIONLOOSE]}${src2[t2.PRERELEASELOOSE]}?${src2[t2.BUILD]}?`);
  createToken2("LOOSE", `^${src2[t2.LOOSEPLAIN]}$`);
  createToken2("GTLT", "((?:<|>)?=?)");
  createToken2("XRANGEIDENTIFIERLOOSE", `${src2[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken2("XRANGEIDENTIFIER", `${src2[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken2("XRANGEPLAIN", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:${src2[t2.PRERELEASE]})?${src2[t2.BUILD]}?)?)?`);
  createToken2("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:${src2[t2.PRERELEASELOOSE]})?${src2[t2.BUILD]}?)?)?`);
  createToken2("XRANGE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAIN]}$`);
  createToken2("XRANGELOOSE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken2("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken2("COERCERTL", src2[t2.COERCE], true);
  createToken2("LONETILDE", "(?:~>?)");
  createToken2("TILDETRIM", `(\\s*)${src2[t2.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken2("TILDE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAIN]}$`);
  createToken2("TILDELOOSE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken2("LONECARET", "(?:\\^)");
  createToken2("CARETTRIM", `(\\s*)${src2[t2.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken2("CARET", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAIN]}$`);
  createToken2("CARETLOOSE", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken2("COMPARATORLOOSE", `^${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]})$|^$`);
  createToken2("COMPARATOR", `^${src2[t2.GTLT]}\\s*(${src2[t2.FULLPLAIN]})$|^$`);
  createToken2("COMPARATORTRIM", `(\\s*)${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]}|${src2[t2.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken2("HYPHENRANGE", `^\\s*(${src2[t2.XRANGEPLAIN]})\\s+-\\s+(${src2[t2.XRANGEPLAIN]})\\s*$`);
  createToken2("HYPHENRANGELOOSE", `^\\s*(${src2[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken2("STAR", "(<|>)?=?\\s*\\*");
  createToken2("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken2("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$5, re$5.exports);
var reExports = re$5.exports;
const re$3 = /* @__PURE__ */ getDefaultExportFromCjs(reExports);
const re$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: re$3
}, [reExports]);
const require$$0$G = /* @__PURE__ */ getAugmentedNamespace(re$4);
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const parseOptions$2 = /* @__PURE__ */ getDefaultExportFromCjs(parseOptions_1);
const parseOptions$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: parseOptions$2
}, [parseOptions_1]);
const require$$0$F = /* @__PURE__ */ getAugmentedNamespace(parseOptions$3);
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a3, b4) => {
  const anum = numeric.test(a3);
  const bnum = numeric.test(b4);
  if (anum && bnum) {
    a3 = +a3;
    b4 = +b4;
  }
  return a3 === b4 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a3 < b4 ? -1 : 1;
};
const rcompareIdentifiers = (a3, b4) => compareIdentifiers$1(b4, a3);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const identifiers$2 = /* @__PURE__ */ getDefaultExportFromCjs(identifiers$1);
const identifiers$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: identifiers$2
}, [identifiers$1]);
const require$$3$a = /* @__PURE__ */ getAugmentedNamespace(identifiers$3);
const debug = require$$3$b;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = require$$1$l;
const { re: re$2, t: t$3 } = require$$0$G;
const parseOptions = require$$0$F;
const { compareIdentifiers } = require$$3$a;
let SemVer$d = class SemVer2 {
  constructor(version2, options) {
    options = parseOptions(options);
    if (version2 instanceof SemVer2) {
      if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m2 = version2.trim().match(options.loose ? re$2[t$3.LOOSE] : re$2[t$3.FULL]);
    if (!m2) {
      throw new TypeError(`Invalid Version: ${version2}`);
    }
    this.raw = version2;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer2)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer2(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i3 = 0;
    do {
      const a3 = this.prerelease[i3];
      const b4 = other.prerelease[i3];
      debug("prerelease compare", i3, a3, b4);
      if (a3 === void 0 && b4 === void 0) {
        return 0;
      } else if (b4 === void 0) {
        return 1;
      } else if (a3 === void 0) {
        return -1;
      } else if (a3 === b4) {
        continue;
      } else {
        return compareIdentifiers(a3, b4);
      }
    } while (++i3);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options);
    }
    let i3 = 0;
    do {
      const a3 = this.build[i3];
      const b4 = other.build[i3];
      debug("prerelease compare", i3, a3, b4);
      if (a3 === void 0 && b4 === void 0) {
        return 0;
      } else if (b4 === void 0) {
        return 1;
      } else if (a3 === void 0) {
        return -1;
      } else if (a3 === b4) {
        continue;
      } else {
        return compareIdentifiers(a3, b4);
      }
    } while (++i3);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base3 = Number(identifierBase) ? 1 : 0;
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (this.prerelease.length === 0) {
          this.prerelease = [base3];
        } else {
          let i3 = this.prerelease.length;
          while (--i3 >= 0) {
            if (typeof this.prerelease[i3] === "number") {
              this.prerelease[i3]++;
              i3 = -2;
            }
          }
          if (i3 === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base3);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base3];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.format();
    this.raw = this.version;
    return this;
  }
};
var semver$2 = SemVer$d;
const semver$3 = /* @__PURE__ */ getDefaultExportFromCjs(semver$2);
const semver$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: semver$3
}, [semver$2]);
const require$$2$f = /* @__PURE__ */ getAugmentedNamespace(semver$4);
const SemVer$c = require$$2$f;
const parse$6 = (version2, options, throwErrors = false) => {
  if (version2 instanceof SemVer$c) {
    return version2;
  }
  try {
    return new SemVer$c(version2, options);
  } catch (er2) {
    if (!throwErrors) {
      return null;
    }
    throw er2;
  }
};
var parse_1 = parse$6;
const parse$7 = /* @__PURE__ */ getDefaultExportFromCjs(parse_1);
const parse$8 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: parse$7
}, [parse_1]);
const require$$4$9 = /* @__PURE__ */ getAugmentedNamespace(parse$8);
const parse$5 = require$$4$9;
const valid$4 = (version2, options) => {
  const v4 = parse$5(version2, options);
  return v4 ? v4.version : null;
};
var valid_1 = valid$4;
const valid$5 = /* @__PURE__ */ getDefaultExportFromCjs(valid_1);
const valid$6 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: valid$5
}, [valid_1]);
const require$$5$7 = /* @__PURE__ */ getAugmentedNamespace(valid$6);
const parse$4 = require$$4$9;
const clean$1 = (version2, options) => {
  const s3 = parse$4(version2.trim().replace(/^[=v]+/, ""), options);
  return s3 ? s3.version : null;
};
var clean_1 = clean$1;
const clean$2 = /* @__PURE__ */ getDefaultExportFromCjs(clean_1);
const clean$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: clean$2
}, [clean_1]);
const require$$6$6 = /* @__PURE__ */ getAugmentedNamespace(clean$3);
const SemVer$b = require$$2$f;
const inc$1 = (version2, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(
      version2 instanceof SemVer$b ? version2.version : version2,
      options
    ).inc(release, identifier, identifierBase).version;
  } catch (er2) {
    return null;
  }
};
var inc_1 = inc$1;
const inc$2 = /* @__PURE__ */ getDefaultExportFromCjs(inc_1);
const inc$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: inc$2
}, [inc_1]);
const require$$7$2 = /* @__PURE__ */ getAugmentedNamespace(inc$3);
const parse$3 = require$$4$9;
const diff$1 = (version1, version2) => {
  const v1 = parse$3(version1, null, true);
  const v22 = parse$3(version2, null, true);
  const comparison = v1.compare(v22);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v22;
  const lowVersion = v1Higher ? v22 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v22.major) {
    return prefix + "major";
  }
  if (v1.minor !== v22.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v22.patch) {
    return prefix + "patch";
  }
  if (highHasPre) {
    return "prerelease";
  }
  if (lowVersion.patch) {
    return "patch";
  }
  if (lowVersion.minor) {
    return "minor";
  }
  return "major";
};
var diff_1 = diff$1;
const diff$2 = /* @__PURE__ */ getDefaultExportFromCjs(diff_1);
const diff$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: diff$2
}, [diff_1]);
const require$$8$2 = /* @__PURE__ */ getAugmentedNamespace(diff$3);
const SemVer$a = require$$2$f;
const major$1 = (a3, loose) => new SemVer$a(a3, loose).major;
var major_1 = major$1;
const major$2 = /* @__PURE__ */ getDefaultExportFromCjs(major_1);
const major$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: major$2
}, [major_1]);
const require$$9$1 = /* @__PURE__ */ getAugmentedNamespace(major$3);
const SemVer$9 = require$$2$f;
const minor$1 = (a3, loose) => new SemVer$9(a3, loose).minor;
var minor_1 = minor$1;
const minor$2 = /* @__PURE__ */ getDefaultExportFromCjs(minor_1);
const minor$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: minor$2
}, [minor_1]);
const require$$10$1 = /* @__PURE__ */ getAugmentedNamespace(minor$3);
const SemVer$8 = require$$2$f;
const patch$1 = (a3, loose) => new SemVer$8(a3, loose).patch;
var patch_1 = patch$1;
const patch$2 = /* @__PURE__ */ getDefaultExportFromCjs(patch_1);
const patch$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: patch$2
}, [patch_1]);
const require$$11$1 = /* @__PURE__ */ getAugmentedNamespace(patch$3);
const parse$2 = require$$4$9;
const prerelease$1 = (version2, options) => {
  const parsed = parse$2(version2, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const prerelease$2 = /* @__PURE__ */ getDefaultExportFromCjs(prerelease_1);
const prerelease$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: prerelease$2
}, [prerelease_1]);
const require$$12$3 = /* @__PURE__ */ getAugmentedNamespace(prerelease$3);
const SemVer$7 = require$$2$f;
const compare$c = (a3, b4, loose) => new SemVer$7(a3, loose).compare(new SemVer$7(b4, loose));
var compare_1 = compare$c;
const compare$d = /* @__PURE__ */ getDefaultExportFromCjs(compare_1);
const compare$e = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: compare$d
}, [compare_1]);
const require$$13$3 = /* @__PURE__ */ getAugmentedNamespace(compare$e);
const compare$b = require$$13$3;
const rcompare$1 = (a3, b4, loose) => compare$b(b4, a3, loose);
var rcompare_1 = rcompare$1;
const rcompare$2 = /* @__PURE__ */ getDefaultExportFromCjs(rcompare_1);
const rcompare$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: rcompare$2
}, [rcompare_1]);
const require$$14$1 = /* @__PURE__ */ getAugmentedNamespace(rcompare$3);
const compare$a = require$$13$3;
const compareLoose$1 = (a3, b4) => compare$a(a3, b4, true);
var compareLoose_1 = compareLoose$1;
const compareLoose$2 = /* @__PURE__ */ getDefaultExportFromCjs(compareLoose_1);
const compareLoose$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: compareLoose$2
}, [compareLoose_1]);
const require$$15$1 = /* @__PURE__ */ getAugmentedNamespace(compareLoose$3);
const SemVer$6 = require$$2$f;
const compareBuild$3 = (a3, b4, loose) => {
  const versionA = new SemVer$6(a3, loose);
  const versionB = new SemVer$6(b4, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$4 = /* @__PURE__ */ getDefaultExportFromCjs(compareBuild_1);
const compareBuild$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: compareBuild$4
}, [compareBuild_1]);
const require$$16 = /* @__PURE__ */ getAugmentedNamespace(compareBuild$5);
const compareBuild$2 = require$$16;
const sort$1 = (list, loose) => list.sort((a3, b4) => compareBuild$2(a3, b4, loose));
var sort_1 = sort$1;
const sort$2 = /* @__PURE__ */ getDefaultExportFromCjs(sort_1);
const sort$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sort$2
}, [sort_1]);
const require$$17 = /* @__PURE__ */ getAugmentedNamespace(sort$3);
const compareBuild$1 = require$$16;
const rsort$1 = (list, loose) => list.sort((a3, b4) => compareBuild$1(b4, a3, loose));
var rsort_1 = rsort$1;
const rsort$2 = /* @__PURE__ */ getDefaultExportFromCjs(rsort_1);
const rsort$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: rsort$2
}, [rsort_1]);
const require$$18 = /* @__PURE__ */ getAugmentedNamespace(rsort$3);
const compare$9 = require$$13$3;
const gt$4 = (a3, b4, loose) => compare$9(a3, b4, loose) > 0;
var gt_1 = gt$4;
const gt$5 = /* @__PURE__ */ getDefaultExportFromCjs(gt_1);
const gt$6 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: gt$5
}, [gt_1]);
const require$$19 = /* @__PURE__ */ getAugmentedNamespace(gt$6);
const compare$8 = require$$13$3;
const lt$3 = (a3, b4, loose) => compare$8(a3, b4, loose) < 0;
var lt_1 = lt$3;
const lt$4 = /* @__PURE__ */ getDefaultExportFromCjs(lt_1);
const lt$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: lt$4
}, [lt_1]);
const require$$20 = /* @__PURE__ */ getAugmentedNamespace(lt$5);
const compare$7 = require$$13$3;
const eq$2 = (a3, b4, loose) => compare$7(a3, b4, loose) === 0;
var eq_1 = eq$2;
const eq$3 = /* @__PURE__ */ getDefaultExportFromCjs(eq_1);
const eq$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: eq$3
}, [eq_1]);
const require$$21 = /* @__PURE__ */ getAugmentedNamespace(eq$4);
const compare$6 = require$$13$3;
const neq$2 = (a3, b4, loose) => compare$6(a3, b4, loose) !== 0;
var neq_1 = neq$2;
const neq$3 = /* @__PURE__ */ getDefaultExportFromCjs(neq_1);
const neq$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: neq$3
}, [neq_1]);
const require$$22 = /* @__PURE__ */ getAugmentedNamespace(neq$4);
const compare$5 = require$$13$3;
const gte$3 = (a3, b4, loose) => compare$5(a3, b4, loose) >= 0;
var gte_1 = gte$3;
const gte$4 = /* @__PURE__ */ getDefaultExportFromCjs(gte_1);
const gte$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: gte$4
}, [gte_1]);
const require$$23 = /* @__PURE__ */ getAugmentedNamespace(gte$5);
const compare$4 = require$$13$3;
const lte$3 = (a3, b4, loose) => compare$4(a3, b4, loose) <= 0;
var lte_1 = lte$3;
const lte$4 = /* @__PURE__ */ getDefaultExportFromCjs(lte_1);
const lte$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: lte$4
}, [lte_1]);
const require$$24 = /* @__PURE__ */ getAugmentedNamespace(lte$5);
const eq$1 = require$$21;
const neq$1 = require$$22;
const gt$3 = require$$19;
const gte$2 = require$$23;
const lt$2 = require$$20;
const lte$2 = require$$24;
const cmp$1 = (a3, op, b4, loose) => {
  switch (op) {
    case "===":
      if (typeof a3 === "object") {
        a3 = a3.version;
      }
      if (typeof b4 === "object") {
        b4 = b4.version;
      }
      return a3 === b4;
    case "!==":
      if (typeof a3 === "object") {
        a3 = a3.version;
      }
      if (typeof b4 === "object") {
        b4 = b4.version;
      }
      return a3 !== b4;
    case "":
    case "=":
    case "==":
      return eq$1(a3, b4, loose);
    case "!=":
      return neq$1(a3, b4, loose);
    case ">":
      return gt$3(a3, b4, loose);
    case ">=":
      return gte$2(a3, b4, loose);
    case "<":
      return lt$2(a3, b4, loose);
    case "<=":
      return lte$2(a3, b4, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const cmp$2 = /* @__PURE__ */ getDefaultExportFromCjs(cmp_1);
const cmp$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: cmp$2
}, [cmp_1]);
const require$$25 = /* @__PURE__ */ getAugmentedNamespace(cmp$3);
const SemVer$5 = require$$2$f;
const parse$1 = require$$4$9;
const { re: re$1, t: t$2 } = require$$0$G;
const coerce$1 = (version2, options) => {
  if (version2 instanceof SemVer$5) {
    return version2;
  }
  if (typeof version2 === "number") {
    version2 = String(version2);
  }
  if (typeof version2 !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version2.match(re$1[t$2.COERCE]);
  } else {
    let next;
    while ((next = re$1[t$2.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re$1[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re$1[t$2.COERCERTL].lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  return parse$1(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
var coerce_1 = coerce$1;
const coerce$2 = /* @__PURE__ */ getDefaultExportFromCjs(coerce_1);
const coerce$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: coerce$2
}, [coerce_1]);
const require$$26 = /* @__PURE__ */ getAugmentedNamespace(coerce$3);
var iterator$1;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator)
    return iterator$1;
  hasRequiredIterator = 1;
  iterator$1 = function(Yallist2) {
    Yallist2.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator$1;
}
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i3 = 0, l2 = arguments.length; i3 < l2; i3++) {
      self2.push(arguments[i3]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node2) {
  if (node2.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node2.next;
  var prev = node2.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node2 === this.head) {
    this.head = next;
  }
  if (node2 === this.tail) {
    this.tail = prev;
  }
  node2.list.length--;
  node2.next = null;
  node2.prev = null;
  node2.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node2) {
  if (node2 === this.head) {
    return;
  }
  if (node2.list) {
    node2.list.removeNode(node2);
  }
  var head = this.head;
  node2.list = this;
  node2.next = head;
  if (head) {
    head.prev = node2;
  }
  this.head = node2;
  if (!this.tail) {
    this.tail = node2;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node2) {
  if (node2 === this.tail) {
    return;
  }
  if (node2.list) {
    node2.list.removeNode(node2);
  }
  var tail = this.tail;
  node2.list = this;
  node2.prev = tail;
  if (tail) {
    tail.next = node2;
  }
  this.tail = node2;
  if (!this.head) {
    this.head = node2;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i3 = 0, l2 = arguments.length; i3 < l2; i3++) {
    push(this, arguments[i3]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i3 = 0, l2 = arguments.length; i3 < l2; i3++) {
    unshift(this, arguments[i3]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn2, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i3 = 0; walker !== null; i3++) {
    fn2.call(thisp, walker.value, i3, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn2, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i3 = this.length - 1; walker !== null; i3--) {
    fn2.call(thisp, walker.value, i3, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n4) {
  for (var i3 = 0, walker = this.head; walker !== null && i3 < n4; i3++) {
    walker = walker.next;
  }
  if (i3 === n4 && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n4) {
  for (var i3 = 0, walker = this.tail; walker !== null && i3 < n4; i3++) {
    walker = walker.prev;
  }
  if (i3 === n4 && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn2, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn2.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn2, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn2.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn2, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i3 = 0; walker !== null; i3++) {
    acc = fn2(acc, walker.value, i3);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn2, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i3 = this.length - 1; walker !== null; i3--) {
    acc = fn2(acc, walker.value, i3);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr2 = new Array(this.length);
  for (var i3 = 0, walker = this.head; walker !== null; i3++) {
    arr2[i3] = walker.value;
    walker = walker.next;
  }
  return arr2;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr2 = new Array(this.length);
  for (var i3 = 0, walker = this.tail; walker !== null; i3++) {
    arr2[i3] = walker.value;
    walker = walker.prev;
  }
  return arr2;
};
Yallist$1.prototype.slice = function(from2, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from2 = from2 || 0;
  if (from2 < 0) {
    from2 += this.length;
  }
  var ret = new Yallist$1();
  if (to < from2 || to < 0) {
    return ret;
  }
  if (from2 < 0) {
    from2 = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i3 = 0, walker = this.head; walker !== null && i3 < from2; i3++) {
    walker = walker.next;
  }
  for (; walker !== null && i3 < to; i3++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from2, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from2 = from2 || 0;
  if (from2 < 0) {
    from2 += this.length;
  }
  var ret = new Yallist$1();
  if (to < from2 || to < 0) {
    return ret;
  }
  if (from2 < 0) {
    from2 = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i3 = this.length, walker = this.tail; walker !== null && i3 > to; i3--) {
    walker = walker.prev;
  }
  for (; walker !== null && i3 > from2; i3--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i3 = 0, walker = this.head; walker !== null && i3 < start; i3++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i3 = 0; walker && i3 < deleteCount; i3++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i3 = 0; i3 < nodes.length; i3++) {
    walker = insert(this, walker, nodes[i3]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p3 = walker.prev;
    walker.prev = walker.next;
    walker.next = p3;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node2, value) {
  var inserted = node2 === self2.head ? new Node(value, null, node2, self2) : new Node(value, node2, node2.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  requireIterator()(Yallist$1);
} catch (er2) {
}
const yallist$1 = /* @__PURE__ */ getDefaultExportFromCjs(yallist);
const yallist$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: yallist$1
}, [yallist]);
const require$$0$E = /* @__PURE__ */ getAugmentedNamespace(yallist$2);
const Yallist = require$$0$E;
const MAX$1 = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options === "number")
      options = { max: options };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX$1] = options.max || Infinity;
    const lc2 = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc2 !== "function" ? naiveLength : lc2;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX$1] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX$1];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn2, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn2, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn2, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn2, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k3) => k3.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k3) => k3.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h5) => h5);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key2, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len2 = this[LENGTH_CALCULATOR](value, key2);
    if (this[CACHE].has(key2)) {
      if (len2 > this[MAX$1]) {
        del(this, this[CACHE].get(key2));
        return false;
      }
      const node2 = this[CACHE].get(key2);
      const item = node2.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key2, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len2 - item.length;
      item.length = len2;
      this.get(key2);
      trim(this);
      return true;
    }
    const hit = new Entry$1(key2, value, len2, now, maxAge);
    if (hit.length > this[MAX$1]) {
      if (this[DISPOSE])
        this[DISPOSE](key2, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key2, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key2) {
    if (!this[CACHE].has(key2))
      return false;
    const hit = this[CACHE].get(key2).value;
    return !isStale(this, hit);
  }
  get(key2) {
    return get$1(this, key2, true);
  }
  peek(key2) {
    return get$1(this, key2, false);
  }
  pop() {
    const node2 = this[LRU_LIST].tail;
    if (!node2)
      return null;
    del(this, node2);
    return node2.value;
  }
  del(key2) {
    del(this, this[CACHE].get(key2));
  }
  load(arr2) {
    this.reset();
    const now = Date.now();
    for (let l2 = arr2.length - 1; l2 >= 0; l2--) {
      const hit = arr2[l2];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key2) => get$1(this, key2, false));
  }
}
const get$1 = (self2, key2, doUse) => {
  const node2 = self2[CACHE].get(key2);
  if (node2) {
    const hit = node2.value;
    if (isStale(self2, hit)) {
      del(self2, node2);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node2.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node2);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX$1]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX$1] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node2) => {
  if (node2) {
    const hit = node2.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node2);
  }
};
let Entry$1 = class Entry2 {
  constructor(key2, value, length2, now, maxAge) {
    this.key = key2;
    this.value = value;
    this.length = length2;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
};
const forEachStep = (self2, fn2, node2, thisp) => {
  let hit = node2.value;
  if (isStale(self2, hit)) {
    del(self2, node2);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn2.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
const index$n = /* @__PURE__ */ getDefaultExportFromCjs(lruCache);
const lruCache$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$n
}, [lruCache]);
const require$$0$D = /* @__PURE__ */ getAugmentedNamespace(lruCache$1);
var range$1;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range$1;
  hasRequiredRange = 1;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2;
      this.set = range2.split("||").map((r2) => this.parseRange(r2.trim())).filter((c2) => c2.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${range2}`);
      }
      if (this.set.length > 1) {
        const first2 = this.set[0];
        this.set = this.set.filter((c2) => !isNullSet(c2[0]));
        if (this.set.length === 0) {
          this.set = [first2];
        } else if (this.set.length > 1) {
          for (const c2 of this.set) {
            if (c2.length === 1 && isAny(c2[0])) {
              this.set = [c2];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      range2 = range2.trim();
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr2 = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr2, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      range2 = range2.split(/\s+/).join(" ");
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er2) {
          return false;
        }
      }
      for (let i3 = 0; i3 < this.set.length; i3++) {
        if (testSet(this.set[i3], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range$1 = Range2;
  const LRU = require$$0$D;
  const cache = new LRU({ max: 1e3 });
  const parseOptions2 = require$$0$F;
  const Comparator2 = requireComparator();
  const debug2 = require$$3$b;
  const SemVer3 = require$$2$f;
  const {
    re: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require$$0$G;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require$$1$l;
  const isNullSet = (c2) => c2.value === "<0.0.0-0";
  const isAny = (c2) => c2.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c2) => {
    return replaceTilde(c2, options);
  }).join(" ");
  const replaceTilde = (comp, options) => {
    const r2 = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r2, (_3, M3, m2, p3, pr2) => {
      debug2("tilde", comp, _3, M3, m2, p3, pr2);
      let ret;
      if (isX(M3)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M3}.0.0 <${+M3 + 1}.0.0-0`;
      } else if (isX(p3)) {
        ret = `>=${M3}.${m2}.0 <${M3}.${+m2 + 1}.0-0`;
      } else if (pr2) {
        debug2("replaceTilde pr", pr2);
        ret = `>=${M3}.${m2}.${p3}-${pr2} <${M3}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M3}.${m2}.${p3} <${M3}.${+m2 + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c2) => {
    return replaceCaret(c2, options);
  }).join(" ");
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r2 = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z2 = options.includePrerelease ? "-0" : "";
    return comp.replace(r2, (_3, M3, m2, p3, pr2) => {
      debug2("caret", comp, _3, M3, m2, p3, pr2);
      let ret;
      if (isX(M3)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M3}.0.0${z2} <${+M3 + 1}.0.0-0`;
      } else if (isX(p3)) {
        if (M3 === "0") {
          ret = `>=${M3}.${m2}.0${z2} <${M3}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M3}.${m2}.0${z2} <${+M3 + 1}.0.0-0`;
        }
      } else if (pr2) {
        debug2("replaceCaret pr", pr2);
        if (M3 === "0") {
          if (m2 === "0") {
            ret = `>=${M3}.${m2}.${p3}-${pr2} <${M3}.${m2}.${+p3 + 1}-0`;
          } else {
            ret = `>=${M3}.${m2}.${p3}-${pr2} <${M3}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M3}.${m2}.${p3}-${pr2} <${+M3 + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M3 === "0") {
          if (m2 === "0") {
            ret = `>=${M3}.${m2}.${p3}${z2} <${M3}.${m2}.${+p3 + 1}-0`;
          } else {
            ret = `>=${M3}.${m2}.${p3}${z2} <${M3}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M3}.${m2}.${p3} <${+M3 + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c2) => {
      return replaceXRange(c2, options);
    }).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r2 = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r2, (ret, gtlt, M3, m2, p3, pr2) => {
      debug2("xRange", comp, ret, gtlt, M3, m2, p3, pr2);
      const xM = isX(M3);
      const xm = xM || isX(m2);
      const xp = xm || isX(p3);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr2 = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p3 = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M3 = +M3 + 1;
            m2 = 0;
            p3 = 0;
          } else {
            m2 = +m2 + 1;
            p3 = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M3 = +M3 + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr2 = "-0";
        }
        ret = `${gtlt + M3}.${m2}.${p3}${pr2}`;
      } else if (xm) {
        ret = `>=${M3}.0.0${pr2} <${+M3 + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M3}.${m2}.0${pr2} <${M3}.${+m2 + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from2, fM, fm, fp, fpr, fb2, to, tM, tm, tp, tpr, tb2) => {
    if (isX(fM)) {
      from2 = "";
    } else if (isX(fm)) {
      from2 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from2 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from2 = `>=${from2}`;
    } else {
      from2 = `>=${from2}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from2} ${to}`.trim();
  };
  const testSet = (set2, version2, options) => {
    for (let i3 = 0; i3 < set2.length; i3++) {
      if (!set2[i3].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i3 = 0; i3 < set2.length; i3++) {
        debug2(set2[i3].semver);
        if (set2[i3].semver === Comparator2.ANY) {
          continue;
        }
        if (set2[i3].semver.prerelease.length > 0) {
          const allowed = set2[i3].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range$1;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator)
    return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r2 = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m2 = comp.match(r2);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== void 0 ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY2 || version2 === ANY2) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er2) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = require$$0$F;
  const { re: re2, t: t2 } = require$$0$G;
  const cmp2 = require$$25;
  const debug2 = require$$3$b;
  const SemVer3 = require$$2$f;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version2, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er2) {
    return false;
  }
  return range2.test(version2);
};
var satisfies_1 = satisfies$4;
const satisfies$5 = /* @__PURE__ */ getDefaultExportFromCjs(satisfies_1);
const satisfies$6 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: satisfies$5
}, [satisfies_1]);
const require$$29 = /* @__PURE__ */ getAugmentedNamespace(satisfies$6);
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const toComparators$2 = /* @__PURE__ */ getDefaultExportFromCjs(toComparators_1);
const toComparators$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: toComparators$2
}, [toComparators_1]);
const require$$30 = /* @__PURE__ */ getAugmentedNamespace(toComparators$3);
const SemVer$4 = require$$2$f;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions2, range2, options) => {
  let max2 = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er2) {
    return null;
  }
  versions2.forEach((v4) => {
    if (rangeObj.test(v4)) {
      if (!max2 || maxSV.compare(v4) === -1) {
        max2 = v4;
        maxSV = new SemVer$4(max2, options);
      }
    }
  });
  return max2;
};
var maxSatisfying_1 = maxSatisfying$1;
const maxSatisfying$2 = /* @__PURE__ */ getDefaultExportFromCjs(maxSatisfying_1);
const maxSatisfying$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: maxSatisfying$2
}, [maxSatisfying_1]);
const require$$31 = /* @__PURE__ */ getAugmentedNamespace(maxSatisfying$3);
const SemVer$3 = require$$2$f;
const Range$6 = requireRange();
const minSatisfying$1 = (versions2, range2, options) => {
  let min2 = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er2) {
    return null;
  }
  versions2.forEach((v4) => {
    if (rangeObj.test(v4)) {
      if (!min2 || minSV.compare(v4) === 1) {
        min2 = v4;
        minSV = new SemVer$3(min2, options);
      }
    }
  });
  return min2;
};
var minSatisfying_1 = minSatisfying$1;
const minSatisfying$2 = /* @__PURE__ */ getDefaultExportFromCjs(minSatisfying_1);
const minSatisfying$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: minSatisfying$2
}, [minSatisfying_1]);
const require$$32 = /* @__PURE__ */ getAugmentedNamespace(minSatisfying$3);
const SemVer$2 = require$$2$f;
const Range$5 = requireRange();
const gt$2 = require$$19;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i3 = 0; i3 < range2.set.length; ++i3) {
    const comparators = range2.set[i3];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const minVersion$2 = /* @__PURE__ */ getDefaultExportFromCjs(minVersion_1);
const minVersion$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: minVersion$2
}, [minVersion_1]);
const require$$33 = /* @__PURE__ */ getAugmentedNamespace(minVersion$3);
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er2) {
    return null;
  }
};
var valid$1 = validRange$1;
const valid$2 = /* @__PURE__ */ getDefaultExportFromCjs(valid$1);
const valid$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: valid$2
}, [valid$1]);
const require$$34 = /* @__PURE__ */ getAugmentedNamespace(valid$3);
const SemVer$1 = require$$2$f;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = require$$29;
const gt$1 = require$$19;
const lt$1 = require$$20;
const lte$1 = require$$24;
const gte$1 = require$$23;
const outside$3 = (version2, range2, hilo, options) => {
  version2 = new SemVer$1(version2, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version2, range2, options)) {
    return false;
  }
  for (let i3 = 0; i3 < range2.set.length; ++i3) {
    const comparators = range2.set[i3];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$4 = /* @__PURE__ */ getDefaultExportFromCjs(outside_1);
const outside$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: outside$4
}, [outside_1]);
const require$$35 = /* @__PURE__ */ getAugmentedNamespace(outside$5);
const outside$2 = require$$35;
const gtr$1 = (version2, range2, options) => outside$2(version2, range2, ">", options);
var gtr_1 = gtr$1;
const gtr$2 = /* @__PURE__ */ getDefaultExportFromCjs(gtr_1);
const gtr$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: gtr$2
}, [gtr_1]);
const require$$36 = /* @__PURE__ */ getAugmentedNamespace(gtr$3);
const outside$1 = require$$35;
const ltr$1 = (version2, range2, options) => outside$1(version2, range2, "<", options);
var ltr_1 = ltr$1;
const ltr$2 = /* @__PURE__ */ getDefaultExportFromCjs(ltr_1);
const ltr$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ltr$2
}, [ltr_1]);
const require$$37 = /* @__PURE__ */ getAugmentedNamespace(ltr$3);
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
const intersects$2 = /* @__PURE__ */ getDefaultExportFromCjs(intersects_1);
const intersects$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: intersects$2
}, [intersects_1]);
const require$$38 = /* @__PURE__ */ getAugmentedNamespace(intersects$3);
const satisfies$2 = require$$29;
const compare$3 = require$$13$3;
var simplify = (versions2, range2, options) => {
  const set2 = [];
  let first2 = null;
  let prev = null;
  const v4 = versions2.sort((a3, b4) => compare$3(a3, b4, options));
  for (const version2 of v4) {
    const included = satisfies$2(version2, range2, options);
    if (included) {
      prev = version2;
      if (!first2) {
        first2 = version2;
      }
    } else {
      if (prev) {
        set2.push([first2, prev]);
      }
      prev = null;
      first2 = null;
    }
  }
  if (first2) {
    set2.push([first2, null]);
  }
  const ranges = [];
  for (const [min2, max2] of set2) {
    if (min2 === max2) {
      ranges.push(min2);
    } else if (!max2 && min2 === v4[0]) {
      ranges.push("*");
    } else if (!max2) {
      ranges.push(`>=${min2}`);
    } else if (min2 === v4[0]) {
      ranges.push(`<=${max2}`);
    } else {
      ranges.push(`${min2} - ${max2}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const simplify$1 = /* @__PURE__ */ getDefaultExportFromCjs(simplify);
const simplify$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: simplify$1
}, [simplify]);
const require$$39 = /* @__PURE__ */ getAugmentedNamespace(simplify$2);
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = require$$29;
const compare$2 = require$$13$3;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c2 of sub) {
    if (c2.operator === ">" || c2.operator === ">=") {
      gt2 = higherGT(gt2, c2, options);
    } else if (c2.operator === "<" || c2.operator === "<=") {
      lt2 = lowerLT(lt2, c2, options);
    } else {
      eqSet.add(c2.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$2(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq5 of eqSet) {
    if (gt2 && !satisfies$1(eq5, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq5, String(lt2), options)) {
      return null;
    }
    for (const c2 of dom) {
      if (!satisfies$1(eq5, String(c2), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c2 of dom) {
    hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
    hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c2.operator === ">" || c2.operator === ">=") {
        higher = higherGT(gt2, c2, options);
        if (higher === c2 && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c2), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c2.operator === "<" || c2.operator === "<=") {
        lower = lowerLT(lt2, c2, options);
        if (lower === c2 && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c2), options)) {
        return false;
      }
    }
    if (!c2.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a3, b4, options) => {
  if (!a3) {
    return b4;
  }
  const comp = compare$2(a3.semver, b4.semver, options);
  return comp > 0 ? a3 : comp < 0 ? b4 : b4.operator === ">" && a3.operator === ">=" ? b4 : a3;
};
const lowerLT = (a3, b4, options) => {
  if (!a3) {
    return b4;
  }
  const comp = compare$2(a3.semver, b4.semver, options);
  return comp < 0 ? a3 : comp > 0 ? b4 : b4.operator === "<" && a3.operator === "<=" ? b4 : a3;
};
var subset_1 = subset$1;
const subset$2 = /* @__PURE__ */ getDefaultExportFromCjs(subset_1);
const subset$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: subset$2
}, [subset_1]);
const require$$40 = /* @__PURE__ */ getAugmentedNamespace(subset$3);
const internalRe = require$$0$G;
const constants$1 = require$$1$l;
const SemVer = require$$2$f;
const identifiers = require$$3$a;
const parse = require$$4$9;
const valid = require$$5$7;
const clean = require$$6$6;
const inc = require$$7$2;
const diff = require$$8$2;
const major = require$$9$1;
const minor = require$$10$1;
const patch = require$$11$1;
const prerelease = require$$12$3;
const compare$1 = require$$13$3;
const rcompare = require$$14$1;
const compareLoose = require$$15$1;
const compareBuild = require$$16;
const sort = require$$17;
const rsort = require$$18;
const gt = require$$19;
const lt = require$$20;
const eq = require$$21;
const neq = require$$22;
const gte = require$$23;
const lte = require$$24;
const cmp = require$$25;
const coerce = require$$26;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = require$$29;
const toComparators = require$$30;
const maxSatisfying = require$$31;
const minSatisfying = require$$32;
const minVersion = require$$33;
const validRange = require$$34;
const outside = require$$35;
const gtr = require$$36;
const ltr = require$$37;
const intersects = require$$38;
const simplifyRange = require$$39;
const subset = require$$40;
var semver = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare: compare$1,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants$1.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants$1.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
const index$m = /* @__PURE__ */ getDefaultExportFromCjs(semver);
const semver$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$m
}, [semver]);
const require$$0$C = /* @__PURE__ */ getAugmentedNamespace(semver$1);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.satisfiesVersionRange = exports2.gtRange = exports2.gtVersion = exports2.assertIsSemVerRange = exports2.assertIsSemVerVersion = exports2.isValidSemVerRange = exports2.isValidSemVerVersion = exports2.VersionRangeStruct = exports2.VersionStruct = void 0;
  const semver_1 = require$$0$C;
  const superstruct_12 = require$$1$n;
  const assert_12 = require$$0$J;
  exports2.VersionStruct = (0, superstruct_12.refine)((0, superstruct_12.string)(), "Version", (value) => {
    if ((0, semver_1.valid)(value) === null) {
      return `Expected SemVer version, got "${value}"`;
    }
    return true;
  });
  exports2.VersionRangeStruct = (0, superstruct_12.refine)((0, superstruct_12.string)(), "Version range", (value) => {
    if ((0, semver_1.validRange)(value) === null) {
      return `Expected SemVer range, got "${value}"`;
    }
    return true;
  });
  function isValidSemVerVersion(version2) {
    return (0, superstruct_12.is)(version2, exports2.VersionStruct);
  }
  exports2.isValidSemVerVersion = isValidSemVerVersion;
  function isValidSemVerRange(versionRange) {
    return (0, superstruct_12.is)(versionRange, exports2.VersionRangeStruct);
  }
  exports2.isValidSemVerRange = isValidSemVerRange;
  function assertIsSemVerVersion(version2) {
    (0, assert_12.assertStruct)(version2, exports2.VersionStruct);
  }
  exports2.assertIsSemVerVersion = assertIsSemVerVersion;
  function assertIsSemVerRange(range2) {
    (0, assert_12.assertStruct)(range2, exports2.VersionRangeStruct);
  }
  exports2.assertIsSemVerRange = assertIsSemVerRange;
  function gtVersion(version1, version2) {
    return (0, semver_1.gt)(version1, version2);
  }
  exports2.gtVersion = gtVersion;
  function gtRange(version2, range2) {
    return (0, semver_1.gtr)(version2, range2);
  }
  exports2.gtRange = gtRange;
  function satisfiesVersionRange(version2, versionRange) {
    return (0, semver_1.satisfies)(version2, versionRange, {
      includePrerelease: true
    });
  }
  exports2.satisfiesVersionRange = satisfiesVersionRange;
})(versions$2);
const versions = /* @__PURE__ */ getDefaultExportFromCjs(versions$2);
const versions$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: versions
}, [versions$2]);
const require$$13$2 = /* @__PURE__ */ getAugmentedNamespace(versions$1);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
    if (k22 === void 0)
      k22 = k3;
    var desc = Object.getOwnPropertyDescriptor(m2, k3);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k3];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k3, k22) {
    if (k22 === void 0)
      k22 = k3;
    o2[k22] = m2[k3];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p3 in m2)
      if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
        __createBinding2(exports3, m2, p3);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require$$0$J, exports2);
  __exportStar(require$$1$m, exports2);
  __exportStar(require$$2$g, exports2);
  __exportStar(require$$3$c, exports2);
  __exportStar(require$$4$a, exports2);
  __exportStar(require$$5$8, exports2);
  __exportStar(require$$6$7, exports2);
  __exportStar(require$$7$3, exports2);
  __exportStar(require$$8$3, exports2);
  __exportStar(require$$9$2, exports2);
  __exportStar(require$$10$2, exports2);
  __exportStar(require$$11$2, exports2);
  __exportStar(require$$12$4, exports2);
  __exportStar(require$$13$2, exports2);
})(dist$7);
const index$l = /* @__PURE__ */ getDefaultExportFromCjs(dist$7);
const dist$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$l
}, [dist$7]);
const require$$0$B = /* @__PURE__ */ getAugmentedNamespace(dist$5);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.createModuleLogger = exports2.projectLogger = void 0;
  const utils_12 = require$$0$B;
  Object.defineProperty(exports2, "createModuleLogger", { enumerable: true, get: function() {
    return utils_12.createModuleLogger;
  } });
  exports2.projectLogger = (0, utils_12.createProjectLogger)("eth-block-tracker");
})(loggingUtils$2);
const loggingUtils = /* @__PURE__ */ getDefaultExportFromCjs(loggingUtils$2);
const loggingUtils$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: loggingUtils
}, [loggingUtils$2]);
const require$$3$9 = /* @__PURE__ */ getAugmentedNamespace(loggingUtils$1);
var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(PollingBlockTracker$2, "__esModule", { value: true });
var PollingBlockTracker_2 = PollingBlockTracker$2.PollingBlockTracker = void 0;
const json_rpc_random_id_1$1 = __importDefault$a(require$$1$q);
const pify_1 = __importDefault$a(require$$1$p);
const BaseBlockTracker_1$1 = require$$1$o;
const logging_utils_1 = require$$3$9;
const log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, "polling-block-tracker");
const createRandomId$2 = (0, json_rpc_random_id_1$1.default)();
const sec = 1e3;
class PollingBlockTracker extends BaseBlockTracker_1$1.BaseBlockTracker {
  constructor(opts = {}) {
    var _a2;
    if (!opts.provider) {
      throw new Error("PollingBlockTracker - no provider specified.");
    }
    super({
      blockResetDuration: (_a2 = opts.blockResetDuration) !== null && _a2 !== void 0 ? _a2 : opts.pollingInterval
    });
    this._provider = opts.provider;
    this._pollingInterval = opts.pollingInterval || 20 * sec;
    this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;
    this._keepEventLoopActive = opts.keepEventLoopActive === void 0 ? true : opts.keepEventLoopActive;
    this._setSkipCacheFlag = opts.setSkipCacheFlag || false;
  }
  // trigger block polling
  async checkForLatestBlock() {
    await this._updateLatestBlock();
    return await this.getLatestBlock();
  }
  async _start() {
    this._synchronize();
  }
  async _end() {
  }
  async _synchronize() {
    var _a2;
    while (this._isRunning) {
      try {
        await this._updateLatestBlock();
        const promise = timeout$1(this._pollingInterval, !this._keepEventLoopActive);
        this.emit("_waitingForNextIteration");
        await promise;
      } catch (err) {
        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${(_a2 = err.stack) !== null && _a2 !== void 0 ? _a2 : err}`);
        try {
          this.emit("error", newErr);
        } catch (emitErr) {
          console.error(newErr);
        }
        const promise = timeout$1(this._retryTimeout, !this._keepEventLoopActive);
        this.emit("_waitingForNextIteration");
        await promise;
      }
    }
  }
  async _updateLatestBlock() {
    const latestBlock = await this._fetchLatestBlock();
    this._newPotentialLatest(latestBlock);
  }
  async _fetchLatestBlock() {
    const req = {
      jsonrpc: "2.0",
      id: createRandomId$2(),
      method: "eth_blockNumber",
      params: []
    };
    if (this._setSkipCacheFlag) {
      req.skipCache = true;
    }
    log("Making request", req);
    const res = await (0, pify_1.default)((cb2) => this._provider.sendAsync(req, cb2))();
    log("Got response", res);
    if (res.error) {
      throw new Error(`PollingBlockTracker - encountered error fetching block:
${res.error.message}`);
    }
    return res.result;
  }
}
PollingBlockTracker_2 = PollingBlockTracker$2.PollingBlockTracker = PollingBlockTracker;
function timeout$1(duration, unref) {
  return new Promise((resolve) => {
    const timeoutRef = setTimeout(resolve, duration);
    if (timeoutRef.unref && unref) {
      timeoutRef.unref();
    }
  });
}
const PollingBlockTracker$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get PollingBlockTracker() {
    return PollingBlockTracker_2;
  },
  default: PollingBlockTracker$2
}, [PollingBlockTracker$2]);
const require$$0$A = /* @__PURE__ */ getAugmentedNamespace(PollingBlockTracker$1);
var SubscribeBlockTracker$2 = {};
var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(SubscribeBlockTracker$2, "__esModule", { value: true });
var SubscribeBlockTracker_2 = SubscribeBlockTracker$2.SubscribeBlockTracker = void 0;
const json_rpc_random_id_1 = __importDefault$9(require$$1$q);
const BaseBlockTracker_1 = require$$1$o;
const createRandomId$1 = (0, json_rpc_random_id_1.default)();
class SubscribeBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {
  constructor(opts = {}) {
    if (!opts.provider) {
      throw new Error("SubscribeBlockTracker - no provider specified.");
    }
    super(opts);
    this._provider = opts.provider;
    this._subscriptionId = null;
  }
  async checkForLatestBlock() {
    return await this.getLatestBlock();
  }
  async _start() {
    if (this._subscriptionId === void 0 || this._subscriptionId === null) {
      try {
        const blockNumber = await this._call("eth_blockNumber");
        this._subscriptionId = await this._call("eth_subscribe", "newHeads");
        this._provider.on("data", this._handleSubData.bind(this));
        this._newPotentialLatest(blockNumber);
      } catch (e2) {
        this.emit("error", e2);
      }
    }
  }
  async _end() {
    if (this._subscriptionId !== null && this._subscriptionId !== void 0) {
      try {
        await this._call("eth_unsubscribe", this._subscriptionId);
        this._subscriptionId = null;
      } catch (e2) {
        this.emit("error", e2);
      }
    }
  }
  _call(method, ...params) {
    return new Promise((resolve, reject) => {
      this._provider.sendAsync({
        id: createRandomId$1(),
        method,
        params,
        jsonrpc: "2.0"
      }, (err, res) => {
        if (err) {
          reject(err);
        } else {
          resolve(res.result);
        }
      });
    });
  }
  _handleSubData(_3, response) {
    var _a2;
    if (response.method === "eth_subscription" && ((_a2 = response.params) === null || _a2 === void 0 ? void 0 : _a2.subscription) === this._subscriptionId) {
      this._newPotentialLatest(response.params.result.number);
    }
  }
}
SubscribeBlockTracker_2 = SubscribeBlockTracker$2.SubscribeBlockTracker = SubscribeBlockTracker;
const SubscribeBlockTracker$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get SubscribeBlockTracker() {
    return SubscribeBlockTracker_2;
  },
  default: SubscribeBlockTracker$2
}, [SubscribeBlockTracker$2]);
const require$$1$k = /* @__PURE__ */ getAugmentedNamespace(SubscribeBlockTracker$1);
var types$2 = {};
Object.defineProperty(types$2, "__esModule", { value: true });
const types$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: types$2
}, [types$2]);
const require$$2$e = /* @__PURE__ */ getAugmentedNamespace(types$1);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
    if (k22 === void 0)
      k22 = k3;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k3];
    } });
  } : function(o2, m2, k3, k22) {
    if (k22 === void 0)
      k22 = k3;
    o2[k22] = m2[k3];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p3 in m2)
      if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
        __createBinding2(exports3, m2, p3);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require$$0$A, exports2);
  __exportStar(require$$1$k, exports2);
  __exportStar(require$$2$e, exports2);
})(dist$8);
const index$k = /* @__PURE__ */ getDefaultExportFromCjs(dist$8);
const dist$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$k
}, [dist$8]);
const require$$0$z = /* @__PURE__ */ getAugmentedNamespace(dist$4);
var dist$3 = {};
var idRemapMiddleware$1 = {};
var getUniqueId$2 = {};
Object.defineProperty(getUniqueId$2, "__esModule", { value: true });
var getUniqueId_2 = getUniqueId$2.getUniqueId = void 0;
const MAX = 4294967295;
let idCounter$1 = Math.floor(Math.random() * MAX);
function getUniqueId() {
  idCounter$1 = (idCounter$1 + 1) % MAX;
  return idCounter$1;
}
getUniqueId_2 = getUniqueId$2.getUniqueId = getUniqueId;
const getUniqueId$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getUniqueId$2,
  get getUniqueId() {
    return getUniqueId_2;
  }
}, [getUniqueId$2]);
const require$$3$8 = /* @__PURE__ */ getAugmentedNamespace(getUniqueId$1);
Object.defineProperty(idRemapMiddleware$1, "__esModule", { value: true });
var createIdRemapMiddleware_1 = idRemapMiddleware$1.createIdRemapMiddleware = void 0;
const getUniqueId_1 = require$$3$8;
function createIdRemapMiddleware() {
  return (req, res, next, _end) => {
    const originalId = req.id;
    const newId = getUniqueId_1.getUniqueId();
    req.id = newId;
    res.id = newId;
    next((done2) => {
      req.id = originalId;
      res.id = originalId;
      done2();
    });
  };
}
createIdRemapMiddleware_1 = idRemapMiddleware$1.createIdRemapMiddleware = createIdRemapMiddleware;
const idRemapMiddleware = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createIdRemapMiddleware() {
    return createIdRemapMiddleware_1;
  },
  default: idRemapMiddleware$1
}, [idRemapMiddleware$1]);
const require$$0$y = /* @__PURE__ */ getAugmentedNamespace(idRemapMiddleware);
var createAsyncMiddleware$4 = {};
Object.defineProperty(createAsyncMiddleware$4, "__esModule", { value: true });
var createAsyncMiddleware_2 = createAsyncMiddleware$4.createAsyncMiddleware = void 0;
function createAsyncMiddleware$2(asyncMiddleware) {
  return async (req, res, next, end2) => {
    let resolveNextPromise;
    const nextPromise = new Promise((resolve) => {
      resolveNextPromise = resolve;
    });
    let returnHandlerCallback = null;
    let nextWasCalled = false;
    const asyncNext = async () => {
      nextWasCalled = true;
      next((runReturnHandlersCallback) => {
        returnHandlerCallback = runReturnHandlersCallback;
        resolveNextPromise();
      });
      await nextPromise;
    };
    try {
      await asyncMiddleware(req, res, asyncNext);
      if (nextWasCalled) {
        await nextPromise;
        returnHandlerCallback(null);
      } else {
        end2(null);
      }
    } catch (error) {
      if (returnHandlerCallback) {
        returnHandlerCallback(error);
      } else {
        end2(error);
      }
    }
  };
}
createAsyncMiddleware_2 = createAsyncMiddleware$4.createAsyncMiddleware = createAsyncMiddleware$2;
const createAsyncMiddleware$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createAsyncMiddleware() {
    return createAsyncMiddleware_2;
  },
  default: createAsyncMiddleware$4
}, [createAsyncMiddleware$4]);
const require$$1$j = /* @__PURE__ */ getAugmentedNamespace(createAsyncMiddleware$3);
var createScaffoldMiddleware$4 = {};
Object.defineProperty(createScaffoldMiddleware$4, "__esModule", { value: true });
var createScaffoldMiddleware_2 = createScaffoldMiddleware$4.createScaffoldMiddleware = void 0;
function createScaffoldMiddleware$2(handlers) {
  return (req, res, next, end2) => {
    const handler = handlers[req.method];
    if (handler === void 0) {
      return next();
    }
    if (typeof handler === "function") {
      return handler(req, res, next, end2);
    }
    res.result = handler;
    return end2();
  };
}
createScaffoldMiddleware_2 = createScaffoldMiddleware$4.createScaffoldMiddleware = createScaffoldMiddleware$2;
const createScaffoldMiddleware$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createScaffoldMiddleware() {
    return createScaffoldMiddleware_2;
  },
  default: createScaffoldMiddleware$4
}, [createScaffoldMiddleware$4]);
const require$$2$d = /* @__PURE__ */ getAugmentedNamespace(createScaffoldMiddleware$3);
var JsonRpcEngine$2 = {};
var dist$2 = {};
var classes$1 = {};
Object.defineProperty(classes$1, "__esModule", { value: true });
var EthereumProviderError_1 = classes$1.EthereumProviderError = EthereumRpcError_1 = classes$1.EthereumRpcError = void 0;
const fast_safe_stringify_1 = require$$0$13;
class EthereumRpcError extends Error {
  constructor(code2, message, data2) {
    if (!Number.isInteger(code2)) {
      throw new Error('"code" must be an integer.');
    }
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a nonempty string.');
    }
    super(message);
    this.code = code2;
    if (data2 !== void 0) {
      this.data = data2;
    }
  }
  /**
   * Returns a plain object with all public class properties.
   */
  serialize() {
    const serialized = {
      code: this.code,
      message: this.message
    };
    if (this.data !== void 0) {
      serialized.data = this.data;
    }
    if (this.stack) {
      serialized.stack = this.stack;
    }
    return serialized;
  }
  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   */
  toString() {
    return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer$1, 2);
  }
}
var EthereumRpcError_1 = classes$1.EthereumRpcError = EthereumRpcError;
class EthereumProviderError extends EthereumRpcError {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(code2, message, data2) {
    if (!isValidEthProviderCode(code2)) {
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    }
    super(code2, message, data2);
  }
}
EthereumProviderError_1 = classes$1.EthereumProviderError = EthereumProviderError;
function isValidEthProviderCode(code2) {
  return Number.isInteger(code2) && code2 >= 1e3 && code2 <= 4999;
}
function stringifyReplacer$1(_3, value) {
  if (value === "[Circular]") {
    return void 0;
  }
  return value;
}
const classes = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get EthereumProviderError() {
    return EthereumProviderError_1;
  },
  get EthereumRpcError() {
    return EthereumRpcError_1;
  },
  default: classes$1
}, [classes$1]);
const require$$0$x = /* @__PURE__ */ getAugmentedNamespace(classes);
var utils$2 = {};
var errorConstants$1 = {};
Object.defineProperty(errorConstants$1, "__esModule", { value: true });
var errorValues = errorConstants$1.errorValues = errorCodes = errorConstants$1.errorCodes = void 0;
var errorCodes = errorConstants$1.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
errorValues = errorConstants$1.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  "4001": {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  "4100": {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  "4200": {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  "4900": {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  "4901": {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
const errorConstants = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: errorConstants$1,
  get errorCodes() {
    return errorCodes;
  },
  get errorValues() {
    return errorValues;
  }
}, [errorConstants$1]);
const require$$3$7 = /* @__PURE__ */ getAugmentedNamespace(errorConstants);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.serializeError = exports2.isValidCode = exports2.getMessageFromCode = exports2.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const error_constants_12 = require$$3$7;
  const classes_12 = require$$0$x;
  const FALLBACK_ERROR_CODE = error_constants_12.errorCodes.rpc.internal;
  const FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
  const FALLBACK_ERROR = {
    code: FALLBACK_ERROR_CODE,
    message: getMessageFromCode(FALLBACK_ERROR_CODE)
  };
  exports2.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function getMessageFromCode(code2, fallbackMessage = FALLBACK_MESSAGE) {
    if (Number.isInteger(code2)) {
      const codeString = code2.toString();
      if (hasKey(error_constants_12.errorValues, codeString)) {
        return error_constants_12.errorValues[codeString].message;
      }
      if (isJsonRpcServerError(code2)) {
        return exports2.JSON_RPC_SERVER_ERROR_MESSAGE;
      }
    }
    return fallbackMessage;
  }
  exports2.getMessageFromCode = getMessageFromCode;
  function isValidCode(code2) {
    if (!Number.isInteger(code2)) {
      return false;
    }
    const codeString = code2.toString();
    if (error_constants_12.errorValues[codeString]) {
      return true;
    }
    if (isJsonRpcServerError(code2)) {
      return true;
    }
    return false;
  }
  exports2.isValidCode = isValidCode;
  function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
    var _a2, _b;
    if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
      throw new Error("Must provide fallback error with integer number code and string message.");
    }
    if (error instanceof classes_12.EthereumRpcError) {
      return error.serialize();
    }
    const serialized = {};
    if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
      const _error = error;
      serialized.code = _error.code;
      if (_error.message && typeof _error.message === "string") {
        serialized.message = _error.message;
        if (hasKey(_error, "data")) {
          serialized.data = _error.data;
        }
      } else {
        serialized.message = getMessageFromCode(serialized.code);
        serialized.data = { originalError: assignOriginalError(error) };
      }
    } else {
      serialized.code = fallbackError.code;
      const message = (_a2 = error) === null || _a2 === void 0 ? void 0 : _a2.message;
      serialized.message = message && typeof message === "string" ? message : fallbackError.message;
      serialized.data = { originalError: assignOriginalError(error) };
    }
    const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
    if (shouldIncludeStack && error && stack && typeof stack === "string") {
      serialized.stack = stack;
    }
    return serialized;
  }
  exports2.serializeError = serializeError;
  function isJsonRpcServerError(code2) {
    return code2 >= -32099 && code2 <= -32e3;
  }
  function assignOriginalError(error) {
    if (error && typeof error === "object" && !Array.isArray(error)) {
      return Object.assign({}, error);
    }
    return error;
  }
  function hasKey(obj, key2) {
    return Object.prototype.hasOwnProperty.call(obj, key2);
  }
})(utils$2);
const utils = /* @__PURE__ */ getDefaultExportFromCjs(utils$2);
const utils$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils
}, [utils$2]);
const require$$1$i = /* @__PURE__ */ getAugmentedNamespace(utils$1);
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: true });
var ethErrors = errors$1.ethErrors = void 0;
const classes_1 = require$$0$x;
const utils_1 = require$$1$i;
const error_constants_1 = require$$3$7;
ethErrors = errors$1.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      }
      const { code: code2 } = opts;
      if (!Number.isInteger(code2) || code2 > -32005 || code2 < -32099) {
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      }
      return getEthJsonRpcError(code2, opts);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
    },
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
    },
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
    },
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
    },
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
    },
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      }
      const { code: code2, message, data: data2 } = opts;
      if (!message || typeof message !== "string") {
        throw new Error('"message" must be a nonempty string');
      }
      return new classes_1.EthereumProviderError(code2, message, data2);
    }
  }
};
function getEthJsonRpcError(code2, arg) {
  const [message, data2] = parseOpts(arg);
  return new classes_1.EthereumRpcError(code2, message || utils_1.getMessageFromCode(code2), data2);
}
function getEthProviderError(code2, arg) {
  const [message, data2] = parseOpts(arg);
  return new classes_1.EthereumProviderError(code2, message || utils_1.getMessageFromCode(code2), data2);
}
function parseOpts(arg) {
  if (arg) {
    if (typeof arg === "string") {
      return [arg];
    } else if (typeof arg === "object" && !Array.isArray(arg)) {
      const { message, data: data2 } = arg;
      if (message && typeof message !== "string") {
        throw new Error("Must specify string message.");
      }
      return [message || void 0, data2];
    }
  }
  return [];
}
const errors = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: errors$1,
  get ethErrors() {
    return ethErrors;
  }
}, [errors$1]);
const require$$2$c = /* @__PURE__ */ getAugmentedNamespace(errors);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getMessageFromCode = exports2.serializeError = exports2.EthereumProviderError = exports2.EthereumRpcError = exports2.ethErrors = exports2.errorCodes = void 0;
  const classes_12 = require$$0$x;
  Object.defineProperty(exports2, "EthereumRpcError", { enumerable: true, get: function() {
    return classes_12.EthereumRpcError;
  } });
  Object.defineProperty(exports2, "EthereumProviderError", { enumerable: true, get: function() {
    return classes_12.EthereumProviderError;
  } });
  const utils_12 = require$$1$i;
  Object.defineProperty(exports2, "serializeError", { enumerable: true, get: function() {
    return utils_12.serializeError;
  } });
  Object.defineProperty(exports2, "getMessageFromCode", { enumerable: true, get: function() {
    return utils_12.getMessageFromCode;
  } });
  const errors_12 = require$$2$c;
  Object.defineProperty(exports2, "ethErrors", { enumerable: true, get: function() {
    return errors_12.ethErrors;
  } });
  const error_constants_12 = require$$3$7;
  Object.defineProperty(exports2, "errorCodes", { enumerable: true, get: function() {
    return error_constants_12.errorCodes;
  } });
})(dist$2);
const index$j = /* @__PURE__ */ getDefaultExportFromCjs(dist$2);
const dist$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$j
}, [dist$2]);
const require$$1$h = /* @__PURE__ */ getAugmentedNamespace(dist$1);
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(JsonRpcEngine$2, "__esModule", { value: true });
var JsonRpcEngine_2 = JsonRpcEngine$2.JsonRpcEngine = void 0;
const safe_event_emitter_1$1 = __importDefault$8(require$$0$14);
const eth_rpc_errors_1 = require$$1$h;
class JsonRpcEngine extends safe_event_emitter_1$1.default {
  constructor() {
    super();
    this._middleware = [];
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(middleware) {
    this._middleware.push(middleware);
  }
  handle(req, cb2) {
    if (cb2 && typeof cb2 !== "function") {
      throw new Error('"callback" must be a function if provided.');
    }
    if (Array.isArray(req)) {
      if (cb2) {
        return this._handleBatch(req, cb2);
      }
      return this._handleBatch(req);
    }
    if (cb2) {
      return this._handle(req, cb2);
    }
    return this._promiseHandle(req);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (req, res, next, end2) => {
      try {
        const [middlewareError, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        if (isComplete) {
          await JsonRpcEngine._runReturnHandlers(returnHandlers);
          return end2(middlewareError);
        }
        return next(async (handlerCallback) => {
          try {
            await JsonRpcEngine._runReturnHandlers(returnHandlers);
          } catch (error) {
            return handlerCallback(error);
          }
          return handlerCallback();
        });
      } catch (error) {
        return end2(error);
      }
    };
  }
  async _handleBatch(reqs, cb2) {
    try {
      const responses = await Promise.all(
        // 1. Begin executing each request in the order received
        reqs.map(this._promiseHandle.bind(this))
      );
      if (cb2) {
        return cb2(null, responses);
      }
      return responses;
    } catch (error) {
      if (cb2) {
        return cb2(error);
      }
      throw error;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(req) {
    return new Promise((resolve) => {
      this._handle(req, (_err, res) => {
        resolve(res);
      });
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(callerReq, cb2) {
    if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
      const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
      return cb2(error2, { id: void 0, jsonrpc: "2.0", error: error2 });
    }
    if (typeof callerReq.method !== "string") {
      const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
      return cb2(error2, { id: callerReq.id, jsonrpc: "2.0", error: error2 });
    }
    const req = Object.assign({}, callerReq);
    const res = {
      id: req.id,
      jsonrpc: req.jsonrpc
    };
    let error = null;
    try {
      await this._processRequest(req, res);
    } catch (_error) {
      error = _error;
    }
    if (error) {
      delete res.result;
      if (!res.error) {
        res.error = eth_rpc_errors_1.serializeError(error);
      }
    }
    return cb2(error, res);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(req, res) {
    const [error, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
    JsonRpcEngine._checkForCompletion(req, res, isComplete);
    await JsonRpcEngine._runReturnHandlers(returnHandlers);
    if (error) {
      throw error;
    }
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(req, res, middlewareStack) {
    const returnHandlers = [];
    let error = null;
    let isComplete = false;
    for (const middleware of middlewareStack) {
      [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
      if (isComplete) {
        break;
      }
    }
    return [error, isComplete, returnHandlers.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware exection,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(req, res, middleware, returnHandlers) {
    return new Promise((resolve) => {
      const end2 = (err) => {
        const error = err || res.error;
        if (error) {
          res.error = eth_rpc_errors_1.serializeError(error);
        }
        resolve([error, true]);
      };
      const next = (returnHandler) => {
        if (res.error) {
          end2(res.error);
        } else {
          if (returnHandler) {
            if (typeof returnHandler !== "function") {
              end2(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof returnHandler}" for request:
${jsonify(req)}`, { request: req }));
            }
            returnHandlers.push(returnHandler);
          }
          resolve([null, false]);
        }
      };
      try {
        middleware(req, res, next, end2);
      } catch (error) {
        end2(error);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(handlers) {
    for (const handler of handlers) {
      await new Promise((resolve, reject) => {
        handler((err) => err ? reject(err) : resolve());
      });
    }
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(req, res, isComplete) {
    if (!("result" in res) && !("error" in res)) {
      throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${jsonify(req)}`, { request: req });
    }
    if (!isComplete) {
      throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${jsonify(req)}`, { request: req });
    }
  }
}
JsonRpcEngine_2 = JsonRpcEngine$2.JsonRpcEngine = JsonRpcEngine;
function jsonify(request) {
  return JSON.stringify(request, null, 2);
}
const JsonRpcEngine$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get JsonRpcEngine() {
    return JsonRpcEngine_2;
  },
  default: JsonRpcEngine$2
}, [JsonRpcEngine$2]);
const require$$4$8 = /* @__PURE__ */ getAugmentedNamespace(JsonRpcEngine$1);
var mergeMiddleware$2 = {};
Object.defineProperty(mergeMiddleware$2, "__esModule", { value: true });
var mergeMiddleware_2 = mergeMiddleware$2.mergeMiddleware = void 0;
const JsonRpcEngine_1 = require$$4$8;
function mergeMiddleware(middlewareStack) {
  const engine = new JsonRpcEngine_1.JsonRpcEngine();
  middlewareStack.forEach((middleware) => engine.push(middleware));
  return engine.asMiddleware();
}
mergeMiddleware_2 = mergeMiddleware$2.mergeMiddleware = mergeMiddleware;
const mergeMiddleware$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: mergeMiddleware$2,
  get mergeMiddleware() {
    return mergeMiddleware_2;
  }
}, [mergeMiddleware$2]);
const require$$5$6 = /* @__PURE__ */ getAugmentedNamespace(mergeMiddleware$1);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
    if (k22 === void 0)
      k22 = k3;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k3];
    } });
  } : function(o2, m2, k3, k22) {
    if (k22 === void 0)
      k22 = k3;
    o2[k22] = m2[k3];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p3 in m2)
      if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
        __createBinding2(exports3, m2, p3);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require$$0$y, exports2);
  __exportStar(require$$1$j, exports2);
  __exportStar(require$$2$d, exports2);
  __exportStar(require$$3$8, exports2);
  __exportStar(require$$4$8, exports2);
  __exportStar(require$$5$6, exports2);
})(dist$3);
const index$i = /* @__PURE__ */ getDefaultExportFromCjs(dist$3);
const dist = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$i
}, [dist$3]);
const require$$1$g = /* @__PURE__ */ getAugmentedNamespace(dist);
var lib$1 = {};
var Mutex$3 = {};
var tslib$2 = { exports: {} };
(function(module2) {
  var __extends2;
  var __assign2;
  var __rest2;
  var __decorate2;
  var __param;
  var __metadata;
  var __awaiter2;
  var __generator2;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray2;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar2;
  var __importDefault2;
  var __classPrivateFieldGet2;
  var __classPrivateFieldSet2;
  var __classPrivateFieldIn;
  var __createBinding2;
  (function(factory2) {
    var root2 = typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : {};
    {
      factory2(createExporter(root2, createExporter(module2.exports)));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root2) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id2, v4) {
        return exports2[id2] = previous ? previous(id2, v4) : v4;
      };
    }
  })(function(exporter) {
    var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
      d3.__proto__ = b4;
    } || function(d3, b4) {
      for (var p3 in b4)
        if (Object.prototype.hasOwnProperty.call(b4, p3))
          d3[p3] = b4[p3];
    };
    __extends2 = function(d3, b4) {
      if (typeof b4 !== "function" && b4 !== null)
        throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
      extendStatics2(d3, b4);
      function __2() {
        this.constructor = d3;
      }
      d3.prototype = b4 === null ? Object.create(b4) : (__2.prototype = b4.prototype, new __2());
    };
    __assign2 = Object.assign || function(t2) {
      for (var s3, i3 = 1, n4 = arguments.length; i3 < n4; i3++) {
        s3 = arguments[i3];
        for (var p3 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p3))
            t2[p3] = s3[p3];
      }
      return t2;
    };
    __rest2 = function(s3, e2) {
      var t2 = {};
      for (var p3 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p3) && e2.indexOf(p3) < 0)
          t2[p3] = s3[p3];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
          if (e2.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
            t2[p3[i3]] = s3[p3[i3]];
        }
      return t2;
    };
    __decorate2 = function(decorators, target, key2, desc) {
      var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r2 = Reflect.decorate(decorators, target, key2, desc);
      else
        for (var i3 = decorators.length - 1; i3 >= 0; i3--)
          if (d3 = decorators[i3])
            r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
      return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key2) {
        decorator(target, key2, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter2 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator2 = function(thisArg, body) {
      var _3 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f4, y3, t2, g3;
      return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
        return this;
      }), g3;
      function verb(n4) {
        return function(v4) {
          return step([n4, v4]);
        };
      }
      function step(op) {
        if (f4)
          throw new TypeError("Generator is already executing.");
        while (_3)
          try {
            if (f4 = 1, y3 && (t2 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t2 = y3["return"]) && t2.call(y3), 0) : y3.next) && !(t2 = t2.call(y3, op[1])).done)
              return t2;
            if (y3 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _3.label++;
                return { value: op[1], done: false };
              case 5:
                _3.label++;
                y3 = op[1];
                op = [0];
                continue;
              case 7:
                op = _3.ops.pop();
                _3.trys.pop();
                continue;
              default:
                if (!(t2 = _3.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _3 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _3.label = op[1];
                  break;
                }
                if (op[0] === 6 && _3.label < t2[1]) {
                  _3.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _3.label < t2[2]) {
                  _3.label = t2[2];
                  _3.ops.push(op);
                  break;
                }
                if (t2[2])
                  _3.ops.pop();
                _3.trys.pop();
                continue;
            }
            op = body.call(thisArg, _3);
          } catch (e2) {
            op = [6, e2];
            y3 = 0;
          } finally {
            f4 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __exportStar = function(m2, o2) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p3))
          __createBinding2(o2, m2, p3);
    };
    __createBinding2 = Object.create ? function(o2, m2, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m2, k3);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k3];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o2[k22] = m2[k3];
    };
    __values = function(o2) {
      var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o2[s3], i3 = 0;
      if (m2)
        return m2.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i3 >= o2.length)
              o2 = void 0;
            return { value: o2 && o2[i3++], done: !o2 };
          }
        };
      throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o2, n4) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2)
        return o2;
      var i3 = m2.call(o2), r2, ar2 = [], e2;
      try {
        while ((n4 === void 0 || n4-- > 0) && !(r2 = i3.next()).done)
          ar2.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i3["return"]))
            m2.call(i3);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar2;
    };
    __spread = function() {
      for (var ar2 = [], i3 = 0; i3 < arguments.length; i3++)
        ar2 = ar2.concat(__read(arguments[i3]));
      return ar2;
    };
    __spreadArrays = function() {
      for (var s3 = 0, i3 = 0, il2 = arguments.length; i3 < il2; i3++)
        s3 += arguments[i3].length;
      for (var r2 = Array(s3), k3 = 0, i3 = 0; i3 < il2; i3++)
        for (var a3 = arguments[i3], j2 = 0, jl2 = a3.length; j2 < jl2; j2++, k3++)
          r2[k3] = a3[j2];
      return r2;
    };
    __spreadArray2 = function(to, from2, pack2) {
      if (pack2 || arguments.length === 2)
        for (var i3 = 0, l2 = from2.length, ar2; i3 < l2; i3++) {
          if (ar2 || !(i3 in from2)) {
            if (!ar2)
              ar2 = Array.prototype.slice.call(from2, 0, i3);
            ar2[i3] = from2[i3];
          }
        }
      return to.concat(ar2 || Array.prototype.slice.call(from2));
    };
    __await = function(v4) {
      return this instanceof __await ? (this.v = v4, this) : new __await(v4);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g3 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
      return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
        return this;
      }, i3;
      function verb(n4) {
        if (g3[n4])
          i3[n4] = function(v4) {
            return new Promise(function(a3, b4) {
              q2.push([n4, v4, a3, b4]) > 1 || resume(n4, v4);
            });
          };
      }
      function resume(n4, v4) {
        try {
          step(g3[n4](v4));
        } catch (e2) {
          settle(q2[0][3], e2);
        }
      }
      function step(r2) {
        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f4, v4) {
        if (f4(v4), q2.shift(), q2.length)
          resume(q2[0][0], q2[0][1]);
      }
    };
    __asyncDelegator = function(o2) {
      var i3, p3;
      return i3 = {}, verb("next"), verb("throw", function(e2) {
        throw e2;
      }), verb("return"), i3[Symbol.iterator] = function() {
        return this;
      }, i3;
      function verb(n4, f4) {
        i3[n4] = o2[n4] ? function(v4) {
          return (p3 = !p3) ? { value: __await(o2[n4](v4)), done: n4 === "return" } : f4 ? f4(v4) : v4;
        } : f4;
      }
    };
    __asyncValues = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m2 = o2[Symbol.asyncIterator], i3;
      return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
        return this;
      }, i3);
      function verb(n4) {
        i3[n4] = o2[n4] && function(v4) {
          return new Promise(function(resolve, reject) {
            v4 = o2[n4](v4), settle(resolve, reject, v4.done, v4.value);
          });
        };
      }
      function settle(resolve, reject, d3, v4) {
        Promise.resolve(v4).then(function(v5) {
          resolve({ value: v5, done: d3 });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw2) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw2 });
      } else {
        cooked.raw = raw2;
      }
      return cooked;
    };
    var __setModuleDefault2 = Object.create ? function(o2, v4) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v4 });
    } : function(o2, v4) {
      o2["default"] = v4;
    };
    __importStar2 = function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k3 in mod2)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k3))
            __createBinding2(result, mod2, k3);
      }
      __setModuleDefault2(result, mod2);
      return result;
    };
    __importDefault2 = function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    __classPrivateFieldGet2 = function(receiver, state2, kind, f4) {
      if (kind === "a" && !f4)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state2 === "function" ? receiver !== state2 || !f4 : !state2.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state2.get(receiver);
    };
    __classPrivateFieldSet2 = function(receiver, state2, value, kind, f4) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f4)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state2 === "function" ? receiver !== state2 || !f4 : !state2.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state2.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state2, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state2 === "function" ? receiver === state2 : state2.has(receiver);
    };
    exporter("__extends", __extends2);
    exporter("__assign", __assign2);
    exporter("__rest", __rest2);
    exporter("__decorate", __decorate2);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter2);
    exporter("__generator", __generator2);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding2);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray2);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar2);
    exporter("__importDefault", __importDefault2);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
  });
})(tslib$2);
var tslibExports = tslib$2.exports;
const tslib = /* @__PURE__ */ getDefaultExportFromCjs(tslibExports);
const tslib$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: tslib
}, [tslibExports]);
const require$$0$w = /* @__PURE__ */ getAugmentedNamespace(tslib$1);
var Semaphore$2 = {};
Object.defineProperty(Semaphore$2, "__esModule", { value: true });
var tslib_1$2 = require$$0$w;
var Semaphore = (
  /** @class */
  function() {
    function Semaphore2(_maxConcurrency) {
      this._maxConcurrency = _maxConcurrency;
      this._queue = [];
      if (_maxConcurrency <= 0) {
        throw new Error("semaphore must be initialized to a positive value");
      }
      this._value = _maxConcurrency;
    }
    Semaphore2.prototype.acquire = function() {
      var _this = this;
      var locked = this.isLocked();
      var ticket = new Promise(function(r2) {
        return _this._queue.push(r2);
      });
      if (!locked)
        this._dispatch();
      return ticket;
    };
    Semaphore2.prototype.runExclusive = function(callback) {
      return tslib_1$2.__awaiter(this, void 0, void 0, function() {
        var _a2, value, release;
        return tslib_1$2.__generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, this.acquire()];
            case 1:
              _a2 = _b.sent(), value = _a2[0], release = _a2[1];
              _b.label = 2;
            case 2:
              _b.trys.push([2, , 4, 5]);
              return [4, callback(value)];
            case 3:
              return [2, _b.sent()];
            case 4:
              release();
              return [
                7
                /*endfinally*/
              ];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Semaphore2.prototype.isLocked = function() {
      return this._value <= 0;
    };
    Semaphore2.prototype.release = function() {
      if (this._maxConcurrency > 1) {
        throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
      }
      if (this._currentReleaser) {
        var releaser = this._currentReleaser;
        this._currentReleaser = void 0;
        releaser();
      }
    };
    Semaphore2.prototype._dispatch = function() {
      var _this = this;
      var nextConsumer = this._queue.shift();
      if (!nextConsumer)
        return;
      var released = false;
      this._currentReleaser = function() {
        if (released)
          return;
        released = true;
        _this._value++;
        _this._dispatch();
      };
      nextConsumer([this._value--, this._currentReleaser]);
    };
    return Semaphore2;
  }()
);
var _default$c = Semaphore$2.default = Semaphore;
const Semaphore$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$c
}, [Semaphore$2]);
const require$$1$f = /* @__PURE__ */ getAugmentedNamespace(Semaphore$1);
Object.defineProperty(Mutex$3, "__esModule", { value: true });
var tslib_1$1 = require$$0$w;
var Semaphore_1 = require$$1$f;
var Mutex$1 = (
  /** @class */
  function() {
    function Mutex2() {
      this._semaphore = new Semaphore_1.default(1);
    }
    Mutex2.prototype.acquire = function() {
      return tslib_1$1.__awaiter(this, void 0, void 0, function() {
        var _a2, releaser;
        return tslib_1$1.__generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, this._semaphore.acquire()];
            case 1:
              _a2 = _b.sent(), releaser = _a2[1];
              return [2, releaser];
          }
        });
      });
    };
    Mutex2.prototype.runExclusive = function(callback) {
      return this._semaphore.runExclusive(function() {
        return callback();
      });
    };
    Mutex2.prototype.isLocked = function() {
      return this._semaphore.isLocked();
    };
    Mutex2.prototype.release = function() {
      this._semaphore.release();
    };
    return Mutex2;
  }()
);
var _default$b = Mutex$3.default = Mutex$1;
const Mutex$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$b
}, [Mutex$3]);
const require$$0$v = /* @__PURE__ */ getAugmentedNamespace(Mutex$2);
var withTimeout$2 = {};
Object.defineProperty(withTimeout$2, "__esModule", { value: true });
var withTimeout_2 = withTimeout$2.withTimeout = void 0;
var tslib_1 = require$$0$w;
function withTimeout(sync, timeout2, timeoutError) {
  var _this = this;
  if (timeoutError === void 0) {
    timeoutError = new Error("timeout");
  }
  return {
    acquire: function() {
      return new Promise(function(resolve, reject) {
        return tslib_1.__awaiter(_this, void 0, void 0, function() {
          var isTimeout, ticket, release;
          return tslib_1.__generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                isTimeout = false;
                setTimeout(function() {
                  isTimeout = true;
                  reject(timeoutError);
                }, timeout2);
                return [4, sync.acquire()];
              case 1:
                ticket = _a2.sent();
                if (isTimeout) {
                  release = Array.isArray(ticket) ? ticket[1] : ticket;
                  release();
                } else {
                  resolve(ticket);
                }
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    },
    runExclusive: function(callback) {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        var release, ticket;
        return tslib_1.__generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              release = function() {
                return void 0;
              };
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, , 7, 8]);
              return [4, this.acquire()];
            case 2:
              ticket = _a2.sent();
              if (!Array.isArray(ticket))
                return [3, 4];
              release = ticket[1];
              return [4, callback(ticket[0])];
            case 3:
              return [2, _a2.sent()];
            case 4:
              release = ticket;
              return [4, callback()];
            case 5:
              return [2, _a2.sent()];
            case 6:
              return [3, 8];
            case 7:
              release();
              return [
                7
                /*endfinally*/
              ];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    },
    release: function() {
      sync.release();
    },
    isLocked: function() {
      return sync.isLocked();
    }
  };
}
withTimeout_2 = withTimeout$2.withTimeout = withTimeout;
const withTimeout$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: withTimeout$2,
  get withTimeout() {
    return withTimeout_2;
  }
}, [withTimeout$2]);
const require$$2$b = /* @__PURE__ */ getAugmentedNamespace(withTimeout$1);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.withTimeout = exports2.Semaphore = exports2.Mutex = void 0;
  var Mutex_1 = require$$0$v;
  Object.defineProperty(exports2, "Mutex", { enumerable: true, get: function() {
    return Mutex_1.default;
  } });
  var Semaphore_12 = require$$1$f;
  Object.defineProperty(exports2, "Semaphore", { enumerable: true, get: function() {
    return Semaphore_12.default;
  } });
  var withTimeout_1 = require$$2$b;
  Object.defineProperty(exports2, "withTimeout", { enumerable: true, get: function() {
    return withTimeout_1.withTimeout;
  } });
})(lib$1);
const index$h = /* @__PURE__ */ getDefaultExportFromCjs(lib$1);
const lib = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$h
}, [lib$1]);
const require$$0$u = /* @__PURE__ */ getAugmentedNamespace(lib);
var immutable = extend$1;
var hasOwnProperty$7 = Object.prototype.hasOwnProperty;
function extend$1() {
  var target = {};
  for (var i3 = 0; i3 < arguments.length; i3++) {
    var source = arguments[i3];
    for (var key2 in source) {
      if (hasOwnProperty$7.call(source, key2)) {
        target[key2] = source[key2];
      }
    }
  }
  return target;
}
const immutable$1 = /* @__PURE__ */ getDefaultExportFromCjs(immutable);
const immutable$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: immutable$1
}, [immutable]);
const require$$0$t = /* @__PURE__ */ getAugmentedNamespace(immutable$2);
const extend = require$$0$t;
const createRandomId = require$$1$q();
var ethQuery = EthQuery$1;
function EthQuery$1(provider) {
  const self2 = this;
  self2.currentProvider = provider;
}
EthQuery$1.prototype.getBalance = generateFnWithDefaultBlockFor(2, "eth_getBalance");
EthQuery$1.prototype.getCode = generateFnWithDefaultBlockFor(2, "eth_getCode");
EthQuery$1.prototype.getTransactionCount = generateFnWithDefaultBlockFor(2, "eth_getTransactionCount");
EthQuery$1.prototype.getStorageAt = generateFnWithDefaultBlockFor(3, "eth_getStorageAt");
EthQuery$1.prototype.call = generateFnWithDefaultBlockFor(2, "eth_call");
EthQuery$1.prototype.protocolVersion = generateFnFor("eth_protocolVersion");
EthQuery$1.prototype.syncing = generateFnFor("eth_syncing");
EthQuery$1.prototype.coinbase = generateFnFor("eth_coinbase");
EthQuery$1.prototype.mining = generateFnFor("eth_mining");
EthQuery$1.prototype.hashrate = generateFnFor("eth_hashrate");
EthQuery$1.prototype.gasPrice = generateFnFor("eth_gasPrice");
EthQuery$1.prototype.accounts = generateFnFor("eth_accounts");
EthQuery$1.prototype.blockNumber = generateFnFor("eth_blockNumber");
EthQuery$1.prototype.getBlockTransactionCountByHash = generateFnFor("eth_getBlockTransactionCountByHash");
EthQuery$1.prototype.getBlockTransactionCountByNumber = generateFnFor("eth_getBlockTransactionCountByNumber");
EthQuery$1.prototype.getUncleCountByBlockHash = generateFnFor("eth_getUncleCountByBlockHash");
EthQuery$1.prototype.getUncleCountByBlockNumber = generateFnFor("eth_getUncleCountByBlockNumber");
EthQuery$1.prototype.sign = generateFnFor("eth_sign");
EthQuery$1.prototype.sendTransaction = generateFnFor("eth_sendTransaction");
EthQuery$1.prototype.sendRawTransaction = generateFnFor("eth_sendRawTransaction");
EthQuery$1.prototype.estimateGas = generateFnFor("eth_estimateGas");
EthQuery$1.prototype.getBlockByHash = generateFnFor("eth_getBlockByHash");
EthQuery$1.prototype.getBlockByNumber = generateFnFor("eth_getBlockByNumber");
EthQuery$1.prototype.getTransactionByHash = generateFnFor("eth_getTransactionByHash");
EthQuery$1.prototype.getTransactionByBlockHashAndIndex = generateFnFor("eth_getTransactionByBlockHashAndIndex");
EthQuery$1.prototype.getTransactionByBlockNumberAndIndex = generateFnFor("eth_getTransactionByBlockNumberAndIndex");
EthQuery$1.prototype.getTransactionReceipt = generateFnFor("eth_getTransactionReceipt");
EthQuery$1.prototype.getUncleByBlockHashAndIndex = generateFnFor("eth_getUncleByBlockHashAndIndex");
EthQuery$1.prototype.getUncleByBlockNumberAndIndex = generateFnFor("eth_getUncleByBlockNumberAndIndex");
EthQuery$1.prototype.getCompilers = generateFnFor("eth_getCompilers");
EthQuery$1.prototype.compileLLL = generateFnFor("eth_compileLLL");
EthQuery$1.prototype.compileSolidity = generateFnFor("eth_compileSolidity");
EthQuery$1.prototype.compileSerpent = generateFnFor("eth_compileSerpent");
EthQuery$1.prototype.newFilter = generateFnFor("eth_newFilter");
EthQuery$1.prototype.newBlockFilter = generateFnFor("eth_newBlockFilter");
EthQuery$1.prototype.newPendingTransactionFilter = generateFnFor("eth_newPendingTransactionFilter");
EthQuery$1.prototype.uninstallFilter = generateFnFor("eth_uninstallFilter");
EthQuery$1.prototype.getFilterChanges = generateFnFor("eth_getFilterChanges");
EthQuery$1.prototype.getFilterLogs = generateFnFor("eth_getFilterLogs");
EthQuery$1.prototype.getLogs = generateFnFor("eth_getLogs");
EthQuery$1.prototype.getWork = generateFnFor("eth_getWork");
EthQuery$1.prototype.submitWork = generateFnFor("eth_submitWork");
EthQuery$1.prototype.submitHashrate = generateFnFor("eth_submitHashrate");
EthQuery$1.prototype.sendAsync = function(opts, cb2) {
  const self2 = this;
  self2.currentProvider.sendAsync(createPayload(opts), function(err, response) {
    if (!err && response.error)
      err = new Error("EthQuery - RPC Error - " + response.error.message);
    if (err)
      return cb2(err);
    cb2(null, response.result);
  });
};
function generateFnFor(methodName) {
  return function() {
    const self2 = this;
    var args = [].slice.call(arguments);
    var cb2 = args.pop();
    self2.sendAsync({
      method: methodName,
      params: args
    }, cb2);
  };
}
function generateFnWithDefaultBlockFor(argCount, methodName) {
  return function() {
    const self2 = this;
    var args = [].slice.call(arguments);
    var cb2 = args.pop();
    if (args.length < argCount)
      args.push("latest");
    self2.sendAsync({
      method: methodName,
      params: args
    }, cb2);
  };
}
function createPayload(data2) {
  return extend({
    // defaults
    id: createRandomId(),
    jsonrpc: "2.0",
    params: []
    // user-specified
  }, data2);
}
const index$g = /* @__PURE__ */ getDefaultExportFromCjs(ethQuery);
const ethQuery$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$g
}, [ethQuery]);
const require$$0$s = /* @__PURE__ */ getAugmentedNamespace(ethQuery$1);
const processFn = (fn2, options, proxy2, unwrapped) => function(...arguments_) {
  const P2 = options.promiseModule;
  return new P2((resolve, reject) => {
    if (options.multiArgs) {
      arguments_.push((...result) => {
        if (options.errorFirst) {
          if (result[0]) {
            reject(result);
          } else {
            result.shift();
            resolve(result);
          }
        } else {
          resolve(result);
        }
      });
    } else if (options.errorFirst) {
      arguments_.push((error, result) => {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      });
    } else {
      arguments_.push(resolve);
    }
    const self2 = this === proxy2 ? unwrapped : this;
    Reflect.apply(fn2, self2, arguments_);
  });
};
const filterCache = /* @__PURE__ */ new WeakMap();
var pify$1 = (input, options) => {
  options = {
    exclude: [/.+(?:Sync|Stream)$/],
    errorFirst: true,
    promiseModule: Promise,
    ...options
  };
  const objectType2 = typeof input;
  if (!(input !== null && (objectType2 === "object" || objectType2 === "function"))) {
    throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType2}\``);
  }
  const filter2 = (target, key2) => {
    let cached = filterCache.get(target);
    if (!cached) {
      cached = {};
      filterCache.set(target, cached);
    }
    if (key2 in cached) {
      return cached[key2];
    }
    const match = (pattern2) => typeof pattern2 === "string" || typeof key2 === "symbol" ? key2 === pattern2 : pattern2.test(key2);
    const desc = Reflect.getOwnPropertyDescriptor(target, key2);
    const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
    const included = options.include ? options.include.some(match) : !options.exclude.some(match);
    const shouldFilter = included && writableOrConfigurableOwn;
    cached[key2] = shouldFilter;
    return shouldFilter;
  };
  const cache = /* @__PURE__ */ new WeakMap();
  const proxy2 = new Proxy(input, {
    apply(target, thisArg, args) {
      const cached = cache.get(target);
      if (cached) {
        return Reflect.apply(cached, thisArg, args);
      }
      const pified = options.excludeMain ? target : processFn(target, options, proxy2, target);
      cache.set(target, pified);
      return Reflect.apply(pified, thisArg, args);
    },
    get(target, key2) {
      const property = target[key2];
      if (!filter2(target, key2) || property === Function.prototype[key2]) {
        return property;
      }
      const cached = cache.get(property);
      if (cached) {
        return cached;
      }
      if (typeof property === "function") {
        const pified = processFn(property, options, proxy2, target);
        cache.set(property, pified);
        return pified;
      }
      return property;
    }
  });
  return proxy2;
};
const index$f = /* @__PURE__ */ getDefaultExportFromCjs(pify$1);
const pify$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$f
}, [pify$1]);
const require$$1$e = /* @__PURE__ */ getAugmentedNamespace(pify$2);
const SafeEventEmitter$1 = require$$0$14.default;
let BaseFilter$3 = class BaseFilter2 extends SafeEventEmitter$1 {
  constructor() {
    super();
    this.updates = [];
  }
  async initialize() {
  }
  async update() {
    throw new Error("BaseFilter - no update method specified");
  }
  addResults(newResults) {
    this.updates = this.updates.concat(newResults);
    newResults.forEach((result) => this.emit("update", result));
  }
  addInitialResults(newResults) {
  }
  getChangesAndClear() {
    const updates = this.updates;
    this.updates = [];
    return updates;
  }
};
var baseFilter = BaseFilter$3;
const baseFilter$1 = /* @__PURE__ */ getDefaultExportFromCjs(baseFilter);
const baseFilter$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: baseFilter$1
}, [baseFilter]);
const require$$0$r = /* @__PURE__ */ getAugmentedNamespace(baseFilter$2);
const BaseFilter$2 = require$$0$r;
let BaseFilterWithHistory$1 = class BaseFilterWithHistory2 extends BaseFilter$2 {
  constructor() {
    super();
    this.allResults = [];
  }
  async update() {
    throw new Error("BaseFilterWithHistory - no update method specified");
  }
  addResults(newResults) {
    this.allResults = this.allResults.concat(newResults);
    super.addResults(newResults);
  }
  addInitialResults(newResults) {
    this.allResults = this.allResults.concat(newResults);
    super.addInitialResults(newResults);
  }
  getAllResults() {
    return this.allResults;
  }
};
var baseFilterHistory = BaseFilterWithHistory$1;
const baseFilterHistory$1 = /* @__PURE__ */ getDefaultExportFromCjs(baseFilterHistory);
const baseFilterHistory$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: baseFilterHistory$1
}, [baseFilterHistory]);
const require$$2$a = /* @__PURE__ */ getAugmentedNamespace(baseFilterHistory$2);
var hexUtils = {
  minBlockRef: minBlockRef$1,
  maxBlockRef,
  sortBlockRefs,
  bnToHex: bnToHex$1,
  blockRefIsNumber: blockRefIsNumber$1,
  hexToInt: hexToInt$3,
  incrementHexInt: incrementHexInt$4,
  intToHex: intToHex$2,
  unsafeRandomBytes: unsafeRandomBytes$1
};
function minBlockRef$1(...refs) {
  const sortedRefs = sortBlockRefs(refs);
  return sortedRefs[0];
}
function maxBlockRef(...refs) {
  const sortedRefs = sortBlockRefs(refs);
  return sortedRefs[sortedRefs.length - 1];
}
function sortBlockRefs(refs) {
  return refs.sort((refA, refB) => {
    if (refA === "latest" || refB === "earliest")
      return 1;
    if (refB === "latest" || refA === "earliest")
      return -1;
    return hexToInt$3(refA) - hexToInt$3(refB);
  });
}
function bnToHex$1(bn2) {
  return "0x" + bn2.toString(16);
}
function blockRefIsNumber$1(blockRef) {
  return blockRef && !["earliest", "latest", "pending"].includes(blockRef);
}
function hexToInt$3(hexString) {
  if (hexString === void 0 || hexString === null)
    return hexString;
  return Number.parseInt(hexString, 16);
}
function incrementHexInt$4(hexString) {
  if (hexString === void 0 || hexString === null)
    return hexString;
  const value = hexToInt$3(hexString);
  return intToHex$2(value + 1);
}
function intToHex$2(int2) {
  if (int2 === void 0 || int2 === null)
    return int2;
  let hexString = int2.toString(16);
  const needsLeftPad = hexString.length % 2;
  if (needsLeftPad)
    hexString = "0" + hexString;
  return "0x" + hexString;
}
function unsafeRandomBytes$1(byteCount) {
  let result = "0x";
  for (let i3 = 0; i3 < byteCount; i3++) {
    result += unsafeRandomNibble();
    result += unsafeRandomNibble();
  }
  return result;
}
function unsafeRandomNibble() {
  return Math.floor(Math.random() * 16).toString(16);
}
const hexUtils$1 = /* @__PURE__ */ getDefaultExportFromCjs(hexUtils);
const hexUtils$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: hexUtils$1
}, [hexUtils]);
const require$$3$6 = /* @__PURE__ */ getAugmentedNamespace(hexUtils$2);
const EthQuery = require$$0$s;
const pify = require$$1$e;
const BaseFilterWithHistory = require$$2$a;
const { bnToHex, hexToInt: hexToInt$2, incrementHexInt: incrementHexInt$3, minBlockRef, blockRefIsNumber } = require$$3$6;
let LogFilter$1 = class LogFilter2 extends BaseFilterWithHistory {
  constructor({ provider, params }) {
    super();
    this.type = "log";
    this.ethQuery = new EthQuery(provider);
    this.params = Object.assign({
      fromBlock: "latest",
      toBlock: "latest",
      address: void 0,
      topics: []
    }, params);
    if (this.params.address) {
      if (!Array.isArray(this.params.address)) {
        this.params.address = [this.params.address];
      }
      this.params.address = this.params.address.map((address) => address.toLowerCase());
    }
  }
  async initialize({ currentBlock }) {
    let fromBlock = this.params.fromBlock;
    if (["latest", "pending"].includes(fromBlock))
      fromBlock = currentBlock;
    if ("earliest" === fromBlock)
      fromBlock = "0x0";
    this.params.fromBlock = fromBlock;
    const toBlock = minBlockRef(this.params.toBlock, currentBlock);
    const params = Object.assign({}, this.params, { toBlock });
    const newLogs = await this._fetchLogs(params);
    this.addInitialResults(newLogs);
  }
  async update({ oldBlock, newBlock }) {
    const toBlock = newBlock;
    let fromBlock;
    if (oldBlock) {
      fromBlock = incrementHexInt$3(oldBlock);
    } else {
      fromBlock = newBlock;
    }
    const params = Object.assign({}, this.params, { fromBlock, toBlock });
    const newLogs = await this._fetchLogs(params);
    const matchingLogs = newLogs.filter((log3) => this.matchLog(log3));
    this.addResults(matchingLogs);
  }
  async _fetchLogs(params) {
    const newLogs = await pify((cb2) => this.ethQuery.getLogs(params, cb2))();
    return newLogs;
  }
  matchLog(log3) {
    if (hexToInt$2(this.params.fromBlock) >= hexToInt$2(log3.blockNumber))
      return false;
    if (blockRefIsNumber(this.params.toBlock) && hexToInt$2(this.params.toBlock) <= hexToInt$2(log3.blockNumber))
      return false;
    const normalizedLogAddress = log3.address && log3.address.toLowerCase();
    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress))
      return false;
    const topicsMatch = this.params.topics.every((topicPattern, index2) => {
      let logTopic = log3.topics[index2];
      if (!logTopic)
        return false;
      logTopic = logTopic.toLowerCase();
      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
      if (subtopicsIncludeWildcard)
        return true;
      subtopicsToMatch = subtopicsToMatch.map((topic) => topic.toLowerCase());
      const topicDoesMatch = subtopicsToMatch.includes(logTopic);
      return topicDoesMatch;
    });
    return topicsMatch;
  }
};
var logFilter = LogFilter$1;
const logFilter$1 = /* @__PURE__ */ getDefaultExportFromCjs(logFilter);
const logFilter$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: logFilter$1
}, [logFilter]);
const require$$2$9 = /* @__PURE__ */ getAugmentedNamespace(logFilter$2);
var getBlocksForRange_1 = getBlocksForRange$3;
async function getBlocksForRange$3({ provider, fromBlock, toBlock }) {
  if (!fromBlock)
    fromBlock = toBlock;
  const fromBlockNumber = hexToInt$1(fromBlock);
  const toBlockNumber = hexToInt$1(toBlock);
  const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
  const missingBlockNumbers = Array(blockCountToQuery).fill().map((_3, index2) => fromBlockNumber + index2).map(intToHex$1);
  const blockBodies = await Promise.all(
    missingBlockNumbers.map((blockNum) => query(provider, "eth_getBlockByNumber", [blockNum, false]))
  );
  return blockBodies;
}
function hexToInt$1(hexString) {
  if (hexString === void 0 || hexString === null)
    return hexString;
  return Number.parseInt(hexString, 16);
}
function intToHex$1(int2) {
  if (int2 === void 0 || int2 === null)
    return int2;
  const hexString = int2.toString(16);
  return "0x" + hexString;
}
function sendAsync(provider, request) {
  return new Promise((resolve, reject) => {
    provider.sendAsync(request, (error, response) => {
      if (error) {
        reject(error);
      } else if (response.error) {
        reject(response.error);
      } else if (response.result) {
        resolve(response.result);
      } else {
        reject(new Error("Result was empty"));
      }
    });
  });
}
async function query(provider, method, params) {
  for (let i3 = 0; i3 < 3; i3++) {
    try {
      return await sendAsync(provider, {
        id: 1,
        jsonrpc: "2.0",
        method,
        params
      });
    } catch (error) {
      console.error(
        `provider.sendAsync failed: ${error.stack || error.message || error}`
      );
    }
  }
  throw new Error(`Block not found for params: ${JSON.stringify(params)}`);
}
const getBlocksForRange$4 = /* @__PURE__ */ getDefaultExportFromCjs(getBlocksForRange_1);
const getBlocksForRange$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getBlocksForRange$4
}, [getBlocksForRange_1]);
const require$$4$7 = /* @__PURE__ */ getAugmentedNamespace(getBlocksForRange$5);
const BaseFilter$1 = require$$0$r;
const getBlocksForRange$2 = require$$4$7;
const { incrementHexInt: incrementHexInt$2 } = require$$3$6;
let BlockFilter$1 = class BlockFilter2 extends BaseFilter$1 {
  constructor({ provider, params }) {
    super();
    this.type = "block";
    this.provider = provider;
  }
  async update({ oldBlock, newBlock }) {
    const toBlock = newBlock;
    const fromBlock = incrementHexInt$2(oldBlock);
    const blockBodies = await getBlocksForRange$2({ provider: this.provider, fromBlock, toBlock });
    const blockHashes = blockBodies.map((block2) => block2.hash);
    this.addResults(blockHashes);
  }
};
var blockFilter = BlockFilter$1;
const blockFilter$1 = /* @__PURE__ */ getDefaultExportFromCjs(blockFilter);
const blockFilter$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: blockFilter$1
}, [blockFilter]);
const require$$3$5 = /* @__PURE__ */ getAugmentedNamespace(blockFilter$2);
const BaseFilter = require$$0$r;
const getBlocksForRange$1 = require$$4$7;
const { incrementHexInt: incrementHexInt$1 } = require$$3$6;
let TxFilter$1 = class TxFilter2 extends BaseFilter {
  constructor({ provider }) {
    super();
    this.type = "tx";
    this.provider = provider;
  }
  async update({ oldBlock }) {
    const toBlock = oldBlock;
    const fromBlock = incrementHexInt$1(oldBlock);
    const blocks = await getBlocksForRange$1({ provider: this.provider, fromBlock, toBlock });
    const blockTxHashes = [];
    for (const block2 of blocks) {
      blockTxHashes.push(...block2.transactions);
    }
    this.addResults(blockTxHashes);
  }
};
var txFilter = TxFilter$1;
const txFilter$1 = /* @__PURE__ */ getDefaultExportFromCjs(txFilter);
const txFilter$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: txFilter$1
}, [txFilter]);
const require$$4$6 = /* @__PURE__ */ getAugmentedNamespace(txFilter$2);
const Mutex = require$$0$u.Mutex;
const { createAsyncMiddleware: createAsyncMiddleware$1, createScaffoldMiddleware: createScaffoldMiddleware$1 } = require$$1$g;
const LogFilter = require$$2$9;
const BlockFilter = require$$3$5;
const TxFilter = require$$4$6;
const { intToHex, hexToInt } = require$$3$6;
var ethJsonRpcFilters = createEthFilterMiddleware;
function createEthFilterMiddleware({ blockTracker, provider }) {
  let filterIndex = 0;
  let filters = {};
  const mutex = new Mutex();
  const waitForFree = mutexMiddlewareWrapper({ mutex });
  const middleware = createScaffoldMiddleware$1({
    // install filters
    eth_newFilter: waitForFree(toFilterCreationMiddleware(newLogFilter)),
    eth_newBlockFilter: waitForFree(toFilterCreationMiddleware(newBlockFilter)),
    eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
    // uninstall filters
    eth_uninstallFilter: waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
    // checking filter changes
    eth_getFilterChanges: waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
    eth_getFilterLogs: waitForFree(toAsyncRpcMiddleware(getFilterLogs))
  });
  const filterUpdater = async ({ oldBlock, newBlock }) => {
    if (filters.length === 0)
      return;
    const releaseLock = await mutex.acquire();
    try {
      await Promise.all(objValues(filters).map(async (filter2) => {
        try {
          await filter2.update({ oldBlock, newBlock });
        } catch (err) {
          console.error(err);
        }
      }));
    } catch (err) {
      console.error(err);
    }
    releaseLock();
  };
  middleware.newLogFilter = newLogFilter;
  middleware.newBlockFilter = newBlockFilter;
  middleware.newPendingTransactionFilter = newPendingTransactionFilter;
  middleware.uninstallFilter = uninstallFilterHandler;
  middleware.getFilterChanges = getFilterChanges;
  middleware.getFilterLogs = getFilterLogs;
  middleware.destroy = () => {
    uninstallAllFilters();
  };
  return middleware;
  async function newLogFilter(params) {
    const filter2 = new LogFilter({ provider, params });
    await installFilter(filter2);
    return filter2;
  }
  async function newBlockFilter() {
    const filter2 = new BlockFilter({ provider });
    await installFilter(filter2);
    return filter2;
  }
  async function newPendingTransactionFilter() {
    const filter2 = new TxFilter({ provider });
    await installFilter(filter2);
    return filter2;
  }
  async function getFilterChanges(filterIndexHex) {
    const filterIndex2 = hexToInt(filterIndexHex);
    const filter2 = filters[filterIndex2];
    if (!filter2) {
      throw new Error(`No filter for index "${filterIndex2}"`);
    }
    const results = filter2.getChangesAndClear();
    return results;
  }
  async function getFilterLogs(filterIndexHex) {
    const filterIndex2 = hexToInt(filterIndexHex);
    const filter2 = filters[filterIndex2];
    if (!filter2) {
      throw new Error(`No filter for index "${filterIndex2}"`);
    }
    let results = [];
    if (filter2.type === "log") {
      results = filter2.getAllResults();
    }
    return results;
  }
  async function uninstallFilterHandler(filterIndexHex) {
    const filterIndex2 = hexToInt(filterIndexHex);
    const filter2 = filters[filterIndex2];
    const result = Boolean(filter2);
    if (result) {
      await uninstallFilter(filterIndex2);
    }
    return result;
  }
  async function installFilter(filter2) {
    const prevFilterCount = objValues(filters).length;
    const currentBlock = await blockTracker.getLatestBlock();
    await filter2.initialize({ currentBlock });
    filterIndex++;
    filters[filterIndex] = filter2;
    filter2.id = filterIndex;
    filter2.idHex = intToHex(filterIndex);
    const newFilterCount = objValues(filters).length;
    updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
    return filterIndex;
  }
  async function uninstallFilter(filterIndex2) {
    const prevFilterCount = objValues(filters).length;
    delete filters[filterIndex2];
    const newFilterCount = objValues(filters).length;
    updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
  }
  async function uninstallAllFilters() {
    const prevFilterCount = objValues(filters).length;
    filters = {};
    updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 });
  }
  function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
    if (prevFilterCount === 0 && newFilterCount > 0) {
      blockTracker.on("sync", filterUpdater);
      return;
    }
    if (prevFilterCount > 0 && newFilterCount === 0) {
      blockTracker.removeListener("sync", filterUpdater);
      return;
    }
  }
}
function toFilterCreationMiddleware(createFilterFn) {
  return toAsyncRpcMiddleware(async (...args) => {
    const filter2 = await createFilterFn(...args);
    const result = intToHex(filter2.id);
    return result;
  });
}
function toAsyncRpcMiddleware(asyncFn) {
  return createAsyncMiddleware$1(async (req, res) => {
    const result = await asyncFn.apply(null, req.params);
    res.result = result;
  });
}
function mutexMiddlewareWrapper({ mutex }) {
  return (middleware) => {
    return async (req, res, next, end2) => {
      const releaseLock = await mutex.acquire();
      releaseLock();
      middleware(req, res, next, end2);
    };
  };
}
function objValues(obj, fn2) {
  const values = [];
  for (let key2 in obj) {
    values.push(obj[key2]);
  }
  return values;
}
const index$e = /* @__PURE__ */ getDefaultExportFromCjs(ethJsonRpcFilters);
const ethJsonRpcFilters$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$e
}, [ethJsonRpcFilters]);
const require$$2$8 = /* @__PURE__ */ getAugmentedNamespace(ethJsonRpcFilters$1);
const SafeEventEmitter = require$$0$14.default;
const { createAsyncMiddleware, createScaffoldMiddleware } = require$$1$g;
const createFilterMiddleware = require$$2$8;
const { unsafeRandomBytes, incrementHexInt } = require$$3$6;
const getBlocksForRange = require$$4$7;
var subscriptionManager = createSubscriptionMiddleware;
function createSubscriptionMiddleware({ blockTracker, provider }) {
  const subscriptions = {};
  const filterManager = createFilterMiddleware({ blockTracker, provider });
  let isDestroyed = false;
  const events2 = new SafeEventEmitter();
  const middleware = createScaffoldMiddleware({
    eth_subscribe: createAsyncMiddleware(subscribe2),
    eth_unsubscribe: createAsyncMiddleware(unsubscribe)
  });
  middleware.destroy = destroy2;
  return { events: events2, middleware };
  async function subscribe2(req, res) {
    if (isDestroyed)
      throw new Error(
        "SubscriptionManager - attempting to use after destroying"
      );
    const subscriptionType = req.params[0];
    const subId = unsafeRandomBytes(16);
    let sub;
    switch (subscriptionType) {
      case "newHeads":
        sub = createSubNewHeads({ subId });
        break;
      case "logs":
        const filterParams = req.params[1];
        const filter2 = await filterManager.newLogFilter(filterParams);
        sub = createSubFromFilter({ subId, filter: filter2 });
        break;
      default:
        throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`);
    }
    subscriptions[subId] = sub;
    res.result = subId;
    return;
    function createSubNewHeads({ subId: subId2 }) {
      const sub2 = {
        type: subscriptionType,
        destroy: async () => {
          blockTracker.removeListener("sync", sub2.update);
        },
        update: async ({ oldBlock, newBlock }) => {
          const toBlock = newBlock;
          const fromBlock = incrementHexInt(oldBlock);
          const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock });
          const results = rawBlocks.map(normalizeBlock).filter((block2) => block2 !== null);
          results.forEach((value) => {
            _emitSubscriptionResult(subId2, value);
          });
        }
      };
      blockTracker.on("sync", sub2.update);
      return sub2;
    }
    function createSubFromFilter({ subId: subId2, filter: filter2 }) {
      filter2.on("update", (result) => _emitSubscriptionResult(subId2, result));
      const sub2 = {
        type: subscriptionType,
        destroy: async () => {
          return await filterManager.uninstallFilter(filter2.idHex);
        }
      };
      return sub2;
    }
  }
  async function unsubscribe(req, res) {
    if (isDestroyed)
      throw new Error(
        "SubscriptionManager - attempting to use after destroying"
      );
    const id2 = req.params[0];
    const subscription = subscriptions[id2];
    if (!subscription) {
      res.result = false;
      return;
    }
    delete subscriptions[id2];
    await subscription.destroy();
    res.result = true;
  }
  function _emitSubscriptionResult(filterIdHex, value) {
    events2.emit("notification", {
      jsonrpc: "2.0",
      method: "eth_subscription",
      params: {
        subscription: filterIdHex,
        result: value
      }
    });
  }
  function destroy2() {
    events2.removeAllListeners();
    for (const id2 in subscriptions) {
      subscriptions[id2].destroy();
      delete subscriptions[id2];
    }
    isDestroyed = true;
  }
}
function normalizeBlock(block2) {
  if (block2 === null || block2 === void 0) {
    return null;
  }
  return {
    hash: block2.hash,
    parentHash: block2.parentHash,
    sha3Uncles: block2.sha3Uncles,
    miner: block2.miner,
    stateRoot: block2.stateRoot,
    transactionsRoot: block2.transactionsRoot,
    receiptsRoot: block2.receiptsRoot,
    logsBloom: block2.logsBloom,
    difficulty: block2.difficulty,
    number: block2.number,
    gasLimit: block2.gasLimit,
    gasUsed: block2.gasUsed,
    nonce: block2.nonce,
    mixHash: block2.mixHash,
    timestamp: block2.timestamp,
    extraData: block2.extraData
  };
}
const subscriptionManager$1 = /* @__PURE__ */ getDefaultExportFromCjs(subscriptionManager);
const subscriptionManager$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: subscriptionManager$1
}, [subscriptionManager]);
const require$$1$d = /* @__PURE__ */ getAugmentedNamespace(subscriptionManager$2);
Object.defineProperty(SubscriptionManager$2, "__esModule", { value: true });
var SubscriptionManager_2 = SubscriptionManager$2.SubscriptionManager = void 0;
const eth_block_tracker_1 = require$$0$z;
const createSubscriptionManager = require$$1$d;
const noop$4 = () => {
};
class SubscriptionManager {
  constructor(provider) {
    const blockTracker = new eth_block_tracker_1.PollingBlockTracker({
      provider,
      pollingInterval: 15 * 1e3,
      setSkipCacheFlag: true
    });
    const { events: events2, middleware } = createSubscriptionManager({
      blockTracker,
      provider
    });
    this.events = events2;
    this.subscriptionMiddleware = middleware;
  }
  async handleRequest(request) {
    const result = {};
    await this.subscriptionMiddleware(request, result, noop$4, noop$4);
    return result;
  }
  destroy() {
    this.subscriptionMiddleware.destroy();
  }
}
SubscriptionManager_2 = SubscriptionManager$2.SubscriptionManager = SubscriptionManager;
const SubscriptionManager$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get SubscriptionManager() {
    return SubscriptionManager_2;
  },
  default: SubscriptionManager$2
}, [SubscriptionManager$2]);
const require$$12$2 = /* @__PURE__ */ getAugmentedNamespace(SubscriptionManager$1);
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(CoinbaseWalletProvider$2, "__esModule", { value: true });
var CoinbaseWalletProvider_2 = CoinbaseWalletProvider$2.CoinbaseWalletProvider = void 0;
const safe_event_emitter_1 = __importDefault$7(require$$0$14);
const bn_js_1 = __importDefault$7(require$$1$B);
const DiagnosticLogger_1$2 = require$$3$g;
const errors_1$1 = require$$5$c;
const Session_1$2 = require$$9$4;
const WalletSDKRelayAbstract_1$1 = require$$10$4;
const Web3Method_1$1 = require$$11$4;
const Web3Response_1$1 = require$$14$2;
const util_1$5 = require$$7$4;
const eth_eip712_util_1 = __importDefault$7(require$$9$3);
const FilterPolyfill_1 = require$$10$3;
const JSONRPC_1 = require$$11$3;
const SubscriptionManager_1 = require$$12$2;
const DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
const DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
class CoinbaseWalletProvider extends safe_event_emitter_1.default {
  constructor(options) {
    var _a2, _b;
    super();
    this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);
    this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);
    this._relay = null;
    this._addresses = [];
    this.hasMadeFirstChainChangedEmission = false;
    this.setProviderInfo = this.setProviderInfo.bind(this);
    this.updateProviderInfo = this.updateProviderInfo.bind(this);
    this.getChainId = this.getChainId.bind(this);
    this.setAppInfo = this.setAppInfo.bind(this);
    this.enable = this.enable.bind(this);
    this.close = this.close.bind(this);
    this.send = this.send.bind(this);
    this.sendAsync = this.sendAsync.bind(this);
    this.request = this.request.bind(this);
    this._setAddresses = this._setAddresses.bind(this);
    this.scanQRCode = this.scanQRCode.bind(this);
    this.genericRequest = this.genericRequest.bind(this);
    this._chainIdFromOpts = options.chainId;
    this._jsonRpcUrlFromOpts = options.jsonRpcUrl;
    this._overrideIsMetaMask = options.overrideIsMetaMask;
    this._relayProvider = options.relayProvider;
    this._storage = options.storage;
    this._relayEventManager = options.relayEventManager;
    this.diagnostic = options.diagnosticLogger;
    this.reloadOnDisconnect = true;
    this.isCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
    this.isCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
    this.qrUrl = options.qrUrl;
    const chainId = this.getChainId();
    const chainIdStr = (0, util_1$5.prepend0x)(chainId.toString(16));
    this.emit("connect", { chainIdStr });
    const cachedAddresses = this._storage.getItem(WalletSDKRelayAbstract_1$1.LOCAL_STORAGE_ADDRESSES_KEY);
    if (cachedAddresses) {
      const addresses = cachedAddresses.split(" ");
      if (addresses[0] !== "") {
        this._addresses = addresses.map((address) => (0, util_1$5.ensureAddressString)(address));
        this.emit("accountsChanged", addresses);
      }
    }
    this._subscriptionManager.events.on("notification", (notification) => {
      this.emit("message", {
        type: notification.method,
        data: notification.params
      });
    });
    if (this._isAuthorized()) {
      void this.initializeRelay();
    }
    window.addEventListener("message", (event) => {
      var _a3;
      if (event.origin !== location.origin || event.source !== window) {
        return;
      }
      if (event.data.type !== "walletLinkMessage")
        return;
      if (event.data.data.action === "dappChainSwitched") {
        const _chainId = event.data.data.chainId;
        const jsonRpcUrl = (_a3 = event.data.data.jsonRpcUrl) !== null && _a3 !== void 0 ? _a3 : this.jsonRpcUrl;
        this.updateProviderInfo(jsonRpcUrl, Number(_chainId));
      }
      if (event.data.data.action === "addressChanged") {
        this._setAddresses([event.data.data.address]);
      }
    });
  }
  /** @deprecated Use `.request({ method: 'eth_accounts' })` instead. */
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  /** @deprecated Use the chain ID. If you still need the network ID, use `.request({ method: 'net_version' })`. */
  get networkVersion() {
    return this.getChainId().toString(10);
  }
  /** @deprecated Use `.request({ method: 'eth_chainId' })` instead. */
  get chainId() {
    return (0, util_1$5.prepend0x)(this.getChainId().toString(16));
  }
  get isWalletLink() {
    return true;
  }
  /**
   * Some DApps (i.e. Alpha Homora) seem to require the window.ethereum object return
   * true for this method.
   */
  get isMetaMask() {
    return this._overrideIsMetaMask;
  }
  get host() {
    return this.jsonRpcUrl;
  }
  get connected() {
    return true;
  }
  isConnected() {
    return true;
  }
  get jsonRpcUrl() {
    var _a2;
    return (_a2 = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a2 !== void 0 ? _a2 : this._jsonRpcUrlFromOpts;
  }
  set jsonRpcUrl(value) {
    this._storage.setItem(DEFAULT_JSON_RPC_URL, value);
  }
  disableReloadOnDisconnect() {
    this.reloadOnDisconnect = false;
  }
  setProviderInfo(jsonRpcUrl, chainId) {
    if (!this.isCoinbaseBrowser) {
      this._chainIdFromOpts = chainId;
      this._jsonRpcUrlFromOpts = jsonRpcUrl;
    }
    this.updateProviderInfo(this.jsonRpcUrl, this.getChainId());
  }
  updateProviderInfo(jsonRpcUrl, chainId) {
    this.jsonRpcUrl = jsonRpcUrl;
    const originalChainId = this.getChainId();
    this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
    const chainChanged = (0, util_1$5.ensureIntNumber)(chainId) !== originalChainId;
    if (chainChanged || !this.hasMadeFirstChainChangedEmission) {
      this.emit("chainChanged", this.getChainId());
      this.hasMadeFirstChainChangedEmission = true;
    }
  }
  async watchAsset(type2, address, symbol2, decimals, image, chainId) {
    const relay = await this.initializeRelay();
    const result = await relay.watchAsset(type2, address, symbol2, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString()).promise;
    return !!result.result;
  }
  async addEthereumChain(chainId, rpcUrls, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {
    var _a2, _b;
    if ((0, util_1$5.ensureIntNumber)(chainId) === this.getChainId()) {
      return false;
    }
    const relay = await this.initializeRelay();
    const isWhitelistedNetworkOrStandalone = relay.inlineAddEthereumChain(chainId.toString());
    if (!this._isAuthorized() && !isWhitelistedNetworkOrStandalone) {
      await relay.requestEthereumAccounts().promise;
    }
    const res = await relay.addEthereumChain(chainId.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency).promise;
    if (((_a2 = res.result) === null || _a2 === void 0 ? void 0 : _a2.isApproved) === true) {
      this.updateProviderInfo(rpcUrls[0], chainId);
    }
    return ((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true;
  }
  async switchEthereumChain(chainId) {
    const relay = await this.initializeRelay();
    const res = await relay.switchEthereumChain(chainId.toString(10), this.selectedAddress || void 0).promise;
    if ((0, Web3Response_1$1.isErrorResponse)(res) && res.errorCode) {
      if (res.errorCode === errors_1$1.standardErrorCodes.provider.unsupportedChain) {
        throw errors_1$1.standardErrors.provider.unsupportedChain(chainId);
      } else {
        throw errors_1$1.standardErrors.provider.custom({
          message: res.errorMessage,
          code: res.errorCode
        });
      }
    }
    const switchResponse = res.result;
    if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
      this.updateProviderInfo(switchResponse.rpcUrl, chainId);
    }
  }
  setAppInfo(appName, appLogoUrl) {
    void this.initializeRelay().then((relay) => relay.setAppInfo(appName, appLogoUrl));
  }
  /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
  async enable() {
    var _a2;
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$2.EVENTS.ETH_ACCOUNTS_STATE, {
      method: "provider::enable",
      addresses_length: this._addresses.length,
      sessionIdHash: this._relay ? Session_1$2.Session.hash(this._relay.session.id) : void 0
    });
    if (this._isAuthorized()) {
      return [...this._addresses];
    }
    return await this.send(JSONRPC_1.JSONRPCMethod.eth_requestAccounts);
  }
  async close() {
    const relay = await this.initializeRelay();
    relay.resetAndReload();
  }
  send(requestOrMethod, callbackOrParams) {
    try {
      const result = this._send(requestOrMethod, callbackOrParams);
      if (result instanceof Promise) {
        return result.catch((error) => {
          throw (0, errors_1$1.serializeError)(error, requestOrMethod);
        });
      }
    } catch (error) {
      throw (0, errors_1$1.serializeError)(error, requestOrMethod);
    }
  }
  _send(requestOrMethod, callbackOrParams) {
    if (typeof requestOrMethod === "string") {
      const method = requestOrMethod;
      const params = Array.isArray(callbackOrParams) ? callbackOrParams : callbackOrParams !== void 0 ? [callbackOrParams] : [];
      const request = {
        jsonrpc: "2.0",
        id: 0,
        method,
        params
      };
      return this._sendRequestAsync(request).then((res) => res.result);
    }
    if (typeof callbackOrParams === "function") {
      const request = requestOrMethod;
      const callback = callbackOrParams;
      return this._sendAsync(request, callback);
    }
    if (Array.isArray(requestOrMethod)) {
      const requests = requestOrMethod;
      return requests.map((r2) => this._sendRequest(r2));
    }
    const req = requestOrMethod;
    return this._sendRequest(req);
  }
  async sendAsync(request, callback) {
    try {
      return this._sendAsync(request, callback).catch((error) => {
        throw (0, errors_1$1.serializeError)(error, request);
      });
    } catch (error) {
      return Promise.reject((0, errors_1$1.serializeError)(error, request));
    }
  }
  async _sendAsync(request, callback) {
    if (typeof callback !== "function") {
      throw new Error("callback is required");
    }
    if (Array.isArray(request)) {
      const arrayCb = callback;
      this._sendMultipleRequestsAsync(request).then((responses) => arrayCb(null, responses)).catch((err) => arrayCb(err, null));
      return;
    }
    const cb2 = callback;
    return this._sendRequestAsync(request).then((response) => cb2(null, response)).catch((err) => cb2(err, null));
  }
  async request(args) {
    try {
      return this._request(args).catch((error) => {
        throw (0, errors_1$1.serializeError)(error, args.method);
      });
    } catch (error) {
      return Promise.reject((0, errors_1$1.serializeError)(error, args.method));
    }
  }
  async _request(args) {
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw errors_1$1.standardErrors.rpc.invalidRequest({
        message: "Expected a single, non-array, object argument.",
        data: args
      });
    }
    const { method, params } = args;
    if (typeof method !== "string" || method.length === 0) {
      throw errors_1$1.standardErrors.rpc.invalidRequest({
        message: "'args.method' must be a non-empty string.",
        data: args
      });
    }
    if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
      throw errors_1$1.standardErrors.rpc.invalidRequest({
        message: "'args.params' must be an object or array if provided.",
        data: args
      });
    }
    const newParams = params === void 0 ? [] : params;
    const id2 = this._relayEventManager.makeRequestId();
    const result = await this._sendRequestAsync({
      method,
      params: newParams,
      jsonrpc: "2.0",
      id: id2
    });
    return result.result;
  }
  async scanQRCode(match) {
    var _a2;
    const relay = await this.initializeRelay();
    const res = await relay.scanQRCode((0, util_1$5.ensureRegExpString)(match)).promise;
    if (typeof res.result !== "string") {
      throw (0, errors_1$1.serializeError)((_a2 = res.errorMessage) !== null && _a2 !== void 0 ? _a2 : "result was not a string", Web3Method_1$1.Web3Method.scanQRCode);
    }
    return res.result;
  }
  async genericRequest(data2, action) {
    var _a2;
    const relay = await this.initializeRelay();
    const res = await relay.genericRequest(data2, action).promise;
    if (typeof res.result !== "string") {
      throw (0, errors_1$1.serializeError)((_a2 = res.errorMessage) !== null && _a2 !== void 0 ? _a2 : "result was not a string", Web3Method_1$1.Web3Method.generic);
    }
    return res.result;
  }
  async selectProvider(providerOptions) {
    var _a2;
    const relay = await this.initializeRelay();
    const res = await relay.selectProvider(providerOptions).promise;
    if (typeof res.result !== "string") {
      throw (0, errors_1$1.serializeError)((_a2 = res.errorMessage) !== null && _a2 !== void 0 ? _a2 : "result was not a string", Web3Method_1$1.Web3Method.selectProvider);
    }
    return res.result;
  }
  supportsSubscriptions() {
    return false;
  }
  subscribe() {
    throw new Error("Subscriptions are not supported");
  }
  unsubscribe() {
    throw new Error("Subscriptions are not supported");
  }
  disconnect() {
    return true;
  }
  _sendRequest(request) {
    const response = {
      jsonrpc: "2.0",
      id: request.id
    };
    const { method } = request;
    response.result = this._handleSynchronousMethods(request);
    if (response.result === void 0) {
      throw new Error(`Coinbase Wallet does not support calling ${method} synchronously without a callback. Please provide a callback parameter to call ${method} asynchronously.`);
    }
    return response;
  }
  _setAddresses(addresses, _3) {
    if (!Array.isArray(addresses)) {
      throw new Error("addresses is not an array");
    }
    const newAddresses = addresses.map((address) => (0, util_1$5.ensureAddressString)(address));
    if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
      return;
    }
    this._addresses = newAddresses;
    this.emit("accountsChanged", this._addresses);
    this._storage.setItem(WalletSDKRelayAbstract_1$1.LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
  }
  _sendRequestAsync(request) {
    return new Promise((resolve, reject) => {
      try {
        const syncResult = this._handleSynchronousMethods(request);
        if (syncResult !== void 0) {
          return resolve({
            jsonrpc: "2.0",
            id: request.id,
            result: syncResult
          });
        }
        const filterPromise = this._handleAsynchronousFilterMethods(request);
        if (filterPromise !== void 0) {
          filterPromise.then((res) => resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
          return;
        }
        const subscriptionPromise = this._handleSubscriptionMethods(request);
        if (subscriptionPromise !== void 0) {
          subscriptionPromise.then((res) => resolve({
            jsonrpc: "2.0",
            id: request.id,
            result: res.result
          })).catch((err) => reject(err));
          return;
        }
      } catch (err) {
        return reject(err);
      }
      this._handleAsynchronousMethods(request).then((res) => res && resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
    });
  }
  _sendMultipleRequestsAsync(requests) {
    return Promise.all(requests.map((r2) => this._sendRequestAsync(r2)));
  }
  _handleSynchronousMethods(request) {
    const { method } = request;
    const params = request.params || [];
    switch (method) {
      case JSONRPC_1.JSONRPCMethod.eth_accounts:
        return this._eth_accounts();
      case JSONRPC_1.JSONRPCMethod.eth_coinbase:
        return this._eth_coinbase();
      case JSONRPC_1.JSONRPCMethod.eth_uninstallFilter:
        return this._eth_uninstallFilter(params);
      case JSONRPC_1.JSONRPCMethod.net_version:
        return this._net_version();
      case JSONRPC_1.JSONRPCMethod.eth_chainId:
        return this._eth_chainId();
      default:
        return void 0;
    }
  }
  async _handleAsynchronousMethods(request) {
    const { method } = request;
    const params = request.params || [];
    switch (method) {
      case JSONRPC_1.JSONRPCMethod.eth_requestAccounts:
        return this._eth_requestAccounts();
      case JSONRPC_1.JSONRPCMethod.eth_sign:
        return this._eth_sign(params);
      case JSONRPC_1.JSONRPCMethod.eth_ecRecover:
        return this._eth_ecRecover(params);
      case JSONRPC_1.JSONRPCMethod.personal_sign:
        return this._personal_sign(params);
      case JSONRPC_1.JSONRPCMethod.personal_ecRecover:
        return this._personal_ecRecover(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTransaction:
        return this._eth_signTransaction(params);
      case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:
        return this._eth_sendRawTransaction(params);
      case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:
        return this._eth_sendTransaction(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v1:
        return this._eth_signTypedData_v1(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v2:
        return this._throwUnsupportedMethodError();
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v3:
        return this._eth_signTypedData_v3(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v4:
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData:
        return this._eth_signTypedData_v4(params);
      case JSONRPC_1.JSONRPCMethod.cbWallet_arbitrary:
        return this._cbwallet_arbitrary(params);
      case JSONRPC_1.JSONRPCMethod.wallet_addEthereumChain:
        return this._wallet_addEthereumChain(params);
      case JSONRPC_1.JSONRPCMethod.wallet_switchEthereumChain:
        return this._wallet_switchEthereumChain(params);
      case JSONRPC_1.JSONRPCMethod.wallet_watchAsset:
        return this._wallet_watchAsset(params);
    }
    const relay = await this.initializeRelay();
    return relay.makeEthereumJSONRPCRequest(request, this.jsonRpcUrl);
  }
  _handleAsynchronousFilterMethods(request) {
    const { method } = request;
    const params = request.params || [];
    switch (method) {
      case JSONRPC_1.JSONRPCMethod.eth_newFilter:
        return this._eth_newFilter(params);
      case JSONRPC_1.JSONRPCMethod.eth_newBlockFilter:
        return this._eth_newBlockFilter();
      case JSONRPC_1.JSONRPCMethod.eth_newPendingTransactionFilter:
        return this._eth_newPendingTransactionFilter();
      case JSONRPC_1.JSONRPCMethod.eth_getFilterChanges:
        return this._eth_getFilterChanges(params);
      case JSONRPC_1.JSONRPCMethod.eth_getFilterLogs:
        return this._eth_getFilterLogs(params);
    }
    return void 0;
  }
  _handleSubscriptionMethods(request) {
    switch (request.method) {
      case JSONRPC_1.JSONRPCMethod.eth_subscribe:
      case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:
        return this._subscriptionManager.handleRequest(request);
    }
    return void 0;
  }
  _isKnownAddress(addressString) {
    try {
      const addressStr = (0, util_1$5.ensureAddressString)(addressString);
      const lowercaseAddresses = this._addresses.map((address) => (0, util_1$5.ensureAddressString)(address));
      return lowercaseAddresses.includes(addressStr);
    } catch (_a2) {
    }
    return false;
  }
  _ensureKnownAddress(addressString) {
    var _a2;
    if (!this._isKnownAddress(addressString)) {
      (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$2.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED);
      throw new Error("Unknown Ethereum address");
    }
  }
  _prepareTransactionParams(tx) {
    const fromAddress = tx.from ? (0, util_1$5.ensureAddressString)(tx.from) : this.selectedAddress;
    if (!fromAddress) {
      throw new Error("Ethereum address is unavailable");
    }
    this._ensureKnownAddress(fromAddress);
    const toAddress = tx.to ? (0, util_1$5.ensureAddressString)(tx.to) : null;
    const weiValue = tx.value != null ? (0, util_1$5.ensureBN)(tx.value) : new bn_js_1.default(0);
    const data2 = tx.data ? (0, util_1$5.ensureBuffer)(tx.data) : buffer$4.Buffer.alloc(0);
    const nonce = tx.nonce != null ? (0, util_1$5.ensureIntNumber)(tx.nonce) : null;
    const gasPriceInWei = tx.gasPrice != null ? (0, util_1$5.ensureBN)(tx.gasPrice) : null;
    const maxFeePerGas = tx.maxFeePerGas != null ? (0, util_1$5.ensureBN)(tx.maxFeePerGas) : null;
    const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? (0, util_1$5.ensureBN)(tx.maxPriorityFeePerGas) : null;
    const gasLimit = tx.gas != null ? (0, util_1$5.ensureBN)(tx.gas) : null;
    const chainId = this.getChainId();
    return {
      fromAddress,
      toAddress,
      weiValue,
      data: data2,
      nonce,
      gasPriceInWei,
      maxFeePerGas,
      maxPriorityFeePerGas,
      gasLimit,
      chainId
    };
  }
  _isAuthorized() {
    return this._addresses.length > 0;
  }
  _requireAuthorization() {
    if (!this._isAuthorized()) {
      throw errors_1$1.standardErrors.provider.unauthorized({});
    }
  }
  _throwUnsupportedMethodError() {
    throw errors_1$1.standardErrors.provider.unsupportedMethod({});
  }
  async _signEthereumMessage(message, address, addPrefix, typedDataJson) {
    this._ensureKnownAddress(address);
    try {
      const relay = await this.initializeRelay();
      const res = await relay.signEthereumMessage(message, address, addPrefix, typedDataJson).promise;
      return { jsonrpc: "2.0", id: 0, result: res.result };
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw errors_1$1.standardErrors.provider.userRejectedRequest("User denied message signature");
      }
      throw err;
    }
  }
  async _ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
    const relay = await this.initializeRelay();
    const res = await relay.ethereumAddressFromSignedMessage(message, signature2, addPrefix).promise;
    return { jsonrpc: "2.0", id: 0, result: res.result };
  }
  _eth_accounts() {
    return [...this._addresses];
  }
  _eth_coinbase() {
    return this.selectedAddress || null;
  }
  _net_version() {
    return this.getChainId().toString(10);
  }
  _eth_chainId() {
    return (0, util_1$5.hexStringFromIntNumber)(this.getChainId());
  }
  getChainId() {
    const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY);
    if (!chainIdStr) {
      return (0, util_1$5.ensureIntNumber)(this._chainIdFromOpts);
    }
    const chainId = parseInt(chainIdStr, 10);
    return (0, util_1$5.ensureIntNumber)(chainId);
  }
  async _eth_requestAccounts() {
    var _a2;
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$2.EVENTS.ETH_ACCOUNTS_STATE, {
      method: "provider::_eth_requestAccounts",
      addresses_length: this._addresses.length,
      sessionIdHash: this._relay ? Session_1$2.Session.hash(this._relay.session.id) : void 0
    });
    if (this._isAuthorized()) {
      return Promise.resolve({
        jsonrpc: "2.0",
        id: 0,
        result: this._addresses
      });
    }
    let res;
    try {
      const relay = await this.initializeRelay();
      res = await relay.requestEthereumAccounts().promise;
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw errors_1$1.standardErrors.provider.userRejectedRequest("User denied account authorization");
      }
      throw err;
    }
    if (!res.result) {
      throw new Error("accounts received is empty");
    }
    this._setAddresses(res.result);
    if (!this.isCoinbaseBrowser) {
      await this.switchEthereumChain(this.getChainId());
    }
    return { jsonrpc: "2.0", id: 0, result: this._addresses };
  }
  _eth_sign(params) {
    this._requireAuthorization();
    const address = (0, util_1$5.ensureAddressString)(params[0]);
    const message = (0, util_1$5.ensureBuffer)(params[1]);
    return this._signEthereumMessage(message, address, false);
  }
  _eth_ecRecover(params) {
    const message = (0, util_1$5.ensureBuffer)(params[0]);
    const signature2 = (0, util_1$5.ensureBuffer)(params[1]);
    return this._ethereumAddressFromSignedMessage(message, signature2, false);
  }
  _personal_sign(params) {
    this._requireAuthorization();
    const message = (0, util_1$5.ensureBuffer)(params[0]);
    const address = (0, util_1$5.ensureAddressString)(params[1]);
    return this._signEthereumMessage(message, address, true);
  }
  _personal_ecRecover(params) {
    const message = (0, util_1$5.ensureBuffer)(params[0]);
    const signature2 = (0, util_1$5.ensureBuffer)(params[1]);
    return this._ethereumAddressFromSignedMessage(message, signature2, true);
  }
  async _eth_signTransaction(params) {
    this._requireAuthorization();
    const tx = this._prepareTransactionParams(params[0] || {});
    try {
      const relay = await this.initializeRelay();
      const res = await relay.signEthereumTransaction(tx).promise;
      return { jsonrpc: "2.0", id: 0, result: res.result };
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw errors_1$1.standardErrors.provider.userRejectedRequest("User denied transaction signature");
      }
      throw err;
    }
  }
  async _eth_sendRawTransaction(params) {
    const signedTransaction = (0, util_1$5.ensureBuffer)(params[0]);
    const relay = await this.initializeRelay();
    const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId()).promise;
    return { jsonrpc: "2.0", id: 0, result: res.result };
  }
  async _eth_sendTransaction(params) {
    this._requireAuthorization();
    const tx = this._prepareTransactionParams(params[0] || {});
    try {
      const relay = await this.initializeRelay();
      const res = await relay.signAndSubmitEthereumTransaction(tx).promise;
      return { jsonrpc: "2.0", id: 0, result: res.result };
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw errors_1$1.standardErrors.provider.userRejectedRequest("User denied transaction signature");
      }
      throw err;
    }
  }
  async _eth_signTypedData_v1(params) {
    this._requireAuthorization();
    const typedData = (0, util_1$5.ensureParsedJSONObject)(params[0]);
    const address = (0, util_1$5.ensureAddressString)(params[1]);
    this._ensureKnownAddress(address);
    const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({ data: typedData });
    const typedDataJSON = JSON.stringify(typedData, null, 2);
    return this._signEthereumMessage(message, address, false, typedDataJSON);
  }
  async _eth_signTypedData_v3(params) {
    this._requireAuthorization();
    const address = (0, util_1$5.ensureAddressString)(params[0]);
    const typedData = (0, util_1$5.ensureParsedJSONObject)(params[1]);
    this._ensureKnownAddress(address);
    const message = eth_eip712_util_1.default.hashForSignTypedData_v3({ data: typedData });
    const typedDataJSON = JSON.stringify(typedData, null, 2);
    return this._signEthereumMessage(message, address, false, typedDataJSON);
  }
  async _eth_signTypedData_v4(params) {
    this._requireAuthorization();
    const address = (0, util_1$5.ensureAddressString)(params[0]);
    const typedData = (0, util_1$5.ensureParsedJSONObject)(params[1]);
    this._ensureKnownAddress(address);
    const message = eth_eip712_util_1.default.hashForSignTypedData_v4({ data: typedData });
    const typedDataJSON = JSON.stringify(typedData, null, 2);
    return this._signEthereumMessage(message, address, false, typedDataJSON);
  }
  /** @deprecated */
  async _cbwallet_arbitrary(params) {
    const action = params[0];
    const data2 = params[1];
    if (typeof data2 !== "string") {
      throw new Error("parameter must be a string");
    }
    if (typeof action !== "object" || action === null) {
      throw new Error("parameter must be an object");
    }
    const result = await this.genericRequest(action, data2);
    return { jsonrpc: "2.0", id: 0, result };
  }
  async _wallet_addEthereumChain(params) {
    var _a2, _b, _c, _d;
    const request = params[0];
    if (((_a2 = request.rpcUrls) === null || _a2 === void 0 ? void 0 : _a2.length) === 0) {
      return {
        jsonrpc: "2.0",
        id: 0,
        error: { code: 2, message: `please pass in at least 1 rpcUrl` }
      };
    }
    if (!request.chainName || request.chainName.trim() === "") {
      throw errors_1$1.standardErrors.rpc.invalidParams("chainName is a required field");
    }
    if (!request.nativeCurrency) {
      throw errors_1$1.standardErrors.rpc.invalidParams("nativeCurrency is a required field");
    }
    const chainIdNumber = parseInt(request.chainId, 16);
    const success = await this.addEthereumChain(chainIdNumber, (_b = request.rpcUrls) !== null && _b !== void 0 ? _b : [], (_c = request.blockExplorerUrls) !== null && _c !== void 0 ? _c : [], request.chainName, (_d = request.iconUrls) !== null && _d !== void 0 ? _d : [], request.nativeCurrency);
    if (success) {
      return { jsonrpc: "2.0", id: 0, result: null };
    } else {
      return {
        jsonrpc: "2.0",
        id: 0,
        error: { code: 2, message: `unable to add ethereum chain` }
      };
    }
  }
  async _wallet_switchEthereumChain(params) {
    const request = params[0];
    await this.switchEthereumChain(parseInt(request.chainId, 16));
    return { jsonrpc: "2.0", id: 0, result: null };
  }
  async _wallet_watchAsset(params) {
    const request = Array.isArray(params) ? params[0] : params;
    if (!request.type) {
      throw errors_1$1.standardErrors.rpc.invalidParams("Type is required");
    }
    if ((request === null || request === void 0 ? void 0 : request.type) !== "ERC20") {
      throw errors_1$1.standardErrors.rpc.invalidParams(`Asset of type '${request.type}' is not supported`);
    }
    if (!(request === null || request === void 0 ? void 0 : request.options)) {
      throw errors_1$1.standardErrors.rpc.invalidParams("Options are required");
    }
    if (!(request === null || request === void 0 ? void 0 : request.options.address)) {
      throw errors_1$1.standardErrors.rpc.invalidParams("Address is required");
    }
    const chainId = this.getChainId();
    const { address, symbol: symbol2, image, decimals } = request.options;
    const res = await this.watchAsset(request.type, address, symbol2, decimals, image, chainId);
    return { jsonrpc: "2.0", id: 0, result: res };
  }
  _eth_uninstallFilter(params) {
    const filterId = (0, util_1$5.ensureHexString)(params[0]);
    return this._filterPolyfill.uninstallFilter(filterId);
  }
  async _eth_newFilter(params) {
    const param = params[0];
    const filterId = await this._filterPolyfill.newFilter(param);
    return { jsonrpc: "2.0", id: 0, result: filterId };
  }
  async _eth_newBlockFilter() {
    const filterId = await this._filterPolyfill.newBlockFilter();
    return { jsonrpc: "2.0", id: 0, result: filterId };
  }
  async _eth_newPendingTransactionFilter() {
    const filterId = await this._filterPolyfill.newPendingTransactionFilter();
    return { jsonrpc: "2.0", id: 0, result: filterId };
  }
  _eth_getFilterChanges(params) {
    const filterId = (0, util_1$5.ensureHexString)(params[0]);
    return this._filterPolyfill.getFilterChanges(filterId);
  }
  _eth_getFilterLogs(params) {
    const filterId = (0, util_1$5.ensureHexString)(params[0]);
    return this._filterPolyfill.getFilterLogs(filterId);
  }
  initializeRelay() {
    if (this._relay) {
      return Promise.resolve(this._relay);
    }
    return this._relayProvider().then((relay) => {
      relay.setAccountsCallback((accounts, isDisconnect) => this._setAddresses(accounts, isDisconnect));
      relay.setChainCallback((chainId, jsonRpcUrl) => {
        this.updateProviderInfo(jsonRpcUrl, parseInt(chainId, 10));
      });
      relay.setDappDefaultChainCallback(this._chainIdFromOpts);
      this._relay = relay;
      return relay;
    });
  }
}
CoinbaseWalletProvider_2 = CoinbaseWalletProvider$2.CoinbaseWalletProvider = CoinbaseWalletProvider;
const CoinbaseWalletProvider$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get CoinbaseWalletProvider() {
    return CoinbaseWalletProvider_2;
  },
  default: CoinbaseWalletProvider$2
}, [CoinbaseWalletProvider$2]);
const require$$1$c = /* @__PURE__ */ getAugmentedNamespace(CoinbaseWalletProvider$1);
var WalletSDKUI$2 = {};
var LinkFlow$2 = {};
var n, l$1, u$2, t$1, i$2, o$1, r$2, f$2, e$1, c$1 = {}, s$1 = [], a$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, h$2 = Array.isArray;
function v$3(n4, l2) {
  for (var u3 in l2)
    n4[u3] = l2[u3];
  return n4;
}
function p$3(n4) {
  var l2 = n4.parentNode;
  l2 && l2.removeChild(n4);
}
function y$2(l2, u3, t2) {
  var i3, o2, r2, f4 = {};
  for (r2 in u3)
    "key" == r2 ? i3 = u3[r2] : "ref" == r2 ? o2 = u3[r2] : f4[r2] = u3[r2];
  if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : t2), "function" == typeof l2 && null != l2.defaultProps)
    for (r2 in l2.defaultProps)
      void 0 === f4[r2] && (f4[r2] = l2.defaultProps[r2]);
  return d$2(l2, f4, i3, o2, null);
}
function d$2(n4, t2, i3, o2, r2) {
  var f4 = { type: n4, props: t2, key: i3, ref: o2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r2 ? ++u$2 : r2, __i: -1, __u: 0 };
  return null == r2 && null != l$1.vnode && l$1.vnode(f4), f4;
}
function _$2() {
  return { current: null };
}
function g$2(n4) {
  return n4.children;
}
function b$2(n4, l2) {
  this.props = n4, this.context = l2;
}
function m$3(n4, l2) {
  if (null == l2)
    return n4.__ ? m$3(n4.__, n4.__i + 1) : null;
  for (var u3; l2 < n4.__k.length; l2++)
    if (null != (u3 = n4.__k[l2]) && null != u3.__e)
      return u3.__e;
  return "function" == typeof n4.type ? m$3(n4) : null;
}
function k$2(n4) {
  var l2, u3;
  if (null != (n4 = n4.__) && null != n4.__c) {
    for (n4.__e = n4.__c.base = null, l2 = 0; l2 < n4.__k.length; l2++)
      if (null != (u3 = n4.__k[l2]) && null != u3.__e) {
        n4.__e = n4.__c.base = u3.__e;
        break;
      }
    return k$2(n4);
  }
}
function w$1(n4) {
  (!n4.__d && (n4.__d = true) && i$2.push(n4) && !x$1.__r++ || o$1 !== l$1.debounceRendering) && ((o$1 = l$1.debounceRendering) || r$2)(x$1);
}
function x$1() {
  var n4, u3, t2, o2, r2, e2, c2, s3, a3;
  for (i$2.sort(f$2); n4 = i$2.shift(); )
    n4.__d && (u3 = i$2.length, o2 = void 0, e2 = (r2 = (t2 = n4).__v).__e, s3 = [], a3 = [], (c2 = t2.__P) && ((o2 = v$3({}, r2)).__v = r2.__v + 1, l$1.vnode && l$1.vnode(o2), L$2(c2, o2, r2, t2.__n, void 0 !== c2.ownerSVGElement, 32 & r2.__u ? [e2] : null, s3, null == e2 ? m$3(r2) : e2, !!(32 & r2.__u), a3), o2.__.__k[o2.__i] = o2, M$2(s3, o2, a3), o2.__e != e2 && k$2(o2)), i$2.length > u3 && i$2.sort(f$2));
  x$1.__r = 0;
}
function C$2(n4, l2, u3, t2, i3, o2, r2, f4, e2, a3, h5) {
  var v4, p3, y3, d3, _3, g3 = t2 && t2.__k || s$1, b4 = l2.length;
  for (u3.__d = e2, P$3(u3, l2, g3), e2 = u3.__d, v4 = 0; v4 < b4; v4++)
    null != (y3 = u3.__k[v4]) && "boolean" != typeof y3 && "function" != typeof y3 && (p3 = -1 === y3.__i ? c$1 : g3[y3.__i] || c$1, y3.__i = v4, L$2(n4, y3, p3, i3, o2, r2, f4, e2, a3, h5), d3 = y3.__e, y3.ref && p3.ref != y3.ref && (p3.ref && z$3(p3.ref, null, y3), h5.push(y3.ref, y3.__c || d3, y3)), null == _3 && null != d3 && (_3 = d3), 65536 & y3.__u || p3.__k === y3.__k ? e2 = S$2(y3, e2, n4) : "function" == typeof y3.type && void 0 !== y3.__d ? e2 = y3.__d : d3 && (e2 = d3.nextSibling), y3.__d = void 0, y3.__u &= -196609);
  u3.__d = e2, u3.__e = _3;
}
function P$3(n4, l2, u3) {
  var t2, i3, o2, r2, f4, e2 = l2.length, c2 = u3.length, s3 = c2, a3 = 0;
  for (n4.__k = [], t2 = 0; t2 < e2; t2++)
    null != (i3 = n4.__k[t2] = null == (i3 = l2[t2]) || "boolean" == typeof i3 || "function" == typeof i3 ? null : "string" == typeof i3 || "number" == typeof i3 || "bigint" == typeof i3 || i3.constructor == String ? d$2(null, i3, null, null, i3) : h$2(i3) ? d$2(g$2, { children: i3 }, null, null, null) : void 0 === i3.constructor && i3.__b > 0 ? d$2(i3.type, i3.props, i3.key, i3.ref ? i3.ref : null, i3.__v) : i3) ? (i3.__ = n4, i3.__b = n4.__b + 1, f4 = H$2(i3, u3, r2 = t2 + a3, s3), i3.__i = f4, o2 = null, -1 !== f4 && (s3--, (o2 = u3[f4]) && (o2.__u |= 131072)), null == o2 || null === o2.__v ? (-1 == f4 && a3--, "function" != typeof i3.type && (i3.__u |= 65536)) : f4 !== r2 && (f4 === r2 + 1 ? a3++ : f4 > r2 ? s3 > e2 - r2 ? a3 += f4 - r2 : a3-- : a3 = f4 < r2 && f4 == r2 - 1 ? f4 - r2 : 0, f4 !== t2 + a3 && (i3.__u |= 65536))) : (o2 = u3[t2]) && null == o2.key && o2.__e && (o2.__e == n4.__d && (n4.__d = m$3(o2)), N$2(o2, o2, false), u3[t2] = null, s3--);
  if (s3)
    for (t2 = 0; t2 < c2; t2++)
      null != (o2 = u3[t2]) && 0 == (131072 & o2.__u) && (o2.__e == n4.__d && (n4.__d = m$3(o2)), N$2(o2, o2));
}
function S$2(n4, l2, u3) {
  var t2, i3;
  if ("function" == typeof n4.type) {
    for (t2 = n4.__k, i3 = 0; t2 && i3 < t2.length; i3++)
      t2[i3] && (t2[i3].__ = n4, l2 = S$2(t2[i3], l2, u3));
    return l2;
  }
  return n4.__e != l2 && (u3.insertBefore(n4.__e, l2 || null), l2 = n4.__e), l2 && l2.nextSibling;
}
function $(n4, l2) {
  return l2 = l2 || [], null == n4 || "boolean" == typeof n4 || (h$2(n4) ? n4.some(function(n5) {
    $(n5, l2);
  }) : l2.push(n4)), l2;
}
function H$2(n4, l2, u3, t2) {
  var i3 = n4.key, o2 = n4.type, r2 = u3 - 1, f4 = u3 + 1, e2 = l2[u3];
  if (null === e2 || e2 && i3 == e2.key && o2 === e2.type)
    return u3;
  if (t2 > (null != e2 && 0 == (131072 & e2.__u) ? 1 : 0))
    for (; r2 >= 0 || f4 < l2.length; ) {
      if (r2 >= 0) {
        if ((e2 = l2[r2]) && 0 == (131072 & e2.__u) && i3 == e2.key && o2 === e2.type)
          return r2;
        r2--;
      }
      if (f4 < l2.length) {
        if ((e2 = l2[f4]) && 0 == (131072 & e2.__u) && i3 == e2.key && o2 === e2.type)
          return f4;
        f4++;
      }
    }
  return -1;
}
function I$2(n4, l2, u3) {
  "-" === l2[0] ? n4.setProperty(l2, null == u3 ? "" : u3) : n4[l2] = null == u3 ? "" : "number" != typeof u3 || a$1.test(l2) ? u3 : u3 + "px";
}
function T$3(n4, l2, u3, t2, i3) {
  var o2;
  n:
    if ("style" === l2)
      if ("string" == typeof u3)
        n4.style.cssText = u3;
      else {
        if ("string" == typeof t2 && (n4.style.cssText = t2 = ""), t2)
          for (l2 in t2)
            u3 && l2 in u3 || I$2(n4.style, l2, "");
        if (u3)
          for (l2 in u3)
            t2 && u3[l2] === t2[l2] || I$2(n4.style, l2, u3[l2]);
      }
    else if ("o" === l2[0] && "n" === l2[1])
      o2 = l2 !== (l2 = l2.replace(/(PointerCapture)$|Capture$/, "$1")), l2 = l2.toLowerCase() in n4 ? l2.toLowerCase().slice(2) : l2.slice(2), n4.l || (n4.l = {}), n4.l[l2 + o2] = u3, u3 ? t2 ? u3.u = t2.u : (u3.u = Date.now(), n4.addEventListener(l2, o2 ? D$2 : A$3, o2)) : n4.removeEventListener(l2, o2 ? D$2 : A$3, o2);
    else {
      if (i3)
        l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l2 && "height" !== l2 && "href" !== l2 && "list" !== l2 && "form" !== l2 && "tabIndex" !== l2 && "download" !== l2 && "rowSpan" !== l2 && "colSpan" !== l2 && "role" !== l2 && l2 in n4)
        try {
          n4[l2] = null == u3 ? "" : u3;
          break n;
        } catch (n5) {
        }
      "function" == typeof u3 || (null == u3 || false === u3 && "-" !== l2[4] ? n4.removeAttribute(l2) : n4.setAttribute(l2, u3));
    }
}
function A$3(n4) {
  var u3 = this.l[n4.type + false];
  if (n4.t) {
    if (n4.t <= u3.u)
      return;
  } else
    n4.t = Date.now();
  return u3(l$1.event ? l$1.event(n4) : n4);
}
function D$2(n4) {
  return this.l[n4.type + true](l$1.event ? l$1.event(n4) : n4);
}
function L$2(n4, u3, t2, i3, o2, r2, f4, e2, c2, s3) {
  var a3, p3, y3, d3, _3, m2, k3, w3, x2, P2, S3, $2, H3, I3, T2, A2 = u3.type;
  if (void 0 !== u3.constructor)
    return null;
  128 & t2.__u && (c2 = !!(32 & t2.__u), r2 = [e2 = u3.__e = t2.__e]), (a3 = l$1.__b) && a3(u3);
  n:
    if ("function" == typeof A2)
      try {
        if (w3 = u3.props, x2 = (a3 = A2.contextType) && i3[a3.__c], P2 = a3 ? x2 ? x2.props.value : a3.__ : i3, t2.__c ? k3 = (p3 = u3.__c = t2.__c).__ = p3.__E : ("prototype" in A2 && A2.prototype.render ? u3.__c = p3 = new A2(w3, P2) : (u3.__c = p3 = new b$2(w3, P2), p3.constructor = A2, p3.render = O$2), x2 && x2.sub(p3), p3.props = w3, p3.state || (p3.state = {}), p3.context = P2, p3.__n = i3, y3 = p3.__d = true, p3.__h = [], p3._sb = []), null == p3.__s && (p3.__s = p3.state), null != A2.getDerivedStateFromProps && (p3.__s == p3.state && (p3.__s = v$3({}, p3.__s)), v$3(p3.__s, A2.getDerivedStateFromProps(w3, p3.__s))), d3 = p3.props, _3 = p3.state, p3.__v = u3, y3)
          null == A2.getDerivedStateFromProps && null != p3.componentWillMount && p3.componentWillMount(), null != p3.componentDidMount && p3.__h.push(p3.componentDidMount);
        else {
          if (null == A2.getDerivedStateFromProps && w3 !== d3 && null != p3.componentWillReceiveProps && p3.componentWillReceiveProps(w3, P2), !p3.__e && (null != p3.shouldComponentUpdate && false === p3.shouldComponentUpdate(w3, p3.__s, P2) || u3.__v === t2.__v)) {
            for (u3.__v !== t2.__v && (p3.props = w3, p3.state = p3.__s, p3.__d = false), u3.__e = t2.__e, u3.__k = t2.__k, u3.__k.forEach(function(n5) {
              n5 && (n5.__ = u3);
            }), S3 = 0; S3 < p3._sb.length; S3++)
              p3.__h.push(p3._sb[S3]);
            p3._sb = [], p3.__h.length && f4.push(p3);
            break n;
          }
          null != p3.componentWillUpdate && p3.componentWillUpdate(w3, p3.__s, P2), null != p3.componentDidUpdate && p3.__h.push(function() {
            p3.componentDidUpdate(d3, _3, m2);
          });
        }
        if (p3.context = P2, p3.props = w3, p3.__P = n4, p3.__e = false, $2 = l$1.__r, H3 = 0, "prototype" in A2 && A2.prototype.render) {
          for (p3.state = p3.__s, p3.__d = false, $2 && $2(u3), a3 = p3.render(p3.props, p3.state, p3.context), I3 = 0; I3 < p3._sb.length; I3++)
            p3.__h.push(p3._sb[I3]);
          p3._sb = [];
        } else
          do {
            p3.__d = false, $2 && $2(u3), a3 = p3.render(p3.props, p3.state, p3.context), p3.state = p3.__s;
          } while (p3.__d && ++H3 < 25);
        p3.state = p3.__s, null != p3.getChildContext && (i3 = v$3(v$3({}, i3), p3.getChildContext())), y3 || null == p3.getSnapshotBeforeUpdate || (m2 = p3.getSnapshotBeforeUpdate(d3, _3)), C$2(n4, h$2(T2 = null != a3 && a3.type === g$2 && null == a3.key ? a3.props.children : a3) ? T2 : [T2], u3, t2, i3, o2, r2, f4, e2, c2, s3), p3.base = u3.__e, u3.__u &= -161, p3.__h.length && f4.push(p3), k3 && (p3.__E = p3.__ = null);
      } catch (n5) {
        u3.__v = null, c2 || null != r2 ? (u3.__e = e2, u3.__u |= c2 ? 160 : 32, r2[r2.indexOf(e2)] = null) : (u3.__e = t2.__e, u3.__k = t2.__k), l$1.__e(n5, u3, t2);
      }
    else
      null == r2 && u3.__v === t2.__v ? (u3.__k = t2.__k, u3.__e = t2.__e) : u3.__e = j$1(t2.__e, u3, t2, i3, o2, r2, f4, c2, s3);
  (a3 = l$1.diffed) && a3(u3);
}
function M$2(n4, u3, t2) {
  u3.__d = void 0;
  for (var i3 = 0; i3 < t2.length; i3++)
    z$3(t2[i3], t2[++i3], t2[++i3]);
  l$1.__c && l$1.__c(u3, n4), n4.some(function(u4) {
    try {
      n4 = u4.__h, u4.__h = [], n4.some(function(n5) {
        n5.call(u4);
      });
    } catch (n5) {
      l$1.__e(n5, u4.__v);
    }
  });
}
function j$1(l2, u3, t2, i3, o2, r2, f4, e2, s3) {
  var a3, v4, y3, d3, _3, g3, b4, k3 = t2.props, w3 = u3.props, x2 = u3.type;
  if ("svg" === x2 && (o2 = true), null != r2) {
    for (a3 = 0; a3 < r2.length; a3++)
      if ((_3 = r2[a3]) && "setAttribute" in _3 == !!x2 && (x2 ? _3.localName === x2 : 3 === _3.nodeType)) {
        l2 = _3, r2[a3] = null;
        break;
      }
  }
  if (null == l2) {
    if (null === x2)
      return document.createTextNode(w3);
    l2 = o2 ? document.createElementNS("http://www.w3.org/2000/svg", x2) : document.createElement(x2, w3.is && w3), r2 = null, e2 = false;
  }
  if (null === x2)
    k3 === w3 || e2 && l2.data === w3 || (l2.data = w3);
  else {
    if (r2 = r2 && n.call(l2.childNodes), k3 = t2.props || c$1, !e2 && null != r2)
      for (k3 = {}, a3 = 0; a3 < l2.attributes.length; a3++)
        k3[(_3 = l2.attributes[a3]).name] = _3.value;
    for (a3 in k3)
      _3 = k3[a3], "children" == a3 || ("dangerouslySetInnerHTML" == a3 ? y3 = _3 : "key" === a3 || a3 in w3 || T$3(l2, a3, null, _3, o2));
    for (a3 in w3)
      _3 = w3[a3], "children" == a3 ? d3 = _3 : "dangerouslySetInnerHTML" == a3 ? v4 = _3 : "value" == a3 ? g3 = _3 : "checked" == a3 ? b4 = _3 : "key" === a3 || e2 && "function" != typeof _3 || k3[a3] === _3 || T$3(l2, a3, _3, k3[a3], o2);
    if (v4)
      e2 || y3 && (v4.__html === y3.__html || v4.__html === l2.innerHTML) || (l2.innerHTML = v4.__html), u3.__k = [];
    else if (y3 && (l2.innerHTML = ""), C$2(l2, h$2(d3) ? d3 : [d3], u3, t2, i3, o2 && "foreignObject" !== x2, r2, f4, r2 ? r2[0] : t2.__k && m$3(t2, 0), e2, s3), null != r2)
      for (a3 = r2.length; a3--; )
        null != r2[a3] && p$3(r2[a3]);
    e2 || (a3 = "value", void 0 !== g3 && (g3 !== l2[a3] || "progress" === x2 && !g3 || "option" === x2 && g3 !== k3[a3]) && T$3(l2, a3, g3, k3[a3], false), a3 = "checked", void 0 !== b4 && b4 !== l2[a3] && T$3(l2, a3, b4, k3[a3], false));
  }
  return l2;
}
function z$3(n4, u3, t2) {
  try {
    "function" == typeof n4 ? n4(u3) : n4.current = u3;
  } catch (n5) {
    l$1.__e(n5, t2);
  }
}
function N$2(n4, u3, t2) {
  var i3, o2;
  if (l$1.unmount && l$1.unmount(n4), (i3 = n4.ref) && (i3.current && i3.current !== n4.__e || z$3(i3, null, u3)), null != (i3 = n4.__c)) {
    if (i3.componentWillUnmount)
      try {
        i3.componentWillUnmount();
      } catch (n5) {
        l$1.__e(n5, u3);
      }
    i3.base = i3.__P = null, n4.__c = void 0;
  }
  if (i3 = n4.__k)
    for (o2 = 0; o2 < i3.length; o2++)
      i3[o2] && N$2(i3[o2], u3, t2 || "function" != typeof n4.type);
  t2 || null == n4.__e || p$3(n4.__e), n4.__ = n4.__e = n4.__d = void 0;
}
function O$2(n4, l2, u3) {
  return this.constructor(n4, u3);
}
function q$2(u3, t2, i3) {
  var o2, r2, f4, e2;
  l$1.__ && l$1.__(u3, t2), r2 = (o2 = "function" == typeof i3) ? null : i3 && i3.__k || t2.__k, f4 = [], e2 = [], L$2(t2, u3 = (!o2 && i3 || t2).__k = y$2(g$2, null, [u3]), r2 || c$1, c$1, void 0 !== t2.ownerSVGElement, !o2 && i3 ? [i3] : r2 ? null : t2.firstChild ? n.call(t2.childNodes) : null, f4, !o2 && i3 ? i3 : r2 ? r2.__e : t2.firstChild, o2, e2), M$2(f4, u3, e2);
}
function B$3(n4, l2) {
  q$2(n4, l2, B$3);
}
function E$2(l2, u3, t2) {
  var i3, o2, r2, f4, e2 = v$3({}, l2.props);
  for (r2 in l2.type && l2.type.defaultProps && (f4 = l2.type.defaultProps), u3)
    "key" == r2 ? i3 = u3[r2] : "ref" == r2 ? o2 = u3[r2] : e2[r2] = void 0 === u3[r2] && void 0 !== f4 ? f4[r2] : u3[r2];
  return arguments.length > 2 && (e2.children = arguments.length > 3 ? n.call(arguments, 2) : t2), d$2(l2.type, e2, i3 || l2.key, o2 || l2.ref, null);
}
function F$2(n4, l2) {
  var u3 = { __c: l2 = "__cC" + e$1++, __: n4, Consumer: function(n5, l3) {
    return n5.children(l3);
  }, Provider: function(n5) {
    var u4, t2;
    return this.getChildContext || (u4 = [], (t2 = {})[l2] = this, this.getChildContext = function() {
      return t2;
    }, this.shouldComponentUpdate = function(n6) {
      this.props.value !== n6.value && u4.some(function(n7) {
        n7.__e = true, w$1(n7);
      });
    }, this.sub = function(n6) {
      u4.push(n6);
      var l3 = n6.componentWillUnmount;
      n6.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n6), 1), l3 && l3.call(n6);
      };
    }), n5.children;
  } };
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
n = s$1.slice, l$1 = { __e: function(n4, l2, u3, t2) {
  for (var i3, o2, r2; l2 = l2.__; )
    if ((i3 = l2.__c) && !i3.__)
      try {
        if ((o2 = i3.constructor) && null != o2.getDerivedStateFromError && (i3.setState(o2.getDerivedStateFromError(n4)), r2 = i3.__d), null != i3.componentDidCatch && (i3.componentDidCatch(n4, t2 || {}), r2 = i3.__d), r2)
          return i3.__E = i3;
      } catch (l3) {
        n4 = l3;
      }
  throw n4;
} }, u$2 = 0, t$1 = function(n4) {
  return null != n4 && null == n4.constructor;
}, b$2.prototype.setState = function(n4, l2) {
  var u3;
  u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v$3({}, this.state), "function" == typeof n4 && (n4 = n4(v$3({}, u3), this.props)), n4 && v$3(u3, n4), null != n4 && this.__v && (l2 && this._sb.push(l2), w$1(this));
}, b$2.prototype.forceUpdate = function(n4) {
  this.__v && (this.__e = true, n4 && this.__h.push(n4), w$1(this));
}, b$2.prototype.render = g$2, i$2 = [], r$2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f$2 = function(n4, l2) {
  return n4.__v.__b - l2.__v.__b;
}, x$1.__r = 0, e$1 = 0;
const preact_module = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Component: b$2,
  Fragment: g$2,
  cloneElement: E$2,
  createContext: F$2,
  createElement: y$2,
  createRef: _$2,
  h: y$2,
  hydrate: B$3,
  get isValidElement() {
    return t$1;
  },
  get options() {
    return l$1;
  },
  render: q$2,
  toChildArray: $
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$b = /* @__PURE__ */ getAugmentedNamespace(preact_module);
function isFunction(x2) {
  return typeof x2 === "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      var error = /* @__PURE__ */ new Error();
      /* @__PURE__ */ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
    }
    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError$1(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var empty$1 = {
  closed: true,
  next: function(value) {
  },
  error: function(err) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      hostReportError$1(err);
    }
  },
  complete: function() {
  }
};
var isArray$1 = /* @__PURE__ */ function() {
  return Array.isArray || function(x2) {
    return x2 && typeof x2.length === "number";
  };
}();
function isObject$1(x2) {
  return x2 !== null && typeof x2 === "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function UnsubscriptionErrorImpl2(errors2) {
    Error.call(this);
    this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i3) {
      return i3 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors2;
    return this;
  }
  UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return UnsubscriptionErrorImpl2;
}();
var UnsubscriptionError = UnsubscriptionErrorImpl;
var Subscription$1 = /* @__PURE__ */ function() {
  function Subscription2(unsubscribe) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (unsubscribe) {
      this._ctorUnsubscribe = true;
      this._unsubscribe = unsubscribe;
    }
  }
  Subscription2.prototype.unsubscribe = function() {
    var errors2;
    if (this.closed) {
      return;
    }
    var _a2 = this, _parentOrParents = _a2._parentOrParents, _ctorUnsubscribe = _a2._ctorUnsubscribe, _unsubscribe = _a2._unsubscribe, _subscriptions = _a2._subscriptions;
    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (_parentOrParents instanceof Subscription2) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index2 = 0; index2 < _parentOrParents.length; ++index2) {
        var parent_1 = _parentOrParents[index2];
        parent_1.remove(this);
      }
    }
    if (isFunction(_unsubscribe)) {
      if (_ctorUnsubscribe) {
        this._unsubscribe = void 0;
      }
      try {
        _unsubscribe.call(this);
      } catch (e2) {
        errors2 = e2 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e2.errors) : [e2];
      }
    }
    if (isArray$1(_subscriptions)) {
      var index2 = -1;
      var len2 = _subscriptions.length;
      while (++index2 < len2) {
        var sub = _subscriptions[index2];
        if (isObject$1(sub)) {
          try {
            sub.unsubscribe();
          } catch (e2) {
            errors2 = errors2 || [];
            if (e2 instanceof UnsubscriptionError) {
              errors2 = errors2.concat(flattenUnsubscriptionErrors(e2.errors));
            } else {
              errors2.push(e2);
            }
          }
        }
      }
    }
    if (errors2) {
      throw new UnsubscriptionError(errors2);
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var subscription = teardown;
    if (!teardown) {
      return Subscription2.EMPTY;
    }
    switch (typeof teardown) {
      case "function":
        subscription = new Subscription2(teardown);
      case "object":
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription2)) {
          var tmp = subscription;
          subscription = new Subscription2();
          subscription._subscriptions = [tmp];
        }
        break;
      default: {
        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
      }
    }
    var _parentOrParents = subscription._parentOrParents;
    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription2) {
      if (_parentOrParents === this) {
        return subscription;
      }
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }
    var subscriptions = this._subscriptions;
    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }
    return subscription;
  };
  Subscription2.prototype.remove = function(subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);
      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };
  Subscription2.EMPTY = function(empty2) {
    empty2.closed = true;
    return empty2;
  }(new Subscription2());
  return Subscription2;
}();
function flattenUnsubscriptionErrors(errors2) {
  return errors2.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}();
var Subscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(Subscriber2, _super);
  function Subscriber2(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;
    switch (arguments.length) {
      case 0:
        _this.destination = empty$1;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = empty$1;
          break;
        }
        if (typeof destinationOrNext === "object") {
          if (destinationOrNext instanceof Subscriber2) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }
          break;
        }
      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }
    return _this;
  }
  Subscriber2.prototype[rxSubscriber] = function() {
    return this;
  };
  Subscriber2.create = function(next, error, complete) {
    var subscriber = new Subscriber2(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };
  Subscriber2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.isStopped = true;
    _super.prototype.unsubscribe.call(this);
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    this.destination.error(err);
    this.unsubscribe();
  };
  Subscriber2.prototype._complete = function() {
    this.destination.complete();
    this.unsubscribe();
  };
  Subscriber2.prototype._unsubscribeAndRecycle = function() {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };
  return Subscriber2;
}(Subscription$1);
var SafeSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SafeSubscriber2, _super);
  function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context = _this;
    if (isFunction(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== empty$1) {
        context = Object.create(observerOrNext);
        if (isFunction(context.unsubscribe)) {
          _this.add(context.unsubscribe.bind(context));
        }
        context.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }
    _this._context = context;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }
  SafeSubscriber2.prototype.next = function(value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }
        hostReportError$1(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          hostReportError$1(err);
        }
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.complete = function() {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function() {
          return _this._complete.call(_this._context);
        };
        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrUnsub = function(fn2, value) {
    try {
      fn2.call(this._context, value);
    } catch (err) {
      this.unsubscribe();
      if (config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError$1(err);
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn2, value) {
    if (!config.useDeprecatedSynchronousErrorHandling) {
      throw new Error("bad call");
    }
    try {
      fn2.call(this._context, value);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      } else {
        hostReportError$1(err);
        return true;
      }
    }
    return false;
  };
  SafeSubscriber2.prototype._unsubscribe = function() {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  };
  return SafeSubscriber2;
}(Subscriber);
function canReportError(observer) {
  while (observer) {
    var _a2 = observer, closed_1 = _a2.closed, destination = _a2.destination, isStopped = _a2.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty$1);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x2) {
  return x2;
}
function pipe$2() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  };
}
var Observable$1 = /* @__PURE__ */ function() {
  function Observable2(subscribe2) {
    this._isScalar = false;
    if (subscribe2) {
      this._subscribe = subscribe2;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber(observerOrNext, error, complete);
    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }
    if (config.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }
    return sink;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }
      if (canReportError(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscription;
      subscription = _this.subscribe(function(value) {
        try {
          next(value);
        } catch (err) {
          reject(err);
          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    return source && source.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    if (operations.length === 0) {
      return this;
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe2) {
    return new Observable2(subscribe2);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function ObjectUnsubscribedErrorImpl2() {
    Error.call(this);
    this.message = "object unsubscribed";
    this.name = "ObjectUnsubscribedError";
    return this;
  }
  ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl2;
}();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
var SubjectSubscription = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SubjectSubscription2, _super);
  function SubjectSubscription2(subject, subscriber) {
    var _this = _super.call(this) || this;
    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }
  SubjectSubscription2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;
    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }
    var subscriberIndex = observers.indexOf(this.subscriber);
    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };
  return SubjectSubscription2;
}(Subscription$1);
var SubjectSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SubjectSubscriber2, _super);
  function SubjectSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    return _this;
  }
  return SubjectSubscriber2;
}(Subscriber);
var Subject = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  };
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype.next = function(value) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    if (!this.isStopped) {
      var observers = this.observers;
      var len2 = observers.length;
      var copy2 = observers.slice();
      for (var i3 = 0; i3 < len2; i3++) {
        copy2[i3].next(value);
      }
    }
  };
  Subject2.prototype.error = function(err) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len2 = observers.length;
    var copy2 = observers.slice();
    for (var i3 = 0; i3 < len2; i3++) {
      copy2[i3].error(err);
    }
    this.observers.length = 0;
  };
  Subject2.prototype.complete = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.isStopped = true;
    var observers = this.observers;
    var len2 = observers.length;
    var copy2 = observers.slice();
    for (var i3 = 0; i3 < len2; i3++) {
      copy2[i3].complete();
    }
    this.observers.length = 0;
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };
  Subject2.prototype._trySubscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };
  Subject2.prototype._subscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription$1.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return Subscription$1.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new SubjectSubscription(this, subscriber);
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable$1();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable$1);
var AnonymousSubject = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var destination = this.destination;
    if (destination && destination.next) {
      destination.next(value);
    }
  };
  AnonymousSubject2.prototype.error = function(err) {
    var destination = this.destination;
    if (destination && destination.error) {
      this.destination.error(err);
    }
  };
  AnonymousSubject2.prototype.complete = function() {
    var destination = this.destination;
    if (destination && destination.complete) {
      this.destination.complete();
    }
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    if (source) {
      return this.source.subscribe(subscriber);
    } else {
      return Subscription$1.EMPTY;
    }
  };
  return AnonymousSubject2;
}(Subject);
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function RefCountOperator2(connectable) {
    this.connectable = connectable;
  }
  RefCountOperator2.prototype.call = function(subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);
    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }
    return subscription;
  };
  return RefCountOperator2;
}();
var RefCountSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(RefCountSubscriber2, _super);
  function RefCountSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  RefCountSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var refCount2 = connectable._refCount;
    if (refCount2 <= 0) {
      this.connection = null;
      return;
    }
    connectable._refCount = refCount2 - 1;
    if (refCount2 > 1) {
      this.connection = null;
      return;
    }
    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;
    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };
  return RefCountSubscriber2;
}(Subscriber);
var ConnectableObservable = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._refCount = 0;
    _this._isComplete = false;
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype.connect = function() {
    var connection = this._connection;
    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new Subscription$1();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription$1.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable$1);
var connectableObservableDescriptor = /* @__PURE__ */ function() {
  var connectableProto = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
  };
}();
var ConnectableSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ConnectableSubscriber2, _super);
  function ConnectableSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  ConnectableSubscriber2.prototype._error = function(err) {
    this._unsubscribe();
    _super.prototype._error.call(this, err);
  };
  ConnectableSubscriber2.prototype._complete = function() {
    this.connectable._isComplete = true;
    this._unsubscribe();
    _super.prototype._complete.call(this);
  };
  ConnectableSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;
      if (connection) {
        connection.unsubscribe();
      }
    }
  };
  return ConnectableSubscriber2;
}(SubjectSubscriber);
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source) {
    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
    this.keySelector = keySelector;
    this.elementSelector = elementSelector;
    this.durationSelector = durationSelector;
    this.subjectSelector = subjectSelector;
  }
  GroupByOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  };
  return GroupByOperator2;
}();
var GroupBySubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(GroupBySubscriber2, _super);
  function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.elementSelector = elementSelector;
    _this.durationSelector = durationSelector;
    _this.subjectSelector = subjectSelector;
    _this.groups = null;
    _this.attemptedToUnsubscribe = false;
    _this.count = 0;
    return _this;
  }
  GroupBySubscriber2.prototype._next = function(value) {
    var key2;
    try {
      key2 = this.keySelector(value);
    } catch (err) {
      this.error(err);
      return;
    }
    this._group(value, key2);
  };
  GroupBySubscriber2.prototype._group = function(value, key2) {
    var groups = this.groups;
    if (!groups) {
      groups = this.groups = /* @__PURE__ */ new Map();
    }
    var group = groups.get(key2);
    var element;
    if (this.elementSelector) {
      try {
        element = this.elementSelector(value);
      } catch (err) {
        this.error(err);
      }
    } else {
      element = value;
    }
    if (!group) {
      group = this.subjectSelector ? this.subjectSelector() : new Subject();
      groups.set(key2, group);
      var groupedObservable = new GroupedObservable(key2, group, this);
      this.destination.next(groupedObservable);
      if (this.durationSelector) {
        var duration = void 0;
        try {
          duration = this.durationSelector(new GroupedObservable(key2, group));
        } catch (err) {
          this.error(err);
          return;
        }
        this.add(duration.subscribe(new GroupDurationSubscriber(key2, group, this)));
      }
    }
    if (!group.closed) {
      group.next(element);
    }
  };
  GroupBySubscriber2.prototype._error = function(err) {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key2) {
        group.error(err);
      });
      groups.clear();
    }
    this.destination.error(err);
  };
  GroupBySubscriber2.prototype._complete = function() {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key2) {
        group.complete();
      });
      groups.clear();
    }
    this.destination.complete();
  };
  GroupBySubscriber2.prototype.removeGroup = function(key2) {
    this.groups.delete(key2);
  };
  GroupBySubscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.attemptedToUnsubscribe = true;
      if (this.count === 0) {
        _super.prototype.unsubscribe.call(this);
      }
    }
  };
  return GroupBySubscriber2;
}(Subscriber);
var GroupDurationSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(GroupDurationSubscriber2, _super);
  function GroupDurationSubscriber2(key2, group, parent) {
    var _this = _super.call(this, group) || this;
    _this.key = key2;
    _this.group = group;
    _this.parent = parent;
    return _this;
  }
  GroupDurationSubscriber2.prototype._next = function(value) {
    this.complete();
  };
  GroupDurationSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, parent = _a2.parent, key2 = _a2.key;
    this.key = this.parent = null;
    if (parent) {
      parent.removeGroup(key2);
    }
  };
  return GroupDurationSubscriber2;
}(Subscriber);
var GroupedObservable = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(GroupedObservable2, _super);
  function GroupedObservable2(key2, groupSubject, refCountSubscription) {
    var _this = _super.call(this) || this;
    _this.key = key2;
    _this.groupSubject = groupSubject;
    _this.refCountSubscription = refCountSubscription;
    return _this;
  }
  GroupedObservable2.prototype._subscribe = function(subscriber) {
    var subscription = new Subscription$1();
    var _a2 = this, refCountSubscription = _a2.refCountSubscription, groupSubject = _a2.groupSubject;
    if (refCountSubscription && !refCountSubscription.closed) {
      subscription.add(new InnerRefCountSubscription(refCountSubscription));
    }
    subscription.add(groupSubject.subscribe(subscriber));
    return subscription;
  };
  return GroupedObservable2;
}(Observable$1);
var InnerRefCountSubscription = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(InnerRefCountSubscription2, _super);
  function InnerRefCountSubscription2(parent) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    parent.count++;
    return _this;
  }
  InnerRefCountSubscription2.prototype.unsubscribe = function() {
    var parent = this.parent;
    if (!parent.closed && !this.closed) {
      _super.prototype.unsubscribe.call(this);
      parent.count -= 1;
      if (parent.count === 0 && parent.attemptedToUnsubscribe) {
        parent.unsubscribe();
      }
    }
  };
  return InnerRefCountSubscription2;
}(Subscription$1);
var BehaviorSubject = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: true,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);
var Action$1 = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(Action2, _super);
  function Action2(scheduler2, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state2, delay2) {
    return this;
  };
  return Action2;
}(Subscription$1);
var AsyncAction = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(AsyncAction2, _super);
  function AsyncAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state2;
    var id2 = this.id;
    var scheduler2 = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler2, id2, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = this.id || this.requestAsyncId(scheduler2, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return setInterval(scheduler2.flush.bind(scheduler2, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && this.delay === delay2 && this.pending === false) {
      return id2;
    }
    clearInterval(id2);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state2, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state2, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state2, delay2) {
    var errored = false;
    var errorValue = void 0;
    try {
      this.work(state2);
    } catch (e2) {
      errored = true;
      errorValue = !!e2 && e2 || new Error(e2);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype._unsubscribe = function() {
    var id2 = this.id;
    var scheduler2 = this.scheduler;
    var actions = scheduler2.actions;
    var index2 = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index2 !== -1) {
      actions.splice(index2, 1);
    }
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler2, id2, null);
    }
    this.delay = null;
  };
  return AsyncAction2;
}(Action$1);
var QueueAction = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(QueueAction2, _super);
  function QueueAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state2, delay2);
    }
    this.delay = delay2;
    this.state = state2;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state2, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
    }
    return scheduler2.flush(this);
  };
  return QueueAction2;
}(AsyncAction);
var Scheduler = /* @__PURE__ */ function() {
  function Scheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.SchedulerAction = SchedulerAction;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.SchedulerAction(this, work).schedule(state2, delay2);
  };
  Scheduler2.now = function() {
    return Date.now();
  };
  return Scheduler2;
}();
var AsyncScheduler = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
        return AsyncScheduler2.delegate.now();
      } else {
        return now();
      }
    }) || this;
    _this.actions = [];
    _this.active = false;
    _this.scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
      return AsyncScheduler2.delegate.schedule(work, delay2, state2);
    } else {
      return _super.prototype.schedule.call(this, work, delay2, state2);
    }
  };
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this.active) {
      actions.push(action);
      return;
    }
    var error;
    this.active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var QueueScheduler = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);
var queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction);
var queue = queueScheduler;
var EMPTY = /* @__PURE__ */ new Observable$1(function(subscriber) {
  return subscriber.complete();
});
function empty(scheduler2) {
  return scheduler2 ? emptyScheduled(scheduler2) : EMPTY;
}
function emptyScheduled(scheduler2) {
  return new Observable$1(function(subscriber) {
    return scheduler2.schedule(function() {
      return subscriber.complete();
    });
  });
}
function isScheduler(value) {
  return value && typeof value.schedule === "function";
}
var subscribeToArray = function(array2) {
  return function(subscriber) {
    for (var i3 = 0, len2 = array2.length; i3 < len2 && !subscriber.closed; i3++) {
      subscriber.next(array2[i3]);
    }
    subscriber.complete();
  };
};
function scheduleArray(input, scheduler2) {
  return new Observable$1(function(subscriber) {
    var sub = new Subscription$1();
    var i3 = 0;
    sub.add(scheduler2.schedule(function() {
      if (i3 === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i3++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
function fromArray$1(input, scheduler2) {
  if (!scheduler2) {
    return new Observable$1(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler2);
  }
}
function of$1() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler2 = args[args.length - 1];
  if (isScheduler(scheduler2)) {
    args.pop();
    return scheduleArray(args, scheduler2);
  } else {
    return fromArray$1(args);
  }
}
function throwError(error, scheduler2) {
  if (!scheduler2) {
    return new Observable$1(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable$1(function(subscriber) {
      return scheduler2.schedule(dispatch$7, 0, { error, subscriber });
    });
  }
}
function dispatch$7(_a2) {
  var error = _a2.error, subscriber = _a2.subscriber;
  subscriber.error(error);
}
var NotificationKind;
/* @__PURE__ */ (function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /* @__PURE__ */ function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    switch (this.kind) {
      case "N":
        return observer.next && observer.next(this.value);
      case "E":
        return observer.error && observer.error(this.error);
      case "C":
        return observer.complete && observer.complete();
    }
  };
  Notification2.prototype.do = function(next, error, complete) {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return next && next(this.value);
      case "E":
        return error && error(this.error);
      case "C":
        return complete && complete();
    }
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === "function") {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  };
  Notification2.prototype.toObservable = function() {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return of$1(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty();
    }
    throw new Error("unexpected notification kind value");
  };
  Notification2.createNext = function(value) {
    if (typeof value !== "undefined") {
      return new Notification2("N", value);
    }
    return Notification2.undefinedValueNotification;
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  Notification2.undefinedValueNotification = new Notification2("N", void 0);
  return Notification2;
}();
function observeOn(scheduler2, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler2, delay2));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function ObserveOnOperator2(scheduler2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.scheduler = scheduler2;
    this.delay = delay2;
  }
  ObserveOnOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  };
  return ObserveOnOperator2;
}();
var ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ObserveOnSubscriber2, _super);
  function ObserveOnSubscriber2(destination, scheduler2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    var _this = _super.call(this, destination) || this;
    _this.scheduler = scheduler2;
    _this.delay = delay2;
    return _this;
  }
  ObserveOnSubscriber2.dispatch = function(arg) {
    var notification = arg.notification, destination = arg.destination;
    notification.observe(destination);
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  };
  ObserveOnSubscriber2.prototype._next = function(value) {
    this.scheduleMessage(Notification.createNext(value));
  };
  ObserveOnSubscriber2.prototype._error = function(err) {
    this.scheduleMessage(Notification.createError(err));
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete());
    this.unsubscribe();
  };
  return ObserveOnSubscriber2;
}(Subscriber);
var ObserveOnMessage = /* @__PURE__ */ function() {
  function ObserveOnMessage2(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }
  return ObserveOnMessage2;
}();
var ReplaySubject = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ReplaySubject2, _super);
  function ReplaySubject2(bufferSize, windowTime2, scheduler2) {
    if (bufferSize === void 0) {
      bufferSize = Number.POSITIVE_INFINITY;
    }
    if (windowTime2 === void 0) {
      windowTime2 = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this) || this;
    _this.scheduler = scheduler2;
    _this._events = [];
    _this._infiniteTimeWindow = false;
    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
    if (windowTime2 === Number.POSITIVE_INFINITY) {
      _this._infiniteTimeWindow = true;
      _this.next = _this.nextInfiniteTimeWindow;
    } else {
      _this.next = _this.nextTimeWindow;
    }
    return _this;
  }
  ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
    if (!this.isStopped) {
      var _events = this._events;
      _events.push(value);
      if (_events.length > this._bufferSize) {
        _events.shift();
      }
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype.nextTimeWindow = function(value) {
    if (!this.isStopped) {
      this._events.push(new ReplayEvent(this._getNow(), value));
      this._trimBufferThenGetEvents();
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow;
    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
    var scheduler2 = this.scheduler;
    var len2 = _events.length;
    var subscription;
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription$1.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription(this, subscriber);
    }
    if (scheduler2) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler2));
    }
    if (_infiniteTimeWindow) {
      for (var i3 = 0; i3 < len2 && !subscriber.closed; i3++) {
        subscriber.next(_events[i3]);
      }
    } else {
      for (var i3 = 0; i3 < len2 && !subscriber.closed; i3++) {
        subscriber.next(_events[i3].value);
      }
    }
    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }
    return subscription;
  };
  ReplaySubject2.prototype._getNow = function() {
    return (this.scheduler || queue).now();
  };
  ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
    var now = this._getNow();
    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;
    while (spliceCount < eventsCount) {
      if (now - _events[spliceCount].time < _windowTime) {
        break;
      }
      spliceCount++;
    }
    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }
    return _events;
  };
  return ReplaySubject2;
}(Subject);
var ReplayEvent = /* @__PURE__ */ function() {
  function ReplayEvent2(time2, value) {
    this.time = time2;
    this.value = value;
  }
  return ReplayEvent2;
}();
var AsyncSubject = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.value = null;
    _this.hasNext = false;
    _this.hasCompleted = false;
    return _this;
  }
  AsyncSubject2.prototype._subscribe = function(subscriber) {
    if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription$1.EMPTY;
    } else if (this.hasCompleted && this.hasNext) {
      subscriber.next(this.value);
      subscriber.complete();
      return Subscription$1.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.hasCompleted) {
      this.value = value;
      this.hasNext = true;
    }
  };
  AsyncSubject2.prototype.error = function(error) {
    if (!this.hasCompleted) {
      _super.prototype.error.call(this, error);
    }
  };
  AsyncSubject2.prototype.complete = function() {
    this.hasCompleted = true;
    if (this.hasNext) {
      _super.prototype.next.call(this, this.value);
    }
    _super.prototype.complete.call(this);
  };
  return AsyncSubject2;
}(Subject);
var nextHandle = 1;
var RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}();
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb2) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    RESOLVED.then(function() {
      return findAndClearHandle(handle) && cb2();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};
var AsapAction = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(AsapAction2, _super);
  function AsapAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
    }
    scheduler2.actions.push(this);
    return scheduler2.scheduled || (scheduler2.scheduled = Immediate.setImmediate(scheduler2.flush.bind(scheduler2, null)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler2, id2, delay2);
    }
    if (scheduler2.actions.length === 0) {
      Immediate.clearImmediate(id2);
      scheduler2.scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);
var AsapScheduler = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error;
    var index2 = -1;
    var count2 = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index2 < count2 && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index2 < count2 && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);
var asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction);
var asap = asapScheduler;
var asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
var AnimationFrameAction = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
    }
    scheduler2.actions.push(this);
    return scheduler2.scheduled || (scheduler2.scheduled = requestAnimationFrame(function() {
      return scheduler2.flush(null);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler2, id2, delay2);
    }
    if (scheduler2.actions.length === 0) {
      cancelAnimationFrame(id2);
      scheduler2.scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);
var AnimationFrameScheduler = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error;
    var index2 = -1;
    var count2 = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index2 < count2 && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index2 < count2 && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);
var animationFrameScheduler = /* @__PURE__ */ new AnimationFrameScheduler(AnimationFrameAction);
var animationFrame = animationFrameScheduler;
var VirtualTimeScheduler = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
    if (SchedulerAction === void 0) {
      SchedulerAction = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
    var error, action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(VirtualAction2, _super);
  function VirtualAction2(scheduler2, work, index2) {
    if (index2 === void 0) {
      index2 = scheduler2.index += 1;
    }
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    _this.index = index2;
    _this.active = true;
    _this.index = scheduler2.index = index2;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (!this.id) {
      return _super.prototype.schedule.call(this, state2, delay2);
    }
    this.active = false;
    var action = new VirtualAction2(this.scheduler, this.work);
    this.add(action);
    return action.schedule(state2, delay2);
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler2.frame + delay2;
    var actions = scheduler2.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return true;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state2, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state2, delay2);
    }
  };
  VirtualAction2.sortActions = function(a3, b4) {
    if (a3.delay === b4.delay) {
      if (a3.index === b4.index) {
        return 0;
      } else if (a3.index > b4.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a3.delay > b4.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);
function noop$3() {
}
function isObservable$1(obj) {
  return !!obj && (obj instanceof Observable$1 || typeof obj.lift === "function" && typeof obj.subscribe === "function");
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function ArgumentOutOfRangeErrorImpl2() {
    Error.call(this);
    this.message = "argument out of range";
    this.name = "ArgumentOutOfRangeError";
    return this;
  }
  ArgumentOutOfRangeErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl2;
}();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
var EmptyErrorImpl = /* @__PURE__ */ function() {
  function EmptyErrorImpl2() {
    Error.call(this);
    this.message = "no elements in sequence";
    this.name = "EmptyError";
    return this;
  }
  EmptyErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return EmptyErrorImpl2;
}();
var EmptyError = EmptyErrorImpl;
var TimeoutErrorImpl = /* @__PURE__ */ function() {
  function TimeoutErrorImpl2() {
    Error.call(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    return this;
  }
  TimeoutErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return TimeoutErrorImpl2;
}();
var TimeoutError = TimeoutErrorImpl;
function map$2(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function MapOperator2(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }
  MapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };
  return MapOperator2;
}();
var MapSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(MapSubscriber2, _super);
  function MapSubscriber2(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  MapSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return MapSubscriber2;
}(Subscriber);
function bindCallback(callbackFunc, resultSelector, scheduler2) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler2 = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallback(callbackFunc, scheduler2).apply(void 0, args).pipe(map$2(function(args2) {
          return isArray$1(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var context = this;
    var subject;
    var params = {
      context,
      subject,
      callbackFunc,
      scheduler: scheduler2
    };
    return new Observable$1(function(subscriber) {
      if (!scheduler2) {
        if (!subject) {
          subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        var state2 = {
          args,
          subscriber,
          params
        };
        return scheduler2.schedule(dispatch$6, 0, state2);
      }
    });
  };
}
function dispatch$6(state2) {
  var _this = this;
  var args = state2.args, subscriber = state2.subscriber, params = state2.params;
  var callbackFunc = params.callbackFunc, context = params.context, scheduler2 = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
      _this.add(scheduler2.schedule(dispatchNext$3, 0, { value, subject }));
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$3(state2) {
  var value = state2.value, subject = state2.subject;
  subject.next(value);
  subject.complete();
}
function bindNodeCallback(callbackFunc, resultSelector, scheduler2) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler2 = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindNodeCallback(callbackFunc, scheduler2).apply(void 0, args).pipe(map$2(function(args2) {
          return isArray$1(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {
      subject: void 0,
      args,
      callbackFunc,
      scheduler: scheduler2,
      context: this
    };
    return new Observable$1(function(subscriber) {
      var context = params.context;
      var subject = params.subject;
      if (!scheduler2) {
        if (!subject) {
          subject = params.subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            var err = innerArgs.shift();
            if (err) {
              subject.error(err);
              return;
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        return scheduler2.schedule(dispatch$5, 0, { params, subscriber, context });
      }
    });
  };
}
function dispatch$5(state2) {
  var _this = this;
  var params = state2.params, subscriber = state2.subscriber, context = state2.context;
  var callbackFunc = params.callbackFunc, args = params.args, scheduler2 = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var err = innerArgs.shift();
      if (err) {
        _this.add(scheduler2.schedule(dispatchError, 0, { err, subject }));
      } else {
        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler2.schedule(dispatchNext$2, 0, { value, subject }));
      }
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler2.schedule(dispatchError, 0, { err, subject }));
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$2(arg) {
  var value = arg.value, subject = arg.subject;
  subject.next(value);
  subject.complete();
}
function dispatchError(arg) {
  var err = arg.err, subject = arg.subject;
  subject.error(err);
}
var OuterSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(OuterSubscriber2, _super);
  function OuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };
  OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
    this.destination.error(error);
  };
  OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.destination.complete();
  };
  return OuterSubscriber2;
}(Subscriber);
var InnerSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(InnerSubscriber2, _super);
  function InnerSubscriber2(parent, outerValue, outerIndex) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    _this.index = 0;
    return _this;
  }
  InnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  };
  InnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  };
  InnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };
  return InnerSubscriber2;
}(Subscriber);
var subscribeToPromise = function(promise) {
  return function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, hostReportError$1);
    return subscriber;
  };
};
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator();
var subscribeToIterable = function(iterable) {
  return function(subscriber) {
    var iterator$12 = iterable[iterator]();
    do {
      var item = void 0;
      try {
        item = iterator$12.next();
      } catch (err) {
        subscriber.error(err);
        return subscriber;
      }
      if (item.done) {
        subscriber.complete();
        break;
      }
      subscriber.next(item.value);
      if (subscriber.closed) {
        break;
      }
    } while (true);
    if (typeof iterator$12.return === "function") {
      subscriber.add(function() {
        if (iterator$12.return) {
          iterator$12.return();
        }
      });
    }
    return subscriber;
  };
};
var subscribeToObservable = function(obj) {
  return function(subscriber) {
    var obs = obj[observable]();
    if (typeof obs.subscribe !== "function") {
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    } else {
      return obs.subscribe(subscriber);
    }
  };
};
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}
var subscribeTo = function(result) {
  if (!!result && typeof result[observable] === "function") {
    return subscribeToObservable(result);
  } else if (isArrayLike(result)) {
    return subscribeToArray(result);
  } else if (isPromise(result)) {
    return subscribeToPromise(result);
  } else if (!!result && typeof result[iterator] === "function") {
    return subscribeToIterable(result);
  } else {
    var value = isObject$1(result) ? "an invalid object" : "'" + result + "'";
    var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
    throw new TypeError(msg);
  }
};
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable$1) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var NONE = {};
function combineLatest$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = void 0;
  var scheduler2 = void 0;
  if (isScheduler(observables[observables.length - 1])) {
    scheduler2 = observables.pop();
  }
  if (typeof observables[observables.length - 1] === "function") {
    resultSelector = observables.pop();
  }
  if (observables.length === 1 && isArray$1(observables[0])) {
    observables = observables[0];
  }
  return fromArray$1(observables, scheduler2).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /* @__PURE__ */ function() {
  function CombineLatestOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  CombineLatestOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  };
  return CombineLatestOperator2;
}();
var CombineLatestSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(CombineLatestSubscriber2, _super);
  function CombineLatestSubscriber2(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.active = 0;
    _this.values = [];
    _this.observables = [];
    return _this;
  }
  CombineLatestSubscriber2.prototype._next = function(observable2) {
    this.values.push(NONE);
    this.observables.push(observable2);
  };
  CombineLatestSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len2 = observables.length;
    if (len2 === 0) {
      this.destination.complete();
    } else {
      this.active = len2;
      this.toRespond = len2;
      for (var i3 = 0; i3 < len2; i3++) {
        var observable2 = observables[i3];
        this.add(subscribeToResult(this, observable2, void 0, i3));
      }
    }
  };
  CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
    if ((this.active -= 1) === 0) {
      this.destination.complete();
    }
  };
  CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    var values = this.values;
    var oldVal = values[outerIndex];
    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
    values[outerIndex] = innerValue;
    if (toRespond === 0) {
      if (this.resultSelector) {
        this._tryResultSelector(values);
      } else {
        this.destination.next(values.slice());
      }
    }
  };
  CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
    var result;
    try {
      result = this.resultSelector.apply(this, values);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return CombineLatestSubscriber2;
}(OuterSubscriber);
function scheduleObservable(input, scheduler2) {
  return new Observable$1(function(subscriber) {
    var sub = new Subscription$1();
    sub.add(scheduler2.schedule(function() {
      var observable$1 = input[observable]();
      sub.add(observable$1.subscribe({
        next: function(value) {
          sub.add(scheduler2.schedule(function() {
            return subscriber.next(value);
          }));
        },
        error: function(err) {
          sub.add(scheduler2.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler2.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
function schedulePromise(input, scheduler2) {
  return new Observable$1(function(subscriber) {
    var sub = new Subscription$1();
    sub.add(scheduler2.schedule(function() {
      return input.then(function(value) {
        sub.add(scheduler2.schedule(function() {
          subscriber.next(value);
          sub.add(scheduler2.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler2.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
function scheduleIterable(input, scheduler2) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable$1(function(subscriber) {
    var sub = new Subscription$1();
    var iterator$12;
    sub.add(function() {
      if (iterator$12 && typeof iterator$12.return === "function") {
        iterator$12.return();
      }
    });
    sub.add(scheduler2.schedule(function() {
      iterator$12 = input[iterator]();
      sub.add(scheduler2.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value;
        var done2;
        try {
          var result = iterator$12.next();
          value = result.value;
          done2 = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done2) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
function isIterable$2(input) {
  return input && typeof input[iterator] === "function";
}
function scheduled(input, scheduler2) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler2);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler2);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler2);
    } else if (isIterable$2(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler2);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
function from(input, scheduler2) {
  if (!scheduler2) {
    if (input instanceof Observable$1) {
      return input;
    }
    return new Observable$1(subscribeTo(input));
  } else {
    return scheduled(input, scheduler2);
  }
}
var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SimpleInnerSubscriber2, _super);
  function SimpleInnerSubscriber2(parent) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    return _this;
  }
  SimpleInnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(value);
  };
  SimpleInnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error);
    this.unsubscribe();
  };
  SimpleInnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete();
    this.unsubscribe();
  };
  return SimpleInnerSubscriber2;
}(Subscriber);
var SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SimpleOuterSubscriber2, _super);
  function SimpleOuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  SimpleOuterSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  SimpleOuterSubscriber2.prototype.notifyComplete = function() {
    this.destination.complete();
  };
  return SimpleOuterSubscriber2;
}(Subscriber);
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable$1) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error) {
    innerSubscriber.error(error);
  }
  return subscription;
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(mergeMap(function(a3, i3) {
        return from(project(a3, i3)).pipe(map$2(function(b4, ii2) {
          return resultSelector(a3, b4, i3, ii2);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function MergeMapOperator2(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    this.project = project;
    this.concurrent = concurrent;
  }
  MergeMapOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  };
  return MergeMapOperator2;
}();
var MergeMapSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(MergeMapSubscriber2, _super);
  function MergeMapSubscriber2(destination, project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeMapSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      this._tryNext(value);
    } else {
      this.buffer.push(value);
    }
  };
  MergeMapSubscriber2.prototype._tryNext = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++;
    this._innerSub(result);
  };
  MergeMapSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  MergeMapSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  };
  return MergeMapSubscriber2;
}(SimpleOuterSubscriber);
var flatMap = mergeMap;
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat$2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return concatAll()(of$1.apply(void 0, observables));
}
function defer$1(observableFactory) {
  return new Observable$1(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = input ? from(input) : empty();
    return source.subscribe(subscriber);
  });
}
function forkJoin() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 1) {
    var first_1 = sources[0];
    if (isArray$1(first_1)) {
      return forkJoinInternal(first_1, null);
    }
    if (isObject$1(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys2 = Object.keys(first_1);
      return forkJoinInternal(keys2.map(function(key2) {
        return first_1[key2];
      }), keys2);
    }
  }
  if (typeof sources[sources.length - 1] === "function") {
    var resultSelector_1 = sources.pop();
    sources = sources.length === 1 && isArray$1(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe(map$2(function(args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys2) {
  return new Observable$1(function(subscriber) {
    var len2 = sources.length;
    if (len2 === 0) {
      subscriber.complete();
      return;
    }
    var values = new Array(len2);
    var completed = 0;
    var emitted = 0;
    var _loop_1 = function(i4) {
      var source = from(sources[i4]);
      var hasValue = false;
      subscriber.add(source.subscribe({
        next: function(value) {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }
          values[i4] = value;
        },
        error: function(err) {
          return subscriber.error(err);
        },
        complete: function() {
          completed++;
          if (completed === len2 || !hasValue) {
            if (emitted === len2) {
              subscriber.next(keys2 ? keys2.reduce(function(result, key2, i5) {
                return result[key2] = values[i5], result;
              }, {}) : values);
            }
            subscriber.complete();
          }
        }
      }));
    };
    for (var i3 = 0; i3 < len2; i3++) {
      _loop_1(i3);
    }
  });
}
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(map$2(function(args) {
      return isArray$1(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable$1(function(subscriber) {
    function handler(e2) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e2);
      }
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe;
  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe = function() {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe = function() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe = function() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i3 = 0, len2 = sourceObj.length; i3 < len2; i3++) {
      setupSubscription(sourceObj[i3], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError("Invalid event target");
  }
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === "function" && typeof sourceObj.removeListener === "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === "function" && typeof sourceObj.off === "function";
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === "function" && typeof sourceObj.removeEventListener === "function";
}
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(map$2(function(args) {
      return isArray$1(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable$1(function(subscriber) {
    var handler = function() {
      var e2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e2[_i] = arguments[_i];
      }
      return subscriber.next(e2.length === 1 ? e2[0] : e2);
    };
    var retValue;
    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!isFunction(removeHandler)) {
      return void 0;
    }
    return function() {
      return removeHandler(handler, retValue);
    };
  });
}
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler2) {
  var resultSelector;
  var initialState;
  if (arguments.length == 1) {
    var options = initialStateOrOptions;
    initialState = options.initialState;
    condition = options.condition;
    iterate = options.iterate;
    resultSelector = options.resultSelector || identity;
    scheduler2 = options.scheduler;
  } else if (resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable)) {
    initialState = initialStateOrOptions;
    resultSelector = identity;
    scheduler2 = resultSelectorOrObservable;
  } else {
    initialState = initialStateOrOptions;
    resultSelector = resultSelectorOrObservable;
  }
  return new Observable$1(function(subscriber) {
    var state2 = initialState;
    if (scheduler2) {
      return scheduler2.schedule(dispatch$4, 0, {
        subscriber,
        iterate,
        condition,
        resultSelector,
        state: state2
      });
    }
    do {
      if (condition) {
        var conditionResult = void 0;
        try {
          conditionResult = condition(state2);
        } catch (err) {
          subscriber.error(err);
          return void 0;
        }
        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }
      var value = void 0;
      try {
        value = resultSelector(state2);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      subscriber.next(value);
      if (subscriber.closed) {
        break;
      }
      try {
        state2 = iterate(state2);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
    } while (true);
    return void 0;
  });
}
function dispatch$4(state2) {
  var subscriber = state2.subscriber, condition = state2.condition;
  if (subscriber.closed) {
    return void 0;
  }
  if (state2.needIterate) {
    try {
      state2.state = state2.iterate(state2.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
  } else {
    state2.needIterate = true;
  }
  if (condition) {
    var conditionResult = void 0;
    try {
      conditionResult = condition(state2.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!conditionResult) {
      subscriber.complete();
      return void 0;
    }
    if (subscriber.closed) {
      return void 0;
    }
  }
  var value;
  try {
    value = state2.resultSelector(state2.state);
  } catch (err) {
    subscriber.error(err);
    return void 0;
  }
  if (subscriber.closed) {
    return void 0;
  }
  subscriber.next(value);
  if (subscriber.closed) {
    return void 0;
  }
  return this.schedule(state2);
}
function iif(condition, trueResult, falseResult) {
  if (trueResult === void 0) {
    trueResult = EMPTY;
  }
  if (falseResult === void 0) {
    falseResult = EMPTY;
  }
  return defer$1(function() {
    return condition() ? trueResult : falseResult;
  });
}
function isNumeric(val) {
  return !isArray$1(val) && val - parseFloat(val) + 1 >= 0;
}
function interval(period, scheduler2) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  if (!isNumeric(period) || period < 0) {
    period = 0;
  }
  if (!scheduler2 || typeof scheduler2.schedule !== "function") {
    scheduler2 = async;
  }
  return new Observable$1(function(subscriber) {
    subscriber.add(scheduler2.schedule(dispatch$3, period, { subscriber, counter: 0, period }));
    return subscriber;
  });
}
function dispatch$3(state2) {
  var subscriber = state2.subscriber, counter = state2.counter, period = state2.period;
  subscriber.next(counter);
  this.schedule({ subscriber, counter: counter + 1, period }, period);
}
function merge$2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler2 = null;
  var last2 = observables[observables.length - 1];
  if (isScheduler(last2)) {
    scheduler2 = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
      concurrent = observables.pop();
    }
  } else if (typeof last2 === "number") {
    concurrent = observables.pop();
  }
  if (scheduler2 === null && observables.length === 1 && observables[0] instanceof Observable$1) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray$1(observables, scheduler2));
}
var NEVER = /* @__PURE__ */ new Observable$1(noop$3);
function never() {
  return NEVER;
}
function onErrorResumeNext$1() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 0) {
    return EMPTY;
  }
  var first2 = sources[0], remainder = sources.slice(1);
  if (sources.length === 1 && isArray$1(first2)) {
    return onErrorResumeNext$1.apply(void 0, first2);
  }
  return new Observable$1(function(subscriber) {
    var subNext = function() {
      return subscriber.add(onErrorResumeNext$1.apply(void 0, remainder).subscribe(subscriber));
    };
    return from(first2).subscribe({
      next: function(value) {
        subscriber.next(value);
      },
      error: subNext,
      complete: subNext
    });
  });
}
function pairs(obj, scheduler2) {
  if (!scheduler2) {
    return new Observable$1(function(subscriber) {
      var keys2 = Object.keys(obj);
      for (var i3 = 0; i3 < keys2.length && !subscriber.closed; i3++) {
        var key2 = keys2[i3];
        if (obj.hasOwnProperty(key2)) {
          subscriber.next([key2, obj[key2]]);
        }
      }
      subscriber.complete();
    });
  } else {
    return new Observable$1(function(subscriber) {
      var keys2 = Object.keys(obj);
      var subscription = new Subscription$1();
      subscription.add(scheduler2.schedule(dispatch$2, 0, { keys: keys2, index: 0, subscriber, subscription, obj }));
      return subscription;
    });
  }
}
function dispatch$2(state2) {
  var keys2 = state2.keys, index2 = state2.index, subscriber = state2.subscriber, subscription = state2.subscription, obj = state2.obj;
  if (!subscriber.closed) {
    if (index2 < keys2.length) {
      var key2 = keys2[index2];
      subscriber.next([key2, obj[key2]]);
      subscription.add(this.schedule({ keys: keys2, index: index2 + 1, subscriber, subscription, obj }));
    } else {
      subscriber.complete();
    }
  }
}
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
function filter$2(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function FilterOperator2(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }
  FilterOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  };
  return FilterOperator2;
}();
var FilterSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(FilterSubscriber2, _super);
  function FilterSubscriber2(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.count = 0;
    return _this;
  }
  FilterSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.destination.next(value);
    }
  };
  return FilterSubscriber2;
}(Subscriber);
function partition$1(source, predicate, thisArg) {
  return [
    filter$2(predicate, thisArg)(new Observable$1(subscribeTo(source))),
    filter$2(not(predicate, thisArg))(new Observable$1(subscribeTo(source)))
  ];
}
function race$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  if (observables.length === 1) {
    if (isArray$1(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return fromArray$1(observables, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function RaceOperator2() {
  }
  RaceOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RaceSubscriber(subscriber));
  };
  return RaceOperator2;
}();
var RaceSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(RaceSubscriber2, _super);
  function RaceSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasFirst = false;
    _this.observables = [];
    _this.subscriptions = [];
    return _this;
  }
  RaceSubscriber2.prototype._next = function(observable2) {
    this.observables.push(observable2);
  };
  RaceSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len2 = observables.length;
    if (len2 === 0) {
      this.destination.complete();
    } else {
      for (var i3 = 0; i3 < len2 && !this.hasFirst; i3++) {
        var observable2 = observables[i3];
        var subscription = subscribeToResult(this, observable2, void 0, i3);
        if (this.subscriptions) {
          this.subscriptions.push(subscription);
        }
        this.add(subscription);
      }
      this.observables = null;
    }
  };
  RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    if (!this.hasFirst) {
      this.hasFirst = true;
      for (var i3 = 0; i3 < this.subscriptions.length; i3++) {
        if (i3 !== outerIndex) {
          var subscription = this.subscriptions[i3];
          subscription.unsubscribe();
          this.remove(subscription);
        }
      }
      this.subscriptions = null;
    }
    this.destination.next(innerValue);
  };
  return RaceSubscriber2;
}(OuterSubscriber);
function range(start, count2, scheduler2) {
  if (start === void 0) {
    start = 0;
  }
  return new Observable$1(function(subscriber) {
    if (count2 === void 0) {
      count2 = start;
      start = 0;
    }
    var index2 = 0;
    var current = start;
    if (scheduler2) {
      return scheduler2.schedule(dispatch$1, 0, {
        index: index2,
        count: count2,
        start,
        subscriber
      });
    } else {
      do {
        if (index2++ >= count2) {
          subscriber.complete();
          break;
        }
        subscriber.next(current++);
        if (subscriber.closed) {
          break;
        }
      } while (true);
    }
    return void 0;
  });
}
function dispatch$1(state2) {
  var start = state2.start, index2 = state2.index, count2 = state2.count, subscriber = state2.subscriber;
  if (index2 >= count2) {
    subscriber.complete();
    return;
  }
  subscriber.next(start);
  if (subscriber.closed) {
    return;
  }
  state2.index = index2 + 1;
  state2.start = start + 1;
  this.schedule(state2);
}
function timer(dueTime, periodOrScheduler, scheduler2) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler2 = periodOrScheduler;
  }
  if (!isScheduler(scheduler2)) {
    scheduler2 = async;
  }
  return new Observable$1(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler2.now();
    return scheduler2.schedule(dispatch, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch(state2) {
  var index2 = state2.index, period = state2.period, subscriber = state2.subscriber;
  subscriber.next(index2);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state2.index = index2 + 1;
  this.schedule(state2, period);
}
function using(resourceFactory, observableFactory) {
  return new Observable$1(function(subscriber) {
    var resource;
    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var result;
    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = result ? from(result) : EMPTY;
    var subscription = source.subscribe(subscriber);
    return function() {
      subscription.unsubscribe();
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
function zip$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === "function") {
    observables.pop();
  }
  return fromArray$1(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /* @__PURE__ */ function() {
  function ZipOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  ZipOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  };
  return ZipOperator2;
}();
var ZipSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ZipSubscriber2, _super);
  function ZipSubscriber2(destination, resultSelector, values) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.iterators = [];
    _this.active = 0;
    _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
    return _this;
  }
  ZipSubscriber2.prototype._next = function(value) {
    var iterators = this.iterators;
    if (isArray$1(value)) {
      iterators.push(new StaticArrayIterator(value));
    } else if (typeof value[iterator] === "function") {
      iterators.push(new StaticIterator(value[iterator]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value));
    }
  };
  ZipSubscriber2.prototype._complete = function() {
    var iterators = this.iterators;
    var len2 = iterators.length;
    this.unsubscribe();
    if (len2 === 0) {
      this.destination.complete();
      return;
    }
    this.active = len2;
    for (var i3 = 0; i3 < len2; i3++) {
      var iterator2 = iterators[i3];
      if (iterator2.stillUnsubscribed) {
        var destination = this.destination;
        destination.add(iterator2.subscribe());
      } else {
        this.active--;
      }
    }
  };
  ZipSubscriber2.prototype.notifyInactive = function() {
    this.active--;
    if (this.active === 0) {
      this.destination.complete();
    }
  };
  ZipSubscriber2.prototype.checkIterators = function() {
    var iterators = this.iterators;
    var len2 = iterators.length;
    var destination = this.destination;
    for (var i3 = 0; i3 < len2; i3++) {
      var iterator2 = iterators[i3];
      if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
        return;
      }
    }
    var shouldComplete = false;
    var args = [];
    for (var i3 = 0; i3 < len2; i3++) {
      var iterator2 = iterators[i3];
      var result = iterator2.next();
      if (iterator2.hasCompleted()) {
        shouldComplete = true;
      }
      if (result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }
    if (shouldComplete) {
      destination.complete();
    }
  };
  ZipSubscriber2.prototype._tryresultSelector = function(args) {
    var result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return ZipSubscriber2;
}(Subscriber);
var StaticIterator = /* @__PURE__ */ function() {
  function StaticIterator2(iterator2) {
    this.iterator = iterator2;
    this.nextResult = iterator2.next();
  }
  StaticIterator2.prototype.hasValue = function() {
    return true;
  };
  StaticIterator2.prototype.next = function() {
    var result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  };
  StaticIterator2.prototype.hasCompleted = function() {
    var nextResult = this.nextResult;
    return Boolean(nextResult && nextResult.done);
  };
  return StaticIterator2;
}();
var StaticArrayIterator = /* @__PURE__ */ function() {
  function StaticArrayIterator2(array2) {
    this.array = array2;
    this.index = 0;
    this.length = 0;
    this.length = array2.length;
  }
  StaticArrayIterator2.prototype[iterator] = function() {
    return this;
  };
  StaticArrayIterator2.prototype.next = function(value) {
    var i3 = this.index++;
    var array2 = this.array;
    return i3 < this.length ? { value: array2[i3], done: false } : { value: null, done: true };
  };
  StaticArrayIterator2.prototype.hasValue = function() {
    return this.array.length > this.index;
  };
  StaticArrayIterator2.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  };
  return StaticArrayIterator2;
}();
var ZipBufferIterator = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ZipBufferIterator2, _super);
  function ZipBufferIterator2(destination, parent, observable2) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent;
    _this.observable = observable2;
    _this.stillUnsubscribed = true;
    _this.buffer = [];
    _this.isComplete = false;
    return _this;
  }
  ZipBufferIterator2.prototype[iterator] = function() {
    return this;
  };
  ZipBufferIterator2.prototype.next = function() {
    var buffer2 = this.buffer;
    if (buffer2.length === 0 && this.isComplete) {
      return { value: null, done: true };
    } else {
      return { value: buffer2.shift(), done: false };
    }
  };
  ZipBufferIterator2.prototype.hasValue = function() {
    return this.buffer.length > 0;
  };
  ZipBufferIterator2.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  };
  ZipBufferIterator2.prototype.notifyComplete = function() {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  };
  ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  };
  ZipBufferIterator2.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  };
  return ZipBufferIterator2;
}(SimpleOuterSubscriber);
const _esm5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArgumentOutOfRangeError,
  AsyncSubject,
  BehaviorSubject,
  ConnectableObservable,
  EMPTY,
  EmptyError,
  GroupedObservable,
  NEVER,
  Notification,
  get NotificationKind() {
    return NotificationKind;
  },
  ObjectUnsubscribedError,
  Observable: Observable$1,
  ReplaySubject,
  Scheduler,
  Subject,
  Subscriber,
  Subscription: Subscription$1,
  TimeoutError,
  UnsubscriptionError,
  VirtualAction,
  VirtualTimeScheduler,
  animationFrame,
  animationFrameScheduler,
  asap,
  asapScheduler,
  async,
  asyncScheduler,
  bindCallback,
  bindNodeCallback,
  combineLatest: combineLatest$1,
  concat: concat$2,
  config,
  defer: defer$1,
  empty,
  forkJoin,
  from,
  fromEvent,
  fromEventPattern,
  generate,
  identity,
  iif,
  interval,
  isObservable: isObservable$1,
  merge: merge$2,
  never,
  noop: noop$3,
  observable,
  of: of$1,
  onErrorResumeNext: onErrorResumeNext$1,
  pairs,
  partition: partition$1,
  pipe: pipe$2,
  queue,
  queueScheduler,
  race: race$1,
  range,
  scheduled,
  throwError,
  timer,
  using,
  zip: zip$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$a = /* @__PURE__ */ getAugmentedNamespace(_esm5);
var ConnectDialog$2 = {};
function r$1(e2) {
  var t2, f4, n4 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n4 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2))
      for (t2 = 0; t2 < e2.length; t2++)
        e2[t2] && (f4 = r$1(e2[t2])) && (n4 && (n4 += " "), n4 += f4);
    else
      for (t2 in e2)
        e2[t2] && (n4 && (n4 += " "), n4 += t2);
  return n4;
}
function clsx() {
  for (var e2, t2, f4 = 0, n4 = ""; f4 < arguments.length; )
    (e2 = arguments[f4++]) && (t2 = r$1(e2)) && (n4 && (n4 += " "), n4 += t2);
  return n4;
}
const clsx_m = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx,
  default: clsx
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$q = /* @__PURE__ */ getAugmentedNamespace(clsx_m);
var t, r, u$1, i$1, o = 0, f$1 = [], c = [], e = l$1.__b, a = l$1.__r, v$2 = l$1.diffed, l = l$1.__c, m$2 = l$1.unmount;
function d$1(t2, u3) {
  l$1.__h && l$1.__h(r, t2, o || u3), o = 0;
  var i3 = r.__H || (r.__H = { __: [], __h: [] });
  return t2 >= i3.__.length && i3.__.push({ __V: c }), i3.__[t2];
}
function h$1(n4) {
  return o = 1, s(B$2, n4);
}
function s(n4, u3, i3) {
  var o2 = d$1(t++, 2);
  if (o2.t = n4, !o2.__c && (o2.__ = [i3 ? i3(u3) : B$2(void 0, u3), function(n5) {
    var t2 = o2.__N ? o2.__N[0] : o2.__[0], r2 = o2.t(t2, n5);
    t2 !== r2 && (o2.__N = [r2, o2.__[1]], o2.__c.setState({}));
  }], o2.__c = r, !r.u)) {
    var f4 = function(n5, t2, r2) {
      if (!o2.__c.__H)
        return true;
      var u4 = o2.__c.__H.__.filter(function(n6) {
        return n6.__c;
      });
      if (u4.every(function(n6) {
        return !n6.__N;
      }))
        return !c2 || c2.call(this, n5, t2, r2);
      var i4 = false;
      return u4.forEach(function(n6) {
        if (n6.__N) {
          var t3 = n6.__[0];
          n6.__ = n6.__N, n6.__N = void 0, t3 !== n6.__[0] && (i4 = true);
        }
      }), !(!i4 && o2.__c.props === n5) && (!c2 || c2.call(this, n5, t2, r2));
    };
    r.u = true;
    var c2 = r.shouldComponentUpdate, e2 = r.componentWillUpdate;
    r.componentWillUpdate = function(n5, t2, r2) {
      if (this.__e) {
        var u4 = c2;
        c2 = void 0, f4(n5, t2, r2), c2 = u4;
      }
      e2 && e2.call(this, n5, t2, r2);
    }, r.shouldComponentUpdate = f4;
  }
  return o2.__N || o2.__;
}
function p$2(u3, i3) {
  var o2 = d$1(t++, 3);
  !l$1.__s && z$2(o2.__H, i3) && (o2.__ = u3, o2.i = i3, r.__H.__h.push(o2));
}
function y$1(u3, i3) {
  var o2 = d$1(t++, 4);
  !l$1.__s && z$2(o2.__H, i3) && (o2.__ = u3, o2.i = i3, r.__h.push(o2));
}
function _$1(n4) {
  return o = 5, F$1(function() {
    return { current: n4 };
  }, []);
}
function A$2(n4, t2, r2) {
  o = 6, y$1(function() {
    return "function" == typeof n4 ? (n4(t2()), function() {
      return n4(null);
    }) : n4 ? (n4.current = t2(), function() {
      return n4.current = null;
    }) : void 0;
  }, null == r2 ? r2 : r2.concat(n4));
}
function F$1(n4, r2) {
  var u3 = d$1(t++, 7);
  return z$2(u3.__H, r2) ? (u3.__V = n4(), u3.i = r2, u3.__h = n4, u3.__V) : u3.__;
}
function T$2(n4, t2) {
  return o = 8, F$1(function() {
    return n4;
  }, t2);
}
function q$1(n4) {
  var u3 = r.context[n4.__c], i3 = d$1(t++, 9);
  return i3.c = n4, u3 ? (null == i3.__ && (i3.__ = true, u3.sub(r)), u3.props.value) : n4.__;
}
function x(t2, r2) {
  l$1.useDebugValue && l$1.useDebugValue(r2 ? r2(t2) : t2);
}
function P$2(n4) {
  var u3 = d$1(t++, 10), i3 = h$1();
  return u3.__ = n4, r.componentDidCatch || (r.componentDidCatch = function(n5, t2) {
    u3.__ && u3.__(n5, t2), i3[1](n5);
  }), [i3[0], function() {
    i3[1](void 0);
  }];
}
function V$1() {
  var n4 = d$1(t++, 11);
  if (!n4.__) {
    for (var u3 = r.__v; null !== u3 && !u3.__m && null !== u3.__; )
      u3 = u3.__;
    var i3 = u3.__m || (u3.__m = [0, 0]);
    n4.__ = "P" + i3[0] + "-" + i3[1]++;
  }
  return n4.__;
}
function b$1() {
  for (var t2; t2 = f$1.shift(); )
    if (t2.__P && t2.__H)
      try {
        t2.__H.__h.forEach(k$1), t2.__H.__h.forEach(w), t2.__H.__h = [];
      } catch (r2) {
        t2.__H.__h = [], l$1.__e(r2, t2.__v);
      }
}
l$1.__b = function(n4) {
  r = null, e && e(n4);
}, l$1.__r = function(n4) {
  a && a(n4), t = 0;
  var i3 = (r = n4.__c).__H;
  i3 && (u$1 === r ? (i3.__h = [], r.__h = [], i3.__.forEach(function(n5) {
    n5.__N && (n5.__ = n5.__N), n5.__V = c, n5.__N = n5.i = void 0;
  })) : (i3.__h.forEach(k$1), i3.__h.forEach(w), i3.__h = [], t = 0)), u$1 = r;
}, l$1.diffed = function(t2) {
  v$2 && v$2(t2);
  var o2 = t2.__c;
  o2 && o2.__H && (o2.__H.__h.length && (1 !== f$1.push(o2) && i$1 === l$1.requestAnimationFrame || ((i$1 = l$1.requestAnimationFrame) || j)(b$1)), o2.__H.__.forEach(function(n4) {
    n4.i && (n4.__H = n4.i), n4.__V !== c && (n4.__ = n4.__V), n4.i = void 0, n4.__V = c;
  })), u$1 = r = null;
}, l$1.__c = function(t2, r2) {
  r2.some(function(t3) {
    try {
      t3.__h.forEach(k$1), t3.__h = t3.__h.filter(function(n4) {
        return !n4.__ || w(n4);
      });
    } catch (u3) {
      r2.some(function(n4) {
        n4.__h && (n4.__h = []);
      }), r2 = [], l$1.__e(u3, t3.__v);
    }
  }), l && l(t2, r2);
}, l$1.unmount = function(t2) {
  m$2 && m$2(t2);
  var r2, u3 = t2.__c;
  u3 && u3.__H && (u3.__H.__.forEach(function(n4) {
    try {
      k$1(n4);
    } catch (n5) {
      r2 = n5;
    }
  }), u3.__H = void 0, r2 && l$1.__e(r2, u3.__v));
};
var g$1 = "function" == typeof requestAnimationFrame;
function j(n4) {
  var t2, r2 = function() {
    clearTimeout(u3), g$1 && cancelAnimationFrame(t2), setTimeout(n4);
  }, u3 = setTimeout(r2, 100);
  g$1 && (t2 = requestAnimationFrame(r2));
}
function k$1(n4) {
  var t2 = r, u3 = n4.__c;
  "function" == typeof u3 && (n4.__c = void 0, u3()), r = t2;
}
function w(n4) {
  var t2 = r;
  n4.__c = n4.__(), r = t2;
}
function z$2(n4, t2) {
  return !n4 || n4.length !== t2.length || t2.some(function(t3, r2) {
    return t3 !== n4[r2];
  });
}
function B$2(n4, t2) {
  return "function" == typeof t2 ? t2(n4) : t2;
}
const hooks_module = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useCallback: T$2,
  useContext: q$1,
  useDebugValue: x,
  useEffect: p$2,
  useErrorBoundary: P$2,
  useId: V$1,
  useImperativeHandle: A$2,
  useLayoutEffect: y$1,
  useMemo: F$1,
  useReducer: s,
  useRef: _$1,
  useState: h$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$2$7 = /* @__PURE__ */ getAugmentedNamespace(hooks_module);
var ConnectContent$2 = {};
var CloseIcon$2 = {};
Object.defineProperty(CloseIcon$2, "__esModule", { value: true });
var CloseIcon_2 = CloseIcon$2.CloseIcon = void 0;
const preact_1$b = require$$1$b;
function CloseIcon(props) {
  return (0, preact_1$b.h)(
    "svg",
    Object.assign({ width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, props),
    (0, preact_1$b.h)("path", { d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z" })
  );
}
CloseIcon_2 = CloseIcon$2.CloseIcon = CloseIcon;
const CloseIcon$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get CloseIcon() {
    return CloseIcon_2;
  },
  default: CloseIcon$2
}, [CloseIcon$2]);
const require$$5$5 = /* @__PURE__ */ getAugmentedNamespace(CloseIcon$1);
var coinbaseRoundSvg$1 = {};
Object.defineProperty(coinbaseRoundSvg$1, "__esModule", { value: true });
var _default$a = coinbaseRoundSvg$1.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMTQuMDM3IDE4LjkyNmMtMi43NSAwLTQuOTA3LTIuMjA1LTQuOTA3LTQuOTI2IDAtMi43MiAyLjIzLTQuOTI2IDQuOTA3LTQuOTI2YTQuODY2IDQuODY2IDAgMCAxIDQuODMzIDQuMTE4aDQuOTgyYy0uNDQ2LTUuMDczLTQuNjg0LTkuMDQ0LTkuODE1LTkuMDQ0QzguNjEgNC4xNDggNC4xNDkgOC41NiA0LjE0OSAxNHM0LjM4NyA5Ljg1MiA5Ljg5IDkuODUyYzUuMjA0IDAgOS4zNjgtMy45NyA5LjgxNC05LjA0M0gxOC44N2E0Ljg2NiA0Ljg2NiAwIDAgMS00LjgzMyA0LjExN1oiIGZpbGw9IiNmZmYiLz48L3N2Zz4=`;
const coinbaseRoundSvg = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$a
}, [coinbaseRoundSvg$1]);
const require$$6$5 = /* @__PURE__ */ getAugmentedNamespace(coinbaseRoundSvg);
var coinbaseWalletRoundSvg$1 = {};
Object.defineProperty(coinbaseWalletRoundSvg$1, "__esModule", { value: true });
var _default$9 = coinbaseWalletRoundSvg$1.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMjMuODUyIDE0QTkuODM0IDkuODM0IDAgMCAxIDE0IDIzLjg1MiA5LjgzNCA5LjgzNCAwIDAgMSA0LjE0OCAxNCA5LjgzNCA5LjgzNCAwIDAgMSAxNCA0LjE0OCA5LjgzNCA5LjgzNCAwIDAgMSAyMy44NTIgMTRaIiBmaWxsPSIjZmZmIi8+PHBhdGggZD0iTTExLjE4NSAxMi41MDRjMC0uNDU2IDAtLjcxLjA5OC0uODYyLjA5OC0uMTUyLjE5Ni0uMzA0LjM0My0uMzU1LjE5Ni0uMTAyLjM5Mi0uMTAyLjg4MS0uMTAyaDIuOTg2Yy40OSAwIC42ODYgMCAuODgyLjEwMi4xNDYuMTAxLjI5My4yMDMuMzQyLjM1NS4wOTguMjAzLjA5OC40MDYuMDk4Ljg2MnYyLjk5MmMwIC40NTcgMCAuNzEtLjA5OC44NjMtLjA5OC4xNTItLjE5NS4zMDQtLjM0Mi4zNTUtLjE5Ni4xMDEtLjM5Mi4xMDEtLjg4Mi4xMDFoLTIuOTg2Yy0uNDkgMC0uNjg1IDAtLjg4LS4xMDEtLjE0OC0uMTAyLS4yOTUtLjIwMy0uMzQ0LS4zNTUtLjA5OC0uMjAzLS4wOTgtLjQwNi0uMDk4LS44NjN2LTIuOTkyWiIgZmlsbD0iIzAwNTJGRiIvPjwvc3ZnPg==`;
const coinbaseWalletRoundSvg = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$9
}, [coinbaseWalletRoundSvg$1]);
const require$$7$1 = /* @__PURE__ */ getAugmentedNamespace(coinbaseWalletRoundSvg);
var QRCodeIcon$2 = {};
Object.defineProperty(QRCodeIcon$2, "__esModule", { value: true });
var QRCodeIcon_2 = QRCodeIcon$2.QRCodeIcon = void 0;
const preact_1$a = require$$1$b;
function QRCodeIcon(props) {
  return (0, preact_1$a.h)(
    "svg",
    Object.assign({ width: "10", height: "10", viewBox: "0 0 10 10", xmlns: "http://www.w3.org/2000/svg" }, props),
    (0, preact_1$a.h)("path", { d: "M8.2271 1.77124L7.0271 1.77124V2.97124H8.2271V1.77124Z" }),
    (0, preact_1$a.h)("path", { d: "M5.44922 0.199219L5.44922 4.54922L9.79922 4.54922V0.199219L5.44922 0.199219ZM8.89922 3.64922L6.34922 3.64922L6.34922 1.09922L8.89922 1.09922V3.64922Z" }),
    (0, preact_1$a.h)("path", { d: "M2.97124 1.77124L1.77124 1.77124L1.77124 2.97124H2.97124V1.77124Z" }),
    (0, preact_1$a.h)("path", { d: "M0.199219 4.54922L4.54922 4.54922L4.54922 0.199219L0.199219 0.199219L0.199219 4.54922ZM1.09922 1.09922L3.64922 1.09922L3.64922 3.64922L1.09922 3.64922L1.09922 1.09922Z" }),
    (0, preact_1$a.h)("path", { d: "M2.97124 7.0271H1.77124L1.77124 8.2271H2.97124V7.0271Z" }),
    (0, preact_1$a.h)("path", { d: "M0.199219 9.79922H4.54922L4.54922 5.44922L0.199219 5.44922L0.199219 9.79922ZM1.09922 6.34922L3.64922 6.34922L3.64922 8.89922H1.09922L1.09922 6.34922Z" }),
    (0, preact_1$a.h)("path", { d: "M8.89922 7.39912H7.99922V5.40112H5.44922L5.44922 9.79912H6.34922L6.34922 6.30112H7.09922V8.29912H9.79922V5.40112H8.89922V7.39912Z" }),
    (0, preact_1$a.h)("path", { d: "M7.99912 8.89917H7.09912V9.79917H7.99912V8.89917Z" }),
    (0, preact_1$a.h)("path", { d: "M9.79917 8.89917H8.89917V9.79917H9.79917V8.89917Z" })
  );
}
QRCodeIcon_2 = QRCodeIcon$2.QRCodeIcon = QRCodeIcon;
const QRCodeIcon$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get QRCodeIcon() {
    return QRCodeIcon_2;
  },
  default: QRCodeIcon$2
}, [QRCodeIcon$2]);
const require$$8$1 = /* @__PURE__ */ getAugmentedNamespace(QRCodeIcon$1);
var QRLogoCoinbase$1 = {};
Object.defineProperty(QRLogoCoinbase$1, "__esModule", { value: true });
const svg = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M50 100C77.6142 100 100 77.6142 100 50C100 22.3858 77.6142 0 50 0C22.3858 0 0 22.3858 0 50C0 77.6142 22.3858 100 50 100Z" fill="white"/>
        <path d="M50.512 94C74.2907 94 93.5673 74.5244 93.5673 50.5C93.5673 26.4756 74.2907 7 50.512 7C26.7332 7 7.45667 26.4756 7.45667 50.5C7.45667 74.5244 26.7332 94 50.512 94Z" fill="#0052FF"/>
        <path d="M50.6248 65.4335C42.3697 65.4335 35.8996 58.7469 35.8996 50.5C35.8996 42.2531 42.5928 35.5664 50.6248 35.5664C57.9873 35.5664 64.0111 40.9157 65.1267 48.0481H80.0749C78.7363 32.6688 66.0191 20.6328 50.6248 20.6328C34.3379 20.6328 20.9514 34.0062 20.9514 50.5C20.9514 66.9936 34.1148 80.3671 50.6248 80.3671C66.2422 80.3671 78.7363 68.331 80.0749 52.9516H65.1267C64.0111 60.0841 57.9873 65.4335 50.6248 65.4335Z" fill="white"/>
    </svg>
`;
var _default$8 = QRLogoCoinbase$1.default = svg;
const QRLogoCoinbase = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$8
}, [QRLogoCoinbase$1]);
const require$$9 = /* @__PURE__ */ getAugmentedNamespace(QRLogoCoinbase);
var QRLogoWallet$1 = {};
Object.defineProperty(QRLogoWallet$1, "__esModule", { value: true });
var _default$7 = QRLogoWallet$1.default = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="50" cy="50" r="50" fill="white"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" fill="#1B53E4"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" stroke="white"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M19.3379 49.9484C19.3379 66.8508 33.04 80.553 49.9425 80.553C66.8449 80.553 80.5471 66.8508 80.5471 49.9484C80.5471 33.0459 66.8449 19.3438 49.9425 19.3438C33.04 19.3438 19.3379 33.0459 19.3379 49.9484ZM44.0817 40.0799C41.8725 40.0799 40.0817 41.8708 40.0817 44.0799V55.8029C40.0817 58.012 41.8725 59.8029 44.0817 59.8029H55.8046C58.0138 59.8029 59.8046 58.012 59.8046 55.8029V44.0799C59.8046 41.8708 58.0138 40.0799 55.8046 40.0799H44.0817Z" fill="white"/>
    </svg>
`;
const QRLogoWallet = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$7
}, [QRLogoWallet$1]);
const require$$10 = /* @__PURE__ */ getAugmentedNamespace(QRLogoWallet);
var StatusDotIcon$2 = {};
Object.defineProperty(StatusDotIcon$2, "__esModule", { value: true });
var StatusDotIcon_2 = StatusDotIcon$2.StatusDotIcon = void 0;
const preact_1$9 = require$$1$b;
function StatusDotIcon(props) {
  return (0, preact_1$9.h)(
    "svg",
    Object.assign({ width: "10", height: "10", viewBox: "0 0 10 10", xmlns: "http://www.w3.org/2000/svg" }, props),
    (0, preact_1$9.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M2.29995 4.99995C2.29995 5.57985 1.82985 6.04995 1.24995 6.04995C0.670052 6.04995 0.199951 5.57985 0.199951 4.99995C0.199951 4.42005 0.670052 3.94995 1.24995 3.94995C1.82985 3.94995 2.29995 4.42005 2.29995 4.99995ZM4.99995 6.04995C5.57985 6.04995 6.04995 5.57985 6.04995 4.99995C6.04995 4.42005 5.57985 3.94995 4.99995 3.94995C4.42005 3.94995 3.94995 4.42005 3.94995 4.99995C3.94995 5.57985 4.42005 6.04995 4.99995 6.04995ZM8.74995 6.04995C9.32985 6.04995 9.79995 5.57985 9.79995 4.99995C9.79995 4.42005 9.32985 3.94995 8.74995 3.94995C8.17005 3.94995 7.69995 4.42005 7.69995 4.99995C7.69995 5.57985 8.17005 6.04995 8.74995 6.04995Z" })
  );
}
StatusDotIcon_2 = StatusDotIcon$2.StatusDotIcon = StatusDotIcon;
const StatusDotIcon$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get StatusDotIcon() {
    return StatusDotIcon_2;
  },
  default: StatusDotIcon$2
}, [StatusDotIcon$2]);
const require$$11 = /* @__PURE__ */ getAugmentedNamespace(StatusDotIcon$1);
var QRCode$3 = {};
function QR8bitByte(data2) {
  this.mode = QRMode.MODE_8BIT_BYTE;
  this.data = data2;
  this.parsedData = [];
  for (var i3 = 0, l2 = this.data.length; i3 < l2; i3++) {
    var byteArray = [];
    var code2 = this.data.charCodeAt(i3);
    if (code2 > 65536) {
      byteArray[0] = 240 | (code2 & 1835008) >>> 18;
      byteArray[1] = 128 | (code2 & 258048) >>> 12;
      byteArray[2] = 128 | (code2 & 4032) >>> 6;
      byteArray[3] = 128 | code2 & 63;
    } else if (code2 > 2048) {
      byteArray[0] = 224 | (code2 & 61440) >>> 12;
      byteArray[1] = 128 | (code2 & 4032) >>> 6;
      byteArray[2] = 128 | code2 & 63;
    } else if (code2 > 128) {
      byteArray[0] = 192 | (code2 & 1984) >>> 6;
      byteArray[1] = 128 | code2 & 63;
    } else {
      byteArray[0] = code2;
    }
    this.parsedData.push(byteArray);
  }
  this.parsedData = Array.prototype.concat.apply([], this.parsedData);
  if (this.parsedData.length != this.data.length) {
    this.parsedData.unshift(191);
    this.parsedData.unshift(187);
    this.parsedData.unshift(239);
  }
}
QR8bitByte.prototype = {
  getLength: function(buffer2) {
    return this.parsedData.length;
  },
  write: function(buffer2) {
    for (var i3 = 0, l2 = this.parsedData.length; i3 < l2; i3++) {
      buffer2.put(this.parsedData[i3], 8);
    }
  }
};
function QRCodeModel(typeNumber, errorCorrectLevel) {
  this.typeNumber = typeNumber;
  this.errorCorrectLevel = errorCorrectLevel;
  this.modules = null;
  this.moduleCount = 0;
  this.dataCache = null;
  this.dataList = [];
}
QRCodeModel.prototype = { addData: function(data2) {
  var newData = new QR8bitByte(data2);
  this.dataList.push(newData);
  this.dataCache = null;
}, isDark: function(row, col) {
  if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
    throw new Error(row + "," + col);
  }
  return this.modules[row][col];
}, getModuleCount: function() {
  return this.moduleCount;
}, make: function() {
  this.makeImpl(false, this.getBestMaskPattern());
}, makeImpl: function(test, maskPattern2) {
  this.moduleCount = this.typeNumber * 4 + 17;
  this.modules = new Array(this.moduleCount);
  for (var row = 0; row < this.moduleCount; row++) {
    this.modules[row] = new Array(this.moduleCount);
    for (var col = 0; col < this.moduleCount; col++) {
      this.modules[row][col] = null;
    }
  }
  this.setupPositionProbePattern(0, 0);
  this.setupPositionProbePattern(this.moduleCount - 7, 0);
  this.setupPositionProbePattern(0, this.moduleCount - 7);
  this.setupPositionAdjustPattern();
  this.setupTimingPattern();
  this.setupTypeInfo(test, maskPattern2);
  if (this.typeNumber >= 7) {
    this.setupTypeNumber(test);
  }
  if (this.dataCache == null) {
    this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
  }
  this.mapData(this.dataCache, maskPattern2);
}, setupPositionProbePattern: function(row, col) {
  for (var r2 = -1; r2 <= 7; r2++) {
    if (row + r2 <= -1 || this.moduleCount <= row + r2)
      continue;
    for (var c2 = -1; c2 <= 7; c2++) {
      if (col + c2 <= -1 || this.moduleCount <= col + c2)
        continue;
      if (0 <= r2 && r2 <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r2 == 0 || r2 == 6) || 2 <= r2 && r2 <= 4 && 2 <= c2 && c2 <= 4) {
        this.modules[row + r2][col + c2] = true;
      } else {
        this.modules[row + r2][col + c2] = false;
      }
    }
  }
}, getBestMaskPattern: function() {
  var minLostPoint = 0;
  var pattern2 = 0;
  for (var i3 = 0; i3 < 8; i3++) {
    this.makeImpl(true, i3);
    var lostPoint = QRUtil.getLostPoint(this);
    if (i3 == 0 || minLostPoint > lostPoint) {
      minLostPoint = lostPoint;
      pattern2 = i3;
    }
  }
  return pattern2;
}, createMovieClip: function(target_mc, instance_name, depth) {
  var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
  var cs2 = 1;
  this.make();
  for (var row = 0; row < this.modules.length; row++) {
    var y3 = row * cs2;
    for (var col = 0; col < this.modules[row].length; col++) {
      var x2 = col * cs2;
      var dark = this.modules[row][col];
      if (dark) {
        qr_mc.beginFill(0, 100);
        qr_mc.moveTo(x2, y3);
        qr_mc.lineTo(x2 + cs2, y3);
        qr_mc.lineTo(x2 + cs2, y3 + cs2);
        qr_mc.lineTo(x2, y3 + cs2);
        qr_mc.endFill();
      }
    }
  }
  return qr_mc;
}, setupTimingPattern: function() {
  for (var r2 = 8; r2 < this.moduleCount - 8; r2++) {
    if (this.modules[r2][6] != null) {
      continue;
    }
    this.modules[r2][6] = r2 % 2 == 0;
  }
  for (var c2 = 8; c2 < this.moduleCount - 8; c2++) {
    if (this.modules[6][c2] != null) {
      continue;
    }
    this.modules[6][c2] = c2 % 2 == 0;
  }
}, setupPositionAdjustPattern: function() {
  var pos = QRUtil.getPatternPosition(this.typeNumber);
  for (var i3 = 0; i3 < pos.length; i3++) {
    for (var j2 = 0; j2 < pos.length; j2++) {
      var row = pos[i3];
      var col = pos[j2];
      if (this.modules[row][col] != null) {
        continue;
      }
      for (var r2 = -2; r2 <= 2; r2++) {
        for (var c2 = -2; c2 <= 2; c2++) {
          if (r2 == -2 || r2 == 2 || c2 == -2 || c2 == 2 || r2 == 0 && c2 == 0) {
            this.modules[row + r2][col + c2] = true;
          } else {
            this.modules[row + r2][col + c2] = false;
          }
        }
      }
    }
  }
}, setupTypeNumber: function(test) {
  var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
  for (var i3 = 0; i3 < 18; i3++) {
    var mod2 = !test && (bits >> i3 & 1) == 1;
    this.modules[Math.floor(i3 / 3)][i3 % 3 + this.moduleCount - 8 - 3] = mod2;
  }
  for (var i3 = 0; i3 < 18; i3++) {
    var mod2 = !test && (bits >> i3 & 1) == 1;
    this.modules[i3 % 3 + this.moduleCount - 8 - 3][Math.floor(i3 / 3)] = mod2;
  }
}, setupTypeInfo: function(test, maskPattern2) {
  var data2 = this.errorCorrectLevel << 3 | maskPattern2;
  var bits = QRUtil.getBCHTypeInfo(data2);
  for (var i3 = 0; i3 < 15; i3++) {
    var mod2 = !test && (bits >> i3 & 1) == 1;
    if (i3 < 6) {
      this.modules[i3][8] = mod2;
    } else if (i3 < 8) {
      this.modules[i3 + 1][8] = mod2;
    } else {
      this.modules[this.moduleCount - 15 + i3][8] = mod2;
    }
  }
  for (var i3 = 0; i3 < 15; i3++) {
    var mod2 = !test && (bits >> i3 & 1) == 1;
    if (i3 < 8) {
      this.modules[8][this.moduleCount - i3 - 1] = mod2;
    } else if (i3 < 9) {
      this.modules[8][15 - i3 - 1 + 1] = mod2;
    } else {
      this.modules[8][15 - i3 - 1] = mod2;
    }
  }
  this.modules[this.moduleCount - 8][8] = !test;
}, mapData: function(data2, maskPattern2) {
  var inc2 = -1;
  var row = this.moduleCount - 1;
  var bitIndex = 7;
  var byteIndex = 0;
  for (var col = this.moduleCount - 1; col > 0; col -= 2) {
    if (col == 6)
      col--;
    while (true) {
      for (var c2 = 0; c2 < 2; c2++) {
        if (this.modules[row][col - c2] == null) {
          var dark = false;
          if (byteIndex < data2.length) {
            dark = (data2[byteIndex] >>> bitIndex & 1) == 1;
          }
          var mask2 = QRUtil.getMask(maskPattern2, row, col - c2);
          if (mask2) {
            dark = !dark;
          }
          this.modules[row][col - c2] = dark;
          bitIndex--;
          if (bitIndex == -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc2;
      if (row < 0 || this.moduleCount <= row) {
        row -= inc2;
        inc2 = -inc2;
        break;
      }
    }
  }
} };
QRCodeModel.PAD0 = 236;
QRCodeModel.PAD1 = 17;
QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
  var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
  var buffer2 = new QRBitBuffer();
  for (var i3 = 0; i3 < dataList.length; i3++) {
    var data2 = dataList[i3];
    buffer2.put(data2.mode, 4);
    buffer2.put(data2.getLength(), QRUtil.getLengthInBits(data2.mode, typeNumber));
    data2.write(buffer2);
  }
  var totalDataCount = 0;
  for (var i3 = 0; i3 < rsBlocks.length; i3++) {
    totalDataCount += rsBlocks[i3].dataCount;
  }
  if (buffer2.getLengthInBits() > totalDataCount * 8) {
    throw new Error("code length overflow. (" + buffer2.getLengthInBits() + ">" + totalDataCount * 8 + ")");
  }
  if (buffer2.getLengthInBits() + 4 <= totalDataCount * 8) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 != 0) {
    buffer2.putBit(false);
  }
  while (true) {
    if (buffer2.getLengthInBits() >= totalDataCount * 8) {
      break;
    }
    buffer2.put(QRCodeModel.PAD0, 8);
    if (buffer2.getLengthInBits() >= totalDataCount * 8) {
      break;
    }
    buffer2.put(QRCodeModel.PAD1, 8);
  }
  return QRCodeModel.createBytes(buffer2, rsBlocks);
};
QRCodeModel.createBytes = function(buffer2, rsBlocks) {
  var offset = 0;
  var maxDcCount = 0;
  var maxEcCount = 0;
  var dcdata = new Array(rsBlocks.length);
  var ecdata = new Array(rsBlocks.length);
  for (var r2 = 0; r2 < rsBlocks.length; r2++) {
    var dcCount = rsBlocks[r2].dataCount;
    var ecCount = rsBlocks[r2].totalCount - dcCount;
    maxDcCount = Math.max(maxDcCount, dcCount);
    maxEcCount = Math.max(maxEcCount, ecCount);
    dcdata[r2] = new Array(dcCount);
    for (var i3 = 0; i3 < dcdata[r2].length; i3++) {
      dcdata[r2][i3] = 255 & buffer2.buffer[i3 + offset];
    }
    offset += dcCount;
    var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
    var rawPoly = new QRPolynomial(dcdata[r2], rsPoly.getLength() - 1);
    var modPoly = rawPoly.mod(rsPoly);
    ecdata[r2] = new Array(rsPoly.getLength() - 1);
    for (var i3 = 0; i3 < ecdata[r2].length; i3++) {
      var modIndex = i3 + modPoly.getLength() - ecdata[r2].length;
      ecdata[r2][i3] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
    }
  }
  var totalCodeCount = 0;
  for (var i3 = 0; i3 < rsBlocks.length; i3++) {
    totalCodeCount += rsBlocks[i3].totalCount;
  }
  var data2 = new Array(totalCodeCount);
  var index2 = 0;
  for (var i3 = 0; i3 < maxDcCount; i3++) {
    for (var r2 = 0; r2 < rsBlocks.length; r2++) {
      if (i3 < dcdata[r2].length) {
        data2[index2++] = dcdata[r2][i3];
      }
    }
  }
  for (var i3 = 0; i3 < maxEcCount; i3++) {
    for (var r2 = 0; r2 < rsBlocks.length; r2++) {
      if (i3 < ecdata[r2].length) {
        data2[index2++] = ecdata[r2][i3];
      }
    }
  }
  return data2;
};
var QRMode = { MODE_NUMBER: 1 << 0, MODE_ALPHA_NUM: 1 << 1, MODE_8BIT_BYTE: 1 << 2, MODE_KANJI: 1 << 3 };
var QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };
var QRMaskPattern = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
var QRUtil = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0, G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0, G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1, getBCHTypeInfo: function(data2) {
  var d3 = data2 << 10;
  while (QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
    d3 ^= QRUtil.G15 << QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G15);
  }
  return (data2 << 10 | d3) ^ QRUtil.G15_MASK;
}, getBCHTypeNumber: function(data2) {
  var d3 = data2 << 12;
  while (QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
    d3 ^= QRUtil.G18 << QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G18);
  }
  return data2 << 12 | d3;
}, getBCHDigit: function(data2) {
  var digit = 0;
  while (data2 != 0) {
    digit++;
    data2 >>>= 1;
  }
  return digit;
}, getPatternPosition: function(typeNumber) {
  return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
}, getMask: function(maskPattern2, i3, j2) {
  switch (maskPattern2) {
    case QRMaskPattern.PATTERN000:
      return (i3 + j2) % 2 == 0;
    case QRMaskPattern.PATTERN001:
      return i3 % 2 == 0;
    case QRMaskPattern.PATTERN010:
      return j2 % 3 == 0;
    case QRMaskPattern.PATTERN011:
      return (i3 + j2) % 3 == 0;
    case QRMaskPattern.PATTERN100:
      return (Math.floor(i3 / 2) + Math.floor(j2 / 3)) % 2 == 0;
    case QRMaskPattern.PATTERN101:
      return i3 * j2 % 2 + i3 * j2 % 3 == 0;
    case QRMaskPattern.PATTERN110:
      return (i3 * j2 % 2 + i3 * j2 % 3) % 2 == 0;
    case QRMaskPattern.PATTERN111:
      return (i3 * j2 % 3 + (i3 + j2) % 2) % 2 == 0;
    default:
      throw new Error("bad maskPattern:" + maskPattern2);
  }
}, getErrorCorrectPolynomial: function(errorCorrectLength) {
  var a3 = new QRPolynomial([1], 0);
  for (var i3 = 0; i3 < errorCorrectLength; i3++) {
    a3 = a3.multiply(new QRPolynomial([1, QRMath.gexp(i3)], 0));
  }
  return a3;
}, getLengthInBits: function(mode2, type2) {
  if (1 <= type2 && type2 < 10) {
    switch (mode2) {
      case QRMode.MODE_NUMBER:
        return 10;
      case QRMode.MODE_ALPHA_NUM:
        return 9;
      case QRMode.MODE_8BIT_BYTE:
        return 8;
      case QRMode.MODE_KANJI:
        return 8;
      default:
        throw new Error("mode:" + mode2);
    }
  } else if (type2 < 27) {
    switch (mode2) {
      case QRMode.MODE_NUMBER:
        return 12;
      case QRMode.MODE_ALPHA_NUM:
        return 11;
      case QRMode.MODE_8BIT_BYTE:
        return 16;
      case QRMode.MODE_KANJI:
        return 10;
      default:
        throw new Error("mode:" + mode2);
    }
  } else if (type2 < 41) {
    switch (mode2) {
      case QRMode.MODE_NUMBER:
        return 14;
      case QRMode.MODE_ALPHA_NUM:
        return 13;
      case QRMode.MODE_8BIT_BYTE:
        return 16;
      case QRMode.MODE_KANJI:
        return 12;
      default:
        throw new Error("mode:" + mode2);
    }
  } else {
    throw new Error("type:" + type2);
  }
}, getLostPoint: function(qrCode) {
  var moduleCount = qrCode.getModuleCount();
  var lostPoint = 0;
  for (var row = 0; row < moduleCount; row++) {
    for (var col = 0; col < moduleCount; col++) {
      var sameCount = 0;
      var dark = qrCode.isDark(row, col);
      for (var r2 = -1; r2 <= 1; r2++) {
        if (row + r2 < 0 || moduleCount <= row + r2) {
          continue;
        }
        for (var c2 = -1; c2 <= 1; c2++) {
          if (col + c2 < 0 || moduleCount <= col + c2) {
            continue;
          }
          if (r2 == 0 && c2 == 0) {
            continue;
          }
          if (dark == qrCode.isDark(row + r2, col + c2)) {
            sameCount++;
          }
        }
      }
      if (sameCount > 5) {
        lostPoint += 3 + sameCount - 5;
      }
    }
  }
  for (var row = 0; row < moduleCount - 1; row++) {
    for (var col = 0; col < moduleCount - 1; col++) {
      var count2 = 0;
      if (qrCode.isDark(row, col))
        count2++;
      if (qrCode.isDark(row + 1, col))
        count2++;
      if (qrCode.isDark(row, col + 1))
        count2++;
      if (qrCode.isDark(row + 1, col + 1))
        count2++;
      if (count2 == 0 || count2 == 4) {
        lostPoint += 3;
      }
    }
  }
  for (var row = 0; row < moduleCount; row++) {
    for (var col = 0; col < moduleCount - 6; col++) {
      if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
        lostPoint += 40;
      }
    }
  }
  for (var col = 0; col < moduleCount; col++) {
    for (var row = 0; row < moduleCount - 6; row++) {
      if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
        lostPoint += 40;
      }
    }
  }
  var darkCount = 0;
  for (var col = 0; col < moduleCount; col++) {
    for (var row = 0; row < moduleCount; row++) {
      if (qrCode.isDark(row, col)) {
        darkCount++;
      }
    }
  }
  var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
  lostPoint += ratio * 10;
  return lostPoint;
} };
var QRMath = { glog: function(n4) {
  if (n4 < 1) {
    throw new Error("glog(" + n4 + ")");
  }
  return QRMath.LOG_TABLE[n4];
}, gexp: function(n4) {
  while (n4 < 0) {
    n4 += 255;
  }
  while (n4 >= 256) {
    n4 -= 255;
  }
  return QRMath.EXP_TABLE[n4];
}, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) };
for (var i = 0; i < 8; i++) {
  QRMath.EXP_TABLE[i] = 1 << i;
}
for (var i = 8; i < 256; i++) {
  QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
}
for (var i = 0; i < 255; i++) {
  QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
}
function QRPolynomial(num, shift) {
  if (num.length == void 0) {
    throw new Error(num.length + "/" + shift);
  }
  var offset = 0;
  while (offset < num.length && num[offset] == 0) {
    offset++;
  }
  this.num = new Array(num.length - offset + shift);
  for (var i3 = 0; i3 < num.length - offset; i3++) {
    this.num[i3] = num[i3 + offset];
  }
}
QRPolynomial.prototype = { get: function(index2) {
  return this.num[index2];
}, getLength: function() {
  return this.num.length;
}, multiply: function(e2) {
  var num = new Array(this.getLength() + e2.getLength() - 1);
  for (var i3 = 0; i3 < this.getLength(); i3++) {
    for (var j2 = 0; j2 < e2.getLength(); j2++) {
      num[i3 + j2] ^= QRMath.gexp(QRMath.glog(this.get(i3)) + QRMath.glog(e2.get(j2)));
    }
  }
  return new QRPolynomial(num, 0);
}, mod: function(e2) {
  if (this.getLength() - e2.getLength() < 0) {
    return this;
  }
  var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e2.get(0));
  var num = new Array(this.getLength());
  for (var i3 = 0; i3 < this.getLength(); i3++) {
    num[i3] = this.get(i3);
  }
  for (var i3 = 0; i3 < e2.getLength(); i3++) {
    num[i3] ^= QRMath.gexp(QRMath.glog(e2.get(i3)) + ratio);
  }
  return new QRPolynomial(num, 0).mod(e2);
} };
function QRRSBlock(totalCount, dataCount) {
  this.totalCount = totalCount;
  this.dataCount = dataCount;
}
QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
  var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
  if (rsBlock == void 0) {
    throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
  }
  var length2 = rsBlock.length / 3;
  var list = [];
  for (var i3 = 0; i3 < length2; i3++) {
    var count2 = rsBlock[i3 * 3 + 0];
    var totalCount = rsBlock[i3 * 3 + 1];
    var dataCount = rsBlock[i3 * 3 + 2];
    for (var j2 = 0; j2 < count2; j2++) {
      list.push(new QRRSBlock(totalCount, dataCount));
    }
  }
  return list;
};
QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
  switch (errorCorrectLevel) {
    case QRErrorCorrectLevel.L:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
    case QRErrorCorrectLevel.M:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
    case QRErrorCorrectLevel.Q:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
    case QRErrorCorrectLevel.H:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
    default:
      return void 0;
  }
};
function QRBitBuffer() {
  this.buffer = [];
  this.length = 0;
}
QRBitBuffer.prototype = { get: function(index2) {
  var bufIndex = Math.floor(index2 / 8);
  return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) == 1;
}, put: function(num, length2) {
  for (var i3 = 0; i3 < length2; i3++) {
    this.putBit((num >>> length2 - i3 - 1 & 1) == 1);
  }
}, getLengthInBits: function() {
  return this.length;
}, putBit: function(bit) {
  var bufIndex = Math.floor(this.length / 8);
  if (this.buffer.length <= bufIndex) {
    this.buffer.push(0);
  }
  if (bit) {
    this.buffer[bufIndex] |= 128 >>> this.length % 8;
  }
  this.length++;
} };
var QRCodeLimitLength = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
function QRCode$2(options) {
  this.options = {
    padding: 4,
    width: 256,
    height: 256,
    typeNumber: 4,
    color: "#000000",
    background: "#ffffff",
    ecl: "M",
    image: {
      svg: "",
      width: 0,
      height: 0
    }
  };
  if (typeof options === "string") {
    options = {
      content: options
    };
  }
  if (options) {
    for (var i3 in options) {
      this.options[i3] = options[i3];
    }
  }
  if (typeof this.options.content !== "string") {
    throw new Error("Expected 'content' as string!");
  }
  if (this.options.content.length === 0) {
    throw new Error("Expected 'content' to be non-empty!");
  }
  if (!(this.options.padding >= 0)) {
    throw new Error("Expected 'padding' value to be non-negative!");
  }
  if (!(this.options.width > 0) || !(this.options.height > 0)) {
    throw new Error("Expected 'width' or 'height' value to be higher than zero!");
  }
  function _getErrorCorrectLevel(ecl2) {
    switch (ecl2) {
      case "L":
        return QRErrorCorrectLevel.L;
      case "M":
        return QRErrorCorrectLevel.M;
      case "Q":
        return QRErrorCorrectLevel.Q;
      case "H":
        return QRErrorCorrectLevel.H;
      default:
        throw new Error("Unknwon error correction level: " + ecl2);
    }
  }
  function _getTypeNumber(content2, ecl2) {
    var length2 = _getUTF8Length(content2);
    var type3 = 1;
    var limit = 0;
    for (var i4 = 0, len2 = QRCodeLimitLength.length; i4 <= len2; i4++) {
      var table = QRCodeLimitLength[i4];
      if (!table) {
        throw new Error("Content too long: expected " + limit + " but got " + length2);
      }
      switch (ecl2) {
        case "L":
          limit = table[0];
          break;
        case "M":
          limit = table[1];
          break;
        case "Q":
          limit = table[2];
          break;
        case "H":
          limit = table[3];
          break;
        default:
          throw new Error("Unknwon error correction level: " + ecl2);
      }
      if (length2 <= limit) {
        break;
      }
      type3++;
    }
    if (type3 > QRCodeLimitLength.length) {
      throw new Error("Content too long");
    }
    return type3;
  }
  function _getUTF8Length(content2) {
    var result = encodeURI(content2).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
    return result.length + (result.length != content2 ? 3 : 0);
  }
  var content = this.options.content;
  var type2 = _getTypeNumber(content, this.options.ecl);
  var ecl = _getErrorCorrectLevel(this.options.ecl);
  this.qrcode = new QRCodeModel(type2, ecl);
  this.qrcode.addData(content);
  this.qrcode.make();
}
QRCode$2.prototype.svg = function(opt) {
  var options = this.options || {};
  var modules = this.qrcode.modules;
  if (typeof opt == "undefined") {
    opt = { container: options.container || "svg" };
  }
  var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;
  var indent2 = pretty ? "  " : "";
  var EOL = pretty ? "\r\n" : "";
  var width = options.width;
  var height = options.height;
  var length2 = modules.length;
  var xsize = width / (length2 + 2 * options.padding);
  var ysize = height / (length2 + 2 * options.padding);
  var join2 = typeof options.join != "undefined" ? !!options.join : false;
  var swap = typeof options.swap != "undefined" ? !!options.swap : false;
  var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;
  var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
  var defs = predefined ? indent2 + '<defs><path id="qrmodule" d="M0 0 h' + ysize + " v" + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL : "";
  var bgrect = indent2 + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL;
  var modrect = "";
  var pathdata = "";
  for (var y3 = 0; y3 < length2; y3++) {
    for (var x2 = 0; x2 < length2; x2++) {
      var module2 = modules[x2][y3];
      if (module2) {
        var px = x2 * xsize + options.padding * xsize;
        var py = y3 * ysize + options.padding * ysize;
        if (swap) {
          var t2 = px;
          px = py;
          py = t2;
        }
        if (join2) {
          var w3 = xsize + px;
          var h5 = ysize + py;
          px = Number.isInteger(px) ? Number(px) : px.toFixed(2);
          py = Number.isInteger(py) ? Number(py) : py.toFixed(2);
          w3 = Number.isInteger(w3) ? Number(w3) : w3.toFixed(2);
          h5 = Number.isInteger(h5) ? Number(h5) : h5.toFixed(2);
          pathdata += "M" + px + "," + py + " V" + h5 + " H" + w3 + " V" + py + " H" + px + " Z ";
        } else if (predefined) {
          modrect += indent2 + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL;
        } else {
          modrect += indent2 + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL;
        }
      }
    }
  }
  if (join2) {
    modrect = indent2 + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
  }
  let imgSvg = "";
  if (this.options.image !== void 0 && this.options.image.svg) {
    const imgWidth = width * this.options.image.width / 100;
    const imgHeight = height * this.options.image.height / 100;
    const imgX = width / 2 - imgWidth / 2;
    const imgY = height / 2 - imgHeight / 2;
    imgSvg += `<svg x="${imgX}" y="${imgY}" width="${imgWidth}" height="${imgHeight}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`;
    imgSvg += this.options.image.svg + EOL;
    imgSvg += "</svg>";
  }
  var svg2 = "";
  switch (opt.container) {
    case "svg":
      if (xmlDeclaration) {
        svg2 += '<?xml version="1.0" standalone="yes"?>' + EOL;
      }
      svg2 += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL;
      svg2 += defs + bgrect + modrect;
      svg2 += imgSvg;
      svg2 += "</svg>";
      break;
    case "svg-viewbox":
      if (xmlDeclaration) {
        svg2 += '<?xml version="1.0" standalone="yes"?>' + EOL;
      }
      svg2 += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + " " + height + '">' + EOL;
      svg2 += defs + bgrect + modrect;
      svg2 += imgSvg;
      svg2 += "</svg>";
      break;
    case "g":
      svg2 += '<g width="' + width + '" height="' + height + '">' + EOL;
      svg2 += defs + bgrect + modrect;
      svg2 += imgSvg;
      svg2 += "</g>";
      break;
    default:
      svg2 += (defs + bgrect + modrect + imgSvg).replace(/^\s+/, "");
      break;
  }
  return svg2;
};
var qrcodeSvg = QRCode$2;
const index$d = /* @__PURE__ */ getDefaultExportFromCjs(qrcodeSvg);
const qrcodeSvg$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$d
}, [qrcodeSvg]);
const require$$2$6 = /* @__PURE__ */ getAugmentedNamespace(qrcodeSvg$1);
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(QRCode$3, "__esModule", { value: true });
var QRCode_2 = QRCode$3.QRCode = void 0;
const preact_1$8 = require$$1$b;
const hooks_1$3 = require$$2$7;
const qrcode_svg_1 = __importDefault$6(require$$2$6);
const QRCode = (props) => {
  const [svg2, setSvg] = (0, hooks_1$3.useState)("");
  (0, hooks_1$3.useEffect)(() => {
    var _a2, _b;
    const qrcode2 = new qrcode_svg_1.default({
      content: props.content,
      background: props.bgColor || "#ffffff",
      color: props.fgColor || "#000000",
      container: "svg",
      ecl: "M",
      width: (_a2 = props.width) !== null && _a2 !== void 0 ? _a2 : 256,
      height: (_b = props.height) !== null && _b !== void 0 ? _b : 256,
      padding: 0,
      image: props.image
    });
    const base642 = buffer$4.Buffer.from(qrcode2.svg(), "utf8").toString("base64");
    setSvg(`data:image/svg+xml;base64,${base642}`);
  });
  return svg2 ? (0, preact_1$8.h)("img", { src: svg2, alt: "QR Code" }) : null;
};
QRCode_2 = QRCode$3.QRCode = QRCode;
const QRCode$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get QRCode() {
    return QRCode_2;
  },
  default: QRCode$3
}, [QRCode$3]);
const require$$12$1 = /* @__PURE__ */ getAugmentedNamespace(QRCode$1);
var Spinner$4 = {};
var SpinnerCss$1 = {};
Object.defineProperty(SpinnerCss$1, "__esModule", { value: true });
var _default$6 = SpinnerCss$1.default = `.-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}`;
const SpinnerCss = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$6
}, [SpinnerCss$1]);
const require$$1$9 = /* @__PURE__ */ getAugmentedNamespace(SpinnerCss);
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(Spinner$4, "__esModule", { value: true });
var Spinner_2 = Spinner$4.Spinner = void 0;
const preact_1$7 = require$$1$b;
const Spinner_css_1 = __importDefault$5(require$$1$9);
const Spinner$2 = (props) => {
  var _a2;
  const size2 = (_a2 = props.size) !== null && _a2 !== void 0 ? _a2 : 64;
  const color = props.color || "#000";
  return (0, preact_1$7.h)(
    "div",
    { class: "-cbwsdk-spinner" },
    (0, preact_1$7.h)("style", null, Spinner_css_1.default),
    (0, preact_1$7.h)(
      "svg",
      { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: size2, height: size2 } },
      (0, preact_1$7.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: color } })
    )
  );
};
Spinner_2 = Spinner$4.Spinner = Spinner$2;
const Spinner$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get Spinner() {
    return Spinner_2;
  },
  default: Spinner$4
}, [Spinner$4]);
const require$$13$1 = /* @__PURE__ */ getAugmentedNamespace(Spinner$3);
var ConnectContentCss$1 = {};
Object.defineProperty(ConnectContentCss$1, "__esModule", { value: true });
var _default$5 = ConnectContentCss$1.default = `.-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-item.light.selected{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark.selected{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item.selected{border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}`;
const ConnectContentCss = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$5
}, [ConnectContentCss$1]);
const require$$14 = /* @__PURE__ */ getAugmentedNamespace(ConnectContentCss);
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(ConnectContent$2, "__esModule", { value: true });
var CoinbaseAppSteps_1 = ConnectContent$2.CoinbaseAppSteps = CoinbaseWalletSteps_1 = ConnectContent$2.CoinbaseWalletSteps = ConnectItem_1 = ConnectContent$2.ConnectItem = ConnectContent_2 = ConnectContent$2.ConnectContent = void 0;
const clsx_1$2 = __importDefault$4(require$$0$q);
const preact_1$6 = require$$1$b;
const hooks_1$2 = require$$2$7;
const util_1$4 = require$$7$4;
const version_1$1 = require$$8$4;
const CloseIcon_1 = require$$5$5;
const coinbase_round_svg_1 = __importDefault$4(require$$6$5);
const coinbase_wallet_round_svg_1 = __importDefault$4(require$$7$1);
const QRCodeIcon_1 = require$$8$1;
const QRLogoCoinbase_1 = __importDefault$4(require$$9);
const QRLogoWallet_1 = __importDefault$4(require$$10);
const StatusDotIcon_1 = require$$11;
const QRCode_1 = require$$12$1;
const Spinner_1 = require$$13$1;
const ConnectContent_css_1 = __importDefault$4(require$$14);
const wallets = {
  "coinbase-wallet-app": {
    title: "Coinbase Wallet app",
    description: "Connect with your self-custody wallet",
    icon: coinbase_wallet_round_svg_1.default,
    steps: CoinbaseWalletSteps
  },
  "coinbase-app": {
    title: "Coinbase app",
    description: "Connect with your Coinbase account",
    icon: coinbase_round_svg_1.default,
    steps: CoinbaseAppSteps
  }
};
const makeQrCodeImage = (app) => {
  switch (app) {
    case "coinbase-app":
      return QRLogoCoinbase_1.default;
    case "coinbase-wallet-app":
    default:
      return QRLogoWallet_1.default;
  }
};
const makeIconColor = (theme) => {
  return theme === "light" ? "#FFFFFF" : "#0A0B0D";
};
function ConnectContent(props) {
  const { theme } = props;
  const [selected, setSelected] = (0, hooks_1$2.useState)("coinbase-wallet-app");
  const handleSelect = (0, hooks_1$2.useCallback)((id2) => {
    setSelected(id2);
  }, []);
  const qrUrl = (0, util_1$4.createQrUrl)(props.sessionId, props.sessionSecret, props.linkAPIUrl, props.isParentConnection, props.version, props.chainId);
  const wallet = wallets[selected];
  if (!selected) {
    return null;
  }
  const WalletSteps = wallet.steps;
  const coinbaseApp = selected === "coinbase-app";
  return (0, preact_1$6.h)(
    "div",
    { "data-testid": "connect-content", class: (0, clsx_1$2.default)("-cbwsdk-connect-content", theme) },
    (0, preact_1$6.h)("style", null, ConnectContent_css_1.default),
    (0, preact_1$6.h)(
      "div",
      { class: "-cbwsdk-connect-content-header" },
      (0, preact_1$6.h)("h2", { class: (0, clsx_1$2.default)("-cbwsdk-connect-content-heading", theme) }, "Scan to connect with one of our mobile apps"),
      props.onCancel && (0, preact_1$6.h)(
        "button",
        { type: "button", class: "-cbwsdk-cancel-button", onClick: props.onCancel },
        (0, preact_1$6.h)(CloseIcon_1.CloseIcon, { fill: theme === "light" ? "#0A0B0D" : "#FFFFFF" })
      )
    ),
    (0, preact_1$6.h)(
      "div",
      { class: "-cbwsdk-connect-content-layout" },
      (0, preact_1$6.h)(
        "div",
        { class: "-cbwsdk-connect-content-column-left" },
        (0, preact_1$6.h)("div", null, Object.entries(wallets).map(([key2, value]) => {
          return (0, preact_1$6.h)(ConnectItem, { key: key2, title: value.title, description: value.description, icon: value.icon, selected: selected === key2, onClick: () => handleSelect(key2), theme });
        })),
        coinbaseApp && (0, preact_1$6.h)(
          "div",
          { class: (0, clsx_1$2.default)("-cbwsdk-connect-content-update-app", theme) },
          "Don’t see a ",
          (0, preact_1$6.h)("strong", null, "Scan"),
          " option? Update your Coinbase app to the latest version and try again."
        )
      ),
      (0, preact_1$6.h)(
        "div",
        { class: "-cbwsdk-connect-content-column-right" },
        (0, preact_1$6.h)(
          "div",
          { class: "-cbwsdk-connect-content-qr-wrapper" },
          (0, preact_1$6.h)(QRCode_1.QRCode, { content: qrUrl, width: 200, height: 200, fgColor: "#000", bgColor: "transparent", image: {
            svg: makeQrCodeImage(selected),
            width: 25,
            height: 25
          } }),
          (0, preact_1$6.h)("input", { type: "hidden", name: "cbw-cbwsdk-version", value: version_1$1.LIB_VERSION }),
          (0, preact_1$6.h)("input", { type: "hidden", value: qrUrl })
        ),
        (0, preact_1$6.h)(WalletSteps, { theme }),
        !props.isConnected && (0, preact_1$6.h)(
          "div",
          { "data-testid": "connecting-spinner", class: (0, clsx_1$2.default)("-cbwsdk-connect-content-qr-connecting", theme) },
          (0, preact_1$6.h)(Spinner_1.Spinner, { size: 36, color: theme === "dark" ? "#FFF" : "#000" }),
          (0, preact_1$6.h)("p", null, "Connecting...")
        )
      )
    )
  );
}
var ConnectContent_2 = ConnectContent$2.ConnectContent = ConnectContent;
function ConnectItem({ title, description, icon, selected, theme, onClick }) {
  return (0, preact_1$6.h)(
    "div",
    { onClick, class: (0, clsx_1$2.default)("-cbwsdk-connect-item", theme, { selected }) },
    (0, preact_1$6.h)(
      "div",
      null,
      (0, preact_1$6.h)("img", { src: icon, alt: title })
    ),
    (0, preact_1$6.h)(
      "div",
      { class: "-cbwsdk-connect-item-copy-wrapper" },
      (0, preact_1$6.h)("h3", { class: "-cbwsdk-connect-item-title" }, title),
      (0, preact_1$6.h)("p", { class: "-cbwsdk-connect-item-description" }, description)
    )
  );
}
var ConnectItem_1 = ConnectContent$2.ConnectItem = ConnectItem;
function CoinbaseWalletSteps({ theme }) {
  return (0, preact_1$6.h)(
    "ol",
    { class: "-cbwsdk-wallet-steps" },
    (0, preact_1$6.h)(
      "li",
      { class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-item", theme) },
      (0, preact_1$6.h)("div", { class: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase Wallet app")
    ),
    (0, preact_1$6.h)(
      "li",
      { class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-item", theme) },
      (0, preact_1$6.h)(
        "div",
        { class: "-cbwsdk-wallet-steps-item-wrapper" },
        (0, preact_1$6.h)(
          "span",
          null,
          "Tap ",
          (0, preact_1$6.h)("strong", null, "Scan"),
          " "
        ),
        (0, preact_1$6.h)(
          "span",
          { class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme) },
          (0, preact_1$6.h)(QRCodeIcon_1.QRCodeIcon, { fill: makeIconColor(theme) })
        )
      )
    )
  );
}
var CoinbaseWalletSteps_1 = ConnectContent$2.CoinbaseWalletSteps = CoinbaseWalletSteps;
function CoinbaseAppSteps({ theme }) {
  return (0, preact_1$6.h)(
    "ol",
    { class: "-cbwsdk-wallet-steps" },
    (0, preact_1$6.h)(
      "li",
      { class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-item", theme) },
      (0, preact_1$6.h)("div", { class: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase app")
    ),
    (0, preact_1$6.h)(
      "li",
      { class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-item", theme) },
      (0, preact_1$6.h)(
        "div",
        { class: "-cbwsdk-wallet-steps-item-wrapper" },
        (0, preact_1$6.h)(
          "span",
          null,
          "Tap ",
          (0, preact_1$6.h)("strong", null, "More")
        ),
        (0, preact_1$6.h)(
          "span",
          { class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme) },
          (0, preact_1$6.h)(StatusDotIcon_1.StatusDotIcon, { fill: makeIconColor(theme) })
        ),
        (0, preact_1$6.h)(
          "span",
          { class: "-cbwsdk-wallet-steps-pad-left" },
          "then ",
          (0, preact_1$6.h)("strong", null, "Scan")
        ),
        (0, preact_1$6.h)(
          "span",
          { class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme) },
          (0, preact_1$6.h)(QRCodeIcon_1.QRCodeIcon, { fill: makeIconColor(theme) })
        )
      )
    )
  );
}
CoinbaseAppSteps_1 = ConnectContent$2.CoinbaseAppSteps = CoinbaseAppSteps;
const ConnectContent$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get CoinbaseAppSteps() {
    return CoinbaseAppSteps_1;
  },
  get CoinbaseWalletSteps() {
    return CoinbaseWalletSteps_1;
  },
  get ConnectContent() {
    return ConnectContent_2;
  },
  get ConnectItem() {
    return ConnectItem_1;
  },
  default: ConnectContent$2
}, [ConnectContent$2]);
const require$$3$4 = /* @__PURE__ */ getAugmentedNamespace(ConnectContent$1);
var TryExtensionContent$2 = {};
var ArrowLeftIcon$2 = {};
Object.defineProperty(ArrowLeftIcon$2, "__esModule", { value: true });
var ArrowLeftIcon_2 = ArrowLeftIcon$2.ArrowLeftIcon = void 0;
const preact_1$5 = require$$1$b;
function ArrowLeftIcon(props) {
  return (0, preact_1$5.h)(
    "svg",
    Object.assign({ width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, props),
    (0, preact_1$5.h)("path", { d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z" })
  );
}
ArrowLeftIcon_2 = ArrowLeftIcon$2.ArrowLeftIcon = ArrowLeftIcon;
const ArrowLeftIcon$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get ArrowLeftIcon() {
    return ArrowLeftIcon_2;
  },
  default: ArrowLeftIcon$2
}, [ArrowLeftIcon$2]);
const require$$3$3 = /* @__PURE__ */ getAugmentedNamespace(ArrowLeftIcon$1);
var LaptopIcon$2 = {};
Object.defineProperty(LaptopIcon$2, "__esModule", { value: true });
var LaptopIcon_2 = LaptopIcon$2.LaptopIcon = void 0;
const preact_1$4 = require$$1$b;
function LaptopIcon(props) {
  return (0, preact_1$4.h)(
    "svg",
    Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, props),
    (0, preact_1$4.h)("path", { d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z" }),
    (0, preact_1$4.h)("path", { d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z" })
  );
}
LaptopIcon_2 = LaptopIcon$2.LaptopIcon = LaptopIcon;
const LaptopIcon$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get LaptopIcon() {
    return LaptopIcon_2;
  },
  default: LaptopIcon$2
}, [LaptopIcon$2]);
const require$$4$5 = /* @__PURE__ */ getAugmentedNamespace(LaptopIcon$1);
var SafeIcon$2 = {};
Object.defineProperty(SafeIcon$2, "__esModule", { value: true });
var SafeIcon_2 = SafeIcon$2.SafeIcon = void 0;
const preact_1$3 = require$$1$b;
function SafeIcon(props) {
  return (0, preact_1$3.h)(
    "svg",
    Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, props),
    (0, preact_1$3.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z" })
  );
}
SafeIcon_2 = SafeIcon$2.SafeIcon = SafeIcon;
const SafeIcon$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get SafeIcon() {
    return SafeIcon_2;
  },
  default: SafeIcon$2
}, [SafeIcon$2]);
const require$$5$4 = /* @__PURE__ */ getAugmentedNamespace(SafeIcon$1);
var TryExtensionContentCss$1 = {};
Object.defineProperty(TryExtensionContentCss$1, "__esModule", { value: true });
var _default$4 = TryExtensionContentCss$1.default = `.-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}`;
const TryExtensionContentCss = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$4
}, [TryExtensionContentCss$1]);
const require$$6$4 = /* @__PURE__ */ getAugmentedNamespace(TryExtensionContentCss);
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(TryExtensionContent$2, "__esModule", { value: true });
var TryExtensionContent_2 = TryExtensionContent$2.TryExtensionContent = void 0;
const clsx_1$1 = __importDefault$3(require$$0$q);
const preact_1$2 = require$$1$b;
const hooks_1$1 = require$$2$7;
const ArrowLeftIcon_1 = require$$3$3;
const LaptopIcon_1 = require$$4$5;
const SafeIcon_1 = require$$5$4;
const TryExtensionContent_css_1 = __importDefault$3(require$$6$4);
function TryExtensionContent({ theme }) {
  const [clicked, setClicked] = (0, hooks_1$1.useState)(false);
  const handleInstallClick = (0, hooks_1$1.useCallback)(() => {
    window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
  }, []);
  const handleClick = (0, hooks_1$1.useCallback)(() => {
    if (clicked) {
      window.location.reload();
    } else {
      handleInstallClick();
      setClicked(true);
    }
  }, [handleInstallClick, clicked]);
  return (0, preact_1$2.h)(
    "div",
    { class: (0, clsx_1$1.default)("-cbwsdk-try-extension", theme) },
    (0, preact_1$2.h)("style", null, TryExtensionContent_css_1.default),
    (0, preact_1$2.h)(
      "div",
      { class: "-cbwsdk-try-extension-column-half" },
      (0, preact_1$2.h)("h3", { class: (0, clsx_1$1.default)("-cbwsdk-try-extension-heading", theme) }, "Or try the Coinbase Wallet browser extension"),
      (0, preact_1$2.h)(
        "div",
        { class: "-cbwsdk-try-extension-cta-wrapper" },
        (0, preact_1$2.h)("button", { class: (0, clsx_1$1.default)("-cbwsdk-try-extension-cta", theme), onClick: handleClick }, clicked ? "Refresh" : "Install"),
        (0, preact_1$2.h)("div", null, !clicked && (0, preact_1$2.h)(ArrowLeftIcon_1.ArrowLeftIcon, { class: "-cbwsdk-try-extension-cta-icon", fill: theme === "light" ? "#0052FF" : "#588AF5" }))
      )
    ),
    (0, preact_1$2.h)(
      "div",
      { class: "-cbwsdk-try-extension-column-half" },
      (0, preact_1$2.h)(
        "ul",
        { class: "-cbwsdk-try-extension-list" },
        (0, preact_1$2.h)(
          "li",
          { class: "-cbwsdk-try-extension-list-item" },
          (0, preact_1$2.h)(
            "div",
            { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
            (0, preact_1$2.h)(
              "span",
              { class: (0, clsx_1$1.default)("-cbwsdk-try-extension-list-item-icon", theme) },
              (0, preact_1$2.h)(LaptopIcon_1.LaptopIcon, { fill: theme === "light" ? "#0A0B0D" : "#FFFFFF" })
            )
          ),
          (0, preact_1$2.h)("div", { class: (0, clsx_1$1.default)("-cbwsdk-try-extension-list-item-copy", theme) }, "Connect with dapps with just one click on your desktop browser")
        ),
        (0, preact_1$2.h)(
          "li",
          { class: "-cbwsdk-try-extension-list-item" },
          (0, preact_1$2.h)(
            "div",
            { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
            (0, preact_1$2.h)(
              "span",
              { class: (0, clsx_1$1.default)("-cbwsdk-try-extension-list-item-icon", theme) },
              (0, preact_1$2.h)(SafeIcon_1.SafeIcon, { fill: theme === "light" ? "#0A0B0D" : "#FFFFFF" })
            )
          ),
          (0, preact_1$2.h)("div", { class: (0, clsx_1$1.default)("-cbwsdk-try-extension-list-item-copy", theme) }, "Add an additional layer of security by using a supported Ledger hardware wallet")
        )
      )
    )
  );
}
TryExtensionContent_2 = TryExtensionContent$2.TryExtensionContent = TryExtensionContent;
const TryExtensionContent$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get TryExtensionContent() {
    return TryExtensionContent_2;
  },
  default: TryExtensionContent$2
}, [TryExtensionContent$2]);
const require$$4$4 = /* @__PURE__ */ getAugmentedNamespace(TryExtensionContent$1);
var ConnectDialogCss$1 = {};
Object.defineProperty(ConnectDialogCss$1, "__esModule", { value: true });
var _default$3 = ConnectDialogCss$1.default = `.-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}`;
const ConnectDialogCss = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$3
}, [ConnectDialogCss$1]);
const require$$5$3 = /* @__PURE__ */ getAugmentedNamespace(ConnectDialogCss);
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(ConnectDialog$2, "__esModule", { value: true });
var ConnectDialog_2 = ConnectDialog$2.ConnectDialog = void 0;
const clsx_1 = __importDefault$2(require$$0$q);
const preact_1$1 = require$$1$b;
const hooks_1 = require$$2$7;
const ConnectContent_1 = require$$3$4;
const TryExtensionContent_1 = require$$4$4;
const ConnectDialog_css_1 = __importDefault$2(require$$5$3);
const ConnectDialog = (props) => {
  const { isOpen, darkMode } = props;
  const [containerHidden, setContainerHidden] = (0, hooks_1.useState)(!isOpen);
  const [dialogHidden, setDialogHidden] = (0, hooks_1.useState)(!isOpen);
  (0, hooks_1.useEffect)(() => {
    const timers = [
      window.setTimeout(() => {
        setDialogHidden(!isOpen);
      }, 10)
    ];
    if (isOpen) {
      setContainerHidden(false);
    } else {
      timers.push(window.setTimeout(() => {
        setContainerHidden(true);
      }, 360));
    }
    return () => {
      timers.forEach(window.clearTimeout);
    };
  }, [props.isOpen]);
  const theme = darkMode ? "dark" : "light";
  return (0, preact_1$1.h)(
    "div",
    { class: (0, clsx_1.default)("-cbwsdk-connect-dialog-container", containerHidden && "-cbwsdk-connect-dialog-container-hidden") },
    (0, preact_1$1.h)("style", null, ConnectDialog_css_1.default),
    (0, preact_1$1.h)("div", { class: (0, clsx_1.default)("-cbwsdk-connect-dialog-backdrop", theme, dialogHidden && "-cbwsdk-connect-dialog-backdrop-hidden") }),
    (0, preact_1$1.h)(
      "div",
      { class: "-cbwsdk-connect-dialog" },
      (0, preact_1$1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-connect-dialog-box", dialogHidden && "-cbwsdk-connect-dialog-box-hidden") },
        !props.connectDisabled ? (0, preact_1$1.h)(ConnectContent_1.ConnectContent, { theme, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, linkAPIUrl: props.linkAPIUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection, chainId: props.chainId, onCancel: props.onCancel }) : null,
        (0, preact_1$1.h)(TryExtensionContent_1.TryExtensionContent, { theme })
      )
    )
  );
};
ConnectDialog_2 = ConnectDialog$2.ConnectDialog = ConnectDialog;
const ConnectDialog$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get ConnectDialog() {
    return ConnectDialog_2;
  },
  default: ConnectDialog$2
}, [ConnectDialog$2]);
const require$$2$5 = /* @__PURE__ */ getAugmentedNamespace(ConnectDialog$1);
Object.defineProperty(LinkFlow$2, "__esModule", { value: true });
var LinkFlow_2 = LinkFlow$2.LinkFlow = void 0;
const preact_1 = require$$1$b;
const rxjs_1$2 = require$$1$a;
const ConnectDialog_1 = require$$2$5;
class LinkFlow {
  constructor(options) {
    this.extensionUI$ = new rxjs_1$2.BehaviorSubject({});
    this.subscriptions = new rxjs_1$2.Subscription();
    this.isConnected = false;
    this.chainId = 1;
    this.isOpen = false;
    this.onCancel = null;
    this.root = null;
    this.connectDisabled = false;
    this.darkMode = options.darkMode;
    this.version = options.version;
    this.sessionId = options.sessionId;
    this.sessionSecret = options.sessionSecret;
    this.linkAPIUrl = options.linkAPIUrl;
    this.isParentConnection = options.isParentConnection;
    this.connected$ = options.connected$;
    this.chainId$ = options.chainId$;
  }
  attach(el2) {
    this.root = document.createElement("div");
    this.root.className = "-cbwsdk-link-flow-root";
    el2.appendChild(this.root);
    this.render();
    this.subscriptions.add(this.connected$.subscribe((v4) => {
      if (this.isConnected !== v4) {
        this.isConnected = v4;
        this.render();
      }
    }));
    this.subscriptions.add(this.chainId$.subscribe((chainId) => {
      if (this.chainId !== chainId) {
        this.chainId = chainId;
        this.render();
      }
    }));
  }
  detach() {
    var _a2;
    if (!this.root) {
      return;
    }
    this.subscriptions.unsubscribe();
    (0, preact_1.render)(null, this.root);
    (_a2 = this.root.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.root);
  }
  setConnectDisabled(connectDisabled) {
    this.connectDisabled = connectDisabled;
  }
  open(options) {
    this.isOpen = true;
    this.onCancel = options.onCancel;
    this.render();
  }
  close() {
    this.isOpen = false;
    this.onCancel = null;
    this.render();
  }
  render() {
    if (!this.root) {
      return;
    }
    const subscription = this.extensionUI$.subscribe(() => {
      if (!this.root) {
        return;
      }
      (0, preact_1.render)((0, preact_1.h)(ConnectDialog_1.ConnectDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, linkAPIUrl: this.linkAPIUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, chainId: this.chainId, onCancel: this.onCancel, connectDisabled: this.connectDisabled }), this.root);
    });
    this.subscriptions.add(subscription);
  }
}
LinkFlow_2 = LinkFlow$2.LinkFlow = LinkFlow;
const LinkFlow$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get LinkFlow() {
    return LinkFlow_2;
  },
  default: LinkFlow$2
}, [LinkFlow$2]);
const require$$0$p = /* @__PURE__ */ getAugmentedNamespace(LinkFlow$1);
var Snackbar$2 = {};
var SnackbarCss$1 = {};
Object.defineProperty(SnackbarCss$1, "__esModule", { value: true });
var _default$2 = SnackbarCss$1.default = `.-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`;
const SnackbarCss = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$2
}, [SnackbarCss$1]);
const require$$3$2 = /* @__PURE__ */ getAugmentedNamespace(SnackbarCss);
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.SnackbarInstance = exports2.SnackbarContainer = exports2.Snackbar = void 0;
  const clsx_12 = __importDefault2(require$$0$q);
  const preact_12 = require$$1$b;
  const hooks_12 = require$$2$7;
  const Snackbar_css_1 = __importDefault2(require$$3$2);
  const gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
  function makeSnackbarIcon(appSrc) {
    switch (appSrc) {
      case "coinbase-app":
        return `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE0LjY3NCAxOC44NThjLTIuMDQ1IDAtMy42NDgtMS43MjItMy42NDgtMy44NDVzMS42NTktMy44NDUgMy42NDgtMy44NDVjMS44MjQgMCAzLjMxNyAxLjM3NyAzLjU5MyAzLjIxNGgzLjcwM2MtLjMzMS0zLjk2LTMuNDgyLTcuMDU5LTcuMjk2LTcuMDU5LTQuMDM0IDAtNy4zNSAzLjQ0My03LjM1IDcuNjkgMCA0LjI0NiAzLjI2IDcuNjkgNy4zNSA3LjY5IDMuODcgMCA2Ljk2NS0zLjEgNy4yOTYtNy4wNTloLTMuNzAzYy0uMjc2IDEuODM2LTEuNzY5IDMuMjE0LTMuNTkzIDMuMjE0WiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0wIDEwLjY3OGMwLTMuNzExIDAtNS41OTYuNzQyLTcuMDIzQTYuNTMyIDYuNTMyIDAgMCAxIDMuNjU1Ljc0MkM1LjA4MiAwIDYuOTY3IDAgMTAuNjc4IDBoNy45MzhjMy43MTEgMCA1LjU5NiAwIDcuMDIzLjc0MmE2LjUzMSA2LjUzMSAwIDAgMSAyLjkxMyAyLjkxM2MuNzQyIDEuNDI3Ljc0MiAzLjMxMi43NDIgNy4wMjN2Ny45MzhjMCAzLjcxMSAwIDUuNTk2LS43NDIgNy4wMjNhNi41MzEgNi41MzEgMCAwIDEtMi45MTMgMi45MTNjLTEuNDI3Ljc0Mi0zLjMxMi43NDItNy4wMjMuNzQyaC03LjkzOGMtMy43MTEgMC01LjU5NiAwLTcuMDIzLS43NDJhNi41MzEgNi41MzEgMCAwIDEtMi45MTMtMi45MTNDMCAyNC4yMTIgMCAyMi4zODQgMCAxOC42MTZ2LTcuOTM4WiIgZmlsbD0iIzAwNTJGRiIvPjxwYXRoIGQ9Ik0xNC42ODQgMTkuNzczYy0yLjcyNyAwLTQuODY0LTIuMjk1LTQuODY0LTUuMTI2IDAtMi44MzEgMi4yMS01LjEyNyA0Ljg2NC01LjEyNyAyLjQzMiAwIDQuNDIyIDEuODM3IDQuNzkgNC4yODVoNC45MzhjLS40NDItNS4yOC00LjY0My05LjQxMS05LjcyOC05LjQxMS01LjM4IDAtOS44MDIgNC41OS05LjgwMiAxMC4yNTMgMCA1LjY2MiA0LjM0OCAxMC4yNTMgOS44MDIgMTAuMjUzIDUuMTU5IDAgOS4yODYtNC4xMzIgOS43MjgtOS40MTFoLTQuOTM4Yy0uMzY4IDIuNDQ4LTIuMzU4IDQuMjg0LTQuNzkgNC4yODRaIiBmaWxsPSIjZmZmIi8+PC9zdmc+`;
      case "coinbase-wallet-app":
      default:
        return `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
    }
  }
  class Snackbar2 {
    constructor(options) {
      this.items = /* @__PURE__ */ new Map();
      this.nextItemKey = 0;
      this.root = null;
      this.darkMode = options.darkMode;
    }
    attach(el2) {
      this.root = document.createElement("div");
      this.root.className = "-cbwsdk-snackbar-root";
      el2.appendChild(this.root);
      this.render();
    }
    presentItem(itemProps) {
      const key2 = this.nextItemKey++;
      this.items.set(key2, itemProps);
      this.render();
      return () => {
        this.items.delete(key2);
        this.render();
      };
    }
    clear() {
      this.items.clear();
      this.render();
    }
    render() {
      if (!this.root) {
        return;
      }
      (0, preact_12.render)((0, preact_12.h)(
        "div",
        null,
        (0, preact_12.h)(exports2.SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key2, itemProps]) => (0, preact_12.h)(exports2.SnackbarInstance, Object.assign({}, itemProps, { key: key2 }))))
      ), this.root);
    }
  }
  exports2.Snackbar = Snackbar2;
  const SnackbarContainer = (props) => (0, preact_12.h)(
    "div",
    { class: (0, clsx_12.default)("-cbwsdk-snackbar-container") },
    (0, preact_12.h)("style", null, Snackbar_css_1.default),
    (0, preact_12.h)("div", { class: "-cbwsdk-snackbar" }, props.children)
  );
  exports2.SnackbarContainer = SnackbarContainer;
  const SnackbarInstance = ({ autoExpand, message, menuItems, appSrc }) => {
    const [hidden2, setHidden] = (0, hooks_12.useState)(true);
    const [expanded, setExpanded] = (0, hooks_12.useState)(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
    (0, hooks_12.useEffect)(() => {
      const timers = [
        window.setTimeout(() => {
          setHidden(false);
        }, 1),
        window.setTimeout(() => {
          setExpanded(true);
        }, 1e4)
      ];
      return () => {
        timers.forEach(window.clearTimeout);
      };
    });
    const toggleExpanded = () => {
      setExpanded(!expanded);
    };
    return (0, preact_12.h)(
      "div",
      { class: (0, clsx_12.default)("-cbwsdk-snackbar-instance", hidden2 && "-cbwsdk-snackbar-instance-hidden", expanded && "-cbwsdk-snackbar-instance-expanded") },
      (0, preact_12.h)(
        "div",
        { class: "-cbwsdk-snackbar-instance-header", onClick: toggleExpanded },
        (0, preact_12.h)("img", { src: makeSnackbarIcon(appSrc), class: "-cbwsdk-snackbar-instance-header-cblogo" }),
        (0, preact_12.h)("div", { class: "-cbwsdk-snackbar-instance-header-message" }, message),
        (0, preact_12.h)(
          "div",
          { class: "-gear-container" },
          !expanded && (0, preact_12.h)(
            "svg",
            { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            (0, preact_12.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
          ),
          (0, preact_12.h)("img", { src: gearIcon, class: "-gear-icon", title: "Expand" })
        )
      ),
      menuItems && menuItems.length > 0 && (0, preact_12.h)("div", { class: "-cbwsdk-snackbar-instance-menu" }, menuItems.map((action, i3) => (0, preact_12.h)(
        "div",
        { class: (0, clsx_12.default)("-cbwsdk-snackbar-instance-menu-item", action.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: action.onClick, key: i3 },
        (0, preact_12.h)(
          "svg",
          { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          (0, preact_12.h)("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })
        ),
        (0, preact_12.h)("span", { class: (0, clsx_12.default)("-cbwsdk-snackbar-instance-menu-item-info", action.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, action.info)
      )))
    );
  };
  exports2.SnackbarInstance = SnackbarInstance;
})(Snackbar$2);
const Snackbar = /* @__PURE__ */ getDefaultExportFromCjs(Snackbar$2);
const Snackbar$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: Snackbar
}, [Snackbar$2]);
const require$$1$8 = /* @__PURE__ */ getAugmentedNamespace(Snackbar$1);
var cssReset$1 = {};
var cssResetCss$1 = {};
Object.defineProperty(cssResetCss$1, "__esModule", { value: true });
var _default$1 = cssResetCss$1.default = `@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}`;
const cssResetCss = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$1
}, [cssResetCss$1]);
const require$$0$o = /* @__PURE__ */ getAugmentedNamespace(cssResetCss);
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(cssReset$1, "__esModule", { value: true });
var injectCssReset_1 = cssReset$1.injectCssReset = void 0;
const cssReset_css_1 = __importDefault$1(require$$0$o);
function injectCssReset() {
  const styleEl = document.createElement("style");
  styleEl.type = "text/css";
  styleEl.appendChild(document.createTextNode(cssReset_css_1.default));
  document.documentElement.appendChild(styleEl);
}
injectCssReset_1 = cssReset$1.injectCssReset = injectCssReset;
const cssReset = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: cssReset$1,
  get injectCssReset() {
    return injectCssReset_1;
  }
}, [cssReset$1]);
const require$$2$4 = /* @__PURE__ */ getAugmentedNamespace(cssReset);
Object.defineProperty(WalletSDKUI$2, "__esModule", { value: true });
var WalletSDKUI_2 = WalletSDKUI$2.WalletSDKUI = void 0;
const LinkFlow_1 = require$$0$p;
const Snackbar_1 = require$$1$8;
const cssReset_1 = require$$2$4;
class WalletSDKUI {
  constructor(options) {
    this.standalone = null;
    this.attached = false;
    this.appSrc = null;
    this.snackbar = new Snackbar_1.Snackbar({
      darkMode: options.darkMode
    });
    this.linkFlow = new LinkFlow_1.LinkFlow({
      darkMode: options.darkMode,
      version: options.version,
      sessionId: options.session.id,
      sessionSecret: options.session.secret,
      linkAPIUrl: options.linkAPIUrl,
      connected$: options.connected$,
      chainId$: options.chainId$,
      isParentConnection: false
    });
  }
  attach() {
    if (this.attached) {
      throw new Error("Coinbase Wallet SDK UI is already attached");
    }
    const el2 = document.documentElement;
    const container2 = document.createElement("div");
    container2.className = "-cbwsdk-css-reset";
    el2.appendChild(container2);
    this.linkFlow.attach(container2);
    this.snackbar.attach(container2);
    this.attached = true;
    (0, cssReset_1.injectCssReset)();
  }
  setConnectDisabled(connectDisabled) {
    this.linkFlow.setConnectDisabled(connectDisabled);
  }
  /* istanbul ignore next */
  addEthereumChain(_options) {
  }
  /* istanbul ignore next */
  watchAsset(_options) {
  }
  /* istanbul ignore next */
  switchEthereumChain(_options) {
  }
  requestEthereumAccounts(options) {
    this.linkFlow.open({ onCancel: options.onCancel });
  }
  hideRequestEthereumAccounts() {
    this.linkFlow.close();
  }
  /* istanbul ignore next */
  signEthereumMessage(_3) {
  }
  /* istanbul ignore next */
  signEthereumTransaction(_3) {
  }
  /* istanbul ignore next */
  submitEthereumTransaction(_3) {
  }
  /* istanbul ignore next */
  ethereumAddressFromSignedMessage(_3) {
  }
  showConnecting(options) {
    let snackbarProps;
    if (options.isUnlinkedErrorState) {
      snackbarProps = {
        autoExpand: true,
        message: "Connection lost",
        appSrc: this.appSrc,
        menuItems: [
          {
            isRed: false,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: options.onResetConnection
          }
        ]
      };
    } else {
      snackbarProps = {
        message: "Confirm on phone",
        appSrc: this.appSrc,
        menuItems: [
          {
            isRed: true,
            info: "Cancel transaction",
            svgWidth: "11",
            svgHeight: "11",
            path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
            defaultFillRule: "inherit",
            defaultClipRule: "inherit",
            onClick: options.onCancel
          },
          {
            isRed: false,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: options.onResetConnection
          }
        ]
      };
    }
    return this.snackbar.presentItem(snackbarProps);
  }
  /* istanbul ignore next */
  setAppSrc(appSrc) {
    this.appSrc = appSrc;
  }
  /* istanbul ignore next */
  reloadUI() {
    document.location.reload();
  }
  /* istanbul ignore next */
  inlineAccountsResponse() {
    return false;
  }
  /* istanbul ignore next */
  inlineAddEthereumChain(_chainId) {
    return false;
  }
  /* istanbul ignore next */
  inlineWatchAsset() {
    return false;
  }
  /* istanbul ignore next */
  inlineSwitchEthereumChain() {
    return false;
  }
  /* istanbul ignore next */
  setStandalone(status) {
    this.standalone = status;
  }
  /* istanbul ignore next */
  isStandalone() {
    var _a2;
    return (_a2 = this.standalone) !== null && _a2 !== void 0 ? _a2 : false;
  }
}
WalletSDKUI_2 = WalletSDKUI$2.WalletSDKUI = WalletSDKUI;
const WalletSDKUI$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get WalletSDKUI() {
    return WalletSDKUI_2;
  },
  default: WalletSDKUI$2
}, [WalletSDKUI$2]);
const require$$4$3 = /* @__PURE__ */ getAugmentedNamespace(WalletSDKUI$1);
var WalletSDKRelay$2 = {};
var bindDecorator$1 = {};
Object.defineProperty(bindDecorator$1, "__esModule", { value: true });
var constants;
(function(constants2) {
  constants2.typeOfFunction = "function";
  constants2.boolTrue = true;
})(constants || (constants = {}));
function bind(target, propertyKey, descriptor) {
  if (!descriptor || typeof descriptor.value !== constants.typeOfFunction) {
    throw new TypeError("Only methods can be decorated with @bind. <" + propertyKey + "> is not a method!");
  }
  return {
    configurable: constants.boolTrue,
    get: function() {
      var bound = descriptor.value.bind(this);
      Object.defineProperty(this, propertyKey, {
        value: bound,
        configurable: constants.boolTrue,
        writable: constants.boolTrue
      });
      return bound;
    }
  };
}
var bind_1 = bindDecorator$1.bind = bind;
var _default = bindDecorator$1.default = bind;
const bindDecorator = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  bind: bind_1,
  default: _default
}, [bindDecorator$1]);
const require$$0$n = /* @__PURE__ */ getAugmentedNamespace(bindDecorator);
function audit(durationSelector) {
  return function auditOperatorFunction(source) {
    return source.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function AuditOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  AuditOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
  };
  return AuditOperator2;
}();
var AuditSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(AuditSubscriber2, _super);
  function AuditSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  AuditSubscriber2.prototype._next = function(value) {
    this.value = value;
    this.hasValue = true;
    if (!this.throttled) {
      var duration = void 0;
      try {
        var durationSelector = this.durationSelector;
        duration = durationSelector(value);
      } catch (err) {
        return this.destination.error(err);
      }
      var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
      if (!innerSubscription || innerSubscription.closed) {
        this.clearThrottle();
      } else {
        this.add(this.throttled = innerSubscription);
      }
    }
  };
  AuditSubscriber2.prototype.clearThrottle = function() {
    var _a2 = this, value = _a2.value, hasValue = _a2.hasValue, throttled = _a2.throttled;
    if (throttled) {
      this.remove(throttled);
      this.throttled = void 0;
      throttled.unsubscribe();
    }
    if (hasValue) {
      this.value = void 0;
      this.hasValue = false;
      this.destination.next(value);
    }
  };
  AuditSubscriber2.prototype.notifyNext = function() {
    this.clearThrottle();
  };
  AuditSubscriber2.prototype.notifyComplete = function() {
    this.clearThrottle();
  };
  return AuditSubscriber2;
}(SimpleOuterSubscriber);
function auditTime(duration, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return audit(function() {
    return timer(duration, scheduler2);
  });
}
function buffer$3(closingNotifier) {
  return function bufferOperatorFunction(source) {
    return source.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function BufferOperator2(closingNotifier) {
    this.closingNotifier = closingNotifier;
  }
  BufferOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
  };
  return BufferOperator2;
}();
var BufferSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(BufferSubscriber2, _super);
  function BufferSubscriber2(destination, closingNotifier) {
    var _this = _super.call(this, destination) || this;
    _this.buffer = [];
    _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
    return _this;
  }
  BufferSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  };
  BufferSubscriber2.prototype.notifyNext = function() {
    var buffer2 = this.buffer;
    this.buffer = [];
    this.destination.next(buffer2);
  };
  return BufferSubscriber2;
}(SimpleOuterSubscriber);
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  return function bufferCountOperatorFunction(source) {
    return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function BufferCountOperator2(bufferSize, startBufferEvery) {
    this.bufferSize = bufferSize;
    this.startBufferEvery = startBufferEvery;
    if (!startBufferEvery || bufferSize === startBufferEvery) {
      this.subscriberClass = BufferCountSubscriber;
    } else {
      this.subscriberClass = BufferSkipCountSubscriber;
    }
  }
  BufferCountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
  };
  return BufferCountOperator2;
}();
var BufferCountSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(BufferCountSubscriber2, _super);
  function BufferCountSubscriber2(destination, bufferSize) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.buffer = [];
    return _this;
  }
  BufferCountSubscriber2.prototype._next = function(value) {
    var buffer2 = this.buffer;
    buffer2.push(value);
    if (buffer2.length == this.bufferSize) {
      this.destination.next(buffer2);
      this.buffer = [];
    }
  };
  BufferCountSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2.length > 0) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  return BufferCountSubscriber2;
}(Subscriber);
var BufferSkipCountSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(BufferSkipCountSubscriber2, _super);
  function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.startBufferEvery = startBufferEvery;
    _this.buffers = [];
    _this.count = 0;
    return _this;
  }
  BufferSkipCountSubscriber2.prototype._next = function(value) {
    var _a2 = this, bufferSize = _a2.bufferSize, startBufferEvery = _a2.startBufferEvery, buffers = _a2.buffers, count2 = _a2.count;
    this.count++;
    if (count2 % startBufferEvery === 0) {
      buffers.push([]);
    }
    for (var i3 = buffers.length; i3--; ) {
      var buffer2 = buffers[i3];
      buffer2.push(value);
      if (buffer2.length === bufferSize) {
        buffers.splice(i3, 1);
        this.destination.next(buffer2);
      }
    }
  };
  BufferSkipCountSubscriber2.prototype._complete = function() {
    var _a2 = this, buffers = _a2.buffers, destination = _a2.destination;
    while (buffers.length > 0) {
      var buffer2 = buffers.shift();
      if (buffer2.length > 0) {
        destination.next(buffer2);
      }
    }
    _super.prototype._complete.call(this);
  };
  return BufferSkipCountSubscriber2;
}(Subscriber);
function bufferTime(bufferTimeSpan) {
  var length2 = arguments.length;
  var scheduler2 = async;
  if (isScheduler(arguments[arguments.length - 1])) {
    scheduler2 = arguments[arguments.length - 1];
    length2--;
  }
  var bufferCreationInterval = null;
  if (length2 >= 2) {
    bufferCreationInterval = arguments[1];
  }
  var maxBufferSize = Number.POSITIVE_INFINITY;
  if (length2 >= 3) {
    maxBufferSize = arguments[2];
  }
  return function bufferTimeOperatorFunction(source) {
    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler2));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler2) {
    this.bufferTimeSpan = bufferTimeSpan;
    this.bufferCreationInterval = bufferCreationInterval;
    this.maxBufferSize = maxBufferSize;
    this.scheduler = scheduler2;
  }
  BufferTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  };
  return BufferTimeOperator2;
}();
var Context = /* @__PURE__ */ function() {
  function Context2() {
    this.buffer = [];
  }
  return Context2;
}();
var BufferTimeSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(BufferTimeSubscriber2, _super);
  function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.bufferTimeSpan = bufferTimeSpan;
    _this.bufferCreationInterval = bufferCreationInterval;
    _this.maxBufferSize = maxBufferSize;
    _this.scheduler = scheduler2;
    _this.contexts = [];
    var context = _this.openContext();
    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
    if (_this.timespanOnly) {
      var timeSpanOnlyState = { subscriber: _this, context, bufferTimeSpan };
      _this.add(context.closeAction = scheduler2.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    } else {
      var closeState = { subscriber: _this, context };
      var creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler: scheduler2 };
      _this.add(context.closeAction = scheduler2.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
      _this.add(scheduler2.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
    }
    return _this;
  }
  BufferTimeSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    var len2 = contexts.length;
    var filledBufferContext;
    for (var i3 = 0; i3 < len2; i3++) {
      var context_1 = contexts[i3];
      var buffer2 = context_1.buffer;
      buffer2.push(value);
      if (buffer2.length == this.maxBufferSize) {
        filledBufferContext = context_1;
      }
    }
    if (filledBufferContext) {
      this.onBufferFull(filledBufferContext);
    }
  };
  BufferTimeSubscriber2.prototype._error = function(err) {
    this.contexts.length = 0;
    _super.prototype._error.call(this, err);
  };
  BufferTimeSubscriber2.prototype._complete = function() {
    var _a2 = this, contexts = _a2.contexts, destination = _a2.destination;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      destination.next(context_2.buffer);
    }
    _super.prototype._complete.call(this);
  };
  BufferTimeSubscriber2.prototype._unsubscribe = function() {
    this.contexts = null;
  };
  BufferTimeSubscriber2.prototype.onBufferFull = function(context) {
    this.closeContext(context);
    var closeAction = context.closeAction;
    closeAction.unsubscribe();
    this.remove(closeAction);
    if (!this.closed && this.timespanOnly) {
      context = this.openContext();
      var bufferTimeSpan = this.bufferTimeSpan;
      var timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };
      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    }
  };
  BufferTimeSubscriber2.prototype.openContext = function() {
    var context = new Context();
    this.contexts.push(context);
    return context;
  };
  BufferTimeSubscriber2.prototype.closeContext = function(context) {
    this.destination.next(context.buffer);
    var contexts = this.contexts;
    var spliceIndex = contexts ? contexts.indexOf(context) : -1;
    if (spliceIndex >= 0) {
      contexts.splice(contexts.indexOf(context), 1);
    }
  };
  return BufferTimeSubscriber2;
}(Subscriber);
function dispatchBufferTimeSpanOnly(state2) {
  var subscriber = state2.subscriber;
  var prevContext = state2.context;
  if (prevContext) {
    subscriber.closeContext(prevContext);
  }
  if (!subscriber.closed) {
    state2.context = subscriber.openContext();
    state2.context.closeAction = this.schedule(state2, state2.bufferTimeSpan);
  }
}
function dispatchBufferCreation(state2) {
  var bufferCreationInterval = state2.bufferCreationInterval, bufferTimeSpan = state2.bufferTimeSpan, subscriber = state2.subscriber, scheduler2 = state2.scheduler;
  var context = subscriber.openContext();
  var action = this;
  if (!subscriber.closed) {
    subscriber.add(context.closeAction = scheduler2.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));
    action.schedule(state2, bufferCreationInterval);
  }
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context = arg.context;
  subscriber.closeContext(context);
}
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source) {
    return source.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function BufferToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  BufferToggleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return BufferToggleOperator2;
}();
var BufferToggleSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(BufferToggleSubscriber2, _super);
  function BufferToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(subscribeToResult(_this, openings));
    return _this;
  }
  BufferToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    var len2 = contexts.length;
    for (var i3 = 0; i3 < len2; i3++) {
      contexts[i3].buffer.push(value);
    }
  };
  BufferToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_1 = contexts.shift();
      context_1.subscription.unsubscribe();
      context_1.buffer = null;
      context_1.subscription = null;
    }
    this.contexts = null;
    _super.prototype._error.call(this, err);
  };
  BufferToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      this.destination.next(context_2.buffer);
      context_2.subscription.unsubscribe();
      context_2.buffer = null;
      context_2.subscription = null;
    }
    this.contexts = null;
    _super.prototype._complete.call(this);
  };
  BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
  };
  BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.closeBuffer(innerSub.context);
  };
  BufferToggleSubscriber2.prototype.openBuffer = function(value) {
    try {
      var closingSelector = this.closingSelector;
      var closingNotifier = closingSelector.call(this, value);
      if (closingNotifier) {
        this.trySubscribe(closingNotifier);
      }
    } catch (err) {
      this._error(err);
    }
  };
  BufferToggleSubscriber2.prototype.closeBuffer = function(context) {
    var contexts = this.contexts;
    if (contexts && context) {
      var buffer2 = context.buffer, subscription = context.subscription;
      this.destination.next(buffer2);
      contexts.splice(contexts.indexOf(context), 1);
      this.remove(subscription);
      subscription.unsubscribe();
    }
  };
  BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
    var contexts = this.contexts;
    var buffer2 = [];
    var subscription = new Subscription$1();
    var context = { buffer: buffer2, subscription };
    contexts.push(context);
    var innerSubscription = subscribeToResult(this, closingNotifier, context);
    if (!innerSubscription || innerSubscription.closed) {
      this.closeBuffer(context);
    } else {
      innerSubscription.context = context;
      this.add(innerSubscription);
      subscription.add(innerSubscription);
    }
  };
  return BufferToggleSubscriber2;
}(OuterSubscriber);
function bufferWhen(closingSelector) {
  return function(source) {
    return source.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function BufferWhenOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  BufferWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
  };
  return BufferWhenOperator2;
}();
var BufferWhenSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(BufferWhenSubscriber2, _super);
  function BufferWhenSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.subscribing = false;
    _this.openBuffer();
    return _this;
  }
  BufferWhenSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  };
  BufferWhenSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  BufferWhenSubscriber2.prototype._unsubscribe = function() {
    this.buffer = void 0;
    this.subscribing = false;
  };
  BufferWhenSubscriber2.prototype.notifyNext = function() {
    this.openBuffer();
  };
  BufferWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.subscribing) {
      this.complete();
    } else {
      this.openBuffer();
    }
  };
  BufferWhenSubscriber2.prototype.openBuffer = function() {
    var closingSubscription = this.closingSubscription;
    if (closingSubscription) {
      this.remove(closingSubscription);
      closingSubscription.unsubscribe();
    }
    var buffer2 = this.buffer;
    if (this.buffer) {
      this.destination.next(buffer2);
    }
    this.buffer = [];
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (err) {
      return this.error(err);
    }
    closingSubscription = new Subscription$1();
    this.closingSubscription = closingSubscription;
    this.add(closingSubscription);
    this.subscribing = true;
    closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
    this.subscribing = false;
  };
  return BufferWhenSubscriber2;
}(SimpleOuterSubscriber);
function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function CatchOperator2(selector) {
    this.selector = selector;
  }
  CatchOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  };
  return CatchOperator2;
}();
var CatchSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(CatchSubscriber2, _super);
  function CatchSubscriber2(destination, selector, caught) {
    var _this = _super.call(this, destination) || this;
    _this.selector = selector;
    _this.caught = caught;
    return _this;
  }
  CatchSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var result = void 0;
      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        _super.prototype.error.call(this, err2);
        return;
      }
      this._unsubscribeAndRecycle();
      var innerSubscriber = new SimpleInnerSubscriber(this);
      this.add(innerSubscriber);
      var innerSubscription = innerSubscribe(result, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        this.add(innerSubscription);
      }
    }
  };
  return CatchSubscriber2;
}(SimpleOuterSubscriber);
function combineAll(project) {
  return function(source) {
    return source.lift(new CombineLatestOperator(project));
  };
}
function combineLatest() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var project = null;
  if (typeof observables[observables.length - 1] === "function") {
    project = observables.pop();
  }
  if (observables.length === 1 && isArray$1(observables[0])) {
    observables = observables[0].slice();
  }
  return function(source) {
    return source.lift.call(from([source].concat(observables)), new CombineLatestOperator(project));
  };
}
function concat$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(concat$2.apply(void 0, [source].concat(observables)));
  };
}
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
function count(predicate) {
  return function(source) {
    return source.lift(new CountOperator(predicate, source));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function CountOperator2(predicate, source) {
    this.predicate = predicate;
    this.source = source;
  }
  CountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
  };
  return CountOperator2;
}();
var CountSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(CountSubscriber2, _super);
  function CountSubscriber2(destination, predicate, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.count = 0;
    _this.index = 0;
    return _this;
  }
  CountSubscriber2.prototype._next = function(value) {
    if (this.predicate) {
      this._tryPredicate(value);
    } else {
      this.count++;
    }
  };
  CountSubscriber2.prototype._tryPredicate = function(value) {
    var result;
    try {
      result = this.predicate(value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.count++;
    }
  };
  CountSubscriber2.prototype._complete = function() {
    this.destination.next(this.count);
    this.destination.complete();
  };
  return CountSubscriber2;
}(Subscriber);
function debounce(durationSelector) {
  return function(source) {
    return source.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function DebounceOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  DebounceOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
  };
  return DebounceOperator2;
}();
var DebounceSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(DebounceSubscriber2, _super);
  function DebounceSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  DebounceSubscriber2.prototype._next = function(value) {
    try {
      var result = this.durationSelector.call(this, value);
      if (result) {
        this._tryNext(value, result);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DebounceSubscriber2.prototype._complete = function() {
    this.emitValue();
    this.destination.complete();
  };
  DebounceSubscriber2.prototype._tryNext = function(value, duration) {
    var subscription = this.durationSubscription;
    this.value = value;
    this.hasValue = true;
    if (subscription) {
      subscription.unsubscribe();
      this.remove(subscription);
    }
    subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
    if (subscription && !subscription.closed) {
      this.add(this.durationSubscription = subscription);
    }
  };
  DebounceSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      var value = this.value;
      var subscription = this.durationSubscription;
      if (subscription) {
        this.durationSubscription = void 0;
        subscription.unsubscribe();
        this.remove(subscription);
      }
      this.value = void 0;
      this.hasValue = false;
      _super.prototype._next.call(this, value);
    }
  };
  return DebounceSubscriber2;
}(SimpleOuterSubscriber);
function debounceTime(dueTime, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return function(source) {
    return source.lift(new DebounceTimeOperator(dueTime, scheduler2));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function DebounceTimeOperator2(dueTime, scheduler2) {
    this.dueTime = dueTime;
    this.scheduler = scheduler2;
  }
  DebounceTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  };
  return DebounceTimeOperator2;
}();
var DebounceTimeSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(DebounceTimeSubscriber2, _super);
  function DebounceTimeSubscriber2(destination, dueTime, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.dueTime = dueTime;
    _this.scheduler = scheduler2;
    _this.debouncedSubscription = null;
    _this.lastValue = null;
    _this.hasValue = false;
    return _this;
  }
  DebounceTimeSubscriber2.prototype._next = function(value) {
    this.clearDebounce();
    this.lastValue = value;
    this.hasValue = true;
    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  };
  DebounceTimeSubscriber2.prototype._complete = function() {
    this.debouncedNext();
    this.destination.complete();
  };
  DebounceTimeSubscriber2.prototype.debouncedNext = function() {
    this.clearDebounce();
    if (this.hasValue) {
      var lastValue = this.lastValue;
      this.lastValue = null;
      this.hasValue = false;
      this.destination.next(lastValue);
    }
  };
  DebounceTimeSubscriber2.prototype.clearDebounce = function() {
    var debouncedSubscription = this.debouncedSubscription;
    if (debouncedSubscription !== null) {
      this.remove(debouncedSubscription);
      debouncedSubscription.unsubscribe();
      this.debouncedSubscription = null;
    }
  };
  return DebounceTimeSubscriber2;
}(Subscriber);
function dispatchNext$1(subscriber) {
  subscriber.debouncedNext();
}
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source) {
    return source.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function DefaultIfEmptyOperator2(defaultValue) {
    this.defaultValue = defaultValue;
  }
  DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
  };
  return DefaultIfEmptyOperator2;
}();
var DefaultIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(DefaultIfEmptySubscriber2, _super);
  function DefaultIfEmptySubscriber2(destination, defaultValue) {
    var _this = _super.call(this, destination) || this;
    _this.defaultValue = defaultValue;
    _this.isEmpty = true;
    return _this;
  }
  DefaultIfEmptySubscriber2.prototype._next = function(value) {
    this.isEmpty = false;
    this.destination.next(value);
  };
  DefaultIfEmptySubscriber2.prototype._complete = function() {
    if (this.isEmpty) {
      this.destination.next(this.defaultValue);
    }
    this.destination.complete();
  };
  return DefaultIfEmptySubscriber2;
}(Subscriber);
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
function delay(delay2, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  var absoluteDelay = isDate(delay2);
  var delayFor = absoluteDelay ? +delay2 - scheduler2.now() : Math.abs(delay2);
  return function(source) {
    return source.lift(new DelayOperator(delayFor, scheduler2));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function DelayOperator2(delay2, scheduler2) {
    this.delay = delay2;
    this.scheduler = scheduler2;
  }
  DelayOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  };
  return DelayOperator2;
}();
var DelaySubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(DelaySubscriber2, _super);
  function DelaySubscriber2(destination, delay2, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.delay = delay2;
    _this.scheduler = scheduler2;
    _this.queue = [];
    _this.active = false;
    _this.errored = false;
    return _this;
  }
  DelaySubscriber2.dispatch = function(state2) {
    var source = state2.source;
    var queue2 = source.queue;
    var scheduler2 = state2.scheduler;
    var destination = state2.destination;
    while (queue2.length > 0 && queue2[0].time - scheduler2.now() <= 0) {
      queue2.shift().notification.observe(destination);
    }
    if (queue2.length > 0) {
      var delay_1 = Math.max(0, queue2[0].time - scheduler2.now());
      this.schedule(state2, delay_1);
    } else {
      this.unsubscribe();
      source.active = false;
    }
  };
  DelaySubscriber2.prototype._schedule = function(scheduler2) {
    this.active = true;
    var destination = this.destination;
    destination.add(scheduler2.schedule(DelaySubscriber2.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler: scheduler2
    }));
  };
  DelaySubscriber2.prototype.scheduleNotification = function(notification) {
    if (this.errored === true) {
      return;
    }
    var scheduler2 = this.scheduler;
    var message = new DelayMessage(scheduler2.now() + this.delay, notification);
    this.queue.push(message);
    if (this.active === false) {
      this._schedule(scheduler2);
    }
  };
  DelaySubscriber2.prototype._next = function(value) {
    this.scheduleNotification(Notification.createNext(value));
  };
  DelaySubscriber2.prototype._error = function(err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
    this.unsubscribe();
  };
  DelaySubscriber2.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete());
    this.unsubscribe();
  };
  return DelaySubscriber2;
}(Subscriber);
var DelayMessage = /* @__PURE__ */ function() {
  function DelayMessage2(time2, notification) {
    this.time = time2;
    this.notification = notification;
  }
  return DelayMessage2;
}();
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  return function(source) {
    return source.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function DelayWhenOperator2(delayDurationSelector) {
    this.delayDurationSelector = delayDurationSelector;
  }
  DelayWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
  };
  return DelayWhenOperator2;
}();
var DelayWhenSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(DelayWhenSubscriber2, _super);
  function DelayWhenSubscriber2(destination, delayDurationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.delayDurationSelector = delayDurationSelector;
    _this.completed = false;
    _this.delayNotifierSubscriptions = [];
    _this.index = 0;
    return _this;
  }
  DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.destination.next(outerValue);
    this.removeSubscription(innerSub);
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype.notifyError = function(error, innerSub) {
    this._error(error);
  };
  DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
    var value = this.removeSubscription(innerSub);
    if (value) {
      this.destination.next(value);
    }
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype._next = function(value) {
    var index2 = this.index++;
    try {
      var delayNotifier = this.delayDurationSelector(value, index2);
      if (delayNotifier) {
        this.tryDelay(delayNotifier, value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DelayWhenSubscriber2.prototype._complete = function() {
    this.completed = true;
    this.tryComplete();
    this.unsubscribe();
  };
  DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
    subscription.unsubscribe();
    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
    if (subscriptionIdx !== -1) {
      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
    }
    return subscription.outerValue;
  };
  DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
    var notifierSubscription = subscribeToResult(this, delayNotifier, value);
    if (notifierSubscription && !notifierSubscription.closed) {
      var destination = this.destination;
      destination.add(notifierSubscription);
      this.delayNotifierSubscriptions.push(notifierSubscription);
    }
  };
  DelayWhenSubscriber2.prototype.tryComplete = function() {
    if (this.completed && this.delayNotifierSubscriptions.length === 0) {
      this.destination.complete();
    }
  };
  return DelayWhenSubscriber2;
}(OuterSubscriber);
var SubscriptionDelayObservable = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SubscriptionDelayObservable2, _super);
  function SubscriptionDelayObservable2(source, subscriptionDelay) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subscriptionDelay = subscriptionDelay;
    return _this;
  }
  SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
  };
  return SubscriptionDelayObservable2;
}(Observable$1);
var SubscriptionDelaySubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SubscriptionDelaySubscriber2, _super);
  function SubscriptionDelaySubscriber2(parent, source) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    _this.source = source;
    _this.sourceSubscribed = false;
    return _this;
  }
  SubscriptionDelaySubscriber2.prototype._next = function(unused) {
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype._error = function(err) {
    this.unsubscribe();
    this.parent.error(err);
  };
  SubscriptionDelaySubscriber2.prototype._complete = function() {
    this.unsubscribe();
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
    if (!this.sourceSubscribed) {
      this.sourceSubscribed = true;
      this.unsubscribe();
      this.source.subscribe(this.parent);
    }
  };
  return SubscriptionDelaySubscriber2;
}(Subscriber);
function dematerialize() {
  return function dematerializeOperatorFunction(source) {
    return source.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function DeMaterializeOperator2() {
  }
  DeMaterializeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DeMaterializeSubscriber(subscriber));
  };
  return DeMaterializeOperator2;
}();
var DeMaterializeSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(DeMaterializeSubscriber2, _super);
  function DeMaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  DeMaterializeSubscriber2.prototype._next = function(value) {
    value.observe(this.destination);
  };
  return DeMaterializeSubscriber2;
}(Subscriber);
function distinct(keySelector, flushes) {
  return function(source) {
    return source.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function DistinctOperator2(keySelector, flushes) {
    this.keySelector = keySelector;
    this.flushes = flushes;
  }
  DistinctOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
  };
  return DistinctOperator2;
}();
var DistinctSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(DistinctSubscriber2, _super);
  function DistinctSubscriber2(destination, keySelector, flushes) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.values = /* @__PURE__ */ new Set();
    if (flushes) {
      _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
    }
    return _this;
  }
  DistinctSubscriber2.prototype.notifyNext = function() {
    this.values.clear();
  };
  DistinctSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  DistinctSubscriber2.prototype._next = function(value) {
    if (this.keySelector) {
      this._useKeySelector(value);
    } else {
      this._finalizeNext(value, value);
    }
  };
  DistinctSubscriber2.prototype._useKeySelector = function(value) {
    var key2;
    var destination = this.destination;
    try {
      key2 = this.keySelector(value);
    } catch (err) {
      destination.error(err);
      return;
    }
    this._finalizeNext(key2, value);
  };
  DistinctSubscriber2.prototype._finalizeNext = function(key2, value) {
    var values = this.values;
    if (!values.has(key2)) {
      values.add(key2);
      this.destination.next(value);
    }
  };
  return DistinctSubscriber2;
}(SimpleOuterSubscriber);
function distinctUntilChanged(compare2, keySelector) {
  return function(source) {
    return source.lift(new DistinctUntilChangedOperator(compare2, keySelector));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function DistinctUntilChangedOperator2(compare2, keySelector) {
    this.compare = compare2;
    this.keySelector = keySelector;
  }
  DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  };
  return DistinctUntilChangedOperator2;
}();
var DistinctUntilChangedSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(DistinctUntilChangedSubscriber2, _super);
  function DistinctUntilChangedSubscriber2(destination, compare2, keySelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.hasKey = false;
    if (typeof compare2 === "function") {
      _this.compare = compare2;
    }
    return _this;
  }
  DistinctUntilChangedSubscriber2.prototype.compare = function(x2, y3) {
    return x2 === y3;
  };
  DistinctUntilChangedSubscriber2.prototype._next = function(value) {
    var key2;
    try {
      var keySelector = this.keySelector;
      key2 = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }
    var result = false;
    if (this.hasKey) {
      try {
        var compare2 = this.compare;
        result = compare2(this.key, key2);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }
    if (!result) {
      this.key = key2;
      this.destination.next(value);
    }
  };
  return DistinctUntilChangedSubscriber2;
}(Subscriber);
function distinctUntilKeyChanged(key2, compare2) {
  return distinctUntilChanged(function(x2, y3) {
    return compare2 ? compare2(x2[key2], y3[key2]) : x2[key2] === y3[key2];
  });
}
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source) {
    return source.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function ThrowIfEmptyOperator2(errorFactory) {
    this.errorFactory = errorFactory;
  }
  ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
  };
  return ThrowIfEmptyOperator2;
}();
var ThrowIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ThrowIfEmptySubscriber2, _super);
  function ThrowIfEmptySubscriber2(destination, errorFactory) {
    var _this = _super.call(this, destination) || this;
    _this.errorFactory = errorFactory;
    _this.hasValue = false;
    return _this;
  }
  ThrowIfEmptySubscriber2.prototype._next = function(value) {
    this.hasValue = true;
    this.destination.next(value);
  };
  ThrowIfEmptySubscriber2.prototype._complete = function() {
    if (!this.hasValue) {
      var err = void 0;
      try {
        err = this.errorFactory();
      } catch (e2) {
        err = e2;
      }
      this.destination.error(err);
    } else {
      return this.destination.complete();
    }
  };
  return ThrowIfEmptySubscriber2;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take$2(count2) {
  return function(source) {
    if (count2 === 0) {
      return empty();
    } else {
      return source.lift(new TakeOperator(count2));
    }
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function TakeOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeSubscriber(subscriber, this.total));
  };
  return TakeOperator2;
}();
var TakeSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(TakeSubscriber2, _super);
  function TakeSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  TakeSubscriber2.prototype._next = function(value) {
    var total = this.total;
    var count2 = ++this.count;
    if (count2 <= total) {
      this.destination.next(value);
      if (count2 === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  };
  return TakeSubscriber2;
}(Subscriber);
function elementAt(index2, defaultValue) {
  if (index2 < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter$2(function(v4, i3) {
      return i3 === index2;
    }), take$2(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  var array2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array2[_i] = arguments[_i];
  }
  return function(source) {
    return concat$2(source, of$1.apply(void 0, array2));
  };
}
function every(predicate, thisArg) {
  return function(source) {
    return source.lift(new EveryOperator(predicate, thisArg, source));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function EveryOperator2(predicate, thisArg, source) {
    this.predicate = predicate;
    this.thisArg = thisArg;
    this.source = source;
  }
  EveryOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
  };
  return EveryOperator2;
}();
var EverySubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(EverySubscriber2, _super);
  function EverySubscriber2(destination, predicate, thisArg, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.source = source;
    _this.index = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
    this.destination.next(everyValueMatch);
    this.destination.complete();
  };
  EverySubscriber2.prototype._next = function(value) {
    var result = false;
    try {
      result = this.predicate.call(this.thisArg, value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (!result) {
      this.notifyComplete(false);
    }
  };
  EverySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return EverySubscriber2;
}(Subscriber);
function exhaust() {
  return function(source) {
    return source.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function SwitchFirstOperator2() {
  }
  SwitchFirstOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SwitchFirstSubscriber(subscriber));
  };
  return SwitchFirstOperator2;
}();
var SwitchFirstSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SwitchFirstSubscriber2, _super);
  function SwitchFirstSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasCompleted = false;
    _this.hasSubscription = false;
    return _this;
  }
  SwitchFirstSubscriber2.prototype._next = function(value) {
    if (!this.hasSubscription) {
      this.hasSubscription = true;
      this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));
    }
  };
  SwitchFirstSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
  };
  SwitchFirstSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return SwitchFirstSubscriber2;
}(SimpleOuterSubscriber);
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a3, i3) {
        return from(project(a3, i3)).pipe(map$2(function(b4, ii2) {
          return resultSelector(a3, b4, i3, ii2);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function ExhaustMapOperator2(project) {
    this.project = project;
  }
  ExhaustMapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
  };
  return ExhaustMapOperator2;
}();
var ExhaustMapSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ExhaustMapSubscriber2, _super);
  function ExhaustMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.hasSubscription = false;
    _this.hasCompleted = false;
    _this.index = 0;
    return _this;
  }
  ExhaustMapSubscriber2.prototype._next = function(value) {
    if (!this.hasSubscription) {
      this.tryNext(value);
    }
  };
  ExhaustMapSubscriber2.prototype.tryNext = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.hasSubscription = true;
    this._innerSub(result);
  };
  ExhaustMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(result, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  ExhaustMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  ExhaustMapSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  ExhaustMapSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return ExhaustMapSubscriber2;
}(SimpleOuterSubscriber);
function expand(project, concurrent, scheduler2) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function(source) {
    return source.lift(new ExpandOperator(project, concurrent, scheduler2));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function ExpandOperator2(project, concurrent, scheduler2) {
    this.project = project;
    this.concurrent = concurrent;
    this.scheduler = scheduler2;
  }
  ExpandOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
  };
  return ExpandOperator2;
}();
var ExpandSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ExpandSubscriber2, _super);
  function ExpandSubscriber2(destination, project, concurrent, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.scheduler = scheduler2;
    _this.index = 0;
    _this.active = 0;
    _this.hasCompleted = false;
    if (concurrent < Number.POSITIVE_INFINITY) {
      _this.buffer = [];
    }
    return _this;
  }
  ExpandSubscriber2.dispatch = function(arg) {
    var subscriber = arg.subscriber, result = arg.result, value = arg.value, index2 = arg.index;
    subscriber.subscribeToProjection(result, value, index2);
  };
  ExpandSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (destination.closed) {
      this._complete();
      return;
    }
    var index2 = this.index++;
    if (this.active < this.concurrent) {
      destination.next(value);
      try {
        var project = this.project;
        var result = project(value, index2);
        if (!this.scheduler) {
          this.subscribeToProjection(result, value, index2);
        } else {
          var state2 = { subscriber: this, result, value, index: index2 };
          var destination_1 = this.destination;
          destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state2));
        }
      } catch (e2) {
        destination.error(e2);
      }
    } else {
      this.buffer.push(value);
    }
  };
  ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index2) {
    this.active++;
    var destination = this.destination;
    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
  };
  ExpandSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
    this._next(innerValue);
  };
  ExpandSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2 && buffer2.length > 0) {
      this._next(buffer2.shift());
    }
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
  };
  return ExpandSubscriber2;
}(SimpleOuterSubscriber);
function finalize(callback) {
  return function(source) {
    return source.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function FinallyOperator2(callback) {
    this.callback = callback;
  }
  FinallyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new FinallySubscriber(subscriber, this.callback));
  };
  return FinallyOperator2;
}();
var FinallySubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(FinallySubscriber2, _super);
  function FinallySubscriber2(destination, callback) {
    var _this = _super.call(this, destination) || this;
    _this.add(new Subscription$1(callback));
    return _this;
  }
  return FinallySubscriber2;
}(Subscriber);
function find(predicate, thisArg) {
  if (typeof predicate !== "function") {
    throw new TypeError("predicate is not a function");
  }
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, false, thisArg));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function FindValueOperator2(predicate, source, yieldIndex, thisArg) {
    this.predicate = predicate;
    this.source = source;
    this.yieldIndex = yieldIndex;
    this.thisArg = thisArg;
  }
  FindValueOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
  };
  return FindValueOperator2;
}();
var FindValueSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(FindValueSubscriber2, _super);
  function FindValueSubscriber2(destination, predicate, source, yieldIndex, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.yieldIndex = yieldIndex;
    _this.thisArg = thisArg;
    _this.index = 0;
    return _this;
  }
  FindValueSubscriber2.prototype.notifyComplete = function(value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
    this.unsubscribe();
  };
  FindValueSubscriber2.prototype._next = function(value) {
    var _a2 = this, predicate = _a2.predicate, thisArg = _a2.thisArg;
    var index2 = this.index++;
    try {
      var result = predicate.call(thisArg || this, value, index2, this.source);
      if (result) {
        this.notifyComplete(this.yieldIndex ? index2 : value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  FindValueSubscriber2.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  };
  return FindValueSubscriber2;
}(Subscriber);
function findIndex(predicate, thisArg) {
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, true, thisArg));
  };
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter$2(function(v4, i3) {
      return predicate(v4, i3, source);
    }) : identity, take$2(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function IgnoreElementsOperator2() {
  }
  IgnoreElementsOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new IgnoreElementsSubscriber(subscriber));
  };
  return IgnoreElementsOperator2;
}();
var IgnoreElementsSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(IgnoreElementsSubscriber2, _super);
  function IgnoreElementsSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IgnoreElementsSubscriber2.prototype._next = function(unused) {
  };
  return IgnoreElementsSubscriber2;
}(Subscriber);
function isEmpty$1() {
  return function(source) {
    return source.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function IsEmptyOperator2() {
  }
  IsEmptyOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new IsEmptySubscriber(observer));
  };
  return IsEmptyOperator2;
}();
var IsEmptySubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(IsEmptySubscriber2, _super);
  function IsEmptySubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
    var destination = this.destination;
    destination.next(isEmpty2);
    destination.complete();
  };
  IsEmptySubscriber2.prototype._next = function(value) {
    this.notifyComplete(false);
  };
  IsEmptySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return IsEmptySubscriber2;
}(Subscriber);
function takeLast(count2) {
  return function takeLastOperatorFunction(source) {
    if (count2 === 0) {
      return empty();
    } else {
      return source.lift(new TakeLastOperator(count2));
    }
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function TakeLastOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeLastOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
  };
  return TakeLastOperator2;
}();
var TakeLastSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(TakeLastSubscriber2, _super);
  function TakeLastSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.ring = new Array();
    _this.count = 0;
    return _this;
  }
  TakeLastSubscriber2.prototype._next = function(value) {
    var ring = this.ring;
    var total = this.total;
    var count2 = this.count++;
    if (ring.length < total) {
      ring.push(value);
    } else {
      var index2 = count2 % total;
      ring[index2] = value;
    }
  };
  TakeLastSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    var count2 = this.count;
    if (count2 > 0) {
      var total = this.count >= this.total ? this.total : this.count;
      var ring = this.ring;
      for (var i3 = 0; i3 < total; i3++) {
        var idx = count2++ % total;
        destination.next(ring[idx]);
      }
    }
    destination.complete();
  };
  return TakeLastSubscriber2;
}(Subscriber);
function last$2(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter$2(function(v4, i3) {
      return predicate(v4, i3, source);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(value) {
  return function(source) {
    return source.lift(new MapToOperator(value));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function MapToOperator2(value) {
    this.value = value;
  }
  MapToOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MapToSubscriber(subscriber, this.value));
  };
  return MapToOperator2;
}();
var MapToSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(MapToSubscriber2, _super);
  function MapToSubscriber2(destination, value) {
    var _this = _super.call(this, destination) || this;
    _this.value = value;
    return _this;
  }
  MapToSubscriber2.prototype._next = function(x2) {
    this.destination.next(this.value);
  };
  return MapToSubscriber2;
}(Subscriber);
function materialize() {
  return function materializeOperatorFunction(source) {
    return source.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function MaterializeOperator2() {
  }
  MaterializeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MaterializeSubscriber(subscriber));
  };
  return MaterializeOperator2;
}();
var MaterializeSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(MaterializeSubscriber2, _super);
  function MaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  MaterializeSubscriber2.prototype._next = function(value) {
    this.destination.next(Notification.createNext(value));
  };
  MaterializeSubscriber2.prototype._error = function(err) {
    var destination = this.destination;
    destination.next(Notification.createError(err));
    destination.complete();
  };
  MaterializeSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    destination.next(Notification.createComplete());
    destination.complete();
  };
  return MaterializeSubscriber2;
}(Subscriber);
function scan(accumulator, seed) {
  var hasSeed = false;
  if (arguments.length >= 2) {
    hasSeed = true;
  }
  return function scanOperatorFunction(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function ScanOperator2(accumulator, seed, hasSeed) {
    if (hasSeed === void 0) {
      hasSeed = false;
    }
    this.accumulator = accumulator;
    this.seed = seed;
    this.hasSeed = hasSeed;
  }
  ScanOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
  };
  return ScanOperator2;
}();
var ScanSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ScanSubscriber2, _super);
  function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this._seed = _seed;
    _this.hasSeed = hasSeed;
    _this.index = 0;
    return _this;
  }
  Object.defineProperty(ScanSubscriber2.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(value) {
      this.hasSeed = true;
      this._seed = value;
    },
    enumerable: true,
    configurable: true
  });
  ScanSubscriber2.prototype._next = function(value) {
    if (!this.hasSeed) {
      this.seed = value;
      this.destination.next(value);
    } else {
      return this._tryNext(value);
    }
  };
  ScanSubscriber2.prototype._tryNext = function(value) {
    var index2 = this.index++;
    var result;
    try {
      result = this.accumulator(this.seed, value, index2);
    } catch (err) {
      this.destination.error(err);
    }
    this.seed = result;
    this.destination.next(result);
  };
  return ScanSubscriber2;
}(Subscriber);
function reduce$1(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source) {
      return pipe$2(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
    };
  }
  return function reduceOperatorFunction(source) {
    return pipe$2(scan(function(acc, value, index2) {
      return accumulator(acc, value, index2 + 1);
    }), takeLast(1))(source);
  };
}
function max(comparer) {
  var max2 = typeof comparer === "function" ? function(x2, y3) {
    return comparer(x2, y3) > 0 ? x2 : y3;
  } : function(x2, y3) {
    return x2 > y3 ? x2 : y3;
  };
  return reduce$1(max2);
}
function merge$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(merge$2.apply(void 0, [source].concat(observables)));
  };
}
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return function(source) {
    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function MergeScanOperator2(accumulator, seed, concurrent) {
    this.accumulator = accumulator;
    this.seed = seed;
    this.concurrent = concurrent;
  }
  MergeScanOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
  };
  return MergeScanOperator2;
}();
var MergeScanSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(MergeScanSubscriber2, _super);
  function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this.acc = acc;
    _this.concurrent = concurrent;
    _this.hasValue = false;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeScanSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      var index2 = this.index++;
      var destination = this.destination;
      var ish = void 0;
      try {
        var accumulator = this.accumulator;
        ish = accumulator(this.acc, value, index2);
      } catch (e2) {
        return destination.error(e2);
      }
      this.active++;
      this._innerSub(ish);
    } else {
      this.buffer.push(value);
    }
  };
  MergeScanSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeScanSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
    var destination = this.destination;
    this.acc = innerValue;
    this.hasValue = true;
    destination.next(innerValue);
  };
  MergeScanSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
  };
  return MergeScanSubscriber2;
}(SimpleOuterSubscriber);
function min(comparer) {
  var min2 = typeof comparer === "function" ? function(x2, y3) {
    return comparer(x2, y3) < 0 ? x2 : y3;
  } : function(x2, y3) {
    return x2 < y3 ? x2 : y3;
  };
  return reduce$1(min2);
}
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function MulticastOperator2(subjectFactory, selector) {
    this.subjectFactory = subjectFactory;
    this.selector = selector;
  }
  MulticastOperator2.prototype.call = function(subscriber, source) {
    var selector = this.selector;
    var subject = this.subjectFactory();
    var subscription = selector(subject).subscribe(subscriber);
    subscription.add(source.subscribe(subject));
    return subscription;
  };
  return MulticastOperator2;
}();
function onErrorResumeNext() {
  var nextSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }
  if (nextSources.length === 1 && isArray$1(nextSources[0])) {
    nextSources = nextSources[0];
  }
  return function(source) {
    return source.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function OnErrorResumeNextOperator2(nextSources) {
    this.nextSources = nextSources;
  }
  OnErrorResumeNextOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
  };
  return OnErrorResumeNextOperator2;
}();
var OnErrorResumeNextSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(OnErrorResumeNextSubscriber2, _super);
  function OnErrorResumeNextSubscriber2(destination, nextSources) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.nextSources = nextSources;
    return _this;
  }
  OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype._error = function(err) {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype._complete = function() {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
    var next = this.nextSources.shift();
    if (!!next) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(next, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    } else {
      this.destination.complete();
    }
  };
  return OnErrorResumeNextSubscriber2;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(source) {
    return source.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function PairwiseOperator2() {
  }
  PairwiseOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new PairwiseSubscriber(subscriber));
  };
  return PairwiseOperator2;
}();
var PairwiseSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(PairwiseSubscriber2, _super);
  function PairwiseSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasPrev = false;
    return _this;
  }
  PairwiseSubscriber2.prototype._next = function(value) {
    var pair;
    if (this.hasPrev) {
      pair = [this.prev, value];
    } else {
      this.hasPrev = true;
    }
    this.prev = value;
    if (pair) {
      this.destination.next(pair);
    }
  };
  return PairwiseSubscriber2;
}(Subscriber);
function partition(predicate, thisArg) {
  return function(source) {
    return [
      filter$2(predicate, thisArg)(source),
      filter$2(not(predicate, thisArg))(source)
    ];
  };
}
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length2 = properties.length;
  if (length2 === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source) {
    return map$2(plucker(properties, length2))(source);
  };
}
function plucker(props, length2) {
  var mapper = function(x2) {
    var currentProp = x2;
    for (var i3 = 0; i3 < length2; i3++) {
      var p3 = currentProp != null ? currentProp[props[i3]] : void 0;
      if (p3 !== void 0) {
        currentProp = p3;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
function publishBehavior(value) {
  return function(source) {
    return multicast(new BehaviorSubject(value))(source);
  };
}
function publishLast() {
  return function(source) {
    return multicast(new AsyncSubject())(source);
  };
}
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler2) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler2 = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime2, scheduler2);
  return function(source) {
    return multicast(function() {
      return subject;
    }, selector)(source);
  };
}
function race() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function raceOperatorFunction(source) {
    if (observables.length === 1 && isArray$1(observables[0])) {
      observables = observables[0];
    }
    return source.lift.call(race$1.apply(void 0, [source].concat(observables)));
  };
}
function repeat(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    if (count2 === 0) {
      return empty();
    } else if (count2 < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count2 - 1, source));
    }
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function RepeatOperator2(count2, source) {
    this.count = count2;
    this.source = source;
  }
  RepeatOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  };
  return RepeatOperator2;
}();
var RepeatSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(RepeatSubscriber2, _super);
  function RepeatSubscriber2(destination, count2, source) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source;
    return _this;
  }
  RepeatSubscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      var _a2 = this, source = _a2.source, count2 = _a2.count;
      if (count2 === 0) {
        return _super.prototype.complete.call(this);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RepeatSubscriber2;
}(Subscriber);
function repeatWhen(notifier) {
  return function(source) {
    return source.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function RepeatWhenOperator2(notifier) {
    this.notifier = notifier;
  }
  RepeatWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
  };
  return RepeatWhenOperator2;
}();
var RepeatWhenSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(RepeatWhenSubscriber2, _super);
  function RepeatWhenSubscriber2(destination, notifier, source) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source;
    _this.sourceIsBeingSubscribedTo = true;
    return _this;
  }
  RepeatWhenSubscriber2.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = true;
    this.source.subscribe(this);
  };
  RepeatWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === false) {
      return _super.prototype.complete.call(this);
    }
  };
  RepeatWhenSubscriber2.prototype.complete = function() {
    this.sourceIsBeingSubscribedTo = false;
    if (!this.isStopped) {
      if (!this.retries) {
        this.subscribeToRetries();
      }
      if (!this.retriesSubscription || this.retriesSubscription.closed) {
        return _super.prototype.complete.call(this);
      }
      this._unsubscribeAndRecycle();
      this.notifications.next(void 0);
    }
  };
  RepeatWhenSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, notifications = _a2.notifications, retriesSubscription = _a2.retriesSubscription;
    if (notifications) {
      notifications.unsubscribe();
      this.notifications = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    _super.prototype._unsubscribeAndRecycle.call(this);
    this._unsubscribe = _unsubscribe;
    return this;
  };
  RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var retries;
    try {
      var notifier = this.notifier;
      retries = notifier(this.notifications);
    } catch (e2) {
      return _super.prototype.complete.call(this);
    }
    this.retries = retries;
    this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
  };
  return RepeatWhenSubscriber2;
}(SimpleOuterSubscriber);
function retry$6(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    return source.lift(new RetryOperator(count2, source));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function RetryOperator2(count2, source) {
    this.count = count2;
    this.source = source;
  }
  RetryOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
  };
  return RetryOperator2;
}();
var RetrySubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(RetrySubscriber2, _super);
  function RetrySubscriber2(destination, count2, source) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source;
    return _this;
  }
  RetrySubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _a2 = this, source = _a2.source, count2 = _a2.count;
      if (count2 === 0) {
        return _super.prototype.error.call(this, err);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RetrySubscriber2;
}(Subscriber);
function retryWhen(notifier) {
  return function(source) {
    return source.lift(new RetryWhenOperator(notifier, source));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function RetryWhenOperator2(notifier, source) {
    this.notifier = notifier;
    this.source = source;
  }
  RetryWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
  };
  return RetryWhenOperator2;
}();
var RetryWhenSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(RetryWhenSubscriber2, _super);
  function RetryWhenSubscriber2(destination, notifier, source) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source;
    return _this;
  }
  RetryWhenSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var errors2 = this.errors;
      var retries = this.retries;
      var retriesSubscription = this.retriesSubscription;
      if (!retries) {
        errors2 = new Subject();
        try {
          var notifier = this.notifier;
          retries = notifier(errors2);
        } catch (e2) {
          return _super.prototype.error.call(this, e2);
        }
        retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      } else {
        this.errors = void 0;
        this.retriesSubscription = void 0;
      }
      this._unsubscribeAndRecycle();
      this.errors = errors2;
      this.retries = retries;
      this.retriesSubscription = retriesSubscription;
      errors2.next(err);
    }
  };
  RetryWhenSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, errors2 = _a2.errors, retriesSubscription = _a2.retriesSubscription;
    if (errors2) {
      errors2.unsubscribe();
      this.errors = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RetryWhenSubscriber2.prototype.notifyNext = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    this._unsubscribeAndRecycle();
    this._unsubscribe = _unsubscribe;
    this.source.subscribe(this);
  };
  return RetryWhenSubscriber2;
}(SimpleOuterSubscriber);
function sample(notifier) {
  return function(source) {
    return source.lift(new SampleOperator(notifier));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function SampleOperator2(notifier) {
    this.notifier = notifier;
  }
  SampleOperator2.prototype.call = function(subscriber, source) {
    var sampleSubscriber = new SampleSubscriber(subscriber);
    var subscription = source.subscribe(sampleSubscriber);
    subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
    return subscription;
  };
  return SampleOperator2;
}();
var SampleSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SampleSubscriber2, _super);
  function SampleSubscriber2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.hasValue = false;
    return _this;
  }
  SampleSubscriber2.prototype._next = function(value) {
    this.value = value;
    this.hasValue = true;
  };
  SampleSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.value);
    }
  };
  return SampleSubscriber2;
}(SimpleOuterSubscriber);
function sampleTime(period, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return function(source) {
    return source.lift(new SampleTimeOperator(period, scheduler2));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function SampleTimeOperator2(period, scheduler2) {
    this.period = period;
    this.scheduler = scheduler2;
  }
  SampleTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
  };
  return SampleTimeOperator2;
}();
var SampleTimeSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SampleTimeSubscriber2, _super);
  function SampleTimeSubscriber2(destination, period, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.period = period;
    _this.scheduler = scheduler2;
    _this.hasValue = false;
    _this.add(scheduler2.schedule(dispatchNotification, period, { subscriber: _this, period }));
    return _this;
  }
  SampleTimeSubscriber2.prototype._next = function(value) {
    this.lastValue = value;
    this.hasValue = true;
  };
  SampleTimeSubscriber2.prototype.notifyNext = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.lastValue);
    }
  };
  return SampleTimeSubscriber2;
}(Subscriber);
function dispatchNotification(state2) {
  var subscriber = state2.subscriber, period = state2.period;
  subscriber.notifyNext();
  this.schedule(state2, period);
}
function sequenceEqual(compareTo, comparator2) {
  return function(source) {
    return source.lift(new SequenceEqualOperator(compareTo, comparator2));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function SequenceEqualOperator2(compareTo, comparator2) {
    this.compareTo = compareTo;
    this.comparator = comparator2;
  }
  SequenceEqualOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
  };
  return SequenceEqualOperator2;
}();
var SequenceEqualSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SequenceEqualSubscriber2, _super);
  function SequenceEqualSubscriber2(destination, compareTo, comparator2) {
    var _this = _super.call(this, destination) || this;
    _this.compareTo = compareTo;
    _this.comparator = comparator2;
    _this._a = [];
    _this._b = [];
    _this._oneComplete = false;
    _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
    return _this;
  }
  SequenceEqualSubscriber2.prototype._next = function(value) {
    if (this._oneComplete && this._b.length === 0) {
      this.emit(false);
    } else {
      this._a.push(value);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype._complete = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
    this.unsubscribe();
  };
  SequenceEqualSubscriber2.prototype.checkValues = function() {
    var _c = this, _a2 = _c._a, _b = _c._b, comparator2 = _c.comparator;
    while (_a2.length > 0 && _b.length > 0) {
      var a3 = _a2.shift();
      var b4 = _b.shift();
      var areEqual = false;
      try {
        areEqual = comparator2 ? comparator2(a3, b4) : a3 === b4;
      } catch (e2) {
        this.destination.error(e2);
      }
      if (!areEqual) {
        this.emit(false);
      }
    }
  };
  SequenceEqualSubscriber2.prototype.emit = function(value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
  };
  SequenceEqualSubscriber2.prototype.nextB = function(value) {
    if (this._oneComplete && this._a.length === 0) {
      this.emit(false);
    } else {
      this._b.push(value);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype.completeB = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
  };
  return SequenceEqualSubscriber2;
}(Subscriber);
var SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SequenceEqualCompareToSubscriber2, _super);
  function SequenceEqualCompareToSubscriber2(destination, parent) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent;
    return _this;
  }
  SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
    this.parent.nextB(value);
  };
  SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
    this.parent.error(err);
    this.unsubscribe();
  };
  SequenceEqualCompareToSubscriber2.prototype._complete = function() {
    this.parent.completeB();
    this.unsubscribe();
  };
  return SequenceEqualCompareToSubscriber2;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source) {
    return refCount()(multicast(shareSubjectFactory)(source));
  };
}
function shareReplay(configOrBufferSize, windowTime2, scheduler2) {
  var config2;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config2 = configOrBufferSize;
  } else {
    config2 = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime2,
      refCount: false,
      scheduler: scheduler2
    };
  }
  return function(source) {
    return source.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a2) {
  var _b = _a2.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a2.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a2.refCount, scheduler2 = _a2.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime2, scheduler2);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next: function(value) {
          subject.next(value);
        },
        error: function(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function() {
          isComplete = true;
          subscription = void 0;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
function single(predicate) {
  return function(source) {
    return source.lift(new SingleOperator(predicate, source));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function SingleOperator2(predicate, source) {
    this.predicate = predicate;
    this.source = source;
  }
  SingleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
  };
  return SingleOperator2;
}();
var SingleSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SingleSubscriber2, _super);
  function SingleSubscriber2(destination, predicate, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.seenValue = false;
    _this.index = 0;
    return _this;
  }
  SingleSubscriber2.prototype.applySingleValue = function(value) {
    if (this.seenValue) {
      this.destination.error("Sequence contains more than one element");
    } else {
      this.seenValue = true;
      this.singleValue = value;
    }
  };
  SingleSubscriber2.prototype._next = function(value) {
    var index2 = this.index++;
    if (this.predicate) {
      this.tryNext(value, index2);
    } else {
      this.applySingleValue(value);
    }
  };
  SingleSubscriber2.prototype.tryNext = function(value, index2) {
    try {
      if (this.predicate(value, index2, this.source)) {
        this.applySingleValue(value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  SingleSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    if (this.index > 0) {
      destination.next(this.seenValue ? this.singleValue : void 0);
      destination.complete();
    } else {
      destination.error(new EmptyError());
    }
  };
  return SingleSubscriber2;
}(Subscriber);
function skip(count2) {
  return function(source) {
    return source.lift(new SkipOperator(count2));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function SkipOperator2(total) {
    this.total = total;
  }
  SkipOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SkipSubscriber(subscriber, this.total));
  };
  return SkipOperator2;
}();
var SkipSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SkipSubscriber2, _super);
  function SkipSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  SkipSubscriber2.prototype._next = function(x2) {
    if (++this.count > this.total) {
      this.destination.next(x2);
    }
  };
  return SkipSubscriber2;
}(Subscriber);
function skipLast(count2) {
  return function(source) {
    return source.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function SkipLastOperator2(_skipCount) {
    this._skipCount = _skipCount;
    if (this._skipCount < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  SkipLastOperator2.prototype.call = function(subscriber, source) {
    if (this._skipCount === 0) {
      return source.subscribe(new Subscriber(subscriber));
    } else {
      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
    }
  };
  return SkipLastOperator2;
}();
var SkipLastSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SkipLastSubscriber2, _super);
  function SkipLastSubscriber2(destination, _skipCount) {
    var _this = _super.call(this, destination) || this;
    _this._skipCount = _skipCount;
    _this._count = 0;
    _this._ring = new Array(_skipCount);
    return _this;
  }
  SkipLastSubscriber2.prototype._next = function(value) {
    var skipCount = this._skipCount;
    var count2 = this._count++;
    if (count2 < skipCount) {
      this._ring[count2] = value;
    } else {
      var currentIndex = count2 % skipCount;
      var ring = this._ring;
      var oldValue = ring[currentIndex];
      ring[currentIndex] = value;
      this.destination.next(oldValue);
    }
  };
  return SkipLastSubscriber2;
}(Subscriber);
function skipUntil(notifier) {
  return function(source) {
    return source.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function SkipUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  SkipUntilOperator2.prototype.call = function(destination, source) {
    return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
  };
  return SkipUntilOperator2;
}();
var SkipUntilSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SkipUntilSubscriber2, _super);
  function SkipUntilSubscriber2(destination, notifier) {
    var _this = _super.call(this, destination) || this;
    _this.hasValue = false;
    var innerSubscriber = new SimpleInnerSubscriber(_this);
    _this.add(innerSubscriber);
    _this.innerSubscription = innerSubscriber;
    var innerSubscription = innerSubscribe(notifier, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      _this.add(innerSubscription);
      _this.innerSubscription = innerSubscription;
    }
    return _this;
  }
  SkipUntilSubscriber2.prototype._next = function(value) {
    if (this.hasValue) {
      _super.prototype._next.call(this, value);
    }
  };
  SkipUntilSubscriber2.prototype.notifyNext = function() {
    this.hasValue = true;
    if (this.innerSubscription) {
      this.innerSubscription.unsubscribe();
    }
  };
  SkipUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return SkipUntilSubscriber2;
}(SimpleOuterSubscriber);
function skipWhile(predicate) {
  return function(source) {
    return source.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function SkipWhileOperator2(predicate) {
    this.predicate = predicate;
  }
  SkipWhileOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
  };
  return SkipWhileOperator2;
}();
var SkipWhileSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SkipWhileSubscriber2, _super);
  function SkipWhileSubscriber2(destination, predicate) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.skipping = true;
    _this.index = 0;
    return _this;
  }
  SkipWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (this.skipping) {
      this.tryCallPredicate(value);
    }
    if (!this.skipping) {
      destination.next(value);
    }
  };
  SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
    try {
      var result = this.predicate(value, this.index++);
      this.skipping = Boolean(result);
    } catch (err) {
      this.destination.error(err);
    }
  };
  return SkipWhileSubscriber2;
}(Subscriber);
function startWith() {
  var array2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array2[_i] = arguments[_i];
  }
  var scheduler2 = array2[array2.length - 1];
  if (isScheduler(scheduler2)) {
    array2.pop();
    return function(source) {
      return concat$2(array2, source, scheduler2);
    };
  } else {
    return function(source) {
      return concat$2(array2, source);
    };
  }
}
var SubscribeOnObservable = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SubscribeOnObservable2, _super);
  function SubscribeOnObservable2(source, delayTime, scheduler2) {
    if (delayTime === void 0) {
      delayTime = 0;
    }
    if (scheduler2 === void 0) {
      scheduler2 = asap;
    }
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.delayTime = delayTime;
    _this.scheduler = scheduler2;
    if (!isNumeric(delayTime) || delayTime < 0) {
      _this.delayTime = 0;
    }
    if (!scheduler2 || typeof scheduler2.schedule !== "function") {
      _this.scheduler = asap;
    }
    return _this;
  }
  SubscribeOnObservable2.create = function(source, delay2, scheduler2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (scheduler2 === void 0) {
      scheduler2 = asap;
    }
    return new SubscribeOnObservable2(source, delay2, scheduler2);
  };
  SubscribeOnObservable2.dispatch = function(arg) {
    var source = arg.source, subscriber = arg.subscriber;
    return this.add(source.subscribe(subscriber));
  };
  SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
    var delay2 = this.delayTime;
    var source = this.source;
    var scheduler2 = this.scheduler;
    return scheduler2.schedule(SubscribeOnObservable2.dispatch, delay2, {
      source,
      subscriber
    });
  };
  return SubscribeOnObservable2;
}(Observable$1);
function subscribeOn(scheduler2, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function subscribeOnOperatorFunction(source) {
    return source.lift(new SubscribeOnOperator(scheduler2, delay2));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function SubscribeOnOperator2(scheduler2, delay2) {
    this.scheduler = scheduler2;
    this.delay = delay2;
  }
  SubscribeOnOperator2.prototype.call = function(subscriber, source) {
    return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
  };
  return SubscribeOnOperator2;
}();
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(switchMap(function(a3, i3) {
        return from(project(a3, i3)).pipe(map$2(function(b4, ii2) {
          return resultSelector(a3, b4, i3, ii2);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function SwitchMapOperator2(project) {
    this.project = project;
  }
  SwitchMapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  };
  return SwitchMapOperator2;
}();
var SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(SwitchMapSubscriber2, _super);
  function SwitchMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.index = 0;
    return _this;
  }
  SwitchMapSubscriber2.prototype._next = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (error) {
      this.destination.error(error);
      return;
    }
    this._innerSub(result);
  };
  SwitchMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscription = this.innerSubscription;
    if (innerSubscription) {
      innerSubscription.unsubscribe();
    }
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    this.innerSubscription = innerSubscribe(result, innerSubscriber);
    if (this.innerSubscription !== innerSubscriber) {
      destination.add(this.innerSubscription);
    }
  };
  SwitchMapSubscriber2.prototype._complete = function() {
    var innerSubscription = this.innerSubscription;
    if (!innerSubscription || innerSubscription.closed) {
      _super.prototype._complete.call(this);
    }
    this.unsubscribe();
  };
  SwitchMapSubscriber2.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  };
  SwitchMapSubscriber2.prototype.notifyComplete = function() {
    this.innerSubscription = void 0;
    if (this.isStopped) {
      _super.prototype._complete.call(this);
    }
  };
  SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  return SwitchMapSubscriber2;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity);
}
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
function takeUntil(notifier) {
  return function(source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function TakeUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  TakeUntilOperator2.prototype.call = function(subscriber, source) {
    var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source.subscribe(takeUntilSubscriber);
    }
    return takeUntilSubscriber;
  };
  return TakeUntilOperator2;
}();
var TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(TakeUntilSubscriber2, _super);
  function TakeUntilSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.seenValue = false;
    return _this;
  }
  TakeUntilSubscriber2.prototype.notifyNext = function() {
    this.seenValue = true;
    this.complete();
  };
  TakeUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return TakeUntilSubscriber2;
}(SimpleOuterSubscriber);
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function TakeWhileOperator2(predicate, inclusive) {
    this.predicate = predicate;
    this.inclusive = inclusive;
  }
  TakeWhileOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  };
  return TakeWhileOperator2;
}();
var TakeWhileSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(TakeWhileSubscriber2, _super);
  function TakeWhileSubscriber2(destination, predicate, inclusive) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.inclusive = inclusive;
    _this.index = 0;
    return _this;
  }
  TakeWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    var result;
    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }
    this.nextOrComplete(value, result);
  };
  TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
    var destination = this.destination;
    if (Boolean(predicateResult)) {
      destination.next(value);
    } else {
      if (this.inclusive) {
        destination.next(value);
      }
      destination.complete();
    }
  };
  return TakeWhileSubscriber2;
}(Subscriber);
function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error, complete));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function DoOperator2(nextOrObserver, error, complete) {
    this.nextOrObserver = nextOrObserver;
    this.error = error;
    this.complete = complete;
  }
  DoOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  };
  return DoOperator2;
}();
var TapSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(TapSubscriber2, _super);
  function TapSubscriber2(destination, observerOrNext, error, complete) {
    var _this = _super.call(this, destination) || this;
    _this._tapNext = noop$3;
    _this._tapError = noop$3;
    _this._tapComplete = noop$3;
    _this._tapError = error || noop$3;
    _this._tapComplete = complete || noop$3;
    if (isFunction(observerOrNext)) {
      _this._context = _this;
      _this._tapNext = observerOrNext;
    } else if (observerOrNext) {
      _this._context = observerOrNext;
      _this._tapNext = observerOrNext.next || noop$3;
      _this._tapError = observerOrNext.error || noop$3;
      _this._tapComplete = observerOrNext.complete || noop$3;
    }
    return _this;
  }
  TapSubscriber2.prototype._next = function(value) {
    try {
      this._tapNext.call(this._context, value);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(value);
  };
  TapSubscriber2.prototype._error = function(err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err2) {
      this.destination.error(err2);
      return;
    }
    this.destination.error(err);
  };
  TapSubscriber2.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    return this.destination.complete();
  };
  return TapSubscriber2;
}(Subscriber);
var defaultThrottleConfig = {
  leading: true,
  trailing: false
};
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function ThrottleOperator2(durationSelector, leading, trailing) {
    this.durationSelector = durationSelector;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
  };
  return ThrottleOperator2;
}();
var ThrottleSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ThrottleSubscriber2, _super);
  function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.durationSelector = durationSelector;
    _this._leading = _leading;
    _this._trailing = _trailing;
    _this._hasValue = false;
    return _this;
  }
  ThrottleSubscriber2.prototype._next = function(value) {
    this._hasValue = true;
    this._sendValue = value;
    if (!this._throttled) {
      if (this._leading) {
        this.send();
      } else {
        this.throttle(value);
      }
    }
  };
  ThrottleSubscriber2.prototype.send = function() {
    var _a2 = this, _hasValue = _a2._hasValue, _sendValue = _a2._sendValue;
    if (_hasValue) {
      this.destination.next(_sendValue);
      this.throttle(_sendValue);
    }
    this._hasValue = false;
    this._sendValue = void 0;
  };
  ThrottleSubscriber2.prototype.throttle = function(value) {
    var duration = this.tryDurationSelector(value);
    if (!!duration) {
      this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
    }
  };
  ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
    try {
      return this.durationSelector(value);
    } catch (err) {
      this.destination.error(err);
      return null;
    }
  };
  ThrottleSubscriber2.prototype.throttlingDone = function() {
    var _a2 = this, _throttled = _a2._throttled, _trailing = _a2._trailing;
    if (_throttled) {
      _throttled.unsubscribe();
    }
    this._throttled = void 0;
    if (_trailing) {
      this.send();
    }
  };
  ThrottleSubscriber2.prototype.notifyNext = function() {
    this.throttlingDone();
  };
  ThrottleSubscriber2.prototype.notifyComplete = function() {
    this.throttlingDone();
  };
  return ThrottleSubscriber2;
}(SimpleOuterSubscriber);
function throttleTime(duration, scheduler2, config2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleTimeOperator(duration, scheduler2, config2.leading, config2.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function ThrottleTimeOperator2(duration, scheduler2, leading, trailing) {
    this.duration = duration;
    this.scheduler = scheduler2;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
  };
  return ThrottleTimeOperator2;
}();
var ThrottleTimeSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(ThrottleTimeSubscriber2, _super);
  function ThrottleTimeSubscriber2(destination, duration, scheduler2, leading, trailing) {
    var _this = _super.call(this, destination) || this;
    _this.duration = duration;
    _this.scheduler = scheduler2;
    _this.leading = leading;
    _this.trailing = trailing;
    _this._hasTrailingValue = false;
    _this._trailingValue = null;
    return _this;
  }
  ThrottleTimeSubscriber2.prototype._next = function(value) {
    if (this.throttled) {
      if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    } else {
      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
      if (this.leading) {
        this.destination.next(value);
      } else if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    }
  };
  ThrottleTimeSubscriber2.prototype._complete = function() {
    if (this._hasTrailingValue) {
      this.destination.next(this._trailingValue);
      this.destination.complete();
    } else {
      this.destination.complete();
    }
  };
  ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
    var throttled = this.throttled;
    if (throttled) {
      if (this.trailing && this._hasTrailingValue) {
        this.destination.next(this._trailingValue);
        this._trailingValue = null;
        this._hasTrailingValue = false;
      }
      throttled.unsubscribe();
      this.remove(throttled);
      this.throttled = null;
    }
  };
  return ThrottleTimeSubscriber2;
}(Subscriber);
function dispatchNext(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
function timeInterval(scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return function(source) {
    return defer$1(function() {
      return source.pipe(scan(function(_a2, value) {
        var current = _a2.current;
        return { value, current: scheduler2.now(), last: current };
      }, { current: scheduler2.now(), value: void 0, last: void 0 }), map$2(function(_a2) {
        var current = _a2.current, last2 = _a2.last, value = _a2.value;
        return new TimeInterval(value, current - last2);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();
function timeoutWith(due, withObservable, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return function(source) {
    var absoluteTimeout = isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler2.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler2));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler2) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.withObservable = withObservable;
    this.scheduler = scheduler2;
  }
  TimeoutWithOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  };
  return TimeoutWithOperator2;
}();
var TimeoutWithSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(TimeoutWithSubscriber2, _super);
  function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.absoluteTimeout = absoluteTimeout;
    _this.waitFor = waitFor;
    _this.withObservable = withObservable;
    _this.scheduler = scheduler2;
    _this.scheduleTimeout();
    return _this;
  }
  TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
    var withObservable = subscriber.withObservable;
    subscriber._unsubscribeAndRecycle();
    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
  };
  TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
    var action = this.action;
    if (action) {
      this.action = action.schedule(this, this.waitFor);
    } else {
      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
    }
  };
  TimeoutWithSubscriber2.prototype._next = function(value) {
    if (!this.absoluteTimeout) {
      this.scheduleTimeout();
    }
    _super.prototype._next.call(this, value);
  };
  TimeoutWithSubscriber2.prototype._unsubscribe = function() {
    this.action = void 0;
    this.scheduler = null;
    this.withObservable = null;
  };
  return TimeoutWithSubscriber2;
}(SimpleOuterSubscriber);
function timeout(due, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler2);
}
function timestamp(scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return map$2(function(value) {
    return new Timestamp(value, scheduler2.now());
  });
}
var Timestamp = /* @__PURE__ */ function() {
  function Timestamp2(value, timestamp2) {
    this.value = value;
    this.timestamp = timestamp2;
  }
  return Timestamp2;
}();
function toArrayReducer(arr2, item, index2) {
  if (index2 === 0) {
    return [item];
  }
  arr2.push(item);
  return arr2;
}
function toArray$1() {
  return reduce$1(toArrayReducer, []);
}
function window$1(windowBoundaries) {
  return function windowOperatorFunction(source) {
    return source.lift(new WindowOperator$1(windowBoundaries));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function WindowOperator2(windowBoundaries) {
    this.windowBoundaries = windowBoundaries;
  }
  WindowOperator2.prototype.call = function(subscriber, source) {
    var windowSubscriber = new WindowSubscriber$1(subscriber);
    var sourceSubscription = source.subscribe(windowSubscriber);
    if (!sourceSubscription.closed) {
      windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
    }
    return sourceSubscription;
  };
  return WindowOperator2;
}();
var WindowSubscriber$1 = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.window = new Subject();
    destination.next(_this.window);
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function() {
    this.openWindow();
  };
  WindowSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  WindowSubscriber2.prototype.notifyComplete = function() {
    this._complete();
  };
  WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
  };
  WindowSubscriber2.prototype._unsubscribe = function() {
    this.window = null;
  };
  WindowSubscriber2.prototype.openWindow = function() {
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var destination = this.destination;
    var newWindow = this.window = new Subject();
    destination.next(newWindow);
  };
  return WindowSubscriber2;
}(SimpleOuterSubscriber);
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  return function windowCountOperatorFunction(source) {
    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function WindowCountOperator2(windowSize, startWindowEvery) {
    this.windowSize = windowSize;
    this.startWindowEvery = startWindowEvery;
  }
  WindowCountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
  };
  return WindowCountOperator2;
}();
var WindowCountSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(WindowCountSubscriber2, _super);
  function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowSize = windowSize;
    _this.startWindowEvery = startWindowEvery;
    _this.windows = [new Subject()];
    _this.count = 0;
    destination.next(_this.windows[0]);
    return _this;
  }
  WindowCountSubscriber2.prototype._next = function(value) {
    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
    var destination = this.destination;
    var windowSize = this.windowSize;
    var windows = this.windows;
    var len2 = windows.length;
    for (var i3 = 0; i3 < len2 && !this.closed; i3++) {
      windows[i3].next(value);
    }
    var c2 = this.count - windowSize + 1;
    if (c2 >= 0 && c2 % startWindowEvery === 0 && !this.closed) {
      windows.shift().complete();
    }
    if (++this.count % startWindowEvery === 0 && !this.closed) {
      var window_1 = new Subject();
      windows.push(window_1);
      destination.next(window_1);
    }
  };
  WindowCountSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().error(err);
      }
    }
    this.destination.error(err);
  };
  WindowCountSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().complete();
      }
    }
    this.destination.complete();
  };
  WindowCountSubscriber2.prototype._unsubscribe = function() {
    this.count = 0;
    this.windows = null;
  };
  return WindowCountSubscriber2;
}(Subscriber);
function windowTime(windowTimeSpan) {
  var scheduler2 = async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;
  if (isScheduler(arguments[3])) {
    scheduler2 = arguments[3];
  }
  if (isScheduler(arguments[2])) {
    scheduler2 = arguments[2];
  } else if (isNumeric(arguments[2])) {
    maxWindowSize = Number(arguments[2]);
  }
  if (isScheduler(arguments[1])) {
    scheduler2 = arguments[1];
  } else if (isNumeric(arguments[1])) {
    windowCreationInterval = Number(arguments[1]);
  }
  return function windowTimeOperatorFunction(source) {
    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler2));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler2) {
    this.windowTimeSpan = windowTimeSpan;
    this.windowCreationInterval = windowCreationInterval;
    this.maxWindowSize = maxWindowSize;
    this.scheduler = scheduler2;
  }
  WindowTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  };
  return WindowTimeOperator2;
}();
var CountedSubject = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(CountedSubject2, _super);
  function CountedSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._numberOfNextedValues = 0;
    return _this;
  }
  CountedSubject2.prototype.next = function(value) {
    this._numberOfNextedValues++;
    _super.prototype.next.call(this, value);
  };
  Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: true,
    configurable: true
  });
  return CountedSubject2;
}(Subject);
var WindowTimeSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(WindowTimeSubscriber2, _super);
  function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowTimeSpan = windowTimeSpan;
    _this.windowCreationInterval = windowCreationInterval;
    _this.maxWindowSize = maxWindowSize;
    _this.scheduler = scheduler2;
    _this.windows = [];
    var window2 = _this.openWindow();
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      var closeState = { subscriber: _this, window: window2, context: null };
      var creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler: scheduler2 };
      _this.add(scheduler2.schedule(dispatchWindowClose, windowTimeSpan, closeState));
      _this.add(scheduler2.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
    } else {
      var timeSpanOnlyState = { subscriber: _this, window: window2, windowTimeSpan };
      _this.add(scheduler2.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
    }
    return _this;
  }
  WindowTimeSubscriber2.prototype._next = function(value) {
    var windows = this.windows;
    var len2 = windows.length;
    for (var i3 = 0; i3 < len2; i3++) {
      var window_1 = windows[i3];
      if (!window_1.closed) {
        window_1.next(value);
        if (window_1.numberOfNextedValues >= this.maxWindowSize) {
          this.closeWindow(window_1);
        }
      }
    }
  };
  WindowTimeSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    while (windows.length > 0) {
      windows.shift().error(err);
    }
    this.destination.error(err);
  };
  WindowTimeSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    while (windows.length > 0) {
      var window_2 = windows.shift();
      if (!window_2.closed) {
        window_2.complete();
      }
    }
    this.destination.complete();
  };
  WindowTimeSubscriber2.prototype.openWindow = function() {
    var window2 = new CountedSubject();
    this.windows.push(window2);
    var destination = this.destination;
    destination.next(window2);
    return window2;
  };
  WindowTimeSubscriber2.prototype.closeWindow = function(window2) {
    window2.complete();
    var windows = this.windows;
    windows.splice(windows.indexOf(window2), 1);
  };
  return WindowTimeSubscriber2;
}(Subscriber);
function dispatchWindowTimeSpanOnly(state2) {
  var subscriber = state2.subscriber, windowTimeSpan = state2.windowTimeSpan, window2 = state2.window;
  if (window2) {
    subscriber.closeWindow(window2);
  }
  state2.window = subscriber.openWindow();
  this.schedule(state2, windowTimeSpan);
}
function dispatchWindowCreation(state2) {
  var windowTimeSpan = state2.windowTimeSpan, subscriber = state2.subscriber, scheduler2 = state2.scheduler, windowCreationInterval = state2.windowCreationInterval;
  var window2 = subscriber.openWindow();
  var action = this;
  var context = { action, subscription: null };
  var timeSpanState = { subscriber, window: window2, context };
  context.subscription = scheduler2.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context.subscription);
  action.schedule(state2, windowCreationInterval);
}
function dispatchWindowClose(state2) {
  var subscriber = state2.subscriber, window2 = state2.window, context = state2.context;
  if (context && context.action && context.subscription) {
    context.action.remove(context.subscription);
  }
  subscriber.closeWindow(window2);
}
function windowToggle(openings, closingSelector) {
  return function(source) {
    return source.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function WindowToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  WindowToggleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return WindowToggleOperator2;
}();
var WindowToggleSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(WindowToggleSubscriber2, _super);
  function WindowToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.openings = openings;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
    return _this;
  }
  WindowToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    if (contexts) {
      var len2 = contexts.length;
      for (var i3 = 0; i3 < len2; i3++) {
        contexts[i3].window.next(value);
      }
    }
  };
  WindowToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len2 = contexts.length;
      var index2 = -1;
      while (++index2 < len2) {
        var context_1 = contexts[index2];
        context_1.window.error(err);
        context_1.subscription.unsubscribe();
      }
    }
    _super.prototype._error.call(this, err);
  };
  WindowToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len2 = contexts.length;
      var index2 = -1;
      while (++index2 < len2) {
        var context_2 = contexts[index2];
        context_2.window.complete();
        context_2.subscription.unsubscribe();
      }
    }
    _super.prototype._complete.call(this);
  };
  WindowToggleSubscriber2.prototype._unsubscribe = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len2 = contexts.length;
      var index2 = -1;
      while (++index2 < len2) {
        var context_3 = contexts[index2];
        context_3.window.unsubscribe();
        context_3.subscription.unsubscribe();
      }
    }
  };
  WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (outerValue === this.openings) {
      var closingNotifier = void 0;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector(innerValue);
      } catch (e2) {
        return this.error(e2);
      }
      var window_1 = new Subject();
      var subscription = new Subscription$1();
      var context_4 = { window: window_1, subscription };
      this.contexts.push(context_4);
      var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
      if (innerSubscription.closed) {
        this.closeWindow(this.contexts.length - 1);
      } else {
        innerSubscription.context = context_4;
        subscription.add(innerSubscription);
      }
      this.destination.next(window_1);
    } else {
      this.closeWindow(this.contexts.indexOf(outerValue));
    }
  };
  WindowToggleSubscriber2.prototype.notifyError = function(err) {
    this.error(err);
  };
  WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
    if (inner !== this.openSubscription) {
      this.closeWindow(this.contexts.indexOf(inner.context));
    }
  };
  WindowToggleSubscriber2.prototype.closeWindow = function(index2) {
    if (index2 === -1) {
      return;
    }
    var contexts = this.contexts;
    var context = contexts[index2];
    var window2 = context.window, subscription = context.subscription;
    contexts.splice(index2, 1);
    window2.complete();
    subscription.unsubscribe();
  };
  return WindowToggleSubscriber2;
}(OuterSubscriber);
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source) {
    return source.lift(new WindowOperator(closingSelector));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function WindowOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  WindowOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
  };
  return WindowOperator2;
}();
var WindowSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.closingSelector = closingSelector;
    _this.openWindow();
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  WindowSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype.unsubscribeClosingNotification = function() {
    if (this.closingNotification) {
      this.closingNotification.unsubscribe();
    }
  };
  WindowSubscriber2.prototype.openWindow = function(innerSub) {
    if (innerSub === void 0) {
      innerSub = null;
    }
    if (innerSub) {
      this.remove(innerSub);
      innerSub.unsubscribe();
    }
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var window2 = this.window = new Subject();
    this.destination.next(window2);
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (e2) {
      this.destination.error(e2);
      this.window.error(e2);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
  };
  return WindowSubscriber2;
}(OuterSubscriber);
function withLatestFrom() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(source) {
    var project;
    if (typeof args[args.length - 1] === "function") {
      project = args.pop();
    }
    var observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function WithLatestFromOperator2(observables, project) {
    this.observables = observables;
    this.project = project;
  }
  WithLatestFromOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  };
  return WithLatestFromOperator2;
}();
var WithLatestFromSubscriber = /* @__PURE__ */ function(_super) {
  tslibExports$1.__extends(WithLatestFromSubscriber2, _super);
  function WithLatestFromSubscriber2(destination, observables, project) {
    var _this = _super.call(this, destination) || this;
    _this.observables = observables;
    _this.project = project;
    _this.toRespond = [];
    var len2 = observables.length;
    _this.values = new Array(len2);
    for (var i3 = 0; i3 < len2; i3++) {
      _this.toRespond.push(i3);
    }
    for (var i3 = 0; i3 < len2; i3++) {
      var observable2 = observables[i3];
      _this.add(subscribeToResult(_this, observable2, void 0, i3));
    }
    return _this;
  }
  WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    this.values[outerIndex] = innerValue;
    var toRespond = this.toRespond;
    if (toRespond.length > 0) {
      var found = toRespond.indexOf(outerIndex);
      if (found !== -1) {
        toRespond.splice(found, 1);
      }
    }
  };
  WithLatestFromSubscriber2.prototype.notifyComplete = function() {
  };
  WithLatestFromSubscriber2.prototype._next = function(value) {
    if (this.toRespond.length === 0) {
      var args = [value].concat(this.values);
      if (this.project) {
        this._tryProject(args);
      } else {
        this.destination.next(args);
      }
    }
  };
  WithLatestFromSubscriber2.prototype._tryProject = function(args) {
    var result;
    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return WithLatestFromSubscriber2;
}(OuterSubscriber);
function zip() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function zipOperatorFunction(source) {
    return source.lift.call(zip$1.apply(void 0, [source].concat(observables)));
  };
}
function zipAll(project) {
  return function(source) {
    return source.lift(new ZipOperator(project));
  };
}
const operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audit,
  auditTime,
  buffer: buffer$3,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat: concat$1,
  concatAll,
  concatMap,
  concatMapTo,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every,
  exhaust,
  exhaustMap,
  expand,
  filter: filter$2,
  finalize,
  find,
  findIndex,
  first,
  flatMap,
  groupBy,
  ignoreElements,
  isEmpty: isEmpty$1,
  last: last$2,
  map: map$2,
  mapTo,
  materialize,
  max,
  merge: merge$1,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce: reduce$1,
  refCount,
  repeat,
  repeatWhen,
  retry: retry$6,
  retryWhen,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take: take$2,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp,
  toArray: toArray$1,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
}, Symbol.toStringTag, { value: "Module" }));
const require$$2$3 = /* @__PURE__ */ getAugmentedNamespace(operators);
var WalletSDKConnection$2 = {};
var ClientMessage$1 = {};
Object.defineProperty(ClientMessage$1, "__esModule", { value: true });
var ClientMessagePublishEvent_1 = ClientMessage$1.ClientMessagePublishEvent = ClientMessageSetSessionConfig_1 = ClientMessage$1.ClientMessageSetSessionConfig = ClientMessageGetSessionConfig_1 = ClientMessage$1.ClientMessageGetSessionConfig = ClientMessageIsLinked_1 = ClientMessage$1.ClientMessageIsLinked = ClientMessageHostSession_1 = ClientMessage$1.ClientMessageHostSession = void 0;
function ClientMessageHostSession(params) {
  return Object.assign({ type: "HostSession" }, params);
}
var ClientMessageHostSession_1 = ClientMessage$1.ClientMessageHostSession = ClientMessageHostSession;
function ClientMessageIsLinked(params) {
  return Object.assign({ type: "IsLinked" }, params);
}
var ClientMessageIsLinked_1 = ClientMessage$1.ClientMessageIsLinked = ClientMessageIsLinked;
function ClientMessageGetSessionConfig(params) {
  return Object.assign({ type: "GetSessionConfig" }, params);
}
var ClientMessageGetSessionConfig_1 = ClientMessage$1.ClientMessageGetSessionConfig = ClientMessageGetSessionConfig;
function ClientMessageSetSessionConfig(params) {
  return Object.assign({ type: "SetSessionConfig" }, params);
}
var ClientMessageSetSessionConfig_1 = ClientMessage$1.ClientMessageSetSessionConfig = ClientMessageSetSessionConfig;
function ClientMessagePublishEvent(params) {
  return Object.assign({ type: "PublishEvent" }, params);
}
ClientMessagePublishEvent_1 = ClientMessage$1.ClientMessagePublishEvent = ClientMessagePublishEvent;
const ClientMessage = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get ClientMessageGetSessionConfig() {
    return ClientMessageGetSessionConfig_1;
  },
  get ClientMessageHostSession() {
    return ClientMessageHostSession_1;
  },
  get ClientMessageIsLinked() {
    return ClientMessageIsLinked_1;
  },
  get ClientMessagePublishEvent() {
    return ClientMessagePublishEvent_1;
  },
  get ClientMessageSetSessionConfig() {
    return ClientMessageSetSessionConfig_1;
  },
  default: ClientMessage$1
}, [ClientMessage$1]);
const require$$4$2 = /* @__PURE__ */ getAugmentedNamespace(ClientMessage);
var RxWebSocket$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.RxWebSocket = exports2.ConnectionState = void 0;
  const rxjs_12 = require$$1$a;
  const operators_12 = require$$2$3;
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
    ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
    ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
  })(ConnectionState = exports2.ConnectionState || (exports2.ConnectionState = {}));
  class RxWebSocket2 {
    /**
     * Constructor
     * @param url WebSocket server URL
     * @param [WebSocketClass] Custom WebSocket implementation
     */
    constructor(url, WebSocketClass = WebSocket) {
      this.WebSocketClass = WebSocketClass;
      this.webSocket = null;
      this.connectionStateSubject = new rxjs_12.BehaviorSubject(ConnectionState.DISCONNECTED);
      this.incomingDataSubject = new rxjs_12.Subject();
      this.url = url.replace(/^http/, "ws");
    }
    /**
     * Make a websocket connection
     * @returns an Observable that completes when connected
     */
    connect() {
      if (this.webSocket) {
        return (0, rxjs_12.throwError)(new Error("webSocket object is not null"));
      }
      return new rxjs_12.Observable((obs) => {
        let webSocket;
        try {
          this.webSocket = webSocket = new this.WebSocketClass(this.url);
        } catch (err) {
          obs.error(err);
          return;
        }
        this.connectionStateSubject.next(ConnectionState.CONNECTING);
        webSocket.onclose = (evt) => {
          this.clearWebSocket();
          obs.error(new Error(`websocket error ${evt.code}: ${evt.reason}`));
          this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
        };
        webSocket.onopen = (_3) => {
          obs.next();
          obs.complete();
          this.connectionStateSubject.next(ConnectionState.CONNECTED);
        };
        webSocket.onmessage = (evt) => {
          this.incomingDataSubject.next(evt.data);
        };
      }).pipe((0, operators_12.take)(1));
    }
    /**
     * Disconnect from server
     */
    disconnect() {
      const { webSocket } = this;
      if (!webSocket) {
        return;
      }
      this.clearWebSocket();
      this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
      try {
        webSocket.close();
      } catch (_a2) {
      }
    }
    /**
     * Emit current connection state and subsequent changes
     * @returns an Observable for the connection state
     */
    get connectionState$() {
      return this.connectionStateSubject.asObservable();
    }
    /**
     * Emit incoming data from server
     * @returns an Observable for the data received
     */
    get incomingData$() {
      return this.incomingDataSubject.asObservable();
    }
    /**
     * Emit incoming JSON data from server. non-JSON data are ignored
     * @returns an Observable for parsed JSON data
     */
    get incomingJSONData$() {
      return this.incomingData$.pipe((0, operators_12.flatMap)((m2) => {
        let j2;
        try {
          j2 = JSON.parse(m2);
        } catch (err) {
          return (0, rxjs_12.empty)();
        }
        return (0, rxjs_12.of)(j2);
      }));
    }
    /**
     * Send data to server
     * @param data text to send
     */
    sendData(data2) {
      const { webSocket } = this;
      if (!webSocket) {
        throw new Error("websocket is not connected");
      }
      webSocket.send(data2);
    }
    clearWebSocket() {
      const { webSocket } = this;
      if (!webSocket) {
        return;
      }
      this.webSocket = null;
      webSocket.onclose = null;
      webSocket.onerror = null;
      webSocket.onmessage = null;
      webSocket.onopen = null;
    }
  }
  exports2.RxWebSocket = RxWebSocket2;
})(RxWebSocket$2);
const RxWebSocket = /* @__PURE__ */ getDefaultExportFromCjs(RxWebSocket$2);
const RxWebSocket$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: RxWebSocket
}, [RxWebSocket$2]);
const require$$6$3 = /* @__PURE__ */ getAugmentedNamespace(RxWebSocket$1);
var ServerMessage$1 = {};
Object.defineProperty(ServerMessage$1, "__esModule", { value: true });
var isServerMessageFail_1 = ServerMessage$1.isServerMessageFail = void 0;
function isServerMessageFail(msg) {
  return msg && msg.type === "Fail" && typeof msg.id === "number" && typeof msg.sessionId === "string" && typeof msg.error === "string";
}
isServerMessageFail_1 = ServerMessage$1.isServerMessageFail = isServerMessageFail;
const ServerMessage = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ServerMessage$1,
  get isServerMessageFail() {
    return isServerMessageFail_1;
  }
}, [ServerMessage$1]);
const require$$7 = /* @__PURE__ */ getAugmentedNamespace(ServerMessage);
Object.defineProperty(WalletSDKConnection$2, "__esModule", { value: true });
var WalletSDKConnection_2 = WalletSDKConnection$2.WalletSDKConnection = void 0;
const rxjs_1$1 = require$$1$a;
const operators_1$1 = require$$2$3;
const Session_1$1 = require$$9$4;
const types_1$1 = require$$6$a;
const ClientMessage_1 = require$$4$2;
const DiagnosticLogger_1$1 = require$$3$g;
const RxWebSocket_1 = require$$6$3;
const ServerMessage_1 = require$$7;
const HEARTBEAT_INTERVAL = 1e4;
const REQUEST_TIMEOUT = 6e4;
class WalletSDKConnection {
  /**
   * Constructor
   * @param sessionId Session ID
   * @param sessionKey Session Key
   * @param linkAPIUrl Coinbase Wallet link server URL
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor(sessionId, sessionKey, linkAPIUrl, diagnostic, WebSocketClass = WebSocket) {
    this.sessionId = sessionId;
    this.sessionKey = sessionKey;
    this.diagnostic = diagnostic;
    this.subscriptions = new rxjs_1$1.Subscription();
    this.destroyed = false;
    this.lastHeartbeatResponse = 0;
    this.nextReqId = (0, types_1$1.IntNumber)(1);
    this.connectedSubject = new rxjs_1$1.BehaviorSubject(false);
    this.linkedSubject = new rxjs_1$1.BehaviorSubject(false);
    this.sessionConfigSubject = new rxjs_1$1.ReplaySubject(1);
    const ws2 = new RxWebSocket_1.RxWebSocket(linkAPIUrl + "/rpc", WebSocketClass);
    this.ws = ws2;
    this.subscriptions.add(ws2.connectionState$.pipe(
      (0, operators_1$1.tap)((state2) => {
        var _a2;
        return (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$1.EVENTS.CONNECTED_STATE_CHANGE, {
          state: state2,
          sessionIdHash: Session_1$1.Session.hash(sessionId)
        });
      }),
      // ignore initial DISCONNECTED state
      (0, operators_1$1.skip)(1),
      // if DISCONNECTED and not destroyed
      (0, operators_1$1.filter)((cs2) => cs2 === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed),
      // wait 5 seconds
      (0, operators_1$1.delay)(5e3),
      // check whether it's destroyed again
      (0, operators_1$1.filter)((_3) => !this.destroyed),
      // reconnect
      (0, operators_1$1.flatMap)((_3) => ws2.connect()),
      (0, operators_1$1.retry)()
    ).subscribe());
    this.subscriptions.add(ws2.connectionState$.pipe(
      // ignore initial DISCONNECTED and CONNECTING states
      (0, operators_1$1.skip)(2),
      (0, operators_1$1.switchMap)((cs2) => (0, rxjs_1$1.iif)(
        () => cs2 === RxWebSocket_1.ConnectionState.CONNECTED,
        // if CONNECTED, authenticate, and then check link status
        this.authenticate().pipe((0, operators_1$1.tap)((_3) => this.sendIsLinked()), (0, operators_1$1.tap)((_3) => this.sendGetSessionConfig()), (0, operators_1$1.map)((_3) => true)),
        // if not CONNECTED, emit false immediately
        (0, rxjs_1$1.of)(false)
      )),
      (0, operators_1$1.distinctUntilChanged)(),
      (0, operators_1$1.catchError)((_3) => (0, rxjs_1$1.of)(false))
    ).subscribe((connected) => this.connectedSubject.next(connected)));
    this.subscriptions.add(ws2.connectionState$.pipe(
      // ignore initial DISCONNECTED state
      (0, operators_1$1.skip)(1),
      (0, operators_1$1.switchMap)((cs2) => (0, rxjs_1$1.iif)(
        () => cs2 === RxWebSocket_1.ConnectionState.CONNECTED,
        // if CONNECTED, start the heartbeat timer
        (0, rxjs_1$1.timer)(0, HEARTBEAT_INTERVAL)
      ))
    ).subscribe((i3) => (
      // first timer event updates lastHeartbeat timestamp
      // subsequent calls send heartbeat message
      i3 === 0 ? this.updateLastHeartbeat() : this.heartbeat()
    )));
    this.subscriptions.add(ws2.incomingData$.pipe((0, operators_1$1.filter)((m2) => m2 === "h")).subscribe((_3) => this.updateLastHeartbeat()));
    this.subscriptions.add(ws2.incomingJSONData$.pipe((0, operators_1$1.filter)((m2) => ["IsLinkedOK", "Linked"].includes(m2.type))).subscribe((m2) => {
      var _a2;
      const msg = m2;
      (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$1.EVENTS.LINKED, {
        sessionIdHash: Session_1$1.Session.hash(sessionId),
        linked: msg.linked,
        type: m2.type,
        onlineGuests: msg.onlineGuests
      });
      this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);
    }));
    this.subscriptions.add(ws2.incomingJSONData$.pipe((0, operators_1$1.filter)((m2) => ["GetSessionConfigOK", "SessionConfigUpdated"].includes(m2.type))).subscribe((m2) => {
      var _a2;
      const msg = m2;
      (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$1.EVENTS.SESSION_CONFIG_RECEIVED, {
        sessionIdHash: Session_1$1.Session.hash(sessionId),
        metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : void 0
      });
      this.sessionConfigSubject.next({
        webhookId: msg.webhookId,
        webhookUrl: msg.webhookUrl,
        metadata: msg.metadata
      });
    }));
  }
  /**
   * Make a connection to the server
   */
  connect() {
    var _a2;
    if (this.destroyed) {
      throw new Error("instance is destroyed");
    }
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$1.EVENTS.STARTED_CONNECTING, {
      sessionIdHash: Session_1$1.Session.hash(this.sessionId)
    });
    this.ws.connect().subscribe();
  }
  /**
   * Terminate connection, and mark as destroyed. To reconnect, create a new
   * instance of WalletSDKConnection
   */
  destroy() {
    var _a2;
    this.subscriptions.unsubscribe();
    this.ws.disconnect();
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$1.EVENTS.DISCONNECTED, {
      sessionIdHash: Session_1$1.Session.hash(this.sessionId)
    });
    this.destroyed = true;
  }
  get isDestroyed() {
    return this.destroyed;
  }
  /**
   * Emit true if connected and authenticated, else false
   * @returns an Observable
   */
  get connected$() {
    return this.connectedSubject.asObservable();
  }
  /**
   * Emit once connected
   * @returns an Observable
   */
  get onceConnected$() {
    return this.connected$.pipe((0, operators_1$1.filter)((v4) => v4), (0, operators_1$1.take)(1), (0, operators_1$1.map)(() => void 0));
  }
  /**
   * Emit true if linked (a guest has joined before)
   * @returns an Observable
   */
  get linked$() {
    return this.linkedSubject.asObservable();
  }
  /**
   * Emit once when linked
   * @returns an Observable
   */
  get onceLinked$() {
    return this.linked$.pipe((0, operators_1$1.filter)((v4) => v4), (0, operators_1$1.take)(1), (0, operators_1$1.map)(() => void 0));
  }
  /**
   * Emit current session config if available, and subsequent updates
   * @returns an Observable for the session config
   */
  get sessionConfig$() {
    return this.sessionConfigSubject.asObservable();
  }
  /**
   * Emit incoming Event messages
   * @returns an Observable for the messages
   */
  get incomingEvent$() {
    return this.ws.incomingJSONData$.pipe((0, operators_1$1.filter)((m2) => {
      if (m2.type !== "Event") {
        return false;
      }
      const sme = m2;
      return typeof sme.sessionId === "string" && typeof sme.eventId === "string" && typeof sme.event === "string" && typeof sme.data === "string";
    }), (0, operators_1$1.map)((m2) => m2));
  }
  /**
   * Set session metadata in SessionConfig object
   * @param key
   * @param value
   * @returns an Observable that completes when successful
   */
  setSessionMetadata(key2, value) {
    const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({
      id: (0, types_1$1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      metadata: { [key2]: value }
    });
    return this.onceConnected$.pipe((0, operators_1$1.flatMap)((_3) => this.makeRequest(message)), (0, operators_1$1.map)((res) => {
      if ((0, ServerMessage_1.isServerMessageFail)(res)) {
        throw new Error(res.error || "failed to set session metadata");
      }
    }));
  }
  /**
   * Publish an event and emit event ID when successful
   * @param event event name
   * @param data event data
   * @param callWebhook whether the webhook should be invoked
   * @returns an Observable that emits event ID when successful
   */
  publishEvent(event, data2, callWebhook = false) {
    const message = (0, ClientMessage_1.ClientMessagePublishEvent)({
      id: (0, types_1$1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      event,
      data: data2,
      callWebhook
    });
    return this.onceLinked$.pipe((0, operators_1$1.flatMap)((_3) => this.makeRequest(message)), (0, operators_1$1.map)((res) => {
      if ((0, ServerMessage_1.isServerMessageFail)(res)) {
        throw new Error(res.error || "failed to publish event");
      }
      return res.eventId;
    }));
  }
  sendData(message) {
    this.ws.sendData(JSON.stringify(message));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
      this.ws.disconnect();
      return;
    }
    try {
      this.ws.sendData("h");
    } catch (_a2) {
    }
  }
  makeRequest(message, timeout2 = REQUEST_TIMEOUT) {
    const reqId = message.id;
    try {
      this.sendData(message);
    } catch (err) {
      return (0, rxjs_1$1.throwError)(err);
    }
    return this.ws.incomingJSONData$.pipe((0, operators_1$1.timeoutWith)(timeout2, (0, rxjs_1$1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1$1.filter)((m2) => m2.id === reqId), (0, operators_1$1.take)(1));
  }
  authenticate() {
    const msg = (0, ClientMessage_1.ClientMessageHostSession)({
      id: (0, types_1$1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      sessionKey: this.sessionKey
    });
    return this.makeRequest(msg).pipe((0, operators_1$1.map)((res) => {
      if ((0, ServerMessage_1.isServerMessageFail)(res)) {
        throw new Error(res.error || "failed to authentcate");
      }
    }));
  }
  sendIsLinked() {
    const msg = (0, ClientMessage_1.ClientMessageIsLinked)({
      id: (0, types_1$1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId
    });
    this.sendData(msg);
  }
  sendGetSessionConfig() {
    const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({
      id: (0, types_1$1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId
    });
    this.sendData(msg);
  }
}
WalletSDKConnection_2 = WalletSDKConnection$2.WalletSDKConnection = WalletSDKConnection;
const WalletSDKConnection$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get WalletSDKConnection() {
    return WalletSDKConnection_2;
  },
  default: WalletSDKConnection$2
}, [WalletSDKConnection$2]);
const require$$4$1 = /* @__PURE__ */ getAugmentedNamespace(WalletSDKConnection$1);
var aes256gcm$2 = {};
Object.defineProperty(aes256gcm$2, "__esModule", { value: true });
var decrypt_1 = aes256gcm$2.decrypt = encrypt_1 = aes256gcm$2.encrypt = void 0;
const util_1$3 = require$$7$4;
async function encrypt(plainText, secret) {
  if (secret.length !== 64)
    throw Error(`secret must be 256 bits`);
  const ivBytes = crypto.getRandomValues(new Uint8Array(12));
  const secretKey = await crypto.subtle.importKey("raw", (0, util_1$3.hexStringToUint8Array)(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
  const enc = new TextEncoder();
  const encryptedResult = await window.crypto.subtle.encrypt({
    name: "AES-GCM",
    iv: ivBytes
  }, secretKey, enc.encode(plainText));
  const tagLength = 16;
  const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
  const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
  const authTagBytes = new Uint8Array(authTag);
  const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
  const concatted = new Uint8Array([
    ...ivBytes,
    ...authTagBytes,
    ...encryptedPlaintextBytes
  ]);
  return (0, util_1$3.uint8ArrayToHex)(concatted);
}
var encrypt_1 = aes256gcm$2.encrypt = encrypt;
function decrypt(cipherText, secret) {
  if (secret.length !== 64)
    throw Error(`secret must be 256 bits`);
  return new Promise((resolve, reject) => {
    void async function() {
      const secretKey = await crypto.subtle.importKey("raw", (0, util_1$3.hexStringToUint8Array)(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
      const encrypted = (0, util_1$3.hexStringToUint8Array)(cipherText);
      const ivBytes = encrypted.slice(0, 12);
      const authTagBytes = encrypted.slice(12, 28);
      const encryptedPlaintextBytes = encrypted.slice(28);
      const concattedBytes = new Uint8Array([
        ...encryptedPlaintextBytes,
        ...authTagBytes
      ]);
      const algo = {
        name: "AES-GCM",
        iv: new Uint8Array(ivBytes)
      };
      try {
        const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
        const decoder = new TextDecoder();
        resolve(decoder.decode(decrypted));
      } catch (err) {
        reject(err);
      }
    }();
  });
}
decrypt_1 = aes256gcm$2.decrypt = decrypt;
const aes256gcm$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get decrypt() {
    return decrypt_1;
  },
  default: aes256gcm$2,
  get encrypt() {
    return encrypt_1;
  }
}, [aes256gcm$2]);
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(aes256gcm$1);
var Web3RequestCanceledMessage$2 = {};
var RelayMessage$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.RelayMessageType = void 0;
  (function(RelayMessageType) {
    RelayMessageType["SESSION_ID_REQUEST"] = "SESSION_ID_REQUEST";
    RelayMessageType["SESSION_ID_RESPONSE"] = "SESSION_ID_RESPONSE";
    RelayMessageType["LINKED"] = "LINKED";
    RelayMessageType["UNLINKED"] = "UNLINKED";
    RelayMessageType["WEB3_REQUEST"] = "WEB3_REQUEST";
    RelayMessageType["WEB3_REQUEST_CANCELED"] = "WEB3_REQUEST_CANCELED";
    RelayMessageType["WEB3_RESPONSE"] = "WEB3_RESPONSE";
  })(exports2.RelayMessageType || (exports2.RelayMessageType = {}));
})(RelayMessage$2);
const RelayMessage = /* @__PURE__ */ getDefaultExportFromCjs(RelayMessage$2);
const RelayMessage$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: RelayMessage
}, [RelayMessage$2]);
const require$$0$m = /* @__PURE__ */ getAugmentedNamespace(RelayMessage$1);
Object.defineProperty(Web3RequestCanceledMessage$2, "__esModule", { value: true });
var Web3RequestCanceledMessage_2 = Web3RequestCanceledMessage$2.Web3RequestCanceledMessage = void 0;
const RelayMessage_1$2 = require$$0$m;
function Web3RequestCanceledMessage(id2) {
  return { type: RelayMessage_1$2.RelayMessageType.WEB3_REQUEST_CANCELED, id: id2 };
}
Web3RequestCanceledMessage_2 = Web3RequestCanceledMessage$2.Web3RequestCanceledMessage = Web3RequestCanceledMessage;
const Web3RequestCanceledMessage$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get Web3RequestCanceledMessage() {
    return Web3RequestCanceledMessage_2;
  },
  default: Web3RequestCanceledMessage$2
}, [Web3RequestCanceledMessage$2]);
const require$$12 = /* @__PURE__ */ getAugmentedNamespace(Web3RequestCanceledMessage$1);
var Web3RequestMessage$2 = {};
Object.defineProperty(Web3RequestMessage$2, "__esModule", { value: true });
var Web3RequestMessage_2 = Web3RequestMessage$2.Web3RequestMessage = void 0;
const RelayMessage_1$1 = require$$0$m;
function Web3RequestMessage(params) {
  return Object.assign({ type: RelayMessage_1$1.RelayMessageType.WEB3_REQUEST }, params);
}
Web3RequestMessage_2 = Web3RequestMessage$2.Web3RequestMessage = Web3RequestMessage;
const Web3RequestMessage$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get Web3RequestMessage() {
    return Web3RequestMessage_2;
  },
  default: Web3RequestMessage$2
}, [Web3RequestMessage$2]);
const require$$13 = /* @__PURE__ */ getAugmentedNamespace(Web3RequestMessage$1);
var Web3ResponseMessage$2 = {};
Object.defineProperty(Web3ResponseMessage$2, "__esModule", { value: true });
var isWeb3ResponseMessage_1 = Web3ResponseMessage$2.isWeb3ResponseMessage = Web3ResponseMessage_2 = Web3ResponseMessage$2.Web3ResponseMessage = void 0;
const RelayMessage_1 = require$$0$m;
function Web3ResponseMessage(params) {
  return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_RESPONSE }, params);
}
var Web3ResponseMessage_2 = Web3ResponseMessage$2.Web3ResponseMessage = Web3ResponseMessage;
function isWeb3ResponseMessage(msg) {
  return msg && msg.type === RelayMessage_1.RelayMessageType.WEB3_RESPONSE;
}
isWeb3ResponseMessage_1 = Web3ResponseMessage$2.isWeb3ResponseMessage = isWeb3ResponseMessage;
const Web3ResponseMessage$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get Web3ResponseMessage() {
    return Web3ResponseMessage_2;
  },
  default: Web3ResponseMessage$2,
  get isWeb3ResponseMessage() {
    return isWeb3ResponseMessage_1;
  }
}, [Web3ResponseMessage$2]);
const require$$15 = /* @__PURE__ */ getAugmentedNamespace(Web3ResponseMessage$1);
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
  if (k22 === void 0)
    k22 = k3;
  Object.defineProperty(o2, k22, { enumerable: true, get: function() {
    return m2[k3];
  } });
} : function(o2, m2, k3, k22) {
  if (k22 === void 0)
    k22 = k3;
  o2[k22] = m2[k3];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v4) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v4 });
} : function(o2, v4) {
  o2["default"] = v4;
});
var __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k3 in mod2)
      if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k3))
        __createBinding(result, mod2, k3);
  }
  __setModuleDefault(result, mod2);
  return result;
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(WalletSDKRelay$2, "__esModule", { value: true });
var WalletSDKRelay_2 = WalletSDKRelay$2.WalletSDKRelay = void 0;
const bind_decorator_1 = __importDefault(require$$0$n);
const rxjs_1 = require$$1$a;
const operators_1 = require$$2$3;
const DiagnosticLogger_1 = require$$3$g;
const WalletSDKConnection_1 = require$$4$1;
const errors_1 = require$$5$c;
const types_1 = require$$6$a;
const util_1$2 = require$$7$4;
const aes256gcm = __importStar(require$$8);
const Session_1 = require$$9$4;
const WalletSDKRelayAbstract_1 = require$$10$4;
const Web3Method_1 = require$$11$4;
const Web3RequestCanceledMessage_1 = require$$12;
const Web3RequestMessage_1 = require$$13;
const Web3Response_1 = require$$14$2;
const Web3ResponseMessage_1 = require$$15;
class WalletSDKRelay extends WalletSDKRelayAbstract_1.WalletSDKRelayAbstract {
  constructor(options) {
    var _a2;
    super();
    this.accountsCallback = null;
    this.chainCallback = null;
    this.dappDefaultChainSubject = new rxjs_1.BehaviorSubject(1);
    this.dappDefaultChain = 1;
    this.appName = "";
    this.appLogoUrl = null;
    this.subscriptions = new rxjs_1.Subscription();
    this.linkAPIUrl = options.linkAPIUrl;
    this.storage = options.storage;
    this.options = options;
    const { session, ui: ui2, connection } = this.subscribe();
    this._session = session;
    this.connection = connection;
    this.relayEventManager = options.relayEventManager;
    if (options.diagnosticLogger && options.eventListener) {
      throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
    }
    if (options.eventListener) {
      this.diagnostic = {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        log: options.eventListener.onEvent
      };
    } else {
      this.diagnostic = options.diagnosticLogger;
    }
    this._reloadOnDisconnect = (_a2 = options.reloadOnDisconnect) !== null && _a2 !== void 0 ? _a2 : true;
    this.ui = ui2;
  }
  subscribe() {
    this.subscriptions.add(this.dappDefaultChainSubject.subscribe((chainId) => {
      if (this.dappDefaultChain !== chainId) {
        this.dappDefaultChain = chainId;
      }
    }));
    const session = Session_1.Session.load(this.storage) || new Session_1.Session(this.storage).save();
    const connection = new WalletSDKConnection_1.WalletSDKConnection(session.id, session.key, this.linkAPIUrl, this.diagnostic);
    this.subscriptions.add(connection.sessionConfig$.subscribe({
      next: (sessionConfig) => {
        this.onSessionConfigChanged(sessionConfig);
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "error while invoking session config callback"
        });
      }
    }));
    this.subscriptions.add(connection.incomingEvent$.pipe((0, operators_1.filter)((m2) => m2.event === "Web3Response")).subscribe({ next: this.handleIncomingEvent }));
    this.subscriptions.add(connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)((linked) => {
      var _a2;
      this.isLinked = linked;
      const cachedAddresses = this.storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
      if (linked) {
        this.session.linked = linked;
      }
      this.isUnlinkedErrorState = false;
      if (cachedAddresses) {
        const addresses = cachedAddresses.split(" ");
        const wasConnectedViaStandalone = this.storage.getItem("IsStandaloneSigning") === "true";
        if (addresses[0] !== "" && !linked && this.session.linked && !wasConnectedViaStandalone) {
          this.isUnlinkedErrorState = true;
          const sessionIdHash = this.getSessionIdHash();
          (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.UNLINKED_ERROR_STATE, {
            sessionIdHash
          });
        }
      }
    })).subscribe());
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => !!c2.metadata && c2.metadata.__destroyed === "1")).subscribe(() => {
      var _a2;
      const alreadyDestroyed = connection.isDestroyed;
      (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.METADATA_DESTROYED, {
        alreadyDestroyed,
        sessionIdHash: this.getSessionIdHash()
      });
      return this.resetAndReload();
    }));
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.WalletUsername !== void 0)).pipe((0, operators_1.mergeMap)((c2) => aes256gcm.decrypt(c2.metadata.WalletUsername, session.secret))).subscribe({
      next: (walletUsername) => {
        this.storage.setItem(WalletSDKRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "username"
        });
      }
    }));
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.AppVersion !== void 0)).pipe((0, operators_1.mergeMap)((c2) => aes256gcm.decrypt(c2.metadata.AppVersion, session.secret))).subscribe({
      next: (appVersion) => {
        this.storage.setItem(WalletSDKRelayAbstract_1.APP_VERSION_KEY, appVersion);
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "appversion"
        });
      }
    }));
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.ChainId !== void 0 && c2.metadata.JsonRpcUrl !== void 0)).pipe((0, operators_1.mergeMap)((c2) => (0, rxjs_1.zip)(aes256gcm.decrypt(c2.metadata.ChainId, session.secret), aes256gcm.decrypt(c2.metadata.JsonRpcUrl, session.secret)))).pipe((0, operators_1.distinctUntilChanged)()).subscribe({
      next: ([chainId, jsonRpcUrl]) => {
        if (this.chainCallback) {
          this.chainCallback(chainId, jsonRpcUrl);
        }
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "chainId|jsonRpcUrl"
        });
      }
    }));
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.EthereumAddress !== void 0)).pipe((0, operators_1.mergeMap)((c2) => aes256gcm.decrypt(c2.metadata.EthereumAddress, session.secret))).subscribe({
      next: (selectedAddress) => {
        if (this.accountsCallback) {
          this.accountsCallback([selectedAddress]);
        }
        if (WalletSDKRelay.accountRequestCallbackIds.size > 0) {
          Array.from(WalletSDKRelay.accountRequestCallbackIds.values()).forEach((id2) => {
            const message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.RequestEthereumAccountsResponse)([
                selectedAddress
              ])
            });
            this.invokeCallback(Object.assign(Object.assign({}, message), { id: id2 }));
          });
          WalletSDKRelay.accountRequestCallbackIds.clear();
        }
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "selectedAddress"
        });
      }
    }));
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.AppSrc !== void 0)).pipe((0, operators_1.mergeMap)((c2) => aes256gcm.decrypt(c2.metadata.AppSrc, session.secret))).subscribe({
      next: (appSrc) => {
        this.ui.setAppSrc(appSrc);
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "appSrc"
        });
      }
    }));
    const ui2 = this.options.uiConstructor({
      linkAPIUrl: this.options.linkAPIUrl,
      version: this.options.version,
      darkMode: this.options.darkMode,
      session,
      connected$: connection.connected$,
      chainId$: this.dappDefaultChainSubject
    });
    connection.connect();
    return { session, ui: ui2, connection };
  }
  attachUI() {
    this.ui.attach();
  }
  resetAndReload() {
    this.connection.setSessionMetadata("__destroyed", "1").pipe((0, operators_1.timeout)(1e3), (0, operators_1.catchError)((_3) => (0, rxjs_1.of)(null))).subscribe((_3) => {
      var _a2, _b, _c;
      const isStandalone = this.ui.isStandalone();
      try {
        this.subscriptions.unsubscribe();
      } catch (err) {
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error unsubscribing"
        });
      }
      (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.SESSION_STATE_CHANGE, {
        method: "relay::resetAndReload",
        sessionMetadataChange: "__destroyed, 1",
        sessionIdHash: this.getSessionIdHash()
      });
      this.connection.destroy();
      const storedSession = Session_1.Session.load(this.storage);
      if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
        this.storage.clear();
      } else if (storedSession) {
        (_c = this.diagnostic) === null || _c === void 0 ? void 0 : _c.log(DiagnosticLogger_1.EVENTS.SKIPPED_CLEARING_SESSION, {
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: Session_1.Session.hash(storedSession.id)
        });
      }
      if (this._reloadOnDisconnect) {
        this.ui.reloadUI();
        return;
      }
      if (this.accountsCallback) {
        this.accountsCallback([], true);
      }
      this.subscriptions = new rxjs_1.Subscription();
      const { session, ui: ui2, connection } = this.subscribe();
      this._session = session;
      this.connection = connection;
      this.ui = ui2;
      if (isStandalone && this.ui.setStandalone)
        this.ui.setStandalone(true);
      this.attachUI();
    }, (err) => {
      var _a2;
      (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.FAILURE, {
        method: "relay::resetAndReload",
        message: `failed to reset and reload with ${err}`,
        sessionIdHash: this.getSessionIdHash()
      });
    });
  }
  setAppInfo(appName, appLogoUrl) {
    this.appName = appName;
    this.appLogoUrl = appLogoUrl;
  }
  getStorageItem(key2) {
    return this.storage.getItem(key2);
  }
  get session() {
    return this._session;
  }
  setStorageItem(key2, value) {
    this.storage.setItem(key2, value);
  }
  signEthereumMessage(message, address, addPrefix, typedDataJson) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.signEthereumMessage,
      params: {
        message: (0, util_1$2.hexStringFromBuffer)(message, true),
        address,
        addPrefix,
        typedDataJson: typedDataJson || null
      }
    });
  }
  ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
      params: {
        message: (0, util_1$2.hexStringFromBuffer)(message, true),
        signature: (0, util_1$2.hexStringFromBuffer)(signature2, true),
        addPrefix
      }
    });
  }
  signEthereumTransaction(params) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.signEthereumTransaction,
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: (0, util_1$2.bigIntStringFromBN)(params.weiValue),
        data: (0, util_1$2.hexStringFromBuffer)(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        maxFeePerGas: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        gasLimit: params.gasLimit ? (0, util_1$2.bigIntStringFromBN)(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: false
      }
    });
  }
  signAndSubmitEthereumTransaction(params) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.signEthereumTransaction,
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: (0, util_1$2.bigIntStringFromBN)(params.weiValue),
        data: (0, util_1$2.hexStringFromBuffer)(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        maxFeePerGas: params.maxFeePerGas ? (0, util_1$2.bigIntStringFromBN)(params.maxFeePerGas) : null,
        maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1$2.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,
        gasLimit: params.gasLimit ? (0, util_1$2.bigIntStringFromBN)(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: true
      }
    });
  }
  submitEthereumTransaction(signedTransaction, chainId) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.submitEthereumTransaction,
      params: {
        signedTransaction: (0, util_1$2.hexStringFromBuffer)(signedTransaction, true),
        chainId
      }
    });
  }
  scanQRCode(regExp) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.scanQRCode,
      params: { regExp }
    });
  }
  getQRCodeUrl() {
    return (0, util_1$2.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, false, this.options.version, this.dappDefaultChain);
  }
  genericRequest(data2, action) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.generic,
      params: {
        action,
        data: data2
      }
    });
  }
  sendGenericMessage(request) {
    return this.sendRequest(request);
  }
  sendRequest(request) {
    let hideSnackbarItem = null;
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    const promise = new Promise((resolve, reject) => {
      if (!this.ui.isStandalone()) {
        hideSnackbarItem = this.ui.showConnecting({
          isUnlinkedErrorState: this.isUnlinkedErrorState,
          onCancel: cancel,
          onResetConnection: this.resetAndReload
          // eslint-disable-line @typescript-eslint/unbound-method
        });
      }
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      if (this.ui.isStandalone()) {
        this.sendRequestStandalone(id2, request);
      } else {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return { promise, cancel };
  }
  setConnectDisabled(disabled) {
    this.ui.setConnectDisabled(disabled);
  }
  setAccountsCallback(accountsCallback) {
    this.accountsCallback = accountsCallback;
  }
  setChainCallback(chainCallback) {
    this.chainCallback = chainCallback;
  }
  setDappDefaultChainCallback(chainId) {
    this.dappDefaultChainSubject.next(chainId);
  }
  publishWeb3RequestEvent(id2, request) {
    var _a2;
    const message = (0, Web3RequestMessage_1.Web3RequestMessage)({ id: id2, request });
    const storedSession = Session_1.Session.load(this.storage);
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST, {
      eventId: message.id,
      method: `relay::${message.request.method}`,
      sessionIdHash: this.getSessionIdHash(),
      storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
      isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
    });
    this.subscriptions.add(this.publishEvent("Web3Request", message, true).subscribe({
      next: (_3) => {
        var _a3;
        (_a3 = this.diagnostic) === null || _a3 === void 0 ? void 0 : _a3.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST_PUBLISHED, {
          eventId: message.id,
          method: `relay::${message.request.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
          isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
        });
      },
      error: (err) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: message.id,
          response: {
            method: message.request.method,
            errorMessage: err.message
          }
        }));
      }
    }));
  }
  publishWeb3RequestCanceledEvent(id2) {
    const message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id2);
    this.subscriptions.add(this.publishEvent("Web3RequestCanceled", message, false).subscribe());
  }
  publishEvent(event, message, callWebhook) {
    const secret = this.session.secret;
    return new rxjs_1.Observable((subscriber) => {
      void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), { origin: location.origin })), secret).then((encrypted) => {
        subscriber.next(encrypted);
        subscriber.complete();
      });
    }).pipe((0, operators_1.mergeMap)((encrypted) => {
      return this.connection.publishEvent(event, encrypted, callWebhook);
    }));
  }
  handleIncomingEvent(event) {
    try {
      this.subscriptions.add((0, rxjs_1.from)(aes256gcm.decrypt(event.data, this.session.secret)).pipe((0, operators_1.map)((c2) => JSON.parse(c2))).subscribe({
        next: (json2) => {
          const message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json2) ? json2 : null;
          if (!message) {
            return;
          }
          this.handleWeb3ResponseMessage(message);
        },
        error: () => {
          var _a2;
          (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: "incomingEvent"
          });
        }
      }));
    } catch (_a2) {
      return;
    }
  }
  handleWeb3ResponseMessage(message) {
    var _a2;
    const { response } = message;
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.WEB3_RESPONSE, {
      eventId: message.id,
      method: `relay::${response.method}`,
      sessionIdHash: this.getSessionIdHash()
    });
    if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {
      WalletSDKRelay.accountRequestCallbackIds.forEach((id2) => this.invokeCallback(Object.assign(Object.assign({}, message), { id: id2 })));
      WalletSDKRelay.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(message);
  }
  handleErrorResponse(id2, method, error, errorCode) {
    var _a2;
    const errorMessage = (_a2 = error === null || error === void 0 ? void 0 : error.message) !== null && _a2 !== void 0 ? _a2 : (0, errors_1.standardErrorMessage)(errorCode);
    this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
      id: id2,
      response: {
        method,
        errorMessage,
        errorCode
      }
    }));
  }
  invokeCallback(message) {
    const callback = this.relayEventManager.callbacks.get(message.id);
    if (callback) {
      callback(message.response);
      this.relayEventManager.callbacks.delete(message.id);
    }
  }
  requestEthereumAccounts() {
    const request = {
      method: Web3Method_1.Web3Method.requestEthereumAccounts,
      params: {
        appName: this.appName,
        appLogoUrl: this.appLogoUrl || null
      }
    };
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
    };
    const promise = new Promise((resolve, reject) => {
      var _a2;
      this.relayEventManager.callbacks.set(id2, (response) => {
        this.ui.hideRequestEthereumAccounts();
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      const userAgent = ((_a2 = window === null || window === void 0 ? void 0 : window.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent) || null;
      if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
        let location2;
        try {
          if ((0, util_1$2.isInIFrame)() && window.top) {
            location2 = window.top.location;
          } else {
            location2 = window.location;
          }
        } catch (e2) {
          location2 = window.location;
        }
        location2.href = `https://www.coinbase.com/connect-dapp?uri=${encodeURIComponent(location2.href)}`;
        return;
      }
      if (this.ui.inlineAccountsResponse()) {
        const onAccounts = (accounts) => {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)
          }));
        };
        this.ui.requestEthereumAccounts({
          onCancel: cancel,
          onAccounts
        });
      } else {
        const err = errors_1.standardErrors.provider.userRejectedRequest("User denied account authorization");
        this.ui.requestEthereumAccounts({
          onCancel: () => cancel(err)
        });
      }
      WalletSDKRelay.accountRequestCallbackIds.add(id2);
      if (!this.ui.inlineAccountsResponse() && !this.ui.isStandalone()) {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return { promise, cancel };
  }
  selectProvider(providerOptions) {
    const request = {
      method: Web3Method_1.Web3Method.selectProvider,
      params: {
        providerOptions
      }
    };
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
    };
    const promise = new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      const _cancel = (_error) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.SelectProviderResponse)(types_1.ProviderType.Unselected)
        }));
      };
      const approve = (selectedProviderKey) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.SelectProviderResponse)(selectedProviderKey)
        }));
      };
      if (this.ui.selectProvider)
        this.ui.selectProvider({
          onApprove: approve,
          onCancel: _cancel,
          providerOptions
        });
    });
    return { cancel, promise };
  }
  watchAsset(type2, address, symbol2, decimals, image, chainId) {
    const request = {
      method: Web3Method_1.Web3Method.watchAsset,
      params: {
        type: type2,
        options: {
          address,
          symbol: symbol2,
          decimals,
          image
        },
        chainId
      }
    };
    let hideSnackbarItem = null;
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    if (!this.ui.inlineWatchAsset()) {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      });
    }
    const promise = new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      const _cancel = (_error) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.WatchAssetReponse)(false)
        }));
      };
      const approve = () => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.WatchAssetReponse)(true)
        }));
      };
      if (this.ui.inlineWatchAsset()) {
        this.ui.watchAsset({
          onApprove: approve,
          onCancel: _cancel,
          type: type2,
          address,
          symbol: symbol2,
          decimals,
          image,
          chainId
        });
      }
      if (!this.ui.inlineWatchAsset() && !this.ui.isStandalone()) {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return { cancel, promise };
  }
  addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
    const request = {
      method: Web3Method_1.Web3Method.addEthereumChain,
      params: {
        chainId,
        rpcUrls,
        blockExplorerUrls,
        chainName,
        iconUrls,
        nativeCurrency
      }
    };
    let hideSnackbarItem = null;
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    if (!this.ui.inlineAddEthereumChain(chainId)) {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      });
    }
    const promise = new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      const _cancel = (_error) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.AddEthereumChainResponse)({
            isApproved: false,
            rpcUrl: ""
          })
        }));
      };
      const approve = (rpcUrl) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.AddEthereumChainResponse)({ isApproved: true, rpcUrl })
        }));
      };
      if (this.ui.inlineAddEthereumChain(chainId)) {
        this.ui.addEthereumChain({
          onCancel: _cancel,
          onApprove: approve,
          chainId: request.params.chainId,
          rpcUrls: request.params.rpcUrls,
          blockExplorerUrls: request.params.blockExplorerUrls,
          chainName: request.params.chainName,
          iconUrls: request.params.iconUrls,
          nativeCurrency: request.params.nativeCurrency
        });
      }
      if (!this.ui.inlineAddEthereumChain(chainId) && !this.ui.isStandalone()) {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return { promise, cancel };
  }
  switchEthereumChain(chainId, address) {
    const request = {
      method: Web3Method_1.Web3Method.switchEthereumChain,
      params: Object.assign({ chainId }, { address })
    };
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
    };
    const promise = new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        if ((0, Web3Response_1.isErrorResponse)(response) && response.errorCode) {
          return reject(errors_1.standardErrors.provider.custom({
            code: response.errorCode,
            message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
          }));
        } else if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      const _cancel = (error) => {
        var _a2;
        if (error) {
          const errorCode = (_a2 = (0, errors_1.getErrorCode)(error)) !== null && _a2 !== void 0 ? _a2 : errors_1.standardErrorCodes.provider.unsupportedChain;
          this.handleErrorResponse(id2, Web3Method_1.Web3Method.switchEthereumChain, error instanceof Error ? error : errors_1.standardErrors.provider.unsupportedChain(chainId), errorCode);
        } else {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.SwitchEthereumChainResponse)({
              isApproved: false,
              rpcUrl: ""
            })
          }));
        }
      };
      const approve = (rpcUrl) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.SwitchEthereumChainResponse)({
            isApproved: true,
            rpcUrl
          })
        }));
      };
      this.ui.switchEthereumChain({
        onCancel: _cancel,
        onApprove: approve,
        chainId: request.params.chainId,
        address: request.params.address
      });
      if (!this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone()) {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return { promise, cancel };
  }
  inlineAddEthereumChain(chainId) {
    return this.ui.inlineAddEthereumChain(chainId);
  }
  getSessionIdHash() {
    return Session_1.Session.hash(this._session.id);
  }
  sendRequestStandalone(id2, request) {
    const _cancel = (error) => {
      this.handleErrorResponse(id2, request.method, error);
    };
    const onSuccess = (response) => {
      this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
        id: id2,
        response
      }));
    };
    switch (request.method) {
      case Web3Method_1.Web3Method.signEthereumMessage:
        this.ui.signEthereumMessage({
          request,
          onSuccess,
          onCancel: _cancel
        });
        break;
      case Web3Method_1.Web3Method.signEthereumTransaction:
        this.ui.signEthereumTransaction({
          request,
          onSuccess,
          onCancel: _cancel
        });
        break;
      case Web3Method_1.Web3Method.submitEthereumTransaction:
        this.ui.submitEthereumTransaction({
          request,
          onSuccess,
          onCancel: _cancel
        });
        break;
      case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:
        this.ui.ethereumAddressFromSignedMessage({
          request,
          onSuccess
        });
        break;
      default:
        _cancel();
        break;
    }
  }
  onSessionConfigChanged(_nextSessionConfig) {
  }
}
WalletSDKRelay.accountRequestCallbackIds = /* @__PURE__ */ new Set();
__decorate([
  bind_decorator_1.default
], WalletSDKRelay.prototype, "resetAndReload", null);
__decorate([
  bind_decorator_1.default
], WalletSDKRelay.prototype, "handleIncomingEvent", null);
WalletSDKRelay_2 = WalletSDKRelay$2.WalletSDKRelay = WalletSDKRelay;
const WalletSDKRelay$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get WalletSDKRelay() {
    return WalletSDKRelay_2;
  },
  default: WalletSDKRelay$2
}, [WalletSDKRelay$2]);
const require$$5$2 = /* @__PURE__ */ getAugmentedNamespace(WalletSDKRelay$1);
var WalletSDKRelayEventManager$2 = {};
Object.defineProperty(WalletSDKRelayEventManager$2, "__esModule", { value: true });
var WalletSDKRelayEventManager_2 = WalletSDKRelayEventManager$2.WalletSDKRelayEventManager = void 0;
const util_1$1 = require$$7$4;
class WalletSDKRelayEventManager {
  constructor() {
    this._nextRequestId = 0;
    this.callbacks = /* @__PURE__ */ new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const id2 = this._nextRequestId;
    const idStr = (0, util_1$1.prepend0x)(id2.toString(16));
    const callback = this.callbacks.get(idStr);
    if (callback) {
      this.callbacks.delete(idStr);
    }
    return id2;
  }
}
WalletSDKRelayEventManager_2 = WalletSDKRelayEventManager$2.WalletSDKRelayEventManager = WalletSDKRelayEventManager;
const WalletSDKRelayEventManager$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get WalletSDKRelayEventManager() {
    return WalletSDKRelayEventManager_2;
  },
  default: WalletSDKRelayEventManager$2
}, [WalletSDKRelayEventManager$2]);
const require$$6$2 = /* @__PURE__ */ getAugmentedNamespace(WalletSDKRelayEventManager$1);
Object.defineProperty(CoinbaseWalletSDK$2, "__esModule", { value: true });
var CoinbaseWalletSDK_2 = CoinbaseWalletSDK$2.CoinbaseWalletSDK = void 0;
const wallet_logo_1 = require$$0$15;
const constants_1 = require$$1$C;
const ScopedLocalStorage_1 = require$$2$o;
const CoinbaseWalletProvider_1 = require$$1$c;
const WalletSDKUI_1 = require$$4$3;
const WalletSDKRelay_1 = require$$5$2;
const WalletSDKRelayEventManager_1 = require$$6$2;
const util_1 = require$$7$4;
const version_1 = require$$8$4;
class CoinbaseWalletSDK {
  /**
   * Constructor
   * @param options Coinbase Wallet SDK constructor options
   */
  constructor(options) {
    var _a2, _b, _c;
    this._appName = "";
    this._appLogoUrl = null;
    this._relay = null;
    this._relayEventManager = null;
    const linkAPIUrl = options.linkAPIUrl || constants_1.LINK_API_URL;
    let uiConstructor;
    if (!options.uiConstructor) {
      uiConstructor = (opts) => new WalletSDKUI_1.WalletSDKUI(opts);
    } else {
      uiConstructor = options.uiConstructor;
    }
    if (typeof options.overrideIsMetaMask === "undefined") {
      this._overrideIsMetaMask = false;
    } else {
      this._overrideIsMetaMask = options.overrideIsMetaMask;
    }
    this._overrideIsCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
    this._overrideIsCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
    if (options.diagnosticLogger && options.eventListener) {
      throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
    }
    if (options.eventListener) {
      this._diagnosticLogger = {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        log: options.eventListener.onEvent
      };
    } else {
      this._diagnosticLogger = options.diagnosticLogger;
    }
    this._reloadOnDisconnect = (_c = options.reloadOnDisconnect) !== null && _c !== void 0 ? _c : true;
    const url = new URL(linkAPIUrl);
    const origin = `${url.protocol}//${url.host}`;
    this._storage = new ScopedLocalStorage_1.ScopedLocalStorage(`-walletlink:${origin}`);
    this._storage.setItem("version", CoinbaseWalletSDK.VERSION);
    if (this.walletExtension || this.coinbaseBrowser) {
      return;
    }
    this._relayEventManager = new WalletSDKRelayEventManager_1.WalletSDKRelayEventManager();
    this._relay = new WalletSDKRelay_1.WalletSDKRelay({
      linkAPIUrl,
      version: version_1.LIB_VERSION,
      darkMode: !!options.darkMode,
      uiConstructor,
      storage: this._storage,
      relayEventManager: this._relayEventManager,
      diagnosticLogger: this._diagnosticLogger,
      reloadOnDisconnect: this._reloadOnDisconnect
    });
    this.setAppInfo(options.appName, options.appLogoUrl);
    if (!!options.headlessMode)
      return;
    this._relay.attachUI();
  }
  /**
   * Create a Web3 Provider object
   * @param jsonRpcUrl Ethereum JSON RPC URL (Default: "")
   * @param chainId Ethereum Chain ID (Default: 1)
   * @returns A Web3 Provider
   */
  makeWeb3Provider(jsonRpcUrl = "", chainId = 1) {
    const extension = this.walletExtension;
    if (extension) {
      if (!this.isCipherProvider(extension)) {
        extension.setProviderInfo(jsonRpcUrl, chainId);
      }
      if (this._reloadOnDisconnect === false && typeof extension.disableReloadOnDisconnect === "function")
        extension.disableReloadOnDisconnect();
      return extension;
    }
    const dappBrowser = this.coinbaseBrowser;
    if (dappBrowser) {
      return dappBrowser;
    }
    const relay = this._relay;
    if (!relay || !this._relayEventManager || !this._storage) {
      throw new Error("Relay not initialized, should never happen");
    }
    if (!jsonRpcUrl)
      relay.setConnectDisabled(true);
    return new CoinbaseWalletProvider_1.CoinbaseWalletProvider({
      relayProvider: () => Promise.resolve(relay),
      relayEventManager: this._relayEventManager,
      storage: this._storage,
      jsonRpcUrl,
      chainId,
      qrUrl: this.getQrUrl(),
      diagnosticLogger: this._diagnosticLogger,
      overrideIsMetaMask: this._overrideIsMetaMask,
      overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
      overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
    });
  }
  /**
   * Set application information
   * @param appName Application name
   * @param appLogoUrl Application logo image URL
   */
  setAppInfo(appName, appLogoUrl) {
    var _a2;
    this._appName = appName || "DApp";
    this._appLogoUrl = appLogoUrl || (0, util_1.getFavicon)();
    const extension = this.walletExtension;
    if (extension) {
      if (!this.isCipherProvider(extension)) {
        extension.setAppInfo(this._appName, this._appLogoUrl);
      }
    } else {
      (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.setAppInfo(this._appName, this._appLogoUrl);
    }
  }
  /**
   * Disconnect. After disconnecting, this will reload the web page to ensure
   * all potential stale state is cleared.
   */
  disconnect() {
    var _a2;
    const extension = this.walletExtension;
    if (extension) {
      void extension.close();
    } else {
      (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.resetAndReload();
    }
  }
  /**
   * Return QR URL for mobile wallet connection, will return null if extension is installed
   */
  getQrUrl() {
    var _a2, _b;
    return (_b = (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.getQRCodeUrl()) !== null && _b !== void 0 ? _b : null;
  }
  /**
   * Official Coinbase Wallet logo for developers to use on their frontend
   * @param type Type of wallet logo: "standard" | "circle" | "text" | "textWithLogo" | "textLight" | "textWithLogoLight"
   * @param width Width of the logo (Optional)
   * @returns SVG Data URI
   */
  getCoinbaseWalletLogo(type2, width = 240) {
    return (0, wallet_logo_1.walletLogo)(type2, width);
  }
  get walletExtension() {
    var _a2;
    return (_a2 = window.coinbaseWalletExtension) !== null && _a2 !== void 0 ? _a2 : window.walletLinkExtension;
  }
  get coinbaseBrowser() {
    var _a2, _b;
    try {
      const ethereum = (_a2 = window.ethereum) !== null && _a2 !== void 0 ? _a2 : (_b = window.top) === null || _b === void 0 ? void 0 : _b.ethereum;
      if (!ethereum) {
        return void 0;
      }
      if ("isCoinbaseBrowser" in ethereum && ethereum.isCoinbaseBrowser) {
        return ethereum;
      } else {
        return void 0;
      }
    } catch (e2) {
      return void 0;
    }
  }
  isCipherProvider(provider) {
    return typeof provider.isCipher === "boolean" && provider.isCipher;
  }
}
CoinbaseWalletSDK_2 = CoinbaseWalletSDK$2.CoinbaseWalletSDK = CoinbaseWalletSDK;
CoinbaseWalletSDK.VERSION = version_1.LIB_VERSION;
const CoinbaseWalletSDK$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get CoinbaseWalletSDK() {
    return CoinbaseWalletSDK_2;
  },
  default: CoinbaseWalletSDK$2
}, [CoinbaseWalletSDK$2]);
const require$$0$l = /* @__PURE__ */ getAugmentedNamespace(CoinbaseWalletSDK$1);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.CoinbaseWalletProvider = exports2.CoinbaseWalletSDK = void 0;
  const CoinbaseWalletSDK_1 = require$$0$l;
  const CoinbaseWalletProvider_12 = require$$1$c;
  var CoinbaseWalletSDK_22 = require$$0$l;
  Object.defineProperty(exports2, "CoinbaseWalletSDK", { enumerable: true, get: function() {
    return CoinbaseWalletSDK_22.CoinbaseWalletSDK;
  } });
  var CoinbaseWalletProvider_22 = require$$1$c;
  Object.defineProperty(exports2, "CoinbaseWalletProvider", { enumerable: true, get: function() {
    return CoinbaseWalletProvider_22.CoinbaseWalletProvider;
  } });
  exports2.default = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
  if (typeof window !== "undefined") {
    window.CoinbaseWalletSDK = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
    window.CoinbaseWalletProvider = CoinbaseWalletProvider_12.CoinbaseWalletProvider;
    window.WalletLink = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
    window.WalletLinkProvider = CoinbaseWalletProvider_12.CoinbaseWalletProvider;
  }
})(dist$b);
function defaultConfig$1(options) {
  const { enableEIP6963 = true, enableInjected = true, enableCoinbase = true, metadata, rpcUrl, defaultChainId } = options;
  let injectedProvider = void 0;
  let coinbaseProvider = void 0;
  const providers = { metadata };
  function getInjectedProvider() {
    if (injectedProvider) {
      return injectedProvider;
    }
    if (typeof window === "undefined") {
      return void 0;
    }
    if (!window.ethereum) {
      return void 0;
    }
    injectedProvider = window.ethereum;
    return injectedProvider;
  }
  function getCoinbaseProvider() {
    if (coinbaseProvider) {
      return coinbaseProvider;
    }
    if (typeof window === "undefined") {
      return void 0;
    }
    const coinbaseWallet = new dist$b.CoinbaseWalletSDK({
      appName: metadata.name,
      appLogoUrl: metadata.icons[0],
      darkMode: false
    });
    coinbaseProvider = coinbaseWallet.makeWeb3Provider(rpcUrl, defaultChainId);
    return coinbaseProvider;
  }
  if (enableInjected) {
    providers.injected = getInjectedProvider();
  }
  if (enableCoinbase && rpcUrl && defaultChainId) {
    providers.coinbase = getCoinbaseProvider();
  }
  if (enableEIP6963) {
    providers.EIP6963 = true;
  }
  return providers;
}
let modal = void 0;
function createWeb3Modal(options) {
  if (!modal) {
    modal = new Web3Modal({
      ...options,
      _sdkVersion: `react-ethers5-${ConstantsUtil.VERSION}`
    });
  }
  return modal;
}
function getIterator(iterable) {
  if (typeof iterable.next === "function") {
    return iterable;
  }
  if (typeof iterable[Symbol.iterator] === "function") {
    return iterable[Symbol.iterator]();
  }
  if (typeof iterable[Symbol.asyncIterator] === "function") {
    return iterable[Symbol.asyncIterator]();
  }
  throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols');
}
function defer() {
  let reject;
  let resolve;
  const promise = new Promise((resolveFunc, rejectFunc) => {
    resolve = resolveFunc;
    reject = rejectFunc;
  });
  return {
    promise,
    reject,
    resolve
  };
}
function _transform(concurrency, func2, iterable) {
  const iterator2 = getIterator(iterable);
  const resultQueue = [];
  const readQueue = [];
  let ended = false;
  let reading = false;
  let inflightCount = 0;
  let lastError = null;
  function fulfillReadQueue() {
    while (readQueue.length > 0 && resultQueue.length > 0) {
      const { resolve } = readQueue.shift();
      const value = resultQueue.shift();
      resolve({ done: false, value });
    }
    while (readQueue.length > 0 && inflightCount === 0 && ended) {
      const { resolve, reject } = readQueue.shift();
      if (lastError) {
        reject(lastError);
        lastError = null;
      } else {
        resolve({ done: true, value: void 0 });
      }
    }
  }
  async function fillQueue() {
    if (ended) {
      fulfillReadQueue();
      return;
    }
    if (reading) {
      return;
    }
    if (inflightCount + resultQueue.length >= concurrency) {
      return;
    }
    reading = true;
    inflightCount++;
    try {
      const { done: done2, value } = await iterator2.next();
      if (done2) {
        ended = true;
        inflightCount--;
        fulfillReadQueue();
      } else {
        mapAndQueue(value);
      }
    } catch (error) {
      ended = true;
      inflightCount--;
      lastError = error;
      fulfillReadQueue();
    }
    reading = false;
    fillQueue();
  }
  async function mapAndQueue(itrValue) {
    try {
      const value = await func2(itrValue);
      resultQueue.push(value);
    } catch (error) {
      ended = true;
      lastError = error;
    }
    inflightCount--;
    fulfillReadQueue();
    fillQueue();
  }
  async function next() {
    if (resultQueue.length === 0) {
      const deferred = defer();
      readQueue.push(deferred);
      fillQueue();
      return deferred.promise;
    }
    const value = resultQueue.shift();
    fillQueue();
    return { done: false, value };
  }
  const asyncIterableIterator = {
    next,
    [Symbol.asyncIterator]: () => asyncIterableIterator
  };
  return asyncIterableIterator;
}
function transform(concurrency, func2, iterable) {
  if (func2 === void 0) {
    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);
  }
  if (iterable === void 0) {
    return (curriedIterable) => transform(concurrency, func2, curriedIterable);
  }
  return _transform(concurrency, func2, iterable);
}
var pRetry$2 = { exports: {} };
var retry$5 = {};
function RetryOperation(timeouts, options) {
  if (typeof options === "boolean") {
    options = { forever: options };
  }
  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
  this._timeouts = timeouts;
  this._options = options || {};
  this._maxRetryTime = options && options.maxRetryTime || Infinity;
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;
  this._operationStart = null;
  this._timer = null;
  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}
var retry_operation = RetryOperation;
RetryOperation.prototype.reset = function() {
  this._attempts = 1;
  this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (this._timer) {
    clearTimeout(this._timer);
  }
  this._timeouts = [];
  this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (!err) {
    return false;
  }
  var currentTime = (/* @__PURE__ */ new Date()).getTime();
  if (err && currentTime - this._operationStart >= this._maxRetryTime) {
    this._errors.push(err);
    this._errors.unshift(new Error("RetryOperation timeout occurred"));
    return false;
  }
  this._errors.push(err);
  var timeout2 = this._timeouts.shift();
  if (timeout2 === void 0) {
    if (this._cachedTimeouts) {
      this._errors.splice(0, this._errors.length - 1);
      timeout2 = this._cachedTimeouts.slice(-1);
    } else {
      return false;
    }
  }
  var self2 = this;
  this._timer = setTimeout(function() {
    self2._attempts++;
    if (self2._operationTimeoutCb) {
      self2._timeout = setTimeout(function() {
        self2._operationTimeoutCb(self2._attempts);
      }, self2._operationTimeout);
      if (self2._options.unref) {
        self2._timeout.unref();
      }
    }
    self2._fn(self2._attempts);
  }, timeout2);
  if (this._options.unref) {
    this._timer.unref();
  }
  return true;
};
RetryOperation.prototype.attempt = function(fn2, timeoutOps) {
  this._fn = fn2;
  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }
    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }
  var self2 = this;
  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function() {
      self2._operationTimeoutCb();
    }, self2._operationTimeout);
  }
  this._operationStart = (/* @__PURE__ */ new Date()).getTime();
  this._fn(this._attempts);
};
RetryOperation.prototype.try = function(fn2) {
  console.log("Using RetryOperation.try() is deprecated");
  this.attempt(fn2);
};
RetryOperation.prototype.start = function(fn2) {
  console.log("Using RetryOperation.start() is deprecated");
  this.attempt(fn2);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
  return this._errors;
};
RetryOperation.prototype.attempts = function() {
  return this._attempts;
};
RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0) {
    return null;
  }
  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;
  for (var i3 = 0; i3 < this._errors.length; i3++) {
    var error = this._errors[i3];
    var message = error.message;
    var count2 = (counts[message] || 0) + 1;
    counts[message] = count2;
    if (count2 >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count2;
    }
  }
  return mainError;
};
const retry_operation$1 = /* @__PURE__ */ getDefaultExportFromCjs(retry_operation);
const retry_operation$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: retry_operation$1
}, [retry_operation]);
const require$$0$k = /* @__PURE__ */ getAugmentedNamespace(retry_operation$2);
(function(exports2) {
  var RetryOperation2 = require$$0$k;
  exports2.operation = function(options) {
    var timeouts = exports2.timeouts(options);
    return new RetryOperation2(timeouts, {
      forever: options && (options.forever || options.retries === Infinity),
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
    });
  };
  exports2.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key2 in options) {
      opts[key2] = options[key2];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i3 = 0; i3 < opts.retries; i3++) {
      timeouts.push(this.createTimeout(i3, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i3, opts));
    }
    timeouts.sort(function(a3, b4) {
      return a3 - b4;
    });
    return timeouts;
  };
  exports2.createTimeout = function(attempt, opts) {
    var random2 = opts.randomize ? Math.random() + 1 : 1;
    var timeout2 = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout2 = Math.min(timeout2, opts.maxTimeout);
    return timeout2;
  };
  exports2.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
    if (!methods) {
      methods = [];
      for (var key2 in obj) {
        if (typeof obj[key2] === "function") {
          methods.push(key2);
        }
      }
    }
    for (var i3 = 0; i3 < methods.length; i3++) {
      var method = methods[i3];
      var original = obj[method];
      obj[method] = function retryWrapper(original2) {
        var op = exports2.operation(options);
        var args = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
})(retry$5);
const retry$3 = /* @__PURE__ */ getDefaultExportFromCjs(retry$5);
const retry$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: retry$3
}, [retry$5]);
const require$$0$j = /* @__PURE__ */ getAugmentedNamespace(retry$4);
var retry$1 = require$$0$j;
const index$c = /* @__PURE__ */ getDefaultExportFromCjs(retry$1);
const retry$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$c
}, [retry$1]);
const require$$0$i = /* @__PURE__ */ getAugmentedNamespace(retry$2);
const retry = require$$0$i;
const networkErrorMsgs = [
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari
  "Network request failed"
  // `cross-fetch`
];
class AbortError extends Error {
  constructor(message) {
    super();
    if (message instanceof Error) {
      this.originalError = message;
      ({ message } = message);
    } else {
      this.originalError = new Error(message);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message;
  }
}
const decorateErrorWithCounts = (error, attemptNumber, options) => {
  const retriesLeft = options.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
const isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
const pRetry = (input, options) => new Promise((resolve, reject) => {
  options = {
    onFailedAttempt: () => {
    },
    retries: 10,
    ...options
  };
  const operation = retry.operation(options);
  operation.attempt(async (attemptNumber) => {
    try {
      resolve(await input(attemptNumber));
    } catch (error) {
      if (!(error instanceof Error)) {
        reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
        return;
      }
      if (error instanceof AbortError) {
        operation.stop();
        reject(error.originalError);
      } else if (error instanceof TypeError && !isNetworkError(error.message)) {
        operation.stop();
        reject(error);
      } else {
        decorateErrorWithCounts(error, attemptNumber, options);
        try {
          await options.onFailedAttempt(error);
        } catch (error2) {
          reject(error2);
          return;
        }
        if (!operation.retry(error)) {
          reject(operation.mainError());
        }
      }
    }
  });
});
pRetry$2.exports = pRetry;
pRetry$2.exports.default = pRetry;
var AbortError_1 = pRetry$2.exports.AbortError = AbortError;
var pRetryExports = pRetry$2.exports;
const pRetry$1 = /* @__PURE__ */ getDefaultExportFromCjs(pRetryExports);
var encode_1 = encode$7;
var MSB$1 = 128, REST$1 = 127, MSBALL = ~REST$1, INT = Math.pow(2, 31);
function encode$7(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode$7.bytes = 0;
    throw new RangeError("Could not encode varint");
  }
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB$1;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB$1;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$7.bytes = offset - oldOffset + 1;
  return out;
}
const encode$8 = /* @__PURE__ */ getDefaultExportFromCjs(encode_1);
const encode$9 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: encode$8
}, [encode_1]);
const require$$0$h = /* @__PURE__ */ getAugmentedNamespace(encode$9);
var decode$6 = read;
var MSB = 128, REST = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b4, l2 = buf2.length;
  do {
    if (counter >= l2 || shift > 49) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b4 = buf2[counter++];
    res += shift < 28 ? (b4 & REST) << shift : (b4 & REST) * Math.pow(2, shift);
    shift += 7;
  } while (b4 >= MSB);
  read.bytes = counter - offset;
  return res;
}
const decode$7 = /* @__PURE__ */ getDefaultExportFromCjs(decode$6);
const decode$8 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: decode$7
}, [decode$6]);
const require$$1$7 = /* @__PURE__ */ getAugmentedNamespace(decode$8);
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
const length$1 = /* @__PURE__ */ getDefaultExportFromCjs(length);
const length$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: length$1
}, [length]);
const require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(length$2);
var varint = {
  encode: require$$0$h,
  decode: require$$1$7,
  encodingLength: require$$2$2
};
const varint$1 = /* @__PURE__ */ getDefaultExportFromCjs(varint);
const typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
const objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer$1(value)) {
    return "Buffer";
  }
  const objectType2 = getObjectType(value);
  if (objectType2) {
    return objectType2;
  }
  return "Object";
}
function isBuffer$1(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
class Type {
  constructor(major2, name2, terminal) {
    this.major = major2;
    this.majorEncoded = major2 << 5;
    this.name = name2;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
}
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
let Token$2 = class Token2 {
  constructor(type2, value, encodedLength) {
    this.type = type2;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};
const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
const textDecoder$1 = new TextDecoder();
const textEncoder$2 = new TextEncoder();
function isBuffer(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
const toString$2 = useBuffer ? (bytes2, start, end2) => {
  return end2 - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end2)).toString("utf8") : utf8Slice(bytes2, start, end2);
} : (bytes2, start, end2) => {
  return end2 - start > 64 ? textDecoder$1.decode(bytes2.subarray(start, end2)) : utf8Slice(bytes2, start, end2);
};
const fromString = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder$2.encode(string2) : utf8ToBytes(string2);
};
const fromArray = (arr2) => {
  return Uint8Array.from(arr2);
};
const slice$1 = useBuffer ? (bytes2, start, end2) => {
  if (isBuffer(bytes2)) {
    return new Uint8Array(bytes2.subarray(start, end2));
  }
  return bytes2.slice(start, end2);
} : (bytes2, start, end2) => {
  return bytes2.slice(start, end2);
};
const concat = useBuffer ? (chunks, length2) => {
  chunks = chunks.map((c2) => c2 instanceof Uint8Array ? c2 : globalThis.Buffer.from(c2));
  return asU8A(globalThis.Buffer.concat(chunks, length2));
} : (chunks, length2) => {
  const out = new Uint8Array(length2);
  let off2 = 0;
  for (let b4 of chunks) {
    if (off2 + b4.length > out.length) {
      b4 = b4.subarray(0, out.length - off2);
    }
    out.set(b4, off2);
    off2 += b4.length;
  }
  return out;
};
const alloc = useBuffer ? (size2) => {
  return globalThis.Buffer.allocUnsafe(size2);
} : (size2) => {
  return new Uint8Array(size2);
};
function compare(b1, b22) {
  if (isBuffer(b1) && isBuffer(b22)) {
    return b1.compare(b22);
  }
  for (let i3 = 0; i3 < b1.length; i3++) {
    if (b1[i3] === b22[i3]) {
      continue;
    }
    return b1[i3] < b22[i3] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length2 = string2.length;
  let leadSurrogate = null;
  const bytes2 = [];
  for (let i3 = 0; i3 < length2; ++i3) {
    codePoint = string2.charCodeAt(i3);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i3 + 1 === length2) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function utf8Slice(buf2, offset, end2) {
  const res = [];
  while (offset < end2) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end2) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len2 = codePoints.length;
  if (len2 <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i3 = 0;
  while (i3 < len2) {
    res += String.fromCharCode.apply(String, codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
const defaultChunkSize = 256;
class Bl {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes2) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes2.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes2, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes2, 0);
      } else {
        this.chunks.push(bytes2);
        this.maxCursor += bytes2.length;
      }
    }
    this.cursor += bytes2.length;
  }
  toBytes(reset2 = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset2 && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice$1(chunk, 0, this.cursor);
      }
    } else {
      byts = concat(this.chunks, this.cursor);
    }
    if (reset2) {
      this.reset();
    }
    return byts;
  }
}
const decodeErrPrefix = "CBOR decode error:";
const encodeErrPrefix = "CBOR encode error:";
function assertEnoughData(data2, pos, need) {
  if (data2.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
const uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data2, offset, options) {
  assertEnoughData(data2, offset, 1);
  const value = data2[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data2, offset, options) {
  assertEnoughData(data2, offset, 2);
  const value = data2[offset] << 8 | data2[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data2, offset, options) {
  assertEnoughData(data2, offset, 4);
  const value = data2[offset] * 16777216 + (data2[offset + 1] << 16) + (data2[offset + 2] << 8) + data2[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data2, offset, options) {
  assertEnoughData(data2, offset, 8);
  const hi2 = data2[offset] * 16777216 + (data2[offset + 1] << 16) + (data2[offset + 2] << 8) + data2[offset + 3];
  const lo = data2[offset + 4] * 16777216 + (data2[offset + 5] << 16) + (data2[offset + 6] << 8) + data2[offset + 7];
  const value = (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data2, pos, _minor, options) {
  return new Token$2(Type.uint, readUint8(data2, pos + 1, options), 2);
}
function decodeUint16(data2, pos, _minor, options) {
  return new Token$2(Type.uint, readUint16(data2, pos + 1, options), 3);
}
function decodeUint32(data2, pos, _minor, options) {
  return new Token$2(Type.uint, readUint32(data2, pos + 1, options), 5);
}
function decodeUint64(data2, pos, _minor, options) {
  return new Token$2(Type.uint, readUint64(data2, pos + 1, options), 9);
}
function encodeUint(buf2, token2) {
  return encodeUintValue(buf2, 0, token2.value);
}
function encodeUintValue(buf2, major2, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major2 | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major2 | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major2 | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major2 | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set2 = [
        major2 | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi2 = Number(buint >> BigInt(32) & BigInt(4294967295));
      set2[8] = lo & 255;
      lo = lo >> 8;
      set2[7] = lo & 255;
      lo = lo >> 8;
      set2[6] = lo & 255;
      lo = lo >> 8;
      set2[5] = lo & 255;
      set2[4] = hi2 & 255;
      hi2 = hi2 >> 8;
      set2[3] = hi2 & 255;
      hi2 = hi2 >> 8;
      set2[2] = hi2 & 255;
      hi2 = hi2 >> 8;
      set2[1] = hi2 & 255;
      buf2.push(set2);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};
function decodeNegint8(data2, pos, _minor, options) {
  return new Token$2(Type.negint, -1 - readUint8(data2, pos + 1, options), 2);
}
function decodeNegint16(data2, pos, _minor, options) {
  return new Token$2(Type.negint, -1 - readUint16(data2, pos + 1, options), 3);
}
function decodeNegint32(data2, pos, _minor, options) {
  return new Token$2(Type.negint, -1 - readUint32(data2, pos + 1, options), 5);
}
const neg1b = BigInt(-1);
const pos1b = BigInt(1);
function decodeNegint64(data2, pos, _minor, options) {
  const int2 = readUint64(data2, pos + 1, options);
  if (typeof int2 !== "bigint") {
    const value = -1 - int2;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token$2(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token$2(Type.negint, neg1b - BigInt(int2), 9);
}
function encodeNegint(buf2, token2) {
  const negint = token2.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token2.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token2) {
  const negint = token2.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};
function toToken$3(data2, pos, prefix, length2) {
  assertEnoughData(data2, pos, prefix + length2);
  const buf2 = slice$1(data2, pos + prefix, pos + prefix + length2);
  return new Token$2(Type.bytes, buf2, prefix + length2);
}
function decodeBytesCompact(data2, pos, minor2, _options) {
  return toToken$3(data2, pos, 1, minor2);
}
function decodeBytes8(data2, pos, _minor, options) {
  return toToken$3(data2, pos, 2, readUint8(data2, pos + 1, options));
}
function decodeBytes16(data2, pos, _minor, options) {
  return toToken$3(data2, pos, 3, readUint16(data2, pos + 1, options));
}
function decodeBytes32(data2, pos, _minor, options) {
  return toToken$3(data2, pos, 5, readUint32(data2, pos + 1, options));
}
function decodeBytes64(data2, pos, _minor, options) {
  const l2 = readUint64(data2, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken$3(data2, pos, 9, l2);
}
function tokenBytes(token2) {
  if (token2.encodedBytes === void 0) {
    token2.encodedBytes = token2.type === Type.string ? fromString(token2.value) : token2.value;
  }
  return token2.encodedBytes;
}
function encodeBytes(buf2, token2) {
  const bytes2 = tokenBytes(token2);
  encodeUintValue(buf2, token2.type.majorEncoded, bytes2.length);
  buf2.push(bytes2);
}
encodeBytes.encodedSize = function encodedSize4(token2) {
  const bytes2 = tokenBytes(token2);
  return encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b22) {
  return b1.length < b22.length ? -1 : b1.length > b22.length ? 1 : compare(b1, b22);
}
function toToken$2(data2, pos, prefix, length2, options) {
  const totLength = prefix + length2;
  assertEnoughData(data2, pos, totLength);
  const tok = new Token$2(Type.string, toString$2(data2, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice$1(data2, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data2, pos, minor2, options) {
  return toToken$2(data2, pos, 1, minor2, options);
}
function decodeString8(data2, pos, _minor, options) {
  return toToken$2(data2, pos, 2, readUint8(data2, pos + 1, options), options);
}
function decodeString16(data2, pos, _minor, options) {
  return toToken$2(data2, pos, 3, readUint16(data2, pos + 1, options), options);
}
function decodeString32(data2, pos, _minor, options) {
  return toToken$2(data2, pos, 5, readUint32(data2, pos + 1, options), options);
}
function decodeString64(data2, pos, _minor, options) {
  const l2 = readUint64(data2, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken$2(data2, pos, 9, l2, options);
}
const encodeString = encodeBytes;
function toToken$1(_data, _pos, prefix, length2) {
  return new Token$2(Type.array, length2, prefix);
}
function decodeArrayCompact(data2, pos, minor2, _options) {
  return toToken$1(data2, pos, 1, minor2);
}
function decodeArray8(data2, pos, _minor, options) {
  return toToken$1(data2, pos, 2, readUint8(data2, pos + 1, options));
}
function decodeArray16(data2, pos, _minor, options) {
  return toToken$1(data2, pos, 3, readUint16(data2, pos + 1, options));
}
function decodeArray32(data2, pos, _minor, options) {
  return toToken$1(data2, pos, 5, readUint32(data2, pos + 1, options));
}
function decodeArray64(data2, pos, _minor, options) {
  const l2 = readUint64(data2, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken$1(data2, pos, 9, l2);
}
function decodeArrayIndefinite(data2, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken$1(data2, pos, 1, Infinity);
}
function encodeArray(buf2, token2) {
  encodeUintValue(buf2, Type.array.majorEncoded, token2.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
function toToken(_data, _pos, prefix, length2) {
  return new Token$2(Type.map, length2, prefix);
}
function decodeMapCompact(data2, pos, minor2, _options) {
  return toToken(data2, pos, 1, minor2);
}
function decodeMap8(data2, pos, _minor, options) {
  return toToken(data2, pos, 2, readUint8(data2, pos + 1, options));
}
function decodeMap16(data2, pos, _minor, options) {
  return toToken(data2, pos, 3, readUint16(data2, pos + 1, options));
}
function decodeMap32(data2, pos, _minor, options) {
  return toToken(data2, pos, 5, readUint32(data2, pos + 1, options));
}
function decodeMap64(data2, pos, _minor, options) {
  const l2 = readUint64(data2, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken(data2, pos, 9, l2);
}
function decodeMapIndefinite(data2, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken(data2, pos, 1, Infinity);
}
function encodeMap(buf2, token2) {
  encodeUintValue(buf2, Type.map.majorEncoded, token2.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
function decodeTagCompact(_data, _pos, minor2, _options) {
  return new Token$2(Type.tag, minor2, 1);
}
function decodeTag8(data2, pos, _minor, options) {
  return new Token$2(Type.tag, readUint8(data2, pos + 1, options), 2);
}
function decodeTag16(data2, pos, _minor, options) {
  return new Token$2(Type.tag, readUint16(data2, pos + 1, options), 3);
}
function decodeTag32(data2, pos, _minor, options) {
  return new Token$2(Type.tag, readUint32(data2, pos + 1, options), 5);
}
function decodeTag64(data2, pos, _minor, options) {
  return new Token$2(Type.tag, readUint64(data2, pos + 1, options), 9);
}
function encodeTag(buf2, token2) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token2.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
const MINOR_FALSE = 20;
const MINOR_TRUE = 21;
const MINOR_NULL = 22;
const MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token$2(Type.null, null, 1);
  }
  return new Token$2(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token$2(Type.break, void 0, 1);
}
function createToken(value, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token$2(Type.float, value, bytes2);
}
function decodeFloat16(data2, pos, _minor, options) {
  return createToken(readFloat16(data2, pos + 1), 3, options);
}
function decodeFloat32(data2, pos, _minor, options) {
  return createToken(readFloat32(data2, pos + 1), 5, options);
}
function decodeFloat64(data2, pos, _minor, options) {
  return createToken(readFloat64(data2, pos + 1), 9, options);
}
function encodeFloat(buf2, token2, options) {
  const float2 = token2.value;
  if (float2 === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float2 === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float2 === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float2 === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float2);
      decoded = readFloat16(ui8a, 1);
      if (float2 === decoded || Number.isNaN(float2)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float2);
        decoded = readFloat32(ui8a, 1);
        if (float2 === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float2);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token2, options) {
  const float2 = token2.value;
  if (float2 === false || float2 === true || float2 === null || float2 === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float2);
    let decoded = readFloat16(ui8a, 1);
    if (float2 === decoded || Number.isNaN(float2)) {
      return 3;
    }
    encodeFloat32(float2);
    decoded = readFloat32(ui8a, 1);
    if (float2 === decoded) {
      return 5;
    }
  }
  return 9;
};
const buffer$2 = new ArrayBuffer(9);
const dataView = new DataView(buffer$2, 1);
const ui8a = new Uint8Array(buffer$2, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp3 = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp3 === 0) {
    val = mant * 2 ** -24;
  } else if (exp3 !== 31) {
    val = (mant + 1024) * 2 ** (exp3 - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;
function invalidMinor(data2, pos, minor2) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor2}) for major ${data2[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
const jump = [];
for (let i3 = 0; i3 <= 23; i3++) {
  jump[i3] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i3 = 32; i3 <= 55; i3++) {
  jump[i3] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i3 = 64; i3 <= 87; i3++) {
  jump[i3] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i3 = 96; i3 <= 119; i3++) {
  jump[i3] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i3 = 128; i3 <= 151; i3++) {
  jump[i3] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i3 = 160; i3 <= 183; i3++) {
  jump[i3] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i3 = 192; i3 <= 215; i3++) {
  jump[i3] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i3 = 224; i3 <= 243; i3++) {
  jump[i3] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
const quick = [];
for (let i3 = 0; i3 < 24; i3++) {
  quick[i3] = new Token$2(Type.uint, i3, 1);
}
for (let i3 = -1; i3 >= -24; i3--) {
  quick[31 - i3] = new Token$2(Type.negint, i3, 1);
}
quick[64] = new Token$2(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token$2(Type.string, "", 1);
quick[128] = new Token$2(Type.array, 0, 1);
quick[160] = new Token$2(Type.map, 0, 1);
quick[244] = new Token$2(Type.false, false, 1);
quick[245] = new Token$2(Type.true, true, 1);
quick[246] = new Token$2(Type.null, null, 1);
function quickEncodeToken(token2) {
  switch (token2.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token2.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token2.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token2.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token2.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token2.value < 24) {
        return fromArray([Number(token2.value)]);
      }
      return;
    case Type.negint:
      if (token2.value >= -24) {
        return fromArray([31 - Number(token2.value)]);
      }
  }
}
const defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
const cborEncoders = makeCborEncoders();
const buf = new Bl();
class Ref {
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p3 = this;
    do {
      if (p3.obj === obj) {
        return true;
      }
    } while (p3 = p3.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
}
const simpleTokens = {
  null: new Token$2(Type.null, null),
  undefined: new Token$2(Type.undefined, void 0),
  true: new Token$2(Type.true, true),
  false: new Token$2(Type.false, false),
  emptyArray: new Token$2(Type.array, 0),
  emptyMap: new Token$2(Type.map, 0)
};
const typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token$2(Type.float, obj);
    } else if (obj >= 0) {
      return new Token$2(Type.uint, obj);
    } else {
      return new Token$2(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token$2(Type.uint, obj);
    } else {
      return new Token$2(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token$2(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token$2(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token$2(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token$2(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token$2(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries2 = [];
    let i3 = 0;
    for (const e2 of obj) {
      entries2[i3++] = objectToTokens(e2, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token$2(Type.array, obj.length),
        entries2,
        new Token$2(Type.break)
      ];
    }
    return [
      new Token$2(Type.array, obj.length),
      entries2
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap2 = typ !== "Object";
    const keys2 = isMap2 ? obj.keys() : Object.keys(obj);
    const length2 = isMap2 ? obj.size : keys2.length;
    if (!length2) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token$2(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries2 = [];
    let i3 = 0;
    for (const key2 of keys2) {
      entries2[i3++] = [
        objectToTokens(key2, options, refStack),
        objectToTokens(isMap2 ? obj.get(key2) : obj[key2], options, refStack)
      ];
    }
    sortMapEntries(entries2, options);
    if (options.addBreakTokens) {
      return [
        new Token$2(Type.map, length2),
        entries2,
        new Token$2(Type.break)
      ];
    }
    return [
      new Token$2(Type.map, length2),
      entries2
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries2, options) {
  if (options.mapSorter) {
    entries2.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major2 = keyToken1.type.major;
  const tcmp = cborEncoders[major2].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token2 of tokens) {
      tokensToEncoded(buf2, token2, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data2, encoders, options) {
  const tokens = objectToTokens(data2, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size2 = encoder.encodedSize(tokens, options);
      const buf2 = new Bl(size2);
      encoder(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode$6(data2, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data2, cborEncoders, options);
}
const defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
class Tokeniser {
  constructor(data2, options = {}) {
    this.pos = 0;
    this.data = data2;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token2 = quick[byt];
    if (token2 === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor2 = byt & 31;
      token2 = decoder(this.data, this.pos, minor2, this.options);
    }
    this.pos += token2.encodedLength;
    return token2;
  }
}
const DONE = Symbol.for("DONE");
const BREAK$1 = Symbol.for("BREAK");
function tokenToArray(token2, tokeniser, options) {
  const arr2 = [];
  for (let i3 = 0; i3 < token2.value; i3++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK$1) {
      if (token2.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i3}, expected ${token2.value})`);
    }
    arr2[i3] = value;
  }
  return arr2;
}
function tokenToMap(token2, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m2 = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i3 = 0; i3 < token2.value; i3++) {
    const key2 = tokensToObject(tokeniser, options);
    if (key2 === BREAK$1) {
      if (token2.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key2 === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i3} [no key], expected ${token2.value})`);
    }
    if (useMaps !== true && typeof key2 !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key2})`);
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i3} [no value], expected ${token2.value})`);
    }
    if (useMaps) {
      m2.set(key2, value);
    } else {
      obj[key2] = value;
    }
  }
  return useMaps ? m2 : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token2 = tokeniser.next();
  if (token2.type === Type.break) {
    return BREAK$1;
  }
  if (token2.type.terminal) {
    return token2.value;
  }
  if (token2.type === Type.array) {
    return tokenToArray(token2, tokeniser, options);
  }
  if (token2.type === Type.map) {
    return tokenToMap(token2, tokeniser, options);
  }
  if (token2.type === Type.tag) {
    if (options.tags && typeof options.tags[token2.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token2.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token2.value})`);
  }
  throw new Error("unsupported");
}
function decode$5(data2, options) {
  if (!(data2 instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data2, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK$1) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
const CID_CBOR_TAG$3 = 42;
function cidEncoder$3(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token$2(Type.tag, CID_CBOR_TAG$3),
    new Token$2(Type.bytes, bytes2)
  ];
}
function undefinedEncoder$3() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder$3(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions$3 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder$3,
    undefined: undefinedEncoder$3,
    number: numberEncoder$3
  }
};
function cidDecoder$3(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
const decodeOptions$3 = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions$3.tags[CID_CBOR_TAG$3] = cidDecoder$3;
const encode$5 = (node2) => encode$6(node2, encodeOptions$3);
const decode$4 = (data2) => decode$5(data2, decodeOptions$3);
const CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
async function readVarint$1(reader2) {
  const bytes2 = await reader2.upTo(8);
  const i3 = varint$1.decode(bytes2);
  reader2.seek(varint$1.decode.bytes);
  return i3;
}
async function readHeader$1(reader2) {
  const length2 = await readVarint$1(reader2);
  if (length2 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader2.exactly(length2);
  reader2.seek(length2);
  const block2 = decode$4(header);
  if (block2 == null || Array.isArray(block2) || typeof block2 !== "object") {
    throw new Error("Invalid CAR header format");
  }
  if (block2.version !== 1) {
    if (typeof block2.version === "string") {
      throw new Error(`Invalid CAR version: "${block2.version}"`);
    }
    throw new Error(`Invalid CAR version: ${block2.version}`);
  }
  if (!Array.isArray(block2.roots)) {
    throw new Error("Invalid CAR header format");
  }
  if (Object.keys(block2).filter((p3) => p3 !== "roots" && p3 !== "version").length) {
    throw new Error("Invalid CAR header format");
  }
  return block2;
}
async function readMultihash(reader2) {
  const bytes2 = await reader2.upTo(8);
  varint$1.decode(bytes2);
  const codeLength = varint$1.decode.bytes;
  const length2 = varint$1.decode(bytes2.subarray(varint$1.decode.bytes));
  const lengthLength = varint$1.decode.bytes;
  const mhLength = codeLength + lengthLength + length2;
  const multihash = await reader2.exactly(mhLength);
  reader2.seek(mhLength);
  return multihash;
}
async function readCid(reader2) {
  const first2 = await reader2.exactly(2);
  if (first2[0] === CIDV0_BYTES.SHA2_256 && first2[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = await reader2.exactly(34);
    reader2.seek(34);
    const multihash2 = decode$e(bytes3);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version2 = await readVarint$1(reader2);
  if (version2 !== 1) {
    throw new Error(`Unexpected CID version (${version2})`);
  }
  const codec = await readVarint$1(reader2);
  const bytes2 = await readMultihash(reader2);
  const multihash = decode$e(bytes2);
  return CID.create(version2, codec, multihash);
}
async function readBlockHead(reader2) {
  const start = reader2.pos;
  let length2 = await readVarint$1(reader2);
  if (length2 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length2 += reader2.pos - start;
  const cid = await readCid(reader2);
  const blockLength = length2 - (reader2.pos - start);
  return {
    cid,
    length: length2,
    blockLength
  };
}
async function readBlock(reader2) {
  const { cid, blockLength } = await readBlockHead(reader2);
  const bytes2 = await reader2.exactly(blockLength);
  reader2.seek(blockLength);
  return {
    bytes: bytes2,
    cid
  };
}
async function readBlockIndex(reader2) {
  const offset = reader2.pos;
  const { cid, length: length2, blockLength } = await readBlockHead(reader2);
  const index2 = {
    cid,
    length: length2,
    blockLength,
    offset,
    blockOffset: reader2.pos
  };
  reader2.seek(index2.blockLength);
  return index2;
}
function createDecoder(reader2) {
  const headerPromise = readHeader$1(reader2);
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader2.upTo(8)).length > 0) {
        yield await readBlock(reader2);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader2.upTo(8)).length > 0) {
        yield await readBlockIndex(reader2);
      }
    }
  };
}
function bytesReader$1(bytes2) {
  let pos = 0;
  return {
    async upTo(length2) {
      return bytes2.subarray(pos, pos + Math.min(length2, bytes2.length - pos));
    },
    async exactly(length2) {
      if (length2 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes2.subarray(pos, pos + length2);
    },
    seek(length2) {
      pos += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read2 = async (length2) => {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length2) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p3, c2) => p3 + c2.length, 0));
    let off2 = 0;
    for (const b4 of bufa) {
      currentChunk.set(b4, off2);
      off2 += b4.length;
    }
    offset = 0;
  };
  return {
    async upTo(length2) {
      if (currentChunk.length - offset < length2) {
        await read2(length2);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length2));
    },
    async exactly(length2) {
      if (currentChunk.length - offset < length2) {
        await read2(length2);
      }
      if (currentChunk.length - offset < length2) {
        throw new Error("Unexpected end of data");
      }
      return currentChunk.subarray(offset, offset + length2);
    },
    seek(length2) {
      pos += length2;
      offset += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator2 = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator2.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
class CarReader {
  constructor(version2, roots2, blocks) {
    this._version = version2;
    this._roots = roots2;
    this._blocks = blocks;
    this._keys = blocks.map((b4) => b4.cid.toString());
  }
  get version() {
    return this._version;
  }
  async getRoots() {
    return this._roots;
  }
  async has(key2) {
    return this._keys.indexOf(key2.toString()) > -1;
  }
  async get(key2) {
    const index2 = this._keys.indexOf(key2.toString());
    return index2 > -1 ? this._blocks[index2] : void 0;
  }
  async *blocks() {
    for (const block2 of this._blocks) {
      yield block2;
    }
  }
  async *cids() {
    for (const block2 of this._blocks) {
      yield block2.cid;
    }
  }
  static async fromBytes(bytes2) {
    if (!(bytes2 instanceof Uint8Array)) {
      throw new TypeError("fromBytes() requires a Uint8Array");
    }
    return decodeReaderComplete(bytesReader$1(bytes2));
  }
  static async fromIterable(asyncIterable) {
    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
      throw new TypeError("fromIterable() requires an async iterable");
    }
    return decodeReaderComplete(asyncIterableReader(asyncIterable));
  }
}
async function decodeReaderComplete(reader2) {
  const decoder = createDecoder(reader2);
  const { version: version2, roots: roots2 } = await decoder.header();
  const blocks = [];
  for await (const block2 of decoder.blocks()) {
    blocks.push(block2);
  }
  return new CarReader(version2, roots2, blocks);
}
function createHeader$1(roots2) {
  const headerBytes = encode$5({
    version: 1,
    roots: roots2
  });
  const varintBytes = varint$1.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder$1(writer2) {
  return {
    async setRoots(roots2) {
      const bytes2 = createHeader$1(roots2);
      await writer2.write(bytes2);
    },
    async writeBlock(block2) {
      const { cid, bytes: bytes2 } = block2;
      await writer2.write(new Uint8Array(varint$1.encode(cid.bytes.length + bytes2.length)));
      await writer2.write(cid.bytes);
      if (bytes2.length) {
        await writer2.write(bytes2);
      }
    },
    async close() {
      return writer2.end();
    }
  };
}
function noop$2() {
}
function create$4() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop$2;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop$2;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop$2;
          resolve();
        };
      });
    }
    return drainer;
  };
  const writer2 = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    }
  };
  const iterator2 = {
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return {
          done: false,
          value: chunk
        };
      }
      if (ended) {
        drainerResolver();
        return {
          done: true,
          value: void 0
        };
      }
      if (!outWait) {
        outWait = new Promise((resolve) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop$2;
            return resolve(iterator2.next());
          };
        });
      }
      return outWait;
    }
  };
  return {
    writer: writer2,
    iterator: iterator2
  };
}
let CarWriter$1 = class CarWriter2 {
  constructor(roots2, encoder) {
    this._encoder = encoder;
    this._mutex = encoder.setRoots(roots2);
    this._ended = false;
  }
  async put(block2) {
    if (!(block2.bytes instanceof Uint8Array) || !block2.cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    if (this._ended) {
      throw new Error("Already closed");
    }
    const cid = CID.asCID(block2.cid);
    if (!cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    this._mutex = this._mutex.then(() => this._encoder.writeBlock({
      cid,
      bytes: block2.bytes
    }));
    return this._mutex;
  }
  async close() {
    if (this._ended) {
      throw new Error("Already closed");
    }
    await this._mutex;
    this._ended = true;
    return this._encoder.close();
  }
  static create(roots2) {
    roots2 = toRoots$1(roots2);
    const { encoder, iterator: iterator2 } = encodeWriter$1();
    const writer2 = new CarWriter2(roots2, encoder);
    const out = new CarWriterOut$1(iterator2);
    return {
      writer: writer2,
      out
    };
  }
  static createAppender() {
    const { encoder, iterator: iterator2 } = encodeWriter$1();
    encoder.setRoots = () => Promise.resolve();
    const writer2 = new CarWriter2([], encoder);
    const out = new CarWriterOut$1(iterator2);
    return {
      writer: writer2,
      out
    };
  }
  static async updateRootsInBytes(bytes2, roots2) {
    const reader2 = bytesReader$1(bytes2);
    await readHeader$1(reader2);
    const newHeader = createHeader$1(roots2);
    if (reader2.pos !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader2.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    bytes2.set(newHeader, 0);
    return bytes2;
  }
};
let CarWriterOut$1 = class CarWriterOut2 {
  constructor(iterator2) {
    this._iterator = iterator2;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
};
function encodeWriter$1() {
  const iw = create$4();
  const { writer: writer2, iterator: iterator2 } = iw;
  const encoder = createEncoder$1(writer2);
  return {
    encoder,
    iterator: iterator2
  };
}
function toRoots$1(roots2) {
  if (roots2 === void 0) {
    return [];
  }
  if (!Array.isArray(roots2)) {
    const cid = CID.asCID(roots2);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root2 of roots2) {
    const _root = CID.asCID(root2);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}
const readonly = ({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
});
const links = function* (source, base3) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key2, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key2
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index2, element] of value.entries()) {
          const elementPath = [
            ...path,
            index2
          ];
          const cid = CID.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid) {
          yield [
            path.join("/"),
            cid
          ];
        } else {
          yield* links(value, path);
        }
      }
    }
  }
};
const tree = function* (source, base3) {
  if (source == null)
    return;
  for (const [key2, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key2
    ];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
      if (Array.isArray(value)) {
        for (const [index2, element] of value.entries()) {
          const elementPath = [
            ...path,
            index2
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID.asCID(element)) {
            yield* tree(element, elementPath);
          }
        }
      } else {
        yield* tree(value, path);
      }
    }
  }
};
const get = (source, path) => {
  let node2 = source;
  for (const [index2, key2] of path.entries()) {
    node2 = node2[key2];
    if (node2 == null) {
      throw new Error(`Object has no property at ${path.slice(0, index2 + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node2);
    if (cid) {
      return {
        value: cid,
        remaining: path.slice(index2 + 1).join("/")
      };
    }
  }
  return { value: node2 };
};
class Block {
  constructor({ cid, bytes: bytes2, value }) {
    if (!cid || !bytes2 || typeof value === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid;
    this.bytes = bytes2;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly(),
      bytes: readonly(),
      value: readonly(),
      asBlock: readonly()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path = "/") {
    return get(this.value, path.split("/").filter(Boolean));
  }
}
const encode$4 = async ({ value, codec, hasher }) => {
  if (typeof value === "undefined")
    throw new Error('Missing required argument "value"');
  if (!codec || !hasher)
    throw new Error("Missing required argument: codec or hasher");
  const bytes2 = codec.encode(value);
  const hash2 = await hasher.digest(bytes2);
  const cid = CID.create(1, codec.code, hash2);
  return new Block({
    value,
    bytes: bytes2,
    cid
  });
};
const CID_CBOR_TAG$2 = 42;
function cidEncoder$2(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token$2(Type.tag, CID_CBOR_TAG$2),
    new Token$2(Type.bytes, bytes2)
  ];
}
function undefinedEncoder$2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder$2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions$2 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder$2,
    undefined: undefinedEncoder$2,
    number: numberEncoder$2
  }
};
function cidDecoder$2(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
const decodeOptions$2 = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions$2.tags[CID_CBOR_TAG$2] = cidDecoder$2;
const name$2 = "dag-cbor";
const code$2 = 113;
const encode$3 = (node2) => encode$6(node2, encodeOptions$2);
const decode$3 = (data2) => decode$5(data2, decodeOptions$2);
const cbor = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code: code$2,
  decode: decode$3,
  encode: encode$3,
  name: name$2
}, Symbol.toStringTag, { value: "Module" }));
const textDecoder = new TextDecoder();
function decodeVarint(bytes2, offset) {
  let v4 = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b4 = bytes2[offset++];
    v4 += shift < 28 ? (b4 & 127) << shift : (b4 & 127) * 2 ** shift;
    if (b4 < 128) {
      break;
    }
  }
  return [
    v4,
    offset
  ];
}
function decodeBytes(bytes2, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes2, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes2.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey(bytes2, index2) {
  let wire;
  [wire, index2] = decodeVarint(bytes2, index2);
  return [
    wire & 7,
    wire >> 3,
    index2
  ];
}
function decodeLink(bytes2) {
  const link = {};
  const l2 = bytes2.length;
  let index2 = 0;
  while (index2 < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index2] = decodeBytes(bytes2, index2);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      link.Name = textDecoder.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index2] = decodeVarint(bytes2, index2);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index2 > l2) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes2) {
  const l2 = bytes2.length;
  let index2 = 0;
  let links2;
  let linksBeforeData = false;
  let data2;
  while (index2 < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data2) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data2, index2] = decodeBytes(bytes2, index2);
      if (links2) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links2) {
        links2 = [];
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      links2.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index2 > l2) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node2 = {};
  if (data2) {
    node2.Data = data2;
  }
  node2.Links = links2 || [];
  return node2;
}
const textEncoder$1 = new TextEncoder();
const maxInt32 = 2 ** 32;
const maxUInt32 = 2 ** 31;
function encodeLink(link, bytes2) {
  let i3 = bytes2.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i3 = encodeVarint(bytes2, i3, link.Tsize) - 1;
    bytes2[i3] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder$1.encode(link.Name);
    i3 -= nameBytes.length;
    bytes2.set(nameBytes, i3);
    i3 = encodeVarint(bytes2, i3, nameBytes.length) - 1;
    bytes2[i3] = 18;
  }
  if (link.Hash) {
    i3 -= link.Hash.length;
    bytes2.set(link.Hash, i3);
    i3 = encodeVarint(bytes2, i3, link.Hash.length) - 1;
    bytes2[i3] = 10;
  }
  return bytes2.length - i3;
}
function encodeNode(node2) {
  const size2 = sizeNode(node2);
  const bytes2 = new Uint8Array(size2);
  let i3 = size2;
  if (node2.Data) {
    i3 -= node2.Data.length;
    bytes2.set(node2.Data, i3);
    i3 = encodeVarint(bytes2, i3, node2.Data.length) - 1;
    bytes2[i3] = 10;
  }
  if (node2.Links) {
    for (let index2 = node2.Links.length - 1; index2 >= 0; index2--) {
      const size3 = encodeLink(node2.Links[index2], bytes2.subarray(0, i3));
      i3 -= size3;
      i3 = encodeVarint(bytes2, i3, size3) - 1;
      bytes2[i3] = 18;
    }
  }
  return bytes2;
}
function sizeLink(link) {
  let n4 = 0;
  if (link.Hash) {
    const l2 = link.Hash.length;
    n4 += 1 + l2 + sov(l2);
  }
  if (typeof link.Name === "string") {
    const l2 = textEncoder$1.encode(link.Name).length;
    n4 += 1 + l2 + sov(l2);
  }
  if (typeof link.Tsize === "number") {
    n4 += 1 + sov(link.Tsize);
  }
  return n4;
}
function sizeNode(node2) {
  let n4 = 0;
  if (node2.Data) {
    const l2 = node2.Data.length;
    n4 += 1 + l2 + sov(l2);
  }
  if (node2.Links) {
    for (const link of node2.Links) {
      const l2 = sizeLink(link);
      n4 += 1 + l2 + sov(l2);
    }
  }
  return n4;
}
function encodeVarint(bytes2, offset, v4) {
  offset -= sov(v4);
  const base3 = offset;
  while (v4 >= maxUInt32) {
    bytes2[offset++] = v4 & 127 | 128;
    v4 /= 128;
  }
  while (v4 >= 128) {
    bytes2[offset++] = v4 & 127 | 128;
    v4 >>>= 7;
  }
  bytes2[offset] = v4;
  return base3;
}
function sov(x2) {
  if (x2 % 2 === 0) {
    x2++;
  }
  return Math.floor((len64(x2) + 6) / 7);
}
function len64(x2) {
  let n4 = 0;
  if (x2 >= maxInt32) {
    x2 = Math.floor(x2 / maxInt32);
    n4 = 32;
  }
  if (x2 >= 1 << 16) {
    x2 >>>= 16;
    n4 += 16;
  }
  if (x2 >= 1 << 8) {
    x2 >>>= 8;
    n4 += 8;
  }
  return n4 + len8tab[x2];
}
const len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];
const pbNodeProperties = [
  "Data",
  "Links"
];
const pbLinkProperties = [
  "Hash",
  "Name",
  "Tsize"
];
const textEncoder = new TextEncoder();
function linkComparator(a3, b4) {
  if (a3 === b4) {
    return 0;
  }
  const abuf = a3.Name ? textEncoder.encode(a3.Name) : [];
  const bbuf = b4.Name ? textEncoder.encode(b4.Name) : [];
  let x2 = abuf.length;
  let y3 = bbuf.length;
  for (let i3 = 0, len2 = Math.min(x2, y3); i3 < len2; ++i3) {
    if (abuf[i3] !== bbuf[i3]) {
      x2 = abuf[i3];
      y3 = bbuf[i3];
      break;
    }
  }
  return x2 < y3 ? -1 : y3 < x2 ? 1 : 0;
}
function hasOnlyProperties(node2, properties) {
  return !Object.keys(node2).some((p3) => !properties.includes(p3));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash2 = CID.asCID(link);
    if (!Hash2) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash: Hash2 };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e2) {
      throw new TypeError(`Invalid DAG-PB form: ${e2.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node2) {
  if (node2 instanceof Uint8Array || typeof node2 === "string") {
    node2 = { Data: node2 };
  }
  if (typeof node2 !== "object" || Array.isArray(node2)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node2.Data !== void 0) {
    if (typeof node2.Data === "string") {
      pbn.Data = textEncoder.encode(node2.Data);
    } else if (node2.Data instanceof Uint8Array) {
      pbn.Data = node2.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node2.Links !== void 0) {
    if (Array.isArray(node2.Links)) {
      pbn.Links = node2.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node2) {
  if (!node2 || typeof node2 !== "object" || Array.isArray(node2)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node2, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node2.Data !== void 0 && !(node2.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node2.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i3 = 0; i3 < node2.Links.length; i3++) {
    const link = node2.Links[i3];
    if (!link || typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i3 > 0 && linkComparator(link, node2.Links[i3 - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data2, links2 = []) {
  return prepare({
    Data: data2,
    Links: links2
  });
}
function createLink(name2, size2, cid) {
  return asLink({
    Hash: cid,
    Name: name2,
    Tsize: size2
  });
}
const name$1 = "dag-pb";
const code$1 = 112;
function encode$2(node2) {
  validate(node2);
  const pbn = {};
  if (node2.Links) {
    pbn.Links = node2.Links.map((l2) => {
      const link = {};
      if (l2.Hash) {
        link.Hash = l2.Hash.bytes;
      }
      if (l2.Name !== void 0) {
        link.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link.Tsize = l2.Tsize;
      }
      return link;
    });
  }
  if (node2.Data) {
    pbn.Data = node2.Data;
  }
  return encodeNode(pbn);
}
function decode$2(bytes2) {
  const pbn = decodeNode(bytes2);
  const node2 = {};
  if (pbn.Data) {
    node2.Data = pbn.Data;
  }
  if (pbn.Links) {
    node2.Links = pbn.Links.map((l2) => {
      const link = {};
      try {
        link.Hash = CID.decode(l2.Hash);
      } catch (e2) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l2.Name !== void 0) {
        link.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link.Tsize = l2.Tsize;
      }
      return link;
    });
  }
  return node2;
}
const dagPb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code: code$1,
  createLink,
  createNode,
  decode: decode$2,
  encode: encode$2,
  name: name$1,
  prepare,
  validate
}, Symbol.toStringTag, { value: "Module" }));
class TreewalkCarSplitter {
  constructor(reader2, targetSize, options = {}) {
    if (typeof targetSize !== "number" || targetSize <= 0) {
      throw new Error("invalid target chunk size");
    }
    this._reader = reader2;
    this._targetSize = targetSize;
    this._decoders = [
      dagPb,
      raw,
      cbor,
      ...options.decoders || []
    ];
  }
  async *cars() {
    const roots2 = await this._reader.getRoots();
    if (roots2.length !== 1)
      throw new Error(`unexpected number of roots: ${roots2.length}`);
    let channel;
    for await (const val of this._cars(roots2[0])) {
      channel = val.channel;
      if (val.out)
        yield val.out;
    }
    if (!channel) {
      throw new Error("missing CAR writer channel");
    }
    channel.writer.close();
    yield channel.out;
  }
  async _get(cid) {
    const rawBlock = await this._reader.get(cid);
    if (!rawBlock)
      throw new Error(`missing block for ${cid}`);
    const { bytes: bytes2 } = rawBlock;
    const decoder = this._decoders.find((d3) => d3.code === cid.code);
    if (!decoder)
      throw new Error(`missing decoder for ${cid.code}`);
    return new Block({
      cid,
      bytes: bytes2,
      value: decoder.decode(bytes2)
    });
  }
  async *_cars(cid, parents = [], channel = void 0) {
    const block2 = await this._get(cid);
    channel = channel || Object.assign(CarWriter$1.create(cid), { size: 0 });
    if (channel.size > 0 && channel.size + block2.bytes.byteLength >= this._targetSize) {
      channel.writer.close();
      const { out } = channel;
      channel = newCar(parents);
      yield {
        channel,
        out
      };
    }
    parents = parents.concat(block2);
    channel.size += block2.bytes.byteLength;
    channel.writer.put(block2);
    for (const [, cid2] of block2.links()) {
      for await (const val of this._cars(cid2, parents, channel)) {
        channel = val.channel;
        yield val;
      }
    }
    if (!channel) {
      throw new Error("missing CAR writer channel");
    }
    yield { channel };
  }
  static async fromIterable(iterable, targetSize, options) {
    const reader2 = await CarReader.fromIterable(iterable);
    return new TreewalkCarSplitter(reader2, targetSize, options);
  }
  static async fromBlob(blob, targetSize, options) {
    const buffer2 = await blob.arrayBuffer();
    const reader2 = await CarReader.fromBytes(new Uint8Array(buffer2));
    return new TreewalkCarSplitter(reader2, targetSize, options);
  }
}
function newCar(parents) {
  const ch2 = Object.assign(CarWriter$1.create(parents[0].cid), { size: parents.reduce((size2, b4) => size2 + b4.bytes.byteLength, 0) });
  for (const b4 of parents) {
    ch2.writer.put(b4);
  }
  return ch2;
}
const last = async (source) => {
  let res;
  for await (const entry of source) {
    res = entry;
  }
  return res;
};
var itLast = last;
const last$1 = /* @__PURE__ */ getDefaultExportFromCjs(itLast);
var itPipe = { exports: {} };
const rawPipe = (...fns) => {
  let res;
  while (fns.length) {
    res = fns.shift()(res);
  }
  return res;
};
const isIterable$1 = (obj) => obj && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
const isDuplex = (obj) => obj && typeof obj.sink === "function" && isIterable$1(obj.source);
const duplexPipelineFn = (duplex) => (source) => {
  duplex.sink(source);
  return duplex.source;
};
const pipe = (...fns) => {
  if (isDuplex(fns[0])) {
    const duplex = fns[0];
    fns[0] = () => duplex.source;
  } else if (isIterable$1(fns[0])) {
    const source = fns[0];
    fns[0] = () => source;
  }
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i3 = 1; i3 < fns.length - 1; i3++) {
      if (isDuplex(fns[i3])) {
        fns[i3] = duplexPipelineFn(fns[i3]);
      }
    }
  }
  return rawPipe(...fns);
};
itPipe.exports = pipe;
itPipe.exports.pipe = pipe;
itPipe.exports.rawPipe = rawPipe;
itPipe.exports.isIterable = isIterable$1;
itPipe.exports.isDuplex = isDuplex;
var itPipeExports = itPipe.exports;
const pipe$1 = /* @__PURE__ */ getDefaultExportFromCjs(itPipeExports);
const CID_CBOR_TAG$1 = 42;
function cidEncoder$1(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token$2(Type.tag, CID_CBOR_TAG$1),
    new Token$2(Type.bytes, bytes2)
  ];
}
function undefinedEncoder$1() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder$1(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions$1 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder$1,
    undefined: undefinedEncoder$1,
    number: numberEncoder$1
  }
};
function cidDecoder$1(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
const decodeOptions$1 = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions$1.tags[CID_CBOR_TAG$1] = cidDecoder$1;
const encode$1 = (node2) => encode$6(node2, encodeOptions$1);
const decode$1 = (data2) => decode$5(data2, decodeOptions$1);
async function readVarint(reader2) {
  const bytes2 = await reader2.upTo(8);
  const i3 = varint$1.decode(bytes2);
  reader2.seek(varint$1.decode.bytes);
  return i3;
}
async function readHeader(reader2) {
  const length2 = await readVarint(reader2);
  if (length2 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader2.exactly(length2);
  reader2.seek(length2);
  const block2 = decode$1(header);
  if (block2 == null || Array.isArray(block2) || typeof block2 !== "object") {
    throw new Error("Invalid CAR header format");
  }
  if (block2.version !== 1) {
    if (typeof block2.version === "string") {
      throw new Error(`Invalid CAR version: "${block2.version}"`);
    }
    throw new Error(`Invalid CAR version: ${block2.version}`);
  }
  if (!Array.isArray(block2.roots)) {
    throw new Error("Invalid CAR header format");
  }
  if (Object.keys(block2).filter((p3) => p3 !== "roots" && p3 !== "version").length) {
    throw new Error("Invalid CAR header format");
  }
  return block2;
}
function bytesReader(bytes2) {
  let pos = 0;
  return {
    async upTo(length2) {
      return bytes2.subarray(pos, pos + Math.min(length2, bytes2.length - pos));
    },
    async exactly(length2) {
      if (length2 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes2.subarray(pos, pos + length2);
    },
    seek(length2) {
      pos += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function createHeader(roots2) {
  const headerBytes = encode$1({
    version: 1,
    roots: roots2
  });
  const varintBytes = varint$1.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer2) {
  return {
    async setRoots(roots2) {
      const bytes2 = createHeader(roots2);
      await writer2.write(bytes2);
    },
    async writeBlock(block2) {
      const { cid, bytes: bytes2 } = block2;
      await writer2.write(new Uint8Array(varint$1.encode(cid.bytes.length + bytes2.length)));
      await writer2.write(cid.bytes);
      if (bytes2.length) {
        await writer2.write(bytes2);
      }
    },
    async close() {
      return writer2.end();
    }
  };
}
function noop$1() {
}
function create$3() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop$1;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop$1;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop$1;
          resolve();
        };
      });
    }
    return drainer;
  };
  const writer2 = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    }
  };
  const iterator2 = {
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return {
          done: false,
          value: chunk
        };
      }
      if (ended) {
        drainerResolver();
        return {
          done: true,
          value: void 0
        };
      }
      if (!outWait) {
        outWait = new Promise((resolve) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop$1;
            return resolve(iterator2.next());
          };
        });
      }
      return outWait;
    }
  };
  return {
    writer: writer2,
    iterator: iterator2
  };
}
class CarWriter {
  constructor(roots2, encoder) {
    this._encoder = encoder;
    this._mutex = encoder.setRoots(roots2);
    this._ended = false;
  }
  async put(block2) {
    if (!(block2.bytes instanceof Uint8Array) || !block2.cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    if (this._ended) {
      throw new Error("Already closed");
    }
    const cid = CID.asCID(block2.cid);
    if (!cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    this._mutex = this._mutex.then(() => this._encoder.writeBlock({
      cid,
      bytes: block2.bytes
    }));
    return this._mutex;
  }
  async close() {
    if (this._ended) {
      throw new Error("Already closed");
    }
    await this._mutex;
    this._ended = true;
    return this._encoder.close();
  }
  static create(roots2) {
    roots2 = toRoots(roots2);
    const { encoder, iterator: iterator2 } = encodeWriter();
    const writer2 = new CarWriter(roots2, encoder);
    const out = new CarWriterOut(iterator2);
    return {
      writer: writer2,
      out
    };
  }
  static createAppender() {
    const { encoder, iterator: iterator2 } = encodeWriter();
    encoder.setRoots = () => Promise.resolve();
    const writer2 = new CarWriter([], encoder);
    const out = new CarWriterOut(iterator2);
    return {
      writer: writer2,
      out
    };
  }
  static async updateRootsInBytes(bytes2, roots2) {
    const reader2 = bytesReader(bytes2);
    await readHeader(reader2);
    const newHeader = createHeader(roots2);
    if (reader2.pos !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader2.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    bytes2.set(newHeader, 0);
    return bytes2;
  }
}
class CarWriterOut {
  constructor(iterator2) {
    this._iterator = iterator2;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
}
function encodeWriter() {
  const iw = create$3();
  const { writer: writer2, iterator: iterator2 } = iw;
  const encoder = createEncoder(writer2);
  return {
    encoder,
    iterator: iterator2
  };
}
function toRoots(roots2) {
  if (roots2 === void 0) {
    return [];
  }
  if (!Array.isArray(roots2)) {
    const cid = CID.asCID(roots2);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root2 of roots2) {
    const _root = CID.asCID(root2);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}
async function* batch$1(source, size2 = 1) {
  let things = [];
  if (size2 < 1) {
    size2 = 1;
  }
  for await (const thing of source) {
    things.push(thing);
    while (things.length >= size2) {
      yield things.slice(0, size2);
      things = things.slice(size2);
    }
  }
  while (things.length) {
    yield things.slice(0, size2);
    things = things.slice(size2);
  }
}
var itBatch = batch$1;
const batch$2 = /* @__PURE__ */ getDefaultExportFromCjs(itBatch);
const itBatch$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: batch$2
}, [itBatch]);
const require$$0$g = /* @__PURE__ */ getAugmentedNamespace(itBatch$1);
const batch = require$$0$g;
async function* parallelBatch(source, size2 = 1) {
  for await (const tasks of batch(source, size2)) {
    const things = tasks.map(
      /**
       * @param {() => Promise<T>} p
       */
      (p3) => {
        return p3().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
      }
    );
    for (let i3 = 0; i3 < things.length; i3++) {
      const result = await things[i3];
      if (result.ok) {
        yield result.value;
      } else {
        throw result.err;
      }
    }
  }
}
var itParallelBatch = parallelBatch;
const parallelBatch$1 = /* @__PURE__ */ getDefaultExportFromCjs(itParallelBatch);
var isPlainObj = (value) => {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype2 = Object.getPrototypeOf(value);
  return prototype2 === null || prototype2 === Object.prototype;
};
const index$b = /* @__PURE__ */ getDefaultExportFromCjs(isPlainObj);
const isPlainObj$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$b
}, [isPlainObj]);
const require$$0$f = /* @__PURE__ */ getAugmentedNamespace(isPlainObj$1);
const isOptionObject = require$$0$f;
const { hasOwnProperty: hasOwnProperty$6 } = Object.prototype;
const { propertyIsEnumerable } = Object;
const defineProperty = (object2, name2, value) => Object.defineProperty(object2, name2, {
  value,
  writable: true,
  enumerable: true,
  configurable: true
});
const globalThis$1 = commonjsGlobal;
const defaultMergeOptions = {
  concatArrays: false,
  ignoreUndefined: false
};
const getEnumerableOwnPropertyKeys = (value) => {
  const keys2 = [];
  for (const key2 in value) {
    if (hasOwnProperty$6.call(value, key2)) {
      keys2.push(key2);
    }
  }
  if (Object.getOwnPropertySymbols) {
    const symbols = Object.getOwnPropertySymbols(value);
    for (const symbol2 of symbols) {
      if (propertyIsEnumerable.call(value, symbol2)) {
        keys2.push(symbol2);
      }
    }
  }
  return keys2;
};
function clone(value) {
  if (Array.isArray(value)) {
    return cloneArray(value);
  }
  if (isOptionObject(value)) {
    return cloneOptionObject(value);
  }
  return value;
}
function cloneArray(array2) {
  const result = array2.slice(0, 0);
  getEnumerableOwnPropertyKeys(array2).forEach((key2) => {
    defineProperty(result, key2, clone(array2[key2]));
  });
  return result;
}
function cloneOptionObject(object2) {
  const result = Object.getPrototypeOf(object2) === null ? /* @__PURE__ */ Object.create(null) : {};
  getEnumerableOwnPropertyKeys(object2).forEach((key2) => {
    defineProperty(result, key2, clone(object2[key2]));
  });
  return result;
}
const mergeKeys = (merged, source, keys2, config2) => {
  keys2.forEach((key2) => {
    if (typeof source[key2] === "undefined" && config2.ignoreUndefined) {
      return;
    }
    if (key2 in merged && merged[key2] !== Object.getPrototypeOf(merged)) {
      defineProperty(merged, key2, merge(merged[key2], source[key2], config2));
    } else {
      defineProperty(merged, key2, clone(source[key2]));
    }
  });
  return merged;
};
const concatArrays = (merged, source, config2) => {
  let result = merged.slice(0, 0);
  let resultIndex = 0;
  [merged, source].forEach((array2) => {
    const indices2 = [];
    for (let k3 = 0; k3 < array2.length; k3++) {
      if (!hasOwnProperty$6.call(array2, k3)) {
        continue;
      }
      indices2.push(String(k3));
      if (array2 === merged) {
        defineProperty(result, resultIndex++, array2[k3]);
      } else {
        defineProperty(result, resultIndex++, clone(array2[k3]));
      }
    }
    result = mergeKeys(result, array2, getEnumerableOwnPropertyKeys(array2).filter((key2) => !indices2.includes(key2)), config2);
  });
  return result;
};
function merge(merged, source, config2) {
  if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
    return concatArrays(merged, source, config2);
  }
  if (!isOptionObject(source) || !isOptionObject(merged)) {
    return clone(source);
  }
  return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
}
var mergeOptions$1 = function(...options) {
  const config2 = merge(clone(defaultMergeOptions), this !== globalThis$1 && this || {}, defaultMergeOptions);
  let merged = { _: {} };
  for (const option of options) {
    if (option === void 0) {
      continue;
    }
    if (!isOptionObject(option)) {
      throw new TypeError("`" + option + "` is not an Option Object");
    }
    merged = merge(merged, { _: option }, config2);
  }
  return merged._;
};
const mergeOptions$2 = /* @__PURE__ */ getDefaultExportFromCjs(mergeOptions$1);
var murmurHash3js$2 = { exports: {} };
(function(module2, exports2) {
  (function(root2, undefined$12) {
    var library = {
      "version": "3.0.0",
      "x86": {},
      "x64": {},
      "inputValidation": true
    };
    function _validBytes(bytes2) {
      if (!Array.isArray(bytes2) && !ArrayBuffer.isView(bytes2)) {
        return false;
      }
      for (var i3 = 0; i3 < bytes2.length; i3++) {
        if (!Number.isInteger(bytes2[i3]) || bytes2[i3] < 0 || bytes2[i3] > 255) {
          return false;
        }
      }
      return true;
    }
    function _x86Multiply(m2, n4) {
      return (m2 & 65535) * n4 + (((m2 >>> 16) * n4 & 65535) << 16);
    }
    function _x86Rotl(m2, n4) {
      return m2 << n4 | m2 >>> 32 - n4;
    }
    function _x86Fmix(h5) {
      h5 ^= h5 >>> 16;
      h5 = _x86Multiply(h5, 2246822507);
      h5 ^= h5 >>> 13;
      h5 = _x86Multiply(h5, 3266489909);
      h5 ^= h5 >>> 16;
      return h5;
    }
    function _x64Add(m2, n4) {
      m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
      n4 = [n4[0] >>> 16, n4[0] & 65535, n4[1] >>> 16, n4[1] & 65535];
      var o2 = [0, 0, 0, 0];
      o2[3] += m2[3] + n4[3];
      o2[2] += o2[3] >>> 16;
      o2[3] &= 65535;
      o2[2] += m2[2] + n4[2];
      o2[1] += o2[2] >>> 16;
      o2[2] &= 65535;
      o2[1] += m2[1] + n4[1];
      o2[0] += o2[1] >>> 16;
      o2[1] &= 65535;
      o2[0] += m2[0] + n4[0];
      o2[0] &= 65535;
      return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
    }
    function _x64Multiply(m2, n4) {
      m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
      n4 = [n4[0] >>> 16, n4[0] & 65535, n4[1] >>> 16, n4[1] & 65535];
      var o2 = [0, 0, 0, 0];
      o2[3] += m2[3] * n4[3];
      o2[2] += o2[3] >>> 16;
      o2[3] &= 65535;
      o2[2] += m2[2] * n4[3];
      o2[1] += o2[2] >>> 16;
      o2[2] &= 65535;
      o2[2] += m2[3] * n4[2];
      o2[1] += o2[2] >>> 16;
      o2[2] &= 65535;
      o2[1] += m2[1] * n4[3];
      o2[0] += o2[1] >>> 16;
      o2[1] &= 65535;
      o2[1] += m2[2] * n4[2];
      o2[0] += o2[1] >>> 16;
      o2[1] &= 65535;
      o2[1] += m2[3] * n4[1];
      o2[0] += o2[1] >>> 16;
      o2[1] &= 65535;
      o2[0] += m2[0] * n4[3] + m2[1] * n4[2] + m2[2] * n4[1] + m2[3] * n4[0];
      o2[0] &= 65535;
      return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
    }
    function _x64Rotl(m2, n4) {
      n4 %= 64;
      if (n4 === 32) {
        return [m2[1], m2[0]];
      } else if (n4 < 32) {
        return [m2[0] << n4 | m2[1] >>> 32 - n4, m2[1] << n4 | m2[0] >>> 32 - n4];
      } else {
        n4 -= 32;
        return [m2[1] << n4 | m2[0] >>> 32 - n4, m2[0] << n4 | m2[1] >>> 32 - n4];
      }
    }
    function _x64LeftShift(m2, n4) {
      n4 %= 64;
      if (n4 === 0) {
        return m2;
      } else if (n4 < 32) {
        return [m2[0] << n4 | m2[1] >>> 32 - n4, m2[1] << n4];
      } else {
        return [m2[1] << n4 - 32, 0];
      }
    }
    function _x64Xor(m2, n4) {
      return [m2[0] ^ n4[0], m2[1] ^ n4[1]];
    }
    function _x64Fmix(h5) {
      h5 = _x64Xor(h5, [0, h5[0] >>> 1]);
      h5 = _x64Multiply(h5, [4283543511, 3981806797]);
      h5 = _x64Xor(h5, [0, h5[0] >>> 1]);
      h5 = _x64Multiply(h5, [3301882366, 444984403]);
      h5 = _x64Xor(h5, [0, h5[0] >>> 1]);
      return h5;
    }
    library.x86.hash32 = function(bytes2, seed) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$12;
      }
      seed = seed || 0;
      var remainder = bytes2.length % 4;
      var blocks = bytes2.length - remainder;
      var h1 = seed;
      var k1 = 0;
      var c1 = 3432918353;
      var c2 = 461845907;
      for (var i3 = 0; i3 < blocks; i3 = i3 + 4) {
        k1 = bytes2[i3] | bytes2[i3 + 1] << 8 | bytes2[i3 + 2] << 16 | bytes2[i3 + 3] << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 13);
        h1 = _x86Multiply(h1, 5) + 3864292196;
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= bytes2[i3 + 2] << 16;
        case 2:
          k1 ^= bytes2[i3 + 1] << 8;
        case 1:
          k1 ^= bytes2[i3];
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes2.length;
      h1 = _x86Fmix(h1);
      return h1 >>> 0;
    };
    library.x86.hash128 = function(bytes2, seed) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$12;
      }
      seed = seed || 0;
      var remainder = bytes2.length % 16;
      var blocks = bytes2.length - remainder;
      var h1 = seed;
      var h22 = seed;
      var h32 = seed;
      var h42 = seed;
      var k1 = 0;
      var k22 = 0;
      var k3 = 0;
      var k4 = 0;
      var c1 = 597399067;
      var c2 = 2869860233;
      var c3 = 951274213;
      var c4 = 2716044179;
      for (var i3 = 0; i3 < blocks; i3 = i3 + 16) {
        k1 = bytes2[i3] | bytes2[i3 + 1] << 8 | bytes2[i3 + 2] << 16 | bytes2[i3 + 3] << 24;
        k22 = bytes2[i3 + 4] | bytes2[i3 + 5] << 8 | bytes2[i3 + 6] << 16 | bytes2[i3 + 7] << 24;
        k3 = bytes2[i3 + 8] | bytes2[i3 + 9] << 8 | bytes2[i3 + 10] << 16 | bytes2[i3 + 11] << 24;
        k4 = bytes2[i3 + 12] | bytes2[i3 + 13] << 8 | bytes2[i3 + 14] << 16 | bytes2[i3 + 15] << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 19);
        h1 += h22;
        h1 = _x86Multiply(h1, 5) + 1444728091;
        k22 = _x86Multiply(k22, c2);
        k22 = _x86Rotl(k22, 16);
        k22 = _x86Multiply(k22, c3);
        h22 ^= k22;
        h22 = _x86Rotl(h22, 17);
        h22 += h32;
        h22 = _x86Multiply(h22, 5) + 197830471;
        k3 = _x86Multiply(k3, c3);
        k3 = _x86Rotl(k3, 17);
        k3 = _x86Multiply(k3, c4);
        h32 ^= k3;
        h32 = _x86Rotl(h32, 15);
        h32 += h42;
        h32 = _x86Multiply(h32, 5) + 2530024501;
        k4 = _x86Multiply(k4, c4);
        k4 = _x86Rotl(k4, 18);
        k4 = _x86Multiply(k4, c1);
        h42 ^= k4;
        h42 = _x86Rotl(h42, 13);
        h42 += h1;
        h42 = _x86Multiply(h42, 5) + 850148119;
      }
      k1 = 0;
      k22 = 0;
      k3 = 0;
      k4 = 0;
      switch (remainder) {
        case 15:
          k4 ^= bytes2[i3 + 14] << 16;
        case 14:
          k4 ^= bytes2[i3 + 13] << 8;
        case 13:
          k4 ^= bytes2[i3 + 12];
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h42 ^= k4;
        case 12:
          k3 ^= bytes2[i3 + 11] << 24;
        case 11:
          k3 ^= bytes2[i3 + 10] << 16;
        case 10:
          k3 ^= bytes2[i3 + 9] << 8;
        case 9:
          k3 ^= bytes2[i3 + 8];
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h32 ^= k3;
        case 8:
          k22 ^= bytes2[i3 + 7] << 24;
        case 7:
          k22 ^= bytes2[i3 + 6] << 16;
        case 6:
          k22 ^= bytes2[i3 + 5] << 8;
        case 5:
          k22 ^= bytes2[i3 + 4];
          k22 = _x86Multiply(k22, c2);
          k22 = _x86Rotl(k22, 16);
          k22 = _x86Multiply(k22, c3);
          h22 ^= k22;
        case 4:
          k1 ^= bytes2[i3 + 3] << 24;
        case 3:
          k1 ^= bytes2[i3 + 2] << 16;
        case 2:
          k1 ^= bytes2[i3 + 1] << 8;
        case 1:
          k1 ^= bytes2[i3];
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes2.length;
      h22 ^= bytes2.length;
      h32 ^= bytes2.length;
      h42 ^= bytes2.length;
      h1 += h22;
      h1 += h32;
      h1 += h42;
      h22 += h1;
      h32 += h1;
      h42 += h1;
      h1 = _x86Fmix(h1);
      h22 = _x86Fmix(h22);
      h32 = _x86Fmix(h32);
      h42 = _x86Fmix(h42);
      h1 += h22;
      h1 += h32;
      h1 += h42;
      h22 += h1;
      h32 += h1;
      h42 += h1;
      return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h22 >>> 0).toString(16)).slice(-8) + ("00000000" + (h32 >>> 0).toString(16)).slice(-8) + ("00000000" + (h42 >>> 0).toString(16)).slice(-8);
    };
    library.x64.hash128 = function(bytes2, seed) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$12;
      }
      seed = seed || 0;
      var remainder = bytes2.length % 16;
      var blocks = bytes2.length - remainder;
      var h1 = [0, seed];
      var h22 = [0, seed];
      var k1 = [0, 0];
      var k22 = [0, 0];
      var c1 = [2277735313, 289559509];
      var c2 = [1291169091, 658871167];
      for (var i3 = 0; i3 < blocks; i3 = i3 + 16) {
        k1 = [bytes2[i3 + 4] | bytes2[i3 + 5] << 8 | bytes2[i3 + 6] << 16 | bytes2[i3 + 7] << 24, bytes2[i3] | bytes2[i3 + 1] << 8 | bytes2[i3 + 2] << 16 | bytes2[i3 + 3] << 24];
        k22 = [bytes2[i3 + 12] | bytes2[i3 + 13] << 8 | bytes2[i3 + 14] << 16 | bytes2[i3 + 15] << 24, bytes2[i3 + 8] | bytes2[i3 + 9] << 8 | bytes2[i3 + 10] << 16 | bytes2[i3 + 11] << 24];
        k1 = _x64Multiply(k1, c1);
        k1 = _x64Rotl(k1, 31);
        k1 = _x64Multiply(k1, c2);
        h1 = _x64Xor(h1, k1);
        h1 = _x64Rotl(h1, 27);
        h1 = _x64Add(h1, h22);
        h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
        k22 = _x64Multiply(k22, c2);
        k22 = _x64Rotl(k22, 33);
        k22 = _x64Multiply(k22, c1);
        h22 = _x64Xor(h22, k22);
        h22 = _x64Rotl(h22, 31);
        h22 = _x64Add(h22, h1);
        h22 = _x64Add(_x64Multiply(h22, [0, 5]), [0, 944331445]);
      }
      k1 = [0, 0];
      k22 = [0, 0];
      switch (remainder) {
        case 15:
          k22 = _x64Xor(k22, _x64LeftShift([0, bytes2[i3 + 14]], 48));
        case 14:
          k22 = _x64Xor(k22, _x64LeftShift([0, bytes2[i3 + 13]], 40));
        case 13:
          k22 = _x64Xor(k22, _x64LeftShift([0, bytes2[i3 + 12]], 32));
        case 12:
          k22 = _x64Xor(k22, _x64LeftShift([0, bytes2[i3 + 11]], 24));
        case 11:
          k22 = _x64Xor(k22, _x64LeftShift([0, bytes2[i3 + 10]], 16));
        case 10:
          k22 = _x64Xor(k22, _x64LeftShift([0, bytes2[i3 + 9]], 8));
        case 9:
          k22 = _x64Xor(k22, [0, bytes2[i3 + 8]]);
          k22 = _x64Multiply(k22, c2);
          k22 = _x64Rotl(k22, 33);
          k22 = _x64Multiply(k22, c1);
          h22 = _x64Xor(h22, k22);
        case 8:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i3 + 7]], 56));
        case 7:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i3 + 6]], 48));
        case 6:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i3 + 5]], 40));
        case 5:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i3 + 4]], 32));
        case 4:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i3 + 3]], 24));
        case 3:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i3 + 2]], 16));
        case 2:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i3 + 1]], 8));
        case 1:
          k1 = _x64Xor(k1, [0, bytes2[i3]]);
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
      }
      h1 = _x64Xor(h1, [0, bytes2.length]);
      h22 = _x64Xor(h22, [0, bytes2.length]);
      h1 = _x64Add(h1, h22);
      h22 = _x64Add(h22, h1);
      h1 = _x64Fmix(h1);
      h22 = _x64Fmix(h22);
      h1 = _x64Add(h1, h22);
      h22 = _x64Add(h22, h1);
      return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h22[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h22[1] >>> 0).toString(16)).slice(-8);
    };
    {
      if (module2.exports) {
        exports2 = module2.exports = library;
      }
      exports2.murmurHash3 = library;
    }
  })();
})(murmurHash3js$2, murmurHash3js$2.exports);
var murmurHash3jsExports = murmurHash3js$2.exports;
const murmurHash3js = /* @__PURE__ */ getDefaultExportFromCjs(murmurHash3jsExports);
const murmurHash3js$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: murmurHash3js
}, [murmurHash3jsExports]);
const require$$0$e = /* @__PURE__ */ getAugmentedNamespace(murmurHash3js$1);
var murmurhash3jsRevisited = require$$0$e;
const mur = /* @__PURE__ */ getDefaultExportFromCjs(murmurhash3jsRevisited);
const murmur3128 = from$1({
  name: "murmur3-128",
  code: 34,
  encode: (input) => fromHex(mur.x64.hash128(input))
});
async function hamtHashFn(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
}
const defaultOptions$1 = {
  chunker: "fixed",
  strategy: "balanced",
  rawLeaves: false,
  onlyHash: false,
  reduceSingleLeafToSelf: true,
  hasher: sha256$3,
  leafType: "file",
  cidVersion: 0,
  progress: () => () => {
  },
  shardSplitThreshold: 1e3,
  fileImportConcurrency: 50,
  blockWriteConcurrency: 10,
  minChunkSize: 262144,
  maxChunkSize: 262144,
  avgChunkSize: 262144,
  window: 16,
  polynomial: 17437180132763652,
  maxChildrenPerNode: 174,
  layerRepeat: 4,
  wrapWithDirectory: false,
  recursive: false,
  hidden: false,
  timeout: void 0,
  hamtHashFn,
  hamtHashCode: 34,
  hamtBucketBits: 8
};
const defaultOptions$2 = (options = {}) => {
  const defaults2 = mergeOptions$2.bind({ ignoreUndefined: true });
  return defaults2(defaultOptions$1, options);
};
function assign$1(obj, props) {
  for (const key2 in props) {
    Object.defineProperty(obj, key2, {
      value: props[key2],
      enumerable: true,
      configurable: true
    });
  }
  return obj;
}
function createError(err, code2, props) {
  if (!err || typeof err === "string") {
    throw new TypeError("Please pass an Error to err-code");
  }
  if (!props) {
    props = {};
  }
  if (typeof code2 === "object") {
    props = code2;
    code2 = "";
  }
  if (code2) {
    props.code = code2;
  }
  try {
    return assign$1(err, props);
  } catch (_3) {
    props.message = err.message;
    props.stack = err.stack;
    const ErrClass = function() {
    };
    ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
    const output = assign$1(new ErrClass(), props);
    return output;
  }
}
var errCode = createError;
const errCode$1 = /* @__PURE__ */ getDefaultExportFromCjs(errCode);
var indexMinimal$2 = {};
var minimal$1 = {};
var aspromise = asPromise;
function asPromise(fn2, ctx) {
  var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
  while (index2 < arguments.length)
    params[offset++] = arguments[index2++];
  return new Promise(function executor(resolve, reject) {
    params[offset] = function callback(err) {
      if (pending) {
        pending = false;
        if (err)
          reject(err);
        else {
          var params2 = new Array(arguments.length - 1), offset2 = 0;
          while (offset2 < params2.length)
            params2[offset2++] = arguments[offset2];
          resolve.apply(null, params2);
        }
      }
    };
    try {
      fn2.apply(ctx || null, params);
    } catch (err) {
      if (pending) {
        pending = false;
        reject(err);
      }
    }
  });
}
const index$a = /* @__PURE__ */ getDefaultExportFromCjs(aspromise);
const aspromise$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$a
}, [aspromise]);
const require$$0$d = /* @__PURE__ */ getAugmentedNamespace(aspromise$1);
var base64$2 = {};
(function(exports2) {
  var base642 = exports2;
  base642.length = function length2(string2) {
    var p3 = string2.length;
    if (!p3)
      return 0;
    var n4 = 0;
    while (--p3 % 4 > 1 && string2.charAt(p3) === "=")
      ++n4;
    return Math.ceil(string2.length * 3) / 4 - n4;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (var i3 = 0; i3 < 64; )
    s64[b64[i3] = i3 < 26 ? i3 + 65 : i3 < 52 ? i3 + 71 : i3 < 62 ? i3 - 4 : i3 - 59 | 43] = i3++;
  base642.encode = function encode5(buffer2, start, end2) {
    var parts = null, chunk = [];
    var i4 = 0, j2 = 0, t2;
    while (start < end2) {
      var b4 = buffer2[start++];
      switch (j2) {
        case 0:
          chunk[i4++] = b64[b4 >> 2];
          t2 = (b4 & 3) << 4;
          j2 = 1;
          break;
        case 1:
          chunk[i4++] = b64[t2 | b4 >> 4];
          t2 = (b4 & 15) << 2;
          j2 = 2;
          break;
        case 2:
          chunk[i4++] = b64[t2 | b4 >> 6];
          chunk[i4++] = b64[b4 & 63];
          j2 = 0;
          break;
      }
      if (i4 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i4 = 0;
      }
    }
    if (j2) {
      chunk[i4++] = b64[t2];
      chunk[i4++] = 61;
      if (j2 === 1)
        chunk[i4++] = 61;
    }
    if (parts) {
      if (i4)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i4)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i4));
  };
  var invalidEncoding = "invalid encoding";
  base642.decode = function decode2(string2, buffer2, offset) {
    var start = offset;
    var j2 = 0, t2;
    for (var i4 = 0; i4 < string2.length; ) {
      var c2 = string2.charCodeAt(i4++);
      if (c2 === 61 && j2 > 1)
        break;
      if ((c2 = s64[c2]) === void 0)
        throw Error(invalidEncoding);
      switch (j2) {
        case 0:
          t2 = c2;
          j2 = 1;
          break;
        case 1:
          buffer2[offset++] = t2 << 2 | (c2 & 48) >> 4;
          t2 = c2;
          j2 = 2;
          break;
        case 2:
          buffer2[offset++] = (t2 & 15) << 4 | (c2 & 60) >> 2;
          t2 = c2;
          j2 = 3;
          break;
        case 3:
          buffer2[offset++] = (t2 & 3) << 6 | c2;
          j2 = 0;
          break;
      }
    }
    if (j2 === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };
  base642.test = function test(string2) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
  };
})(base64$2);
const index$9 = /* @__PURE__ */ getDefaultExportFromCjs(base64$2);
const base64$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$9
}, [base64$2]);
const require$$1$6 = /* @__PURE__ */ getAugmentedNamespace(base64$1);
var eventemitter = EventEmitter;
function EventEmitter() {
  this._listeners = {};
}
EventEmitter.prototype.on = function on2(evt, fn2, ctx) {
  (this._listeners[evt] || (this._listeners[evt] = [])).push({
    fn: fn2,
    ctx: ctx || this
  });
  return this;
};
EventEmitter.prototype.off = function off(evt, fn2) {
  if (evt === void 0)
    this._listeners = {};
  else {
    if (fn2 === void 0)
      this._listeners[evt] = [];
    else {
      var listeners2 = this._listeners[evt];
      for (var i3 = 0; i3 < listeners2.length; )
        if (listeners2[i3].fn === fn2)
          listeners2.splice(i3, 1);
        else
          ++i3;
    }
  }
  return this;
};
EventEmitter.prototype.emit = function emit2(evt) {
  var listeners2 = this._listeners[evt];
  if (listeners2) {
    var args = [], i3 = 1;
    for (; i3 < arguments.length; )
      args.push(arguments[i3++]);
    for (i3 = 0; i3 < listeners2.length; )
      listeners2[i3].fn.apply(listeners2[i3++].ctx, args);
  }
  return this;
};
const index$8 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter);
const eventemitter$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$8
}, [eventemitter]);
const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(eventemitter$1);
var float = factory(factory);
function factory(exports2) {
  if (typeof Float32Array !== "undefined")
    (function() {
      var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le2 = f8b[3] === 128;
      function writeFloat_f32_cpy(val, buf2, pos) {
        f32[0] = val;
        buf2[pos] = f8b[0];
        buf2[pos + 1] = f8b[1];
        buf2[pos + 2] = f8b[2];
        buf2[pos + 3] = f8b[3];
      }
      function writeFloat_f32_rev(val, buf2, pos) {
        f32[0] = val;
        buf2[pos] = f8b[3];
        buf2[pos + 1] = f8b[2];
        buf2[pos + 2] = f8b[1];
        buf2[pos + 3] = f8b[0];
      }
      exports2.writeFloatLE = le2 ? writeFloat_f32_cpy : writeFloat_f32_rev;
      exports2.writeFloatBE = le2 ? writeFloat_f32_rev : writeFloat_f32_cpy;
      function readFloat_f32_cpy(buf2, pos) {
        f8b[0] = buf2[pos];
        f8b[1] = buf2[pos + 1];
        f8b[2] = buf2[pos + 2];
        f8b[3] = buf2[pos + 3];
        return f32[0];
      }
      function readFloat_f32_rev(buf2, pos) {
        f8b[3] = buf2[pos];
        f8b[2] = buf2[pos + 1];
        f8b[1] = buf2[pos + 2];
        f8b[0] = buf2[pos + 3];
        return f32[0];
      }
      exports2.readFloatLE = le2 ? readFloat_f32_cpy : readFloat_f32_rev;
      exports2.readFloatBE = le2 ? readFloat_f32_rev : readFloat_f32_cpy;
    })();
  else
    (function() {
      function writeFloat_ieee754(writeUint, val, buf2, pos) {
        var sign3 = val < 0 ? 1 : 0;
        if (sign3)
          val = -val;
        if (val === 0)
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf2, pos);
        else if (isNaN(val))
          writeUint(2143289344, buf2, pos);
        else if (val > 34028234663852886e22)
          writeUint((sign3 << 31 | 2139095040) >>> 0, buf2, pos);
        else if (val < 11754943508222875e-54)
          writeUint((sign3 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
        else {
          var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
          writeUint((sign3 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
        }
      }
      exports2.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
      exports2.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
      function readFloat_ieee754(readUint, buf2, pos) {
        var uint = readUint(buf2, pos), sign3 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
        return exponent === 255 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 1401298464324817e-60 * mantissa : sign3 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
      }
      exports2.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
      exports2.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
  if (typeof Float64Array !== "undefined")
    (function() {
      var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le2 = f8b[7] === 128;
      function writeDouble_f64_cpy(val, buf2, pos) {
        f64[0] = val;
        buf2[pos] = f8b[0];
        buf2[pos + 1] = f8b[1];
        buf2[pos + 2] = f8b[2];
        buf2[pos + 3] = f8b[3];
        buf2[pos + 4] = f8b[4];
        buf2[pos + 5] = f8b[5];
        buf2[pos + 6] = f8b[6];
        buf2[pos + 7] = f8b[7];
      }
      function writeDouble_f64_rev(val, buf2, pos) {
        f64[0] = val;
        buf2[pos] = f8b[7];
        buf2[pos + 1] = f8b[6];
        buf2[pos + 2] = f8b[5];
        buf2[pos + 3] = f8b[4];
        buf2[pos + 4] = f8b[3];
        buf2[pos + 5] = f8b[2];
        buf2[pos + 6] = f8b[1];
        buf2[pos + 7] = f8b[0];
      }
      exports2.writeDoubleLE = le2 ? writeDouble_f64_cpy : writeDouble_f64_rev;
      exports2.writeDoubleBE = le2 ? writeDouble_f64_rev : writeDouble_f64_cpy;
      function readDouble_f64_cpy(buf2, pos) {
        f8b[0] = buf2[pos];
        f8b[1] = buf2[pos + 1];
        f8b[2] = buf2[pos + 2];
        f8b[3] = buf2[pos + 3];
        f8b[4] = buf2[pos + 4];
        f8b[5] = buf2[pos + 5];
        f8b[6] = buf2[pos + 6];
        f8b[7] = buf2[pos + 7];
        return f64[0];
      }
      function readDouble_f64_rev(buf2, pos) {
        f8b[7] = buf2[pos];
        f8b[6] = buf2[pos + 1];
        f8b[5] = buf2[pos + 2];
        f8b[4] = buf2[pos + 3];
        f8b[3] = buf2[pos + 4];
        f8b[2] = buf2[pos + 5];
        f8b[1] = buf2[pos + 6];
        f8b[0] = buf2[pos + 7];
        return f64[0];
      }
      exports2.readDoubleLE = le2 ? readDouble_f64_cpy : readDouble_f64_rev;
      exports2.readDoubleBE = le2 ? readDouble_f64_rev : readDouble_f64_cpy;
    })();
  else
    (function() {
      function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
        var sign3 = val < 0 ? 1 : 0;
        if (sign3)
          val = -val;
        if (val === 0) {
          writeUint(0, buf2, pos + off0);
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf2, pos + off1);
        } else if (isNaN(val)) {
          writeUint(0, buf2, pos + off0);
          writeUint(2146959360, buf2, pos + off1);
        } else if (val > 17976931348623157e292) {
          writeUint(0, buf2, pos + off0);
          writeUint((sign3 << 31 | 2146435072) >>> 0, buf2, pos + off1);
        } else {
          var mantissa;
          if (val < 22250738585072014e-324) {
            mantissa = val / 5e-324;
            writeUint(mantissa >>> 0, buf2, pos + off0);
            writeUint((sign3 << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
          } else {
            var exponent = Math.floor(Math.log(val) / Math.LN2);
            if (exponent === 1024)
              exponent = 1023;
            mantissa = val * Math.pow(2, -exponent);
            writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
            writeUint((sign3 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
          }
        }
      }
      exports2.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
      exports2.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
      function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
        var lo = readUint(buf2, pos + off0), hi2 = readUint(buf2, pos + off1);
        var sign3 = (hi2 >> 31) * 2 + 1, exponent = hi2 >>> 20 & 2047, mantissa = 4294967296 * (hi2 & 1048575) + lo;
        return exponent === 2047 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 5e-324 * mantissa : sign3 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
      }
      exports2.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
      exports2.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
  return exports2;
}
function writeUintLE(val, buf2, pos) {
  buf2[pos] = val & 255;
  buf2[pos + 1] = val >>> 8 & 255;
  buf2[pos + 2] = val >>> 16 & 255;
  buf2[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf2, pos) {
  buf2[pos] = val >>> 24;
  buf2[pos + 1] = val >>> 16 & 255;
  buf2[pos + 2] = val >>> 8 & 255;
  buf2[pos + 3] = val & 255;
}
function readUintLE(buf2, pos) {
  return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
}
function readUintBE(buf2, pos) {
  return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
}
const index$7 = /* @__PURE__ */ getDefaultExportFromCjs(float);
const float$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$7
}, [float]);
const require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(float$1);
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (e2) {
  }
  return null;
}
const index$6 = /* @__PURE__ */ getDefaultExportFromCjs(inquire_1);
const inquire$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$6
}, [inquire_1]);
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(inquire$1);
var utf8$3 = {};
(function(exports2) {
  var utf82 = exports2;
  utf82.length = function utf8_length(string2) {
    var len2 = 0, c2 = 0;
    for (var i3 = 0; i3 < string2.length; ++i3) {
      c2 = string2.charCodeAt(i3);
      if (c2 < 128)
        len2 += 1;
      else if (c2 < 2048)
        len2 += 2;
      else if ((c2 & 64512) === 55296 && (string2.charCodeAt(i3 + 1) & 64512) === 56320) {
        ++i3;
        len2 += 4;
      } else
        len2 += 3;
    }
    return len2;
  };
  utf82.read = function utf8_read(buffer2, start, end2) {
    var len2 = end2 - start;
    if (len2 < 1)
      return "";
    var parts = null, chunk = [], i3 = 0, t2;
    while (start < end2) {
      t2 = buffer2[start++];
      if (t2 < 128)
        chunk[i3++] = t2;
      else if (t2 > 191 && t2 < 224)
        chunk[i3++] = (t2 & 31) << 6 | buffer2[start++] & 63;
      else if (t2 > 239 && t2 < 365) {
        t2 = ((t2 & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
        chunk[i3++] = 55296 + (t2 >> 10);
        chunk[i3++] = 56320 + (t2 & 1023);
      } else
        chunk[i3++] = (t2 & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
      if (i3 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i3 = 0;
      }
    }
    if (parts) {
      if (i3)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i3));
  };
  utf82.write = function utf8_write(string2, buffer2, offset) {
    var start = offset, c1, c2;
    for (var i3 = 0; i3 < string2.length; ++i3) {
      c1 = string2.charCodeAt(i3);
      if (c1 < 128) {
        buffer2[offset++] = c1;
      } else if (c1 < 2048) {
        buffer2[offset++] = c1 >> 6 | 192;
        buffer2[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i3 + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i3;
        buffer2[offset++] = c1 >> 18 | 240;
        buffer2[offset++] = c1 >> 12 & 63 | 128;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      } else {
        buffer2[offset++] = c1 >> 12 | 224;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  };
})(utf8$3);
const index$5 = /* @__PURE__ */ getDefaultExportFromCjs(utf8$3);
const utf8$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$5
}, [utf8$3]);
const require$$5$1 = /* @__PURE__ */ getAugmentedNamespace(utf8$2);
var pool_1 = pool;
function pool(alloc3, slice3, size2) {
  var SIZE = size2 || 8192;
  var MAX2 = SIZE >>> 1;
  var slab = null;
  var offset = SIZE;
  return function pool_alloc(size3) {
    if (size3 < 1 || size3 > MAX2)
      return alloc3(size3);
    if (offset + size3 > SIZE) {
      slab = alloc3(SIZE);
      offset = 0;
    }
    var buf2 = slice3.call(slab, offset, offset += size3);
    if (offset & 7)
      offset = (offset | 7) + 1;
    return buf2;
  };
}
const index$4 = /* @__PURE__ */ getDefaultExportFromCjs(pool_1);
const pool$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$4
}, [pool_1]);
const require$$6$1 = /* @__PURE__ */ getAugmentedNamespace(pool$1);
var longbits;
var hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1;
  longbits = LongBits2;
  var util2 = requireMinimal();
  function LongBits2(lo, hi2) {
    this.lo = lo >>> 0;
    this.hi = hi2 >>> 0;
  }
  var zero = LongBits2.zero = new LongBits2(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits2.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign3 = value < 0;
    if (sign3)
      value = -value;
    var lo = value >>> 0, hi2 = (value - lo) / 4294967296 >>> 0;
    if (sign3) {
      hi2 = ~hi2 >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi2 > 4294967295)
          hi2 = 0;
      }
    }
    return new LongBits2(lo, hi2);
  };
  LongBits2.from = function from2(value) {
    if (typeof value === "number")
      return LongBits2.fromNumber(value);
    if (util2.isString(value)) {
      if (util2.Long)
        value = util2.Long.fromString(value);
      else
        return LongBits2.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits2.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi2 = ~this.hi >>> 0;
      if (!lo)
        hi2 = hi2 + 1 >>> 0;
      return -(lo + hi2 * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits2.prototype.toLong = function toLong(unsigned) {
    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits2.fromHash = function fromHash(hash2) {
    if (hash2 === zeroHash)
      return zero;
    return new LongBits2(
      (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
      (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
    );
  };
  LongBits2.prototype.toHash = function toHash() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  };
  LongBits2.prototype.zzEncode = function zzEncode() {
    var mask2 = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask2) >>> 0;
    this.lo = (this.lo << 1 ^ mask2) >>> 0;
    return this;
  };
  LongBits2.prototype.zzDecode = function zzDecode() {
    var mask2 = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask2) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask2) >>> 0;
    return this;
  };
  LongBits2.prototype.length = function length2() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
  return longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  if (hasRequiredMinimal)
    return minimal$1;
  hasRequiredMinimal = 1;
  (function(exports2) {
    var util2 = exports2;
    util2.asPromise = require$$0$d;
    util2.base64 = require$$1$6;
    util2.EventEmitter = require$$2$1;
    util2.float = require$$3$1;
    util2.inquire = require$$4;
    util2.utf8 = require$$5$1;
    util2.pool = require$$6$1;
    util2.LongBits = requireLongbits();
    util2.isNode = Boolean(typeof commonjsGlobal !== "undefined" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);
    util2.global = util2.isNode && commonjsGlobal || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger2(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util2.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util2.isSet = function isSet2(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util2.LongBits.fromHash(hash2);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge3(dst, src2, ifNotSet) {
      for (var keys2 = Object.keys(src2), i3 = 0; i3 < keys2.length; ++i3)
        if (dst[keys2[i3]] === void 0 || !ifNotSet)
          dst[keys2[i3]] = src2[keys2[i3]];
      return dst;
    }
    util2.merge = merge3;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge3(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name2;
      } });
      CustomError.prototype.toString = function toString3() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i3 = 0; i3 < fieldNames.length; ++i3)
        fieldMap[fieldNames[i3]] = 1;
      return function() {
        for (var keys2 = Object.keys(this), i4 = keys2.length - 1; i4 > -1; --i4)
          if (fieldMap[keys2[i4]] === 1 && this[keys2[i4]] !== void 0 && this[keys2[i4]] !== null)
            return keys2[i4];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i3 = 0; i3 < fieldNames.length; ++i3)
          if (fieldNames[i3] !== name2)
            delete this[fieldNames[i3]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size2) {
        return new Buffer2(size2);
      };
    };
  })(minimal$1);
  return minimal$1;
}
var writer = Writer$1;
var util$4 = requireMinimal();
var BufferWriter$1;
var LongBits$1 = util$4.LongBits, base64 = util$4.base64, utf8$1 = util$4.utf8;
function Op(fn2, len2, val) {
  this.fn = fn2;
  this.len = len2;
  this.next = void 0;
  this.val = val;
}
function noop() {
}
function State(writer2) {
  this.head = writer2.head;
  this.tail = writer2.tail;
  this.len = writer2.len;
  this.next = writer2.states;
}
function Writer$1() {
  this.len = 0;
  this.head = new Op(noop, 0, 0);
  this.tail = this.head;
  this.states = null;
}
var create$2 = function create3() {
  return util$4.Buffer ? function create_buffer_setup() {
    return (Writer$1.create = function create_buffer() {
      return new BufferWriter$1();
    })();
  } : function create_array3() {
    return new Writer$1();
  };
};
Writer$1.create = create$2();
Writer$1.alloc = function alloc2(size2) {
  return new util$4.Array(size2);
};
if (util$4.Array !== Array)
  Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray);
Writer$1.prototype._push = function push2(fn2, len2, val) {
  this.tail = this.tail.next = new Op(fn2, len2, val);
  this.len += len2;
  return this;
};
function writeByte(val, buf2, pos) {
  buf2[pos] = val & 255;
}
function writeVarint32(val, buf2, pos) {
  while (val > 127) {
    buf2[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf2[pos] = val;
}
function VarintOp(len2, val) {
  this.len = len2;
  this.next = void 0;
  this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function write_uint32(value) {
  this.len += (this.tail = this.tail.next = new VarintOp(
    (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
    value
  )).len;
  return this;
};
Writer$1.prototype.int32 = function write_int32(value) {
  return value < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) : this.uint32(value);
};
Writer$1.prototype.sint32 = function write_sint32(value) {
  return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf2, pos) {
  while (val.hi) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf2[pos++] = val.lo;
}
Writer$1.prototype.uint64 = function write_uint64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function write_sint64(value) {
  var bits = LongBits$1.from(value).zzEncode();
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.bool = function write_bool(value) {
  return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf2, pos) {
  buf2[pos] = val & 255;
  buf2[pos + 1] = val >>> 8 & 255;
  buf2[pos + 2] = val >>> 16 & 255;
  buf2[pos + 3] = val >>> 24;
}
Writer$1.prototype.fixed32 = function write_fixed32(value) {
  return this._push(writeFixed32, 4, value >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function write_fixed64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function write_float(value) {
  return this._push(util$4.float.writeFloatLE, 4, value);
};
Writer$1.prototype.double = function write_double(value) {
  return this._push(util$4.float.writeDoubleLE, 8, value);
};
var writeBytes = util$4.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
  buf2.set(val, pos);
} : function writeBytes_for(val, buf2, pos) {
  for (var i3 = 0; i3 < val.length; ++i3)
    buf2[pos + i3] = val[i3];
};
Writer$1.prototype.bytes = function write_bytes(value) {
  var len2 = value.length >>> 0;
  if (!len2)
    return this._push(writeByte, 1, 0);
  if (util$4.isString(value)) {
    var buf2 = Writer$1.alloc(len2 = base64.length(value));
    base64.decode(value, buf2, 0);
    value = buf2;
  }
  return this.uint32(len2)._push(writeBytes, len2, value);
};
Writer$1.prototype.string = function write_string(value) {
  var len2 = utf8$1.length(value);
  return len2 ? this.uint32(len2)._push(utf8$1.write, len2, value) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function fork() {
  this.states = new State(this);
  this.head = this.tail = new Op(noop, 0, 0);
  this.len = 0;
  return this;
};
Writer$1.prototype.reset = function reset() {
  if (this.states) {
    this.head = this.states.head;
    this.tail = this.states.tail;
    this.len = this.states.len;
    this.states = this.states.next;
  } else {
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
  }
  return this;
};
Writer$1.prototype.ldelim = function ldelim() {
  var head = this.head, tail = this.tail, len2 = this.len;
  this.reset().uint32(len2);
  if (len2) {
    this.tail.next = head.next;
    this.tail = tail;
    this.len += len2;
  }
  return this;
};
Writer$1.prototype.finish = function finish() {
  var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
  while (head) {
    head.fn(head.val, buf2, pos);
    pos += head.len;
    head = head.next;
  }
  return buf2;
};
Writer$1._configure = function(BufferWriter_) {
  BufferWriter$1 = BufferWriter_;
  Writer$1.create = create$2();
  BufferWriter$1._configure();
};
const writer$1 = /* @__PURE__ */ getDefaultExportFromCjs(writer);
const writer$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: writer$1
}, [writer]);
const require$$0$c = /* @__PURE__ */ getAugmentedNamespace(writer$2);
var writer_buffer = BufferWriter;
var Writer = require$$0$c;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$3 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$3._Buffer_allocUnsafe;
  BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
    buf2.set(val, pos);
  } : function writeBytesBuffer_copy(val, buf2, pos) {
    if (val.copy)
      val.copy(buf2, pos, 0, val.length);
    else
      for (var i3 = 0; i3 < val.length; )
        buf2[pos++] = val[i3++];
  };
};
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
  if (util$3.isString(value))
    value = util$3._Buffer_from(value, "base64");
  var len2 = value.length >>> 0;
  this.uint32(len2);
  if (len2)
    this._push(BufferWriter.writeBytesBuffer, len2, value);
  return this;
};
function writeStringBuffer(val, buf2, pos) {
  if (val.length < 40)
    util$3.utf8.write(val, buf2, pos);
  else if (buf2.utf8Write)
    buf2.utf8Write(val, pos);
  else
    buf2.write(val, pos);
}
BufferWriter.prototype.string = function write_string_buffer(value) {
  var len2 = util$3.Buffer.byteLength(value);
  this.uint32(len2);
  if (len2)
    this._push(writeStringBuffer, len2, value);
  return this;
};
BufferWriter._configure();
const writer_buffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(writer_buffer);
const writer_buffer$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: writer_buffer$1
}, [writer_buffer]);
const require$$1$5 = /* @__PURE__ */ getAugmentedNamespace(writer_buffer$2);
var reader = Reader$1;
var util$2 = requireMinimal();
var BufferReader$1;
var LongBits = util$2.LongBits, utf8 = util$2.utf8;
function indexOutOfRange(reader2, writeLength) {
  return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
}
function Reader$1(buffer2) {
  this.buf = buffer2;
  this.pos = 0;
  this.len = buffer2.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
  if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
} : function create_array2(buffer2) {
  if (Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
};
var create$1 = function create4() {
  return util$2.Buffer ? function create_buffer_setup(buffer2) {
    return (Reader$1.create = function create_buffer(buffer3) {
      return util$2.Buffer.isBuffer(buffer3) ? new BufferReader$1(buffer3) : create_array(buffer3);
    })(buffer2);
  } : create_array;
};
Reader$1.create = create$1();
Reader$1.prototype._slice = util$2.Array.prototype.subarray || /* istanbul ignore next */
util$2.Array.prototype.slice;
Reader$1.prototype.uint32 = function read_uint32_setup() {
  var value = 4294967295;
  return function read_uint32() {
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value;
  };
}();
Reader$1.prototype.int32 = function read_int32() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function read_sint32() {
  var value = this.uint32();
  return value >>> 1 ^ -(value & 1) | 0;
};
function readLongVarint() {
  var bits = new LongBits(0, 0);
  var i3 = 0;
  if (this.len - this.pos > 4) {
    for (; i3 < 4; ++i3) {
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i3 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
    if (this.buf[this.pos++] < 128)
      return bits;
    i3 = 0;
  } else {
    for (; i3 < 3; ++i3) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i3 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i3 * 7) >>> 0;
    return bits;
  }
  if (this.len - this.pos > 4) {
    for (; i3 < 5; ++i3) {
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i3 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  } else {
    for (; i3 < 5; ++i3) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i3 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function read_bool() {
  return this.uint32() !== 0;
};
function readFixed32_end(buf2, end2) {
  return (buf2[end2 - 4] | buf2[end2 - 3] << 8 | buf2[end2 - 2] << 16 | buf2[end2 - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function read_fixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function read_sfixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function read_float() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readFloatLE(this.buf, this.pos);
  this.pos += 4;
  return value;
};
Reader$1.prototype.double = function read_double() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readDoubleLE(this.buf, this.pos);
  this.pos += 8;
  return value;
};
Reader$1.prototype.bytes = function read_bytes() {
  var length2 = this.uint32(), start = this.pos, end2 = this.pos + length2;
  if (end2 > this.len)
    throw indexOutOfRange(this, length2);
  this.pos += length2;
  if (Array.isArray(this.buf))
    return this.buf.slice(start, end2);
  return start === end2 ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end2);
};
Reader$1.prototype.string = function read_string() {
  var bytes2 = this.bytes();
  return utf8.read(bytes2, 0, bytes2.length);
};
Reader$1.prototype.skip = function skip2(length2) {
  if (typeof length2 === "number") {
    if (this.pos + length2 > this.len)
      throw indexOutOfRange(this, length2);
    this.pos += length2;
  } else {
    do {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    } while (this.buf[this.pos++] & 128);
  }
  return this;
};
Reader$1.prototype.skipType = function(wireType) {
  switch (wireType) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      while ((wireType = this.uint32() & 7) !== 4) {
        this.skipType(wireType);
      }
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + wireType + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(BufferReader_) {
  BufferReader$1 = BufferReader_;
  Reader$1.create = create$1();
  BufferReader$1._configure();
  var fn2 = util$2.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$2.merge(Reader$1.prototype, {
    int64: function read_int64() {
      return readLongVarint.call(this)[fn2](false);
    },
    uint64: function read_uint64() {
      return readLongVarint.call(this)[fn2](true);
    },
    sint64: function read_sint64() {
      return readLongVarint.call(this).zzDecode()[fn2](false);
    },
    fixed64: function read_fixed64() {
      return readFixed64.call(this)[fn2](true);
    },
    sfixed64: function read_sfixed64() {
      return readFixed64.call(this)[fn2](false);
    }
  });
};
const reader$1 = /* @__PURE__ */ getDefaultExportFromCjs(reader);
const reader$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: reader$1
}, [reader]);
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(reader$2);
var reader_buffer = BufferReader;
var Reader = require$$2;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$1 = requireMinimal();
function BufferReader(buffer2) {
  Reader.call(this, buffer2);
}
BufferReader._configure = function() {
  if (util$1.Buffer)
    BufferReader.prototype._slice = util$1.Buffer.prototype.slice;
};
BufferReader.prototype.string = function read_string_buffer() {
  var len2 = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len2, this.len));
};
BufferReader._configure();
const reader_buffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(reader_buffer);
const reader_buffer$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: reader_buffer$1
}, [reader_buffer]);
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(reader_buffer$2);
var rpc$2 = {};
var service = Service;
var util = requireMinimal();
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
function Service(rpcImpl, requestDelimited, responseDelimited) {
  if (typeof rpcImpl !== "function")
    throw TypeError("rpcImpl must be a function");
  util.EventEmitter.call(this);
  this.rpcImpl = rpcImpl;
  this.requestDelimited = Boolean(requestDelimited);
  this.responseDelimited = Boolean(responseDelimited);
}
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
  if (!request)
    throw TypeError("request must be specified");
  var self2 = this;
  if (!callback)
    return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
  if (!self2.rpcImpl) {
    setTimeout(function() {
      callback(Error("already ended"));
    }, 0);
    return void 0;
  }
  try {
    return self2.rpcImpl(
      method,
      requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
      function rpcCallback(err, response) {
        if (err) {
          self2.emit("error", err, method);
          return callback(err);
        }
        if (response === null) {
          self2.end(
            /* endedByRPC */
            true
          );
          return void 0;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      }
    );
  } catch (err) {
    self2.emit("error", err, method);
    setTimeout(function() {
      callback(err);
    }, 0);
    return void 0;
  }
};
Service.prototype.end = function end(endedByRPC) {
  if (this.rpcImpl) {
    if (!endedByRPC)
      this.rpcImpl(null, null, null);
    this.rpcImpl = null;
    this.emit("end").off();
  }
  return this;
};
const service$1 = /* @__PURE__ */ getDefaultExportFromCjs(service);
const service$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: service$1
}, [service]);
const require$$0$b = /* @__PURE__ */ getAugmentedNamespace(service$2);
(function(exports2) {
  var rpc2 = exports2;
  rpc2.Service = require$$0$b;
})(rpc$2);
const rpc = /* @__PURE__ */ getDefaultExportFromCjs(rpc$2);
const rpc$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: rpc
}, [rpc$2]);
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(rpc$1);
var roots = {};
const roots$1 = /* @__PURE__ */ getDefaultExportFromCjs(roots);
const roots$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: roots$1
}, [roots]);
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(roots$2);
(function(exports2) {
  var protobuf = exports2;
  protobuf.build = "minimal";
  protobuf.Writer = require$$0$c;
  protobuf.BufferWriter = require$$1$5;
  protobuf.Reader = require$$2;
  protobuf.BufferReader = require$$3;
  protobuf.util = requireMinimal();
  protobuf.rpc = require$$5;
  protobuf.roots = require$$6;
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
})(indexMinimal$2);
const indexMinimal = /* @__PURE__ */ getDefaultExportFromCjs(indexMinimal$2);
const indexMinimal$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: indexMinimal
}, [indexMinimal$2]);
const require$$0$a = /* @__PURE__ */ getAugmentedNamespace(indexMinimal$1);
var minimal = require$$0$a;
const $protobuf = /* @__PURE__ */ getDefaultExportFromCjs(minimal);
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
const $root = $protobuf.roots["ipfs-unixfs"] || ($protobuf.roots["ipfs-unixfs"] = {});
const Data = $root.Data = (() => {
  function Data2(p3) {
    this.blocksizes = [];
    if (p3) {
      for (var ks2 = Object.keys(p3), i3 = 0; i3 < ks2.length; ++i3)
        if (p3[ks2[i3]] != null)
          this[ks2[i3]] = p3[ks2[i3]];
    }
  }
  Data2.prototype.Type = 0;
  Data2.prototype.Data = $util.newBuffer([]);
  Data2.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.blocksizes = $util.emptyArray;
  Data2.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.mode = 0;
  Data2.prototype.mtime = null;
  Data2.encode = function encode5(m2, w3) {
    if (!w3)
      w3 = $Writer.create();
    w3.uint32(8).int32(m2.Type);
    if (m2.Data != null && Object.hasOwnProperty.call(m2, "Data"))
      w3.uint32(18).bytes(m2.Data);
    if (m2.filesize != null && Object.hasOwnProperty.call(m2, "filesize"))
      w3.uint32(24).uint64(m2.filesize);
    if (m2.blocksizes != null && m2.blocksizes.length) {
      for (var i3 = 0; i3 < m2.blocksizes.length; ++i3)
        w3.uint32(32).uint64(m2.blocksizes[i3]);
    }
    if (m2.hashType != null && Object.hasOwnProperty.call(m2, "hashType"))
      w3.uint32(40).uint64(m2.hashType);
    if (m2.fanout != null && Object.hasOwnProperty.call(m2, "fanout"))
      w3.uint32(48).uint64(m2.fanout);
    if (m2.mode != null && Object.hasOwnProperty.call(m2, "mode"))
      w3.uint32(56).uint32(m2.mode);
    if (m2.mtime != null && Object.hasOwnProperty.call(m2, "mtime"))
      $root.UnixTime.encode(m2.mtime, w3.uint32(66).fork()).ldelim();
    return w3;
  };
  Data2.decode = function decode2(r2, l2) {
    if (!(r2 instanceof $Reader))
      r2 = $Reader.create(r2);
    var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.Data();
    while (r2.pos < c2) {
      var t2 = r2.uint32();
      switch (t2 >>> 3) {
        case 1:
          m2.Type = r2.int32();
          break;
        case 2:
          m2.Data = r2.bytes();
          break;
        case 3:
          m2.filesize = r2.uint64();
          break;
        case 4:
          if (!(m2.blocksizes && m2.blocksizes.length))
            m2.blocksizes = [];
          if ((t2 & 7) === 2) {
            var c22 = r2.uint32() + r2.pos;
            while (r2.pos < c22)
              m2.blocksizes.push(r2.uint64());
          } else
            m2.blocksizes.push(r2.uint64());
          break;
        case 5:
          m2.hashType = r2.uint64();
          break;
        case 6:
          m2.fanout = r2.uint64();
          break;
        case 7:
          m2.mode = r2.uint32();
          break;
        case 8:
          m2.mtime = $root.UnixTime.decode(r2, r2.uint32());
          break;
        default:
          r2.skipType(t2 & 7);
          break;
      }
    }
    if (!m2.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m2 });
    return m2;
  };
  Data2.fromObject = function fromObject(d3) {
    if (d3 instanceof $root.Data)
      return d3;
    var m2 = new $root.Data();
    switch (d3.Type) {
      case "Raw":
      case 0:
        m2.Type = 0;
        break;
      case "Directory":
      case 1:
        m2.Type = 1;
        break;
      case "File":
      case 2:
        m2.Type = 2;
        break;
      case "Metadata":
      case 3:
        m2.Type = 3;
        break;
      case "Symlink":
      case 4:
        m2.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m2.Type = 5;
        break;
    }
    if (d3.Data != null) {
      if (typeof d3.Data === "string")
        $util.base64.decode(d3.Data, m2.Data = $util.newBuffer($util.base64.length(d3.Data)), 0);
      else if (d3.Data.length)
        m2.Data = d3.Data;
    }
    if (d3.filesize != null) {
      if ($util.Long)
        (m2.filesize = $util.Long.fromValue(d3.filesize)).unsigned = true;
      else if (typeof d3.filesize === "string")
        m2.filesize = parseInt(d3.filesize, 10);
      else if (typeof d3.filesize === "number")
        m2.filesize = d3.filesize;
      else if (typeof d3.filesize === "object")
        m2.filesize = new $util.LongBits(d3.filesize.low >>> 0, d3.filesize.high >>> 0).toNumber(true);
    }
    if (d3.blocksizes) {
      if (!Array.isArray(d3.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m2.blocksizes = [];
      for (var i3 = 0; i3 < d3.blocksizes.length; ++i3) {
        if ($util.Long)
          (m2.blocksizes[i3] = $util.Long.fromValue(d3.blocksizes[i3])).unsigned = true;
        else if (typeof d3.blocksizes[i3] === "string")
          m2.blocksizes[i3] = parseInt(d3.blocksizes[i3], 10);
        else if (typeof d3.blocksizes[i3] === "number")
          m2.blocksizes[i3] = d3.blocksizes[i3];
        else if (typeof d3.blocksizes[i3] === "object")
          m2.blocksizes[i3] = new $util.LongBits(d3.blocksizes[i3].low >>> 0, d3.blocksizes[i3].high >>> 0).toNumber(true);
      }
    }
    if (d3.hashType != null) {
      if ($util.Long)
        (m2.hashType = $util.Long.fromValue(d3.hashType)).unsigned = true;
      else if (typeof d3.hashType === "string")
        m2.hashType = parseInt(d3.hashType, 10);
      else if (typeof d3.hashType === "number")
        m2.hashType = d3.hashType;
      else if (typeof d3.hashType === "object")
        m2.hashType = new $util.LongBits(d3.hashType.low >>> 0, d3.hashType.high >>> 0).toNumber(true);
    }
    if (d3.fanout != null) {
      if ($util.Long)
        (m2.fanout = $util.Long.fromValue(d3.fanout)).unsigned = true;
      else if (typeof d3.fanout === "string")
        m2.fanout = parseInt(d3.fanout, 10);
      else if (typeof d3.fanout === "number")
        m2.fanout = d3.fanout;
      else if (typeof d3.fanout === "object")
        m2.fanout = new $util.LongBits(d3.fanout.low >>> 0, d3.fanout.high >>> 0).toNumber(true);
    }
    if (d3.mode != null) {
      m2.mode = d3.mode >>> 0;
    }
    if (d3.mtime != null) {
      if (typeof d3.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m2.mtime = $root.UnixTime.fromObject(d3.mtime);
    }
    return m2;
  };
  Data2.toObject = function toObject2(m2, o2) {
    if (!o2)
      o2 = {};
    var d3 = {};
    if (o2.arrays || o2.defaults) {
      d3.blocksizes = [];
    }
    if (o2.defaults) {
      d3.Type = o2.enums === String ? "Raw" : 0;
      if (o2.bytes === String)
        d3.Data = "";
      else {
        d3.Data = [];
        if (o2.bytes !== Array)
          d3.Data = $util.newBuffer(d3.Data);
      }
      if ($util.Long) {
        var n4 = new $util.Long(0, 0, true);
        d3.filesize = o2.longs === String ? n4.toString() : o2.longs === Number ? n4.toNumber() : n4;
      } else
        d3.filesize = o2.longs === String ? "0" : 0;
      if ($util.Long) {
        var n4 = new $util.Long(0, 0, true);
        d3.hashType = o2.longs === String ? n4.toString() : o2.longs === Number ? n4.toNumber() : n4;
      } else
        d3.hashType = o2.longs === String ? "0" : 0;
      if ($util.Long) {
        var n4 = new $util.Long(0, 0, true);
        d3.fanout = o2.longs === String ? n4.toString() : o2.longs === Number ? n4.toNumber() : n4;
      } else
        d3.fanout = o2.longs === String ? "0" : 0;
      d3.mode = 0;
      d3.mtime = null;
    }
    if (m2.Type != null && m2.hasOwnProperty("Type")) {
      d3.Type = o2.enums === String ? $root.Data.DataType[m2.Type] : m2.Type;
    }
    if (m2.Data != null && m2.hasOwnProperty("Data")) {
      d3.Data = o2.bytes === String ? $util.base64.encode(m2.Data, 0, m2.Data.length) : o2.bytes === Array ? Array.prototype.slice.call(m2.Data) : m2.Data;
    }
    if (m2.filesize != null && m2.hasOwnProperty("filesize")) {
      if (typeof m2.filesize === "number")
        d3.filesize = o2.longs === String ? String(m2.filesize) : m2.filesize;
      else
        d3.filesize = o2.longs === String ? $util.Long.prototype.toString.call(m2.filesize) : o2.longs === Number ? new $util.LongBits(m2.filesize.low >>> 0, m2.filesize.high >>> 0).toNumber(true) : m2.filesize;
    }
    if (m2.blocksizes && m2.blocksizes.length) {
      d3.blocksizes = [];
      for (var j2 = 0; j2 < m2.blocksizes.length; ++j2) {
        if (typeof m2.blocksizes[j2] === "number")
          d3.blocksizes[j2] = o2.longs === String ? String(m2.blocksizes[j2]) : m2.blocksizes[j2];
        else
          d3.blocksizes[j2] = o2.longs === String ? $util.Long.prototype.toString.call(m2.blocksizes[j2]) : o2.longs === Number ? new $util.LongBits(m2.blocksizes[j2].low >>> 0, m2.blocksizes[j2].high >>> 0).toNumber(true) : m2.blocksizes[j2];
      }
    }
    if (m2.hashType != null && m2.hasOwnProperty("hashType")) {
      if (typeof m2.hashType === "number")
        d3.hashType = o2.longs === String ? String(m2.hashType) : m2.hashType;
      else
        d3.hashType = o2.longs === String ? $util.Long.prototype.toString.call(m2.hashType) : o2.longs === Number ? new $util.LongBits(m2.hashType.low >>> 0, m2.hashType.high >>> 0).toNumber(true) : m2.hashType;
    }
    if (m2.fanout != null && m2.hasOwnProperty("fanout")) {
      if (typeof m2.fanout === "number")
        d3.fanout = o2.longs === String ? String(m2.fanout) : m2.fanout;
      else
        d3.fanout = o2.longs === String ? $util.Long.prototype.toString.call(m2.fanout) : o2.longs === Number ? new $util.LongBits(m2.fanout.low >>> 0, m2.fanout.high >>> 0).toNumber(true) : m2.fanout;
    }
    if (m2.mode != null && m2.hasOwnProperty("mode")) {
      d3.mode = m2.mode;
    }
    if (m2.mtime != null && m2.hasOwnProperty("mtime")) {
      d3.mtime = $root.UnixTime.toObject(m2.mtime, o2);
    }
    return d3;
  };
  Data2.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  Data2.DataType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Raw"] = 0;
    values[valuesById[1] = "Directory"] = 1;
    values[valuesById[2] = "File"] = 2;
    values[valuesById[3] = "Metadata"] = 3;
    values[valuesById[4] = "Symlink"] = 4;
    values[valuesById[5] = "HAMTShard"] = 5;
    return values;
  }();
  return Data2;
})();
$root.UnixTime = (() => {
  function UnixTime(p3) {
    if (p3) {
      for (var ks2 = Object.keys(p3), i3 = 0; i3 < ks2.length; ++i3)
        if (p3[ks2[i3]] != null)
          this[ks2[i3]] = p3[ks2[i3]];
    }
  }
  UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime.prototype.FractionalNanoseconds = 0;
  UnixTime.encode = function encode5(m2, w3) {
    if (!w3)
      w3 = $Writer.create();
    w3.uint32(8).int64(m2.Seconds);
    if (m2.FractionalNanoseconds != null && Object.hasOwnProperty.call(m2, "FractionalNanoseconds"))
      w3.uint32(21).fixed32(m2.FractionalNanoseconds);
    return w3;
  };
  UnixTime.decode = function decode2(r2, l2) {
    if (!(r2 instanceof $Reader))
      r2 = $Reader.create(r2);
    var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.UnixTime();
    while (r2.pos < c2) {
      var t2 = r2.uint32();
      switch (t2 >>> 3) {
        case 1:
          m2.Seconds = r2.int64();
          break;
        case 2:
          m2.FractionalNanoseconds = r2.fixed32();
          break;
        default:
          r2.skipType(t2 & 7);
          break;
      }
    }
    if (!m2.hasOwnProperty("Seconds"))
      throw $util.ProtocolError("missing required 'Seconds'", { instance: m2 });
    return m2;
  };
  UnixTime.fromObject = function fromObject(d3) {
    if (d3 instanceof $root.UnixTime)
      return d3;
    var m2 = new $root.UnixTime();
    if (d3.Seconds != null) {
      if ($util.Long)
        (m2.Seconds = $util.Long.fromValue(d3.Seconds)).unsigned = false;
      else if (typeof d3.Seconds === "string")
        m2.Seconds = parseInt(d3.Seconds, 10);
      else if (typeof d3.Seconds === "number")
        m2.Seconds = d3.Seconds;
      else if (typeof d3.Seconds === "object")
        m2.Seconds = new $util.LongBits(d3.Seconds.low >>> 0, d3.Seconds.high >>> 0).toNumber();
    }
    if (d3.FractionalNanoseconds != null) {
      m2.FractionalNanoseconds = d3.FractionalNanoseconds >>> 0;
    }
    return m2;
  };
  UnixTime.toObject = function toObject2(m2, o2) {
    if (!o2)
      o2 = {};
    var d3 = {};
    if (o2.defaults) {
      if ($util.Long) {
        var n4 = new $util.Long(0, 0, false);
        d3.Seconds = o2.longs === String ? n4.toString() : o2.longs === Number ? n4.toNumber() : n4;
      } else
        d3.Seconds = o2.longs === String ? "0" : 0;
      d3.FractionalNanoseconds = 0;
    }
    if (m2.Seconds != null && m2.hasOwnProperty("Seconds")) {
      if (typeof m2.Seconds === "number")
        d3.Seconds = o2.longs === String ? String(m2.Seconds) : m2.Seconds;
      else
        d3.Seconds = o2.longs === String ? $util.Long.prototype.toString.call(m2.Seconds) : o2.longs === Number ? new $util.LongBits(m2.Seconds.low >>> 0, m2.Seconds.high >>> 0).toNumber() : m2.Seconds;
    }
    if (m2.FractionalNanoseconds != null && m2.hasOwnProperty("FractionalNanoseconds")) {
      d3.FractionalNanoseconds = m2.FractionalNanoseconds;
    }
    return d3;
  };
  UnixTime.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return UnixTime;
})();
$root.Metadata = (() => {
  function Metadata(p3) {
    if (p3) {
      for (var ks2 = Object.keys(p3), i3 = 0; i3 < ks2.length; ++i3)
        if (p3[ks2[i3]] != null)
          this[ks2[i3]] = p3[ks2[i3]];
    }
  }
  Metadata.prototype.MimeType = "";
  Metadata.encode = function encode5(m2, w3) {
    if (!w3)
      w3 = $Writer.create();
    if (m2.MimeType != null && Object.hasOwnProperty.call(m2, "MimeType"))
      w3.uint32(10).string(m2.MimeType);
    return w3;
  };
  Metadata.decode = function decode2(r2, l2) {
    if (!(r2 instanceof $Reader))
      r2 = $Reader.create(r2);
    var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.Metadata();
    while (r2.pos < c2) {
      var t2 = r2.uint32();
      switch (t2 >>> 3) {
        case 1:
          m2.MimeType = r2.string();
          break;
        default:
          r2.skipType(t2 & 7);
          break;
      }
    }
    return m2;
  };
  Metadata.fromObject = function fromObject(d3) {
    if (d3 instanceof $root.Metadata)
      return d3;
    var m2 = new $root.Metadata();
    if (d3.MimeType != null) {
      m2.MimeType = String(d3.MimeType);
    }
    return m2;
  };
  Metadata.toObject = function toObject2(m2, o2) {
    if (!o2)
      o2 = {};
    var d3 = {};
    if (o2.defaults) {
      d3.MimeType = "";
    }
    if (m2.MimeType != null && m2.hasOwnProperty("MimeType")) {
      d3.MimeType = m2.MimeType;
    }
    return d3;
  };
  Metadata.prototype.toJSON = function toJSON2() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Metadata;
})();
const PBData = Data;
const types = [
  "raw",
  "directory",
  "file",
  "metadata",
  "symlink",
  "hamt-sharded-directory"
];
const dirTypes = [
  "directory",
  "hamt-sharded-directory"
];
const DEFAULT_FILE_MODE = parseInt("0644", 8);
const DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
function parseMode(mode2) {
  if (mode2 == null) {
    return void 0;
  }
  if (typeof mode2 === "number") {
    return mode2 & 4095;
  }
  mode2 = mode2.toString();
  if (mode2.substring(0, 1) === "0") {
    return parseInt(mode2, 8) & 4095;
  }
  return parseInt(mode2, 10) & 4095;
}
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms2 = input.getTime();
    const secs = Math.floor(ms2 / 1e3);
    mtime = {
      secs,
      nsecs: (ms2 - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw errCode$1(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
class UnixFS {
  static unmarshal(marshaled) {
    const message = PBData.decode(marshaled);
    const decoded = PBData.toObject(message, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const data2 = new UnixFS({
      type: types[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime ? {
        secs: decoded.mtime.Seconds,
        nsecs: decoded.mtime.FractionalNanoseconds
      } : void 0
    });
    data2._originalMode = decoded.mode || 0;
    return data2;
  }
  constructor(options = { type: "file" }) {
    const { type: type2, data: data2, blockSizes, hashType, fanout, mtime, mode: mode2 } = options;
    if (type2 && !types.includes(type2)) {
      throw errCode$1(new Error("Type: " + type2 + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type2 || "file";
    this.data = data2;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes || [];
    this._originalMode = 0;
    this.mode = parseMode(mode2);
    if (mtime) {
      this.mtime = parseMtime(mtime);
      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0;
      }
    }
  }
  set mode(mode2) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    const parsedMode = parseMode(mode2);
    if (parsedMode !== void 0) {
      this._mode = parsedMode;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return Boolean(this.type && dirTypes.includes(this.type));
  }
  addBlockSize(size2) {
    this.blockSizes.push(size2);
  }
  removeBlockSize(index2) {
    this.blockSizes.splice(index2, 1);
  }
  fileSize() {
    if (this.isDirectory()) {
      return 0;
    }
    let sum = 0;
    this.blockSizes.forEach((size2) => {
      sum += size2;
    });
    if (this.data) {
      sum += this.data.length;
    }
    return sum;
  }
  marshal() {
    let type2;
    switch (this.type) {
      case "raw":
        type2 = PBData.DataType.Raw;
        break;
      case "directory":
        type2 = PBData.DataType.Directory;
        break;
      case "file":
        type2 = PBData.DataType.File;
        break;
      case "metadata":
        type2 = PBData.DataType.Metadata;
        break;
      case "symlink":
        type2 = PBData.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type2 = PBData.DataType.HAMTShard;
        break;
      default:
        throw errCode$1(new Error("Type: " + type2 + " is not valid"), "ERR_INVALID_TYPE");
    }
    let data2 = this.data;
    if (!this.data || !this.data.length) {
      data2 = void 0;
    }
    let mode2;
    if (this.mode != null) {
      mode2 = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
      if (mode2 === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode2 = void 0;
      }
      if (mode2 === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode2 = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      const parsed = parseMtime(this.mtime);
      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        };
        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds;
        }
      }
    }
    const pbData = {
      Type: type2,
      Data: data2,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode: mode2,
      mtime
    };
    return PBData.encode(pbData).finish();
  }
}
const persist = async (buffer2, blockstore, options) => {
  if (!options.codec) {
    options.codec = dagPb;
  }
  if (!options.hasher) {
    options.hasher = sha256$3;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === dagPb && options.hasher !== sha256$3) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer2, { signal: options.signal });
  }
  return cid;
};
const dirBuilder = async (item, blockstore, options) => {
  const unixfs = new UnixFS({
    type: "directory",
    mtime: item.mtime,
    mode: item.mode
  });
  const buffer2 = encode$2(prepare({ Data: unixfs.marshal() }));
  const cid = await persist(buffer2, blockstore, options);
  const path = item.path;
  return {
    cid,
    path,
    unixfs,
    size: buffer2.length
  };
};
const all = async (source) => {
  const arr2 = [];
  for await (const entry of source) {
    arr2.push(entry);
  }
  return arr2;
};
var itAll = all;
const all$1 = /* @__PURE__ */ getDefaultExportFromCjs(itAll);
async function flat(source, reduce2) {
  return reduce2(await all$1(source));
}
function balanced(source, reduce2, options) {
  return reduceToParents(source, reduce2, options);
}
async function reduceToParents(source, reduce2, options) {
  const roots2 = [];
  for await (const chunked of batch$2(source, options.maxChildrenPerNode)) {
    roots2.push(await reduce2(chunked));
  }
  if (roots2.length > 1) {
    return reduceToParents(roots2, reduce2, options);
  }
  return roots2[0];
}
async function trickleStream(source, reduce2, options) {
  const root2 = new Root(options.layerRepeat);
  let iteration = 0;
  let maxDepth = 1;
  let subTree = root2;
  for await (const layer of batch$2(source, options.maxChildrenPerNode)) {
    if (subTree.isFull()) {
      if (subTree !== root2) {
        root2.addChild(await subTree.reduce(reduce2));
      }
      if (iteration && iteration % options.layerRepeat === 0) {
        maxDepth++;
      }
      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
      iteration++;
    }
    subTree.append(layer);
  }
  if (subTree && subTree !== root2) {
    root2.addChild(await subTree.reduce(reduce2));
  }
  return root2.reduce(reduce2);
}
class SubTree {
  constructor(maxDepth, layerRepeat, iteration = 0) {
    this.maxDepth = maxDepth;
    this.layerRepeat = layerRepeat;
    this.currentDepth = 1;
    this.iteration = iteration;
    this.root = this.node = this.parent = {
      children: [],
      depth: this.currentDepth,
      maxDepth,
      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
    };
  }
  isFull() {
    if (!this.root.data) {
      return false;
    }
    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
      this._addNextNodeToParent(this.node);
      return false;
    }
    const distantRelative = this._findParent(this.node, this.currentDepth);
    if (distantRelative) {
      this._addNextNodeToParent(distantRelative);
      return false;
    }
    return true;
  }
  _addNextNodeToParent(parent) {
    this.parent = parent;
    const nextNode = {
      children: [],
      depth: parent.depth + 1,
      parent,
      maxDepth: this.maxDepth,
      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat
    };
    parent.children.push(nextNode);
    this.currentDepth = nextNode.depth;
    this.node = nextNode;
  }
  append(layer) {
    this.node.data = layer;
  }
  reduce(reduce2) {
    return this._reduce(this.root, reduce2);
  }
  async _reduce(node2, reduce2) {
    let children = [];
    if (node2.children.length) {
      children = await Promise.all(node2.children.filter((child) => child.data).map((child) => this._reduce(child, reduce2)));
    }
    return reduce2((node2.data || []).concat(children));
  }
  _findParent(node2, depth) {
    const parent = node2.parent;
    if (!parent || parent.depth === 0) {
      return;
    }
    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {
      return this._findParent(parent, depth);
    }
    return parent;
  }
}
class Root extends SubTree {
  constructor(layerRepeat) {
    super(0, layerRepeat);
    this.root.depth = 0;
    this.currentDepth = 1;
  }
  addChild(child) {
    this.root.children.push(child);
  }
  reduce(reduce2) {
    return reduce2((this.root.data || []).concat(this.root.children));
  }
}
async function* bufferImporter(file, block2, options) {
  for await (let buffer2 of file.content) {
    yield async () => {
      options.progress(buffer2.length, file.path);
      let unixfs;
      const opts = {
        codec: dagPb,
        cidVersion: options.cidVersion,
        hasher: options.hasher,
        onlyHash: options.onlyHash
      };
      if (options.rawLeaves) {
        opts.codec = raw;
        opts.cidVersion = 1;
      } else {
        unixfs = new UnixFS({
          type: options.leafType,
          data: buffer2
        });
        buffer2 = encode$2({
          Data: unixfs.marshal(),
          Links: []
        });
      }
      return {
        cid: await persist(buffer2, block2, opts),
        unixfs,
        size: buffer2.length
      };
    };
  }
}
const dagBuilders = {
  flat,
  balanced,
  trickle: trickleStream
};
async function* buildFileBatch(file, blockstore, options) {
  let count2 = -1;
  let previous;
  let bufferImporter$1;
  if (typeof options.bufferImporter === "function") {
    bufferImporter$1 = options.bufferImporter;
  } else {
    bufferImporter$1 = bufferImporter;
  }
  for await (const entry of parallelBatch$1(bufferImporter$1(file, blockstore, options), options.blockWriteConcurrency)) {
    count2++;
    if (count2 === 0) {
      previous = entry;
      continue;
    } else if (count2 === 1 && previous) {
      yield previous;
      previous = null;
    }
    yield entry;
  }
  if (previous) {
    previous.single = true;
    yield previous;
  }
}
const reduce = (file, blockstore, options) => {
  async function reducer(leaves) {
    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
      const leaf = leaves[0];
      if (file.mtime !== void 0 || file.mode !== void 0) {
        let buffer3 = await blockstore.get(leaf.cid);
        leaf.unixfs = new UnixFS({
          type: "file",
          mtime: file.mtime,
          mode: file.mode,
          data: buffer3
        });
        buffer3 = encode$2(prepare({ Data: leaf.unixfs.marshal() }));
        leaf.cid = await persist(buffer3, blockstore, {
          ...options,
          codec: dagPb,
          hasher: options.hasher,
          cidVersion: options.cidVersion
        });
        leaf.size = buffer3.length;
      }
      return {
        cid: leaf.cid,
        path: file.path,
        unixfs: leaf.unixfs,
        size: leaf.size
      };
    }
    const f4 = new UnixFS({
      type: "file",
      mtime: file.mtime,
      mode: file.mode
    });
    const links2 = leaves.filter((leaf) => {
      if (leaf.cid.code === code$4 && leaf.size) {
        return true;
      }
      if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
        return true;
      }
      return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
    }).map((leaf) => {
      if (leaf.cid.code === code$4) {
        f4.addBlockSize(leaf.size);
        return {
          Name: "",
          Tsize: leaf.size,
          Hash: leaf.cid
        };
      }
      if (!leaf.unixfs || !leaf.unixfs.data) {
        f4.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
      } else {
        f4.addBlockSize(leaf.unixfs.data.length);
      }
      return {
        Name: "",
        Tsize: leaf.size,
        Hash: leaf.cid
      };
    });
    const node2 = {
      Data: f4.marshal(),
      Links: links2
    };
    const buffer2 = encode$2(prepare(node2));
    const cid = await persist(buffer2, blockstore, options);
    return {
      cid,
      path: file.path,
      unixfs: f4,
      size: buffer2.length + node2.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
    };
  }
  return reducer;
};
function fileBuilder(file, block2, options) {
  const dagBuilder2 = dagBuilders[options.strategy];
  if (!dagBuilder2) {
    throw errCode$1(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
  }
  return dagBuilder2(buildFileBatch(file, block2, options), reduce(file, block2, options), options);
}
var buffer$1 = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base642 = require$$0$1b;
  const ieee7542 = require$$1$G;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr2 = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr2, proto);
      return arr2.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf2 = new Uint8Array(length2);
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    const b4 = fromObject(value);
    if (b4)
      return b4;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc3(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc3(size2, fill, encoding);
  };
  function allocUnsafe2(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length2 = byteLength2(string2, encoding) | 0;
    let buf2 = createBuffer(length2);
    const actual = buf2.write(string2, encoding);
    if (actual !== length2) {
      buf2 = buf2.slice(0, actual);
    }
    return buf2;
  }
  function fromArrayLike(array2) {
    const length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
    const buf2 = createBuffer(length2);
    for (let i3 = 0; i3 < length2; i3 += 1) {
      buf2[i3] = array2[i3] & 255;
    }
    return buf2;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array2, byteOffset, length2) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf2;
    if (byteOffset === void 0 && length2 === void 0) {
      buf2 = new Uint8Array(array2);
    } else if (length2 === void 0) {
      buf2 = new Uint8Array(array2, byteOffset);
    } else {
      buf2 = new Uint8Array(array2, byteOffset, length2);
    }
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf2 = createBuffer(len2);
      if (buf2.length === 0) {
        return buf2;
      }
      obj.copy(buf2, 0, 0, len2);
      return buf2;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer3(b4) {
    return b4 != null && b4._isBuffer === true && b4 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a3, b4) {
    if (isInstance(a3, Uint8Array))
      a3 = Buffer2.from(a3, a3.offset, a3.byteLength);
    if (isInstance(b4, Uint8Array))
      b4 = Buffer2.from(b4, b4.offset, b4.byteLength);
    if (!Buffer2.isBuffer(a3) || !Buffer2.isBuffer(b4)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a3 === b4)
      return 0;
    let x2 = a3.length;
    let y3 = b4.length;
    for (let i3 = 0, len2 = Math.min(x2, y3); i3 < len2; ++i3) {
      if (a3[i3] !== b4[i3]) {
        x2 = a3[i3];
        y3 = b4[i3];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i3;
    if (length2 === void 0) {
      length2 = 0;
      for (i3 = 0; i3 < list.length; ++i3) {
        length2 += list[i3].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length2);
    let pos = 0;
    for (i3 = 0; i3 < list.length; ++i3) {
      let buf2 = list[i3];
      if (isInstance(buf2, Uint8Array)) {
        if (pos + buf2.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf2))
            buf2 = Buffer2.from(buf2);
          buf2.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf2,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf2.copy(buffer2, pos);
      }
      pos += buf2.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end2) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice2(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b4, n4, m2) {
    const i3 = b4[n4];
    b4[n4] = b4[m2];
    b4[m2] = i3;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i3 = 0; i3 < len2; i3 += 2) {
      swap(this, i3, i3 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i3 = 0; i3 < len2; i3 += 4) {
      swap(this, i3, i3 + 3);
      swap(this, i3 + 1, i3 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i3 = 0; i3 < len2; i3 += 8) {
      swap(this, i3, i3 + 7);
      swap(this, i3 + 1, i3 + 6);
      swap(this, i3 + 2, i3 + 5);
      swap(this, i3 + 3, i3 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    const length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice2(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b4) {
    if (!Buffer2.isBuffer(b4))
      throw new TypeError("Argument must be a Buffer");
    if (this === b4)
      return true;
    return Buffer2.compare(this, b4) === 0;
  };
  Buffer2.prototype.inspect = function inspect5() {
    let str = "";
    const max2 = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y3 = end2 - start;
    const len2 = Math.min(x2, y3);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end2);
    for (let i3 = 0; i3 < len2; ++i3) {
      if (thisCopy[i3] !== targetCopy[i3]) {
        x2 = thisCopy[i3];
        y3 = targetCopy[i3];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr2.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr2.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf2, i4) {
      if (indexSize === 1) {
        return buf2[i4];
      } else {
        return buf2.readUInt16BE(i4 * indexSize);
      }
    }
    let i3;
    if (dir) {
      let foundIndex = -1;
      for (i3 = byteOffset; i3 < arrLength; i3++) {
        if (read2(arr2, i3) === read2(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i3;
          if (i3 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i3 -= i3 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i3 = byteOffset; i3 >= 0; i3--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read2(arr2, i3 + j2) !== read2(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i3;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf2, string2, offset, length2) {
    offset = Number(offset) || 0;
    const remaining = buf2.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i3;
    for (i3 = 0; i3 < length2; ++i3) {
      const parsed = parseInt(string2.substr(i3 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i3;
      buf2[offset + i3] = parsed;
    }
    return i3;
  }
  function utf8Write(buf2, string2, offset, length2) {
    return blitBuffer(utf8ToBytes2(string2, buf2.length - offset), buf2, offset, length2);
  }
  function asciiWrite(buf2, string2, offset, length2) {
    return blitBuffer(asciiToBytes(string2), buf2, offset, length2);
  }
  function base64Write(buf2, string2, offset, length2) {
    return blitBuffer(base64ToBytes(string2), buf2, offset, length2);
  }
  function ucs2Write(buf2, string2, offset, length2) {
    return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length2);
  }
  Buffer2.prototype.write = function write4(string2, offset, length2, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length2);
        case "base64":
          return base64Write(this, string2, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf2, start, end2) {
    if (start === 0 && end2 === buf2.length) {
      return base642.fromByteArray(buf2);
    } else {
      return base642.fromByteArray(buf2.slice(start, end2));
    }
  }
  function utf8Slice2(buf2, start, end2) {
    end2 = Math.min(buf2.length, end2);
    const res = [];
    let i3 = start;
    while (i3 < end2) {
      const firstByte = buf2[i3];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i3 + bytesPerSequence <= end2) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[i3 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[i3 + 1];
            thirdByte = buf2[i3 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[i3 + 1];
            thirdByte = buf2[i3 + 2];
            fourthByte = buf2[i3 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i3 += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  const MAX_ARGUMENTS_LENGTH2 = 4096;
  function decodeCodePointsArray2(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i3 = 0;
    while (i3 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH2)
      );
    }
    return res;
  }
  function asciiSlice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i3 = start; i3 < end2; ++i3) {
      ret += String.fromCharCode(buf2[i3] & 127);
    }
    return ret;
  }
  function latin1Slice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i3 = start; i3 < end2; ++i3) {
      ret += String.fromCharCode(buf2[i3]);
    }
    return ret;
  }
  function hexSlice(buf2, start, end2) {
    const len2 = buf2.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len2)
      end2 = len2;
    let out = "";
    for (let i3 = start; i3 < end2; ++i3) {
      out += hexSliceLookupTable[buf2[i3]];
    }
    return out;
  }
  function utf16leSlice(buf2, start, end2) {
    const bytes2 = buf2.slice(start, end2);
    let res = "";
    for (let i3 = 0; i3 < bytes2.length - 1; i3 += 2) {
      res += String.fromCharCode(bytes2[i3] + bytes2[i3 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice3(start, end2) {
    const len2 = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len2 : ~~end2;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end2 < 0) {
      end2 += len2;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len2) {
      end2 = len2;
    }
    if (end2 < start)
      end2 = start;
    const newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length2) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul5 = 1;
    let i3 = 0;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      val += this[offset + i3] * mul5;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul5 = 1;
    while (byteLength3 > 0 && (mul5 *= 256)) {
      val += this[offset + --byteLength3] * mul5;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul5 = 1;
    let i3 = 0;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      val += this[offset + i3] * mul5;
    }
    mul5 *= 128;
    if (val >= mul5)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i3 = byteLength3;
    let mul5 = 1;
    let val = this[offset + --i3];
    while (i3 > 0 && (mul5 *= 256)) {
      val += this[offset + --i3] * mul5;
    }
    mul5 *= 128;
    if (val >= mul5)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first2 << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, false, 52, 8);
  };
  function checkInt(buf2, value, offset, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul5 = 1;
    let i3 = 0;
    this[offset] = value & 255;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      this[offset + i3] = value / mul5 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i3 = byteLength3 - 1;
    let mul5 = 1;
    this[offset + i3] = value & 255;
    while (--i3 >= 0 && (mul5 *= 256)) {
      this[offset + i3] = value / mul5 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf2, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf2, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf2, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf2, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf2[offset + 7] = lo;
    lo = lo >> 8;
    buf2[offset + 6] = lo;
    lo = lo >> 8;
    buf2[offset + 5] = lo;
    lo = lo >> 8;
    buf2[offset + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i3 = 0;
    let mul5 = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i3 < byteLength3 && (mul5 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i3] = (value / mul5 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i3 = byteLength3 - 1;
    let mul5 = 1;
    let sub = 0;
    this[offset + i3] = value & 255;
    while (--i3 >= 0 && (mul5 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i3] = (value / mul5 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf2, value, offset, ext, max2, min2) {
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 4);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 8);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    const len2 = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end2),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end2, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding = end2;
        end2 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    let i3;
    if (typeof val === "number") {
      for (i3 = start; i3 < end2; ++i3) {
        this[i3] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i3 = 0; i3 < end2 - start; ++i3) {
        this[i3 + start] = bytes2[i3 % len2];
      }
    }
    return this;
  };
  const errors2 = {};
  function E3(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E3(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E3(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E3(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i3 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i3 >= start + 4; i3 -= 3) {
      res = `_${val.slice(i3 - 3, i3)}${res}`;
    }
    return `${val.slice(0, i3)}${res}`;
  }
  function checkBounds(buf2, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf2[offset] === void 0 || buf2[offset + byteLength3] === void 0) {
      boundsError(offset, buf2.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf2, offset, byteLength3) {
    if (value > max2 || value < min2) {
      const n4 = typeof min2 === "bigint" ? "n" : "";
      let range2;
      if (byteLength3 > 3) {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n4} and < 2${n4} ** ${(byteLength3 + 1) * 8}${n4}`;
        } else {
          range2 = `>= -(2${n4} ** ${(byteLength3 + 1) * 8 - 1}${n4}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n4}`;
        }
      } else {
        range2 = `>= ${min2}${n4} and <= ${max2}${n4}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf2, offset, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length2, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors2.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length2 < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      type2 || "offset",
      `>= ${type2 ? 1 : 0} and <= ${length2}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i3 = 0; i3 < length2; ++i3) {
      codePoint = string2.charCodeAt(i3);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i3 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i3 = 0; i3 < str.length; ++i3) {
      byteArray.push(str.charCodeAt(i3) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo;
    const byteArray = [];
    for (let i3 = 0; i3 < str.length; ++i3) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i3);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length2) {
    let i3;
    for (i3 = 0; i3 < length2; ++i3) {
      if (i3 + offset >= dst.length || i3 >= src2.length)
        break;
      dst[i3 + offset] = src2[i3];
    }
    return i3;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table = new Array(256);
    for (let i3 = 0; i3 < 16; ++i3) {
      const i16 = i3 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet2[i3] + alphabet2[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const index$3 = /* @__PURE__ */ getDefaultExportFromCjs(buffer$1);
const buffer = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$3
}, [buffer$1]);
const require$$0$9 = /* @__PURE__ */ getAugmentedNamespace(buffer);
const { Buffer } = require$$0$9;
const symbol = Symbol.for("BufferList");
function BufferList(buf2) {
  if (!(this instanceof BufferList)) {
    return new BufferList(buf2);
  }
  BufferList._init.call(this, buf2);
}
BufferList._init = function _init(buf2) {
  Object.defineProperty(this, symbol, { value: true });
  this._bufs = [];
  this.length = 0;
  if (buf2) {
    this.append(buf2);
  }
};
BufferList.prototype._new = function _new(buf2) {
  return new BufferList(buf2);
};
BufferList.prototype._offset = function _offset(offset) {
  if (offset === 0) {
    return [0, 0];
  }
  let tot = 0;
  for (let i3 = 0; i3 < this._bufs.length; i3++) {
    const _t2 = tot + this._bufs[i3].length;
    if (offset < _t2 || i3 === this._bufs.length - 1) {
      return [i3, offset - tot];
    }
    tot = _t2;
  }
};
BufferList.prototype._reverseOffset = function(blOffset) {
  const bufferId = blOffset[0];
  let offset = blOffset[1];
  for (let i3 = 0; i3 < bufferId; i3++) {
    offset += this._bufs[i3].length;
  }
  return offset;
};
BufferList.prototype.get = function get2(index2) {
  if (index2 > this.length || index2 < 0) {
    return void 0;
  }
  const offset = this._offset(index2);
  return this._bufs[offset[0]][offset[1]];
};
BufferList.prototype.slice = function slice2(start, end2) {
  if (typeof start === "number" && start < 0) {
    start += this.length;
  }
  if (typeof end2 === "number" && end2 < 0) {
    end2 += this.length;
  }
  return this.copy(null, 0, start, end2);
};
BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart !== "number" || srcStart < 0) {
    srcStart = 0;
  }
  if (typeof srcEnd !== "number" || srcEnd > this.length) {
    srcEnd = this.length;
  }
  if (srcStart >= this.length) {
    return dst || Buffer.alloc(0);
  }
  if (srcEnd <= 0) {
    return dst || Buffer.alloc(0);
  }
  const copy2 = !!dst;
  const off2 = this._offset(srcStart);
  const len2 = srcEnd - srcStart;
  let bytes2 = len2;
  let bufoff = copy2 && dstStart || 0;
  let start = off2[1];
  if (srcStart === 0 && srcEnd === this.length) {
    if (!copy2) {
      return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);
    }
    for (let i3 = 0; i3 < this._bufs.length; i3++) {
      this._bufs[i3].copy(dst, bufoff);
      bufoff += this._bufs[i3].length;
    }
    return dst;
  }
  if (bytes2 <= this._bufs[off2[0]].length - start) {
    return copy2 ? this._bufs[off2[0]].copy(dst, dstStart, start, start + bytes2) : this._bufs[off2[0]].slice(start, start + bytes2);
  }
  if (!copy2) {
    dst = Buffer.allocUnsafe(len2);
  }
  for (let i3 = off2[0]; i3 < this._bufs.length; i3++) {
    const l2 = this._bufs[i3].length - start;
    if (bytes2 > l2) {
      this._bufs[i3].copy(dst, bufoff, start);
      bufoff += l2;
    } else {
      this._bufs[i3].copy(dst, bufoff, start, start + bytes2);
      bufoff += l2;
      break;
    }
    bytes2 -= l2;
    if (start) {
      start = 0;
    }
  }
  if (dst.length > bufoff)
    return dst.slice(0, bufoff);
  return dst;
};
BufferList.prototype.shallowSlice = function shallowSlice(start, end2) {
  start = start || 0;
  end2 = typeof end2 !== "number" ? this.length : end2;
  if (start < 0) {
    start += this.length;
  }
  if (end2 < 0) {
    end2 += this.length;
  }
  if (start === end2) {
    return this._new();
  }
  const startOffset = this._offset(start);
  const endOffset = this._offset(end2);
  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
  if (endOffset[1] === 0) {
    buffers.pop();
  } else {
    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
  }
  if (startOffset[1] !== 0) {
    buffers[0] = buffers[0].slice(startOffset[1]);
  }
  return this._new(buffers);
};
BufferList.prototype.toString = function toString2(encoding, start, end2) {
  return this.slice(start, end2).toString(encoding);
};
BufferList.prototype.consume = function consume(bytes2) {
  bytes2 = Math.trunc(bytes2);
  if (Number.isNaN(bytes2) || bytes2 <= 0)
    return this;
  while (this._bufs.length) {
    if (bytes2 >= this._bufs[0].length) {
      bytes2 -= this._bufs[0].length;
      this.length -= this._bufs[0].length;
      this._bufs.shift();
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes2);
      this.length -= bytes2;
      break;
    }
  }
  return this;
};
BufferList.prototype.duplicate = function duplicate() {
  const copy2 = this._new();
  for (let i3 = 0; i3 < this._bufs.length; i3++) {
    copy2.append(this._bufs[i3]);
  }
  return copy2;
};
BufferList.prototype.append = function append(buf2) {
  if (buf2 == null) {
    return this;
  }
  if (buf2.buffer) {
    this._appendBuffer(Buffer.from(buf2.buffer, buf2.byteOffset, buf2.byteLength));
  } else if (Array.isArray(buf2)) {
    for (let i3 = 0; i3 < buf2.length; i3++) {
      this.append(buf2[i3]);
    }
  } else if (this._isBufferList(buf2)) {
    for (let i3 = 0; i3 < buf2._bufs.length; i3++) {
      this.append(buf2._bufs[i3]);
    }
  } else {
    if (typeof buf2 === "number") {
      buf2 = buf2.toString();
    }
    this._appendBuffer(Buffer.from(buf2));
  }
  return this;
};
BufferList.prototype._appendBuffer = function appendBuffer(buf2) {
  this._bufs.push(buf2);
  this.length += buf2.length;
};
BufferList.prototype.indexOf = function(search, offset, encoding) {
  if (encoding === void 0 && typeof offset === "string") {
    encoding = offset;
    offset = void 0;
  }
  if (typeof search === "function" || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
  } else if (typeof search === "number") {
    search = Buffer.from([search]);
  } else if (typeof search === "string") {
    search = Buffer.from(search, encoding);
  } else if (this._isBufferList(search)) {
    search = search.slice();
  } else if (Array.isArray(search.buffer)) {
    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);
  } else if (!Buffer.isBuffer(search)) {
    search = Buffer.from(search);
  }
  offset = Number(offset || 0);
  if (isNaN(offset)) {
    offset = 0;
  }
  if (offset < 0) {
    offset = this.length + offset;
  }
  if (offset < 0) {
    offset = 0;
  }
  if (search.length === 0) {
    return offset > this.length ? this.length : offset;
  }
  const blOffset = this._offset(offset);
  let blIndex = blOffset[0];
  let buffOffset = blOffset[1];
  for (; blIndex < this._bufs.length; blIndex++) {
    const buff = this._bufs[blIndex];
    while (buffOffset < buff.length) {
      const availableWindow = buff.length - buffOffset;
      if (availableWindow >= search.length) {
        const nativeSearchResult = buff.indexOf(search, buffOffset);
        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult]);
        }
        buffOffset = buff.length - search.length + 1;
      } else {
        const revOffset = this._reverseOffset([blIndex, buffOffset]);
        if (this._match(revOffset, search)) {
          return revOffset;
        }
        buffOffset++;
      }
    }
    buffOffset = 0;
  }
  return -1;
};
BufferList.prototype._match = function(offset, search) {
  if (this.length - offset < search.length) {
    return false;
  }
  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
    if (this.get(offset + searchOffset) !== search[searchOffset]) {
      return false;
    }
  }
  return true;
};
(function() {
  const methods = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1,
    readIntBE: null,
    readIntLE: null,
    readUIntBE: null,
    readUIntLE: null
  };
  for (const m2 in methods) {
    (function(m3) {
      if (methods[m3] === null) {
        BufferList.prototype[m3] = function(offset, byteLength2) {
          return this.slice(offset, offset + byteLength2)[m3](0, byteLength2);
        };
      } else {
        BufferList.prototype[m3] = function(offset = 0) {
          return this.slice(offset, offset + methods[m3])[m3](0);
        };
      }
    })(m2);
  }
})();
BufferList.prototype._isBufferList = function _isBufferList(b4) {
  return b4 instanceof BufferList || BufferList.isBufferList(b4);
};
BufferList.isBufferList = function isBufferList(b4) {
  return b4 != null && b4[symbol];
};
var BufferList_1 = BufferList;
const BufferList$1 = /* @__PURE__ */ getDefaultExportFromCjs(BufferList_1);
let Rabin$1 = class Rabin2 {
  /**
   * Creates an instance of Rabin.
   * @param { import("./../dist/rabin-wasm") } asModule
   * @param {number} [bits=12]
   * @param {number} [min=8 * 1024]
   * @param {number} [max=32 * 1024]
   * @param {number} polynomial
   * @memberof Rabin
   */
  constructor(asModule, bits = 12, min2 = 8 * 1024, max2 = 32 * 1024, windowSize = 64, polynomial2) {
    this.bits = bits;
    this.min = min2;
    this.max = max2;
    this.asModule = asModule;
    this.rabin = new asModule.Rabin(bits, min2, max2, windowSize, polynomial2);
    this.polynomial = polynomial2;
  }
  /**
   * Fingerprints the buffer
   *
   * @param {Uint8Array} buf
   * @returns {Array<number>}
   * @memberof Rabin
   */
  fingerprint(buf2) {
    const {
      __retain,
      __release,
      __allocArray,
      __getInt32Array,
      Int32Array_ID,
      Uint8Array_ID
    } = this.asModule;
    const lengths = new Int32Array(Math.ceil(buf2.length / this.min));
    const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
    const pointer = __retain(__allocArray(Uint8Array_ID, buf2));
    const out = this.rabin.fingerprint(pointer, lengthsPtr);
    const processed = __getInt32Array(out);
    __release(pointer);
    __release(lengthsPtr);
    const end2 = processed.indexOf(0);
    return end2 >= 0 ? processed.subarray(0, end2) : processed;
  }
};
var rabin$1 = Rabin$1;
const rabin$2 = /* @__PURE__ */ getDefaultExportFromCjs(rabin$1);
const rabin$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: rabin$2
}, [rabin$1]);
const require$$0$8 = /* @__PURE__ */ getAugmentedNamespace(rabin$3);
var loader$1 = {};
const ID_OFFSET = -8;
const SIZE_OFFSET = -4;
const ARRAYBUFFER_ID = 0;
const STRING_ID = 1;
const ARRAYBUFFERVIEW = 1 << 0;
const ARRAY = 1 << 1;
const VAL_ALIGN_OFFSET = 5;
const VAL_SIGNED = 1 << 10;
const VAL_FLOAT = 1 << 11;
const VAL_MANAGED = 1 << 13;
const ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
const ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
const ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
const ARRAYBUFFERVIEW_SIZE = 12;
const ARRAY_LENGTH_OFFSET = 12;
const ARRAY_SIZE = 16;
const BIGINT = typeof BigUint64Array !== "undefined";
const THIS = Symbol();
const CHUNKSIZE = 1024;
function getStringImpl(buffer2, ptr) {
  const U32 = new Uint32Array(buffer2);
  const U16 = new Uint16Array(buffer2);
  var length2 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
  var offset = ptr >>> 1;
  if (length2 <= CHUNKSIZE)
    return String.fromCharCode.apply(String, U16.subarray(offset, offset + length2));
  const parts = [];
  do {
    const last2 = U16[offset + CHUNKSIZE - 1];
    const size2 = last2 >= 55296 && last2 < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size2)));
    length2 -= size2;
  } while (length2 > CHUNKSIZE);
  return parts.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length2));
}
function preInstantiate(imports) {
  const baseModule = {};
  function getString(memory2, ptr) {
    if (!memory2)
      return "<yet unknown>";
    return getStringImpl(memory2.buffer, ptr);
  }
  const env2 = imports.env = imports.env || {};
  env2.abort = env2.abort || function abort(mesg, file, line, colm) {
    const memory2 = baseModule.memory || env2.memory;
    throw Error("abort: " + getString(memory2, mesg) + " at " + getString(memory2, file) + ":" + line + ":" + colm);
  };
  env2.trace = env2.trace || function trace(mesg, n4) {
    const memory2 = baseModule.memory || env2.memory;
    console.log("trace: " + getString(memory2, mesg) + (n4 ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n4).join(", "));
  };
  imports.Math = imports.Math || Math;
  imports.Date = imports.Date || Date;
  return baseModule;
}
function postInstantiate(baseModule, instance2) {
  const rawExports = instance2.exports;
  const memory2 = rawExports.memory;
  const table = rawExports.table;
  const alloc3 = rawExports["__alloc"];
  const retain = rawExports["__retain"];
  const rttiBase = rawExports["__rtti_base"] || ~0;
  function getInfo(id2) {
    const U32 = new Uint32Array(memory2.buffer);
    const count2 = U32[rttiBase >>> 2];
    if ((id2 >>>= 0) >= count2)
      throw Error("invalid id: " + id2);
    return U32[(rttiBase + 4 >>> 2) + id2 * 2];
  }
  function getBase(id2) {
    const U32 = new Uint32Array(memory2.buffer);
    const count2 = U32[rttiBase >>> 2];
    if ((id2 >>>= 0) >= count2)
      throw Error("invalid id: " + id2);
    return U32[(rttiBase + 4 >>> 2) + id2 * 2 + 1];
  }
  function getValueAlign(info) {
    return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
  }
  function __allocString(str) {
    const length2 = str.length;
    const ptr = alloc3(length2 << 1, STRING_ID);
    const U16 = new Uint16Array(memory2.buffer);
    for (var i3 = 0, p3 = ptr >>> 1; i3 < length2; ++i3)
      U16[p3 + i3] = str.charCodeAt(i3);
    return ptr;
  }
  baseModule.__allocString = __allocString;
  function __getString(ptr) {
    const buffer2 = memory2.buffer;
    const id2 = new Uint32Array(buffer2)[ptr + ID_OFFSET >>> 2];
    if (id2 !== STRING_ID)
      throw Error("not a string: " + ptr);
    return getStringImpl(buffer2, ptr);
  }
  baseModule.__getString = __getString;
  function getView(alignLog2, signed2, float2) {
    const buffer2 = memory2.buffer;
    if (float2) {
      switch (alignLog2) {
        case 2:
          return new Float32Array(buffer2);
        case 3:
          return new Float64Array(buffer2);
      }
    } else {
      switch (alignLog2) {
        case 0:
          return new (signed2 ? Int8Array : Uint8Array)(buffer2);
        case 1:
          return new (signed2 ? Int16Array : Uint16Array)(buffer2);
        case 2:
          return new (signed2 ? Int32Array : Uint32Array)(buffer2);
        case 3:
          return new (signed2 ? BigInt64Array : BigUint64Array)(buffer2);
      }
    }
    throw Error("unsupported align: " + alignLog2);
  }
  function __allocArray(id2, values) {
    const info = getInfo(id2);
    if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
      throw Error("not an array: " + id2 + " @ " + info);
    const align = getValueAlign(info);
    const length2 = values.length;
    const buf2 = alloc3(length2 << align, ARRAYBUFFER_ID);
    const arr2 = alloc3(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id2);
    const U32 = new Uint32Array(memory2.buffer);
    U32[arr2 + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf2);
    U32[arr2 + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf2;
    U32[arr2 + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length2 << align;
    if (info & ARRAY)
      U32[arr2 + ARRAY_LENGTH_OFFSET >>> 2] = length2;
    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
    if (info & VAL_MANAGED) {
      for (let i3 = 0; i3 < length2; ++i3)
        view[(buf2 >>> align) + i3] = retain(values[i3]);
    } else {
      view.set(values, buf2 >>> align);
    }
    return arr2;
  }
  baseModule.__allocArray = __allocArray;
  function __getArrayView(arr2) {
    const U32 = new Uint32Array(memory2.buffer);
    const id2 = U32[arr2 + ID_OFFSET >>> 2];
    const info = getInfo(id2);
    if (!(info & ARRAYBUFFERVIEW))
      throw Error("not an array: " + id2);
    const align = getValueAlign(info);
    var buf2 = U32[arr2 + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
    const length2 = info & ARRAY ? U32[arr2 + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf2 + SIZE_OFFSET >>> 2] >>> align;
    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf2 >>>= align, buf2 + length2);
  }
  baseModule.__getArrayView = __getArrayView;
  function __getArray(arr2) {
    const input = __getArrayView(arr2);
    const len2 = input.length;
    const out = new Array(len2);
    for (let i3 = 0; i3 < len2; i3++)
      out[i3] = input[i3];
    return out;
  }
  baseModule.__getArray = __getArray;
  function __getArrayBuffer(ptr) {
    const buffer2 = memory2.buffer;
    const length2 = new Uint32Array(buffer2)[ptr + SIZE_OFFSET >>> 2];
    return buffer2.slice(ptr, ptr + length2);
  }
  baseModule.__getArrayBuffer = __getArrayBuffer;
  function getTypedArray(Type2, alignLog2, ptr) {
    return new Type2(getTypedArrayView(Type2, alignLog2, ptr));
  }
  function getTypedArrayView(Type2, alignLog2, ptr) {
    const buffer2 = memory2.buffer;
    const U32 = new Uint32Array(buffer2);
    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
    return new Type2(buffer2, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
  }
  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
  if (BIGINT) {
    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
  }
  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
  function __instanceof(ptr, baseId) {
    const U32 = new Uint32Array(memory2.buffer);
    var id2 = U32[ptr + ID_OFFSET >>> 2];
    if (id2 <= U32[rttiBase >>> 2]) {
      do
        if (id2 == baseId)
          return true;
      while (id2 = getBase(id2));
    }
    return false;
  }
  baseModule.__instanceof = __instanceof;
  baseModule.memory = baseModule.memory || memory2;
  baseModule.table = baseModule.table || table;
  return demangle(rawExports, baseModule);
}
function isResponse(o2) {
  return typeof Response !== "undefined" && o2 instanceof Response;
}
async function instantiate$1(source, imports) {
  if (isResponse(source = await source))
    return instantiateStreaming(source, imports);
  return postInstantiate(
    preInstantiate(imports || (imports = {})),
    await WebAssembly.instantiate(
      source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source),
      imports
    )
  );
}
var instantiate_1 = loader$1.instantiate = instantiate$1;
function instantiateSync(source, imports) {
  return postInstantiate(
    preInstantiate(imports || (imports = {})),
    new WebAssembly.Instance(
      source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source),
      imports
    )
  );
}
var instantiateSync_1 = loader$1.instantiateSync = instantiateSync;
async function instantiateStreaming(source, imports) {
  if (!WebAssembly.instantiateStreaming) {
    return instantiate$1(
      isResponse(source = await source) ? source.arrayBuffer() : source,
      imports
    );
  }
  return postInstantiate(
    preInstantiate(imports || (imports = {})),
    (await WebAssembly.instantiateStreaming(source, imports)).instance
  );
}
var instantiateStreaming_1 = loader$1.instantiateStreaming = instantiateStreaming;
function demangle(exports2, baseModule) {
  var module2 = baseModule ? Object.create(baseModule) : {};
  var setArgumentsLength = exports2["__argumentsLength"] ? function(length2) {
    exports2["__argumentsLength"].value = length2;
  } : exports2["__setArgumentsLength"] || exports2["__setargc"] || function() {
  };
  for (let internalName in exports2) {
    if (!Object.prototype.hasOwnProperty.call(exports2, internalName))
      continue;
    const elem = exports2[internalName];
    let parts = internalName.split(".");
    let curr = module2;
    while (parts.length > 1) {
      let part = parts.shift();
      if (!Object.prototype.hasOwnProperty.call(curr, part))
        curr[part] = {};
      curr = curr[part];
    }
    let name2 = parts[0];
    let hash2 = name2.indexOf("#");
    if (hash2 >= 0) {
      let className = name2.substring(0, hash2);
      let classElem = curr[className];
      if (typeof classElem === "undefined" || !classElem.prototype) {
        let ctor = function(...args) {
          return ctor.wrap(ctor.prototype.constructor(0, ...args));
        };
        ctor.prototype = {
          valueOf: function valueOf() {
            return this[THIS];
          }
        };
        ctor.wrap = function(thisValue) {
          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
        };
        if (classElem)
          Object.getOwnPropertyNames(classElem).forEach(
            (name3) => Object.defineProperty(ctor, name3, Object.getOwnPropertyDescriptor(classElem, name3))
          );
        curr[className] = ctor;
      }
      name2 = name2.substring(hash2 + 1);
      curr = curr[className].prototype;
      if (/^(get|set):/.test(name2)) {
        if (!Object.prototype.hasOwnProperty.call(curr, name2 = name2.substring(4))) {
          let getter = exports2[internalName.replace("set:", "get:")];
          let setter = exports2[internalName.replace("get:", "set:")];
          Object.defineProperty(curr, name2, {
            get: function() {
              return getter(this[THIS]);
            },
            set: function(value) {
              setter(this[THIS], value);
            },
            enumerable: true
          });
        }
      } else {
        if (name2 === "constructor") {
          (curr[name2] = (...args) => {
            setArgumentsLength(args.length);
            return elem(...args);
          }).original = elem;
        } else {
          (curr[name2] = function(...args) {
            setArgumentsLength(args.length);
            return elem(this[THIS], ...args);
          }).original = elem;
        }
      }
    } else {
      if (/^(get|set):/.test(name2)) {
        if (!Object.prototype.hasOwnProperty.call(curr, name2 = name2.substring(4))) {
          Object.defineProperty(curr, name2, {
            get: exports2[internalName.replace("set:", "get:")],
            set: exports2[internalName.replace("get:", "set:")],
            enumerable: true
          });
        }
      } else if (typeof elem === "function" && elem !== setArgumentsLength) {
        (curr[name2] = (...args) => {
          setArgumentsLength(args.length);
          return elem(...args);
        }).original = elem;
      } else {
        curr[name2] = elem;
      }
    }
  }
  return module2;
}
var demangle_1 = loader$1.demangle = demangle;
const loader = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: loader$1,
  demangle: demangle_1,
  instantiate: instantiate_1,
  instantiateStreaming: instantiateStreaming_1,
  instantiateSync: instantiateSync_1
}, [loader$1]);
const require$$0$7 = /* @__PURE__ */ getAugmentedNamespace(loader);
const { instantiate } = require$$0$7;
loadWebAssembly.supported = typeof WebAssembly !== "undefined";
function loadWebAssembly(imp = {}) {
  if (!loadWebAssembly.supported)
    return null;
  var wasm = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
  return instantiate(new Response(new Blob([wasm], { type: "application/wasm" })), imp);
}
var rabinWasm = loadWebAssembly;
const rabinWasm$1 = /* @__PURE__ */ getDefaultExportFromCjs(rabinWasm);
const rabinWasm$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: rabinWasm$1
}, [rabinWasm]);
const require$$1$4 = /* @__PURE__ */ getAugmentedNamespace(rabinWasm$2);
const Rabin = require$$0$8;
const getRabin = require$$1$4;
const create = async (avg, min2, max2, windowSize, polynomial2) => {
  const compiled = await getRabin();
  return new Rabin(compiled, avg, min2, max2, windowSize, polynomial2);
};
var src$1 = {
  Rabin,
  create
};
async function* rabinChunker(source, options) {
  let min2, max2, avg;
  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
    avg = options.avgChunkSize;
    min2 = options.minChunkSize;
    max2 = options.maxChunkSize;
  } else if (!options.avgChunkSize) {
    throw errCode$1(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
  } else {
    avg = options.avgChunkSize;
    min2 = avg / 3;
    max2 = avg + avg / 2;
  }
  if (min2 < 16) {
    throw errCode$1(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
  }
  if (max2 < min2) {
    max2 = min2;
  }
  if (avg < min2) {
    avg = min2;
  }
  const sizepow = Math.floor(Math.log2(avg));
  for await (const chunk of rabin(source, {
    min: min2,
    max: max2,
    bits: sizepow,
    window: options.window,
    polynomial: options.polynomial
  })) {
    yield chunk;
  }
}
async function* rabin(source, options) {
  const r2 = await src$1.create(options.bits, options.min, options.max, options.window);
  const buffers = new BufferList$1();
  for await (const chunk of source) {
    buffers.append(chunk);
    const sizes = r2.fingerprint(chunk);
    for (let i3 = 0; i3 < sizes.length; i3++) {
      const size2 = sizes[i3];
      const buf2 = buffers.slice(0, size2);
      buffers.consume(size2);
      yield buf2;
    }
  }
  if (buffers.length) {
    yield buffers.slice(0);
  }
}
async function* fixedSizeChunker(source, options) {
  let bl2 = new BufferList$1();
  let currentLength = 0;
  let emitted = false;
  const maxChunkSize = options.maxChunkSize;
  for await (const buffer2 of source) {
    bl2.append(buffer2);
    currentLength += buffer2.length;
    while (currentLength >= maxChunkSize) {
      yield bl2.slice(0, maxChunkSize);
      emitted = true;
      if (maxChunkSize === bl2.length) {
        bl2 = new BufferList$1();
        currentLength = 0;
      } else {
        const newBl = new BufferList$1();
        newBl.append(bl2.shallowSlice(maxChunkSize));
        bl2 = newBl;
        currentLength -= maxChunkSize;
      }
    }
  }
  if (!emitted || currentLength) {
    yield bl2.slice(0, currentLength);
  }
}
async function* validateChunks(source) {
  for await (const content of source) {
    if (content.length === void 0) {
      throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
    if (typeof content === "string" || content instanceof String) {
      yield fromString$2(content.toString());
    } else if (Array.isArray(content)) {
      yield Uint8Array.from(content);
    } else if (content instanceof Uint8Array) {
      yield content;
    } else {
      throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
  }
}
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return async function* () {
        yield content;
      }();
    } else if (isIterable(content)) {
      return async function* () {
        yield* content;
      }();
    } else if (isAsyncIterable(content)) {
      return content;
    }
  } catch {
    throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
async function* dagBuilder(source, blockstore, options) {
  for await (const entry of source) {
    if (entry.path) {
      if (entry.path.substring(0, 2) === "./") {
        options.wrapWithDirectory = true;
      }
      entry.path = entry.path.split("/").filter((path) => path && path !== ".").join("/");
    }
    if (entry.content) {
      let chunker;
      if (typeof options.chunker === "function") {
        chunker = options.chunker;
      } else if (options.chunker === "rabin") {
        chunker = rabinChunker;
      } else {
        chunker = fixedSizeChunker;
      }
      let chunkValidator;
      if (typeof options.chunkValidator === "function") {
        chunkValidator = options.chunkValidator;
      } else {
        chunkValidator = validateChunks;
      }
      const file = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode,
        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
      };
      yield () => fileBuilder(file, blockstore, options);
    } else if (entry.path) {
      const dir = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode
      };
      yield () => dirBuilder(dir, blockstore, options);
    } else {
      throw new Error("Import candidate must have content or path or both");
    }
  }
}
class Dir {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  async put(name2, value) {
  }
  get(name2) {
    return Promise.resolve(this);
  }
  async *eachChildSeries() {
  }
  async *flush(blockstore) {
  }
}
class DirFlat extends Dir {
  constructor(props, options) {
    super(props, options);
    this._children = {};
  }
  async put(name2, value) {
    this.cid = void 0;
    this.size = void 0;
    this._children[name2] = value;
  }
  get(name2) {
    return Promise.resolve(this._children[name2]);
  }
  childCount() {
    return Object.keys(this._children).length;
  }
  directChildrenCount() {
    return this.childCount();
  }
  onlyChild() {
    return this._children[Object.keys(this._children)[0]];
  }
  async *eachChildSeries() {
    const keys2 = Object.keys(this._children);
    for (let i3 = 0; i3 < keys2.length; i3++) {
      const key2 = keys2[i3];
      yield {
        key: key2,
        child: this._children[key2]
      };
    }
  }
  async *flush(block2) {
    const children = Object.keys(this._children);
    const links2 = [];
    for (let i3 = 0; i3 < children.length; i3++) {
      let child = this._children[children[i3]];
      if (child instanceof Dir) {
        for await (const entry of child.flush(block2)) {
          child = entry;
          yield child;
        }
      }
      if (child.size != null && child.cid) {
        links2.push({
          Name: children[i3],
          Tsize: child.size,
          Hash: child.cid
        });
      }
    }
    const unixfs = new UnixFS({
      type: "directory",
      mtime: this.mtime,
      mode: this.mode
    });
    const node2 = {
      Data: unixfs.marshal(),
      Links: links2
    };
    const buffer2 = encode$2(prepare(node2));
    const cid = await persist(buffer2, block2, this.options);
    const size2 = buffer2.length + node2.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);
    this.cid = cid;
    this.size = size2;
    yield {
      cid,
      unixfs,
      path: this.path,
      size: size2
    };
  }
}
const BITS_PER_BYTE = 7;
var sparseArray = class SparseArray2 {
  constructor() {
    this._bitArrays = [];
    this._data = [];
    this._length = 0;
    this._changedLength = false;
    this._changedData = false;
  }
  set(index2, value) {
    let pos = this._internalPositionFor(index2, false);
    if (value === void 0) {
      if (pos !== -1) {
        this._unsetInternalPos(pos);
        this._unsetBit(index2);
        this._changedLength = true;
        this._changedData = true;
      }
    } else {
      let needsSort = false;
      if (pos === -1) {
        pos = this._data.length;
        this._setBit(index2);
        this._changedData = true;
      } else {
        needsSort = true;
      }
      this._setInternalPos(pos, index2, value, needsSort);
      this._changedLength = true;
    }
  }
  unset(index2) {
    this.set(index2, void 0);
  }
  get(index2) {
    this._sortData();
    const pos = this._internalPositionFor(index2, true);
    if (pos === -1) {
      return void 0;
    }
    return this._data[pos][1];
  }
  push(value) {
    this.set(this.length, value);
    return this.length;
  }
  get length() {
    this._sortData();
    if (this._changedLength) {
      const last2 = this._data[this._data.length - 1];
      this._length = last2 ? last2[0] + 1 : 0;
      this._changedLength = false;
    }
    return this._length;
  }
  forEach(iterator2) {
    let i3 = 0;
    while (i3 < this.length) {
      iterator2(this.get(i3), i3, this);
      i3++;
    }
  }
  map(iterator2) {
    let i3 = 0;
    let mapped = new Array(this.length);
    while (i3 < this.length) {
      mapped[i3] = iterator2(this.get(i3), i3, this);
      i3++;
    }
    return mapped;
  }
  reduce(reducer, initialValue) {
    let i3 = 0;
    let acc = initialValue;
    while (i3 < this.length) {
      const value = this.get(i3);
      acc = reducer(acc, value, i3);
      i3++;
    }
    return acc;
  }
  find(finder) {
    let i3 = 0, found, last2;
    while (i3 < this.length && !found) {
      last2 = this.get(i3);
      found = finder(last2);
      i3++;
    }
    return found ? last2 : void 0;
  }
  _internalPositionFor(index2, noCreate) {
    const bytePos = this._bytePosFor(index2, noCreate);
    if (bytePos >= this._bitArrays.length) {
      return -1;
    }
    const byte2 = this._bitArrays[bytePos];
    const bitPos = index2 - bytePos * BITS_PER_BYTE;
    const exists2 = (byte2 & 1 << bitPos) > 0;
    if (!exists2) {
      return -1;
    }
    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
    const mask2 = ~(4294967295 << bitPos + 1);
    const bytePopCount = popCount(byte2 & mask2);
    const arrayPos = previousPopCount + bytePopCount - 1;
    return arrayPos;
  }
  _bytePosFor(index2, noCreate) {
    const bytePos = Math.floor(index2 / BITS_PER_BYTE);
    const targetLength = bytePos + 1;
    while (!noCreate && this._bitArrays.length < targetLength) {
      this._bitArrays.push(0);
    }
    return bytePos;
  }
  _setBit(index2) {
    const bytePos = this._bytePosFor(index2, false);
    this._bitArrays[bytePos] |= 1 << index2 - bytePos * BITS_PER_BYTE;
  }
  _unsetBit(index2) {
    const bytePos = this._bytePosFor(index2, false);
    this._bitArrays[bytePos] &= ~(1 << index2 - bytePos * BITS_PER_BYTE);
  }
  _setInternalPos(pos, index2, value, needsSort) {
    const data2 = this._data;
    const elem = [index2, value];
    if (needsSort) {
      this._sortData();
      data2[pos] = elem;
    } else {
      if (data2.length) {
        if (data2[data2.length - 1][0] >= index2) {
          data2.push(elem);
        } else if (data2[0][0] <= index2) {
          data2.unshift(elem);
        } else {
          const randomIndex = Math.round(data2.length / 2);
          this._data = data2.slice(0, randomIndex).concat(elem).concat(data2.slice(randomIndex));
        }
      } else {
        this._data.push(elem);
      }
      this._changedData = true;
      this._changedLength = true;
    }
  }
  _unsetInternalPos(pos) {
    this._data.splice(pos, 1);
  }
  _sortData() {
    if (this._changedData) {
      this._data.sort(sortInternal);
    }
    this._changedData = false;
  }
  bitField() {
    const bytes2 = [];
    let pendingBitsForResultingByte = 8;
    let pendingBitsForNewByte = 0;
    let resultingByte = 0;
    let newByte;
    const pending = this._bitArrays.slice();
    while (pending.length || pendingBitsForNewByte) {
      if (pendingBitsForNewByte === 0) {
        newByte = pending.shift();
        pendingBitsForNewByte = 7;
      }
      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
      const mask2 = ~(255 << usingBits);
      const masked = newByte & mask2;
      resultingByte |= masked << 8 - pendingBitsForResultingByte;
      newByte = newByte >>> usingBits;
      pendingBitsForNewByte -= usingBits;
      pendingBitsForResultingByte -= usingBits;
      if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
        bytes2.push(resultingByte);
        resultingByte = 0;
        pendingBitsForResultingByte = 8;
      }
    }
    for (var i3 = bytes2.length - 1; i3 > 0; i3--) {
      const value = bytes2[i3];
      if (value === 0) {
        bytes2.pop();
      } else {
        break;
      }
    }
    return bytes2;
  }
  compactArray() {
    this._sortData();
    return this._data.map(valueOnly);
  }
};
function popCountReduce(count2, byte2) {
  return count2 + popCount(byte2);
}
function popCount(_v) {
  let v4 = _v;
  v4 = v4 - (v4 >> 1 & 1431655765);
  v4 = (v4 & 858993459) + (v4 >> 2 & 858993459);
  return (v4 + (v4 >> 4) & 252645135) * 16843009 >> 24;
}
function sortInternal(a3, b4) {
  return a3[0] - b4[0];
}
function valueOnly(elem) {
  return elem[1];
}
const index$2 = /* @__PURE__ */ getDefaultExportFromCjs(sparseArray);
const sparseArray$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$2
}, [sparseArray]);
const require$$0$6 = /* @__PURE__ */ getAugmentedNamespace(sparseArray$1);
const require$$1$3 = /* @__PURE__ */ getAugmentedNamespace(fromString$3);
const SparseArray = require$$0$6;
const { fromString: uint8ArrayFromString } = require$$1$3;
let Bucket$1 = class Bucket2 {
  /**
   * @param {BucketOptions} options
   * @param {Bucket<T>} [parent]
   * @param {number} [posAtParent=0]
   */
  constructor(options, parent, posAtParent = 0) {
    this._options = options;
    this._popCount = 0;
    this._parent = parent;
    this._posAtParent = posAtParent;
    this._children = new SparseArray();
    this.key = null;
  }
  /**
   * @param {string} key
   * @param {T} value
   */
  async put(key2, value) {
    const place = await this._findNewBucketAndPos(key2);
    await place.bucket._putAt(place, key2, value);
  }
  /**
   * @param {string} key
   */
  async get(key2) {
    const child = await this._findChild(key2);
    if (child) {
      return child.value;
    }
  }
  /**
   * @param {string} key
   */
  async del(key2) {
    const place = await this._findPlace(key2);
    const child = place.bucket._at(place.pos);
    if (child && child.key === key2) {
      place.bucket._delAt(place.pos);
    }
  }
  /**
   * @returns {number}
   */
  leafCount() {
    const children = this._children.compactArray();
    return children.reduce((acc, child) => {
      if (child instanceof Bucket2) {
        return acc + child.leafCount();
      }
      return acc + 1;
    }, 0);
  }
  childrenCount() {
    return this._children.length;
  }
  onlyChild() {
    return this._children.get(0);
  }
  /**
   * @returns {Iterable<BucketChild<T>>}
   */
  *eachLeafSeries() {
    const children = this._children.compactArray();
    for (const child of children) {
      if (child instanceof Bucket2) {
        yield* child.eachLeafSeries();
      } else {
        yield child;
      }
    }
    return [];
  }
  /**
   * @param {(value: BucketChild<T>, index: number) => T} map
   * @param {(reduced: any) => any} reduce
   */
  serialize(map2, reduce2) {
    const acc = [];
    return reduce2(this._children.reduce((acc2, child, index2) => {
      if (child) {
        if (child instanceof Bucket2) {
          acc2.push(child.serialize(map2, reduce2));
        } else {
          acc2.push(map2(child, index2));
        }
      }
      return acc2;
    }, acc));
  }
  /**
   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap
   * @param {(reduced: any) => Promise<any>} asyncReduce
   */
  asyncTransform(asyncMap2, asyncReduce) {
    return asyncTransformBucket(this, asyncMap2, asyncReduce);
  }
  toJSON() {
    return this.serialize(mapNode, reduceNodes);
  }
  prettyPrint() {
    return JSON.stringify(this.toJSON(), null, "  ");
  }
  tableSize() {
    return Math.pow(2, this._options.bits);
  }
  /**
   * @param {string} key
   * @returns {Promise<BucketChild<T> | undefined>}
   */
  async _findChild(key2) {
    const result = await this._findPlace(key2);
    const child = result.bucket._at(result.pos);
    if (child instanceof Bucket2) {
      return void 0;
    }
    if (child && child.key === key2) {
      return child;
    }
  }
  /**
   * @param {string | InfiniteHash} key
   * @returns {Promise<BucketPosition<T>>}
   */
  async _findPlace(key2) {
    const hashValue = this._options.hash(typeof key2 === "string" ? uint8ArrayFromString(key2) : key2);
    const index2 = await hashValue.take(this._options.bits);
    const child = this._children.get(index2);
    if (child instanceof Bucket2) {
      return child._findPlace(hashValue);
    }
    return {
      bucket: this,
      pos: index2,
      hash: hashValue,
      existingChild: child
    };
  }
  /**
   * @param {string | InfiniteHash} key
   * @returns {Promise<BucketPosition<T>>}
   */
  async _findNewBucketAndPos(key2) {
    const place = await this._findPlace(key2);
    if (place.existingChild && place.existingChild.key !== key2) {
      const bucket2 = new Bucket2(this._options, place.bucket, place.pos);
      place.bucket._putObjectAt(place.pos, bucket2);
      const newPlace = await bucket2._findPlace(place.existingChild.hash);
      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
      return bucket2._findNewBucketAndPos(place.hash);
    }
    return place;
  }
  /**
   * @param {BucketPosition<T>} place
   * @param {string} key
   * @param {T} value
   */
  _putAt(place, key2, value) {
    this._putObjectAt(place.pos, {
      key: key2,
      value,
      hash: place.hash
    });
  }
  /**
   * @param {number} pos
   * @param {Bucket<T> | BucketChild<T>} object
   */
  _putObjectAt(pos, object2) {
    if (!this._children.get(pos)) {
      this._popCount++;
    }
    this._children.set(pos, object2);
  }
  /**
   * @param {number} pos
   */
  _delAt(pos) {
    if (pos === -1) {
      throw new Error("Invalid position");
    }
    if (this._children.get(pos)) {
      this._popCount--;
    }
    this._children.unset(pos);
    this._level();
  }
  _level() {
    if (this._parent && this._popCount <= 1) {
      if (this._popCount === 1) {
        const onlyChild = this._children.find(exists);
        if (onlyChild && !(onlyChild instanceof Bucket2)) {
          const hash2 = onlyChild.hash;
          hash2.untake(this._options.bits);
          const place = {
            pos: this._posAtParent,
            hash: hash2,
            bucket: this._parent
          };
          this._parent._putAt(place, onlyChild.key, onlyChild.value);
        }
      } else {
        this._parent._delAt(this._posAtParent);
      }
    }
  }
  /**
   * @param {number} index
   * @returns {BucketChild<T> | Bucket<T> | undefined}
   */
  _at(index2) {
    return this._children.get(index2);
  }
};
function exists(o2) {
  return Boolean(o2);
}
function mapNode(node2, index2) {
  return node2.key;
}
function reduceNodes(nodes) {
  return nodes;
}
async function asyncTransformBucket(bucket2, asyncMap2, asyncReduce) {
  const output = [];
  for (const child of bucket2._children.compactArray()) {
    if (child instanceof Bucket$1) {
      await asyncTransformBucket(child, asyncMap2, asyncReduce);
    } else {
      const mappedChildren = await asyncMap2(child);
      output.push({
        bitField: bucket2._children.bitField(),
        children: mappedChildren
      });
    }
  }
  return asyncReduce(output);
}
var bucket = Bucket$1;
const bucket$1 = /* @__PURE__ */ getDefaultExportFromCjs(bucket);
const bucket$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: bucket$1
}, [bucket]);
const require$$0$5 = /* @__PURE__ */ getAugmentedNamespace(bucket$2);
var consumableHash$2 = { exports: {} };
const START_MASKS = [
  255,
  254,
  252,
  248,
  240,
  224,
  192,
  128
];
const STOP_MASKS = [
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255
];
var consumableBuffer = class ConsumableBuffer2 {
  /**
   * @param {Uint8Array} value
   */
  constructor(value) {
    this._value = value;
    this._currentBytePos = value.length - 1;
    this._currentBitPos = 7;
  }
  availableBits() {
    return this._currentBitPos + 1 + this._currentBytePos * 8;
  }
  totalBits() {
    return this._value.length * 8;
  }
  /**
   * @param {number} bits
   */
  take(bits) {
    let pendingBits = bits;
    let result = 0;
    while (pendingBits && this._haveBits()) {
      const byte2 = this._value[this._currentBytePos];
      const availableBits = this._currentBitPos + 1;
      const taking = Math.min(availableBits, pendingBits);
      const value = byteBitsToInt(byte2, availableBits - taking, taking);
      result = (result << taking) + value;
      pendingBits -= taking;
      this._currentBitPos -= taking;
      if (this._currentBitPos < 0) {
        this._currentBitPos = 7;
        this._currentBytePos--;
      }
    }
    return result;
  }
  /**
   * @param {number} bits
   */
  untake(bits) {
    this._currentBitPos += bits;
    while (this._currentBitPos > 7) {
      this._currentBitPos -= 8;
      this._currentBytePos += 1;
    }
  }
  _haveBits() {
    return this._currentBytePos >= 0;
  }
};
function byteBitsToInt(byte2, start, length2) {
  const mask2 = maskFor(start, length2);
  return (byte2 & mask2) >>> start;
}
function maskFor(start, length2) {
  return START_MASKS[start] & STOP_MASKS[Math.min(length2 + start - 1, 7)];
}
const consumableBuffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(consumableBuffer);
const consumableBuffer$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: consumableBuffer$1
}, [consumableBuffer]);
const require$$0$4 = /* @__PURE__ */ getAugmentedNamespace(consumableBuffer$2);
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(concat$5);
const ConsumableBuffer = require$$0$4;
const { concat: uint8ArrayConcat } = require$$1$2;
function wrapHash$1(hashFn) {
  function hashing(value) {
    if (value instanceof InfiniteHash) {
      return value;
    } else {
      return new InfiniteHash(value, hashFn);
    }
  }
  return hashing;
}
class InfiniteHash {
  /**
   *
   * @param {Uint8Array} value
   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn
   */
  constructor(value, hashFn) {
    if (!(value instanceof Uint8Array)) {
      throw new Error("can only hash Uint8Arrays");
    }
    this._value = value;
    this._hashFn = hashFn;
    this._depth = -1;
    this._availableBits = 0;
    this._currentBufferIndex = 0;
    this._buffers = [];
  }
  /**
   * @param {number} bits
   */
  async take(bits) {
    let pendingBits = bits;
    while (this._availableBits < pendingBits) {
      await this._produceMoreBits();
    }
    let result = 0;
    while (pendingBits > 0) {
      const hash2 = this._buffers[this._currentBufferIndex];
      const available = Math.min(hash2.availableBits(), pendingBits);
      const took = hash2.take(available);
      result = (result << available) + took;
      pendingBits -= available;
      this._availableBits -= available;
      if (hash2.availableBits() === 0) {
        this._currentBufferIndex++;
      }
    }
    return result;
  }
  /**
   * @param {number} bits
   */
  untake(bits) {
    let pendingBits = bits;
    while (pendingBits > 0) {
      const hash2 = this._buffers[this._currentBufferIndex];
      const availableForUntake = Math.min(hash2.totalBits() - hash2.availableBits(), pendingBits);
      hash2.untake(availableForUntake);
      pendingBits -= availableForUntake;
      this._availableBits += availableForUntake;
      if (this._currentBufferIndex > 0 && hash2.totalBits() === hash2.availableBits()) {
        this._depth--;
        this._currentBufferIndex--;
      }
    }
  }
  async _produceMoreBits() {
    this._depth++;
    const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;
    const hashValue = await this._hashFn(value);
    const buffer2 = new ConsumableBuffer(hashValue);
    this._buffers.push(buffer2);
    this._availableBits += buffer2.availableBits();
  }
}
consumableHash$2.exports = wrapHash$1;
var InfiniteHash_1 = consumableHash$2.exports.InfiniteHash = InfiniteHash;
var consumableHashExports = consumableHash$2.exports;
const consumableHash = /* @__PURE__ */ getDefaultExportFromCjs(consumableHashExports);
const consumableHash$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  InfiniteHash: InfiniteHash_1,
  default: consumableHash
}, [consumableHashExports]);
const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(consumableHash$1);
const Bucket = require$$0$5;
const wrapHash = require$$1$1;
function createHAMT(options) {
  if (!options || !options.hashFn) {
    throw new Error("please define an options.hashFn");
  }
  const bucketOptions = {
    bits: options.bits || 8,
    hash: wrapHash(options.hashFn)
  };
  return new Bucket(bucketOptions);
}
var src = {
  createHAMT,
  Bucket
};
class DirSharded extends Dir {
  constructor(props, options) {
    super(props, options);
    this._bucket = src.createHAMT({
      hashFn: options.hamtHashFn,
      bits: options.hamtBucketBits
    });
  }
  async put(name2, value) {
    await this._bucket.put(name2, value);
  }
  get(name2) {
    return this._bucket.get(name2);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key: key2, value } of this._bucket.eachLeafSeries()) {
      yield {
        key: key2,
        child: value
      };
    }
  }
  async *flush(blockstore) {
    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {
      yield {
        ...entry,
        path: this.path
      };
    }
  }
}
async function* flush(bucket2, blockstore, shardRoot, options) {
  const children = bucket2._children;
  const links2 = [];
  let childrenSize = 0;
  for (let i3 = 0; i3 < children.length; i3++) {
    const child = children.get(i3);
    if (!child) {
      continue;
    }
    const labelPrefix = i3.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof src.Bucket) {
      let shard;
      for await (const subShard of await flush(child, blockstore, null, options)) {
        shard = subShard;
      }
      if (!shard) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links2.push({
        Name: labelPrefix,
        Tsize: shard.size,
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links2.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value = child.value;
      if (!value.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size3 = value.size;
      links2.push({
        Name: label,
        Tsize: size3,
        Hash: value.cid
      });
      childrenSize += size3;
    }
  }
  const data2 = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data: data2,
    fanout: bucket2.tableSize(),
    hashType: options.hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node2 = {
    Data: dir.marshal(),
    Links: links2
  };
  const buffer2 = encode$2(prepare(node2));
  const cid = await persist(buffer2, blockstore, options);
  const size2 = buffer2.length + childrenSize;
  yield {
    cid,
    unixfs: dir,
    size: size2
  };
}
async function flatToShard(child, dir, threshold, options) {
  let newDir = dir;
  if (dir instanceof DirFlat && dir.directChildrenCount() >= threshold) {
    newDir = await convertToShard(dir, options);
  }
  const parent = newDir.parent;
  if (parent) {
    if (newDir !== dir) {
      if (child) {
        child.parent = newDir;
      }
      if (!newDir.parentKey) {
        throw new Error("No parent key found");
      }
      await parent.put(newDir.parentKey, newDir);
    }
    return flatToShard(newDir, parent, threshold, options);
  }
  return newDir;
}
async function convertToShard(oldDir, options) {
  const newDir = new DirSharded({
    root: oldDir.root,
    dir: true,
    parent: oldDir.parent,
    parentKey: oldDir.parentKey,
    path: oldDir.path,
    dirty: oldDir.dirty,
    flat: false,
    mtime: oldDir.mtime,
    mode: oldDir.mode
  }, options);
  for await (const { key: key2, child } of oldDir.eachChildSeries()) {
    await newDir.put(key2, child);
  }
  return newDir;
}
const toPathComponents = (path = "") => {
  return (path.trim().match(/([^\\/]|\\\/)+/g) || []).filter(Boolean);
};
async function addToTree(elem, tree2, options) {
  const pathElems = toPathComponents(elem.path || "");
  const lastIndex = pathElems.length - 1;
  let parent = tree2;
  let currentPath = "";
  for (let i3 = 0; i3 < pathElems.length; i3++) {
    const pathElem = pathElems[i3];
    currentPath += `${currentPath ? "/" : ""}${pathElem}`;
    const last2 = i3 === lastIndex;
    parent.dirty = true;
    parent.cid = void 0;
    parent.size = void 0;
    if (last2) {
      await parent.put(pathElem, elem);
      tree2 = await flatToShard(null, parent, options.shardSplitThreshold, options);
    } else {
      let dir = await parent.get(pathElem);
      if (!dir || !(dir instanceof Dir)) {
        dir = new DirFlat({
          root: false,
          dir: true,
          parent,
          parentKey: pathElem,
          path: currentPath,
          dirty: true,
          flat: true,
          mtime: dir && dir.unixfs && dir.unixfs.mtime,
          mode: dir && dir.unixfs && dir.unixfs.mode
        }, options);
      }
      await parent.put(pathElem, dir);
      parent = dir;
    }
  }
  return tree2;
}
async function* flushAndYield(tree2, blockstore) {
  if (!(tree2 instanceof Dir)) {
    if (tree2 && tree2.unixfs && tree2.unixfs.isDirectory()) {
      yield tree2;
    }
    return;
  }
  yield* tree2.flush(blockstore);
}
async function* treeBuilder(source, block2, options) {
  let tree2 = new DirFlat({
    root: true,
    dir: true,
    path: "",
    dirty: true,
    flat: true
  }, options);
  for await (const entry of source) {
    if (!entry) {
      continue;
    }
    tree2 = await addToTree(entry, tree2, options);
    if (!entry.unixfs || !entry.unixfs.isDirectory()) {
      yield entry;
    }
  }
  if (options.wrapWithDirectory) {
    yield* flushAndYield(tree2, block2);
  } else {
    for await (const unwrapped of tree2.eachChildSeries()) {
      if (!unwrapped) {
        continue;
      }
      yield* flushAndYield(unwrapped.child, block2);
    }
  }
}
async function* importer(source, blockstore, options = {}) {
  const opts = defaultOptions$2(options);
  let dagBuilder$1;
  if (typeof options.dagBuilder === "function") {
    dagBuilder$1 = options.dagBuilder;
  } else {
    dagBuilder$1 = dagBuilder;
  }
  let treeBuilder$1;
  if (typeof options.treeBuilder === "function") {
    treeBuilder$1 = options.treeBuilder;
  } else {
    treeBuilder$1 = treeBuilder;
  }
  let candidates;
  if (Symbol.asyncIterator in source || Symbol.iterator in source) {
    candidates = source;
  } else {
    candidates = [source];
  }
  for await (const entry of treeBuilder$1(parallelBatch$1(dagBuilder$1(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}
async function* browserReadableStreamToIt$1(stream2, options = {}) {
  const reader2 = stream2.getReader();
  try {
    while (true) {
      const result = await reader2.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options.preventCancel !== true) {
      reader2.cancel();
    }
    reader2.releaseLock();
  }
}
var browserReadablestreamToIt = browserReadableStreamToIt$1;
const browserStreamToIt = /* @__PURE__ */ getDefaultExportFromCjs(browserReadablestreamToIt);
const browserReadablestreamToIt$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: browserStreamToIt
}, [browserReadablestreamToIt]);
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(browserReadablestreamToIt$1);
const browserReadableStreamToIt = require$$0$3;
function blobToIt(blob) {
  if (typeof blob.stream === "function") {
    return browserReadableStreamToIt(blob.stream());
  }
  return browserReadableStreamToIt(new Response(blob).body);
}
var blobToIt_1 = blobToIt;
const blobToIt$1 = /* @__PURE__ */ getDefaultExportFromCjs(blobToIt_1);
function peekableIterator(iterable) {
  const [iterator2, symbol2] = iterable[Symbol.asyncIterator] ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue2 = [];
  return {
    peek: () => {
      return iterator2.next();
    },
    push: (value) => {
      queue2.push(value);
    },
    next: () => {
      if (queue2.length) {
        return {
          done: false,
          value: queue2.shift()
        };
      }
      return iterator2.next();
    },
    [symbol2]() {
      return this;
    }
  };
}
var itPeekable = peekableIterator;
const itPeekable$1 = /* @__PURE__ */ getDefaultExportFromCjs(itPeekable);
const map = async function* (source, func2) {
  for await (const val of source) {
    yield func2(val);
  }
};
var itMap = map;
const map$1 = /* @__PURE__ */ getDefaultExportFromCjs(itMap);
function isBytes$1(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob$2(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
const isReadableStream = (value) => value && typeof value.getReader === "function";
async function* toAsyncIterable(thing) {
  yield thing;
}
async function normaliseContent(input) {
  if (isBytes$1(input)) {
    return toAsyncIterable(toBytes(input));
  }
  if (typeof input === "string" || input instanceof String) {
    return toAsyncIterable(toBytes(input.toString()));
  }
  if (isBlob$2(input)) {
    return blobToIt$1(input);
  }
  if (isReadableStream(input)) {
    input = browserStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = itPeekable$1(input);
    const { value, done: done2 } = await peekable.peek();
    if (done2) {
      return toAsyncIterable(new Uint8Array(0));
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return toAsyncIterable(Uint8Array.from(await all$1(peekable)));
    }
    if (isBytes$1(value) || typeof value === "string" || value instanceof String) {
      return map$1(peekable, toBytes);
    }
  }
  throw errCode$1(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
function toBytes(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString$2(chunk.toString());
}
async function* normaliseCandidateSingle(input, normaliseContent2) {
  if (input === null || input === void 0) {
    throw errCode$1(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input === "string" || input instanceof String) {
    yield toFileObject$1(input.toString(), normaliseContent2);
    return;
  }
  if (isBytes$1(input) || isBlob$2(input)) {
    yield toFileObject$1(input, normaliseContent2);
    return;
  }
  if (isReadableStream(input)) {
    input = browserStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = itPeekable$1(input);
    const { value, done: done2 } = await peekable.peek();
    if (done2) {
      yield { content: [] };
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value) || isBytes$1(value) || typeof value === "string" || value instanceof String) {
      yield toFileObject$1(peekable, normaliseContent2);
      return;
    }
    throw errCode$1(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isFileObject(input)) {
    yield toFileObject$1(input, normaliseContent2);
    return;
  }
  throw errCode$1(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject$1(input, normaliseContent2) {
  const { path, mode: mode2, mtime, content } = input;
  const file = {
    path: path || "",
    mode: parseMode(mode2),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent2(content);
  } else if (!path) {
    file.content = await normaliseContent2(input);
  }
  return file;
}
function normaliseInput$1(input) {
  return normaliseCandidateSingle(input, normaliseContent);
}
async function* normaliseCandidateMultiple(input, normaliseContent2) {
  if (typeof input === "string" || input instanceof String || isBytes$1(input) || isBlob$2(input) || input._readableState) {
    throw errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isReadableStream(input)) {
    input = browserStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = itPeekable$1(input);
    const { value, done: done2 } = await peekable.peek();
    if (done2) {
      yield* [];
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      throw errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (value._readableState) {
      yield* map$1(peekable, (value2) => toFileObject({ content: value2 }, normaliseContent2));
      return;
    }
    if (isBytes$1(value)) {
      yield toFileObject({ content: peekable }, normaliseContent2);
      return;
    }
    if (isFileObject(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value) || isBlob$2(value)) {
      yield* map$1(peekable, (value2) => toFileObject(value2, normaliseContent2));
      return;
    }
  }
  if (isFileObject(input)) {
    throw errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  throw errCode$1(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input, normaliseContent2) {
  const { path, mode: mode2, mtime, content } = input;
  const file = {
    path: path || "",
    mode: parseMode(mode2),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent2(content);
  } else if (!path) {
    file.content = await normaliseContent2(input);
  }
  return file;
}
function normaliseInput(input) {
  return normaliseCandidateMultiple(input, normaliseContent);
}
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob$1(obj) {
  return Boolean(obj.constructor) && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isSingle(input) {
  return typeof input === "string" || input instanceof String || isBytes(input) || isBlob$1(input) || "_readableState" in input;
}
function getNormaliser(input) {
  if (isSingle(input)) {
    return normaliseInput$1(input);
  } else {
    return normaliseInput(input);
  }
}
const drain = async (source) => {
  for await (const _3 of source) {
  }
};
var itDrain = drain;
const drain$1 = /* @__PURE__ */ getDefaultExportFromCjs(itDrain);
const filter = async function* (source, fn2) {
  for await (const entry of source) {
    if (await fn2(entry)) {
      yield entry;
    }
  }
};
var itFilter = filter;
const filter$1 = /* @__PURE__ */ getDefaultExportFromCjs(itFilter);
const take = async function* (source, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
};
var itTake = take;
const take$1 = /* @__PURE__ */ getDefaultExportFromCjs(itTake);
const sortAll = (iterable, sorter) => {
  return async function* () {
    const values = await all$1(iterable);
    yield* values.sort(sorter);
  }();
};
class BaseBlockstore {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key2, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key2, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key2, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key2, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key: key2, value } of source) {
      await this.put(key2, value, options);
      yield {
        key: key2,
        value
      };
    }
  }
  async *getMany(source, options = {}) {
    for await (const key2 of source) {
      yield this.get(key2, options);
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key2 of source) {
      await this.delete(key2, options);
      yield key2;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key2, value) {
        puts.push({
          key: key2,
          value
        });
      },
      delete(key2) {
        dels.push(key2);
      },
      commit: async (options) => {
        await drain$1(this.putMany(puts, options));
        puts = [];
        await drain$1(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q2, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q2, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q2, options) {
    let it2 = this._all(q2, options);
    if (q2.prefix != null) {
      it2 = filter$1(it2, (e2) => e2.key.toString().startsWith(q2.prefix || ""));
    }
    if (Array.isArray(q2.filters)) {
      it2 = q2.filters.reduce((it3, f4) => filter$1(it3, f4), it2);
    }
    if (Array.isArray(q2.orders)) {
      it2 = q2.orders.reduce((it3, f4) => sortAll(it3, f4), it2);
    }
    if (q2.offset != null) {
      let i3 = 0;
      it2 = filter$1(it2, () => i3++ >= (q2.offset || 0));
    }
    if (q2.limit != null) {
      it2 = take$1(it2, q2.limit);
    }
    return it2;
  }
  queryKeys(q2, options) {
    let it2 = this._allKeys(q2, options);
    if (q2.prefix != null) {
      it2 = filter$1(it2, (cid) => cid.toString().startsWith(q2.prefix || ""));
    }
    if (Array.isArray(q2.filters)) {
      it2 = q2.filters.reduce((it3, f4) => filter$1(it3, f4), it2);
    }
    if (Array.isArray(q2.orders)) {
      it2 = q2.orders.reduce((it3, f4) => sortAll(it3, f4), it2);
    }
    if (q2.offset != null) {
      let i3 = 0;
      it2 = filter$1(it2, () => i3++ >= q2.offset);
    }
    if (q2.limit != null) {
      it2 = take$1(it2, q2.limit);
    }
    return it2;
  }
}
class MemoryBlockStore extends BaseBlockstore {
  constructor() {
    super();
    this.store = /* @__PURE__ */ new Map();
  }
  async *blocks() {
    for (const [cidStr, bytes2] of this.store.entries()) {
      yield { cid: CID.parse(cidStr), bytes: bytes2 };
    }
  }
  put(cid, bytes2) {
    this.store.set(cid.toString(), bytes2);
    return Promise.resolve();
  }
  get(cid) {
    const bytes2 = this.store.get(cid.toString());
    if (!bytes2) {
      throw new Error(`block with cid ${cid.toString()} no found`);
    }
    return Promise.resolve(bytes2);
  }
  has(cid) {
    return Promise.resolve(this.store.has(cid.toString()));
  }
  close() {
    this.store.clear();
    return Promise.resolve();
  }
}
const unixfsImporterOptionsDefault = {
  cidVersion: 1,
  chunker: "fixed",
  maxChunkSize: 262144,
  hasher: sha256$3,
  rawLeaves: true,
  wrapWithDirectory: true,
  maxChildrenPerNode: 174
};
async function pack({ input, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves }) {
  if (!input || Array.isArray(input) && !input.length) {
    throw new Error("missing input file(s)");
  }
  const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();
  const rootEntry = await last$1(pipe$1(getNormaliser(input), (source) => importer(source, blockstore, {
    ...unixfsImporterOptionsDefault,
    hasher: hasher || unixfsImporterOptionsDefault.hasher,
    maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,
    maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,
    wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,
    rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves
  })));
  if (!rootEntry || !rootEntry.cid) {
    throw new Error("given input could not be parsed correctly");
  }
  const root2 = rootEntry.cid;
  const { writer: writer2, out: carOut } = await CarWriter.create([root2]);
  const carOutIter = carOut[Symbol.asyncIterator]();
  let writingPromise;
  const writeAll = async () => {
    for await (const block2 of blockstore.blocks()) {
      await writer2.put(block2);
    }
    await writer2.close();
    if (!userBlockstore) {
      await blockstore.close();
    }
  };
  const out = {
    [Symbol.asyncIterator]() {
      if (writingPromise != null) {
        throw new Error("Multiple iterator not supported");
      }
      writingPromise = writeAll();
      return {
        async next() {
          const result = await carOutIter.next();
          if (result.done) {
            await writingPromise;
          }
          return result;
        }
      };
    }
  };
  return { root: root2, out };
}
var throttledQueue$1 = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  function throttledQueue2(maxRequestsPerInterval, interval2, evenlySpaced) {
    if (evenlySpaced === void 0) {
      evenlySpaced = false;
    }
    if (evenlySpaced) {
      interval2 = interval2 / maxRequestsPerInterval;
      maxRequestsPerInterval = 1;
    }
    var queue2 = [];
    var lastIntervalStart = 0;
    var numRequestsPerInterval = 0;
    var timeout2;
    var dequeue = function() {
      var intervalEnd = lastIntervalStart + interval2;
      var now = Date.now();
      if (now < intervalEnd) {
        timeout2 !== void 0 && clearTimeout(timeout2);
        timeout2 = setTimeout(dequeue, intervalEnd - now);
        return;
      }
      lastIntervalStart = now;
      numRequestsPerInterval = 0;
      for (var _i = 0, _a2 = queue2.splice(0, maxRequestsPerInterval); _i < _a2.length; _i++) {
        var callback = _a2[_i];
        numRequestsPerInterval++;
        void callback();
      }
      if (queue2.length) {
        timeout2 = setTimeout(dequeue, interval2);
      } else {
        timeout2 = void 0;
      }
    };
    return function(fn2) {
      return new Promise(function(resolve, reject) {
        var callback = function() {
          return Promise.resolve().then(fn2).then(resolve).catch(reject);
        };
        var now = Date.now();
        if (timeout2 === void 0 && now - lastIntervalStart > interval2) {
          lastIntervalStart = now;
          numRequestsPerInterval = 0;
        }
        if (numRequestsPerInterval++ < maxRequestsPerInterval) {
          void callback();
        } else {
          queue2.push(callback);
          if (timeout2 === void 0) {
            timeout2 = setTimeout(dequeue, lastIntervalStart + interval2 - now);
          }
        }
      });
    };
  }
  module2.exports = throttledQueue2;
  exports2.default = throttledQueue2;
})(throttledQueue$1, throttledQueue$1.exports);
var throttledQueueExports = throttledQueue$1.exports;
const throttledQueue = /* @__PURE__ */ getDefaultExportFromCjs(throttledQueueExports);
const CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token$2(Type.tag, CID_CBOR_TAG),
    new Token$2(Type.bytes, bytes2)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
const decodeOptions = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
const name = "dag-cbor";
const code = 113;
const encode = (node2) => encode$6(node2, encodeOptions);
const decode = (data2) => decode$5(data2, decodeOptions);
const dagCbor = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code,
  decode,
  encode,
  name
}, Symbol.toStringTag, { value: "Module" }));
const fetch$1 = globalThis.fetch;
const Blob$1 = globalThis.Blob;
const Blockstore = MemoryBlockStore;
const GATEWAY = new URL("https://nftstorage.link/");
const toGatewayURL = (url, options = {}) => {
  const gateway = options.gateway || GATEWAY;
  url = new URL(String(url));
  return url.protocol === "ipfs:" ? new URL(`/ipfs/${url.href.slice("ipfs://".length)}`, gateway) : url;
};
class BlockstoreCarReader {
  /**
   * @param {number} version
   * @param {CID[]} roots
   * @param {import('ipfs-car/blockstore').Blockstore} blockstore
   */
  constructor(version2, roots2, blockstore) {
    this._version = version2;
    this._roots = roots2;
    this._blockstore = blockstore;
  }
  get version() {
    return this._version;
  }
  get blockstore() {
    return this._blockstore;
  }
  async getRoots() {
    return this._roots;
  }
  /**
   * @param {CID} cid
   */
  has(cid) {
    return this._blockstore.has(cid);
  }
  /**
   * @param {CID} cid
   */
  async get(cid) {
    const bytes2 = await this._blockstore.get(cid);
    return { cid, bytes: bytes2 };
  }
  blocks() {
    return this._blockstore.blocks();
  }
  async *cids() {
    for await (const b4 of this.blocks()) {
      yield b4.cid;
    }
  }
}
let Token$1 = class Token3 {
  /**
   * @param {import('./lib/interface.js').CIDString} ipnft
   * @param {import('./lib/interface.js').EncodedURL} url
   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data
   */
  constructor(ipnft, url, data2) {
    this.ipnft = ipnft;
    this.url = url;
    this.data = data2;
    Object.defineProperties(this, {
      ipnft: { enumerable: true, writable: false },
      url: { enumerable: true, writable: false },
      data: { enumerable: false, writable: false }
    });
  }
  /**
   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}
   */
  embed() {
    return Token3.embed(this);
  }
  /**
   * @template {TokenInput} T
   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token
   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}
   */
  static embed({ data: data2 }) {
    return embed(data2, { gateway: GATEWAY });
  }
  /**
   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new
   * Token instance from it. Where values are discovered `Blob` (or `File`)
   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`
   * prefixed CID with an optional path).
   *
   * @example
   * ```js
   * const cat = new File(['...'], 'cat.png')
   * const kitty = new File(['...'], 'kitty.png')
   * const { token, car } = await Token.encode({
   *   name: 'hello'
   *   image: cat
   *   properties: {
   *     extra: {
   *       image: kitty
   *     }
   *   }
   * })
   * ```
   *
   * @template {TokenInput} T
   * @param {T} input
   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}
   */
  static async encode(input) {
    const blockstore = new Blockstore();
    const [blobs, meta] = mapTokenInputBlobs(input);
    const data2 = JSON.parse(JSON.stringify(meta));
    const dag = JSON.parse(JSON.stringify(meta));
    for (const [dotPath, blob] of blobs.entries()) {
      const name2 = blob.name || "blob";
      const content = blob.stream();
      const { root: cid } = await pack({
        input: [{ path: name2, content }],
        blockstore,
        wrapWithDirectory: true
      });
      const href = new URL(`ipfs://${cid}/${name2}`);
      const path = dotPath.split(".");
      setIn(data2, path, href);
      setIn(dag, path, cid);
    }
    const { root: metadataJsonCid } = await pack({
      input: [{ path: "metadata.json", content: JSON.stringify(data2) }],
      blockstore,
      wrapWithDirectory: false
    });
    const block2 = await encode$4({
      value: {
        ...dag,
        "metadata.json": metadataJsonCid,
        type: "nft"
      },
      codec: dagCbor,
      hasher: sha256$3
    });
    await blockstore.put(block2.cid, block2.bytes);
    return {
      cid: block2.cid,
      token: new Token3(
        block2.cid.toString(),
        `ipfs://${block2.cid}/metadata.json`,
        data2
      ),
      car: new BlockstoreCarReader(1, [block2.cid], blockstore)
    };
  }
};
const embed = (input, options) => mapWith(input, isURL, embedURL, options);
const isURL = (value) => value instanceof URL;
const embedURL = (context, url) => [context, toGatewayURL(url, context)];
const isObject = (value) => typeof value === "object" && value != null;
const encodeBlob = (data2, blob, path) => {
  data2.set(path.join("."), blob);
  return [data2, void 0];
};
const isBlob = (value) => value instanceof Blob$1;
const mapTokenInputBlobs = (input) => {
  return mapValueWith(input, isBlob, encodeBlob, /* @__PURE__ */ new Map(), []);
};
const mapWith = (input, p3, f4, state2) => {
  const [, output] = mapValueWith(input, p3, f4, state2, []);
  return output;
};
const mapValueWith = (input, p3, f4, state2, path) => p3(input, state2, path) ? f4(state2, input, path) : Array.isArray(input) ? mapArrayWith(input, p3, f4, state2, path) : isObject(input) ? mapObjectWith(input, p3, f4, state2, path) : [
  state2,
  /** @type {any} */
  input
];
const mapObjectWith = (input, p3, f4, init3, path) => {
  let state2 = init3;
  const output = (
    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */
    {}
  );
  for (const [key2, value] of Object.entries(input)) {
    const [next, out] = mapValueWith(value, p3, f4, state2, [...path, key2]);
    output[key2] = out;
    state2 = next;
  }
  return [state2, output];
};
const mapArrayWith = (input, p3, f4, init3, path) => {
  const output = (
    /** @type {unknown[]} */
    []
  );
  let state2 = init3;
  for (const [index2, element] of input.entries()) {
    const [next, out] = mapValueWith(element, p3, f4, state2, [...path, index2]);
    output[index2] = out;
    state2 = next;
  }
  return [
    state2,
    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */
    output
  ];
};
const setIn = (object2, path, value) => {
  const n4 = path.length - 1;
  let target = object2;
  for (let [index2, key2] of path.entries()) {
    if (index2 === n4) {
      target[key2] = value;
    } else {
      target = target[key2];
    }
  }
};
const MAX_STORE_RETRIES = 5;
const MAX_CONCURRENT_UPLOADS = 3;
const MAX_CHUNK_SIZE = 1024 * 1024 * 10;
const RATE_LIMIT_REQUESTS = 30;
const RATE_LIMIT_PERIOD = 10 * 1e3;
function createRateLimiter() {
  const throttle2 = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD);
  return () => throttle2(() => {
  });
}
const globalRateLimiter = createRateLimiter();
class NFTStorage {
  /**
   * Constructs a client bound to the given `options.token` and
   * `options.endpoint`.
   *
   * @example
   * ```js
   * import { NFTStorage, File, Blob } from "nft.storage"
   * const client = new NFTStorage({ token: API_TOKEN })
   *
   * const cid = await client.storeBlob(new Blob(['hello world']))
   * ```
   * Optionally you could pass an alternative API endpoint (e.g. for testing)
   * @example
   * ```js
   * import { NFTStorage } from "nft.storage"
   * const client = new NFTStorage({
   *   token: API_TOKEN
   *   endpoint: new URL('http://localhost:8080/')
   * })
   * ```
   *
   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options
   */
  constructor({
    token: token2,
    did,
    endpoint = new URL("https://api.nft.storage"),
    rateLimiter
  }) {
    this.token = token2;
    this.endpoint = endpoint;
    this.rateLimiter = rateLimiter || createRateLimiter();
    this.did = did;
  }
  /**
   * @hidden
   * @param {object} options
   * @param {string} options.token
   * @param {string} [options.did]
   */
  static auth({ token: token2, did }) {
    if (!token2)
      throw new Error("missing token");
    return {
      Authorization: `Bearer ${token2}`,
      "X-Client": "nft.storage/js",
      ...did ? { "x-agent-did": did } : {}
    };
  }
  /**
   * Stores a single file and returns its CID.
   *
   * @param {Service} service
   * @param {Blob} blob
   * @param {RequestOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static async storeBlob(service2, blob, options) {
    const blockstore = new Blockstore();
    let cidString;
    try {
      const { cid, car } = await NFTStorage.encodeBlob(blob, { blockstore });
      await NFTStorage.storeCar(service2, car, options);
      cidString = cid.toString();
    } finally {
      await blockstore.close();
    }
    return cidString;
  }
  /**
   * Stores a CAR file and returns its root CID.
   *
   * @param {Service} service
   * @param {Blob|CarReader} car
   * @param {import('./lib/interface.js').CarStorerOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static async storeCar({ endpoint, rateLimiter = globalRateLimiter, ...token2 }, car, { onStoredChunk, maxRetries, decoders, signal } = {}) {
    const url = new URL("upload/", endpoint);
    const headers = NFTStorage.auth(token2);
    const targetSize = MAX_CHUNK_SIZE;
    const splitter = car instanceof Blob$1 ? await TreewalkCarSplitter.fromBlob(car, targetSize, { decoders }) : new TreewalkCarSplitter(car, targetSize, { decoders });
    const upload = transform(
      MAX_CONCURRENT_UPLOADS,
      async function(car2) {
        const carParts = [];
        for await (const part of car2) {
          carParts.push(part);
        }
        const carFile = new Blob$1(carParts, { type: "application/car" });
        const cid = await pRetry$1(
          async () => {
            await rateLimiter();
            let response;
            try {
              response = await fetch$1(url.toString(), {
                method: "POST",
                headers,
                body: carFile,
                signal
              });
            } catch (err) {
              throw signal && signal.aborted ? new AbortError_1(err) : err;
            }
            if (response.status === 429) {
              throw new Error("rate limited");
            }
            const result = await response.json();
            if (!result.ok) {
              if (response.status === 401) {
                throw new AbortError_1(result.error.message);
              }
              throw new Error(result.error.message);
            }
            return result.value.cid;
          },
          {
            retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries
          }
        );
        onStoredChunk && onStoredChunk(carFile.size);
        return cid;
      }
    );
    let root2;
    for await (const cid of upload(splitter.cars())) {
      root2 = cid;
    }
    return (
      /** @type {CIDString} */
      root2
    );
  }
  /**
   * Stores a directory of files and returns a CID. Provided files **MUST**
   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,
   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.
   *
   * @param {Service} service
   * @param {FilesSource} filesSource
   * @param {RequestOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static async storeDirectory(service2, filesSource, options) {
    const blockstore = new Blockstore();
    let cidString;
    try {
      const { cid, car } = await NFTStorage.encodeDirectory(filesSource, {
        blockstore
      });
      await NFTStorage.storeCar(service2, car, options);
      cidString = cid.toString();
    } finally {
      await blockstore.close();
    }
    return cidString;
  }
  /**
   * Stores the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The
   * `token.image` must be either a `File` or a `Blob` instance, which will be
   * stored and the corresponding content address URL will be saved in the
   * metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {Service} service
   * @param {T} metadata
   * @param {RequestOptions} [options]
   * @returns {Promise<TokenType<T>>}
   */
  static async store(service2, metadata, options) {
    const { token: token2, car } = await NFTStorage.encodeNFT(metadata);
    await NFTStorage.storeCar(service2, car, options);
    return token2;
  }
  /**
   * Returns current status of the stored NFT by its CID. Note the NFT must
   * have previously been stored by this account.
   *
   * @param {Service} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<import('./lib/interface.js').StatusResult>}
   */
  static async status({ endpoint, rateLimiter = globalRateLimiter, ...token2 }, cid, options) {
    const url = new URL(`${cid}/`, endpoint);
    await rateLimiter();
    const response = await fetch$1(url.toString(), {
      method: "GET",
      headers: NFTStorage.auth(token2),
      signal: options && options.signal
    });
    if (response.status === 429) {
      throw new Error("rate limited");
    }
    const result = await response.json();
    if (result.ok) {
      return {
        cid: result.value.cid,
        deals: decodeDeals(result.value.deals),
        size: result.value.size,
        pin: decodePin(result.value.pin),
        created: new Date(result.value.created)
      };
    } else {
      throw new Error(result.error.message);
    }
  }
  /**
   * Check if a CID of an NFT is being stored by NFT.Storage.
   *
   * @param {import('./lib/interface.js').PublicService} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<import('./lib/interface.js').CheckResult>}
   */
  static async check({ endpoint, rateLimiter = globalRateLimiter }, cid, options) {
    const url = new URL(`check/${cid}/`, endpoint);
    await rateLimiter();
    const response = await fetch$1(url.toString(), {
      signal: options && options.signal
    });
    if (response.status === 429) {
      throw new Error("rate limited");
    }
    const result = await response.json();
    if (result.ok) {
      return {
        cid: result.value.cid,
        deals: decodeDeals(result.value.deals),
        pin: result.value.pin
      };
    } else {
      throw new Error(result.error.message);
    }
  }
  /**
   * Removes stored content by its CID from this account. Please note that
   * even if content is removed from the service other nodes that have
   * replicated it might still continue providing it.
   *
   * @param {Service} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<void>}
   */
  static async delete({ endpoint, rateLimiter = globalRateLimiter, ...token2 }, cid, options) {
    const url = new URL(`${cid}/`, endpoint);
    await rateLimiter();
    const response = await fetch$1(url.toString(), {
      method: "DELETE",
      headers: NFTStorage.auth(token2),
      signal: options && options.signal
    });
    if (response.status === 429) {
      throw new Error("rate limited");
    }
    const result = await response.json();
    if (!result.ok) {
      throw new Error(result.error.message);
    }
  }
  /**
   * Encodes the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a
   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,
   * which will be stored and the corresponding content address URL will be
   * saved in the metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @example
   * ```js
   * const { token, car } = await NFTStorage.encodeNFT({
   *   name: 'nft.storage store test',
   *   description: 'Test ERC-1155 compatible metadata.',
   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),
   *   properties: {
   *     custom: 'Custom data can appear here, files are auto uploaded.',
   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),
   *   }
   * })
   *
   * console.log('IPFS URL for the metadata:', token.url)
   * console.log('metadata.json contents:\n', token.data)
   * console.log('metadata.json with IPFS gateway URLs:\n', token.embed())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {T} input
   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}
   */
  static async encodeNFT(input) {
    validateERC1155(input);
    return Token$1.encode(input);
  }
  /**
   * Encodes a single file to a CAR file and also returns its root CID.
   *
   * @example
   * ```js
   * const content = new Blob(['hello world'])
   * const { cid, car } = await NFTStorage.encodeBlob(content)
   *
   * // Root CID of the file
   * console.log(cid.toString())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @param {Blob} blob
   * @param {object} [options]
   * @param {BlockstoreI} [options.blockstore]
   * @returns {Promise<{ cid: CID, car: CarReader }>}
   */
  static async encodeBlob(blob, { blockstore } = {}) {
    if (blob.size === 0) {
      throw new Error("Content size is 0, make sure to provide some content");
    }
    return packCar([toImportCandidate("blob", blob)], {
      blockstore,
      wrapWithDirectory: false
    });
  }
  /**
   * Encodes a directory of files to a CAR file and also returns the root CID.
   * Provided files **MUST** be within the same directory, otherwise error is
   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,
   * `bla/baz.json` is not.
   *
   * @example
   * ```js
   * const { cid, car } = await NFTStorage.encodeDirectory([
   *   new File(['hello world'], 'hello.txt'),
   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')
   * ])
   *
   * // Root CID of the directory
   * console.log(cid.toString())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @param {FilesSource} files
   * @param {object} [options]
   * @param {BlockstoreI} [options.blockstore]
   * @returns {Promise<{ cid: CID, car: CarReader }>}
   */
  static async encodeDirectory(files, { blockstore } = {}) {
    let size2 = 0;
    const input = pipe$1(files, async function* (files2) {
      for await (const file of files2) {
        yield toImportCandidate(file.name, file);
        size2 += file.size;
      }
    });
    const packed = await packCar(input, {
      blockstore,
      wrapWithDirectory: true
    });
    if (size2 === 0) {
      throw new Error(
        "Total size of files should exceed 0, make sure to provide some content"
      );
    }
    return packed;
  }
  // Just a sugar so you don't have to pass around endpoint and token around.
  /**
   * Stores a single file and returns the corresponding Content Identifier (CID).
   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)
   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note
   * that no file name or file metadata is retained.
   *
   * @example
   * ```js
   * const content = new Blob(['hello world'])
   * const cid = await client.storeBlob(content)
   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'
   * ```
   *
   * @param {Blob} blob
   * @param {RequestOptions} [options]
   */
  storeBlob(blob, options) {
    return NFTStorage.storeBlob(this, blob, options);
  }
  /**
   * Stores files encoded as a single [Content Addressed Archive
   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).
   *
   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)
   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).
   *
   * Returns the corresponding Content Identifier (CID).
   *
   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more
   * details on packing a CAR file.
   *
   * @example
   * ```js
   * import { pack } from 'ipfs-car/pack'
   * import { CarReader } from '@ipld/car'
   * const { out, root } = await pack({
   *  input: fs.createReadStream('pinpie.pdf')
   * })
   * const expectedCid = root.toString()
   * const carReader = await CarReader.fromIterable(out)
   * const cid = await storage.storeCar(carReader)
   * console.assert(cid === expectedCid)
   * ```
   *
   * @example
   * ```
   * import { packToBlob } from 'ipfs-car/pack/blob'
   * const data = 'Hello world'
   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })
   * const expectedCid = root.toString()
   * const cid = await client.storeCar(car)
   * console.assert(cid === expectedCid)
   * ```
   * @param {Blob|CarReader} car
   * @param {import('./lib/interface.js').CarStorerOptions} [options]
   */
  storeCar(car, options) {
    return NFTStorage.storeCar(this, car, options);
  }
  /**
   * Stores a directory of files and returns a CID for the directory.
   *
   * @example
   * ```js
   * const cid = await client.storeDirectory([
   *   new File(['hello world'], 'hello.txt'),
   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')
   * ])
   * cid //>
   * ```
   *
   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)
   * instance as well, in which case directory structure will be retained.
   *
   * @param {FilesSource} files
   * @param {RequestOptions} [options]
   */
  storeDirectory(files, options) {
    return NFTStorage.storeDirectory(this, files, options);
  }
  /**
   * Returns current status of the stored NFT by its CID. Note the NFT must
   * have previously been stored by this account.
   *
   * @example
   * ```js
   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  status(cid, options) {
    return NFTStorage.status(this, cid, options);
  }
  /**
   * Removes stored content by its CID from the service.
   *
   * > Please note that even if content is removed from the service other nodes
   * that have replicated it might still continue providing it.
   *
   * @example
   * ```js
   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  delete(cid, options) {
    return NFTStorage.delete(this, cid, options);
  }
  /**
   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT
   * was not found.
   *
   * @example
   * ```js
   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  check(cid, options) {
    return NFTStorage.check(this, cid, options);
  }
  /**
   * Stores the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in
   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The
   * `token.image` must be either a `File` or a `Blob` instance, which will be
   * stored and the corresponding content address URL will be saved in the
   * metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @example
   * ```js
   * const metadata = await client.store({
   *   name: 'nft.storage store test',
   *   description: 'Test ERC-1155 compatible metadata.',
   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),
   *   properties: {
   *     custom: 'Custom data can appear here, files are auto uploaded.',
   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),
   *   }
   * })
   *
   * console.log('IPFS URL for the metadata:', metadata.url)
   * console.log('metadata.json contents:\n', metadata.data)
   * console.log('metadata.json with IPFS gateway URLs:\n', metadata.embed())
   * ```
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {T} token
   * @param {RequestOptions} [options]
   */
  store(token2, options) {
    return NFTStorage.store(this, token2, options);
  }
}
const validateERC1155 = ({ name: name2, description, image, decimals }) => {
  if (typeof name2 !== "string") {
    throw new TypeError(
      "string property `name` identifying the asset is required"
    );
  }
  if (typeof description !== "string") {
    throw new TypeError(
      "string property `description` describing asset is required"
    );
  }
  if (!(image instanceof Blob$1)) {
    throw new TypeError("property `image` must be a Blob or File object");
  } else if (!image.type.startsWith("image/")) {
    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.

For better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \`properties: { video: file }\` and using 'image' field for storing a preview image for it instead.

For more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`);
  }
  if (typeof decimals !== "undefined" && typeof decimals !== "number") {
    throw new TypeError("property `decimals` must be an integer value");
  }
};
const packCar = async (input, { blockstore, wrapWithDirectory } = {}) => {
  blockstore = blockstore || new Blockstore();
  const { root: cid } = await pack({ input, blockstore, wrapWithDirectory });
  const car = new BlockstoreCarReader(1, [cid], blockstore);
  return { cid, car };
};
const decodeDeals = (deals) => deals.map((deal) => {
  const { dealActivation, dealExpiration, lastChanged } = {
    dealExpiration: null,
    dealActivation: null,
    ...deal
  };
  return {
    ...deal,
    lastChanged: new Date(lastChanged),
    ...dealActivation && { dealActivation: new Date(dealActivation) },
    ...dealExpiration && { dealExpiration: new Date(dealExpiration) }
  };
});
const decodePin = (pin) => ({ ...pin, created: new Date(pin.created) });
function toImportCandidate(path, blob) {
  let stream2;
  return {
    path,
    get content() {
      stream2 = stream2 || blob.stream();
      return stream2;
    }
  };
}
const style = "_style_11ouq_1";
const cs = {
  style
};
const contractNetwork = (() => {
  switch (window.location.host) {
    case "op.chiev.es": {
      return "optimisticEthereum";
    }
    case "poly.chiev.es": {
      return "polygon";
    }
    default: {
      {
        return "optimisticEthereum";
      }
    }
  }
})();
const ipfsLinkPattern = typeof IPFS_LINK_PATTERN !== "undefined" ? IPFS_LINK_PATTERN : "https://nftstorage.link/{protocol}/{v1cid}/{path}";
const nftGraph = typeof NFT_GRAPH !== "undefined" ? NFT_GRAPH : "https://api.thegraph.com/subgraphs/name/alberthaotan/nft-matic";
const nftBase = typeof NFT_BASE !== "undefined" ? NFT_BASE : "https://chiev.es/#/view";
const envNFTStorageAPIToken = typeof NFT_STORAGE_API_TOKEN !== "undefined" ? NFT_STORAGE_API_TOKEN : null;
const walletConnectProjectId = "806b7118ca48eec75f6cf7981bfca00d";
const rolePermissions = {
  Superuser: "Can perform all actions on the token.",
  Minter: "Can mint new instances of the token.",
  Caster: "Can assign roles for the token.",
  Transferer: "Can transfer the token to another account.",
  Configurer: "Can change the token’s metadata URI.",
  Maintainer: "Can update the token contract.",
  Creator: "Can create new token types.",
  Limiter: "Can set the maximum mintable allowance for a token.",
  Burner: "Can destroy an instance of a token.",
  Destroyer: "Can destroy a token type.",
  Oracle: "Provides information about the off-chain world."
};
const tokenPermissions = [
  "Superuser",
  "Minter",
  "Caster",
  "Transferer",
  "Configurer",
  "Limiter",
  "Burner",
  "Destroyer"
];
const defaults = {
  limit: 10,
  offset: 0,
  gating: false,
  visible: ""
};
const Settings = reactExports.forwardRef(({
  nftStorageAPIToken: apiToken,
  setNFTStorageAPIToken: setAPIToken
}, ref2) => {
  const [internalAPIToken, setInternalAPIToken] = reactExports.useState(apiToken ?? "");
  return /* @__PURE__ */ jsx("dialog", { ...{ ref: ref2 }, id: cs.style, children: /* @__PURE__ */ jsxs(
    "form",
    {
      onSubmit: () => {
        setAPIToken(internalAPIToken);
      },
      children: [
        /* @__PURE__ */ jsx("header", { children: /* @__PURE__ */ jsx("h2", { children: "Settings" }) }),
        /* @__PURE__ */ jsx("main", { children: /* @__PURE__ */ jsxs("label", { children: [
          /* @__PURE__ */ jsxs("h3", { children: [
            /* @__PURE__ */ jsx(
              "a",
              {
                target: "_blank",
                href: "//nft.storage",
                rel: "noreferrer",
                children: "NFT.Storage"
              }
            ),
            "API Token",
            /* @__PURE__ */ jsx("span", { children: "*" })
          ] }),
          /* @__PURE__ */ jsx(
            "input",
            {
              placeholder: "Required Token",
              type: "password",
              autoComplete: "off",
              value: internalAPIToken,
              onChange: ({ target: { value } }) => {
                setInternalAPIToken(value);
              }
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxs("footer", { children: [
          /* @__PURE__ */ jsx("button", { formMethod: "dialog", children: "Cancel" }),
          /* @__PURE__ */ jsx("button", { children: "Save" })
        ] })
      ]
    }
  ) });
});
Settings.displayName = "Settings";
const useConfig = ({ requireStorage = false } = {}) => {
  const host2 = window.location.host;
  const key2 = `chievemints-${host2}-nftStorageAPIToken`;
  const store = localStorage;
  const [nftStorageAPIToken, baseSetNFTStorageAPIToken] = reactExports.useState(
    envNFTStorageAPIToken ?? store.getItem(key2) ?? null
  );
  const setNFTStorageAPIToken = reactExports.useCallback(
    (token2) => {
      store.setItem(key2, token2);
      baseSetNFTStorageAPIToken(token2);
    },
    [key2, store]
  );
  const dialog = reactExports.useRef(null);
  const storage = reactExports.useMemo(() => {
    const token2 = nftStorageAPIToken;
    return token2 ? new NFTStorage({ token: token2 }) : null;
  }, [nftStorageAPIToken]);
  const openSettings = reactExports.useCallback(() => {
    if (!dialog.current) {
      console.error({ openSettings: "dialog.current is null" });
    } else {
      dialog.current.showModal();
    }
  }, [dialog]);
  const SettingsDialog = reactExports.useCallback(
    () => /* @__PURE__ */ jsx(
      Settings,
      {
        ref: dialog,
        ...{
          nftStorageAPIToken,
          setNFTStorageAPIToken
        }
      }
    ),
    [nftStorageAPIToken, setNFTStorageAPIToken]
  );
  return reactExports.useMemo(() => ({
    storage,
    openSettings,
    Settings: SettingsDialog
  }), [storage, openSettings, SettingsDialog]);
};
const networks = [
  "mainnet",
  "gnosis",
  "polygon",
  "mumbai",
  "optimism",
  "localhost"
];
const NETWORKS = {
  mainnet: {
    chainId: 1,
    name: "Ethereum Mainnet",
    label: "Ethereum",
    currency: "ETH",
    explorerUrl: "https://etherscan.io",
    rpcUrl: typeof MAINNET_RPC !== "undefined" ? MAINNET_RPC : "https://eth.public-rpcUrl.com/"
  },
  gnosis: {
    chainId: 100,
    name: "Gnosis Chain",
    label: "Gnosis",
    currency: "xDAI",
    explorerUrl: "https://blockscout.com/xdai/mainnet",
    rpcUrl: typeof GNOSIS_RPC !== "undefined" ? GNOSIS_RPC : "https://rpcUrl.gnosischain.com/"
  },
  polygon: {
    chainId: 137,
    name: "Polygon",
    label: "Polygon",
    currency: "MATIC",
    explorerUrl: "https://polygonscan.com",
    rpcUrl: typeof POLYGON_RPC !== "undefined" ? POLYGON_RPC : "https://polygon-rpcUrl.com"
  },
  mumbai: {
    chainId: 80001,
    name: "Polygon’s Mumbai Testnet",
    label: "Mumbai",
    currency: "𝙼𝙰𝚃𝙸𝙲",
    explorerUrl: "https://mumbai.polygonscan.com",
    rpcUrl: typeof MUMBAI_RPC !== "undefined" ? MUMBAI_RPC : "https://rpcUrl.ankr.com/polygon_mumbai"
  },
  optimisticEthereum: {
    chainId: 10,
    name: "Optimism",
    label: "Optimism",
    currency: "OETH",
    explorerUrl: "https://optimistic.etherscan.io",
    rpcUrl: typeof OPTIMISM_RPC !== "undefined" ? OPTIMISM_RPC : "https://mainnet.optimism.io"
  },
  localhost: {
    chainId: 31337,
    name: "Ganache",
    label: "Ganache",
    currency: "🄴🅃🄷",
    explorerUrl: null,
    rpcUrl: typeof LOCAL_RPC !== "undefined" ? LOCAL_RPC : "http://127.0.0.1:8545"
  },
  get contract() {
    let net = this[contractNetwork];
    if (!net) {
      networks.forEach((name2) => {
        if (contractNetwork.toLowerCase().includes(name2)) {
          net = this[name2];
        }
      });
    }
    return net;
  }
};
const Web3Context = reactExports.createContext({
  connect: async () => {
    throw new Error("Unimplemented");
  },
  disconnect: () => {
    throw new Error("Unimplemented");
  },
  connecting: false,
  connected: false,
  contract: {
    address: null,
    abi: null
  }
});
const useWeb3 = () => reactExports.useContext(Web3Context);
const Web3ContextProvider = ({ children }) => {
  const [web3Modal, setWeb3Modal] = reactExports.useState(null);
  const [userProvider, setUserProvider] = reactExports.useState();
  const [chain, setChain] = reactExports.useState();
  const [address, setAddress] = reactExports.useState();
  const [connected, setConnected] = reactExports.useState(false);
  const [contractAddress, setContractAddress] = reactExports.useState(null);
  const [abi2, setABI] = reactExports.useState(null);
  const [rolesAddress, setRolesAddress] = reactExports.useState(null);
  const [rolesABI, setRolesABI] = reactExports.useState(null);
  const [bitsAddress, setBitsAddress] = reactExports.useState(null);
  const [bitsABI, setBitsABI] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const lib2 = async () => {
      if (typeof window !== "undefined") {
        const metadata = {
          name: "’Chievemints",
          description: "MetaGame’s NFT ’Chievemints award attestations.",
          url: "https://chiev.es",
          icons: []
        };
        setWeb3Modal(
          createWeb3Modal({
            projectId: walletConnectProjectId,
            chains: [NETWORKS[contractNetwork]],
            ethersConfig: defaultConfig$1({ metadata })
          })
        );
      }
    };
    lib2();
  }, []);
  const [connecting, setConnecting] = reactExports.useState(!!web3Modal?.cachedProvider);
  const ensProvider = reactExports.useMemo(
    () => new StaticJsonRpcProvider(NETWORKS.mainnet.rpcUrl),
    []
  );
  const contractProvider = reactExports.useMemo(
    () => new StaticJsonRpcProvider(NETWORKS.contract.rpcUrl),
    []
  );
  const roContract = reactExports.useMemo(
    () => {
      if (contractAddress && abi2) {
        return new Contract(contractAddress, abi2, contractProvider);
      }
    },
    [contractProvider, abi2, contractAddress]
  );
  const bitsLibrary = reactExports.useMemo(
    () => {
      if (bitsAddress && bitsABI) {
        return new Contract(bitsAddress, bitsABI, contractProvider);
      }
    },
    [contractProvider, bitsABI, bitsAddress]
  );
  const rolesLibrary = reactExports.useMemo(
    () => {
      if (rolesAddress && rolesABI) {
        return new Contract(rolesAddress, rolesABI, contractProvider);
      }
    },
    [contractProvider, rolesABI, rolesAddress]
  );
  const rwContract = reactExports.useMemo(
    () => {
      if (contractAddress && abi2 && userProvider && chain === NETWORKS.contract.chainId) {
        return new Contract(contractAddress, abi2, userProvider.getSigner());
      } else {
        return void 0;
      }
    },
    [userProvider, chain, abi2, contractAddress]
  );
  const disconnect = reactExports.useCallback(() => {
    web3Modal?.clearCachedProvider();
    setAddress(void 0);
    setChain(void 0);
    setUserProvider(void 0);
    setConnecting(false);
    setConnected(false);
    setContractAddress(null);
    setABI(null);
  }, [web3Modal]);
  const update5 = reactExports.useCallback(
    async (vider) => {
      const web3Provider = new Web3Provider(vider);
      await web3Provider.ready;
      setUserProvider(web3Provider);
      setAddress(await web3Provider.getSigner().getAddress());
      setChain(Number(vider.chainId));
    },
    []
  );
  const connect = reactExports.useCallback(async () => {
    console.debug("Connecting…");
    if (web3Modal == null) {
      throw new Error(`Web3Modal is ${web3Modal}`);
    }
    setConnecting(true);
    try {
      const prov = await web3Modal.connect();
      await update5(prov);
      prov.on("accountsChanged", () => {
        disconnect();
      });
      prov.on("chainChanged", () => {
        update5(prov);
      });
    } catch (error) {
      console.error("`connect` Error", error);
      disconnect();
    } finally {
      setConnecting(false);
    }
  }, [disconnect, update5, web3Modal]);
  reactExports.useEffect(() => {
    if (web3Modal?.cachedProvider) {
      connect();
    }
  }, []);
  reactExports.useEffect(() => {
    const libs = async () => {
      const chain2 = contractNetwork;
      if (!contractAddress) {
        __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/dysMumbai/BulkDisbursableNFTs.address.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.address-3a0e05e8.js"), true ? [] : void 0), "../contracts/mumbai/BulkDisbursableNFTs.address.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.address-2cf40a1a.js"), true ? [] : void 0), "../contracts/optimisticEthereum/BulkDisbursableNFTs.address.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.address-49d44612.js"), true ? [] : void 0), "../contracts/polygon/BulkDisbursableNFTs.address.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.address-1d795b30.js"), true ? [] : void 0) }), `../contracts/${chain2}/BulkDisbursableNFTs.address.ts`).then(({ default: addr }) => setContractAddress(addr));
      }
      if (!abi2) {
        __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/dysMumbai/BulkDisbursableNFTs.abi.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.abi-6fd52542.js"), true ? [] : void 0), "../contracts/mumbai/BulkDisbursableNFTs.abi.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.abi-1508ba0e.js"), true ? [] : void 0), "../contracts/optimisticEthereum/BulkDisbursableNFTs.abi.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.abi-18cf1a1c.js"), true ? [] : void 0), "../contracts/polygon/BulkDisbursableNFTs.abi.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.abi-c23a0720.js"), true ? [] : void 0) }), `../contracts/${chain2}/BulkDisbursableNFTs.abi.ts`).then(({ default: abi22 }) => setABI(abi22));
      }
    };
    libs();
  }, [abi2, contractAddress, userProvider]);
  reactExports.useEffect(() => {
    const libs = async () => {
      const chain2 = contractNetwork;
      __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/dysMumbai/Bits.address.ts": () => __vitePreload(() => import("./Bits.address-2c9b59b2.js"), true ? [] : void 0), "../contracts/mumbai/Bits.address.ts": () => __vitePreload(() => import("./Bits.address-9884dbb4.js"), true ? [] : void 0), "../contracts/optimisticEthereum/Bits.address.ts": () => __vitePreload(() => import("./Bits.address-d31a33bd.js"), true ? [] : void 0), "../contracts/polygon/Bits.address.ts": () => __vitePreload(() => import("./Bits.address-c28df2f9.js"), true ? [] : void 0) }), `../contracts/${chain2}/Bits.address.ts`).then(({ default: addr }) => setBitsAddress(addr));
      __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/dysMumbai/Bits.abi.ts": () => __vitePreload(() => import("./Bits.abi-2b43165a.js"), true ? [] : void 0), "../contracts/mumbai/Bits.abi.ts": () => __vitePreload(() => import("./Bits.abi-f30927de.js"), true ? [] : void 0), "../contracts/optimisticEthereum/Bits.abi.ts": () => __vitePreload(() => import("./Bits.abi-61c694df.js"), true ? [] : void 0), "../contracts/polygon/Bits.abi.ts": () => __vitePreload(() => import("./Bits.abi-848655e0.js"), true ? [] : void 0) }), `../contracts/${chain2}/Bits.abi.ts`).then(({ default: abi22 }) => setBitsABI(abi22));
      __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/dysMumbai/Roles.address.ts": () => __vitePreload(() => import("./Roles.address-da5faab2.js"), true ? [] : void 0), "../contracts/mumbai/Roles.address.ts": () => __vitePreload(() => import("./Roles.address-3bb600cc.js"), true ? [] : void 0), "../contracts/optimisticEthereum/Roles.address.ts": () => __vitePreload(() => import("./Roles.address-0249f7f1.js"), true ? [] : void 0), "../contracts/polygon/Roles.address.ts": () => __vitePreload(() => import("./Roles.address-e0b0405d.js"), true ? [] : void 0) }), `../contracts/${chain2}/Roles.address.ts`).then(({ default: addr }) => setRolesAddress(addr));
      __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/dysMumbai/Roles.abi.ts": () => __vitePreload(() => import("./Roles.abi-b52b7484.js"), true ? [] : void 0), "../contracts/mumbai/Roles.abi.ts": () => __vitePreload(() => import("./Roles.abi-c462a9d9.js"), true ? [] : void 0), "../contracts/optimisticEthereum/Roles.abi.ts": () => __vitePreload(() => import("./Roles.abi-52765278.js"), true ? [] : void 0), "../contracts/polygon/Roles.abi.ts": () => __vitePreload(() => import("./Roles.abi-fb944a19.js"), true ? [] : void 0) }), `../contracts/${chain2}/Roles.abi.ts`).then(({ default: abi22 }) => setRolesABI(abi22));
    };
    libs();
  }, []);
  return /* @__PURE__ */ jsx(
    Web3Context.Provider,
    {
      value: {
        userProvider,
        ensProvider,
        contractProvider,
        roContract,
        bitsLibrary,
        rolesLibrary,
        rwContract,
        connect,
        disconnect,
        connecting,
        connected,
        address,
        chain,
        contract: {
          address: contractAddress,
          abi: abi2
        }
      },
      children
    }
  );
};
var extendStatics$1 = function(d3, b4) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b5) {
    d4.__proto__ = b5;
  } || function(d4, b5) {
    for (var p3 in b5)
      if (Object.prototype.hasOwnProperty.call(b5, p3))
        d4[p3] = b5[p3];
  };
  return extendStatics$1(d3, b4);
};
function __extends$1(d3, b4) {
  if (typeof b4 !== "function" && b4 !== null)
    throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
  extendStatics$1(d3, b4);
  function __2() {
    this.constructor = d3;
  }
  d3.prototype = b4 === null ? Object.create(b4) : (__2.prototype = b4.prototype, new __2());
}
var genericMessage = "Invariant Violation";
var _a$3 = Object.setPrototypeOf, setPrototypeOf = _a$3 === void 0 ? function(obj, proto) {
  obj.__proto__ = proto;
  return obj;
} : _a$3;
var InvariantError = (
  /** @class */
  function(_super) {
    __extends$1(InvariantError2, _super);
    function InvariantError2(message) {
      if (message === void 0) {
        message = genericMessage;
      }
      var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
      _this.framesToPop = 1;
      _this.name = genericMessage;
      setPrototypeOf(_this, InvariantError2.prototype);
      return _this;
    }
    return InvariantError2;
  }(Error)
);
function invariant$1(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}
var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
var verbosityLevel = verbosityLevels.indexOf("log");
function wrapConsoleMethod(name2) {
  return function() {
    if (verbosityLevels.indexOf(name2) >= verbosityLevel) {
      var method = console[name2] || console.log;
      return method.apply(console, arguments);
    }
  };
}
(function(invariant2) {
  invariant2.debug = wrapConsoleMethod("debug");
  invariant2.log = wrapConsoleMethod("log");
  invariant2.warn = wrapConsoleMethod("warn");
  invariant2.error = wrapConsoleMethod("error");
})(invariant$1 || (invariant$1 = {}));
function maybe$1(thunk) {
  try {
    return thunk();
  } catch (_a2) {
  }
}
const global$2 = maybe$1(function() {
  return globalThis;
}) || maybe$1(function() {
  return window;
}) || maybe$1(function() {
  return self;
}) || maybe$1(function() {
  return global;
}) || maybe$1(function() {
  return maybe$1.constructor("return this")();
});
var __ = "__";
var GLOBAL_KEY = [__, __].join("DEV");
function getDEV() {
  try {
    return Boolean(__DEV__);
  } catch (_a2) {
    Object.defineProperty(global$2, GLOBAL_KEY, {
      value: maybe$1(function() {
        return "production";
      }) !== "production",
      enumerable: false,
      configurable: true,
      writable: true
    });
    return global$2[GLOBAL_KEY];
  }
}
const DEV = getDEV();
function maybe(thunk) {
  try {
    return thunk();
  } catch (_3) {
  }
}
var safeGlobal = maybe(function() {
  return globalThis;
}) || maybe(function() {
  return window;
}) || maybe(function() {
  return self;
}) || maybe(function() {
  return global;
}) || // We don't expect the Function constructor ever to be invoked at runtime, as
// long as at least one of globalThis, window, self, or global is defined, so
// we are under no obligation to make it easy for static analysis tools to
// detect syntactic usage of the Function constructor. If you think you can
// improve your static analysis to detect this obfuscation, think again. This
// is an arms race you cannot win, at least not in JavaScript.
maybe(function() {
  return maybe.constructor("return this")();
});
var needToRemove = false;
function install() {
  if (safeGlobal && !maybe(function() {
    return "production";
  }) && !maybe(function() {
    return process;
  })) {
    Object.defineProperty(safeGlobal, "process", {
      value: {
        env: {
          // This default needs to be "production" instead of "development", to
          // avoid the problem https://github.com/graphql/graphql-js/pull/2894
          // will eventually solve, once merged and released.
          NODE_ENV: "production"
        }
      },
      // Let anyone else change global.process as they see fit, but hide it from
      // Object.keys(global) enumeration.
      configurable: true,
      enumerable: false,
      writable: true
    });
    needToRemove = true;
  }
}
install();
function remove() {
  if (needToRemove) {
    delete safeGlobal.process;
    needToRemove = false;
  }
}
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
class Location {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class Token {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end2, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end2;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
const kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
let OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));
let Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));
function isWhiteSpace(code2) {
  return code2 === 9 || code2 === 32;
}
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isLetter(code2) {
  return code2 >= 97 && code2 <= 122 || // A-Z
  code2 >= 65 && code2 <= 90;
}
function isNameStart(code2) {
  return isLetter(code2) || code2 === 95;
}
function isNameContinue(code2) {
  return isLetter(code2) || isDigit(code2) || code2 === 95;
}
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i3 = 0; i3 < lines.length; ++i3) {
    var _firstNonEmptyLine;
    const line = lines[i3];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i3;
    lastNonEmptyLine = i3;
    if (i3 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i3) => i3 === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i3 = 0;
  while (i3 < str.length && isWhiteSpace(str.charCodeAt(i3))) {
    ++i3;
  }
  return i3;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
const MAX_ARRAY_LENGTH = 10;
const MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object2, seenValues) {
  const entries2 = Object.entries(object2);
  if (entries2.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object2) + "]";
  }
  const properties = entries2.map(
    ([key2, value]) => key2 + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array2, seenValues) {
  if (array2.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len2 = Math.min(MAX_ARRAY_LENGTH, array2.length);
  const remaining = array2.length - len2;
  const items = [];
  for (let i3 = 0; i3 < len2; ++i3) {
    items.push(formatValue(array2[i3], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object2) {
  const tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object2.constructor === "function") {
    const name2 = object2.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}
const instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  // eslint-disable-next-line no-undef
  function instanceOf2(value, constructor) {
    return value instanceof constructor;
  }
);
class Source {
  constructor(body, name2 = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name2;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function isSource(source) {
  return instanceOf(source, Source);
}
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
const escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];
const BREAK = Object.freeze({});
function visit(root2, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root2);
  let keys2 = [root2];
  let index2 = -1;
  let edits = [];
  let node2 = root2;
  let key2 = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index2++;
    const isLeaving = index2 === keys2.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key2 = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node2 = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node2 = node2.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node2.splice(arrayKey, 1);
              editOffset++;
            } else {
              node2[arrayKey] = editValue;
            }
          }
        } else {
          node2 = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node2)
          );
          for (const [editKey, editValue] of edits) {
            node2[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys2 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key2 = inArray ? index2 : keys2[index2];
      node2 = parent[key2];
      if (node2 === null || node2 === void 0) {
        continue;
      }
      path.push(key2);
    }
    let result;
    if (!Array.isArray(node2)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node2) || devAssert(false, `Invalid AST Node: ${inspect(node2)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node2, key2, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key2, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node2 = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key2, node2]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index2,
        keys: keys2,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node2);
      keys2 = inArray ? node2 : (_node$kind = visitorKeys[node2.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index2 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node2;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root2;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
function print(ast) {
  return visit(ast, printDocASTReducer);
}
const MAX_LINE_LENGTH = 80;
const printDocASTReducer = {
  Name: {
    leave: (node2) => node2.value
  },
  Variable: {
    leave: (node2) => "$" + node2.name
  },
  // Document
  Document: {
    leave: (node2) => join(node2.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node2) {
      const varDefs = wrap$1("(", join(node2.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node2.operation,
          join([node2.name, varDefs]),
          join(node2.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node2.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue, directives }) => variable + ": " + type2 + wrap$1(" = ", defaultValue) + wrap$1(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name: name2, arguments: args, directives, selectionSet }) {
      const prefix = wrap$1("", alias, ": ") + name2;
      let argsLine = prefix + wrap$1("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap$1("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name: name2, value }) => name2 + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: name2, directives }) => "..." + name2 + wrap$1(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap$1("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: name2, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name2}${wrap$1("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap$1("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: name2, value }) => name2 + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap$1("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: name2 }) => name2
  },
  ListType: {
    leave: ({ type: type2 }) => "[" + type2 + "]"
  },
  NonNullType: {
    leave: ({ type: type2 }) => type2 + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap$1("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ description, name: name2, directives }) => wrap$1("", description, "\n") + join(["scalar", name2, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives, fields }) => wrap$1("", description, "\n") + join(
      [
        "type",
        name2,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name: name2, arguments: args, type: type2, directives }) => wrap$1("", description, "\n") + name2 + (hasMultilineItems(args) ? wrap$1("(\n", indent(join(args, "\n")), "\n)") : wrap$1("(", join(args, ", "), ")")) + ": " + type2 + wrap$1(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name: name2, type: type2, defaultValue, directives }) => wrap$1("", description, "\n") + join(
      [name2 + ": " + type2, wrap$1("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives, fields }) => wrap$1("", description, "\n") + join(
      [
        "interface",
        name2,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name: name2, directives, types: types2 }) => wrap$1("", description, "\n") + join(
      ["union", name2, join(directives, " "), wrap$1("= ", join(types2, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name: name2, directives, values }) => wrap$1("", description, "\n") + join(["enum", name2, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name: name2, directives }) => wrap$1("", description, "\n") + join([name2, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name: name2, directives, fields }) => wrap$1("", description, "\n") + join(["input", name2, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap$1("", description, "\n") + "directive @" + name2 + (hasMultilineItems(args) ? wrap$1("(\n", indent(join(args, "\n")), "\n)") : wrap$1("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives }) => join(["extend scalar", name2, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join(
      [
        "extend type",
        name2,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name2,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives, types: types2 }) => join(
      [
        "extend union",
        name2,
        join(directives, " "),
        wrap$1("= ", join(types2, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives, values }) => join(["extend enum", name2, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives, fields }) => join(["extend input", name2, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x2) => x2).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array2) {
  return wrap$1("{\n", indent(join(array2, "\n")), "\n}");
}
function wrap$1(start, maybeString, end2 = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end2 : "";
}
function indent(str) {
  return wrap$1("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
function removeTemporaryGlobals() {
  return typeof Source === "function" ? remove() : remove();
}
function checkDEV() {
  __DEV__ ? invariant$1("boolean" === typeof DEV, DEV) : invariant$1("boolean" === typeof DEV, 36);
}
removeTemporaryGlobals();
checkDEV();
var extendStatics = function(d3, b4) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b5) {
    d4.__proto__ = b5;
  } || function(d4, b5) {
    for (var p3 in b5)
      if (Object.prototype.hasOwnProperty.call(b5, p3))
        d4[p3] = b5[p3];
  };
  return extendStatics(d3, b4);
};
function __extends(d3, b4) {
  if (typeof b4 !== "function" && b4 !== null)
    throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
  extendStatics(d3, b4);
  function __2() {
    this.constructor = d3;
  }
  d3.prototype = b4 === null ? Object.create(b4) : (__2.prototype = b4.prototype, new __2());
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s3, i3 = 1, n4 = arguments.length; i3 < n4; i3++) {
      s3 = arguments[i3];
      for (var p3 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p3))
          t2[p3] = s3[p3];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __rest$1(s3, e2) {
  var t2 = {};
  for (var p3 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p3) && e2.indexOf(p3) < 0)
      t2[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
      if (e2.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
        t2[p3[i3]] = s3[p3[i3]];
    }
  return t2;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _3 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f4, y3, t2, g3;
  return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n4) {
    return function(v4) {
      return step([n4, v4]);
    };
  }
  function step(op) {
    if (f4)
      throw new TypeError("Generator is already executing.");
    while (_3)
      try {
        if (f4 = 1, y3 && (t2 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t2 = y3["return"]) && t2.call(y3), 0) : y3.next) && !(t2 = t2.call(y3, op[1])).done)
          return t2;
        if (y3 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _3.label++;
            return { value: op[1], done: false };
          case 5:
            _3.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _3.ops.pop();
            _3.trys.pop();
            continue;
          default:
            if (!(t2 = _3.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _3 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _3.label = op[1];
              break;
            }
            if (op[0] === 6 && _3.label < t2[1]) {
              _3.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _3.label < t2[2]) {
              _3.label = t2[2];
              _3.ops.push(op);
              break;
            }
            if (t2[2])
              _3.ops.pop();
            _3.trys.pop();
            continue;
        }
        op = body.call(thisArg, _3);
      } catch (e2) {
        op = [6, e2];
        y3 = 0;
      } finally {
        f4 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i3 = 0, l2 = from2.length, ar2; i3 < l2; i3++) {
      if (ar2 || !(i3 in from2)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from2, 0, i3);
        ar2[i3] = from2[i3];
      }
    }
  return to.concat(ar2 || Array.prototype.slice.call(from2));
}
function shouldInclude(_a2, variables) {
  var directives = _a2.directives;
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives(directives).every(function(_a3) {
    var directive = _a3.directive, ifArgument = _a3.ifArgument;
    var evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      __DEV__ ? invariant$1(evaledValue !== void 0, "Invalid variable referenced in @".concat(directive.name.value, " directive.")) : invariant$1(evaledValue !== void 0, 37);
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function getDirectiveNames(root2) {
  var names2 = [];
  visit(root2, {
    Directive: function(node2) {
      names2.push(node2.name.value);
    }
  });
  return names2;
}
function hasDirectives(names2, root2) {
  return getDirectiveNames(root2).some(function(name2) {
    return names2.indexOf(name2) > -1;
  });
}
function hasClientExports(document2) {
  return document2 && hasDirectives(["client"], document2) && hasDirectives(["export"], document2);
}
function isInclusionDirective(_a2) {
  var value = _a2.name.value;
  return value === "skip" || value === "include";
}
function getInclusionDirectives(directives) {
  var result = [];
  if (directives && directives.length) {
    directives.forEach(function(directive) {
      if (!isInclusionDirective(directive))
        return;
      var directiveArguments = directive.arguments;
      var directiveName = directive.name.value;
      __DEV__ ? invariant$1(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @".concat(directiveName, " directive.")) : invariant$1(directiveArguments && directiveArguments.length === 1, 38);
      var ifArgument = directiveArguments[0];
      __DEV__ ? invariant$1(ifArgument.name && ifArgument.name.value === "if", "Invalid argument for the @".concat(directiveName, " directive.")) : invariant$1(ifArgument.name && ifArgument.name.value === "if", 39);
      var ifValue = ifArgument.value;
      __DEV__ ? invariant$1(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), "Argument for the @".concat(directiveName, " directive must be a variable or a boolean value.")) : invariant$1(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 40);
      result.push({ directive, ifArgument });
    });
  }
  return result;
}
function getFragmentQueryDocument(document2, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document2.definitions.forEach(function(definition) {
    if (definition.kind === "OperationDefinition") {
      throw __DEV__ ? new InvariantError("Found a ".concat(definition.operation, " operation").concat(definition.name ? " named '".concat(definition.name.value, "'") : "", ". ") + "No operations are allowed when using a fragment as a query. Only fragments are allowed.") : new InvariantError(41);
    }
    if (definition.kind === "FragmentDefinition") {
      fragments.push(definition);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    __DEV__ ? invariant$1(fragments.length === 1, "Found ".concat(fragments.length, " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.")) : invariant$1(fragments.length === 1, 42);
    actualFragmentName = fragments[0].name.value;
  }
  var query2 = __assign$1(__assign$1({}, document2), { definitions: __spreadArray([
    {
      kind: "OperationDefinition",
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: actualFragmentName
            }
          }
        ]
      }
    }
  ], document2.definitions, true) });
  return query2;
}
function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }
  var symTable = {};
  fragments.forEach(function(fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      var fragment = fragmentMap && fragmentMap[selection.name.value];
      __DEV__ ? invariant$1(fragment, "No fragment named ".concat(selection.name.value, ".")) : invariant$1(fragment, 43);
      return fragment;
    }
    default:
      return null;
  }
}
function isNonNullObject(obj) {
  return obj !== null && typeof obj === "object";
}
function makeReference(id2) {
  return { __ref: String(id2) };
}
function isReference(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}
function isDocumentNode(value) {
  return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
}
function isStringValue(value) {
  return value.kind === "StringValue";
}
function isBooleanValue(value) {
  return value.kind === "BooleanValue";
}
function isIntValue(value) {
  return value.kind === "IntValue";
}
function isFloatValue(value) {
  return value.kind === "FloatValue";
}
function isVariable(value) {
  return value.kind === "Variable";
}
function isObjectValue(value) {
  return value.kind === "ObjectValue";
}
function isListValue(value) {
  return value.kind === "ListValue";
}
function isEnumValue(value) {
  return value.kind === "EnumValue";
}
function isNullValue(value) {
  return value.kind === "NullValue";
}
function valueToObjectRepresentation(argObj, name2, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name2.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name2.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function(obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name2.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name2.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name2.value] = value.values.map(function(listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name2, listValue, variables);
      return nestedArgArrayObj[name2.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name2.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name2.value] = null;
  } else {
    throw __DEV__ ? new InvariantError('The inline argument "'.concat(name2.value, '" of kind "').concat(value.kind, '"') + "is not supported. Use variables instead of inline arguments to overcome this limitation.") : new InvariantError(52);
  }
}
function storeKeyNameFromField(field, variables) {
  var directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function(directive) {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(function(_a2) {
          var name2 = _a2.name, value = _a2.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name2, value, variables);
        });
      }
    });
  }
  var argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function(_a2) {
      var name2 = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj, name2, value, variables);
    });
  }
  return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export"
];
var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
  if (args && directives && directives["connection"] && directives["connection"]["key"]) {
    if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
      var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
      filterKeys.sort();
      var filteredArgs_1 = {};
      filterKeys.forEach(function(key2) {
        filteredArgs_1[key2] = args[key2];
      });
      return "".concat(directives["connection"]["key"], "(").concat(stringify(filteredArgs_1), ")");
    } else {
      return directives["connection"]["key"];
    }
  }
  var completeFieldName = fieldName;
  if (args) {
    var stringifiedArgs = stringify(args);
    completeFieldName += "(".concat(stringifiedArgs, ")");
  }
  if (directives) {
    Object.keys(directives).forEach(function(key2) {
      if (KNOWN_DIRECTIVES.indexOf(key2) !== -1)
        return;
      if (directives[key2] && Object.keys(directives[key2]).length) {
        completeFieldName += "@".concat(key2, "(").concat(stringify(directives[key2]), ")");
      } else {
        completeFieldName += "@".concat(key2);
      }
    });
  }
  return completeFieldName;
}, {
  setStringify: function(s3) {
    var previous = stringify;
    stringify = s3;
    return previous;
  }
});
var stringify = function defaultStringify(value) {
  return JSON.stringify(value, stringifyReplacer);
};
function stringifyReplacer(_key, value) {
  if (isNonNullObject(value) && !Array.isArray(value)) {
    value = Object.keys(value).sort().reduce(function(copy2, key2) {
      copy2[key2] = value[key2];
      return copy2;
    }, {});
  }
  return value;
}
function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function(_a2) {
      var name2 = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj_1, name2, value, variables);
    });
    return argObj_1;
  }
  return null;
}
function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result, selectionSet, fragmentMap) {
  if (typeof result.__typename === "string") {
    return result.__typename;
  }
  for (var _i = 0, _a2 = selectionSet.selections; _i < _a2.length; _i++) {
    var selection = _a2[_i];
    if (isField(selection)) {
      if (selection.name.value === "__typename") {
        return result[resultKeyNameFromField(selection)];
      }
    } else {
      var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}
function isField(selection) {
  return selection.kind === "Field";
}
function isInlineFragment(selection) {
  return selection.kind === "InlineFragment";
}
function checkDocument(doc) {
  __DEV__ ? invariant$1(doc && doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : invariant$1(doc && doc.kind === "Document", 44);
  var operations = doc.definitions.filter(function(d3) {
    return d3.kind !== "FragmentDefinition";
  }).map(function(definition) {
    if (definition.kind !== "OperationDefinition") {
      throw __DEV__ ? new InvariantError('Schema type definitions not allowed in queries. Found: "'.concat(definition.kind, '"')) : new InvariantError(45);
    }
    return definition;
  });
  __DEV__ ? invariant$1(operations.length <= 1, "Ambiguous GraphQL document: contains ".concat(operations.length, " operations")) : invariant$1(operations.length <= 1, 46);
  return doc;
}
function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition";
  })[0];
}
function getOperationName(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition" && definition.name;
  }).map(function(x2) {
    return x2.name.value;
  })[0] || null;
}
function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "FragmentDefinition";
  });
}
function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
  __DEV__ ? invariant$1(queryDef && queryDef.operation === "query", "Must contain a query definition.") : invariant$1(queryDef && queryDef.operation === "query", 47);
  return queryDef;
}
function getFragmentDefinition(doc) {
  __DEV__ ? invariant$1(doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : invariant$1(doc.kind === "Document", 48);
  __DEV__ ? invariant$1(doc.definitions.length <= 1, "Fragment must have exactly one definition.") : invariant$1(doc.definitions.length <= 1, 49);
  var fragmentDef = doc.definitions[0];
  __DEV__ ? invariant$1(fragmentDef.kind === "FragmentDefinition", "Must be a fragment definition.") : invariant$1(fragmentDef.kind === "FragmentDefinition", 50);
  return fragmentDef;
}
function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;
  for (var _i = 0, _a2 = queryDoc.definitions; _i < _a2.length; _i++) {
    var definition = _a2[_i];
    if (definition.kind === "OperationDefinition") {
      var operation = definition.operation;
      if (operation === "query" || operation === "mutation" || operation === "subscription") {
        return definition;
      }
    }
    if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw __DEV__ ? new InvariantError("Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.") : new InvariantError(51);
}
function getDefaultValues(definition) {
  var defaultValues = /* @__PURE__ */ Object.create(null);
  var defs = definition && definition.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach(function(def) {
      if (def.defaultValue) {
        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}
function filterInPlace(array2, test, context) {
  var target = 0;
  array2.forEach(function(elem, i3) {
    if (test.call(this, elem, i3, array2)) {
      array2[target++] = elem;
    }
  }, context);
  array2.length = target;
  return array2;
}
var TYPENAME_FIELD = {
  kind: "Field",
  name: {
    kind: "Name",
    value: "__typename"
  }
};
function isEmpty(op, fragments) {
  return op.selectionSet.selections.every(function(selection) {
    return selection.kind === "FragmentSpread" && isEmpty(fragments[selection.name.value], fragments);
  });
}
function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}
function getDirectiveMatcher(directives) {
  return function directiveMatcher(directive) {
    return directives.some(function(dir) {
      return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);
    });
  };
}
function removeDirectivesFromDocument(directives, doc) {
  var variablesInUse = /* @__PURE__ */ Object.create(null);
  var variablesToRemove = [];
  var fragmentSpreadsInUse = /* @__PURE__ */ Object.create(null);
  var fragmentSpreadsToRemove = [];
  var modifiedDoc = nullIfDocIsEmpty(visit(doc, {
    Variable: {
      enter: function(node2, _key, parent) {
        if (parent.kind !== "VariableDefinition") {
          variablesInUse[node2.name.value] = true;
        }
      }
    },
    Field: {
      enter: function(node2) {
        if (directives && node2.directives) {
          var shouldRemoveField = directives.some(function(directive) {
            return directive.remove;
          });
          if (shouldRemoveField && node2.directives && node2.directives.some(getDirectiveMatcher(directives))) {
            if (node2.arguments) {
              node2.arguments.forEach(function(arg) {
                if (arg.value.kind === "Variable") {
                  variablesToRemove.push({
                    name: arg.value.name.value
                  });
                }
              });
            }
            if (node2.selectionSet) {
              getAllFragmentSpreadsFromSelectionSet(node2.selectionSet).forEach(function(frag) {
                fragmentSpreadsToRemove.push({
                  name: frag.name.value
                });
              });
            }
            return null;
          }
        }
      }
    },
    FragmentSpread: {
      enter: function(node2) {
        fragmentSpreadsInUse[node2.name.value] = true;
      }
    },
    Directive: {
      enter: function(node2) {
        if (getDirectiveMatcher(directives)(node2)) {
          return null;
        }
      }
    }
  }));
  if (modifiedDoc && filterInPlace(variablesToRemove, function(v4) {
    return !!v4.name && !variablesInUse[v4.name];
  }).length) {
    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
  }
  if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function(fs2) {
    return !!fs2.name && !fragmentSpreadsInUse[fs2.name];
  }).length) {
    modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
  }
  return modifiedDoc;
}
var addTypenameToDocument = Object.assign(function(doc) {
  return visit(doc, {
    SelectionSet: {
      enter: function(node2, _key, parent) {
        if (parent && parent.kind === "OperationDefinition") {
          return;
        }
        var selections = node2.selections;
        if (!selections) {
          return;
        }
        var skip3 = selections.some(function(selection) {
          return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
        });
        if (skip3) {
          return;
        }
        var field = parent;
        if (isField(field) && field.directives && field.directives.some(function(d3) {
          return d3.name.value === "export";
        })) {
          return;
        }
        return __assign$1(__assign$1({}, node2), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
      }
    }
  });
}, {
  added: function(field) {
    return field === TYPENAME_FIELD;
  }
});
var connectionRemoveConfig = {
  test: function(directive) {
    var willRemove = directive.name.value === "connection";
    if (willRemove) {
      if (!directive.arguments || !directive.arguments.some(function(arg) {
        return arg.name.value === "key";
      })) {
        __DEV__ && invariant$1.warn("Removing an @connection directive even though it does not have a key. You may want to use the key parameter to specify a store key.");
      }
    }
    return willRemove;
  }
};
function removeConnectionDirectiveFromDocument(doc) {
  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
}
function getArgumentMatcher(config2) {
  return function argumentMatcher(argument) {
    return config2.some(function(aConfig) {
      return argument.value && argument.value.kind === "Variable" && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
    });
  };
}
function removeArgumentsFromDocument(config2, doc) {
  var argMatcher = getArgumentMatcher(config2);
  return nullIfDocIsEmpty(visit(doc, {
    OperationDefinition: {
      enter: function(node2) {
        return __assign$1(__assign$1({}, node2), { variableDefinitions: node2.variableDefinitions ? node2.variableDefinitions.filter(function(varDef) {
          return !config2.some(function(arg) {
            return arg.name === varDef.variable.name.value;
          });
        }) : [] });
      }
    },
    Field: {
      enter: function(node2) {
        var shouldRemoveField = config2.some(function(argConfig) {
          return argConfig.remove;
        });
        if (shouldRemoveField) {
          var argMatchCount_1 = 0;
          if (node2.arguments) {
            node2.arguments.forEach(function(arg) {
              if (argMatcher(arg)) {
                argMatchCount_1 += 1;
              }
            });
          }
          if (argMatchCount_1 === 1) {
            return null;
          }
        }
      }
    },
    Argument: {
      enter: function(node2) {
        if (argMatcher(node2)) {
          return null;
        }
      }
    }
  }));
}
function removeFragmentSpreadFromDocument(config2, doc) {
  function enter(node2) {
    if (config2.some(function(def) {
      return def.name === node2.name.value;
    })) {
      return null;
    }
  }
  return nullIfDocIsEmpty(visit(doc, {
    FragmentSpread: { enter },
    FragmentDefinition: { enter }
  }));
}
function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
  var allFragments = [];
  selectionSet.selections.forEach(function(selection) {
    if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {
      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function(frag) {
        return allFragments.push(frag);
      });
    } else if (selection.kind === "FragmentSpread") {
      allFragments.push(selection);
    }
  });
  return allFragments;
}
function buildQueryFromSelectionSet(document2) {
  var definition = getMainDefinition(document2);
  var definitionOperation = definition.operation;
  if (definitionOperation === "query") {
    return document2;
  }
  var modifiedDoc = visit(document2, {
    OperationDefinition: {
      enter: function(node2) {
        return __assign$1(__assign$1({}, node2), { operation: "query" });
      }
    }
  });
  return modifiedDoc;
}
function removeClientSetsFromDocument(document2) {
  checkDocument(document2);
  var modifiedDoc = removeDirectivesFromDocument([
    {
      test: function(directive) {
        return directive.name.value === "client";
      },
      remove: true
    }
  ], document2);
  if (modifiedDoc) {
    modifiedDoc = visit(modifiedDoc, {
      FragmentDefinition: {
        enter: function(node2) {
          if (node2.selectionSet) {
            var isTypenameOnly = node2.selectionSet.selections.every(function(selection) {
              return isField(selection) && selection.name.value === "__typename";
            });
            if (isTypenameOnly) {
              return null;
            }
          }
        }
      }
    });
  }
  return modifiedDoc;
}
var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
function mergeDeep() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count2 = sources.length;
  if (count2 > 1) {
    var merger = new DeepMerger();
    for (var i3 = 1; i3 < count2; ++i3) {
      target = merger.merge(target, sources[i3]);
    }
  }
  return target;
}
var defaultReconciler = function(target, source, property) {
  return this.merge(target[property], source[property]);
};
var DeepMerger = function() {
  function DeepMerger2(reconciler) {
    if (reconciler === void 0) {
      reconciler = defaultReconciler;
    }
    this.reconciler = reconciler;
    this.isObject = isNonNullObject;
    this.pastCopies = /* @__PURE__ */ new Set();
  }
  DeepMerger2.prototype.merge = function(target, source) {
    var _this = this;
    var context = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      context[_i - 2] = arguments[_i];
    }
    if (isNonNullObject(source) && isNonNullObject(target)) {
      Object.keys(source).forEach(function(sourceKey) {
        if (hasOwnProperty$5.call(target, sourceKey)) {
          var targetValue = target[sourceKey];
          if (source[sourceKey] !== targetValue) {
            var result = _this.reconciler.apply(_this, __spreadArray([target, source, sourceKey], context, false));
            if (result !== targetValue) {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = result;
            }
          }
        } else {
          target = _this.shallowCopyForMerge(target);
          target[sourceKey] = source[sourceKey];
        }
      });
      return target;
    }
    return source;
  };
  DeepMerger2.prototype.shallowCopyForMerge = function(value) {
    if (isNonNullObject(value)) {
      if (!this.pastCopies.has(value)) {
        if (Array.isArray(value)) {
          value = value.slice(0);
        } else {
          value = __assign$1({ __proto__: Object.getPrototypeOf(value) }, value);
        }
        this.pastCopies.add(value);
      }
    }
    return value;
  };
  return DeepMerger2;
}();
function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (it2)
    return (it2 = it2.call(o2)).next.bind(it2);
  if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
    if (it2)
      o2 = it2;
    var i3 = 0;
    return function() {
      if (i3 >= o2.length)
        return { done: true };
      return { done: false, value: o2[i3++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n4 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n4 === "Object" && o2.constructor)
    n4 = o2.constructor.name;
  if (n4 === "Map" || n4 === "Set")
    return Array.from(o2);
  if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr2, len2) {
  if (len2 == null || len2 > arr2.length)
    len2 = arr2.length;
  for (var i3 = 0, arr22 = new Array(len2); i3 < len2; i3++) {
    arr22[i3] = arr2[i3];
  }
  return arr22;
}
function _defineProperties(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var hasSymbols = function() {
  return typeof Symbol === "function";
};
var hasSymbol = function(name2) {
  return hasSymbols() && Boolean(Symbol[name2]);
};
var getSymbol = function(name2) {
  return hasSymbol(name2) ? Symbol[name2] : "@@" + name2;
};
if (hasSymbols() && !hasSymbol("observable")) {
  Symbol.observable = Symbol("observable");
}
var SymbolIterator = getSymbol("iterator");
var SymbolObservable = getSymbol("observable");
var SymbolSpecies = getSymbol("species");
function getMethod(obj, key2) {
  var value = obj[key2];
  if (value == null)
    return void 0;
  if (typeof value !== "function")
    throw new TypeError(value + " is not a function");
  return value;
}
function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable;
}
function isObservable(x2) {
  return x2 instanceof Observable;
}
function hostReportError(e2) {
  if (hostReportError.log) {
    hostReportError.log(e2);
  } else {
    setTimeout(function() {
      throw e2;
    });
  }
}
function enqueue(fn2) {
  Promise.resolve().then(function() {
    try {
      fn2();
    } catch (e2) {
      hostReportError(e2);
    }
  });
}
function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === void 0)
    return;
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, "unsubscribe");
      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e2) {
    hostReportError(e2);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  var queue2 = subscription._queue;
  if (!queue2) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (var i3 = 0; i3 < queue2.length; ++i3) {
    notifySubscription(subscription, queue2[i3].type, queue2[i3].value);
    if (subscription._state === "closed")
      break;
  }
}
function notifySubscription(subscription, type2, value) {
  subscription._state = "running";
  var observer = subscription._observer;
  try {
    var m2 = getMethod(observer, type2);
    switch (type2) {
      case "next":
        if (m2)
          m2.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m2)
          m2.call(observer, value);
        else
          throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m2)
          m2.call(observer);
        break;
    }
  } catch (e2) {
    hostReportError(e2);
  }
  if (subscription._state === "closed")
    cleanupSubscription(subscription);
  else if (subscription._state === "running")
    subscription._state = "ready";
}
function onNotify(subscription, type2, value) {
  if (subscription._state === "closed")
    return;
  if (subscription._state === "buffering") {
    subscription._queue.push({
      type: type2,
      value
    });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{
      type: type2,
      value
    }];
    enqueue(function() {
      return flushSubscription(subscription);
    });
    return;
  }
  notifySubscription(subscription, type2, value);
}
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(observer, subscriber) {
    this._cleanup = void 0;
    this._observer = observer;
    this._queue = void 0;
    this._state = "initializing";
    var subscriptionObserver = new SubscriptionObserver(this);
    try {
      this._cleanup = subscriber.call(void 0, subscriptionObserver);
    } catch (e2) {
      subscriptionObserver.error(e2);
    }
    if (this._state === "initializing")
      this._state = "ready";
  }
  var _proto = Subscription2.prototype;
  _proto.unsubscribe = function unsubscribe() {
    if (this._state !== "closed") {
      closeSubscription(this);
      cleanupSubscription(this);
    }
  };
  _createClass(Subscription2, [{
    key: "closed",
    get: function() {
      return this._state === "closed";
    }
  }]);
  return Subscription2;
}();
var SubscriptionObserver = /* @__PURE__ */ function() {
  function SubscriptionObserver2(subscription) {
    this._subscription = subscription;
  }
  var _proto2 = SubscriptionObserver2.prototype;
  _proto2.next = function next(value) {
    onNotify(this._subscription, "next", value);
  };
  _proto2.error = function error(value) {
    onNotify(this._subscription, "error", value);
  };
  _proto2.complete = function complete() {
    onNotify(this._subscription, "complete");
  };
  _createClass(SubscriptionObserver2, [{
    key: "closed",
    get: function() {
      return this._subscription._state === "closed";
    }
  }]);
  return SubscriptionObserver2;
}();
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscriber) {
    if (!(this instanceof Observable2))
      throw new TypeError("Observable cannot be called as a function");
    if (typeof subscriber !== "function")
      throw new TypeError("Observable initializer must be a function");
    this._subscriber = subscriber;
  }
  var _proto3 = Observable2.prototype;
  _proto3.subscribe = function subscribe2(observer) {
    if (typeof observer !== "object" || observer === null) {
      observer = {
        next: observer,
        error: arguments[1],
        complete: arguments[2]
      };
    }
    return new Subscription(observer, this._subscriber);
  };
  _proto3.forEach = function forEach2(fn2) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      if (typeof fn2 !== "function") {
        reject(new TypeError(fn2 + " is not a function"));
        return;
      }
      function done2() {
        subscription.unsubscribe();
        resolve();
      }
      var subscription = _this.subscribe({
        next: function(value) {
          try {
            fn2(value, done2);
          } catch (e2) {
            reject(e2);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  };
  _proto3.map = function map2(fn2) {
    var _this2 = this;
    if (typeof fn2 !== "function")
      throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      return _this2.subscribe({
        next: function(value) {
          try {
            value = fn2(value);
          } catch (e2) {
            return observer.error(e2);
          }
          observer.next(value);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.filter = function filter2(fn2) {
    var _this3 = this;
    if (typeof fn2 !== "function")
      throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      return _this3.subscribe({
        next: function(value) {
          try {
            if (!fn2(value))
              return;
          } catch (e2) {
            return observer.error(e2);
          }
          observer.next(value);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.reduce = function reduce2(fn2) {
    var _this4 = this;
    if (typeof fn2 !== "function")
      throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    var hasSeed = arguments.length > 1;
    var hasValue = false;
    var seed = arguments[1];
    var acc = seed;
    return new C2(function(observer) {
      return _this4.subscribe({
        next: function(value) {
          var first2 = !hasValue;
          hasValue = true;
          if (!first2 || hasSeed) {
            try {
              acc = fn2(acc, value);
            } catch (e2) {
              return observer.error(e2);
            }
          } else {
            acc = value;
          }
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          if (!hasValue && !hasSeed)
            return observer.error(new TypeError("Cannot reduce an empty sequence"));
          observer.next(acc);
          observer.complete();
        }
      });
    });
  };
  _proto3.concat = function concat2() {
    var _this5 = this;
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      var subscription;
      var index2 = 0;
      function startNext(next) {
        subscription = next.subscribe({
          next: function(v4) {
            observer.next(v4);
          },
          error: function(e2) {
            observer.error(e2);
          },
          complete: function() {
            if (index2 === sources.length) {
              subscription = void 0;
              observer.complete();
            } else {
              startNext(C2.from(sources[index2++]));
            }
          }
        });
      }
      startNext(_this5);
      return function() {
        if (subscription) {
          subscription.unsubscribe();
          subscription = void 0;
        }
      };
    });
  };
  _proto3.flatMap = function flatMap2(fn2) {
    var _this6 = this;
    if (typeof fn2 !== "function")
      throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      var subscriptions = [];
      var outer = _this6.subscribe({
        next: function(value) {
          if (fn2) {
            try {
              value = fn2(value);
            } catch (e2) {
              return observer.error(e2);
            }
          }
          var inner = C2.from(value).subscribe({
            next: function(value2) {
              observer.next(value2);
            },
            error: function(e2) {
              observer.error(e2);
            },
            complete: function() {
              var i3 = subscriptions.indexOf(inner);
              if (i3 >= 0)
                subscriptions.splice(i3, 1);
              completeIfDone();
            }
          });
          subscriptions.push(inner);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          completeIfDone();
        }
      });
      function completeIfDone() {
        if (outer.closed && subscriptions.length === 0)
          observer.complete();
      }
      return function() {
        subscriptions.forEach(function(s3) {
          return s3.unsubscribe();
        });
        outer.unsubscribe();
      };
    });
  };
  _proto3[SymbolObservable] = function() {
    return this;
  };
  Observable2.from = function from2(x2) {
    var C2 = typeof this === "function" ? this : Observable2;
    if (x2 == null)
      throw new TypeError(x2 + " is not an object");
    var method = getMethod(x2, SymbolObservable);
    if (method) {
      var observable2 = method.call(x2);
      if (Object(observable2) !== observable2)
        throw new TypeError(observable2 + " is not an object");
      if (isObservable(observable2) && observable2.constructor === C2)
        return observable2;
      return new C2(function(observer) {
        return observable2.subscribe(observer);
      });
    }
    if (hasSymbol("iterator")) {
      method = getMethod(x2, SymbolIterator);
      if (method) {
        return new C2(function(observer) {
          enqueue(function() {
            if (observer.closed)
              return;
            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x2)), _step; !(_step = _iterator()).done; ) {
              var item = _step.value;
              observer.next(item);
              if (observer.closed)
                return;
            }
            observer.complete();
          });
        });
      }
    }
    if (Array.isArray(x2)) {
      return new C2(function(observer) {
        enqueue(function() {
          if (observer.closed)
            return;
          for (var i3 = 0; i3 < x2.length; ++i3) {
            observer.next(x2[i3]);
            if (observer.closed)
              return;
          }
          observer.complete();
        });
      });
    }
    throw new TypeError(x2 + " is not observable");
  };
  Observable2.of = function of2() {
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    var C2 = typeof this === "function" ? this : Observable2;
    return new C2(function(observer) {
      enqueue(function() {
        if (observer.closed)
          return;
        for (var i3 = 0; i3 < items.length; ++i3) {
          observer.next(items[i3]);
          if (observer.closed)
            return;
        }
        observer.complete();
      });
    });
  };
  _createClass(Observable2, null, [{
    key: SymbolSpecies,
    get: function() {
      return this;
    }
  }]);
  return Observable2;
}();
if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol("extensions"), {
    value: {
      symbol: SymbolObservable,
      hostReportError
    },
    configurable: true
  });
}
function symbolObservablePonyfill(root2) {
  var result;
  var Symbol2 = root2.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result = Symbol2.observable;
    } else {
      if (typeof Symbol2.for === "function") {
        result = Symbol2.for("https://github.com/benlesh/symbol-observable");
      } else {
        result = Symbol2("https://github.com/benlesh/symbol-observable");
      }
      try {
        Symbol2.observable = result;
      } catch (err) {
      }
    }
  } else {
    result = "@@observable";
  }
  return result;
}
var root;
if (typeof self !== "undefined") {
  root = self;
} else if (typeof window !== "undefined") {
  root = window;
} else if (typeof global !== "undefined") {
  root = global;
} else if (typeof module !== "undefined") {
  root = module;
} else {
  root = Function("return this")();
}
symbolObservablePonyfill(root);
var prototype = Observable.prototype;
var fakeObsSymbol = "@@observable";
if (!prototype[fakeObsSymbol]) {
  prototype[fakeObsSymbol] = function() {
    return this;
  };
}
var toString$1 = Object.prototype.toString;
function cloneDeep(value) {
  return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen2) {
  switch (toString$1.call(val)) {
    case "[object Array]": {
      seen2 = seen2 || /* @__PURE__ */ new Map();
      if (seen2.has(val))
        return seen2.get(val);
      var copy_1 = val.slice(0);
      seen2.set(val, copy_1);
      copy_1.forEach(function(child, i3) {
        copy_1[i3] = cloneDeepHelper(child, seen2);
      });
      return copy_1;
    }
    case "[object Object]": {
      seen2 = seen2 || /* @__PURE__ */ new Map();
      if (seen2.has(val))
        return seen2.get(val);
      var copy_2 = Object.create(Object.getPrototypeOf(val));
      seen2.set(val, copy_2);
      Object.keys(val).forEach(function(key2) {
        copy_2[key2] = cloneDeepHelper(val[key2], seen2);
      });
      return copy_2;
    }
    default:
      return val;
  }
}
function deepFreeze(value) {
  var workSet = /* @__PURE__ */ new Set([value]);
  workSet.forEach(function(obj) {
    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
      Object.getOwnPropertyNames(obj).forEach(function(name2) {
        if (isNonNullObject(obj[name2]))
          workSet.add(obj[name2]);
      });
    }
  });
  return value;
}
function shallowFreeze(obj) {
  if (__DEV__ && !Object.isFrozen(obj)) {
    try {
      Object.freeze(obj);
    } catch (e2) {
      if (e2 instanceof TypeError)
        return null;
      throw e2;
    }
  }
  return obj;
}
function maybeDeepFreeze(obj) {
  if (__DEV__) {
    deepFreeze(obj);
  }
  return obj;
}
function iterateObserversSafely(observers, method, argument) {
  var observersWithMethod = [];
  observers.forEach(function(obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method](argument);
  });
}
function asyncMap(observable2, mapFn, catchFn) {
  return new Observable(function(observer) {
    var next = observer.next, error = observer.error, complete = observer.complete;
    var activeCallbackCount = 0;
    var completed = false;
    var promiseQueue = {
      then: function(callback) {
        return new Promise(function(resolve) {
          return resolve(callback());
        });
      }
    };
    function makeCallback(examiner, delegate) {
      if (examiner) {
        return function(arg) {
          ++activeCallbackCount;
          var both = function() {
            return examiner(arg);
          };
          promiseQueue = promiseQueue.then(both, both).then(function(result) {
            --activeCallbackCount;
            next && next.call(observer, result);
            if (completed) {
              handler.complete();
            }
          }, function(error2) {
            --activeCallbackCount;
            throw error2;
          }).catch(function(caught) {
            error && error.call(observer, caught);
          });
        };
      } else {
        return function(arg) {
          return delegate && delegate.call(observer, arg);
        };
      }
    }
    var handler = {
      next: makeCallback(mapFn, next),
      error: makeCallback(catchFn, error),
      complete: function() {
        completed = true;
        if (!activeCallbackCount) {
          complete && complete.call(observer);
        }
      }
    };
    var sub = observable2.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}
var canUseWeakMap = typeof WeakMap === "function" && maybe$1(function() {
  return navigator.product;
}) !== "ReactNative";
var canUseWeakSet = typeof WeakSet === "function";
var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
var canUseDOM = typeof maybe$1(function() {
  return window.document.createElement;
}) === "function";
var usingJSDOM = maybe$1(function() {
  return navigator.userAgent.indexOf("jsdom") >= 0;
}) || false;
var canUseLayoutEffect = canUseDOM && !usingJSDOM;
function fixObservableSubclass(subclass) {
  function set2(key2) {
    Object.defineProperty(subclass, key2, { value: Observable });
  }
  if (canUseSymbol && Symbol.species) {
    set2(Symbol.species);
  }
  set2("@@species");
  return subclass;
}
function isPromiseLike(value) {
  return value && typeof value.then === "function";
}
var Concast = function(_super) {
  __extends(Concast2, _super);
  function Concast2(sources) {
    var _this = _super.call(this, function(observer) {
      _this.addObserver(observer);
      return function() {
        return _this.removeObserver(observer);
      };
    }) || this;
    _this.observers = /* @__PURE__ */ new Set();
    _this.addCount = 0;
    _this.promise = new Promise(function(resolve, reject) {
      _this.resolve = resolve;
      _this.reject = reject;
    });
    _this.handlers = {
      next: function(result) {
        if (_this.sub !== null) {
          _this.latest = ["next", result];
          iterateObserversSafely(_this.observers, "next", result);
        }
      },
      error: function(error) {
        var sub = _this.sub;
        if (sub !== null) {
          if (sub)
            setTimeout(function() {
              return sub.unsubscribe();
            });
          _this.sub = null;
          _this.latest = ["error", error];
          _this.reject(error);
          iterateObserversSafely(_this.observers, "error", error);
        }
      },
      complete: function() {
        var sub = _this.sub;
        if (sub !== null) {
          var value = _this.sources.shift();
          if (!value) {
            if (sub)
              setTimeout(function() {
                return sub.unsubscribe();
              });
            _this.sub = null;
            if (_this.latest && _this.latest[0] === "next") {
              _this.resolve(_this.latest[1]);
            } else {
              _this.resolve();
            }
            iterateObserversSafely(_this.observers, "complete");
          } else if (isPromiseLike(value)) {
            value.then(function(obs) {
              return _this.sub = obs.subscribe(_this.handlers);
            });
          } else {
            _this.sub = value.subscribe(_this.handlers);
          }
        }
      }
    };
    _this.cancel = function(reason) {
      _this.reject(reason);
      _this.sources = [];
      _this.handlers.complete();
    };
    _this.promise.catch(function(_3) {
    });
    if (typeof sources === "function") {
      sources = [new Observable(sources)];
    }
    if (isPromiseLike(sources)) {
      sources.then(function(iterable) {
        return _this.start(iterable);
      }, _this.handlers.error);
    } else {
      _this.start(sources);
    }
    return _this;
  }
  Concast2.prototype.start = function(sources) {
    if (this.sub !== void 0)
      return;
    this.sources = Array.from(sources);
    this.handlers.complete();
  };
  Concast2.prototype.deliverLastMessage = function(observer) {
    if (this.latest) {
      var nextOrError = this.latest[0];
      var method = observer[nextOrError];
      if (method) {
        method.call(observer, this.latest[1]);
      }
      if (this.sub === null && nextOrError === "next" && observer.complete) {
        observer.complete();
      }
    }
  };
  Concast2.prototype.addObserver = function(observer) {
    if (!this.observers.has(observer)) {
      this.deliverLastMessage(observer);
      this.observers.add(observer);
      ++this.addCount;
    }
  };
  Concast2.prototype.removeObserver = function(observer, quietly) {
    if (this.observers.delete(observer) && --this.addCount < 1 && !quietly) {
      this.handlers.complete();
    }
  };
  Concast2.prototype.cleanup = function(callback) {
    var _this = this;
    var called = false;
    var once3 = function() {
      if (!called) {
        called = true;
        _this.observers.delete(observer);
        callback();
      }
    };
    var observer = {
      next: once3,
      error: once3,
      complete: once3
    };
    var count2 = this.addCount;
    this.addObserver(observer);
    this.addCount = count2;
  };
  return Concast2;
}(Observable);
fixObservableSubclass(Concast);
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
function graphQLResultHasError(result) {
  return result.errors && result.errors.length > 0 || false;
}
function compact() {
  var objects = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    objects[_i] = arguments[_i];
  }
  var result = /* @__PURE__ */ Object.create(null);
  objects.forEach(function(obj) {
    if (!obj)
      return;
    Object.keys(obj).forEach(function(key2) {
      var value = obj[key2];
      if (value !== void 0) {
        result[key2] = value;
      }
    });
  });
  return result;
}
var prefixCounts = /* @__PURE__ */ new Map();
function makeUniqueId(prefix) {
  var count2 = prefixCounts.get(prefix) || 1;
  prefixCounts.set(prefix, count2 + 1);
  return "".concat(prefix, ":").concat(count2, ":").concat(Math.random().toString(36).slice(2));
}
function stringifyForDisplay(value) {
  var undefId = makeUniqueId("stringifyForDisplay");
  return JSON.stringify(value, function(key2, value2) {
    return value2 === void 0 ? undefId : value2;
  }).split(JSON.stringify(undefId)).join("<undefined>");
}
function mergeOptions(defaults2, options) {
  return compact(defaults2, options, options.variables && {
    variables: __assign$1(__assign$1({}, defaults2 && defaults2.variables), options.variables)
  });
}
function fromError(errorValue) {
  return new Observable(function(observer) {
    observer.error(errorValue);
  });
}
var throwServerError = function(response, result, message) {
  var error = new Error(message);
  error.name = "ServerError";
  error.response = response;
  error.statusCode = response.status;
  error.result = result;
  throw error;
};
function validateOperation(operation) {
  var OPERATION_FIELDS = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ];
  for (var _i = 0, _a2 = Object.keys(operation); _i < _a2.length; _i++) {
    var key2 = _a2[_i];
    if (OPERATION_FIELDS.indexOf(key2) < 0) {
      throw __DEV__ ? new InvariantError("illegal argument: ".concat(key2)) : new InvariantError(24);
    }
  }
  return operation;
}
function createOperation(starting, operation) {
  var context = __assign$1({}, starting);
  var setContext = function(next) {
    if (typeof next === "function") {
      context = __assign$1(__assign$1({}, context), next(context));
    } else {
      context = __assign$1(__assign$1({}, context), next);
    }
  };
  var getContext = function() {
    return __assign$1({}, context);
  };
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext
  });
  return operation;
}
function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };
  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
  }
  return transformedOperation;
}
function passthrough(op, forward) {
  return forward ? forward(op) : Observable.of();
}
function toLink(handler) {
  return typeof handler === "function" ? new ApolloLink(handler) : handler;
}
function isTerminating(link) {
  return link.request.length <= 1;
}
var LinkError = function(_super) {
  __extends(LinkError2, _super);
  function LinkError2(message, link) {
    var _this = _super.call(this, message) || this;
    _this.link = link;
    return _this;
  }
  return LinkError2;
}(Error);
var ApolloLink = function() {
  function ApolloLink2(request) {
    if (request)
      this.request = request;
  }
  ApolloLink2.empty = function() {
    return new ApolloLink2(function() {
      return Observable.of();
    });
  };
  ApolloLink2.from = function(links2) {
    if (links2.length === 0)
      return ApolloLink2.empty();
    return links2.map(toLink).reduce(function(x2, y3) {
      return x2.concat(y3);
    });
  };
  ApolloLink2.split = function(test, left, right) {
    var leftLink = toLink(left);
    var rightLink = toLink(right || new ApolloLink2(passthrough));
    if (isTerminating(leftLink) && isTerminating(rightLink)) {
      return new ApolloLink2(function(operation) {
        return test(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
      });
    } else {
      return new ApolloLink2(function(operation, forward) {
        return test(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
      });
    }
  };
  ApolloLink2.execute = function(link, operation) {
    return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();
  };
  ApolloLink2.concat = function(first2, second) {
    var firstLink = toLink(first2);
    if (isTerminating(firstLink)) {
      __DEV__ && invariant$1.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
      return firstLink;
    }
    var nextLink = toLink(second);
    if (isTerminating(nextLink)) {
      return new ApolloLink2(function(operation) {
        return firstLink.request(operation, function(op) {
          return nextLink.request(op) || Observable.of();
        }) || Observable.of();
      });
    } else {
      return new ApolloLink2(function(operation, forward) {
        return firstLink.request(operation, function(op) {
          return nextLink.request(op, forward) || Observable.of();
        }) || Observable.of();
      });
    }
  };
  ApolloLink2.prototype.split = function(test, left, right) {
    return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
  };
  ApolloLink2.prototype.concat = function(next) {
    return ApolloLink2.concat(this, next);
  };
  ApolloLink2.prototype.request = function(operation, forward) {
    throw __DEV__ ? new InvariantError("request is not implemented") : new InvariantError(19);
  };
  ApolloLink2.prototype.onError = function(error, observer) {
    if (observer && observer.error) {
      observer.error(error);
      return false;
    }
    throw error;
  };
  ApolloLink2.prototype.setOnError = function(fn2) {
    this.onError = fn2;
    return this;
  };
  return ApolloLink2;
}();
var execute = ApolloLink.execute;
var version$1 = "3.6.9";
var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
function parseAndCheckHttpResponse(operations) {
  return function(response) {
    return response.text().then(function(bodyText) {
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        var parseError = err;
        parseError.name = "ServerParseError";
        parseError.response = response;
        parseError.statusCode = response.status;
        parseError.bodyText = bodyText;
        throw parseError;
      }
    }).then(function(result) {
      if (response.status >= 300) {
        throwServerError(response, result, "Response not successful: Received status code ".concat(response.status));
      }
      if (!Array.isArray(result) && !hasOwnProperty$4.call(result, "data") && !hasOwnProperty$4.call(result, "errors")) {
        throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
          return op.operationName;
        }) : operations.operationName, "'."));
      }
      return result;
    });
  };
}
var serializeFetchParameter = function(p3, label) {
  var serialized;
  try {
    serialized = JSON.stringify(p3);
  } catch (e2) {
    var parseError = __DEV__ ? new InvariantError("Network request failed. ".concat(label, " is not serializable: ").concat(e2.message)) : new InvariantError(21);
    parseError.parseError = e2;
    throw parseError;
  }
  return serialized;
};
var defaultHttpOptions = {
  includeQuery: true,
  includeExtensions: false
};
var defaultHeaders = {
  accept: "*/*",
  "content-type": "application/json"
};
var defaultOptions = {
  method: "POST"
};
var fallbackHttpConfig = {
  http: defaultHttpOptions,
  headers: defaultHeaders,
  options: defaultOptions
};
var defaultPrinter = function(ast, printer) {
  return printer(ast);
};
function selectHttpOptionsAndBodyInternal(operation, printer) {
  var configs = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    configs[_i - 2] = arguments[_i];
  }
  var options = {};
  var http = {};
  configs.forEach(function(config2) {
    options = __assign$1(__assign$1(__assign$1({}, options), config2.options), { headers: __assign$1(__assign$1({}, options.headers), headersToLowerCase(config2.headers)) });
    if (config2.credentials) {
      options.credentials = config2.credentials;
    }
    http = __assign$1(__assign$1({}, http), config2.http);
  });
  var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query2 = operation.query;
  var body = { operationName, variables };
  if (http.includeExtensions)
    body.extensions = extensions;
  if (http.includeQuery)
    body.query = printer(query2, print);
  return {
    options,
    body
  };
}
function headersToLowerCase(headers) {
  if (headers) {
    var normalized_1 = /* @__PURE__ */ Object.create(null);
    Object.keys(Object(headers)).forEach(function(name2) {
      normalized_1[name2.toLowerCase()] = headers[name2];
    });
    return normalized_1;
  }
  return headers;
}
var checkFetcher = function(fetcher) {
  if (!fetcher && typeof fetch === "undefined") {
    throw __DEV__ ? new InvariantError(`
"fetch" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:

import fetch from 'cross-fetch';
import { ApolloClient, HttpLink } from '@apollo/client';
const client = new ApolloClient({
  link: new HttpLink({ uri: '/graphql', fetch })
});
    `) : new InvariantError(20);
  }
};
var createSignalIfSupported = function() {
  if (typeof AbortController === "undefined")
    return { controller: false, signal: false };
  var controller = new AbortController();
  var signal = controller.signal;
  return { controller, signal };
};
var selectURI = function(operation, fallbackURI) {
  var context = operation.getContext();
  var contextURI = context.uri;
  if (contextURI) {
    return contextURI;
  } else if (typeof fallbackURI === "function") {
    return fallbackURI(operation);
  } else {
    return fallbackURI || "/graphql";
  }
};
function rewriteURIForGET(chosenURI, body) {
  var queryParams = [];
  var addQueryParam = function(key2, value) {
    queryParams.push("".concat(key2, "=").concat(encodeURIComponent(value)));
  };
  if ("query" in body) {
    addQueryParam("query", body.query);
  }
  if (body.operationName) {
    addQueryParam("operationName", body.operationName);
  }
  if (body.variables) {
    var serializedVariables = void 0;
    try {
      serializedVariables = serializeFetchParameter(body.variables, "Variables map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body.extensions) {
    var serializedExtensions = void 0;
    try {
      serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("extensions", serializedExtensions);
  }
  var fragment = "", preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return { newURI };
}
var backupFetch = maybe$1(function() {
  return fetch;
});
var createHttpLink = function(linkOptions) {
  if (linkOptions === void 0) {
    linkOptions = {};
  }
  var _a2 = linkOptions.uri, uri = _a2 === void 0 ? "/graphql" : _a2, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print2 = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest$1(linkOptions, ["uri", "fetch", "print", "includeExtensions", "useGETForQueries", "includeUnusedVariables"]);
  if (__DEV__) {
    checkFetcher(preferredFetch || backupFetch);
  }
  var linkConfig = {
    http: { includeExtensions },
    options: requestOptions.fetchOptions,
    credentials: requestOptions.credentials,
    headers: requestOptions.headers
  };
  return new ApolloLink(function(operation) {
    var chosenURI = selectURI(operation, uri);
    var context = operation.getContext();
    var clientAwarenessHeaders = {};
    if (context.clientAwareness) {
      var _a3 = context.clientAwareness, name_1 = _a3.name, version2 = _a3.version;
      if (name_1) {
        clientAwarenessHeaders["apollographql-client-name"] = name_1;
      }
      if (version2) {
        clientAwarenessHeaders["apollographql-client-version"] = version2;
      }
    }
    var contextHeaders = __assign$1(__assign$1({}, clientAwarenessHeaders), context.headers);
    var contextConfig = {
      http: context.http,
      options: context.fetchOptions,
      credentials: context.credentials,
      headers: contextHeaders
    };
    var _b2 = selectHttpOptionsAndBodyInternal(operation, print2, fallbackHttpConfig, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
    if (body.variables && !includeUnusedVariables) {
      var unusedNames_1 = new Set(Object.keys(body.variables));
      visit(operation.query, {
        Variable: function(node2, _key, parent) {
          if (parent && parent.kind !== "VariableDefinition") {
            unusedNames_1.delete(node2.name.value);
          }
        }
      });
      if (unusedNames_1.size) {
        body.variables = __assign$1({}, body.variables);
        unusedNames_1.forEach(function(name2) {
          delete body.variables[name2];
        });
      }
    }
    var controller;
    if (!options.signal) {
      var _c2 = createSignalIfSupported(), _controller = _c2.controller, signal = _c2.signal;
      controller = _controller;
      if (controller)
        options.signal = signal;
    }
    var definitionIsMutation = function(d3) {
      return d3.kind === "OperationDefinition" && d3.operation === "mutation";
    };
    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
      options.method = "GET";
    }
    if (options.method === "GET") {
      var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
      if (parseError) {
        return fromError(parseError);
      }
      chosenURI = newURI;
    } else {
      try {
        options.body = serializeFetchParameter(body, "Payload");
      } catch (parseError2) {
        return fromError(parseError2);
      }
    }
    return new Observable(function(observer) {
      var currentFetch = preferredFetch || maybe$1(function() {
        return fetch;
      }) || backupFetch;
      currentFetch(chosenURI, options).then(function(response) {
        operation.setContext({ response });
        return response;
      }).then(parseAndCheckHttpResponse(operation)).then(function(result) {
        observer.next(result);
        observer.complete();
        return result;
      }).catch(function(err) {
        if (err.name === "AbortError")
          return;
        if (err.result && err.result.errors && err.result.data) {
          observer.next(err.result);
        }
        observer.error(err);
      });
      return function() {
        if (controller)
          controller.abort();
      };
    });
  });
};
var HttpLink = function(_super) {
  __extends(HttpLink2, _super);
  function HttpLink2(options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this, createHttpLink(options).request) || this;
    _this.options = options;
    return _this;
  }
  return HttpLink2;
}(ApolloLink);
var _a$2 = Object.prototype, toString = _a$2.toString, hasOwnProperty$3 = _a$2.hasOwnProperty;
var fnToStr = Function.prototype.toString;
var previousComparisons = /* @__PURE__ */ new Map();
function equal(a3, b4) {
  try {
    return check(a3, b4);
  } finally {
    previousComparisons.clear();
  }
}
function check(a3, b4) {
  if (a3 === b4) {
    return true;
  }
  var aTag = toString.call(a3);
  var bTag = toString.call(b4);
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case "[object Array]":
      if (a3.length !== b4.length)
        return false;
    case "[object Object]": {
      if (previouslyCompared(a3, b4))
        return true;
      var aKeys = definedKeys(a3);
      var bKeys = definedKeys(b4);
      var keyCount = aKeys.length;
      if (keyCount !== bKeys.length)
        return false;
      for (var k3 = 0; k3 < keyCount; ++k3) {
        if (!hasOwnProperty$3.call(b4, aKeys[k3])) {
          return false;
        }
      }
      for (var k3 = 0; k3 < keyCount; ++k3) {
        var key2 = aKeys[k3];
        if (!check(a3[key2], b4[key2])) {
          return false;
        }
      }
      return true;
    }
    case "[object Error]":
      return a3.name === b4.name && a3.message === b4.message;
    case "[object Number]":
      if (a3 !== a3)
        return b4 !== b4;
    case "[object Boolean]":
    case "[object Date]":
      return +a3 === +b4;
    case "[object RegExp]":
    case "[object String]":
      return a3 == "" + b4;
    case "[object Map]":
    case "[object Set]": {
      if (a3.size !== b4.size)
        return false;
      if (previouslyCompared(a3, b4))
        return true;
      var aIterator = a3.entries();
      var isMap2 = aTag === "[object Map]";
      while (true) {
        var info = aIterator.next();
        if (info.done)
          break;
        var _a2 = info.value, aKey = _a2[0], aValue = _a2[1];
        if (!b4.has(aKey)) {
          return false;
        }
        if (isMap2 && !check(aValue, b4.get(aKey))) {
          return false;
        }
      }
      return true;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      a3 = new Uint8Array(a3);
      b4 = new Uint8Array(b4);
    case "[object DataView]": {
      var len2 = a3.byteLength;
      if (len2 === b4.byteLength) {
        while (len2-- && a3[len2] === b4[len2]) {
        }
      }
      return len2 === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      var aCode = fnToStr.call(a3);
      if (aCode !== fnToStr.call(b4)) {
        return false;
      }
      return !endsWith(aCode, nativeCodeSuffix);
    }
  }
  return false;
}
function definedKeys(obj) {
  return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key2) {
  return this[key2] !== void 0;
}
var nativeCodeSuffix = "{ [native code] }";
function endsWith(full, suffix) {
  var fromIndex = full.length - suffix.length;
  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a3, b4) {
  var bSet = previousComparisons.get(a3);
  if (bSet) {
    if (bSet.has(b4))
      return true;
  } else {
    previousComparisons.set(a3, bSet = /* @__PURE__ */ new Set());
  }
  bSet.add(b4);
  return false;
}
var defaultMakeData = function() {
  return /* @__PURE__ */ Object.create(null);
};
var _a$1 = Array.prototype, forEach = _a$1.forEach, slice = _a$1.slice;
var Trie = (
  /** @class */
  function() {
    function Trie2(weakness, makeData) {
      if (weakness === void 0) {
        weakness = true;
      }
      if (makeData === void 0) {
        makeData = defaultMakeData;
      }
      this.weakness = weakness;
      this.makeData = makeData;
    }
    Trie2.prototype.lookup = function() {
      var array2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        array2[_i] = arguments[_i];
      }
      return this.lookupArray(array2);
    };
    Trie2.prototype.lookupArray = function(array2) {
      var node2 = this;
      forEach.call(array2, function(key2) {
        return node2 = node2.getChildTrie(key2);
      });
      return node2.data || (node2.data = this.makeData(slice.call(array2)));
    };
    Trie2.prototype.getChildTrie = function(key2) {
      var map2 = this.weakness && isObjRef(key2) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
      var child = map2.get(key2);
      if (!child)
        map2.set(key2, child = new Trie2(this.weakness, this.makeData));
      return child;
    };
    return Trie2;
  }()
);
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
var currentContext = null;
var MISSING_VALUE = {};
var idCounter = 1;
var makeSlotClass = function() {
  return (
    /** @class */
    function() {
      function Slot2() {
        this.id = [
          "slot",
          idCounter++,
          Date.now(),
          Math.random().toString(36).slice(2)
        ].join(":");
      }
      Slot2.prototype.hasValue = function() {
        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
          if (this.id in context_1.slots) {
            var value = context_1.slots[this.id];
            if (value === MISSING_VALUE)
              break;
            if (context_1 !== currentContext) {
              currentContext.slots[this.id] = value;
            }
            return true;
          }
        }
        if (currentContext) {
          currentContext.slots[this.id] = MISSING_VALUE;
        }
        return false;
      };
      Slot2.prototype.getValue = function() {
        if (this.hasValue()) {
          return currentContext.slots[this.id];
        }
      };
      Slot2.prototype.withValue = function(value, callback, args, thisArg) {
        var _a2;
        var slots = (_a2 = {
          __proto__: null
        }, _a2[this.id] = value, _a2);
        var parent = currentContext;
        currentContext = { parent, slots };
        try {
          return callback.apply(thisArg, args);
        } finally {
          currentContext = parent;
        }
      };
      Slot2.bind = function(callback) {
        var context = currentContext;
        return function() {
          var saved = currentContext;
          try {
            currentContext = context;
            return callback.apply(this, arguments);
          } finally {
            currentContext = saved;
          }
        };
      };
      Slot2.noContext = function(callback, args, thisArg) {
        if (currentContext) {
          var saved = currentContext;
          try {
            currentContext = null;
            return callback.apply(thisArg, args);
          } finally {
            currentContext = saved;
          }
        } else {
          return callback.apply(thisArg, args);
        }
      };
      return Slot2;
    }()
  );
};
var globalKey = "@wry/context:Slot";
var host = Array;
var Slot = host[globalKey] || function() {
  var Slot2 = makeSlotClass();
  try {
    Object.defineProperty(host, globalKey, {
      value: host[globalKey] = Slot2,
      enumerable: false,
      writable: false,
      configurable: false
    });
  } finally {
    return Slot2;
  }
}();
Slot.bind;
Slot.noContext;
function defaultDispose() {
}
var Cache = (
  /** @class */
  function() {
    function Cache2(max2, dispose2) {
      if (max2 === void 0) {
        max2 = Infinity;
      }
      if (dispose2 === void 0) {
        dispose2 = defaultDispose;
      }
      this.max = max2;
      this.dispose = dispose2;
      this.map = /* @__PURE__ */ new Map();
      this.newest = null;
      this.oldest = null;
    }
    Cache2.prototype.has = function(key2) {
      return this.map.has(key2);
    };
    Cache2.prototype.get = function(key2) {
      var node2 = this.getNode(key2);
      return node2 && node2.value;
    };
    Cache2.prototype.getNode = function(key2) {
      var node2 = this.map.get(key2);
      if (node2 && node2 !== this.newest) {
        var older = node2.older, newer = node2.newer;
        if (newer) {
          newer.older = older;
        }
        if (older) {
          older.newer = newer;
        }
        node2.older = this.newest;
        node2.older.newer = node2;
        node2.newer = null;
        this.newest = node2;
        if (node2 === this.oldest) {
          this.oldest = newer;
        }
      }
      return node2;
    };
    Cache2.prototype.set = function(key2, value) {
      var node2 = this.getNode(key2);
      if (node2) {
        return node2.value = value;
      }
      node2 = {
        key: key2,
        value,
        newer: null,
        older: this.newest
      };
      if (this.newest) {
        this.newest.newer = node2;
      }
      this.newest = node2;
      this.oldest = this.oldest || node2;
      this.map.set(key2, node2);
      return node2.value;
    };
    Cache2.prototype.clean = function() {
      while (this.oldest && this.map.size > this.max) {
        this.delete(this.oldest.key);
      }
    };
    Cache2.prototype.delete = function(key2) {
      var node2 = this.map.get(key2);
      if (node2) {
        if (node2 === this.newest) {
          this.newest = node2.older;
        }
        if (node2 === this.oldest) {
          this.oldest = node2.newer;
        }
        if (node2.newer) {
          node2.newer.older = node2.older;
        }
        if (node2.older) {
          node2.older.newer = node2.newer;
        }
        this.map.delete(key2);
        this.dispose(node2.value, key2);
        return true;
      }
      return false;
    };
    return Cache2;
  }()
);
var parentEntrySlot = new Slot();
var _a;
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var toArray = (_a = Array.from, _a === void 0 ? function(collection) {
  var array2 = [];
  collection.forEach(function(item) {
    return array2.push(item);
  });
  return array2;
} : _a);
function maybeUnsubscribe(entryOrDep) {
  var unsubscribe = entryOrDep.unsubscribe;
  if (typeof unsubscribe === "function") {
    entryOrDep.unsubscribe = void 0;
    unsubscribe();
  }
}
var emptySetPool = [];
var POOL_TARGET_SIZE = 100;
function assert(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a3, b4) {
  var len2 = a3.length;
  return (
    // Unknown values are not equal to each other.
    len2 > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    len2 === b4.length && // The underlying value or exception must be the same.
    a3[len2 - 1] === b4[len2 - 1]
  );
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
var Entry = (
  /** @class */
  function() {
    function Entry3(fn2) {
      this.fn = fn2;
      this.parents = /* @__PURE__ */ new Set();
      this.childValues = /* @__PURE__ */ new Map();
      this.dirtyChildren = null;
      this.dirty = true;
      this.recomputing = false;
      this.value = [];
      this.deps = null;
      ++Entry3.count;
    }
    Entry3.prototype.peek = function() {
      if (this.value.length === 1 && !mightBeDirty(this)) {
        rememberParent(this);
        return this.value[0];
      }
    };
    Entry3.prototype.recompute = function(args) {
      assert(!this.recomputing, "already recomputing");
      rememberParent(this);
      return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
    };
    Entry3.prototype.setDirty = function() {
      if (this.dirty)
        return;
      this.dirty = true;
      this.value.length = 0;
      reportDirty(this);
      maybeUnsubscribe(this);
    };
    Entry3.prototype.dispose = function() {
      var _this = this;
      this.setDirty();
      forgetChildren(this);
      eachParent(this, function(parent, child) {
        parent.setDirty();
        forgetChild(parent, _this);
      });
    };
    Entry3.prototype.forget = function() {
      this.dispose();
    };
    Entry3.prototype.dependOn = function(dep2) {
      dep2.add(this);
      if (!this.deps) {
        this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
      }
      this.deps.add(dep2);
    };
    Entry3.prototype.forgetDeps = function() {
      var _this = this;
      if (this.deps) {
        toArray(this.deps).forEach(function(dep2) {
          return dep2.delete(_this);
        });
        this.deps.clear();
        emptySetPool.push(this.deps);
        this.deps = null;
      }
    };
    Entry3.count = 0;
    return Entry3;
  }()
);
function rememberParent(child) {
  var parent = parentEntrySlot.getValue();
  if (parent) {
    child.parents.add(parent);
    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }
    return parent;
  }
}
function reallyRecompute(entry, args) {
  forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
  if (maybeSubscribe(entry, args)) {
    setClean(entry);
  }
  return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
  entry.recomputing = true;
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, args);
  } catch (e2) {
    entry.value[1] = e2;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  eachParent(child, reportDirtyChild);
}
function reportClean(child) {
  eachParent(child, reportCleanChild);
}
function eachParent(child, callback) {
  var parentCount = child.parents.size;
  if (parentCount) {
    var parents = toArray(child.parents);
    for (var i3 = 0; i3 < parentCount; ++i3) {
      callback(parents[i3], child);
    }
  }
}
function reportDirtyChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(mightBeDirty(child));
  var parentWasClean = !mightBeDirty(parent);
  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
  } else if (parent.dirtyChildren.has(child)) {
    return;
  }
  parent.dirtyChildren.add(child);
  if (parentWasClean) {
    reportDirty(parent);
  }
}
function reportCleanChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(!mightBeDirty(child));
  var childValue = parent.childValues.get(child);
  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }
  removeDirtyChild(parent, child);
  if (mightBeDirty(parent)) {
    return;
  }
  reportClean(parent);
}
function removeDirtyChild(parent, child) {
  var dc2 = parent.dirtyChildren;
  if (dc2) {
    dc2.delete(child);
    if (dc2.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc2);
      }
      parent.dirtyChildren = null;
    }
  }
}
function forgetChildren(parent) {
  if (parent.childValues.size > 0) {
    parent.childValues.forEach(function(_value, child) {
      forgetChild(parent, child);
    });
  }
  parent.forgetDeps();
  assert(parent.dirtyChildren === null);
}
function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}
function maybeSubscribe(entry, args) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, args);
    } catch (e2) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}
var EntryMethods = {
  setDirty: true,
  dispose: true,
  forget: true
};
function dep(options) {
  var depsByKey = /* @__PURE__ */ new Map();
  var subscribe2 = options && options.subscribe;
  function depend(key2) {
    var parent = parentEntrySlot.getValue();
    if (parent) {
      var dep_1 = depsByKey.get(key2);
      if (!dep_1) {
        depsByKey.set(key2, dep_1 = /* @__PURE__ */ new Set());
      }
      parent.dependOn(dep_1);
      if (typeof subscribe2 === "function") {
        maybeUnsubscribe(dep_1);
        dep_1.unsubscribe = subscribe2(key2);
      }
    }
  }
  depend.dirty = function dirty(key2, entryMethodName) {
    var dep2 = depsByKey.get(key2);
    if (dep2) {
      var m_1 = entryMethodName && hasOwnProperty$2.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
      toArray(dep2).forEach(function(entry) {
        return entry[m_1]();
      });
      depsByKey.delete(key2);
      maybeUnsubscribe(dep2);
    }
  };
  return depend;
}
function makeDefaultMakeCacheKeyFunction() {
  var keyTrie = new Trie(typeof WeakMap === "function");
  return function() {
    return keyTrie.lookupArray(arguments);
  };
}
makeDefaultMakeCacheKeyFunction();
var caches = /* @__PURE__ */ new Set();
function wrap(originalFunction, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  var cache = new Cache(options.max || Math.pow(2, 16), function(entry) {
    return entry.dispose();
  });
  var keyArgs = options.keyArgs;
  var makeCacheKey = options.makeCacheKey || makeDefaultMakeCacheKeyFunction();
  var optimistic = function() {
    var key2 = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
    if (key2 === void 0) {
      return originalFunction.apply(null, arguments);
    }
    var entry = cache.get(key2);
    if (!entry) {
      cache.set(key2, entry = new Entry(originalFunction));
      entry.subscribe = options.subscribe;
      entry.forget = function() {
        return cache.delete(key2);
      };
    }
    var value = entry.recompute(Array.prototype.slice.call(arguments));
    cache.set(key2, entry);
    caches.add(cache);
    if (!parentEntrySlot.hasValue()) {
      caches.forEach(function(cache2) {
        return cache2.clean();
      });
      caches.clear();
    }
    return value;
  };
  Object.defineProperty(optimistic, "size", {
    get: function() {
      return cache["map"].size;
    },
    configurable: false,
    enumerable: false
  });
  function dirtyKey(key2) {
    var entry = cache.get(key2);
    if (entry) {
      entry.setDirty();
    }
  }
  optimistic.dirtyKey = dirtyKey;
  optimistic.dirty = function dirty() {
    dirtyKey(makeCacheKey.apply(null, arguments));
  };
  function peekKey(key2) {
    var entry = cache.get(key2);
    if (entry) {
      return entry.peek();
    }
  }
  optimistic.peekKey = peekKey;
  optimistic.peek = function peek() {
    return peekKey(makeCacheKey.apply(null, arguments));
  };
  function forgetKey(key2) {
    return cache.delete(key2);
  }
  optimistic.forgetKey = forgetKey;
  optimistic.forget = function forget() {
    return forgetKey(makeCacheKey.apply(null, arguments));
  };
  optimistic.makeCacheKey = makeCacheKey;
  optimistic.getKey = keyArgs ? function getKey() {
    return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
  } : makeCacheKey;
  return Object.freeze(optimistic);
}
var ApolloCache = function() {
  function ApolloCache2() {
    this.getFragmentDoc = wrap(getFragmentQueryDocument);
  }
  ApolloCache2.prototype.batch = function(options) {
    var _this = this;
    var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
    var updateResult;
    this.performTransaction(function() {
      return updateResult = options.update(_this);
    }, optimisticId);
    return updateResult;
  };
  ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
    this.performTransaction(transaction, optimisticId);
  };
  ApolloCache2.prototype.transformDocument = function(document2) {
    return document2;
  };
  ApolloCache2.prototype.identify = function(object2) {
    return;
  };
  ApolloCache2.prototype.gc = function() {
    return [];
  };
  ApolloCache2.prototype.modify = function(options) {
    return false;
  };
  ApolloCache2.prototype.transformForLink = function(document2) {
    return document2;
  };
  ApolloCache2.prototype.readQuery = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = !!options.optimistic;
    }
    return this.read(__assign$1(__assign$1({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
  };
  ApolloCache2.prototype.readFragment = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = !!options.optimistic;
    }
    return this.read(__assign$1(__assign$1({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
  };
  ApolloCache2.prototype.writeQuery = function(_a2) {
    var id2 = _a2.id, data2 = _a2.data, options = __rest$1(_a2, ["id", "data"]);
    return this.write(Object.assign(options, {
      dataId: id2 || "ROOT_QUERY",
      result: data2
    }));
  };
  ApolloCache2.prototype.writeFragment = function(_a2) {
    var id2 = _a2.id, data2 = _a2.data, fragment = _a2.fragment, fragmentName = _a2.fragmentName, options = __rest$1(_a2, ["id", "data", "fragment", "fragmentName"]);
    return this.write(Object.assign(options, {
      query: this.getFragmentDoc(fragment, fragmentName),
      dataId: id2,
      result: data2
    }));
  };
  ApolloCache2.prototype.updateQuery = function(options, update5) {
    return this.batch({
      update: function(cache) {
        var value = cache.readQuery(options);
        var data2 = update5(value);
        if (data2 === void 0 || data2 === null)
          return value;
        cache.writeQuery(__assign$1(__assign$1({}, options), { data: data2 }));
        return data2;
      }
    });
  };
  ApolloCache2.prototype.updateFragment = function(options, update5) {
    return this.batch({
      update: function(cache) {
        var value = cache.readFragment(options);
        var data2 = update5(value);
        if (data2 === void 0 || data2 === null)
          return value;
        cache.writeFragment(__assign$1(__assign$1({}, options), { data: data2 }));
        return data2;
      }
    });
  };
  return ApolloCache2;
}();
var MissingFieldError = function() {
  function MissingFieldError2(message, path, query2, variables) {
    this.message = message;
    this.path = path;
    this.query = query2;
    this.variables = variables;
  }
  return MissingFieldError2;
}();
var hasOwn = Object.prototype.hasOwnProperty;
function defaultDataIdFromObject(_a2, context) {
  var __typename = _a2.__typename, id2 = _a2.id, _id = _a2._id;
  if (typeof __typename === "string") {
    if (context) {
      context.keyObject = id2 !== void 0 ? { id: id2 } : _id !== void 0 ? { _id } : void 0;
    }
    if (id2 === void 0)
      id2 = _id;
    if (id2 !== void 0) {
      return "".concat(__typename, ":").concat(typeof id2 === "number" || typeof id2 === "string" ? id2 : JSON.stringify(id2));
    }
  }
}
var defaultConfig = {
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  canonizeResults: false
};
function normalizeConfig(config2) {
  return compact(defaultConfig, config2);
}
function shouldCanonizeResults(config2) {
  var value = config2.canonizeResults;
  return value === void 0 ? defaultConfig.canonizeResults : value;
}
function getTypenameFromStoreObject(store, objectOrReference) {
  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
}
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
  var match = storeFieldName.match(TypeOrFieldNameRegExp);
  return match ? match[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result, variables) {
  if (isNonNullObject(result)) {
    return isArray(result) ? result.every(function(item) {
      return selectionSetMatchesResult(selectionSet, item, variables);
    }) : selectionSet.selections.every(function(field) {
      if (isField(field) && shouldInclude(field, variables)) {
        var key2 = resultKeyNameFromField(field);
        return hasOwn.call(result, key2) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key2], variables));
      }
      return true;
    });
  }
  return false;
}
function storeValueIsStoreObject(value) {
  return isNonNullObject(value) && !isReference(value) && !isArray(value);
}
function makeProcessedFieldsMerger() {
  return new DeepMerger();
}
var isArray = function(a3) {
  return Array.isArray(a3);
};
var DELETE = /* @__PURE__ */ Object.create(null);
var delModifier = function() {
  return DELETE;
};
var INVALIDATE = /* @__PURE__ */ Object.create(null);
var EntityStore = function() {
  function EntityStore2(policies, group) {
    var _this = this;
    this.policies = policies;
    this.group = group;
    this.data = /* @__PURE__ */ Object.create(null);
    this.rootIds = /* @__PURE__ */ Object.create(null);
    this.refs = /* @__PURE__ */ Object.create(null);
    this.getFieldValue = function(objectOrReference, storeFieldName) {
      return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
    };
    this.canRead = function(objOrRef) {
      return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
    };
    this.toReference = function(objOrIdOrRef, mergeIntoStore) {
      if (typeof objOrIdOrRef === "string") {
        return makeReference(objOrIdOrRef);
      }
      if (isReference(objOrIdOrRef)) {
        return objOrIdOrRef;
      }
      var id2 = _this.policies.identify(objOrIdOrRef)[0];
      if (id2) {
        var ref2 = makeReference(id2);
        if (mergeIntoStore) {
          _this.merge(id2, objOrIdOrRef);
        }
        return ref2;
      }
    };
  }
  EntityStore2.prototype.toObject = function() {
    return __assign$1({}, this.data);
  };
  EntityStore2.prototype.has = function(dataId) {
    return this.lookup(dataId, true) !== void 0;
  };
  EntityStore2.prototype.get = function(dataId, fieldName) {
    this.group.depend(dataId, fieldName);
    if (hasOwn.call(this.data, dataId)) {
      var storeObject = this.data[dataId];
      if (storeObject && hasOwn.call(storeObject, fieldName)) {
        return storeObject[fieldName];
      }
    }
    if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
      return this.policies.rootTypenamesById[dataId];
    }
    if (this instanceof Layer) {
      return this.parent.get(dataId, fieldName);
    }
  };
  EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
    if (dependOnExistence)
      this.group.depend(dataId, "__exists");
    if (hasOwn.call(this.data, dataId)) {
      return this.data[dataId];
    }
    if (this instanceof Layer) {
      return this.parent.lookup(dataId, dependOnExistence);
    }
    if (this.policies.rootTypenamesById[dataId]) {
      return /* @__PURE__ */ Object.create(null);
    }
  };
  EntityStore2.prototype.merge = function(older, newer) {
    var _this = this;
    var dataId;
    if (isReference(older))
      older = older.__ref;
    if (isReference(newer))
      newer = newer.__ref;
    var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
    var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
    if (!incoming)
      return;
    __DEV__ ? invariant$1(typeof dataId === "string", "store.merge expects a string ID") : invariant$1(typeof dataId === "string", 1);
    var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
    this.data[dataId] = merged;
    if (merged !== existing) {
      delete this.refs[dataId];
      if (this.group.caching) {
        var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
        if (!existing)
          fieldsToDirty_1.__exists = 1;
        Object.keys(incoming).forEach(function(storeFieldName) {
          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
            fieldsToDirty_1[storeFieldName] = 1;
            var fieldName = fieldNameFromStoreName(storeFieldName);
            if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
              fieldsToDirty_1[fieldName] = 1;
            }
            if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
              delete merged[storeFieldName];
            }
          }
        });
        if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {
          delete fieldsToDirty_1.__typename;
        }
        Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
          return _this.group.dirty(dataId, fieldName);
        });
      }
    }
  };
  EntityStore2.prototype.modify = function(dataId, fields) {
    var _this = this;
    var storeObject = this.lookup(dataId);
    if (storeObject) {
      var changedFields_1 = /* @__PURE__ */ Object.create(null);
      var needToMerge_1 = false;
      var allDeleted_1 = true;
      var sharedDetails_1 = {
        DELETE,
        INVALIDATE,
        isReference,
        toReference: this.toReference,
        canRead: this.canRead,
        readField: function(fieldNameOrOptions, from2) {
          return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
            fieldName: fieldNameOrOptions,
            from: from2 || makeReference(dataId)
          } : fieldNameOrOptions, { store: _this });
        }
      };
      Object.keys(storeObject).forEach(function(storeFieldName) {
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var fieldValue = storeObject[storeFieldName];
        if (fieldValue === void 0)
          return;
        var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
        if (modify) {
          var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign$1(__assign$1({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
          if (newValue === INVALIDATE) {
            _this.group.dirty(dataId, storeFieldName);
          } else {
            if (newValue === DELETE)
              newValue = void 0;
            if (newValue !== fieldValue) {
              changedFields_1[storeFieldName] = newValue;
              needToMerge_1 = true;
              fieldValue = newValue;
            }
          }
        }
        if (fieldValue !== void 0) {
          allDeleted_1 = false;
        }
      });
      if (needToMerge_1) {
        this.merge(dataId, changedFields_1);
        if (allDeleted_1) {
          if (this instanceof Layer) {
            this.data[dataId] = void 0;
          } else {
            delete this.data[dataId];
          }
          this.group.dirty(dataId, "__exists");
        }
        return true;
      }
    }
    return false;
  };
  EntityStore2.prototype.delete = function(dataId, fieldName, args) {
    var _a2;
    var storeObject = this.lookup(dataId);
    if (storeObject) {
      var typename = this.getFieldValue(storeObject, "__typename");
      var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
      return this.modify(dataId, storeFieldName ? (_a2 = {}, _a2[storeFieldName] = delModifier, _a2) : delModifier);
    }
    return false;
  };
  EntityStore2.prototype.evict = function(options, limit) {
    var evicted = false;
    if (options.id) {
      if (hasOwn.call(this.data, options.id)) {
        evicted = this.delete(options.id, options.fieldName, options.args);
      }
      if (this instanceof Layer && this !== limit) {
        evicted = this.parent.evict(options, limit) || evicted;
      }
      if (options.fieldName || evicted) {
        this.group.dirty(options.id, options.fieldName || "__exists");
      }
    }
    return evicted;
  };
  EntityStore2.prototype.clear = function() {
    this.replace(null);
  };
  EntityStore2.prototype.extract = function() {
    var _this = this;
    var obj = this.toObject();
    var extraRootIds = [];
    this.getRootIdSet().forEach(function(id2) {
      if (!hasOwn.call(_this.policies.rootTypenamesById, id2)) {
        extraRootIds.push(id2);
      }
    });
    if (extraRootIds.length) {
      obj.__META = { extraRootIds: extraRootIds.sort() };
    }
    return obj;
  };
  EntityStore2.prototype.replace = function(newData) {
    var _this = this;
    Object.keys(this.data).forEach(function(dataId) {
      if (!(newData && hasOwn.call(newData, dataId))) {
        _this.delete(dataId);
      }
    });
    if (newData) {
      var __META = newData.__META, rest_1 = __rest$1(newData, ["__META"]);
      Object.keys(rest_1).forEach(function(dataId) {
        _this.merge(dataId, rest_1[dataId]);
      });
      if (__META) {
        __META.extraRootIds.forEach(this.retain, this);
      }
    }
  };
  EntityStore2.prototype.retain = function(rootId) {
    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
  };
  EntityStore2.prototype.release = function(rootId) {
    if (this.rootIds[rootId] > 0) {
      var count2 = --this.rootIds[rootId];
      if (!count2)
        delete this.rootIds[rootId];
      return count2;
    }
    return 0;
  };
  EntityStore2.prototype.getRootIdSet = function(ids) {
    if (ids === void 0) {
      ids = /* @__PURE__ */ new Set();
    }
    Object.keys(this.rootIds).forEach(ids.add, ids);
    if (this instanceof Layer) {
      this.parent.getRootIdSet(ids);
    } else {
      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
    }
    return ids;
  };
  EntityStore2.prototype.gc = function() {
    var _this = this;
    var ids = this.getRootIdSet();
    var snapshot2 = this.toObject();
    ids.forEach(function(id2) {
      if (hasOwn.call(snapshot2, id2)) {
        Object.keys(_this.findChildRefIds(id2)).forEach(ids.add, ids);
        delete snapshot2[id2];
      }
    });
    var idsToRemove = Object.keys(snapshot2);
    if (idsToRemove.length) {
      var root_1 = this;
      while (root_1 instanceof Layer)
        root_1 = root_1.parent;
      idsToRemove.forEach(function(id2) {
        return root_1.delete(id2);
      });
    }
    return idsToRemove;
  };
  EntityStore2.prototype.findChildRefIds = function(dataId) {
    if (!hasOwn.call(this.refs, dataId)) {
      var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
      var root2 = this.data[dataId];
      if (!root2)
        return found_1;
      var workSet_1 = /* @__PURE__ */ new Set([root2]);
      workSet_1.forEach(function(obj) {
        if (isReference(obj)) {
          found_1[obj.__ref] = true;
        }
        if (isNonNullObject(obj)) {
          Object.keys(obj).forEach(function(key2) {
            var child = obj[key2];
            if (isNonNullObject(child)) {
              workSet_1.add(child);
            }
          });
        }
      });
    }
    return this.refs[dataId];
  };
  EntityStore2.prototype.makeCacheKey = function() {
    return this.group.keyMaker.lookupArray(arguments);
  };
  return EntityStore2;
}();
var CacheGroup = function() {
  function CacheGroup2(caching, parent) {
    if (parent === void 0) {
      parent = null;
    }
    this.caching = caching;
    this.parent = parent;
    this.d = null;
    this.resetCaching();
  }
  CacheGroup2.prototype.resetCaching = function() {
    this.d = this.caching ? dep() : null;
    this.keyMaker = new Trie(canUseWeakMap);
  };
  CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
    if (this.d) {
      this.d(makeDepKey(dataId, storeFieldName));
      var fieldName = fieldNameFromStoreName(storeFieldName);
      if (fieldName !== storeFieldName) {
        this.d(makeDepKey(dataId, fieldName));
      }
      if (this.parent) {
        this.parent.depend(dataId, storeFieldName);
      }
    }
  };
  CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
    if (this.d) {
      this.d.dirty(makeDepKey(dataId, storeFieldName), storeFieldName === "__exists" ? "forget" : "setDirty");
    }
  };
  return CacheGroup2;
}();
function makeDepKey(dataId, storeFieldName) {
  return storeFieldName + "#" + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
  if (supportsResultCaching(store)) {
    store.group.depend(entityId, "__exists");
  }
}
(function(EntityStore2) {
  var Root2 = function(_super) {
    __extends(Root3, _super);
    function Root3(_a2) {
      var policies = _a2.policies, _b = _a2.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a2.seed;
      var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
      _this.stump = new Stump(_this);
      _this.storageTrie = new Trie(canUseWeakMap);
      if (seed)
        _this.replace(seed);
      return _this;
    }
    Root3.prototype.addLayer = function(layerId, replay) {
      return this.stump.addLayer(layerId, replay);
    };
    Root3.prototype.removeLayer = function() {
      return this;
    };
    Root3.prototype.getStorage = function() {
      return this.storageTrie.lookupArray(arguments);
    };
    return Root3;
  }(EntityStore2);
  EntityStore2.Root = Root2;
})(EntityStore || (EntityStore = {}));
var Layer = function(_super) {
  __extends(Layer2, _super);
  function Layer2(id2, parent, replay, group) {
    var _this = _super.call(this, parent.policies, group) || this;
    _this.id = id2;
    _this.parent = parent;
    _this.replay = replay;
    _this.group = group;
    replay(_this);
    return _this;
  }
  Layer2.prototype.addLayer = function(layerId, replay) {
    return new Layer2(layerId, this, replay, this.group);
  };
  Layer2.prototype.removeLayer = function(layerId) {
    var _this = this;
    var parent = this.parent.removeLayer(layerId);
    if (layerId === this.id) {
      if (this.group.caching) {
        Object.keys(this.data).forEach(function(dataId) {
          var ownStoreObject = _this.data[dataId];
          var parentStoreObject = parent["lookup"](dataId);
          if (!parentStoreObject) {
            _this.delete(dataId);
          } else if (!ownStoreObject) {
            _this.group.dirty(dataId, "__exists");
            Object.keys(parentStoreObject).forEach(function(storeFieldName) {
              _this.group.dirty(dataId, storeFieldName);
            });
          } else if (ownStoreObject !== parentStoreObject) {
            Object.keys(ownStoreObject).forEach(function(storeFieldName) {
              if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                _this.group.dirty(dataId, storeFieldName);
              }
            });
          }
        });
      }
      return parent;
    }
    if (parent === this.parent)
      return this;
    return parent.addLayer(this.id, this.replay);
  };
  Layer2.prototype.toObject = function() {
    return __assign$1(__assign$1({}, this.parent.toObject()), this.data);
  };
  Layer2.prototype.findChildRefIds = function(dataId) {
    var fromParent = this.parent.findChildRefIds(dataId);
    return hasOwn.call(this.data, dataId) ? __assign$1(__assign$1({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
  };
  Layer2.prototype.getStorage = function() {
    var p3 = this.parent;
    while (p3.parent)
      p3 = p3.parent;
    return p3.getStorage.apply(p3, arguments);
  };
  return Layer2;
}(EntityStore);
var Stump = function(_super) {
  __extends(Stump2, _super);
  function Stump2(root2) {
    return _super.call(this, "EntityStore.Stump", root2, function() {
    }, new CacheGroup(root2.group.caching, root2.group)) || this;
  }
  Stump2.prototype.removeLayer = function() {
    return this;
  };
  Stump2.prototype.merge = function() {
    return this.parent.merge.apply(this.parent, arguments);
  };
  return Stump2;
}(Layer);
function storeObjectReconciler(existingObject, incomingObject, property) {
  var existingValue = existingObject[property];
  var incomingValue = incomingObject[property];
  return equal(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
  return !!(store instanceof EntityStore && store.group.caching);
}
function shallowCopy(value) {
  if (isNonNullObject(value)) {
    return isArray(value) ? value.slice(0) : __assign$1({ __proto__: Object.getPrototypeOf(value) }, value);
  }
  return value;
}
var ObjectCanon = function() {
  function ObjectCanon2() {
    this.known = new (canUseWeakSet ? WeakSet : Set)();
    this.pool = new Trie(canUseWeakMap);
    this.passes = /* @__PURE__ */ new WeakMap();
    this.keysByJSON = /* @__PURE__ */ new Map();
    this.empty = this.admit({});
  }
  ObjectCanon2.prototype.isKnown = function(value) {
    return isNonNullObject(value) && this.known.has(value);
  };
  ObjectCanon2.prototype.pass = function(value) {
    if (isNonNullObject(value)) {
      var copy2 = shallowCopy(value);
      this.passes.set(copy2, value);
      return copy2;
    }
    return value;
  };
  ObjectCanon2.prototype.admit = function(value) {
    var _this = this;
    if (isNonNullObject(value)) {
      var original = this.passes.get(value);
      if (original)
        return original;
      var proto = Object.getPrototypeOf(value);
      switch (proto) {
        case Array.prototype: {
          if (this.known.has(value))
            return value;
          var array2 = value.map(this.admit, this);
          var node2 = this.pool.lookupArray(array2);
          if (!node2.array) {
            this.known.add(node2.array = array2);
            if (__DEV__) {
              Object.freeze(array2);
            }
          }
          return node2.array;
        }
        case null:
        case Object.prototype: {
          if (this.known.has(value))
            return value;
          var proto_1 = Object.getPrototypeOf(value);
          var array_1 = [proto_1];
          var keys2 = this.sortedKeys(value);
          array_1.push(keys2.json);
          var firstValueIndex_1 = array_1.length;
          keys2.sorted.forEach(function(key2) {
            array_1.push(_this.admit(value[key2]));
          });
          var node2 = this.pool.lookupArray(array_1);
          if (!node2.object) {
            var obj_1 = node2.object = Object.create(proto_1);
            this.known.add(obj_1);
            keys2.sorted.forEach(function(key2, i3) {
              obj_1[key2] = array_1[firstValueIndex_1 + i3];
            });
            if (__DEV__) {
              Object.freeze(obj_1);
            }
          }
          return node2.object;
        }
      }
    }
    return value;
  };
  ObjectCanon2.prototype.sortedKeys = function(obj) {
    var keys2 = Object.keys(obj);
    var node2 = this.pool.lookupArray(keys2);
    if (!node2.keys) {
      keys2.sort();
      var json2 = JSON.stringify(keys2);
      if (!(node2.keys = this.keysByJSON.get(json2))) {
        this.keysByJSON.set(json2, node2.keys = { sorted: keys2, json: json2 });
      }
    }
    return node2.keys;
  };
  return ObjectCanon2;
}();
var canonicalStringify = Object.assign(function(value) {
  if (isNonNullObject(value)) {
    if (stringifyCanon === void 0) {
      resetCanonicalStringify();
    }
    var canonical = stringifyCanon.admit(value);
    var json2 = stringifyCache.get(canonical);
    if (json2 === void 0) {
      stringifyCache.set(canonical, json2 = JSON.stringify(canonical));
    }
    return json2;
  }
  return JSON.stringify(value);
}, {
  reset: resetCanonicalStringify
});
var stringifyCanon;
var stringifyCache;
function resetCanonicalStringify() {
  stringifyCanon = new ObjectCanon();
  stringifyCache = new (canUseWeakMap ? WeakMap : Map)();
}
function execSelectionSetKeyArgs(options) {
  return [
    options.selectionSet,
    options.objectOrReference,
    options.context,
    options.context.canonizeResults
  ];
}
var StoreReader = function() {
  function StoreReader2(config2) {
    var _this = this;
    this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
    this.config = compact(config2, {
      addTypename: config2.addTypename !== false,
      canonizeResults: shouldCanonizeResults(config2)
    });
    this.canon = config2.canon || new ObjectCanon();
    this.executeSelectionSet = wrap(function(options) {
      var _a2;
      var canonizeResults = options.context.canonizeResults;
      var peekArgs = execSelectionSetKeyArgs(options);
      peekArgs[3] = !canonizeResults;
      var other = (_a2 = _this.executeSelectionSet).peek.apply(_a2, peekArgs);
      if (other) {
        if (canonizeResults) {
          return __assign$1(__assign$1({}, other), { result: _this.canon.admit(other.result) });
        }
        return other;
      }
      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
      return _this.execSelectionSetImpl(options);
    }, {
      max: this.config.resultCacheMaxSize,
      keyArgs: execSelectionSetKeyArgs,
      makeCacheKey: function(selectionSet, parent, context, canonizeResults) {
        if (supportsResultCaching(context.store)) {
          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
        }
      }
    });
    this.executeSubSelectedArray = wrap(function(options) {
      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
      return _this.execSubSelectedArrayImpl(options);
    }, {
      max: this.config.resultCacheMaxSize,
      makeCacheKey: function(_a2) {
        var field = _a2.field, array2 = _a2.array, context = _a2.context;
        if (supportsResultCaching(context.store)) {
          return context.store.makeCacheKey(field, array2, context.varString);
        }
      }
    });
  }
  StoreReader2.prototype.resetCanon = function() {
    this.canon = new ObjectCanon();
  };
  StoreReader2.prototype.diffQueryAgainstStore = function(_a2) {
    var store = _a2.store, query2 = _a2.query, _b = _a2.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a2.variables, _c = _a2.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a2.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
    var policies = this.config.cache.policies;
    variables = __assign$1(__assign$1({}, getDefaultValues(getQueryDefinition(query2))), variables);
    var rootRef = makeReference(rootId);
    var execResult = this.executeSelectionSet({
      selectionSet: getMainDefinition(query2).selectionSet,
      objectOrReference: rootRef,
      enclosingRef: rootRef,
      context: {
        store,
        query: query2,
        policies,
        variables,
        varString: canonicalStringify(variables),
        canonizeResults,
        fragmentMap: createFragmentMap(getFragmentDefinitions(query2))
      }
    });
    var missing;
    if (execResult.missing) {
      missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query2, variables)];
      if (!returnPartialData) {
        throw missing[0];
      }
    }
    return {
      result: execResult.result,
      complete: !missing,
      missing
    };
  };
  StoreReader2.prototype.isFresh = function(result, parent, selectionSet, context) {
    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {
      var latest = this.executeSelectionSet.peek(selectionSet, parent, context, this.canon.isKnown(result));
      if (latest && result === latest.result) {
        return true;
      }
    }
    return false;
  };
  StoreReader2.prototype.execSelectionSetImpl = function(_a2) {
    var _this = this;
    var selectionSet = _a2.selectionSet, objectOrReference = _a2.objectOrReference, enclosingRef = _a2.enclosingRef, context = _a2.context;
    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
      return {
        result: this.canon.empty,
        missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
      };
    }
    var variables = context.variables, policies = context.policies, store = context.store;
    var typename = store.getFieldValue(objectOrReference, "__typename");
    var objectsToMerge = [];
    var missing;
    var missingMerger = new DeepMerger();
    if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
      objectsToMerge.push({ __typename: typename });
    }
    function handleMissing(result2, resultName) {
      var _a3;
      if (result2.missing) {
        missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = result2.missing, _a3));
      }
      return result2.result;
    }
    var workSet = new Set(selectionSet.selections);
    workSet.forEach(function(selection) {
      var _a3, _b;
      if (!shouldInclude(selection, variables))
        return;
      if (isField(selection)) {
        var fieldValue = policies.readField({
          fieldName: selection.name.value,
          field: selection,
          variables: context.variables,
          from: objectOrReference
        }, context);
        var resultName = resultKeyNameFromField(selection);
        if (fieldValue === void 0) {
          if (!addTypenameToDocument.added(selection)) {
            missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a3));
          }
        } else if (isArray(fieldValue)) {
          fieldValue = handleMissing(_this.executeSubSelectedArray({
            field: selection,
            array: fieldValue,
            enclosingRef,
            context
          }), resultName);
        } else if (!selection.selectionSet) {
          if (context.canonizeResults) {
            fieldValue = _this.canon.pass(fieldValue);
          }
        } else if (fieldValue != null) {
          fieldValue = handleMissing(_this.executeSelectionSet({
            selectionSet: selection.selectionSet,
            objectOrReference: fieldValue,
            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
            context
          }), resultName);
        }
        if (fieldValue !== void 0) {
          objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
        }
      } else {
        var fragment = getFragmentFromSelection(selection, context.fragmentMap);
        if (fragment && policies.fragmentMatches(fragment, typename)) {
          fragment.selectionSet.selections.forEach(workSet.add, workSet);
        }
      }
    });
    var result = mergeDeepArray(objectsToMerge);
    var finalResult = { result, missing };
    var frozen = context.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);
    if (frozen.result) {
      this.knownResults.set(frozen.result, selectionSet);
    }
    return frozen;
  };
  StoreReader2.prototype.execSubSelectedArrayImpl = function(_a2) {
    var _this = this;
    var field = _a2.field, array2 = _a2.array, enclosingRef = _a2.enclosingRef, context = _a2.context;
    var missing;
    var missingMerger = new DeepMerger();
    function handleMissing(childResult, i3) {
      var _a3;
      if (childResult.missing) {
        missing = missingMerger.merge(missing, (_a3 = {}, _a3[i3] = childResult.missing, _a3));
      }
      return childResult.result;
    }
    if (field.selectionSet) {
      array2 = array2.filter(context.store.canRead);
    }
    array2 = array2.map(function(item, i3) {
      if (item === null) {
        return null;
      }
      if (isArray(item)) {
        return handleMissing(_this.executeSubSelectedArray({
          field,
          array: item,
          enclosingRef,
          context
        }), i3);
      }
      if (field.selectionSet) {
        return handleMissing(_this.executeSelectionSet({
          selectionSet: field.selectionSet,
          objectOrReference: item,
          enclosingRef: isReference(item) ? item : enclosingRef,
          context
        }), i3);
      }
      if (__DEV__) {
        assertSelectionSetForIdValue(context.store, field, item);
      }
      return item;
    });
    return {
      result: context.canonizeResults ? this.canon.admit(array2) : array2,
      missing
    };
  };
  return StoreReader2;
}();
function firstMissing(tree2) {
  try {
    JSON.stringify(tree2, function(_3, value) {
      if (typeof value === "string")
        throw value;
      return value;
    });
  } catch (result) {
    return result;
  }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
  if (!field.selectionSet) {
    var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
    workSet_1.forEach(function(value) {
      if (isNonNullObject(value)) {
        __DEV__ ? invariant$1(!isReference(value), "Missing selection set for object of type ".concat(getTypenameFromStoreObject(store, value), " returned for query field ").concat(field.name.value)) : invariant$1(!isReference(value), 5);
        Object.values(value).forEach(workSet_1.add, workSet_1);
      }
    });
  }
}
var cacheSlot = new Slot();
var cacheInfoMap = /* @__PURE__ */ new WeakMap();
function getCacheInfo(cache) {
  var info = cacheInfoMap.get(cache);
  if (!info) {
    cacheInfoMap.set(cache, info = {
      vars: /* @__PURE__ */ new Set(),
      dep: dep()
    });
  }
  return info;
}
function forgetCache(cache) {
  getCacheInfo(cache).vars.forEach(function(rv2) {
    return rv2.forgetCache(cache);
  });
}
function recallCache(cache) {
  getCacheInfo(cache).vars.forEach(function(rv2) {
    return rv2.attachCache(cache);
  });
}
function makeVar(value) {
  var caches2 = /* @__PURE__ */ new Set();
  var listeners2 = /* @__PURE__ */ new Set();
  var rv2 = function(newValue) {
    if (arguments.length > 0) {
      if (value !== newValue) {
        value = newValue;
        caches2.forEach(function(cache2) {
          getCacheInfo(cache2).dep.dirty(rv2);
          broadcast(cache2);
        });
        var oldListeners = Array.from(listeners2);
        listeners2.clear();
        oldListeners.forEach(function(listener) {
          return listener(value);
        });
      }
    } else {
      var cache = cacheSlot.getValue();
      if (cache) {
        attach(cache);
        getCacheInfo(cache).dep(rv2);
      }
    }
    return value;
  };
  rv2.onNextChange = function(listener) {
    listeners2.add(listener);
    return function() {
      listeners2.delete(listener);
    };
  };
  var attach = rv2.attachCache = function(cache) {
    caches2.add(cache);
    getCacheInfo(cache).vars.add(rv2);
    return rv2;
  };
  rv2.forgetCache = function(cache) {
    return caches2.delete(cache);
  };
  return rv2;
}
function broadcast(cache) {
  if (cache.broadcastWatches) {
    cache.broadcastWatches();
  }
}
var specifierInfoCache = /* @__PURE__ */ Object.create(null);
function lookupSpecifierInfo(spec) {
  var cacheKey = JSON.stringify(spec);
  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = /* @__PURE__ */ Object.create(null));
}
function keyFieldsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyFieldsFn || (info.keyFieldsFn = function(object2, context) {
    var extract = function(from2, key2) {
      return context.readField(key2, from2);
    };
    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
      var extracted = extractKeyPath(context.storeObject, schemaKeyPath, extract);
      if (extracted === void 0 && object2 !== context.storeObject && hasOwn.call(object2, schemaKeyPath[0])) {
        extracted = extractKeyPath(object2, schemaKeyPath, extractKey);
      }
      __DEV__ ? invariant$1(extracted !== void 0, "Missing field '".concat(schemaKeyPath.join("."), "' while extracting keyFields from ").concat(JSON.stringify(object2))) : invariant$1(extracted !== void 0, 2);
      return extracted;
    });
    return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
  });
}
function keyArgsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyArgsFn || (info.keyArgsFn = function(args, _a2) {
    var field = _a2.field, variables = _a2.variables, fieldName = _a2.fieldName;
    var collected = collectSpecifierPaths(specifier, function(keyPath) {
      var firstKey = keyPath[0];
      var firstChar = firstKey.charAt(0);
      if (firstChar === "@") {
        if (field && isNonEmptyArray(field.directives)) {
          var directiveName_1 = firstKey.slice(1);
          var d3 = field.directives.find(function(d4) {
            return d4.name.value === directiveName_1;
          });
          var directiveArgs = d3 && argumentsObjectFromField(d3, variables);
          return directiveArgs && extractKeyPath(directiveArgs, keyPath.slice(1));
        }
        return;
      }
      if (firstChar === "$") {
        var variableName = firstKey.slice(1);
        if (variables && hasOwn.call(variables, variableName)) {
          var varKeyPath = keyPath.slice(0);
          varKeyPath[0] = variableName;
          return extractKeyPath(variables, varKeyPath);
        }
        return;
      }
      if (args) {
        return extractKeyPath(args, keyPath);
      }
    });
    var suffix = JSON.stringify(collected);
    if (args || suffix !== "{}") {
      fieldName += ":" + suffix;
    }
    return fieldName;
  });
}
function collectSpecifierPaths(specifier, extractor) {
  var merger = new DeepMerger();
  return getSpecifierPaths(specifier).reduce(function(collected, path) {
    var _a2;
    var toMerge = extractor(path);
    if (toMerge !== void 0) {
      for (var i3 = path.length - 1; i3 >= 0; --i3) {
        toMerge = (_a2 = {}, _a2[path[i3]] = toMerge, _a2);
      }
      collected = merger.merge(collected, toMerge);
    }
    return collected;
  }, /* @__PURE__ */ Object.create(null));
}
function getSpecifierPaths(spec) {
  var info = lookupSpecifierInfo(spec);
  if (!info.paths) {
    var paths_1 = info.paths = [];
    var currentPath_1 = [];
    spec.forEach(function(s3, i3) {
      if (isArray(s3)) {
        getSpecifierPaths(s3).forEach(function(p3) {
          return paths_1.push(currentPath_1.concat(p3));
        });
        currentPath_1.length = 0;
      } else {
        currentPath_1.push(s3);
        if (!isArray(spec[i3 + 1])) {
          paths_1.push(currentPath_1.slice(0));
          currentPath_1.length = 0;
        }
      }
    });
  }
  return info.paths;
}
function extractKey(object2, key2) {
  return object2[key2];
}
function extractKeyPath(object2, path, extract) {
  extract = extract || extractKey;
  return normalize(path.reduce(function reducer(obj, key2) {
    return isArray(obj) ? obj.map(function(child) {
      return reducer(child, key2);
    }) : obj && extract(obj, key2);
  }, object2));
}
function normalize(value) {
  if (isNonNullObject(value)) {
    if (isArray(value)) {
      return value.map(normalize);
    }
    return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
      return extractKeyPath(value, path);
    });
  }
  return value;
}
getStoreKeyName.setStringify(canonicalStringify);
function argsFromFieldSpecifier(spec) {
  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
}
var nullKeyFieldsFn = function() {
  return void 0;
};
var simpleKeyArgsFn = function(_args, context) {
  return context.fieldName;
};
var mergeTrueFn = function(existing, incoming, _a2) {
  var mergeObjects = _a2.mergeObjects;
  return mergeObjects(existing, incoming);
};
var mergeFalseFn = function(_3, incoming) {
  return incoming;
};
var Policies = function() {
  function Policies2(config2) {
    this.config = config2;
    this.typePolicies = /* @__PURE__ */ Object.create(null);
    this.toBeAdded = /* @__PURE__ */ Object.create(null);
    this.supertypeMap = /* @__PURE__ */ new Map();
    this.fuzzySubtypes = /* @__PURE__ */ new Map();
    this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
    this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
    this.usingPossibleTypes = false;
    this.config = __assign$1({ dataIdFromObject: defaultDataIdFromObject }, config2);
    this.cache = this.config.cache;
    this.setRootTypename("Query");
    this.setRootTypename("Mutation");
    this.setRootTypename("Subscription");
    if (config2.possibleTypes) {
      this.addPossibleTypes(config2.possibleTypes);
    }
    if (config2.typePolicies) {
      this.addTypePolicies(config2.typePolicies);
    }
  }
  Policies2.prototype.identify = function(object2, partialContext) {
    var _a2;
    var policies = this;
    var typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) === null || _a2 === void 0 ? void 0 : _a2.__typename)) || object2.__typename;
    if (typename === this.rootTypenamesById.ROOT_QUERY) {
      return ["ROOT_QUERY"];
    }
    var storeObject = partialContext && partialContext.storeObject || object2;
    var context = __assign$1(__assign$1({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
      var options = normalizeReadFieldOptions(arguments, storeObject);
      return policies.readField(options, {
        store: policies.cache["data"],
        variables: options.variables
      });
    } });
    var id2;
    var policy = typename && this.getTypePolicy(typename);
    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
    while (keyFn) {
      var specifierOrId = keyFn(object2, context);
      if (isArray(specifierOrId)) {
        keyFn = keyFieldsFnFromSpecifier(specifierOrId);
      } else {
        id2 = specifierOrId;
        break;
      }
    }
    id2 = id2 ? String(id2) : void 0;
    return context.keyObject ? [id2, context.keyObject] : [id2];
  };
  Policies2.prototype.addTypePolicies = function(typePolicies) {
    var _this = this;
    Object.keys(typePolicies).forEach(function(typename) {
      var _a2 = typePolicies[typename], queryType = _a2.queryType, mutationType = _a2.mutationType, subscriptionType = _a2.subscriptionType, incoming = __rest$1(_a2, ["queryType", "mutationType", "subscriptionType"]);
      if (queryType)
        _this.setRootTypename("Query", typename);
      if (mutationType)
        _this.setRootTypename("Mutation", typename);
      if (subscriptionType)
        _this.setRootTypename("Subscription", typename);
      if (hasOwn.call(_this.toBeAdded, typename)) {
        _this.toBeAdded[typename].push(incoming);
      } else {
        _this.toBeAdded[typename] = [incoming];
      }
    });
  };
  Policies2.prototype.updateTypePolicy = function(typename, incoming) {
    var _this = this;
    var existing = this.getTypePolicy(typename);
    var keyFields = incoming.keyFields, fields = incoming.fields;
    function setMerge(existing2, merge3) {
      existing2.merge = typeof merge3 === "function" ? merge3 : merge3 === true ? mergeTrueFn : merge3 === false ? mergeFalseFn : existing2.merge;
    }
    setMerge(existing, incoming.merge);
    existing.keyFn = keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
    if (fields) {
      Object.keys(fields).forEach(function(fieldName) {
        var existing2 = _this.getFieldPolicy(typename, fieldName, true);
        var incoming2 = fields[fieldName];
        if (typeof incoming2 === "function") {
          existing2.read = incoming2;
        } else {
          var keyArgs = incoming2.keyArgs, read2 = incoming2.read, merge3 = incoming2.merge;
          existing2.keyFn = keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
          if (typeof read2 === "function") {
            existing2.read = read2;
          }
          setMerge(existing2, merge3);
        }
        if (existing2.read && existing2.merge) {
          existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
        }
      });
    }
  };
  Policies2.prototype.setRootTypename = function(which, typename) {
    if (typename === void 0) {
      typename = which;
    }
    var rootId = "ROOT_" + which.toUpperCase();
    var old = this.rootTypenamesById[rootId];
    if (typename !== old) {
      __DEV__ ? invariant$1(!old || old === which, "Cannot change root ".concat(which, " __typename more than once")) : invariant$1(!old || old === which, 3);
      if (old)
        delete this.rootIdsByTypename[old];
      this.rootIdsByTypename[typename] = rootId;
      this.rootTypenamesById[rootId] = typename;
    }
  };
  Policies2.prototype.addPossibleTypes = function(possibleTypes) {
    var _this = this;
    this.usingPossibleTypes = true;
    Object.keys(possibleTypes).forEach(function(supertype) {
      _this.getSupertypeSet(supertype, true);
      possibleTypes[supertype].forEach(function(subtype) {
        _this.getSupertypeSet(subtype, true).add(supertype);
        var match = subtype.match(TypeOrFieldNameRegExp);
        if (!match || match[0] !== subtype) {
          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
        }
      });
    });
  };
  Policies2.prototype.getTypePolicy = function(typename) {
    var _this = this;
    if (!hasOwn.call(this.typePolicies, typename)) {
      var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
      policy_1.fields = /* @__PURE__ */ Object.create(null);
      var supertypes = this.supertypeMap.get(typename);
      if (supertypes && supertypes.size) {
        supertypes.forEach(function(supertype) {
          var _a2 = _this.getTypePolicy(supertype), fields = _a2.fields, rest = __rest$1(_a2, ["fields"]);
          Object.assign(policy_1, rest);
          Object.assign(policy_1.fields, fields);
        });
      }
    }
    var inbox = this.toBeAdded[typename];
    if (inbox && inbox.length) {
      inbox.splice(0).forEach(function(policy) {
        _this.updateTypePolicy(typename, policy);
      });
    }
    return this.typePolicies[typename];
  };
  Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
    if (typename) {
      var fieldPolicies = this.getTypePolicy(typename).fields;
      return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
    }
  };
  Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
    var supertypeSet = this.supertypeMap.get(subtype);
    if (!supertypeSet && createIfMissing) {
      this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
    }
    return supertypeSet;
  };
  Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {
    var _this = this;
    if (!fragment.typeCondition)
      return true;
    if (!typename)
      return false;
    var supertype = fragment.typeCondition.name.value;
    if (typename === supertype)
      return true;
    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
      var typenameSupertypeSet = this.getSupertypeSet(typename, true);
      var workQueue_1 = [typenameSupertypeSet];
      var maybeEnqueue_1 = function(subtype) {
        var supertypeSet2 = _this.getSupertypeSet(subtype, false);
        if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
          workQueue_1.push(supertypeSet2);
        }
      };
      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
      var checkingFuzzySubtypes = false;
      for (var i3 = 0; i3 < workQueue_1.length; ++i3) {
        var supertypeSet = workQueue_1[i3];
        if (supertypeSet.has(supertype)) {
          if (!typenameSupertypeSet.has(supertype)) {
            if (checkingFuzzySubtypes) {
              __DEV__ && invariant$1.warn("Inferring subtype ".concat(typename, " of supertype ").concat(supertype));
            }
            typenameSupertypeSet.add(supertype);
          }
          return true;
        }
        supertypeSet.forEach(maybeEnqueue_1);
        if (needToCheckFuzzySubtypes && i3 === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
          needToCheckFuzzySubtypes = false;
          checkingFuzzySubtypes = true;
          this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
            var match = typename.match(regExp);
            if (match && match[0] === typename) {
              maybeEnqueue_1(fuzzyString);
            }
          });
        }
      }
    }
    return false;
  };
  Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
    var policy = this.getFieldPolicy(typename, fieldName, false);
    return !!(policy && policy.keyFn);
  };
  Policies2.prototype.getStoreFieldName = function(fieldSpec) {
    var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
    var policy = this.getFieldPolicy(typename, fieldName, false);
    var storeFieldName;
    var keyFn = policy && policy.keyFn;
    if (keyFn && typename) {
      var context = {
        typename,
        fieldName,
        field: fieldSpec.field || null,
        variables: fieldSpec.variables
      };
      var args = argsFromFieldSpecifier(fieldSpec);
      while (keyFn) {
        var specifierOrString = keyFn(args, context);
        if (isArray(specifierOrString)) {
          keyFn = keyArgsFnFromSpecifier(specifierOrString);
        } else {
          storeFieldName = specifierOrString || fieldName;
          break;
        }
      }
    }
    if (storeFieldName === void 0) {
      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
    }
    if (storeFieldName === false) {
      return fieldName;
    }
    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
  };
  Policies2.prototype.readField = function(options, context) {
    var objectOrReference = options.from;
    if (!objectOrReference)
      return;
    var nameOrField = options.field || options.fieldName;
    if (!nameOrField)
      return;
    if (options.typename === void 0) {
      var typename = context.store.getFieldValue(objectOrReference, "__typename");
      if (typename)
        options.typename = typename;
    }
    var storeFieldName = this.getStoreFieldName(options);
    var fieldName = fieldNameFromStoreName(storeFieldName);
    var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
    var policy = this.getFieldPolicy(options.typename, fieldName, false);
    var read2 = policy && policy.read;
    if (read2) {
      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
      return cacheSlot.withValue(this.cache, read2, [existing, readOptions]);
    }
    return existing;
  };
  Policies2.prototype.getReadFunction = function(typename, fieldName) {
    var policy = this.getFieldPolicy(typename, fieldName, false);
    return policy && policy.read;
  };
  Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
    var policy = this.getFieldPolicy(parentTypename, fieldName, false);
    var merge3 = policy && policy.merge;
    if (!merge3 && childTypename) {
      policy = this.getTypePolicy(childTypename);
      merge3 = policy && policy.merge;
    }
    return merge3;
  };
  Policies2.prototype.runMergeFunction = function(existing, incoming, _a2, context, storage) {
    var field = _a2.field, typename = _a2.typename, merge3 = _a2.merge;
    if (merge3 === mergeTrueFn) {
      return makeMergeObjectsFunction(context.store)(existing, incoming);
    }
    if (merge3 === mergeFalseFn) {
      return incoming;
    }
    if (context.overwrite) {
      existing = void 0;
    }
    return merge3(existing, incoming, makeFieldFunctionOptions(this, void 0, { typename, fieldName: field.name.value, field, variables: context.variables }, context, storage || /* @__PURE__ */ Object.create(null)));
  };
  return Policies2;
}();
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
  var storeFieldName = policies.getStoreFieldName(fieldSpec);
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var variables = fieldSpec.variables || context.variables;
  var _a2 = context.store, toReference = _a2.toReference, canRead = _a2.canRead;
  return {
    args: argsFromFieldSpecifier(fieldSpec),
    field: fieldSpec.field || null,
    fieldName,
    storeFieldName,
    variables,
    isReference,
    toReference,
    storage,
    cache: policies.cache,
    canRead,
    readField: function() {
      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);
    },
    mergeObjects: makeMergeObjectsFunction(context.store)
  };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
  var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
  var options;
  if (typeof fieldNameOrOptions === "string") {
    options = {
      fieldName: fieldNameOrOptions,
      from: argc > 1 ? from2 : objectOrReference
    };
  } else {
    options = __assign$1({}, fieldNameOrOptions);
    if (!hasOwn.call(options, "from")) {
      options.from = objectOrReference;
    }
  }
  if (__DEV__ && options.from === void 0) {
    __DEV__ && invariant$1.warn("Undefined 'from' passed to readField with arguments ".concat(stringifyForDisplay(Array.from(readFieldArgs))));
  }
  if (void 0 === options.variables) {
    options.variables = variables;
  }
  return options;
}
function makeMergeObjectsFunction(store) {
  return function mergeObjects(existing, incoming) {
    if (isArray(existing) || isArray(incoming)) {
      throw __DEV__ ? new InvariantError("Cannot automatically merge arrays") : new InvariantError(4);
    }
    if (isNonNullObject(existing) && isNonNullObject(incoming)) {
      var eType = store.getFieldValue(existing, "__typename");
      var iType = store.getFieldValue(incoming, "__typename");
      var typesDiffer = eType && iType && eType !== iType;
      if (typesDiffer) {
        return incoming;
      }
      if (isReference(existing) && storeValueIsStoreObject(incoming)) {
        store.merge(existing.__ref, incoming);
        return existing;
      }
      if (storeValueIsStoreObject(existing) && isReference(incoming)) {
        store.merge(existing, incoming.__ref);
        return incoming;
      }
      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
        return __assign$1(__assign$1({}, existing), incoming);
      }
    }
    return incoming;
  };
}
function getContextFlavor(context, clientOnly, deferred) {
  var key2 = "".concat(clientOnly).concat(deferred);
  var flavored = context.flavors.get(key2);
  if (!flavored) {
    context.flavors.set(key2, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign$1(__assign$1({}, context), { clientOnly, deferred }));
  }
  return flavored;
}
var StoreWriter = function() {
  function StoreWriter2(cache, reader2) {
    this.cache = cache;
    this.reader = reader2;
  }
  StoreWriter2.prototype.writeToStore = function(store, _a2) {
    var _this = this;
    var query2 = _a2.query, result = _a2.result, dataId = _a2.dataId, variables = _a2.variables, overwrite = _a2.overwrite;
    var operationDefinition = getOperationDefinition(query2);
    var merger = makeProcessedFieldsMerger();
    variables = __assign$1(__assign$1({}, getDefaultValues(operationDefinition)), variables);
    var context = {
      store,
      written: /* @__PURE__ */ Object.create(null),
      merge: function(existing, incoming) {
        return merger.merge(existing, incoming);
      },
      variables,
      varString: canonicalStringify(variables),
      fragmentMap: createFragmentMap(getFragmentDefinitions(query2)),
      overwrite: !!overwrite,
      incomingById: /* @__PURE__ */ new Map(),
      clientOnly: false,
      deferred: false,
      flavors: /* @__PURE__ */ new Map()
    };
    var ref2 = this.processSelectionSet({
      result: result || /* @__PURE__ */ Object.create(null),
      dataId,
      selectionSet: operationDefinition.selectionSet,
      mergeTree: { map: /* @__PURE__ */ new Map() },
      context
    });
    if (!isReference(ref2)) {
      throw __DEV__ ? new InvariantError("Could not identify object ".concat(JSON.stringify(result))) : new InvariantError(6);
    }
    context.incomingById.forEach(function(_a3, dataId2) {
      var storeObject = _a3.storeObject, mergeTree = _a3.mergeTree, fieldNodeSet = _a3.fieldNodeSet;
      var entityRef = makeReference(dataId2);
      if (mergeTree && mergeTree.map.size) {
        var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
        if (isReference(applied)) {
          return;
        }
        storeObject = applied;
      }
      if (__DEV__ && !context.overwrite) {
        var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
        fieldNodeSet.forEach(function(field) {
          if (field.selectionSet) {
            fieldsWithSelectionSets_1[field.name.value] = true;
          }
        });
        var hasSelectionSet_1 = function(storeFieldName) {
          return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
        };
        var hasMergeFunction_1 = function(storeFieldName) {
          var childTree = mergeTree && mergeTree.map.get(storeFieldName);
          return Boolean(childTree && childTree.info && childTree.info.merge);
        };
        Object.keys(storeObject).forEach(function(storeFieldName) {
          if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
            warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
          }
        });
      }
      store.merge(dataId2, storeObject);
    });
    store.retain(ref2.__ref);
    return ref2;
  };
  StoreWriter2.prototype.processSelectionSet = function(_a2) {
    var _this = this;
    var dataId = _a2.dataId, result = _a2.result, selectionSet = _a2.selectionSet, context = _a2.context, mergeTree = _a2.mergeTree;
    var policies = this.cache.policies;
    var incoming = /* @__PURE__ */ Object.create(null);
    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, "__typename");
    if ("string" === typeof typename) {
      incoming.__typename = typename;
    }
    var readField = function() {
      var options = normalizeReadFieldOptions(arguments, incoming, context.variables);
      if (isReference(options.from)) {
        var info = context.incomingById.get(options.from.__ref);
        if (info) {
          var result_1 = policies.readField(__assign$1(__assign$1({}, options), { from: info.storeObject }), context);
          if (result_1 !== void 0) {
            return result_1;
          }
        }
      }
      return policies.readField(options, context);
    };
    var fieldNodeSet = /* @__PURE__ */ new Set();
    this.flattenFields(selectionSet, result, context, typename).forEach(function(context2, field) {
      var _a3;
      var resultFieldKey = resultKeyNameFromField(field);
      var value = result[resultFieldKey];
      fieldNodeSet.add(field);
      if (value !== void 0) {
        var storeFieldName = policies.getStoreFieldName({
          typename,
          fieldName: field.name.value,
          field,
          variables: context2.variables
        });
        var childTree = getChildMergeTree(mergeTree, storeFieldName);
        var incomingValue = _this.processFieldValue(value, field, field.selectionSet ? getContextFlavor(context2, false, false) : context2, childTree);
        var childTypename = void 0;
        if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
          childTypename = readField("__typename", incomingValue);
        }
        var merge3 = policies.getMergeFunction(typename, field.name.value, childTypename);
        if (merge3) {
          childTree.info = {
            field,
            typename,
            merge: merge3
          };
        } else {
          maybeRecycleChildMergeTree(mergeTree, storeFieldName);
        }
        incoming = context2.merge(incoming, (_a3 = {}, _a3[storeFieldName] = incomingValue, _a3));
      } else if (__DEV__ && !context2.clientOnly && !context2.deferred && !addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {
        __DEV__ && invariant$1.error("Missing field '".concat(resultKeyNameFromField(field), "' while writing result ").concat(JSON.stringify(result, null, 2)).substring(0, 1e3));
      }
    });
    try {
      var _b = policies.identify(result, {
        typename,
        selectionSet,
        fragmentMap: context.fragmentMap,
        storeObject: incoming,
        readField
      }), id2 = _b[0], keyObject = _b[1];
      dataId = dataId || id2;
      if (keyObject) {
        incoming = context.merge(incoming, keyObject);
      }
    } catch (e2) {
      if (!dataId)
        throw e2;
    }
    if ("string" === typeof dataId) {
      var dataRef = makeReference(dataId);
      var sets = context.written[dataId] || (context.written[dataId] = []);
      if (sets.indexOf(selectionSet) >= 0)
        return dataRef;
      sets.push(selectionSet);
      if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {
        return dataRef;
      }
      var previous_1 = context.incomingById.get(dataId);
      if (previous_1) {
        previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
        previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
        fieldNodeSet.forEach(function(field) {
          return previous_1.fieldNodeSet.add(field);
        });
      } else {
        context.incomingById.set(dataId, {
          storeObject: incoming,
          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
          fieldNodeSet
        });
      }
      return dataRef;
    }
    return incoming;
  };
  StoreWriter2.prototype.processFieldValue = function(value, field, context, mergeTree) {
    var _this = this;
    if (!field.selectionSet || value === null) {
      return __DEV__ ? cloneDeep(value) : value;
    }
    if (isArray(value)) {
      return value.map(function(item, i3) {
        var value2 = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i3));
        maybeRecycleChildMergeTree(mergeTree, i3);
        return value2;
      });
    }
    return this.processSelectionSet({
      result: value,
      selectionSet: field.selectionSet,
      context,
      mergeTree
    });
  };
  StoreWriter2.prototype.flattenFields = function(selectionSet, result, context, typename) {
    if (typename === void 0) {
      typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);
    }
    var fieldMap = /* @__PURE__ */ new Map();
    var policies = this.cache.policies;
    var limitingTrie = new Trie(false);
    (function flatten(selectionSet2, inheritedContext) {
      var visitedNode = limitingTrie.lookup(selectionSet2, inheritedContext.clientOnly, inheritedContext.deferred);
      if (visitedNode.visited)
        return;
      visitedNode.visited = true;
      selectionSet2.selections.forEach(function(selection) {
        if (!shouldInclude(selection, context.variables))
          return;
        var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
        if (!(clientOnly && deferred) && isNonEmptyArray(selection.directives)) {
          selection.directives.forEach(function(dir) {
            var name2 = dir.name.value;
            if (name2 === "client")
              clientOnly = true;
            if (name2 === "defer") {
              var args = argumentsObjectFromField(dir, context.variables);
              if (!args || args.if !== false) {
                deferred = true;
              }
            }
          });
        }
        if (isField(selection)) {
          var existing = fieldMap.get(selection);
          if (existing) {
            clientOnly = clientOnly && existing.clientOnly;
            deferred = deferred && existing.deferred;
          }
          fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
        } else {
          var fragment = getFragmentFromSelection(selection, context.fragmentMap);
          if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {
            flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
          }
        }
      });
    })(selectionSet, context);
    return fieldMap;
  };
  StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {
    var _a2;
    var _this = this;
    if (mergeTree.map.size && !isReference(incoming)) {
      var e_1 = !isArray(incoming) && (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;
      var i_1 = incoming;
      if (e_1 && !getStorageArgs) {
        getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
      }
      var changedFields_1;
      var getValue_1 = function(from2, name2) {
        return isArray(from2) ? typeof name2 === "number" ? from2[name2] : void 0 : context.store.getFieldValue(from2, String(name2));
      };
      mergeTree.map.forEach(function(childTree, storeFieldName) {
        var eVal = getValue_1(e_1, storeFieldName);
        var iVal = getValue_1(i_1, storeFieldName);
        if (void 0 === iVal)
          return;
        if (getStorageArgs) {
          getStorageArgs.push(storeFieldName);
        }
        var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
        if (aVal !== iVal) {
          changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
          changedFields_1.set(storeFieldName, aVal);
        }
        if (getStorageArgs) {
          invariant$1(getStorageArgs.pop() === storeFieldName);
        }
      });
      if (changedFields_1) {
        incoming = isArray(i_1) ? i_1.slice(0) : __assign$1({}, i_1);
        changedFields_1.forEach(function(value, name2) {
          incoming[name2] = value;
        });
      }
    }
    if (mergeTree.info) {
      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a2 = context.store).getStorage.apply(_a2, getStorageArgs));
    }
    return incoming;
  };
  return StoreWriter2;
}();
var emptyMergeTreePool = [];
function getChildMergeTree(_a2, name2) {
  var map2 = _a2.map;
  if (!map2.has(name2)) {
    map2.set(name2, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
  }
  return map2.get(name2);
}
function mergeMergeTrees(left, right) {
  if (left === right || !right || mergeTreeIsEmpty(right))
    return left;
  if (!left || mergeTreeIsEmpty(left))
    return right;
  var info = left.info && right.info ? __assign$1(__assign$1({}, left.info), right.info) : left.info || right.info;
  var needToMergeMaps = left.map.size && right.map.size;
  var map2 = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
  var merged = { info, map: map2 };
  if (needToMergeMaps) {
    var remainingRightKeys_1 = new Set(right.map.keys());
    left.map.forEach(function(leftTree, key2) {
      merged.map.set(key2, mergeMergeTrees(leftTree, right.map.get(key2)));
      remainingRightKeys_1.delete(key2);
    });
    remainingRightKeys_1.forEach(function(key2) {
      merged.map.set(key2, mergeMergeTrees(right.map.get(key2), left.map.get(key2)));
    });
  }
  return merged;
}
function mergeTreeIsEmpty(tree2) {
  return !tree2 || !(tree2.info || tree2.map.size);
}
function maybeRecycleChildMergeTree(_a2, name2) {
  var map2 = _a2.map;
  var childTree = map2.get(name2);
  if (childTree && mergeTreeIsEmpty(childTree)) {
    emptyMergeTreePool.push(childTree);
    map2.delete(name2);
  }
}
var warnings = /* @__PURE__ */ new Set();
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
  var getChild = function(objOrRef) {
    var child = store.getFieldValue(objOrRef, storeFieldName);
    return typeof child === "object" && child;
  };
  var existing = getChild(existingRef);
  if (!existing)
    return;
  var incoming = getChild(incomingObj);
  if (!incoming)
    return;
  if (isReference(existing))
    return;
  if (equal(existing, incoming))
    return;
  if (Object.keys(existing).every(function(key2) {
    return store.getFieldValue(incoming, key2) !== void 0;
  })) {
    return;
  }
  var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var typeDotName = "".concat(parentType, ".").concat(fieldName);
  if (warnings.has(typeDotName))
    return;
  warnings.add(typeDotName);
  var childTypenames = [];
  if (!isArray(existing) && !isArray(incoming)) {
    [existing, incoming].forEach(function(child) {
      var typename = store.getFieldValue(child, "__typename");
      if (typeof typename === "string" && !childTypenames.includes(typename)) {
        childTypenames.push(typename);
      }
    });
  }
  __DEV__ && invariant$1.warn("Cache data may be lost when replacing the ".concat(fieldName, " field of a ").concat(parentType, " object.\n\nTo address this problem (which is not a bug in Apollo Client), ").concat(childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", "define a custom merge function for the ").concat(typeDotName, " field, so InMemoryCache can safely merge these objects:\n\n  existing: ").concat(JSON.stringify(existing).slice(0, 1e3), "\n  incoming: ").concat(JSON.stringify(incoming).slice(0, 1e3), "\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n"));
}
var InMemoryCache = function(_super) {
  __extends(InMemoryCache2, _super);
  function InMemoryCache2(config2) {
    if (config2 === void 0) {
      config2 = {};
    }
    var _this = _super.call(this) || this;
    _this.watches = /* @__PURE__ */ new Set();
    _this.typenameDocumentCache = /* @__PURE__ */ new Map();
    _this.makeVar = makeVar;
    _this.txCount = 0;
    _this.config = normalizeConfig(config2);
    _this.addTypename = !!_this.config.addTypename;
    _this.policies = new Policies({
      cache: _this,
      dataIdFromObject: _this.config.dataIdFromObject,
      possibleTypes: _this.config.possibleTypes,
      typePolicies: _this.config.typePolicies
    });
    _this.init();
    return _this;
  }
  InMemoryCache2.prototype.init = function() {
    var rootStore = this.data = new EntityStore.Root({
      policies: this.policies,
      resultCaching: this.config.resultCaching
    });
    this.optimisticData = rootStore.stump;
    this.resetResultCache();
  };
  InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
    var _this = this;
    var previousReader = this.storeReader;
    this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
      cache: this,
      addTypename: this.addTypename,
      resultCacheMaxSize: this.config.resultCacheMaxSize,
      canonizeResults: shouldCanonizeResults(this.config),
      canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon
    }));
    this.maybeBroadcastWatch = wrap(function(c2, options) {
      return _this.broadcastWatch(c2, options);
    }, {
      max: this.config.resultCacheMaxSize,
      makeCacheKey: function(c2) {
        var store = c2.optimistic ? _this.optimisticData : _this.data;
        if (supportsResultCaching(store)) {
          var optimistic = c2.optimistic, rootId = c2.rootId, variables = c2.variables;
          return store.makeCacheKey(c2.query, c2.callback, canonicalStringify({ optimistic, rootId, variables }));
        }
      }
    });
    (/* @__PURE__ */ new Set([
      this.data.group,
      this.optimisticData.group
    ])).forEach(function(group) {
      return group.resetCaching();
    });
  };
  InMemoryCache2.prototype.restore = function(data2) {
    this.init();
    if (data2)
      this.data.replace(data2);
    return this;
  };
  InMemoryCache2.prototype.extract = function(optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return (optimistic ? this.optimisticData : this.data).extract();
  };
  InMemoryCache2.prototype.read = function(options) {
    var _a2 = options.returnPartialData, returnPartialData = _a2 === void 0 ? false : _a2;
    try {
      return this.storeReader.diffQueryAgainstStore(__assign$1(__assign$1({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
    } catch (e2) {
      if (e2 instanceof MissingFieldError) {
        return null;
      }
      throw e2;
    }
  };
  InMemoryCache2.prototype.write = function(options) {
    try {
      ++this.txCount;
      return this.storeWriter.writeToStore(this.data, options);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.modify = function(options) {
    if (hasOwn.call(options, "id") && !options.id) {
      return false;
    }
    var store = options.optimistic ? this.optimisticData : this.data;
    try {
      ++this.txCount;
      return store.modify(options.id || "ROOT_QUERY", options.fields);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.diff = function(options) {
    return this.storeReader.diffQueryAgainstStore(__assign$1(__assign$1({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
  };
  InMemoryCache2.prototype.watch = function(watch2) {
    var _this = this;
    if (!this.watches.size) {
      recallCache(this);
    }
    this.watches.add(watch2);
    if (watch2.immediate) {
      this.maybeBroadcastWatch(watch2);
    }
    return function() {
      if (_this.watches.delete(watch2) && !_this.watches.size) {
        forgetCache(_this);
      }
      _this.maybeBroadcastWatch.forget(watch2);
    };
  };
  InMemoryCache2.prototype.gc = function(options) {
    canonicalStringify.reset();
    var ids = this.optimisticData.gc();
    if (options && !this.txCount) {
      if (options.resetResultCache) {
        this.resetResultCache(options.resetResultIdentities);
      } else if (options.resetResultIdentities) {
        this.storeReader.resetCanon();
      }
    }
    return ids;
  };
  InMemoryCache2.prototype.retain = function(rootId, optimistic) {
    return (optimistic ? this.optimisticData : this.data).retain(rootId);
  };
  InMemoryCache2.prototype.release = function(rootId, optimistic) {
    return (optimistic ? this.optimisticData : this.data).release(rootId);
  };
  InMemoryCache2.prototype.identify = function(object2) {
    if (isReference(object2))
      return object2.__ref;
    try {
      return this.policies.identify(object2)[0];
    } catch (e2) {
      __DEV__ && invariant$1.warn(e2);
    }
  };
  InMemoryCache2.prototype.evict = function(options) {
    if (!options.id) {
      if (hasOwn.call(options, "id")) {
        return false;
      }
      options = __assign$1(__assign$1({}, options), { id: "ROOT_QUERY" });
    }
    try {
      ++this.txCount;
      return this.optimisticData.evict(options, this.data);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.reset = function(options) {
    var _this = this;
    this.init();
    canonicalStringify.reset();
    if (options && options.discardWatches) {
      this.watches.forEach(function(watch2) {
        return _this.maybeBroadcastWatch.forget(watch2);
      });
      this.watches.clear();
      forgetCache(this);
    } else {
      this.broadcastWatches();
    }
    return Promise.resolve();
  };
  InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
    var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
    if (newOptimisticData !== this.optimisticData) {
      this.optimisticData = newOptimisticData;
      this.broadcastWatches();
    }
  };
  InMemoryCache2.prototype.batch = function(options) {
    var _this = this;
    var update5 = options.update, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
    var updateResult;
    var perform = function(layer) {
      var _a3 = _this, data2 = _a3.data, optimisticData = _a3.optimisticData;
      ++_this.txCount;
      if (layer) {
        _this.data = _this.optimisticData = layer;
      }
      try {
        return updateResult = update5(_this);
      } finally {
        --_this.txCount;
        _this.data = data2;
        _this.optimisticData = optimisticData;
      }
    };
    var alreadyDirty = /* @__PURE__ */ new Set();
    if (onWatchUpdated && !this.txCount) {
      this.broadcastWatches(__assign$1(__assign$1({}, options), { onWatchUpdated: function(watch2) {
        alreadyDirty.add(watch2);
        return false;
      } }));
    }
    if (typeof optimistic === "string") {
      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
    } else if (optimistic === false) {
      perform(this.data);
    } else {
      perform();
    }
    if (typeof removeOptimistic === "string") {
      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
    }
    if (onWatchUpdated && alreadyDirty.size) {
      this.broadcastWatches(__assign$1(__assign$1({}, options), { onWatchUpdated: function(watch2, diff2) {
        var result = onWatchUpdated.call(this, watch2, diff2);
        if (result !== false) {
          alreadyDirty.delete(watch2);
        }
        return result;
      } }));
      if (alreadyDirty.size) {
        alreadyDirty.forEach(function(watch2) {
          return _this.maybeBroadcastWatch.dirty(watch2);
        });
      }
    } else {
      this.broadcastWatches(options);
    }
    return updateResult;
  };
  InMemoryCache2.prototype.performTransaction = function(update5, optimisticId) {
    return this.batch({
      update: update5,
      optimistic: optimisticId || optimisticId !== null
    });
  };
  InMemoryCache2.prototype.transformDocument = function(document2) {
    if (this.addTypename) {
      var result = this.typenameDocumentCache.get(document2);
      if (!result) {
        result = addTypenameToDocument(document2);
        this.typenameDocumentCache.set(document2, result);
        this.typenameDocumentCache.set(result, result);
      }
      return result;
    }
    return document2;
  };
  InMemoryCache2.prototype.broadcastWatches = function(options) {
    var _this = this;
    if (!this.txCount) {
      this.watches.forEach(function(c2) {
        return _this.maybeBroadcastWatch(c2, options);
      });
    }
  };
  InMemoryCache2.prototype.broadcastWatch = function(c2, options) {
    var lastDiff = c2.lastDiff;
    var diff2 = this.diff(c2);
    if (options) {
      if (c2.optimistic && typeof options.optimistic === "string") {
        diff2.fromOptimisticTransaction = true;
      }
      if (options.onWatchUpdated && options.onWatchUpdated.call(this, c2, diff2, lastDiff) === false) {
        return;
      }
    }
    if (!lastDiff || !equal(lastDiff.result, diff2.result)) {
      c2.callback(c2.lastDiff = diff2, lastDiff);
    }
  };
  return InMemoryCache2;
}(ApolloCache);
function isApolloError(err) {
  return err.hasOwnProperty("graphQLErrors");
}
var generateErrorMessage = function(err) {
  var message = "";
  if (isNonEmptyArray(err.graphQLErrors) || isNonEmptyArray(err.clientErrors)) {
    var errors2 = (err.graphQLErrors || []).concat(err.clientErrors || []);
    errors2.forEach(function(error) {
      var errorMessage = error ? error.message : "Error message not found.";
      message += "".concat(errorMessage, "\n");
    });
  }
  if (err.networkError) {
    message += "".concat(err.networkError.message, "\n");
  }
  message = message.replace(/\n$/, "");
  return message;
};
var ApolloError = function(_super) {
  __extends(ApolloError2, _super);
  function ApolloError2(_a2) {
    var graphQLErrors = _a2.graphQLErrors, clientErrors = _a2.clientErrors, networkError = _a2.networkError, errorMessage = _a2.errorMessage, extraInfo = _a2.extraInfo;
    var _this = _super.call(this, errorMessage) || this;
    _this.graphQLErrors = graphQLErrors || [];
    _this.clientErrors = clientErrors || [];
    _this.networkError = networkError || null;
    _this.message = errorMessage || generateErrorMessage(_this);
    _this.extraInfo = extraInfo;
    _this.__proto__ = ApolloError2.prototype;
    return _this;
  }
  return ApolloError2;
}(Error);
var NetworkStatus;
(function(NetworkStatus2) {
  NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
  NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
  NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
  NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
  NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
  NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
  NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
  return networkStatus ? networkStatus < 7 : false;
}
var assign = Object.assign, hasOwnProperty$1 = Object.hasOwnProperty;
var ObservableQuery = function(_super) {
  __extends(ObservableQuery2, _super);
  function ObservableQuery2(_a2) {
    var queryManager = _a2.queryManager, queryInfo = _a2.queryInfo, options = _a2.options;
    var _this = _super.call(this, function(observer) {
      try {
        var subObserver = observer._subscription._observer;
        if (subObserver && !subObserver.error) {
          subObserver.error = defaultSubscriptionObserverErrorCallback;
        }
      } catch (_a3) {
      }
      var first2 = !_this.observers.size;
      _this.observers.add(observer);
      var last2 = _this.last;
      if (last2 && last2.error) {
        observer.error && observer.error(last2.error);
      } else if (last2 && last2.result) {
        observer.next && observer.next(last2.result);
      }
      if (first2) {
        _this.reobserve().catch(function() {
        });
      }
      return function() {
        if (_this.observers.delete(observer) && !_this.observers.size) {
          _this.tearDownQuery();
        }
      };
    }) || this;
    _this.observers = /* @__PURE__ */ new Set();
    _this.subscriptions = /* @__PURE__ */ new Set();
    _this.queryInfo = queryInfo;
    _this.queryManager = queryManager;
    _this.isTornDown = false;
    var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
    var _e2 = options.fetchPolicy, fetchPolicy = _e2 === void 0 ? defaultFetchPolicy : _e2, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
    _this.options = __assign$1(__assign$1({}, options), { initialFetchPolicy, fetchPolicy });
    _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
    var opDef = getOperationDefinition(_this.query);
    _this.queryName = opDef && opDef.name && opDef.name.value;
    return _this;
  }
  Object.defineProperty(ObservableQuery2.prototype, "query", {
    get: function() {
      return this.queryManager.transform(this.options.query).document;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ObservableQuery2.prototype, "variables", {
    get: function() {
      return this.options.variables;
    },
    enumerable: false,
    configurable: true
  });
  ObservableQuery2.prototype.result = function() {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var observer = {
        next: function(result) {
          resolve(result);
          _this.observers.delete(observer);
          if (!_this.observers.size) {
            _this.queryManager.removeQuery(_this.queryId);
          }
          setTimeout(function() {
            subscription.unsubscribe();
          }, 0);
        },
        error: reject
      };
      var subscription = _this.subscribe(observer);
    });
  };
  ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
    if (saveAsLastResult === void 0) {
      saveAsLastResult = true;
    }
    var lastResult = this.getLastResult(true);
    var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
    var result = __assign$1(__assign$1({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
    var _a2 = this.options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2;
    if (fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby" || this.queryManager.transform(this.options.query).hasForcedResolvers)
      ;
    else {
      var diff2 = this.queryInfo.getDiff();
      if (diff2.complete || this.options.returnPartialData) {
        result.data = diff2.result;
      }
      if (equal(result.data, {})) {
        result.data = void 0;
      }
      if (diff2.complete) {
        delete result.partial;
        if (diff2.complete && result.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
          result.networkStatus = NetworkStatus.ready;
          result.loading = false;
        }
      } else {
        result.partial = true;
      }
      if (__DEV__ && !diff2.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
        logMissingFieldErrors(diff2.missing);
      }
    }
    if (saveAsLastResult) {
      this.updateLastResult(result);
    }
    return result;
  };
  ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult) {
    return !this.last || !equal(this.last.result, newResult);
  };
  ObservableQuery2.prototype.getLast = function(key2, variablesMustMatch) {
    var last2 = this.last;
    if (last2 && last2[key2] && (!variablesMustMatch || equal(last2.variables, this.variables))) {
      return last2[key2];
    }
  };
  ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
    return this.getLast("result", variablesMustMatch);
  };
  ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
    return this.getLast("error", variablesMustMatch);
  };
  ObservableQuery2.prototype.resetLastResults = function() {
    delete this.last;
    this.isTornDown = false;
  };
  ObservableQuery2.prototype.resetQueryStoreErrors = function() {
    this.queryManager.resetErrors(this.queryId);
  };
  ObservableQuery2.prototype.refetch = function(variables) {
    var _a2;
    var reobserveOptions = {
      pollInterval: 0
    };
    var fetchPolicy = this.options.fetchPolicy;
    if (fetchPolicy === "cache-and-network") {
      reobserveOptions.fetchPolicy = fetchPolicy;
    } else if (fetchPolicy === "no-cache") {
      reobserveOptions.fetchPolicy = "no-cache";
    } else {
      reobserveOptions.fetchPolicy = "network-only";
    }
    if (__DEV__ && variables && hasOwnProperty$1.call(variables, "variables")) {
      var queryDef = getQueryDefinition(this.query);
      var vars = queryDef.variableDefinitions;
      if (!vars || !vars.some(function(v4) {
        return v4.variable.name.value === "variables";
      })) {
        __DEV__ && invariant$1.warn("Called refetch(".concat(JSON.stringify(variables), ") for query ").concat(((_a2 = queryDef.name) === null || _a2 === void 0 ? void 0 : _a2.value) || JSON.stringify(queryDef), ", which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?"));
      }
    }
    if (variables && !equal(this.options.variables, variables)) {
      reobserveOptions.variables = this.options.variables = __assign$1(__assign$1({}, this.options.variables), variables);
    }
    this.queryInfo.resetLastWrite();
    return this.reobserve(reobserveOptions, NetworkStatus.refetch);
  };
  ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
    var _this = this;
    var combinedOptions = __assign$1(__assign$1({}, fetchMoreOptions.query ? fetchMoreOptions : __assign$1(__assign$1(__assign$1(__assign$1({}, this.options), { query: this.query }), fetchMoreOptions), { variables: __assign$1(__assign$1({}, this.options.variables), fetchMoreOptions.variables) })), { fetchPolicy: "no-cache" });
    var qid = this.queryManager.generateQueryId();
    var queryInfo = this.queryInfo;
    var originalNetworkStatus = queryInfo.networkStatus;
    queryInfo.networkStatus = NetworkStatus.fetchMore;
    if (combinedOptions.notifyOnNetworkStatusChange) {
      this.observe();
    }
    var updatedQuerySet = /* @__PURE__ */ new Set();
    return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
      _this.queryManager.removeQuery(qid);
      if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
        queryInfo.networkStatus = originalNetworkStatus;
      }
      _this.queryManager.cache.batch({
        update: function(cache) {
          var updateQuery = fetchMoreOptions.updateQuery;
          if (updateQuery) {
            cache.updateQuery({
              query: _this.query,
              variables: _this.variables,
              returnPartialData: true,
              optimistic: false
            }, function(previous) {
              return updateQuery(previous, {
                fetchMoreResult: fetchMoreResult.data,
                variables: combinedOptions.variables
              });
            });
          } else {
            cache.writeQuery({
              query: combinedOptions.query,
              variables: combinedOptions.variables,
              data: fetchMoreResult.data
            });
          }
        },
        onWatchUpdated: function(watch2) {
          updatedQuerySet.add(watch2.query);
        }
      });
      return fetchMoreResult;
    }).finally(function() {
      if (!updatedQuerySet.has(_this.query)) {
        reobserveCacheFirst(_this);
      }
    });
  };
  ObservableQuery2.prototype.subscribeToMore = function(options) {
    var _this = this;
    var subscription = this.queryManager.startGraphQLSubscription({
      query: options.document,
      variables: options.variables,
      context: options.context
    }).subscribe({
      next: function(subscriptionData) {
        var updateQuery = options.updateQuery;
        if (updateQuery) {
          _this.updateQuery(function(previous, _a2) {
            var variables = _a2.variables;
            return updateQuery(previous, {
              subscriptionData,
              variables
            });
          });
        }
      },
      error: function(err) {
        if (options.onError) {
          options.onError(err);
          return;
        }
        __DEV__ && invariant$1.error("Unhandled GraphQL subscription error", err);
      }
    });
    this.subscriptions.add(subscription);
    return function() {
      if (_this.subscriptions.delete(subscription)) {
        subscription.unsubscribe();
      }
    };
  };
  ObservableQuery2.prototype.setOptions = function(newOptions) {
    return this.reobserve(newOptions);
  };
  ObservableQuery2.prototype.setVariables = function(variables) {
    if (equal(this.variables, variables)) {
      return this.observers.size ? this.result() : Promise.resolve();
    }
    this.options.variables = variables;
    if (!this.observers.size) {
      return Promise.resolve();
    }
    return this.reobserve({
      fetchPolicy: this.options.initialFetchPolicy,
      variables
    }, NetworkStatus.setVariables);
  };
  ObservableQuery2.prototype.updateQuery = function(mapFn) {
    var queryManager = this.queryManager;
    var result = queryManager.cache.diff({
      query: this.options.query,
      variables: this.variables,
      returnPartialData: true,
      optimistic: false
    }).result;
    var newResult = mapFn(result, {
      variables: this.variables
    });
    if (newResult) {
      queryManager.cache.writeQuery({
        query: this.options.query,
        data: newResult,
        variables: this.variables
      });
      queryManager.broadcastQueries();
    }
  };
  ObservableQuery2.prototype.startPolling = function(pollInterval) {
    this.options.pollInterval = pollInterval;
    this.updatePolling();
  };
  ObservableQuery2.prototype.stopPolling = function() {
    this.options.pollInterval = 0;
    this.updatePolling();
  };
  ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {
    if (options.nextFetchPolicy) {
      var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
      if (fetchPolicy === "standby")
        ;
      else if (typeof options.nextFetchPolicy === "function") {
        options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
          reason,
          options,
          observable: this,
          initialFetchPolicy
        });
      } else if (reason === "variables-changed") {
        options.fetchPolicy = initialFetchPolicy;
      } else {
        options.fetchPolicy = options.nextFetchPolicy;
      }
    }
    return options.fetchPolicy;
  };
  ObservableQuery2.prototype.fetch = function(options, newNetworkStatus) {
    this.queryManager.setObservableQuery(this);
    return this.queryManager.fetchQueryObservable(this.queryId, options, newNetworkStatus);
  };
  ObservableQuery2.prototype.updatePolling = function() {
    var _this = this;
    if (this.queryManager.ssrMode) {
      return;
    }
    var _a2 = this, pollingInfo = _a2.pollingInfo, pollInterval = _a2.options.pollInterval;
    if (!pollInterval) {
      if (pollingInfo) {
        clearTimeout(pollingInfo.timeout);
        delete this.pollingInfo;
      }
      return;
    }
    if (pollingInfo && pollingInfo.interval === pollInterval) {
      return;
    }
    __DEV__ ? invariant$1(pollInterval, "Attempted to start a polling query without a polling interval.") : invariant$1(pollInterval, 10);
    var info = pollingInfo || (this.pollingInfo = {});
    info.interval = pollInterval;
    var maybeFetch = function() {
      if (_this.pollingInfo) {
        if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {
          _this.reobserve({
            fetchPolicy: "network-only"
          }, NetworkStatus.poll).then(poll2, poll2);
        } else {
          poll2();
        }
      }
    };
    var poll2 = function() {
      var info2 = _this.pollingInfo;
      if (info2) {
        clearTimeout(info2.timeout);
        info2.timeout = setTimeout(maybeFetch, info2.interval);
      }
    };
    poll2();
  };
  ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
    if (variables === void 0) {
      variables = this.variables;
    }
    this.last = __assign$1(__assign$1({}, this.last), { result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult), variables });
    if (!isNonEmptyArray(newResult.errors)) {
      delete this.last.error;
    }
    return this.last;
  };
  ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
    var _this = this;
    this.isTornDown = false;
    var useDisposableConcast = newNetworkStatus === NetworkStatus.refetch || newNetworkStatus === NetworkStatus.fetchMore || newNetworkStatus === NetworkStatus.poll;
    var oldVariables = this.options.variables;
    var oldFetchPolicy = this.options.fetchPolicy;
    var mergedOptions = compact(this.options, newOptions || {});
    var options = useDisposableConcast ? mergedOptions : assign(this.options, mergedOptions);
    if (!useDisposableConcast) {
      this.updatePolling();
      if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) && options.fetchPolicy !== "standby" && options.fetchPolicy === oldFetchPolicy) {
        this.applyNextFetchPolicy("variables-changed", options);
        if (newNetworkStatus === void 0) {
          newNetworkStatus = NetworkStatus.setVariables;
        }
      }
    }
    var variables = options.variables && __assign$1({}, options.variables);
    var concast = this.fetch(options, newNetworkStatus);
    var observer = {
      next: function(result) {
        _this.reportResult(result, variables);
      },
      error: function(error) {
        _this.reportError(error, variables);
      }
    };
    if (!useDisposableConcast) {
      if (this.concast && this.observer) {
        this.concast.removeObserver(this.observer);
      }
      this.concast = concast;
      this.observer = observer;
    }
    concast.addObserver(observer);
    return concast.promise;
  };
  ObservableQuery2.prototype.observe = function() {
    this.reportResult(this.getCurrentResult(false), this.variables);
  };
  ObservableQuery2.prototype.reportResult = function(result, variables) {
    var lastError = this.getLastError();
    if (lastError || this.isDifferentFromLastResult(result)) {
      if (lastError || !result.partial || this.options.returnPartialData) {
        this.updateLastResult(result, variables);
      }
      iterateObserversSafely(this.observers, "next", result);
    }
  };
  ObservableQuery2.prototype.reportError = function(error, variables) {
    var errorResult = __assign$1(__assign$1({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
    this.updateLastResult(errorResult, variables);
    iterateObserversSafely(this.observers, "error", this.last.error = error);
  };
  ObservableQuery2.prototype.hasObservers = function() {
    return this.observers.size > 0;
  };
  ObservableQuery2.prototype.tearDownQuery = function() {
    if (this.isTornDown)
      return;
    if (this.concast && this.observer) {
      this.concast.removeObserver(this.observer);
      delete this.concast;
      delete this.observer;
    }
    this.stopPolling();
    this.subscriptions.forEach(function(sub) {
      return sub.unsubscribe();
    });
    this.subscriptions.clear();
    this.queryManager.stopQuery(this.queryId);
    this.observers.clear();
    this.isTornDown = true;
  };
  return ObservableQuery2;
}(Observable);
fixObservableSubclass(ObservableQuery);
function reobserveCacheFirst(obsQuery) {
  var _a2 = obsQuery.options, fetchPolicy = _a2.fetchPolicy, nextFetchPolicy = _a2.nextFetchPolicy;
  if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
    return obsQuery.reobserve({
      fetchPolicy: "cache-first",
      nextFetchPolicy: function() {
        this.nextFetchPolicy = nextFetchPolicy;
        if (typeof nextFetchPolicy === "function") {
          return nextFetchPolicy.apply(this, arguments);
        }
        return fetchPolicy;
      }
    });
  }
  return obsQuery.reobserve();
}
function defaultSubscriptionObserverErrorCallback(error) {
  __DEV__ && invariant$1.error("Unhandled error", error.message, error.stack);
}
function logMissingFieldErrors(missing) {
  if (__DEV__ && missing) {
    __DEV__ && invariant$1.debug("Missing cache result fields: ".concat(JSON.stringify(missing)), missing);
  }
}
var LocalState = function() {
  function LocalState2(_a2) {
    var cache = _a2.cache, client2 = _a2.client, resolvers = _a2.resolvers, fragmentMatcher = _a2.fragmentMatcher;
    this.cache = cache;
    if (client2) {
      this.client = client2;
    }
    if (resolvers) {
      this.addResolvers(resolvers);
    }
    if (fragmentMatcher) {
      this.setFragmentMatcher(fragmentMatcher);
    }
  }
  LocalState2.prototype.addResolvers = function(resolvers) {
    var _this = this;
    this.resolvers = this.resolvers || {};
    if (Array.isArray(resolvers)) {
      resolvers.forEach(function(resolverGroup) {
        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
      });
    } else {
      this.resolvers = mergeDeep(this.resolvers, resolvers);
    }
  };
  LocalState2.prototype.setResolvers = function(resolvers) {
    this.resolvers = {};
    this.addResolvers(resolvers);
  };
  LocalState2.prototype.getResolvers = function() {
    return this.resolvers || {};
  };
  LocalState2.prototype.runResolvers = function(_a2) {
    var document2 = _a2.document, remoteResult = _a2.remoteResult, context = _a2.context, variables = _a2.variables, _b = _a2.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_c) {
        if (document2) {
          return [2, this.resolveDocument(document2, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
            return __assign$1(__assign$1({}, remoteResult), { data: localResult.result });
          })];
        }
        return [2, remoteResult];
      });
    });
  };
  LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
    this.fragmentMatcher = fragmentMatcher;
  };
  LocalState2.prototype.getFragmentMatcher = function() {
    return this.fragmentMatcher;
  };
  LocalState2.prototype.clientQuery = function(document2) {
    if (hasDirectives(["client"], document2)) {
      if (this.resolvers) {
        return document2;
      }
    }
    return null;
  };
  LocalState2.prototype.serverQuery = function(document2) {
    return removeClientSetsFromDocument(document2);
  };
  LocalState2.prototype.prepareContext = function(context) {
    var cache = this.cache;
    return __assign$1(__assign$1({}, context), { cache, getCacheKey: function(obj) {
      return cache.identify(obj);
    } });
  };
  LocalState2.prototype.addExportedVariables = function(document2, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (context === void 0) {
      context = {};
    }
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        if (document2) {
          return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context), variables).then(function(data2) {
            return __assign$1(__assign$1({}, variables), data2.exportedVariables);
          })];
        }
        return [2, __assign$1({}, variables)];
      });
    });
  };
  LocalState2.prototype.shouldForceResolvers = function(document2) {
    var forceResolvers = false;
    visit(document2, {
      Directive: {
        enter: function(node2) {
          if (node2.name.value === "client" && node2.arguments) {
            forceResolvers = node2.arguments.some(function(arg) {
              return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
            });
            if (forceResolvers) {
              return BREAK;
            }
          }
        }
      }
    });
    return forceResolvers;
  };
  LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
    return this.cache.diff({
      query: buildQueryFromSelectionSet(document2),
      variables,
      returnPartialData: true,
      optimistic: false
    }).result;
  };
  LocalState2.prototype.resolveDocument = function(document2, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
    if (context === void 0) {
      context = {};
    }
    if (variables === void 0) {
      variables = {};
    }
    if (fragmentMatcher === void 0) {
      fragmentMatcher = function() {
        return true;
      };
    }
    if (onlyRunForcedResolvers === void 0) {
      onlyRunForcedResolvers = false;
    }
    return __awaiter(this, void 0, void 0, function() {
      var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a2, cache, client2, execContext;
      return __generator(this, function(_b) {
        mainDefinition = getMainDefinition(document2);
        fragments = getFragmentDefinitions(document2);
        fragmentMap = createFragmentMap(fragments);
        definitionOperation = mainDefinition.operation;
        defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
        _a2 = this, cache = _a2.cache, client2 = _a2.client;
        execContext = {
          fragmentMap,
          context: __assign$1(__assign$1({}, context), { cache, client: client2 }),
          variables,
          fragmentMatcher,
          defaultOperationType,
          exportedVariables: {},
          onlyRunForcedResolvers
        };
        return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function(result) {
          return {
            result,
            exportedVariables: execContext.exportedVariables
          };
        })];
      });
    });
  };
  LocalState2.prototype.resolveSelectionSet = function(selectionSet, rootValue, execContext) {
    return __awaiter(this, void 0, void 0, function() {
      var fragmentMap, context, variables, resultsToMerge, execute2;
      var _this = this;
      return __generator(this, function(_a2) {
        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
        resultsToMerge = [rootValue];
        execute2 = function(selection) {
          return __awaiter(_this, void 0, void 0, function() {
            var fragment, typeCondition;
            return __generator(this, function(_a3) {
              if (!shouldInclude(selection, variables)) {
                return [2];
              }
              if (isField(selection)) {
                return [2, this.resolveField(selection, rootValue, execContext).then(function(fieldResult) {
                  var _a4;
                  if (typeof fieldResult !== "undefined") {
                    resultsToMerge.push((_a4 = {}, _a4[resultKeyNameFromField(selection)] = fieldResult, _a4));
                  }
                })];
              }
              if (isInlineFragment(selection)) {
                fragment = selection;
              } else {
                fragment = fragmentMap[selection.name.value];
                __DEV__ ? invariant$1(fragment, "No fragment named ".concat(selection.name.value)) : invariant$1(fragment, 9);
              }
              if (fragment && fragment.typeCondition) {
                typeCondition = fragment.typeCondition.name.value;
                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                  return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function(fragmentResult) {
                    resultsToMerge.push(fragmentResult);
                  })];
                }
              }
              return [2];
            });
          });
        };
        return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
          return mergeDeepArray(resultsToMerge);
        })];
      });
    });
  };
  LocalState2.prototype.resolveField = function(field, rootValue, execContext) {
    return __awaiter(this, void 0, void 0, function() {
      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
      var _this = this;
      return __generator(this, function(_a2) {
        variables = execContext.variables;
        fieldName = field.name.value;
        aliasedFieldName = resultKeyNameFromField(field);
        aliasUsed = fieldName !== aliasedFieldName;
        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
        resultPromise = Promise.resolve(defaultResult);
        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
          resolverType = rootValue.__typename || execContext.defaultOperationType;
          resolverMap = this.resolvers && this.resolvers[resolverType];
          if (resolverMap) {
            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
            if (resolve) {
              resultPromise = Promise.resolve(cacheSlot.withValue(this.cache, resolve, [
                rootValue,
                argumentsObjectFromField(field, variables),
                execContext.context,
                { field, fragmentMap: execContext.fragmentMap }
              ]));
            }
          }
        }
        return [2, resultPromise.then(function(result) {
          if (result === void 0) {
            result = defaultResult;
          }
          if (field.directives) {
            field.directives.forEach(function(directive) {
              if (directive.name.value === "export" && directive.arguments) {
                directive.arguments.forEach(function(arg) {
                  if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                    execContext.exportedVariables[arg.value.value] = result;
                  }
                });
              }
            });
          }
          if (!field.selectionSet) {
            return result;
          }
          if (result == null) {
            return result;
          }
          if (Array.isArray(result)) {
            return _this.resolveSubSelectedArray(field, result, execContext);
          }
          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, result, execContext);
          }
        })];
      });
    });
  };
  LocalState2.prototype.resolveSubSelectedArray = function(field, result, execContext) {
    var _this = this;
    return Promise.all(result.map(function(item) {
      if (item === null) {
        return null;
      }
      if (Array.isArray(item)) {
        return _this.resolveSubSelectedArray(field, item, execContext);
      }
      if (field.selectionSet) {
        return _this.resolveSelectionSet(field.selectionSet, item, execContext);
      }
    }));
  };
  return LocalState2;
}();
var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
function wrapDestructiveCacheMethod(cache, methodName) {
  var original = cache[methodName];
  if (typeof original === "function") {
    cache[methodName] = function() {
      destructiveMethodCounts.set(cache, (destructiveMethodCounts.get(cache) + 1) % 1e15);
      return original.apply(this, arguments);
    };
  }
}
function cancelNotifyTimeout(info) {
  if (info["notifyTimeout"]) {
    clearTimeout(info["notifyTimeout"]);
    info["notifyTimeout"] = void 0;
  }
}
var QueryInfo = function() {
  function QueryInfo2(queryManager, queryId) {
    if (queryId === void 0) {
      queryId = queryManager.generateQueryId();
    }
    this.queryId = queryId;
    this.listeners = /* @__PURE__ */ new Set();
    this.document = null;
    this.lastRequestId = 1;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.stopped = false;
    this.dirty = false;
    this.observableQuery = null;
    var cache = this.cache = queryManager.cache;
    if (!destructiveMethodCounts.has(cache)) {
      destructiveMethodCounts.set(cache, 0);
      wrapDestructiveCacheMethod(cache, "evict");
      wrapDestructiveCacheMethod(cache, "modify");
      wrapDestructiveCacheMethod(cache, "reset");
    }
  }
  QueryInfo2.prototype.init = function(query2) {
    var networkStatus = query2.networkStatus || NetworkStatus.loading;
    if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query2.variables)) {
      networkStatus = NetworkStatus.setVariables;
    }
    if (!equal(query2.variables, this.variables)) {
      this.lastDiff = void 0;
    }
    Object.assign(this, {
      document: query2.document,
      variables: query2.variables,
      networkError: null,
      graphQLErrors: this.graphQLErrors || [],
      networkStatus
    });
    if (query2.observableQuery) {
      this.setObservableQuery(query2.observableQuery);
    }
    if (query2.lastRequestId) {
      this.lastRequestId = query2.lastRequestId;
    }
    return this;
  };
  QueryInfo2.prototype.reset = function() {
    cancelNotifyTimeout(this);
    this.lastDiff = void 0;
    this.dirty = false;
  };
  QueryInfo2.prototype.getDiff = function(variables) {
    if (variables === void 0) {
      variables = this.variables;
    }
    var options = this.getDiffOptions(variables);
    if (this.lastDiff && equal(options, this.lastDiff.options)) {
      return this.lastDiff.diff;
    }
    this.updateWatch(this.variables = variables);
    var oq = this.observableQuery;
    if (oq && oq.options.fetchPolicy === "no-cache") {
      return { complete: false };
    }
    var diff2 = this.cache.diff(options);
    this.updateLastDiff(diff2, options);
    return diff2;
  };
  QueryInfo2.prototype.updateLastDiff = function(diff2, options) {
    this.lastDiff = diff2 ? {
      diff: diff2,
      options: options || this.getDiffOptions()
    } : void 0;
  };
  QueryInfo2.prototype.getDiffOptions = function(variables) {
    var _a2;
    if (variables === void 0) {
      variables = this.variables;
    }
    return {
      query: this.document,
      variables,
      returnPartialData: true,
      optimistic: true,
      canonizeResults: (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.options.canonizeResults
    };
  };
  QueryInfo2.prototype.setDiff = function(diff2) {
    var _this = this;
    var oldDiff = this.lastDiff && this.lastDiff.diff;
    this.updateLastDiff(diff2);
    if (!this.dirty && !equal(oldDiff && oldDiff.result, diff2 && diff2.result)) {
      this.dirty = true;
      if (!this.notifyTimeout) {
        this.notifyTimeout = setTimeout(function() {
          return _this.notify();
        }, 0);
      }
    }
  };
  QueryInfo2.prototype.setObservableQuery = function(oq) {
    var _this = this;
    if (oq === this.observableQuery)
      return;
    if (this.oqListener) {
      this.listeners.delete(this.oqListener);
    }
    this.observableQuery = oq;
    if (oq) {
      oq["queryInfo"] = this;
      this.listeners.add(this.oqListener = function() {
        var diff2 = _this.getDiff();
        if (diff2.fromOptimisticTransaction) {
          oq["observe"]();
        } else {
          reobserveCacheFirst(oq);
        }
      });
    } else {
      delete this.oqListener;
    }
  };
  QueryInfo2.prototype.notify = function() {
    var _this = this;
    cancelNotifyTimeout(this);
    if (this.shouldNotify()) {
      this.listeners.forEach(function(listener) {
        return listener(_this);
      });
    }
    this.dirty = false;
  };
  QueryInfo2.prototype.shouldNotify = function() {
    if (!this.dirty || !this.listeners.size) {
      return false;
    }
    if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
      var fetchPolicy = this.observableQuery.options.fetchPolicy;
      if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
        return false;
      }
    }
    return true;
  };
  QueryInfo2.prototype.stop = function() {
    if (!this.stopped) {
      this.stopped = true;
      this.reset();
      this.cancel();
      this.cancel = QueryInfo2.prototype.cancel;
      this.subscriptions.forEach(function(sub) {
        return sub.unsubscribe();
      });
      var oq = this.observableQuery;
      if (oq)
        oq.stopPolling();
    }
  };
  QueryInfo2.prototype.cancel = function() {
  };
  QueryInfo2.prototype.updateWatch = function(variables) {
    var _this = this;
    if (variables === void 0) {
      variables = this.variables;
    }
    var oq = this.observableQuery;
    if (oq && oq.options.fetchPolicy === "no-cache") {
      return;
    }
    var watchOptions = __assign$1(__assign$1({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff2) {
      return _this.setDiff(diff2);
    } });
    if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {
      this.cancel();
      this.cancel = this.cache.watch(this.lastWatch = watchOptions);
    }
  };
  QueryInfo2.prototype.resetLastWrite = function() {
    this.lastWrite = void 0;
  };
  QueryInfo2.prototype.shouldWrite = function(result, variables) {
    var lastWrite = this.lastWrite;
    return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result.data, lastWrite.result.data));
  };
  QueryInfo2.prototype.markResult = function(result, options, cacheWriteBehavior) {
    var _this = this;
    this.graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];
    this.reset();
    if (options.fetchPolicy === "no-cache") {
      this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));
    } else if (cacheWriteBehavior !== 0) {
      if (shouldWriteResult(result, options.errorPolicy)) {
        this.cache.performTransaction(function(cache) {
          if (_this.shouldWrite(result, options.variables)) {
            cache.writeQuery({
              query: _this.document,
              data: result.data,
              variables: options.variables,
              overwrite: cacheWriteBehavior === 1
            });
            _this.lastWrite = {
              result,
              variables: options.variables,
              dmCount: destructiveMethodCounts.get(_this.cache)
            };
          } else {
            if (_this.lastDiff && _this.lastDiff.diff.complete) {
              result.data = _this.lastDiff.diff.result;
              return;
            }
          }
          var diffOptions = _this.getDiffOptions(options.variables);
          var diff2 = cache.diff(diffOptions);
          if (!_this.stopped) {
            _this.updateWatch(options.variables);
          }
          _this.updateLastDiff(diff2, diffOptions);
          if (diff2.complete) {
            result.data = diff2.result;
          }
        });
      } else {
        this.lastWrite = void 0;
      }
    }
  };
  QueryInfo2.prototype.markReady = function() {
    this.networkError = null;
    return this.networkStatus = NetworkStatus.ready;
  };
  QueryInfo2.prototype.markError = function(error) {
    this.networkStatus = NetworkStatus.error;
    this.lastWrite = void 0;
    this.reset();
    if (error.graphQLErrors) {
      this.graphQLErrors = error.graphQLErrors;
    }
    if (error.networkError) {
      this.networkError = error.networkError;
    }
    return error;
  };
  return QueryInfo2;
}();
function shouldWriteResult(result, errorPolicy) {
  if (errorPolicy === void 0) {
    errorPolicy = "none";
  }
  var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
  var writeWithErrors = !graphQLResultHasError(result);
  if (!writeWithErrors && ignoreErrors && result.data) {
    writeWithErrors = true;
  }
  return writeWithErrors;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
var QueryManager = function() {
  function QueryManager2(_a2) {
    var cache = _a2.cache, link = _a2.link, defaultOptions2 = _a2.defaultOptions, _b = _a2.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a2.onBroadcast, _c = _a2.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a2.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a2.localState, assumeImmutableResults = _a2.assumeImmutableResults;
    this.clientAwareness = {};
    this.queries = /* @__PURE__ */ new Map();
    this.fetchCancelFns = /* @__PURE__ */ new Map();
    this.transformCache = new (canUseWeakMap ? WeakMap : Map)();
    this.queryIdCounter = 1;
    this.requestIdCounter = 1;
    this.mutationIdCounter = 1;
    this.inFlightLinkObservables = /* @__PURE__ */ new Map();
    this.cache = cache;
    this.link = link;
    this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
    this.queryDeduplication = queryDeduplication;
    this.clientAwareness = clientAwareness;
    this.localState = localState || new LocalState({ cache });
    this.ssrMode = ssrMode;
    this.assumeImmutableResults = !!assumeImmutableResults;
    if (this.onBroadcast = onBroadcast) {
      this.mutationStore = /* @__PURE__ */ Object.create(null);
    }
  }
  QueryManager2.prototype.stop = function() {
    var _this = this;
    this.queries.forEach(function(_info, queryId) {
      _this.stopQueryNoBroadcast(queryId);
    });
    this.cancelPendingFetches(__DEV__ ? new InvariantError("QueryManager stopped while query was in flight") : new InvariantError(11));
  };
  QueryManager2.prototype.cancelPendingFetches = function(error) {
    this.fetchCancelFns.forEach(function(cancel) {
      return cancel(error);
    });
    this.fetchCancelFns.clear();
  };
  QueryManager2.prototype.mutate = function(_a2) {
    var _b, _c;
    var mutation = _a2.mutation, variables = _a2.variables, optimisticResponse = _a2.optimisticResponse, updateQueries = _a2.updateQueries, _d = _a2.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e2 = _a2.awaitRefetchQueries, awaitRefetchQueries = _e2 === void 0 ? false : _e2, updateWithProxyFn = _a2.update, onQueryUpdated = _a2.onQueryUpdated, _f = _a2.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || "network-only" : _f, _g = _a2.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || "none" : _g, keepRootFields = _a2.keepRootFields, context = _a2.context;
    return __awaiter(this, void 0, void 0, function() {
      var mutationId, mutationStoreValue, self2;
      return __generator(this, function(_h) {
        switch (_h.label) {
          case 0:
            __DEV__ ? invariant$1(mutation, "mutation option is required. You must specify your GraphQL document in the mutation option.") : invariant$1(mutation, 12);
            __DEV__ ? invariant$1(fetchPolicy === "network-only" || fetchPolicy === "no-cache", "Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.") : invariant$1(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 13);
            mutationId = this.generateMutationId();
            mutation = this.transform(mutation).document;
            variables = this.getVariables(mutation, variables);
            if (!this.transform(mutation).hasClientExports)
              return [3, 2];
            return [4, this.localState.addExportedVariables(mutation, variables, context)];
          case 1:
            variables = _h.sent();
            _h.label = 2;
          case 2:
            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
              mutation,
              variables,
              loading: true,
              error: null
            });
            if (optimisticResponse) {
              this.markMutationOptimistic(optimisticResponse, {
                mutationId,
                document: mutation,
                variables,
                fetchPolicy,
                errorPolicy,
                context,
                updateQueries,
                update: updateWithProxyFn,
                keepRootFields
              });
            }
            this.broadcastQueries();
            self2 = this;
            return [2, new Promise(function(resolve, reject) {
              return asyncMap(self2.getObservableFromLink(mutation, __assign$1(__assign$1({}, context), { optimisticResponse }), variables, false), function(result) {
                if (graphQLResultHasError(result) && errorPolicy === "none") {
                  throw new ApolloError({
                    graphQLErrors: result.errors
                  });
                }
                if (mutationStoreValue) {
                  mutationStoreValue.loading = false;
                  mutationStoreValue.error = null;
                }
                var storeResult = __assign$1({}, result);
                if (typeof refetchQueries === "function") {
                  refetchQueries = refetchQueries(storeResult);
                }
                if (errorPolicy === "ignore" && graphQLResultHasError(storeResult)) {
                  delete storeResult.errors;
                }
                return self2.markMutationResult({
                  mutationId,
                  result: storeResult,
                  document: mutation,
                  variables,
                  fetchPolicy,
                  errorPolicy,
                  context,
                  update: updateWithProxyFn,
                  updateQueries,
                  awaitRefetchQueries,
                  refetchQueries,
                  removeOptimistic: optimisticResponse ? mutationId : void 0,
                  onQueryUpdated,
                  keepRootFields
                });
              }).subscribe({
                next: function(storeResult) {
                  self2.broadcastQueries();
                  resolve(storeResult);
                },
                error: function(err) {
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = err;
                  }
                  if (optimisticResponse) {
                    self2.cache.removeOptimistic(mutationId);
                  }
                  self2.broadcastQueries();
                  reject(err instanceof ApolloError ? err : new ApolloError({
                    networkError: err
                  }));
                }
              });
            })];
        }
      });
    });
  };
  QueryManager2.prototype.markMutationResult = function(mutation, cache) {
    var _this = this;
    if (cache === void 0) {
      cache = this.cache;
    }
    var result = mutation.result;
    var cacheWrites = [];
    var skipCache = mutation.fetchPolicy === "no-cache";
    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
      cacheWrites.push({
        result: result.data,
        dataId: "ROOT_MUTATION",
        query: mutation.document,
        variables: mutation.variables
      });
      var updateQueries_1 = mutation.updateQueries;
      if (updateQueries_1) {
        this.queries.forEach(function(_a2, queryId) {
          var observableQuery = _a2.observableQuery;
          var queryName = observableQuery && observableQuery.queryName;
          if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {
            return;
          }
          var updater = updateQueries_1[queryName];
          var _b = _this.queries.get(queryId), document2 = _b.document, variables = _b.variables;
          var _c = cache.diff({
            query: document2,
            variables,
            returnPartialData: true,
            optimistic: false
          }), currentQueryResult = _c.result, complete = _c.complete;
          if (complete && currentQueryResult) {
            var nextQueryResult = updater(currentQueryResult, {
              mutationResult: result,
              queryName: document2 && getOperationName(document2) || void 0,
              queryVariables: variables
            });
            if (nextQueryResult) {
              cacheWrites.push({
                result: nextQueryResult,
                dataId: "ROOT_QUERY",
                query: document2,
                variables
              });
            }
          }
        });
      }
    }
    if (cacheWrites.length > 0 || mutation.refetchQueries || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
      var results_1 = [];
      this.refetchQueries({
        updateCache: function(cache2) {
          if (!skipCache) {
            cacheWrites.forEach(function(write4) {
              return cache2.write(write4);
            });
          }
          var update5 = mutation.update;
          if (update5) {
            if (!skipCache) {
              var diff2 = cache2.diff({
                id: "ROOT_MUTATION",
                query: _this.transform(mutation.document).asQuery,
                variables: mutation.variables,
                optimistic: false,
                returnPartialData: true
              });
              if (diff2.complete) {
                result = __assign$1(__assign$1({}, result), { data: diff2.result });
              }
            }
            update5(cache2, result, {
              context: mutation.context,
              variables: mutation.variables
            });
          }
          if (!skipCache && !mutation.keepRootFields) {
            cache2.modify({
              id: "ROOT_MUTATION",
              fields: function(value, _a2) {
                var fieldName = _a2.fieldName, DELETE2 = _a2.DELETE;
                return fieldName === "__typename" ? value : DELETE2;
              }
            });
          }
        },
        include: mutation.refetchQueries,
        optimistic: false,
        removeOptimistic: mutation.removeOptimistic,
        onQueryUpdated: mutation.onQueryUpdated || null
      }).forEach(function(result2) {
        return results_1.push(result2);
      });
      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
        return Promise.all(results_1).then(function() {
          return result;
        });
      }
    }
    return Promise.resolve(result);
  };
  QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
    var _this = this;
    var data2 = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables) : optimisticResponse;
    return this.cache.recordOptimisticTransaction(function(cache) {
      try {
        _this.markMutationResult(__assign$1(__assign$1({}, mutation), { result: { data: data2 } }), cache);
      } catch (error) {
        __DEV__ && invariant$1.error(error);
      }
    }, mutation.mutationId);
  };
  QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
    return this.fetchQueryObservable(queryId, options, networkStatus).promise;
  };
  QueryManager2.prototype.getQueryStore = function() {
    var store = /* @__PURE__ */ Object.create(null);
    this.queries.forEach(function(info, queryId) {
      store[queryId] = {
        variables: info.variables,
        networkStatus: info.networkStatus,
        networkError: info.networkError,
        graphQLErrors: info.graphQLErrors
      };
    });
    return store;
  };
  QueryManager2.prototype.resetErrors = function(queryId) {
    var queryInfo = this.queries.get(queryId);
    if (queryInfo) {
      queryInfo.networkError = void 0;
      queryInfo.graphQLErrors = [];
    }
  };
  QueryManager2.prototype.transform = function(document2) {
    var transformCache = this.transformCache;
    if (!transformCache.has(document2)) {
      var transformed = this.cache.transformDocument(document2);
      var forLink = removeConnectionDirectiveFromDocument(this.cache.transformForLink(transformed));
      var clientQuery = this.localState.clientQuery(transformed);
      var serverQuery = forLink && this.localState.serverQuery(forLink);
      var cacheEntry_1 = {
        document: transformed,
        hasClientExports: hasClientExports(transformed),
        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
        clientQuery,
        serverQuery,
        defaultVars: getDefaultValues(getOperationDefinition(transformed)),
        asQuery: __assign$1(__assign$1({}, transformed), { definitions: transformed.definitions.map(function(def) {
          if (def.kind === "OperationDefinition" && def.operation !== "query") {
            return __assign$1(__assign$1({}, def), { operation: "query" });
          }
          return def;
        }) })
      };
      var add3 = function(doc) {
        if (doc && !transformCache.has(doc)) {
          transformCache.set(doc, cacheEntry_1);
        }
      };
      add3(document2);
      add3(transformed);
      add3(clientQuery);
      add3(serverQuery);
    }
    return transformCache.get(document2);
  };
  QueryManager2.prototype.getVariables = function(document2, variables) {
    return __assign$1(__assign$1({}, this.transform(document2).defaultVars), variables);
  };
  QueryManager2.prototype.watchQuery = function(options) {
    options = __assign$1(__assign$1({}, options), { variables: this.getVariables(options.query, options.variables) });
    if (typeof options.notifyOnNetworkStatusChange === "undefined") {
      options.notifyOnNetworkStatusChange = false;
    }
    var queryInfo = new QueryInfo(this);
    var observable2 = new ObservableQuery({
      queryManager: this,
      queryInfo,
      options
    });
    this.queries.set(observable2.queryId, queryInfo);
    queryInfo.init({
      document: observable2.query,
      observableQuery: observable2,
      variables: observable2.variables
    });
    return observable2;
  };
  QueryManager2.prototype.query = function(options, queryId) {
    var _this = this;
    if (queryId === void 0) {
      queryId = this.generateQueryId();
    }
    __DEV__ ? invariant$1(options.query, "query option is required. You must specify your GraphQL document in the query option.") : invariant$1(options.query, 14);
    __DEV__ ? invariant$1(options.query.kind === "Document", 'You must wrap the query string in a "gql" tag.') : invariant$1(options.query.kind === "Document", 15);
    __DEV__ ? invariant$1(!options.returnPartialData, "returnPartialData option only supported on watchQuery.") : invariant$1(!options.returnPartialData, 16);
    __DEV__ ? invariant$1(!options.pollInterval, "pollInterval option only supported on watchQuery.") : invariant$1(!options.pollInterval, 17);
    return this.fetchQuery(queryId, options).finally(function() {
      return _this.stopQuery(queryId);
    });
  };
  QueryManager2.prototype.generateQueryId = function() {
    return String(this.queryIdCounter++);
  };
  QueryManager2.prototype.generateRequestId = function() {
    return this.requestIdCounter++;
  };
  QueryManager2.prototype.generateMutationId = function() {
    return String(this.mutationIdCounter++);
  };
  QueryManager2.prototype.stopQueryInStore = function(queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.broadcastQueries();
  };
  QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
    var queryInfo = this.queries.get(queryId);
    if (queryInfo)
      queryInfo.stop();
  };
  QueryManager2.prototype.clearStore = function(options) {
    if (options === void 0) {
      options = {
        discardWatches: true
      };
    }
    this.cancelPendingFetches(__DEV__ ? new InvariantError("Store reset while query was in flight (not completed in link chain)") : new InvariantError(18));
    this.queries.forEach(function(queryInfo) {
      if (queryInfo.observableQuery) {
        queryInfo.networkStatus = NetworkStatus.loading;
      } else {
        queryInfo.stop();
      }
    });
    if (this.mutationStore) {
      this.mutationStore = /* @__PURE__ */ Object.create(null);
    }
    return this.cache.reset(options);
  };
  QueryManager2.prototype.getObservableQueries = function(include) {
    var _this = this;
    if (include === void 0) {
      include = "active";
    }
    var queries = /* @__PURE__ */ new Map();
    var queryNamesAndDocs = /* @__PURE__ */ new Map();
    var legacyQueryOptions = /* @__PURE__ */ new Set();
    if (Array.isArray(include)) {
      include.forEach(function(desc) {
        if (typeof desc === "string") {
          queryNamesAndDocs.set(desc, false);
        } else if (isDocumentNode(desc)) {
          queryNamesAndDocs.set(_this.transform(desc).document, false);
        } else if (isNonNullObject(desc) && desc.query) {
          legacyQueryOptions.add(desc);
        }
      });
    }
    this.queries.forEach(function(_a2, queryId) {
      var oq = _a2.observableQuery, document2 = _a2.document;
      if (oq) {
        if (include === "all") {
          queries.set(queryId, oq);
          return;
        }
        var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
        if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
          return;
        }
        if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document2 && queryNamesAndDocs.has(document2)) {
          queries.set(queryId, oq);
          if (queryName)
            queryNamesAndDocs.set(queryName, true);
          if (document2)
            queryNamesAndDocs.set(document2, true);
        }
      }
    });
    if (legacyQueryOptions.size) {
      legacyQueryOptions.forEach(function(options) {
        var queryId = makeUniqueId("legacyOneTimeQuery");
        var queryInfo = _this.getQuery(queryId).init({
          document: options.query,
          variables: options.variables
        });
        var oq = new ObservableQuery({
          queryManager: _this,
          queryInfo,
          options: __assign$1(__assign$1({}, options), { fetchPolicy: "network-only" })
        });
        invariant$1(oq.queryId === queryId);
        queryInfo.setObservableQuery(oq);
        queries.set(queryId, oq);
      });
    }
    if (__DEV__ && queryNamesAndDocs.size) {
      queryNamesAndDocs.forEach(function(included, nameOrDoc) {
        if (!included) {
          __DEV__ && invariant$1.warn("Unknown query ".concat(typeof nameOrDoc === "string" ? "named " : "").concat(JSON.stringify(nameOrDoc, null, 2), " requested in refetchQueries options.include array"));
        }
      });
    }
    return queries;
  };
  QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
    var _this = this;
    if (includeStandby === void 0) {
      includeStandby = false;
    }
    var observableQueryPromises = [];
    this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
      var fetchPolicy = observableQuery.options.fetchPolicy;
      observableQuery.resetLastResults();
      if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
        observableQueryPromises.push(observableQuery.refetch());
      }
      _this.getQuery(queryId).setDiff(null);
    });
    this.broadcastQueries();
    return Promise.all(observableQueryPromises);
  };
  QueryManager2.prototype.setObservableQuery = function(observableQuery) {
    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
  };
  QueryManager2.prototype.startGraphQLSubscription = function(_a2) {
    var _this = this;
    var query2 = _a2.query, fetchPolicy = _a2.fetchPolicy, errorPolicy = _a2.errorPolicy, variables = _a2.variables, _b = _a2.context, context = _b === void 0 ? {} : _b;
    query2 = this.transform(query2).document;
    variables = this.getVariables(query2, variables);
    var makeObservable = function(variables2) {
      return _this.getObservableFromLink(query2, context, variables2).map(function(result) {
        if (fetchPolicy !== "no-cache") {
          if (shouldWriteResult(result, errorPolicy)) {
            _this.cache.write({
              query: query2,
              result: result.data,
              dataId: "ROOT_SUBSCRIPTION",
              variables: variables2
            });
          }
          _this.broadcastQueries();
        }
        if (graphQLResultHasError(result)) {
          throw new ApolloError({
            graphQLErrors: result.errors
          });
        }
        return result;
      });
    };
    if (this.transform(query2).hasClientExports) {
      var observablePromise_1 = this.localState.addExportedVariables(query2, variables, context).then(makeObservable);
      return new Observable(function(observer) {
        var sub = null;
        observablePromise_1.then(function(observable2) {
          return sub = observable2.subscribe(observer);
        }, observer.error);
        return function() {
          return sub && sub.unsubscribe();
        };
      });
    }
    return makeObservable(variables);
  };
  QueryManager2.prototype.stopQuery = function(queryId) {
    this.stopQueryNoBroadcast(queryId);
    this.broadcastQueries();
  };
  QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.removeQuery(queryId);
  };
  QueryManager2.prototype.removeQuery = function(queryId) {
    this.fetchCancelFns.delete(queryId);
    if (this.queries.has(queryId)) {
      this.getQuery(queryId).stop();
      this.queries.delete(queryId);
    }
  };
  QueryManager2.prototype.broadcastQueries = function() {
    if (this.onBroadcast)
      this.onBroadcast();
    this.queries.forEach(function(info) {
      return info.notify();
    });
  };
  QueryManager2.prototype.getLocalState = function() {
    return this.localState;
  };
  QueryManager2.prototype.getObservableFromLink = function(query2, context, variables, deduplication) {
    var _this = this;
    var _a2;
    if (deduplication === void 0) {
      deduplication = (_a2 = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a2 !== void 0 ? _a2 : this.queryDeduplication;
    }
    var observable2;
    var serverQuery = this.transform(query2).serverQuery;
    if (serverQuery) {
      var _b = this, inFlightLinkObservables_1 = _b.inFlightLinkObservables, link = _b.link;
      var operation = {
        query: serverQuery,
        variables,
        operationName: getOperationName(serverQuery) || void 0,
        context: this.prepareContext(__assign$1(__assign$1({}, context), { forceFetch: !deduplication }))
      };
      context = operation.context;
      if (deduplication) {
        var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || /* @__PURE__ */ new Map();
        inFlightLinkObservables_1.set(serverQuery, byVariables_1);
        var varJson_1 = canonicalStringify(variables);
        observable2 = byVariables_1.get(varJson_1);
        if (!observable2) {
          var concast = new Concast([
            execute(link, operation)
          ]);
          byVariables_1.set(varJson_1, observable2 = concast);
          concast.cleanup(function() {
            if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {
              inFlightLinkObservables_1.delete(serverQuery);
            }
          });
        }
      } else {
        observable2 = new Concast([
          execute(link, operation)
        ]);
      }
    } else {
      observable2 = new Concast([
        Observable.of({ data: {} })
      ]);
      context = this.prepareContext(context);
    }
    var clientQuery = this.transform(query2).clientQuery;
    if (clientQuery) {
      observable2 = asyncMap(observable2, function(result) {
        return _this.localState.runResolvers({
          document: clientQuery,
          remoteResult: result,
          context,
          variables
        });
      });
    }
    return observable2;
  };
  QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
    var requestId = queryInfo.lastRequestId = this.generateRequestId();
    return asyncMap(this.getObservableFromLink(queryInfo.document, options.context, options.variables), function(result) {
      var hasErrors = isNonEmptyArray(result.errors);
      if (requestId >= queryInfo.lastRequestId) {
        if (hasErrors && options.errorPolicy === "none") {
          throw queryInfo.markError(new ApolloError({
            graphQLErrors: result.errors
          }));
        }
        queryInfo.markResult(result, options, cacheWriteBehavior);
        queryInfo.markReady();
      }
      var aqr = {
        data: result.data,
        loading: false,
        networkStatus: NetworkStatus.ready
      };
      if (hasErrors && options.errorPolicy !== "ignore") {
        aqr.errors = result.errors;
        aqr.networkStatus = NetworkStatus.error;
      }
      return aqr;
    }, function(networkError) {
      var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
      if (requestId >= queryInfo.lastRequestId) {
        queryInfo.markError(error);
      }
      throw error;
    });
  };
  QueryManager2.prototype.fetchQueryObservable = function(queryId, options, networkStatus) {
    var _this = this;
    if (networkStatus === void 0) {
      networkStatus = NetworkStatus.loading;
    }
    var query2 = this.transform(options.query).document;
    var variables = this.getVariables(query2, options.variables);
    var queryInfo = this.getQuery(queryId);
    var defaults2 = this.defaultOptions.watchQuery;
    var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? defaults2 && defaults2.fetchPolicy || "cache-first" : _a2, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults2 && defaults2.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e2 = options.context, context = _e2 === void 0 ? {} : _e2;
    var normalized = Object.assign({}, options, {
      query: query2,
      variables,
      fetchPolicy,
      errorPolicy,
      returnPartialData,
      notifyOnNetworkStatusChange,
      context
    });
    var fromVariables = function(variables2) {
      normalized.variables = variables2;
      var concastSources = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
      if (normalized.fetchPolicy !== "standby" && concastSources.length > 0 && queryInfo.observableQuery) {
        queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
      }
      return concastSources;
    };
    var cleanupCancelFn = function() {
      return _this.fetchCancelFns.delete(queryId);
    };
    this.fetchCancelFns.set(queryId, function(reason) {
      cleanupCancelFn();
      setTimeout(function() {
        return concast.cancel(reason);
      });
    });
    var concast = new Concast(this.transform(normalized.query).hasClientExports ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables) : fromVariables(normalized.variables));
    concast.promise.then(cleanupCancelFn, cleanupCancelFn);
    return concast;
  };
  QueryManager2.prototype.refetchQueries = function(_a2) {
    var _this = this;
    var updateCache = _a2.updateCache, include = _a2.include, _b = _a2.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a2.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a2.onQueryUpdated;
    var includedQueriesById = /* @__PURE__ */ new Map();
    if (include) {
      this.getObservableQueries(include).forEach(function(oq, queryId) {
        includedQueriesById.set(queryId, {
          oq,
          lastDiff: _this.getQuery(queryId).getDiff()
        });
      });
    }
    var results = /* @__PURE__ */ new Map();
    if (updateCache) {
      this.cache.batch({
        update: updateCache,
        optimistic: optimistic && removeOptimistic || false,
        removeOptimistic,
        onWatchUpdated: function(watch2, diff2, lastDiff) {
          var oq = watch2.watcher instanceof QueryInfo && watch2.watcher.observableQuery;
          if (oq) {
            if (onQueryUpdated) {
              includedQueriesById.delete(oq.queryId);
              var result = onQueryUpdated(oq, diff2, lastDiff);
              if (result === true) {
                result = oq.refetch();
              }
              if (result !== false) {
                results.set(oq, result);
              }
              return result;
            }
            if (onQueryUpdated !== null) {
              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff: diff2 });
            }
          }
        }
      });
    }
    if (includedQueriesById.size) {
      includedQueriesById.forEach(function(_a3, queryId) {
        var oq = _a3.oq, lastDiff = _a3.lastDiff, diff2 = _a3.diff;
        var result;
        if (onQueryUpdated) {
          if (!diff2) {
            var info = oq["queryInfo"];
            info.reset();
            diff2 = info.getDiff();
          }
          result = onQueryUpdated(oq, diff2, lastDiff);
        }
        if (!onQueryUpdated || result === true) {
          result = oq.refetch();
        }
        if (result !== false) {
          results.set(oq, result);
        }
        if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
          _this.stopQueryNoBroadcast(queryId);
        }
      });
    }
    if (removeOptimistic) {
      this.cache.removeOptimistic(removeOptimistic);
    }
    return results;
  };
  QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a2, networkStatus) {
    var _this = this;
    var query2 = _a2.query, variables = _a2.variables, fetchPolicy = _a2.fetchPolicy, refetchWritePolicy = _a2.refetchWritePolicy, errorPolicy = _a2.errorPolicy, returnPartialData = _a2.returnPartialData, context = _a2.context, notifyOnNetworkStatusChange = _a2.notifyOnNetworkStatusChange;
    var oldNetworkStatus = queryInfo.networkStatus;
    queryInfo.init({
      document: this.transform(query2).document,
      variables,
      networkStatus
    });
    var readCache = function() {
      return queryInfo.getDiff(variables);
    };
    var resultsFromCache = function(diff3, networkStatus2) {
      if (networkStatus2 === void 0) {
        networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
      }
      var data2 = diff3.result;
      if (__DEV__ && !returnPartialData && !equal(data2, {})) {
        logMissingFieldErrors(diff3.missing);
      }
      var fromData = function(data3) {
        return Observable.of(__assign$1({ data: data3, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff3.complete ? null : { partial: true }));
      };
      if (data2 && _this.transform(query2).hasForcedResolvers) {
        return _this.localState.runResolvers({
          document: query2,
          remoteResult: { data: data2 },
          context,
          variables,
          onlyRunForcedResolvers: true
        }).then(function(resolved) {
          return fromData(resolved.data || void 0);
        });
      }
      return fromData(data2);
    };
    var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
    var resultsFromLink = function() {
      return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
        variables,
        context,
        fetchPolicy,
        errorPolicy
      });
    };
    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
    switch (fetchPolicy) {
      default:
      case "cache-first": {
        var diff2 = readCache();
        if (diff2.complete) {
          return [
            resultsFromCache(diff2, queryInfo.markReady())
          ];
        }
        if (returnPartialData || shouldNotify) {
          return [
            resultsFromCache(diff2),
            resultsFromLink()
          ];
        }
        return [
          resultsFromLink()
        ];
      }
      case "cache-and-network": {
        var diff2 = readCache();
        if (diff2.complete || returnPartialData || shouldNotify) {
          return [
            resultsFromCache(diff2),
            resultsFromLink()
          ];
        }
        return [
          resultsFromLink()
        ];
      }
      case "cache-only":
        return [
          resultsFromCache(readCache(), queryInfo.markReady())
        ];
      case "network-only":
        if (shouldNotify) {
          return [
            resultsFromCache(readCache()),
            resultsFromLink()
          ];
        }
        return [resultsFromLink()];
      case "no-cache":
        if (shouldNotify) {
          return [
            resultsFromCache(queryInfo.getDiff()),
            resultsFromLink()
          ];
        }
        return [resultsFromLink()];
      case "standby":
        return [];
    }
  };
  QueryManager2.prototype.getQuery = function(queryId) {
    if (queryId && !this.queries.has(queryId)) {
      this.queries.set(queryId, new QueryInfo(this, queryId));
    }
    return this.queries.get(queryId);
  };
  QueryManager2.prototype.prepareContext = function(context) {
    if (context === void 0) {
      context = {};
    }
    var newContext = this.localState.prepareContext(context);
    return __assign$1(__assign$1({}, newContext), { clientAwareness: this.clientAwareness });
  };
  return QueryManager2;
}();
var hasSuggestedDevtools = false;
var ApolloClient = function() {
  function ApolloClient2(options) {
    var _this = this;
    this.resetStoreCallbacks = [];
    this.clearStoreCallbacks = [];
    var uri = options.uri, credentials = options.credentials, headers = options.headers, cache = options.cache, _a2 = options.ssrMode, ssrMode = _a2 === void 0 ? false : _a2, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options.connectToDevTools, connectToDevTools = _c === void 0 ? typeof window === "object" && !window.__APOLLO_CLIENT__ && __DEV__ : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions2 = options.defaultOptions, _e2 = options.assumeImmutableResults, assumeImmutableResults = _e2 === void 0 ? false : _e2, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
    var link = options.link;
    if (!link) {
      link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();
    }
    if (!cache) {
      throw __DEV__ ? new InvariantError("To initialize Apollo Client, you must specify a 'cache' property in the options object. \nFor more information, please visit: https://go.apollo.dev/c/docs") : new InvariantError(7);
    }
    this.link = link;
    this.cache = cache;
    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
    this.queryDeduplication = queryDeduplication;
    this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
    this.typeDefs = typeDefs;
    if (ssrForceFetchDelay) {
      setTimeout(function() {
        return _this.disableNetworkFetches = false;
      }, ssrForceFetchDelay);
    }
    this.watchQuery = this.watchQuery.bind(this);
    this.query = this.query.bind(this);
    this.mutate = this.mutate.bind(this);
    this.resetStore = this.resetStore.bind(this);
    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
    if (connectToDevTools && typeof window === "object") {
      window.__APOLLO_CLIENT__ = this;
    }
    if (!hasSuggestedDevtools && __DEV__) {
      hasSuggestedDevtools = true;
      if (typeof window !== "undefined" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
        var nav = window.navigator;
        var ua2 = nav && nav.userAgent;
        var url = void 0;
        if (typeof ua2 === "string") {
          if (ua2.indexOf("Chrome/") > -1) {
            url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
          } else if (ua2.indexOf("Firefox/") > -1) {
            url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
          }
        }
        if (url) {
          __DEV__ && invariant$1.log("Download the Apollo DevTools for a better development experience: " + url);
        }
      }
    }
    this.version = version$1;
    this.localState = new LocalState({
      cache,
      client: this,
      resolvers,
      fragmentMatcher
    });
    this.queryManager = new QueryManager({
      cache: this.cache,
      link: this.link,
      defaultOptions: this.defaultOptions,
      queryDeduplication,
      ssrMode,
      clientAwareness: {
        name: clientAwarenessName,
        version: clientAwarenessVersion
      },
      localState: this.localState,
      assumeImmutableResults,
      onBroadcast: connectToDevTools ? function() {
        if (_this.devToolsHookCb) {
          _this.devToolsHookCb({
            action: {},
            state: {
              queries: _this.queryManager.getQueryStore(),
              mutations: _this.queryManager.mutationStore || {}
            },
            dataWithOptimisticResults: _this.cache.extract(true)
          });
        }
      } : void 0
    });
  }
  ApolloClient2.prototype.stop = function() {
    this.queryManager.stop();
  };
  ApolloClient2.prototype.watchQuery = function(options) {
    if (this.defaultOptions.watchQuery) {
      options = mergeOptions(this.defaultOptions.watchQuery, options);
    }
    if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
      options = __assign$1(__assign$1({}, options), { fetchPolicy: "cache-first" });
    }
    return this.queryManager.watchQuery(options);
  };
  ApolloClient2.prototype.query = function(options) {
    if (this.defaultOptions.query) {
      options = mergeOptions(this.defaultOptions.query, options);
    }
    __DEV__ ? invariant$1(options.fetchPolicy !== "cache-and-network", "The cache-and-network fetchPolicy does not work with client.query, because client.query can only return a single result. Please use client.watchQuery to receive multiple results from the cache and the network, or consider using a different fetchPolicy, such as cache-first or network-only.") : invariant$1(options.fetchPolicy !== "cache-and-network", 8);
    if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
      options = __assign$1(__assign$1({}, options), { fetchPolicy: "cache-first" });
    }
    return this.queryManager.query(options);
  };
  ApolloClient2.prototype.mutate = function(options) {
    if (this.defaultOptions.mutate) {
      options = mergeOptions(this.defaultOptions.mutate, options);
    }
    return this.queryManager.mutate(options);
  };
  ApolloClient2.prototype.subscribe = function(options) {
    return this.queryManager.startGraphQLSubscription(options);
  };
  ApolloClient2.prototype.readQuery = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.cache.readQuery(options, optimistic);
  };
  ApolloClient2.prototype.readFragment = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.cache.readFragment(options, optimistic);
  };
  ApolloClient2.prototype.writeQuery = function(options) {
    this.cache.writeQuery(options);
    this.queryManager.broadcastQueries();
  };
  ApolloClient2.prototype.writeFragment = function(options) {
    this.cache.writeFragment(options);
    this.queryManager.broadcastQueries();
  };
  ApolloClient2.prototype.__actionHookForDevTools = function(cb2) {
    this.devToolsHookCb = cb2;
  };
  ApolloClient2.prototype.__requestRaw = function(payload) {
    return execute(this.link, payload);
  };
  ApolloClient2.prototype.resetStore = function() {
    var _this = this;
    return Promise.resolve().then(function() {
      return _this.queryManager.clearStore({
        discardWatches: false
      });
    }).then(function() {
      return Promise.all(_this.resetStoreCallbacks.map(function(fn2) {
        return fn2();
      }));
    }).then(function() {
      return _this.reFetchObservableQueries();
    });
  };
  ApolloClient2.prototype.clearStore = function() {
    var _this = this;
    return Promise.resolve().then(function() {
      return _this.queryManager.clearStore({
        discardWatches: true
      });
    }).then(function() {
      return Promise.all(_this.clearStoreCallbacks.map(function(fn2) {
        return fn2();
      }));
    });
  };
  ApolloClient2.prototype.onResetStore = function(cb2) {
    var _this = this;
    this.resetStoreCallbacks.push(cb2);
    return function() {
      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c2) {
        return c2 !== cb2;
      });
    };
  };
  ApolloClient2.prototype.onClearStore = function(cb2) {
    var _this = this;
    this.clearStoreCallbacks.push(cb2);
    return function() {
      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c2) {
        return c2 !== cb2;
      });
    };
  };
  ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
    return this.queryManager.reFetchObservableQueries(includeStandby);
  };
  ApolloClient2.prototype.refetchQueries = function(options) {
    var map2 = this.queryManager.refetchQueries(options);
    var queries = [];
    var results = [];
    map2.forEach(function(result2, obsQuery) {
      queries.push(obsQuery);
      results.push(result2);
    });
    var result = Promise.all(results);
    result.queries = queries;
    result.results = results;
    result.catch(function(error) {
      __DEV__ && invariant$1.debug("In client.refetchQueries, Promise.all promise rejected with error ".concat(error));
    });
    return result;
  };
  ApolloClient2.prototype.getObservableQueries = function(include) {
    if (include === void 0) {
      include = "active";
    }
    return this.queryManager.getObservableQueries(include);
  };
  ApolloClient2.prototype.extract = function(optimistic) {
    return this.cache.extract(optimistic);
  };
  ApolloClient2.prototype.restore = function(serializedState) {
    return this.cache.restore(serializedState);
  };
  ApolloClient2.prototype.addResolvers = function(resolvers) {
    this.localState.addResolvers(resolvers);
  };
  ApolloClient2.prototype.setResolvers = function(resolvers) {
    this.localState.setResolvers(resolvers);
  };
  ApolloClient2.prototype.getResolvers = function() {
    return this.localState.getResolvers();
  };
  ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
    this.localState.setFragmentMatcher(fragmentMatcher);
  };
  ApolloClient2.prototype.setLink = function(newLink) {
    this.link = this.queryManager.link = newLink;
  };
  return ApolloClient2;
}();
var contextKey = canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
function getApolloContext() {
  var context = reactExports.createContext[contextKey];
  if (!context) {
    Object.defineProperty(reactExports.createContext, contextKey, {
      value: context = reactExports.createContext({}),
      enumerable: false,
      writable: false,
      configurable: true
    });
    context.displayName = "ApolloContext";
  }
  return context;
}
var ApolloProvider = function(_a2) {
  var client2 = _a2.client, children = _a2.children;
  var ApolloContext = getApolloContext();
  return reactExports.createElement(ApolloContext.Consumer, null, function(context) {
    if (context === void 0) {
      context = {};
    }
    if (client2 && context.client !== client2) {
      context = Object.assign({}, context, { client: client2 });
    }
    __DEV__ ? invariant$1(context.client, 'ApolloProvider was not passed a client instance. Make sure you pass in your client via the "client" prop.') : invariant$1(context.client, 26);
    return reactExports.createElement(ApolloContext.Provider, { value: context }, children);
  });
};
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
var readOnly = function(obj) {
  return obj;
};
var BeforeUnloadEventType = "beforeunload";
var HashChangeEventType = "hashchange";
var PopStateEventType = "popstate";
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  var _options2 = options, _options2$window = _options2.window, window2 = _options2$window === void 0 ? document.defaultView : _options2$window;
  var globalHistory = window2.history;
  function getIndexAndLocation() {
    var _parsePath = parsePath(window2.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? "/" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? "" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash2 = _parsePath$hash === void 0 ? "" : _parsePath$hash;
    var state2 = globalHistory.state || {};
    return [state2.idx, readOnly({
      pathname,
      search,
      hash: hash2,
      state: state2.usr || null,
      key: state2.key || "default"
    })];
  }
  var blockedPopTx = null;
  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action.Pop;
      var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];
      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index2 - nextIndex;
          if (delta) {
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry2() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        }
      } else {
        applyTx(nextAction);
      }
    }
  }
  window2.addEventListener(PopStateEventType, handlePop);
  window2.addEventListener(HashChangeEventType, function() {
    var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1];
    if (createPath(nextLocation) !== createPath(location2)) {
      handlePop();
    }
  });
  var action = Action.Pop;
  var _getIndexAndLocation6 = getIndexAndLocation(), index2 = _getIndexAndLocation6[0], location2 = _getIndexAndLocation6[1];
  var listeners2 = createEvents();
  var blockers = createEvents();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$1({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getBaseHref() {
    var base3 = document.querySelector("base");
    var href = "";
    if (base3 && base3.getAttribute("href")) {
      var url = window2.location.href;
      var hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href;
  }
  function createHref(to) {
    return getBaseHref() + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function getNextLocation(to, state2) {
    if (state2 === void 0) {
      state2 = null;
    }
    return readOnly(_extends$1({
      pathname: location2.pathname,
      hash: "",
      search: ""
    }, typeof to === "string" ? parsePath(to) : to, {
      state: state2,
      key: createKey()
    }));
  }
  function getHistoryStateAndUrl(nextLocation, index3) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index3
    }, createHref(nextLocation)];
  }
  function allowTx(action2, location3, retry2) {
    return !blockers.length || (blockers.call({
      action: action2,
      location: location3,
      retry: retry2
    }), false);
  }
  function applyTx(nextAction) {
    action = nextAction;
    var _getIndexAndLocation7 = getIndexAndLocation();
    index2 = _getIndexAndLocation7[0];
    location2 = _getIndexAndLocation7[1];
    listeners2.call({
      action,
      location: location2
    });
  }
  function push3(to, state2) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state2);
    function retry2() {
      push3(to, state2);
    }
    if (allowTx(nextAction, nextLocation, retry2)) {
      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index2 + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1];
      try {
        globalHistory.pushState(historyState, "", url);
      } catch (error) {
        window2.location.assign(url);
      }
      applyTx(nextAction);
    }
  }
  function replace2(to, state2) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state2);
    function retry2() {
      replace2(to, state2);
    }
    if (allowTx(nextAction, nextLocation, retry2)) {
      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index2), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1];
      globalHistory.replaceState(historyState, "", url);
      applyTx(nextAction);
    }
  }
  function go(delta) {
    globalHistory.go(delta);
  }
  var history = {
    get action() {
      return action;
    },
    get location() {
      return location2;
    },
    createHref,
    push: push3,
    replace: replace2,
    go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners2.push(listener);
    },
    block: function block2(blocker) {
      var unblock = blockers.push(blocker);
      if (blockers.length === 1) {
        window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }
      return function() {
        unblock();
        if (!blockers.length) {
          window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history;
}
function promptBeforeUnload(event) {
  event.preventDefault();
  event.returnValue = "";
}
function createEvents() {
  var handlers = [];
  return {
    get length() {
      return handlers.length;
    },
    push: function push3(fn2) {
      handlers.push(fn2);
      return function() {
        handlers = handlers.filter(function(handler) {
          return handler !== fn2;
        });
      };
    },
    call: function call2(arg) {
      handlers.forEach(function(fn2) {
        return fn2 && fn2(arg);
      });
    }
  };
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function createPath(_ref) {
  var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash2 = _ref$hash === void 0 ? "" : _ref$hash;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  var parsedPath = {};
  if (path) {
    var hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    var searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
/**
 * React Router v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: []
});
function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location2.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i3 = 0; matches == null && i3 < branches.length; ++i3) {
    matches = matchRouteBranch(branches[i3], pathname);
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes.forEach((route, index2) => {
    let meta = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      !meta.relativePath.startsWith(parentPath) ? invariant(false) : void 0;
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      !(route.index !== true) ? invariant(false) : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a3, b4) => a3.score !== b4.score ? b4.score - a3.score : compareIndexes(a3.routesMeta.map((meta) => meta.childrenIndex), b4.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s3) => s3 === "*";
function computeScore(path, index2) {
  let segments2 = path.split("/");
  let initialScore = segments2.length;
  if (segments2.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments2.filter((s3) => !isSplat(s3)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a3, b4) {
  let siblings = a3.length === b4.length && a3.slice(0, -1).every((n4, i3) => n4 === b4[i3]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a3[a3.length - 1] - b4[b4.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i3 = 0; i3 < routesMeta.length; ++i3) {
    let meta = routesMeta[i3];
    let end2 = i3 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern2, pathname) {
  if (typeof pattern2 === "string") {
    pattern2 = {
      path: pattern2,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern2.path, pattern2.caseSensitive, pattern2.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo2, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo2[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "");
    return memo2;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern: pattern2
  };
}
function compilePath(path, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_3, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else {
    regexpSource += end2 ? "\\/*$" : (
      // Otherwise, match a word boundary or a proceeding /. The word boundary restricts
      // parent routes to matching only their own words and nothing more, e.g. parent
      // route "/home" should not match "/home2".
      // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,
      // but do not consume the character in the matched path so they can match against
      // nested paths.
      "(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)"
    );
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    return value;
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments2 = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments2.length > 1)
        segments2.pop();
    } else if (segment !== ".") {
      segments2.push(segment);
    }
  });
  return segments2.length > 1 ? segments2.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname) {
  let to = typeof toArg === "string" ? parsePath(toArg) : toArg;
  let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }
  return path;
}
function getToPathname(to) {
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let nextChar = pathname.charAt(basename.length);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(basename.length) || "/";
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function useHref(to) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to);
  let joinedPathname = pathname;
  if (basename !== "/") {
    let toPathname = getToPathname(to);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  let activeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
  return navigate;
}
function useParams() {
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to) {
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
function useRoutes(routes, locationArg) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location2;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location2 = parsedLocationArg;
  } else {
    location2 = locationFromContext;
  }
  let pathname = location2.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  return _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
}
function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null)
    return null;
  return matches.reduceRight((outlet, match, index2) => {
    return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      children: match.route.element !== void 0 ? match.route.element : outlet,
      value: {
        outlet,
        matches: parentMatches.concat(matches.slice(0, index2 + 1))
      }
    });
  }, null);
}
function Route(_props) {
  invariant(false);
}
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state: state2 = null,
    key: key2 = "default"
  } = locationProp;
  let location2 = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash: hash2,
      state: state2,
      key: key2
    };
  }, [basename, pathname, search, hash2, state2, key2]);
  if (location2 == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: {
      location: location2,
      navigationType
    }
  }));
}
function Routes(_ref4) {
  let {
    children,
    location: location2
  } = _ref4;
  return useRoutes(createRoutesFromChildren(children), location2);
}
function createRoutesFromChildren(children) {
  let routes = [];
  reactExports.Children.forEach(children, (element) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    let route = {
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded2) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key2 = sourceKeys[i3];
    if (excluded2.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
const _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"];
function HashRouter(_ref2) {
  let {
    basename,
    children,
    window: window2
  } = _ref2;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window: window2
    });
  }
  let history = historyRef.current;
  let [state2, setState] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  reactExports.useLayoutEffect(() => history.listen(setState), [history]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state2.location,
    navigationType: state2.action,
    navigator: history
  });
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref4, ref2) {
  let {
    onClick,
    reloadDocument,
    replace: replace2 = false,
    state: state2,
    target,
    to
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let href = useHref(to);
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state: state2,
    target
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends({}, rest, {
      href,
      onClick: handleClick,
      ref: ref2,
      target
    }))
  );
});
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state: state2
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location2 = useLocation();
  let path = useResolvedPath(to);
  return reactExports.useCallback((event) => {
    if (event.button === 0 && // Ignore everything but left clicks
    (!target || target === "_self") && // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event)) {
      event.preventDefault();
      let replace2 = !!replaceProp || createPath(location2) === createPath(path);
      navigate(to, {
        replace: replace2,
        state: state2
      });
    }
  }, [location2, navigate, path, replaceProp, state2, target, to]);
}
function useSearchParams(defaultInit) {
  let defaultSearchParamsRef = reactExports.useRef(createSearchParams(defaultInit));
  let location2 = useLocation();
  let searchParams = reactExports.useMemo(() => {
    let searchParams2 = createSearchParams(location2.search);
    for (let key2 of defaultSearchParamsRef.current.keys()) {
      if (!searchParams2.has(key2)) {
        defaultSearchParamsRef.current.getAll(key2).forEach((value) => {
          searchParams2.append(key2, value);
        });
      }
    }
    return searchParams2;
  }, [location2.search]);
  let navigate = useNavigate();
  let setSearchParams = reactExports.useCallback((nextInit, navigateOptions) => {
    navigate("?" + createSearchParams(nextInit), navigateOptions);
  }, [navigate]);
  return [searchParams, setSearchParams];
}
function createSearchParams(init3) {
  if (init3 === void 0) {
    init3 = "";
  }
  return new URLSearchParams(typeof init3 === "string" || Array.isArray(init3) || init3 instanceof URLSearchParams ? init3 : Object.keys(init3).reduce((memo2, key2) => {
    let value = init3[key2];
    return memo2.concat(Array.isArray(value) ? value.map((v4) => [key2, v4]) : [[key2, value]]);
  }, []));
}
var cssUnit = {
  cm: true,
  mm: true,
  in: true,
  px: true,
  pt: true,
  pc: true,
  em: true,
  ex: true,
  ch: true,
  rem: true,
  vw: true,
  vh: true,
  vmin: true,
  vmax: true,
  "%": true
};
function parseLengthAndUnit(size2) {
  if (typeof size2 === "number") {
    return {
      value: size2,
      unit: "px"
    };
  }
  var value;
  var valueString = (size2.match(/^[0-9.]*/) || "").toString();
  if (valueString.includes(".")) {
    value = parseFloat(valueString);
  } else {
    value = parseInt(valueString, 10);
  }
  var unit = (size2.match(/[^0-9]*$/) || "").toString();
  if (cssUnit[unit]) {
    return {
      value,
      unit
    };
  }
  console.warn("React Spinners: ".concat(size2, " is not a valid css value. Defaulting to ").concat(value, "px."));
  return {
    value,
    unit: "px"
  };
}
function cssValue(value) {
  var lengthWithunit = parseLengthAndUnit(value);
  return "".concat(lengthWithunit.value).concat(lengthWithunit.unit);
}
var createAnimation = function(loaderName, frames, suffix) {
  var animationName = "react-spinners-".concat(loaderName, "-").concat(suffix);
  if (typeof window == "undefined" || !window.document) {
    return animationName;
  }
  var styleEl = document.createElement("style");
  document.head.appendChild(styleEl);
  var styleSheet = styleEl.sheet;
  var keyFrames = "\n    @keyframes ".concat(animationName, " {\n      ").concat(frames, "\n    }\n  ");
  if (styleSheet) {
    styleSheet.insertRule(keyFrames, 0);
  }
  return animationName;
};
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s3, i3 = 1, n4 = arguments.length; i3 < n4; i3++) {
      s3 = arguments[i3];
      for (var p3 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p3))
          t2[p3] = s3[p3];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __rest = globalThis && globalThis.__rest || function(s3, e2) {
  var t2 = {};
  for (var p3 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p3) && e2.indexOf(p3) < 0)
      t2[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
      if (e2.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
        t2[p3[i3]] = s3[p3[i3]];
    }
  return t2;
};
var climbingBox = createAnimation("ClimbingBoxLoader", "0% {transform:translate(0, -1em) rotate(-45deg)}\n  5% {transform:translate(0, -1em) rotate(-50deg)}\n  20% {transform:translate(1em, -2em) rotate(47deg)}\n  25% {transform:translate(1em, -2em) rotate(45deg)}\n  30% {transform:translate(1em, -2em) rotate(40deg)}\n  45% {transform:translate(2em, -3em) rotate(137deg)}\n  50% {transform:translate(2em, -3em) rotate(135deg)}\n  55% {transform:translate(2em, -3em) rotate(130deg)}\n  70% {transform:translate(3em, -4em) rotate(217deg)}\n  75% {transform:translate(3em, -4em) rotate(220deg)}\n  100% {transform:translate(0, -1em) rotate(-225deg)}", "climbingBox");
function ClimbingBoxLoader(_a2) {
  var _b = _a2.loading, loading = _b === void 0 ? true : _b, _c = _a2.color, color = _c === void 0 ? "#000000" : _c, _d = _a2.speedMultiplier, speedMultiplier = _d === void 0 ? 1 : _d, _e2 = _a2.cssOverride, cssOverride = _e2 === void 0 ? {} : _e2, _f = _a2.size, size2 = _f === void 0 ? 15 : _f, additionalprops = __rest(_a2, ["loading", "color", "speedMultiplier", "cssOverride", "size"]);
  var container2 = __assign({ display: "inherit", position: "relative", width: "7.1em", height: "7.1em" }, cssOverride);
  var wrapper = {
    position: "absolute",
    top: "50%",
    left: "50%",
    marginTop: "-2.7em",
    marginLeft: "-2.7em",
    width: "5.4em",
    height: "5.4em",
    fontSize: cssValue(size2)
  };
  var style2 = {
    position: "absolute",
    left: "0",
    bottom: "-0.1em",
    height: "1em",
    width: "1em",
    backgroundColor: "transparent",
    borderRadius: "15%",
    border: "0.25em solid ".concat(color),
    transform: "translate(0, -1em) rotate(-45deg)",
    animationFillMode: "both",
    animation: "".concat(climbingBox, " ").concat(2.5 / speedMultiplier, "s infinite cubic-bezier(0.79, 0, 0.47, 0.97)")
  };
  var hill = {
    position: "absolute",
    width: "7.1em",
    height: "7.1em",
    top: "1.7em",
    left: "1.7em",
    borderLeft: "0.25em solid ".concat(color),
    transform: "rotate(45deg)"
  };
  if (!loading) {
    return null;
  }
  return reactExports.createElement(
    "span",
    __assign({ style: container2 }, additionalprops),
    reactExports.createElement(
      "span",
      { style: wrapper },
      reactExports.createElement("span", { style: style2 }),
      reactExports.createElement("span", { style: hill })
    )
  );
}
const Spinner$1 = "";
const Spinner = () => /* @__PURE__ */ jsx("div", { id: "spinner", children: /* @__PURE__ */ jsx(ClimbingBoxLoader, { color: "#FE0235" }) });
const u = (t2) => "number" == typeof t2 && !isNaN(t2), d = (t2) => "string" == typeof t2, p$1 = (t2) => "function" == typeof t2, m$1 = (t2) => d(t2) || p$1(t2) ? t2 : null, f = (t2) => reactExports.isValidElement(t2) || d(t2) || p$1(t2) || u(t2);
function g(t2, e2, n4) {
  void 0 === n4 && (n4 = 300);
  const { scrollHeight: o2, style: s3 } = t2;
  requestAnimationFrame(() => {
    s3.minHeight = "initial", s3.height = o2 + "px", s3.transition = `all ${n4}ms`, requestAnimationFrame(() => {
      s3.height = "0", s3.padding = "0", s3.margin = "0", setTimeout(e2, n4);
    });
  });
}
function h(e2) {
  let { enter: a3, exit: r2, appendPosition: i3 = false, collapse: l2 = true, collapseDuration: c2 = 300 } = e2;
  return function(e3) {
    let { children: u3, position: d3, preventExitTransition: p3, done: m2, nodeRef: f4, isIn: h5 } = e3;
    const y3 = i3 ? `${a3}--${d3}` : a3, v4 = i3 ? `${r2}--${d3}` : r2, T2 = reactExports.useRef(0);
    return reactExports.useLayoutEffect(() => {
      const t2 = f4.current, e4 = y3.split(" "), n4 = (o2) => {
        o2.target === f4.current && (t2.dispatchEvent(new Event("d")), t2.removeEventListener("animationend", n4), t2.removeEventListener("animationcancel", n4), 0 === T2.current && "animationcancel" !== o2.type && t2.classList.remove(...e4));
      };
      t2.classList.add(...e4), t2.addEventListener("animationend", n4), t2.addEventListener("animationcancel", n4);
    }, []), reactExports.useEffect(() => {
      const t2 = f4.current, e4 = () => {
        t2.removeEventListener("animationend", e4), l2 ? g(t2, m2, c2) : m2();
      };
      h5 || (p3 ? e4() : (T2.current = 1, t2.className += ` ${v4}`, t2.addEventListener("animationend", e4)));
    }, [h5]), React$1.createElement(React$1.Fragment, null, u3);
  };
}
function y(t2, e2) {
  return { content: t2.content, containerId: t2.props.containerId, id: t2.props.toastId, theme: t2.props.theme, type: t2.props.type, data: t2.props.data || {}, isLoading: t2.props.isLoading, icon: t2.props.icon, status: e2 };
}
const v$1 = { list: /* @__PURE__ */ new Map(), emitQueue: /* @__PURE__ */ new Map(), on(t2, e2) {
  return this.list.has(t2) || this.list.set(t2, []), this.list.get(t2).push(e2), this;
}, off(t2, e2) {
  if (e2) {
    const n4 = this.list.get(t2).filter((t3) => t3 !== e2);
    return this.list.set(t2, n4), this;
  }
  return this.list.delete(t2), this;
}, cancelEmit(t2) {
  const e2 = this.emitQueue.get(t2);
  return e2 && (e2.forEach(clearTimeout), this.emitQueue.delete(t2)), this;
}, emit(t2) {
  this.list.has(t2) && this.list.get(t2).forEach((e2) => {
    const n4 = setTimeout(() => {
      e2(...[].slice.call(arguments, 1));
    }, 0);
    this.emitQueue.has(t2) || this.emitQueue.set(t2, []), this.emitQueue.get(t2).push(n4);
  });
} }, T$1 = (e2) => {
  let { theme: n4, type: o2, ...s3 } = e2;
  return React$1.createElement("svg", { viewBox: "0 0 24 24", width: "100%", height: "100%", fill: "colored" === n4 ? "currentColor" : `var(--toastify-icon-color-${o2})`, ...s3 });
}, E$1 = { info: function(e2) {
  return React$1.createElement(T$1, { ...e2 }, React$1.createElement("path", { d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z" }));
}, warning: function(e2) {
  return React$1.createElement(T$1, { ...e2 }, React$1.createElement("path", { d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z" }));
}, success: function(e2) {
  return React$1.createElement(T$1, { ...e2 }, React$1.createElement("path", { d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z" }));
}, error: function(e2) {
  return React$1.createElement(T$1, { ...e2 }, React$1.createElement("path", { d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z" }));
}, spinner: function() {
  return React$1.createElement("div", { className: "Toastify__spinner" });
} };
function C$1(t2) {
  const [, o2] = reactExports.useReducer((t3) => t3 + 1, 0), [l2, c2] = reactExports.useState([]), g3 = reactExports.useRef(null), h5 = reactExports.useRef(/* @__PURE__ */ new Map()).current, T2 = (t3) => -1 !== l2.indexOf(t3), C2 = reactExports.useRef({ toastKey: 1, displayedToast: 0, count: 0, queue: [], props: t2, containerId: null, isToastActive: T2, getToast: (t3) => h5.get(t3) }).current;
  function I3(t3) {
    let { containerId: e2 } = t3;
    const { limit: n4 } = C2.props;
    !n4 || e2 && C2.containerId !== e2 || (C2.count -= C2.queue.length, C2.queue = []);
  }
  function b4(t3) {
    c2((e2) => null == t3 ? [] : e2.filter((e3) => e3 !== t3));
  }
  function _3() {
    const { toastContent: t3, toastProps: e2, staleId: n4 } = C2.queue.shift();
    O2(t3, e2, n4);
  }
  function L3(t3, n4) {
    let { delay: s3, staleId: r2, ...i3 } = n4;
    if (!f(t3) || function(t4) {
      return !g3.current || C2.props.enableMultiContainer && t4.containerId !== C2.props.containerId || h5.has(t4.toastId) && null == t4.updateId;
    }(i3))
      return;
    const { toastId: l3, updateId: c3, data: T3 } = i3, { props: I4 } = C2, L4 = () => b4(l3), N10 = null == c3;
    N10 && C2.count++;
    const M3 = { ...I4, style: I4.toastStyle, key: C2.toastKey++, ...i3, toastId: l3, updateId: c3, data: T3, closeToast: L4, isIn: false, className: m$1(i3.className || I4.toastClassName), bodyClassName: m$1(i3.bodyClassName || I4.bodyClassName), progressClassName: m$1(i3.progressClassName || I4.progressClassName), autoClose: !i3.isLoading && (R3 = i3.autoClose, w3 = I4.autoClose, false === R3 || u(R3) && R3 > 0 ? R3 : w3), deleteToast() {
      const t4 = y(h5.get(l3), "removed");
      h5.delete(l3), v$1.emit(4, t4);
      const e2 = C2.queue.length;
      if (C2.count = null == l3 ? C2.count - C2.displayedToast : C2.count - 1, C2.count < 0 && (C2.count = 0), e2 > 0) {
        const t5 = null == l3 ? C2.props.limit : 1;
        if (1 === e2 || 1 === t5)
          C2.displayedToast++, _3();
        else {
          const n5 = t5 > e2 ? e2 : t5;
          C2.displayedToast = n5;
          for (let t6 = 0; t6 < n5; t6++)
            _3();
        }
      } else
        o2();
    } };
    var R3, w3;
    M3.iconOut = function(t4) {
      let { theme: n5, type: o3, isLoading: s4, icon: r3 } = t4, i4 = null;
      const l4 = { theme: n5, type: o3 };
      return false === r3 || (p$1(r3) ? i4 = r3(l4) : reactExports.isValidElement(r3) ? i4 = reactExports.cloneElement(r3, l4) : d(r3) || u(r3) ? i4 = r3 : s4 ? i4 = E$1.spinner() : ((t5) => t5 in E$1)(o3) && (i4 = E$1[o3](l4))), i4;
    }(M3), p$1(i3.onOpen) && (M3.onOpen = i3.onOpen), p$1(i3.onClose) && (M3.onClose = i3.onClose), M3.closeButton = I4.closeButton, false === i3.closeButton || f(i3.closeButton) ? M3.closeButton = i3.closeButton : true === i3.closeButton && (M3.closeButton = !f(I4.closeButton) || I4.closeButton);
    let x2 = t3;
    reactExports.isValidElement(t3) && !d(t3.type) ? x2 = reactExports.cloneElement(t3, { closeToast: L4, toastProps: M3, data: T3 }) : p$1(t3) && (x2 = t3({ closeToast: L4, toastProps: M3, data: T3 })), I4.limit && I4.limit > 0 && C2.count > I4.limit && N10 ? C2.queue.push({ toastContent: x2, toastProps: M3, staleId: r2 }) : u(s3) ? setTimeout(() => {
      O2(x2, M3, r2);
    }, s3) : O2(x2, M3, r2);
  }
  function O2(t3, e2, n4) {
    const { toastId: o3 } = e2;
    n4 && h5.delete(n4);
    const s3 = { content: t3, props: e2 };
    h5.set(o3, s3), c2((t4) => [...t4, o3].filter((t5) => t5 !== n4)), v$1.emit(4, y(s3, null == s3.props.updateId ? "added" : "updated"));
  }
  return reactExports.useEffect(() => (C2.containerId = t2.containerId, v$1.cancelEmit(3).on(0, L3).on(1, (t3) => g3.current && b4(t3)).on(5, I3).emit(2, C2), () => {
    h5.clear(), v$1.emit(3, C2);
  }), []), reactExports.useEffect(() => {
    C2.props = t2, C2.isToastActive = T2, C2.displayedToast = l2.length;
  }), { getToastToRender: function(e2) {
    const n4 = /* @__PURE__ */ new Map(), o3 = Array.from(h5.values());
    return t2.newestOnTop && o3.reverse(), o3.forEach((t3) => {
      const { position: e3 } = t3.props;
      n4.has(e3) || n4.set(e3, []), n4.get(e3).push(t3);
    }), Array.from(n4, (t3) => e2(t3[0], t3[1]));
  }, containerRef: g3, isToastActive: T2 };
}
function I$1(t2) {
  return t2.targetTouches && t2.targetTouches.length >= 1 ? t2.targetTouches[0].clientX : t2.clientX;
}
function b(t2) {
  return t2.targetTouches && t2.targetTouches.length >= 1 ? t2.targetTouches[0].clientY : t2.clientY;
}
function _(t2) {
  const [o2, a3] = reactExports.useState(false), [r2, l2] = reactExports.useState(false), c2 = reactExports.useRef(null), u3 = reactExports.useRef({ start: 0, x: 0, y: 0, delta: 0, removalDistance: 0, canCloseOnClick: true, canDrag: false, boundingRect: null, didMove: false }).current, d3 = reactExports.useRef(t2), { autoClose: m2, pauseOnHover: f4, closeToast: g3, onClick: h5, closeOnClick: y3 } = t2;
  function v4(e2) {
    if (t2.draggable) {
      "touchstart" === e2.nativeEvent.type && e2.nativeEvent.preventDefault(), u3.didMove = false, document.addEventListener("mousemove", _3), document.addEventListener("mouseup", L3), document.addEventListener("touchmove", _3), document.addEventListener("touchend", L3);
      const n4 = c2.current;
      u3.canCloseOnClick = true, u3.canDrag = true, u3.boundingRect = n4.getBoundingClientRect(), n4.style.transition = "", u3.x = I$1(e2.nativeEvent), u3.y = b(e2.nativeEvent), "x" === t2.draggableDirection ? (u3.start = u3.x, u3.removalDistance = n4.offsetWidth * (t2.draggablePercent / 100)) : (u3.start = u3.y, u3.removalDistance = n4.offsetHeight * (80 === t2.draggablePercent ? 1.5 * t2.draggablePercent : t2.draggablePercent / 100));
    }
  }
  function T2(e2) {
    if (u3.boundingRect) {
      const { top: n4, bottom: o3, left: s3, right: a4 } = u3.boundingRect;
      "touchend" !== e2.nativeEvent.type && t2.pauseOnHover && u3.x >= s3 && u3.x <= a4 && u3.y >= n4 && u3.y <= o3 ? C2() : E3();
    }
  }
  function E3() {
    a3(true);
  }
  function C2() {
    a3(false);
  }
  function _3(e2) {
    const n4 = c2.current;
    u3.canDrag && n4 && (u3.didMove = true, o2 && C2(), u3.x = I$1(e2), u3.y = b(e2), u3.delta = "x" === t2.draggableDirection ? u3.x - u3.start : u3.y - u3.start, u3.start !== u3.x && (u3.canCloseOnClick = false), n4.style.transform = `translate${t2.draggableDirection}(${u3.delta}px)`, n4.style.opacity = "" + (1 - Math.abs(u3.delta / u3.removalDistance)));
  }
  function L3() {
    document.removeEventListener("mousemove", _3), document.removeEventListener("mouseup", L3), document.removeEventListener("touchmove", _3), document.removeEventListener("touchend", L3);
    const e2 = c2.current;
    if (u3.canDrag && u3.didMove && e2) {
      if (u3.canDrag = false, Math.abs(u3.delta) > u3.removalDistance)
        return l2(true), void t2.closeToast();
      e2.style.transition = "transform 0.2s, opacity 0.2s", e2.style.transform = `translate${t2.draggableDirection}(0)`, e2.style.opacity = "1";
    }
  }
  reactExports.useEffect(() => {
    d3.current = t2;
  }), reactExports.useEffect(() => (c2.current && c2.current.addEventListener("d", E3, { once: true }), p$1(t2.onOpen) && t2.onOpen(reactExports.isValidElement(t2.children) && t2.children.props), () => {
    const t3 = d3.current;
    p$1(t3.onClose) && t3.onClose(reactExports.isValidElement(t3.children) && t3.children.props);
  }), []), reactExports.useEffect(() => (t2.pauseOnFocusLoss && (document.hasFocus() || C2(), window.addEventListener("focus", E3), window.addEventListener("blur", C2)), () => {
    t2.pauseOnFocusLoss && (window.removeEventListener("focus", E3), window.removeEventListener("blur", C2));
  }), [t2.pauseOnFocusLoss]);
  const O2 = { onMouseDown: v4, onTouchStart: v4, onMouseUp: T2, onTouchEnd: T2 };
  return m2 && f4 && (O2.onMouseEnter = C2, O2.onMouseLeave = E3), y3 && (O2.onClick = (t3) => {
    h5 && h5(t3), u3.canCloseOnClick && g3();
  }), { playToast: E3, pauseToast: C2, isRunning: o2, preventExitTransition: r2, toastRef: c2, eventHandlers: O2 };
}
function L$1(e2) {
  let { closeToast: n4, theme: o2, ariaLabel: s3 = "close" } = e2;
  return React$1.createElement("button", { className: `Toastify__close-button Toastify__close-button--${o2}`, type: "button", onClick: (t2) => {
    t2.stopPropagation(), n4(t2);
  }, "aria-label": s3 }, React$1.createElement("svg", { "aria-hidden": "true", viewBox: "0 0 14 16" }, React$1.createElement("path", { fillRule: "evenodd", d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z" })));
}
function O$1(e2) {
  let { delay: n4, isRunning: o2, closeToast: s3, type: a3 = "default", hide: r2, className: i3, style: l2, controlledProgress: u3, progress: d3, rtl: m2, isIn: f4, theme: g3 } = e2;
  const h5 = r2 || u3 && 0 === d3, y3 = { ...l2, animationDuration: `${n4}ms`, animationPlayState: o2 ? "running" : "paused", opacity: h5 ? 0 : 1 };
  u3 && (y3.transform = `scaleX(${d3})`);
  const v4 = clsx("Toastify__progress-bar", u3 ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${g3}`, `Toastify__progress-bar--${a3}`, { "Toastify__progress-bar--rtl": m2 }), T2 = p$1(i3) ? i3({ rtl: m2, type: a3, defaultClassName: v4 }) : clsx(v4, i3);
  return React$1.createElement("div", { role: "progressbar", "aria-hidden": h5 ? "true" : "false", "aria-label": "notification timer", className: T2, style: y3, [u3 && d3 >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: u3 && d3 < 1 ? null : () => {
    f4 && s3();
  } });
}
const N$1 = (n4) => {
  const { isRunning: o2, preventExitTransition: s3, toastRef: r2, eventHandlers: i3 } = _(n4), { closeButton: l2, children: u3, autoClose: d3, onClick: m2, type: f4, hideProgressBar: g3, closeToast: h5, transition: y3, position: v4, className: T2, style: E3, bodyClassName: C2, bodyStyle: I3, progressClassName: b4, progressStyle: N10, updateId: M3, role: R3, progress: w3, rtl: x2, toastId: $2, deleteToast: k3, isIn: P2, isLoading: B2, iconOut: D2, closeOnClick: A2, theme: z2 } = n4, F2 = clsx("Toastify__toast", `Toastify__toast-theme--${z2}`, `Toastify__toast--${f4}`, { "Toastify__toast--rtl": x2 }, { "Toastify__toast--close-on-click": A2 }), H3 = p$1(T2) ? T2({ rtl: x2, position: v4, type: f4, defaultClassName: F2 }) : clsx(F2, T2), S3 = !!w3 || !d3, q2 = { closeToast: h5, type: f4, theme: z2 };
  let Q3 = null;
  return false === l2 || (Q3 = p$1(l2) ? l2(q2) : reactExports.isValidElement(l2) ? reactExports.cloneElement(l2, q2) : L$1(q2)), React$1.createElement(y3, { isIn: P2, done: k3, position: v4, preventExitTransition: s3, nodeRef: r2 }, React$1.createElement("div", { id: $2, onClick: m2, className: H3, ...i3, style: E3, ref: r2 }, React$1.createElement("div", { ...P2 && { role: R3 }, className: p$1(C2) ? C2({ type: f4 }) : clsx("Toastify__toast-body", C2), style: I3 }, null != D2 && React$1.createElement("div", { className: clsx("Toastify__toast-icon", { "Toastify--animate-icon Toastify__zoom-enter": !B2 }) }, D2), React$1.createElement("div", null, u3)), Q3, React$1.createElement(O$1, { ...M3 && !S3 ? { key: `pb-${M3}` } : {}, rtl: x2, theme: z2, delay: d3, isRunning: o2, isIn: P2, closeToast: h5, hide: g3, type: f4, style: N10, className: b4, controlledProgress: S3, progress: w3 || 0 })));
}, M$1 = function(t2, e2) {
  return void 0 === e2 && (e2 = false), { enter: `Toastify--animate Toastify__${t2}-enter`, exit: `Toastify--animate Toastify__${t2}-exit`, appendPosition: e2 };
}, R$1 = h(M$1("bounce", true));
h(M$1("slide", true));
h(M$1("zoom"));
h(M$1("flip"));
const k = reactExports.forwardRef((e2, n4) => {
  const { getToastToRender: o2, containerRef: a3, isToastActive: r2 } = C$1(e2), { className: i3, style: l2, rtl: u3, containerId: d3 } = e2;
  function f4(t2) {
    const e3 = clsx("Toastify__toast-container", `Toastify__toast-container--${t2}`, { "Toastify__toast-container--rtl": u3 });
    return p$1(i3) ? i3({ position: t2, rtl: u3, defaultClassName: e3 }) : clsx(e3, m$1(i3));
  }
  return reactExports.useEffect(() => {
    n4 && (n4.current = a3.current);
  }, []), React$1.createElement("div", { ref: a3, className: "Toastify", id: d3 }, o2((e3, n5) => {
    const o3 = n5.length ? { ...l2 } : { ...l2, pointerEvents: "none" };
    return React$1.createElement("div", { className: f4(e3), style: o3, key: `container-${e3}` }, n5.map((e4, o4) => {
      let { content: s3, props: a4 } = e4;
      return React$1.createElement(N$1, { ...a4, isIn: r2(a4.toastId), style: { ...a4.style, "--nth": o4 + 1, "--len": n5.length }, key: `toast-${a4.key}` }, s3);
    }));
  }));
});
k.displayName = "ToastContainer", k.defaultProps = { position: "top-right", transition: R$1, autoClose: 5e3, closeButton: L$1, pauseOnHover: true, pauseOnFocusLoss: true, closeOnClick: true, draggable: true, draggablePercent: 80, draggableDirection: "x", role: "alert", theme: "light" };
let P$1, B$1 = /* @__PURE__ */ new Map(), D$1 = [], A$1 = 1;
function z$1() {
  return "" + A$1++;
}
function F(t2) {
  return t2 && (d(t2.toastId) || u(t2.toastId)) ? t2.toastId : z$1();
}
function H$1(t2, e2) {
  return B$1.size > 0 ? v$1.emit(0, t2, e2) : D$1.push({ content: t2, options: e2 }), e2.toastId;
}
function S$1(t2, e2) {
  return { ...e2, type: e2 && e2.type || t2, toastId: F(e2) };
}
function q(t2) {
  return (e2, n4) => H$1(e2, S$1(t2, n4));
}
function Q$1(t2, e2) {
  return H$1(t2, S$1("default", e2));
}
Q$1.loading = (t2, e2) => H$1(t2, S$1("default", { isLoading: true, autoClose: false, closeOnClick: false, closeButton: false, draggable: false, ...e2 })), Q$1.promise = function(t2, e2, n4) {
  let o2, { pending: s3, error: a3, success: r2 } = e2;
  s3 && (o2 = d(s3) ? Q$1.loading(s3, n4) : Q$1.loading(s3.render, { ...n4, ...s3 }));
  const i3 = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null, delay: 100 }, l2 = (t3, e3, s4) => {
    if (null == e3)
      return void Q$1.dismiss(o2);
    const a4 = { type: t3, ...i3, ...n4, data: s4 }, r3 = d(e3) ? { render: e3 } : e3;
    return o2 ? Q$1.update(o2, { ...a4, ...r3 }) : Q$1(r3.render, { ...a4, ...r3 }), s4;
  }, c2 = p$1(t2) ? t2() : t2;
  return c2.then((t3) => l2("success", r2, t3)).catch((t3) => l2("error", a3, t3)), c2;
}, Q$1.success = q("success"), Q$1.info = q("info"), Q$1.error = q("error"), Q$1.warning = q("warning"), Q$1.warn = Q$1.warning, Q$1.dark = (t2, e2) => H$1(t2, S$1("default", { theme: "dark", ...e2 })), Q$1.dismiss = (t2) => {
  B$1.size > 0 ? v$1.emit(1, t2) : D$1 = D$1.filter((e2) => null != t2 && e2.options.toastId !== t2);
}, Q$1.clearWaitingQueue = function(t2) {
  return void 0 === t2 && (t2 = {}), v$1.emit(5, t2);
}, Q$1.isActive = (t2) => {
  let e2 = false;
  return B$1.forEach((n4) => {
    n4.isToastActive && n4.isToastActive(t2) && (e2 = true);
  }), e2;
}, Q$1.update = function(t2, e2) {
  void 0 === e2 && (e2 = {}), setTimeout(() => {
    const n4 = function(t3, e3) {
      let { containerId: n5 } = e3;
      const o2 = B$1.get(n5 || P$1);
      return o2 && o2.getToast(t3);
    }(t2, e2);
    if (n4) {
      const { props: o2, content: s3 } = n4, a3 = { ...o2, ...e2, toastId: e2.toastId || t2, updateId: z$1() };
      a3.toastId !== t2 && (a3.staleId = t2);
      const r2 = a3.render || s3;
      delete a3.render, H$1(r2, a3);
    }
  }, 0);
}, Q$1.done = (t2) => {
  Q$1.update(t2, { progress: 1 });
}, Q$1.onChange = (t2) => (v$1.on(4, t2), () => {
  v$1.off(4, t2);
}), Q$1.POSITION = { TOP_LEFT: "top-left", TOP_RIGHT: "top-right", TOP_CENTER: "top-center", BOTTOM_LEFT: "bottom-left", BOTTOM_RIGHT: "bottom-right", BOTTOM_CENTER: "bottom-center" }, Q$1.TYPE = { INFO: "info", SUCCESS: "success", WARNING: "warning", ERROR: "error", DEFAULT: "default" }, v$1.on(2, (t2) => {
  P$1 = t2.containerId || t2, B$1.set(P$1, t2), D$1.forEach((t3) => {
    v$1.emit(0, t3.content, t3.options);
  }), D$1 = [];
}).on(3, (t2) => {
  B$1.delete(t2.containerId || t2), 0 === B$1.size && v$1.off(0).off(1).off(5);
});
const Home = React$1.lazy(() => __vitePreload(() => import("./home-969263c5.js"), true ? ["assets/home-969263c5.js","assets/TokenFilterForm.module-4a5a5329.js","assets/TokenFilterForm-39f442cf.css","assets/Header-e493a732.js","assets/react-markdown-6591dae8.js","assets/index.esm-ffcadc9d.js","assets/home-d99d1f4c.css"] : void 0));
const New = React$1.lazy(() => __vitePreload(() => import("./new-2a4ae3e8.js"), true ? ["assets/new-2a4ae3e8.js","assets/index.esm-ffcadc9d.js","assets/Header-e493a732.js","assets/TokenFilterForm.module-4a5a5329.js","assets/TokenFilterForm-39f442cf.css","assets/MaxForm-24329240.js","assets/ThreeDScene-d471941e.js","assets/react-markdown-6591dae8.js","assets/SubmitButton-890014ea.js","assets/new-7a9928e8.css"] : void 0));
const View = React$1.lazy(() => __vitePreload(() => import("./view-80068ff7.js"), true ? ["assets/view-80068ff7.js","assets/react-markdown-6591dae8.js","assets/TokenFilterForm.module-4a5a5329.js","assets/TokenFilterForm-39f442cf.css","assets/HomeLink-813a91a1.js","assets/ThreeDScene-d471941e.js","assets/view-f623cdf0.css"] : void 0));
const Edit = React$1.lazy(() => __vitePreload(() => import("./edit-eed9d162.js"), true ? ["assets/edit-eed9d162.js","assets/TokenFilterForm.module-4a5a5329.js","assets/TokenFilterForm-39f442cf.css","assets/MaxForm-24329240.js","assets/index.esm-ffcadc9d.js","assets/ThreeDScene-d471941e.js","assets/react-markdown-6591dae8.js","assets/SubmitButton-890014ea.js","assets/HomeLink-813a91a1.js"] : void 0));
const Disburse = React$1.lazy(() => __vitePreload(() => import("./disburse-24122024.js"), true ? ["assets/disburse-24122024.js","assets/TokenFilterForm.module-4a5a5329.js","assets/TokenFilterForm-39f442cf.css","assets/HomeLink-813a91a1.js","assets/disburse-dccb2b7a.css"] : void 0));
const SelfMint = React$1.lazy(() => __vitePreload(() => import("./self-mint-75e02567.js"), true ? ["assets/self-mint-75e02567.js","assets/TokenFilterForm.module-4a5a5329.js","assets/TokenFilterForm-39f442cf.css","assets/view-80068ff7.js","assets/react-markdown-6591dae8.js","assets/HomeLink-813a91a1.js","assets/ThreeDScene-d471941e.js","assets/view-f623cdf0.css","assets/SubmitButton-890014ea.js"] : void 0));
const Owners = React$1.lazy(() => __vitePreload(() => import("./owners-91c5070d.js"), true ? ["assets/owners-91c5070d.js","assets/BulkDisbursableNFTs.address-1d795b30.js","assets/TokenFilterForm.module-4a5a5329.js","assets/TokenFilterForm-39f442cf.css","assets/HomeLink-813a91a1.js"] : void 0));
const client = new ApolloClient({
  uri: nftGraph,
  cache: new InMemoryCache()
});
const App = () => /* @__PURE__ */ jsxs(Fragment$1, { children: [
  /* @__PURE__ */ jsxs(HelmetExport, { children: [
    /* @__PURE__ */ jsx("link", { rel: "shortcut icon", href: "favicon.svg" }),
    /* @__PURE__ */ jsx(
      "meta",
      {
        name: "viewport",
        content: "width=device-width, initial-scale=1.0"
      }
    )
  ] }),
  /* @__PURE__ */ jsx(ApolloProvider, { ...{ client }, children: /* @__PURE__ */ jsx(Web3ContextProvider, { children: /* @__PURE__ */ jsx(React$1.Suspense, { fallback: /* @__PURE__ */ jsx(Spinner, {}), children: /* @__PURE__ */ jsx(HashRouter, { children: /* @__PURE__ */ jsxs(Routes, { children: [
    /* @__PURE__ */ jsx(Route, { path: "/new", element: /* @__PURE__ */ jsx(New, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/view/:nftId", element: /* @__PURE__ */ jsx(View, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/self-mint/:nftId", element: /* @__PURE__ */ jsx(SelfMint, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/disburse/:nftId", element: /* @__PURE__ */ jsx(Disburse, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/owners/:nftId", element: /* @__PURE__ */ jsx(Owners, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/edit/:nftId", element: /* @__PURE__ */ jsx(Edit, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/", element: /* @__PURE__ */ jsx(Home, {}) })
  ] }) }) }) }) }),
  /* @__PURE__ */ jsx(
    k,
    {
      position: "bottom-center",
      autoClose: 15e3,
      closeOnClick: true,
      pauseOnHover: true
    }
  )
] });
var reactDom$1 = { exports: {} };
var reactDom_production_min$1 = {};
var scheduler$1 = { exports: {} };
var scheduler_production_min$2 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports2) {
  function f4(a3, b4) {
    var c2 = a3.length;
    a3.push(b4);
    a:
      for (; 0 < c2; ) {
        var d3 = c2 - 1 >>> 1, e2 = a3[d3];
        if (0 < g3(e2, b4))
          a3[d3] = b4, a3[c2] = e2, c2 = d3;
        else
          break a;
      }
  }
  function h5(a3) {
    return 0 === a3.length ? null : a3[0];
  }
  function k3(a3) {
    if (0 === a3.length)
      return null;
    var b4 = a3[0], c2 = a3.pop();
    if (c2 !== b4) {
      a3[0] = c2;
      a:
        for (var d3 = 0, e2 = a3.length, w3 = e2 >>> 1; d3 < w3; ) {
          var m2 = 2 * (d3 + 1) - 1, C2 = a3[m2], n4 = m2 + 1, x2 = a3[n4];
          if (0 > g3(C2, c2))
            n4 < e2 && 0 > g3(x2, C2) ? (a3[d3] = x2, a3[n4] = c2, d3 = n4) : (a3[d3] = C2, a3[m2] = c2, d3 = m2);
          else if (n4 < e2 && 0 > g3(x2, c2))
            a3[d3] = x2, a3[n4] = c2, d3 = n4;
          else
            break a;
        }
    }
    return b4;
  }
  function g3(a3, b4) {
    var c2 = a3.sortIndex - b4.sortIndex;
    return 0 !== c2 ? c2 : a3.id - b4.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports2.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p3 = Date, q2 = p3.now();
    exports2.unstable_now = function() {
      return p3.now() - q2;
    };
  }
  var r2 = [], t2 = [], u3 = 1, v4 = null, y3 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E3 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a3) {
    for (var b4 = h5(t2); null !== b4; ) {
      if (null === b4.callback)
        k3(t2);
      else if (b4.startTime <= a3)
        k3(t2), b4.sortIndex = b4.expirationTime, f4(r2, b4);
      else
        break;
      b4 = h5(t2);
    }
  }
  function H3(a3) {
    B2 = false;
    G2(a3);
    if (!A2)
      if (null !== h5(r2))
        A2 = true, I3(J2);
      else {
        var b4 = h5(t2);
        null !== b4 && K3(H3, b4.startTime - a3);
      }
  }
  function J2(a3, b4) {
    A2 = false;
    B2 && (B2 = false, E3(L3), L3 = -1);
    z2 = true;
    var c2 = y3;
    try {
      G2(b4);
      for (v4 = h5(r2); null !== v4 && (!(v4.expirationTime > b4) || a3 && !M3()); ) {
        var d3 = v4.callback;
        if ("function" === typeof d3) {
          v4.callback = null;
          y3 = v4.priorityLevel;
          var e2 = d3(v4.expirationTime <= b4);
          b4 = exports2.unstable_now();
          "function" === typeof e2 ? v4.callback = e2 : v4 === h5(r2) && k3(r2);
          G2(b4);
        } else
          k3(r2);
        v4 = h5(r2);
      }
      if (null !== v4)
        var w3 = true;
      else {
        var m2 = h5(t2);
        null !== m2 && K3(H3, m2.startTime - b4);
        w3 = false;
      }
      return w3;
    } finally {
      v4 = null, y3 = c2, z2 = false;
    }
  }
  var N10 = false, O2 = null, L3 = -1, P2 = 5, Q3 = -1;
  function M3() {
    return exports2.unstable_now() - Q3 < P2 ? false : true;
  }
  function R3() {
    if (null !== O2) {
      var a3 = exports2.unstable_now();
      Q3 = a3;
      var b4 = true;
      try {
        b4 = O2(true, a3);
      } finally {
        b4 ? S3() : (N10 = false, O2 = null);
      }
    } else
      N10 = false;
  }
  var S3;
  if ("function" === typeof F2)
    S3 = function() {
      F2(R3);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R3;
    S3 = function() {
      U2.postMessage(null);
    };
  } else
    S3 = function() {
      D2(R3, 0);
    };
  function I3(a3) {
    O2 = a3;
    N10 || (N10 = true, S3());
  }
  function K3(a3, b4) {
    L3 = D2(function() {
      a3(exports2.unstable_now());
    }, b4);
  }
  exports2.unstable_IdlePriority = 5;
  exports2.unstable_ImmediatePriority = 1;
  exports2.unstable_LowPriority = 4;
  exports2.unstable_NormalPriority = 3;
  exports2.unstable_Profiling = null;
  exports2.unstable_UserBlockingPriority = 2;
  exports2.unstable_cancelCallback = function(a3) {
    a3.callback = null;
  };
  exports2.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I3(J2));
  };
  exports2.unstable_forceFrameRate = function(a3) {
    0 > a3 || 125 < a3 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a3 ? Math.floor(1e3 / a3) : 5;
  };
  exports2.unstable_getCurrentPriorityLevel = function() {
    return y3;
  };
  exports2.unstable_getFirstCallbackNode = function() {
    return h5(r2);
  };
  exports2.unstable_next = function(a3) {
    switch (y3) {
      case 1:
      case 2:
      case 3:
        var b4 = 3;
        break;
      default:
        b4 = y3;
    }
    var c2 = y3;
    y3 = b4;
    try {
      return a3();
    } finally {
      y3 = c2;
    }
  };
  exports2.unstable_pauseExecution = function() {
  };
  exports2.unstable_requestPaint = function() {
  };
  exports2.unstable_runWithPriority = function(a3, b4) {
    switch (a3) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a3 = 3;
    }
    var c2 = y3;
    y3 = a3;
    try {
      return b4();
    } finally {
      y3 = c2;
    }
  };
  exports2.unstable_scheduleCallback = function(a3, b4, c2) {
    var d3 = exports2.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d3 + c2 : d3) : c2 = d3;
    switch (a3) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a3 = { id: u3++, callback: b4, priorityLevel: a3, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d3 ? (a3.sortIndex = c2, f4(t2, a3), null === h5(r2) && a3 === h5(t2) && (B2 ? (E3(L3), L3 = -1) : B2 = true, K3(H3, c2 - d3))) : (a3.sortIndex = e2, f4(r2, a3), A2 || z2 || (A2 = true, I3(J2)));
    return a3;
  };
  exports2.unstable_shouldYield = M3;
  exports2.unstable_wrapCallback = function(a3) {
    var b4 = y3;
    return function() {
      var c2 = y3;
      y3 = b4;
      try {
        return a3.apply(this, arguments);
      } finally {
        y3 = c2;
      }
    };
  };
})(scheduler_production_min$2);
const scheduler_production_min = /* @__PURE__ */ getDefaultExportFromCjs(scheduler_production_min$2);
const scheduler_production_min$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: scheduler_production_min
}, [scheduler_production_min$2]);
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(scheduler_production_min$1);
{
  scheduler$1.exports = require$$0$2;
}
var schedulerExports = scheduler$1.exports;
const index$1 = /* @__PURE__ */ getDefaultExportFromCjs(schedulerExports);
const scheduler = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$1
}, [schedulerExports]);
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(scheduler);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = require$$0$1z, ca = require$$1;
function p(a3) {
  for (var b4 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a3, c2 = 1; c2 < arguments.length; c2++)
    b4 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a3 + "; visit " + b4 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a3, b4) {
  ha(a3, b4);
  ha(a3 + "Capture", b4);
}
function ha(a3, b4) {
  ea[a3] = b4;
  for (a3 = 0; a3 < b4.length; a3++)
    da.add(b4[a3]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a3) {
  if (ja.call(ma, a3))
    return true;
  if (ja.call(la, a3))
    return false;
  if (ka.test(a3))
    return ma[a3] = true;
  la[a3] = true;
  return false;
}
function pa(a3, b4, c2, d3) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b4) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d3)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a3 = a3.toLowerCase().slice(0, 5);
      return "data-" !== a3 && "aria-" !== a3;
    default:
      return false;
  }
}
function qa(a3, b4, c2, d3) {
  if (null === b4 || "undefined" === typeof b4 || pa(a3, b4, c2, d3))
    return true;
  if (d3)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b4;
      case 4:
        return false === b4;
      case 5:
        return isNaN(b4);
      case 6:
        return isNaN(b4) || 1 > b4;
    }
  return false;
}
function v(a3, b4, c2, d3, e2, f4, g3) {
  this.acceptsBooleans = 2 === b4 || 3 === b4 || 4 === b4;
  this.attributeName = d3;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a3;
  this.type = b4;
  this.sanitizeURL = f4;
  this.removeEmptyString = g3;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a3) {
  z[a3] = new v(a3, 0, false, a3, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a3) {
  var b4 = a3[0];
  z[b4] = new v(b4, 1, false, a3[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a3) {
  z[a3] = new v(a3, 2, false, a3.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a3) {
  z[a3] = new v(a3, 2, false, a3, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a3) {
  z[a3] = new v(a3, 3, false, a3.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a3) {
  z[a3] = new v(a3, 3, true, a3, null, false, false);
});
["capture", "download"].forEach(function(a3) {
  z[a3] = new v(a3, 4, false, a3, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a3) {
  z[a3] = new v(a3, 6, false, a3, null, false, false);
});
["rowSpan", "start"].forEach(function(a3) {
  z[a3] = new v(a3, 5, false, a3.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a3) {
  return a3[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a3) {
  var b4 = a3.replace(
    ra,
    sa
  );
  z[b4] = new v(b4, 1, false, a3, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a3) {
  var b4 = a3.replace(ra, sa);
  z[b4] = new v(b4, 1, false, a3, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a3) {
  var b4 = a3.replace(ra, sa);
  z[b4] = new v(b4, 1, false, a3, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a3) {
  z[a3] = new v(a3, 1, false, a3.toLowerCase(), null, false, false);
});
z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a3) {
  z[a3] = new v(a3, 1, false, a3.toLowerCase(), null, true, true);
});
function ta(a3, b4, c2, d3) {
  var e2 = z.hasOwnProperty(b4) ? z[b4] : null;
  if (null !== e2 ? 0 !== e2.type : d3 || !(2 < b4.length) || "o" !== b4[0] && "O" !== b4[0] || "n" !== b4[1] && "N" !== b4[1])
    qa(b4, c2, e2, d3) && (c2 = null), d3 || null === e2 ? oa(b4) && (null === c2 ? a3.removeAttribute(b4) : a3.setAttribute(b4, "" + c2)) : e2.mustUseProperty ? a3[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b4 = e2.attributeName, d3 = e2.attributeNamespace, null === c2 ? a3.removeAttribute(b4) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d3 ? a3.setAttributeNS(d3, b4, c2) : a3.setAttribute(b4, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a3) {
  if (null === a3 || "object" !== typeof a3)
    return null;
  a3 = Ja && a3[Ja] || a3["@@iterator"];
  return "function" === typeof a3 ? a3 : null;
}
var A = Object.assign, La;
function Ma(a3) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b4 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b4 && b4[1] || "";
    }
  return "\n" + La + a3;
}
var Na = false;
function Oa(a3, b4) {
  if (!a3 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b4)
      if (b4 = function() {
        throw Error();
      }, Object.defineProperty(b4.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b4, []);
        } catch (l2) {
          var d3 = l2;
        }
        Reflect.construct(a3, [], b4);
      } else {
        try {
          b4.call();
        } catch (l2) {
          d3 = l2;
        }
        a3.call(b4.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d3 = l2;
      }
      a3();
    }
  } catch (l2) {
    if (l2 && d3 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f4 = d3.stack.split("\n"), g3 = e2.length - 1, h5 = f4.length - 1; 1 <= g3 && 0 <= h5 && e2[g3] !== f4[h5]; )
        h5--;
      for (; 1 <= g3 && 0 <= h5; g3--, h5--)
        if (e2[g3] !== f4[h5]) {
          if (1 !== g3 || 1 !== h5) {
            do
              if (g3--, h5--, 0 > h5 || e2[g3] !== f4[h5]) {
                var k3 = "\n" + e2[g3].replace(" at new ", " at ");
                a3.displayName && k3.includes("<anonymous>") && (k3 = k3.replace("<anonymous>", a3.displayName));
                return k3;
              }
            while (1 <= g3 && 0 <= h5);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a3 = a3 ? a3.displayName || a3.name : "") ? Ma(a3) : "";
}
function Pa(a3) {
  switch (a3.tag) {
    case 5:
      return Ma(a3.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a3 = Oa(a3.type, false), a3;
    case 11:
      return a3 = Oa(a3.type.render, false), a3;
    case 1:
      return a3 = Oa(a3.type, true), a3;
    default:
      return "";
  }
}
function Qa(a3) {
  if (null == a3)
    return null;
  if ("function" === typeof a3)
    return a3.displayName || a3.name || null;
  if ("string" === typeof a3)
    return a3;
  switch (a3) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a3)
    switch (a3.$$typeof) {
      case Ca:
        return (a3.displayName || "Context") + ".Consumer";
      case Ba:
        return (a3._context.displayName || "Context") + ".Provider";
      case Da:
        var b4 = a3.render;
        a3 = a3.displayName;
        a3 || (a3 = b4.displayName || b4.name || "", a3 = "" !== a3 ? "ForwardRef(" + a3 + ")" : "ForwardRef");
        return a3;
      case Ga:
        return b4 = a3.displayName || null, null !== b4 ? b4 : Qa(a3.type) || "Memo";
      case Ha:
        b4 = a3._payload;
        a3 = a3._init;
        try {
          return Qa(a3(b4));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a3) {
  var b4 = a3.type;
  switch (a3.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b4.displayName || "Context") + ".Consumer";
    case 10:
      return (b4._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a3 = b4.render, a3 = a3.displayName || a3.name || "", b4.displayName || ("" !== a3 ? "ForwardRef(" + a3 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b4;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b4);
    case 8:
      return b4 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b4)
        return b4.displayName || b4.name || null;
      if ("string" === typeof b4)
        return b4;
  }
  return null;
}
function Sa(a3) {
  switch (typeof a3) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a3;
    case "object":
      return a3;
    default:
      return "";
  }
}
function Ta(a3) {
  var b4 = a3.type;
  return (a3 = a3.nodeName) && "input" === a3.toLowerCase() && ("checkbox" === b4 || "radio" === b4);
}
function Ua(a3) {
  var b4 = Ta(a3) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a3.constructor.prototype, b4), d3 = "" + a3[b4];
  if (!a3.hasOwnProperty(b4) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f4 = c2.set;
    Object.defineProperty(a3, b4, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a4) {
      d3 = "" + a4;
      f4.call(this, a4);
    } });
    Object.defineProperty(a3, b4, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d3;
    }, setValue: function(a4) {
      d3 = "" + a4;
    }, stopTracking: function() {
      a3._valueTracker = null;
      delete a3[b4];
    } };
  }
}
function Va(a3) {
  a3._valueTracker || (a3._valueTracker = Ua(a3));
}
function Wa(a3) {
  if (!a3)
    return false;
  var b4 = a3._valueTracker;
  if (!b4)
    return true;
  var c2 = b4.getValue();
  var d3 = "";
  a3 && (d3 = Ta(a3) ? a3.checked ? "true" : "false" : a3.value);
  a3 = d3;
  return a3 !== c2 ? (b4.setValue(a3), true) : false;
}
function Xa(a3) {
  a3 = a3 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a3)
    return null;
  try {
    return a3.activeElement || a3.body;
  } catch (b4) {
    return a3.body;
  }
}
function Ya(a3, b4) {
  var c2 = b4.checked;
  return A({}, b4, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a3._wrapperState.initialChecked });
}
function Za(a3, b4) {
  var c2 = null == b4.defaultValue ? "" : b4.defaultValue, d3 = null != b4.checked ? b4.checked : b4.defaultChecked;
  c2 = Sa(null != b4.value ? b4.value : c2);
  a3._wrapperState = { initialChecked: d3, initialValue: c2, controlled: "checkbox" === b4.type || "radio" === b4.type ? null != b4.checked : null != b4.value };
}
function ab(a3, b4) {
  b4 = b4.checked;
  null != b4 && ta(a3, "checked", b4, false);
}
function bb(a3, b4) {
  ab(a3, b4);
  var c2 = Sa(b4.value), d3 = b4.type;
  if (null != c2)
    if ("number" === d3) {
      if (0 === c2 && "" === a3.value || a3.value != c2)
        a3.value = "" + c2;
    } else
      a3.value !== "" + c2 && (a3.value = "" + c2);
  else if ("submit" === d3 || "reset" === d3) {
    a3.removeAttribute("value");
    return;
  }
  b4.hasOwnProperty("value") ? cb(a3, b4.type, c2) : b4.hasOwnProperty("defaultValue") && cb(a3, b4.type, Sa(b4.defaultValue));
  null == b4.checked && null != b4.defaultChecked && (a3.defaultChecked = !!b4.defaultChecked);
}
function db(a3, b4, c2) {
  if (b4.hasOwnProperty("value") || b4.hasOwnProperty("defaultValue")) {
    var d3 = b4.type;
    if (!("submit" !== d3 && "reset" !== d3 || void 0 !== b4.value && null !== b4.value))
      return;
    b4 = "" + a3._wrapperState.initialValue;
    c2 || b4 === a3.value || (a3.value = b4);
    a3.defaultValue = b4;
  }
  c2 = a3.name;
  "" !== c2 && (a3.name = "");
  a3.defaultChecked = !!a3._wrapperState.initialChecked;
  "" !== c2 && (a3.name = c2);
}
function cb(a3, b4, c2) {
  if ("number" !== b4 || Xa(a3.ownerDocument) !== a3)
    null == c2 ? a3.defaultValue = "" + a3._wrapperState.initialValue : a3.defaultValue !== "" + c2 && (a3.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a3, b4, c2, d3) {
  a3 = a3.options;
  if (b4) {
    b4 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b4["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a3.length; c2++)
      e2 = b4.hasOwnProperty("$" + a3[c2].value), a3[c2].selected !== e2 && (a3[c2].selected = e2), e2 && d3 && (a3[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b4 = null;
    for (e2 = 0; e2 < a3.length; e2++) {
      if (a3[e2].value === c2) {
        a3[e2].selected = true;
        d3 && (a3[e2].defaultSelected = true);
        return;
      }
      null !== b4 || a3[e2].disabled || (b4 = a3[e2]);
    }
    null !== b4 && (b4.selected = true);
  }
}
function gb(a3, b4) {
  if (null != b4.dangerouslySetInnerHTML)
    throw Error(p(91));
  return A({}, b4, { value: void 0, defaultValue: void 0, children: "" + a3._wrapperState.initialValue });
}
function hb(a3, b4) {
  var c2 = b4.value;
  if (null == c2) {
    c2 = b4.children;
    b4 = b4.defaultValue;
    if (null != c2) {
      if (null != b4)
        throw Error(p(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p(93));
        c2 = c2[0];
      }
      b4 = c2;
    }
    null == b4 && (b4 = "");
    c2 = b4;
  }
  a3._wrapperState = { initialValue: Sa(c2) };
}
function ib(a3, b4) {
  var c2 = Sa(b4.value), d3 = Sa(b4.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a3.value && (a3.value = c2), null == b4.defaultValue && a3.defaultValue !== c2 && (a3.defaultValue = c2));
  null != d3 && (a3.defaultValue = "" + d3);
}
function jb(a3) {
  var b4 = a3.textContent;
  b4 === a3._wrapperState.initialValue && "" !== b4 && null !== b4 && (a3.value = b4);
}
function kb(a3) {
  switch (a3) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a3, b4) {
  return null == a3 || "http://www.w3.org/1999/xhtml" === a3 ? kb(b4) : "http://www.w3.org/2000/svg" === a3 && "foreignObject" === b4 ? "http://www.w3.org/1999/xhtml" : a3;
}
var mb, nb = function(a3) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b4, c2, d3, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a3(b4, c2, d3, e2);
    });
  } : a3;
}(function(a3, b4) {
  if ("http://www.w3.org/2000/svg" !== a3.namespaceURI || "innerHTML" in a3)
    a3.innerHTML = b4;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b4.valueOf().toString() + "</svg>";
    for (b4 = mb.firstChild; a3.firstChild; )
      a3.removeChild(a3.firstChild);
    for (; b4.firstChild; )
      a3.appendChild(b4.firstChild);
  }
});
function ob(a3, b4) {
  if (b4) {
    var c2 = a3.firstChild;
    if (c2 && c2 === a3.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b4;
      return;
    }
  }
  a3.textContent = b4;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a3) {
  qb.forEach(function(b4) {
    b4 = b4 + a3.charAt(0).toUpperCase() + a3.substring(1);
    pb[b4] = pb[a3];
  });
});
function rb(a3, b4, c2) {
  return null == b4 || "boolean" === typeof b4 || "" === b4 ? "" : c2 || "number" !== typeof b4 || 0 === b4 || pb.hasOwnProperty(a3) && pb[a3] ? ("" + b4).trim() : b4 + "px";
}
function sb(a3, b4) {
  a3 = a3.style;
  for (var c2 in b4)
    if (b4.hasOwnProperty(c2)) {
      var d3 = 0 === c2.indexOf("--"), e2 = rb(c2, b4[c2], d3);
      "float" === c2 && (c2 = "cssFloat");
      d3 ? a3.setProperty(c2, e2) : a3[c2] = e2;
    }
}
var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a3, b4) {
  if (b4) {
    if (tb[a3] && (null != b4.children || null != b4.dangerouslySetInnerHTML))
      throw Error(p(137, a3));
    if (null != b4.dangerouslySetInnerHTML) {
      if (null != b4.children)
        throw Error(p(60));
      if ("object" !== typeof b4.dangerouslySetInnerHTML || !("__html" in b4.dangerouslySetInnerHTML))
        throw Error(p(61));
    }
    if (null != b4.style && "object" !== typeof b4.style)
      throw Error(p(62));
  }
}
function vb(a3, b4) {
  if (-1 === a3.indexOf("-"))
    return "string" === typeof b4.is;
  switch (a3) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a3) {
  a3 = a3.target || a3.srcElement || window;
  a3.correspondingUseElement && (a3 = a3.correspondingUseElement);
  return 3 === a3.nodeType ? a3.parentNode : a3;
}
var yb = null, zb = null, Ab = null;
function Bb(a3) {
  if (a3 = Cb(a3)) {
    if ("function" !== typeof yb)
      throw Error(p(280));
    var b4 = a3.stateNode;
    b4 && (b4 = Db(b4), yb(a3.stateNode, a3.type, b4));
  }
}
function Eb(a3) {
  zb ? Ab ? Ab.push(a3) : Ab = [a3] : zb = a3;
}
function Fb() {
  if (zb) {
    var a3 = zb, b4 = Ab;
    Ab = zb = null;
    Bb(a3);
    if (b4)
      for (a3 = 0; a3 < b4.length; a3++)
        Bb(b4[a3]);
  }
}
function Gb(a3, b4) {
  return a3(b4);
}
function Hb() {
}
var Ib = false;
function Jb(a3, b4, c2) {
  if (Ib)
    return a3(b4, c2);
  Ib = true;
  try {
    return Gb(a3, b4, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a3, b4) {
  var c2 = a3.stateNode;
  if (null === c2)
    return null;
  var d3 = Db(c2);
  if (null === d3)
    return null;
  c2 = d3[b4];
  a:
    switch (b4) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d3 = !d3.disabled) || (a3 = a3.type, d3 = !("button" === a3 || "input" === a3 || "select" === a3 || "textarea" === a3));
        a3 = !d3;
        break a;
      default:
        a3 = false;
    }
  if (a3)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p(231, b4, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a3) {
    Lb = false;
  }
function Nb(a3, b4, c2, d3, e2, f4, g3, h5, k3) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b4.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a3) {
  Ob = true;
  Pb = a3;
} };
function Tb(a3, b4, c2, d3, e2, f4, g3, h5, k3) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a3, b4, c2, d3, e2, f4, g3, h5, k3) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a3) {
  var b4 = a3, c2 = a3;
  if (a3.alternate)
    for (; b4.return; )
      b4 = b4.return;
  else {
    a3 = b4;
    do
      b4 = a3, 0 !== (b4.flags & 4098) && (c2 = b4.return), a3 = b4.return;
    while (a3);
  }
  return 3 === b4.tag ? c2 : null;
}
function Wb(a3) {
  if (13 === a3.tag) {
    var b4 = a3.memoizedState;
    null === b4 && (a3 = a3.alternate, null !== a3 && (b4 = a3.memoizedState));
    if (null !== b4)
      return b4.dehydrated;
  }
  return null;
}
function Xb(a3) {
  if (Vb(a3) !== a3)
    throw Error(p(188));
}
function Yb(a3) {
  var b4 = a3.alternate;
  if (!b4) {
    b4 = Vb(a3);
    if (null === b4)
      throw Error(p(188));
    return b4 !== a3 ? null : a3;
  }
  for (var c2 = a3, d3 = b4; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f4 = e2.alternate;
    if (null === f4) {
      d3 = e2.return;
      if (null !== d3) {
        c2 = d3;
        continue;
      }
      break;
    }
    if (e2.child === f4.child) {
      for (f4 = e2.child; f4; ) {
        if (f4 === c2)
          return Xb(e2), a3;
        if (f4 === d3)
          return Xb(e2), b4;
        f4 = f4.sibling;
      }
      throw Error(p(188));
    }
    if (c2.return !== d3.return)
      c2 = e2, d3 = f4;
    else {
      for (var g3 = false, h5 = e2.child; h5; ) {
        if (h5 === c2) {
          g3 = true;
          c2 = e2;
          d3 = f4;
          break;
        }
        if (h5 === d3) {
          g3 = true;
          d3 = e2;
          c2 = f4;
          break;
        }
        h5 = h5.sibling;
      }
      if (!g3) {
        for (h5 = f4.child; h5; ) {
          if (h5 === c2) {
            g3 = true;
            c2 = f4;
            d3 = e2;
            break;
          }
          if (h5 === d3) {
            g3 = true;
            d3 = f4;
            c2 = e2;
            break;
          }
          h5 = h5.sibling;
        }
        if (!g3)
          throw Error(p(189));
      }
    }
    if (c2.alternate !== d3)
      throw Error(p(190));
  }
  if (3 !== c2.tag)
    throw Error(p(188));
  return c2.stateNode.current === c2 ? a3 : b4;
}
function Zb(a3) {
  a3 = Yb(a3);
  return null !== a3 ? $b(a3) : null;
}
function $b(a3) {
  if (5 === a3.tag || 6 === a3.tag)
    return a3;
  for (a3 = a3.child; null !== a3; ) {
    var b4 = $b(a3);
    if (null !== b4)
      return b4;
    a3 = a3.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a3) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a3, void 0, 128 === (a3.current.flags & 128));
    } catch (b4) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a3) {
  a3 >>>= 0;
  return 0 === a3 ? 32 : 31 - (pc(a3) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a3) {
  switch (a3 & -a3) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a3 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a3 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a3;
  }
}
function uc(a3, b4) {
  var c2 = a3.pendingLanes;
  if (0 === c2)
    return 0;
  var d3 = 0, e2 = a3.suspendedLanes, f4 = a3.pingedLanes, g3 = c2 & 268435455;
  if (0 !== g3) {
    var h5 = g3 & ~e2;
    0 !== h5 ? d3 = tc(h5) : (f4 &= g3, 0 !== f4 && (d3 = tc(f4)));
  } else
    g3 = c2 & ~e2, 0 !== g3 ? d3 = tc(g3) : 0 !== f4 && (d3 = tc(f4));
  if (0 === d3)
    return 0;
  if (0 !== b4 && b4 !== d3 && 0 === (b4 & e2) && (e2 = d3 & -d3, f4 = b4 & -b4, e2 >= f4 || 16 === e2 && 0 !== (f4 & 4194240)))
    return b4;
  0 !== (d3 & 4) && (d3 |= c2 & 16);
  b4 = a3.entangledLanes;
  if (0 !== b4)
    for (a3 = a3.entanglements, b4 &= d3; 0 < b4; )
      c2 = 31 - oc(b4), e2 = 1 << c2, d3 |= a3[c2], b4 &= ~e2;
  return d3;
}
function vc(a3, b4) {
  switch (a3) {
    case 1:
    case 2:
    case 4:
      return b4 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b4 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a3, b4) {
  for (var c2 = a3.suspendedLanes, d3 = a3.pingedLanes, e2 = a3.expirationTimes, f4 = a3.pendingLanes; 0 < f4; ) {
    var g3 = 31 - oc(f4), h5 = 1 << g3, k3 = e2[g3];
    if (-1 === k3) {
      if (0 === (h5 & c2) || 0 !== (h5 & d3))
        e2[g3] = vc(h5, b4);
    } else
      k3 <= b4 && (a3.expiredLanes |= h5);
    f4 &= ~h5;
  }
}
function xc(a3) {
  a3 = a3.pendingLanes & -1073741825;
  return 0 !== a3 ? a3 : a3 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a3 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a3;
}
function zc(a3) {
  for (var b4 = [], c2 = 0; 31 > c2; c2++)
    b4.push(a3);
  return b4;
}
function Ac(a3, b4, c2) {
  a3.pendingLanes |= b4;
  536870912 !== b4 && (a3.suspendedLanes = 0, a3.pingedLanes = 0);
  a3 = a3.eventTimes;
  b4 = 31 - oc(b4);
  a3[b4] = c2;
}
function Bc(a3, b4) {
  var c2 = a3.pendingLanes & ~b4;
  a3.pendingLanes = b4;
  a3.suspendedLanes = 0;
  a3.pingedLanes = 0;
  a3.expiredLanes &= b4;
  a3.mutableReadLanes &= b4;
  a3.entangledLanes &= b4;
  b4 = a3.entanglements;
  var d3 = a3.eventTimes;
  for (a3 = a3.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f4 = 1 << e2;
    b4[e2] = 0;
    d3[e2] = -1;
    a3[e2] = -1;
    c2 &= ~f4;
  }
}
function Cc(a3, b4) {
  var c2 = a3.entangledLanes |= b4;
  for (a3 = a3.entanglements; c2; ) {
    var d3 = 31 - oc(c2), e2 = 1 << d3;
    e2 & b4 | a3[d3] & b4 && (a3[d3] |= b4);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a3) {
  a3 &= -a3;
  return 1 < a3 ? 4 < a3 ? 0 !== (a3 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a3, b4) {
  switch (a3) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b4.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b4.pointerId);
  }
}
function Tc(a3, b4, c2, d3, e2, f4) {
  if (null === a3 || a3.nativeEvent !== f4)
    return a3 = { blockedOn: b4, domEventName: c2, eventSystemFlags: d3, nativeEvent: f4, targetContainers: [e2] }, null !== b4 && (b4 = Cb(b4), null !== b4 && Fc(b4)), a3;
  a3.eventSystemFlags |= d3;
  b4 = a3.targetContainers;
  null !== e2 && -1 === b4.indexOf(e2) && b4.push(e2);
  return a3;
}
function Uc(a3, b4, c2, d3, e2) {
  switch (b4) {
    case "focusin":
      return Lc = Tc(Lc, a3, b4, c2, d3, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a3, b4, c2, d3, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a3, b4, c2, d3, e2), true;
    case "pointerover":
      var f4 = e2.pointerId;
      Oc.set(f4, Tc(Oc.get(f4) || null, a3, b4, c2, d3, e2));
      return true;
    case "gotpointercapture":
      return f4 = e2.pointerId, Pc.set(f4, Tc(Pc.get(f4) || null, a3, b4, c2, d3, e2)), true;
  }
  return false;
}
function Vc(a3) {
  var b4 = Wc(a3.target);
  if (null !== b4) {
    var c2 = Vb(b4);
    if (null !== c2) {
      if (b4 = c2.tag, 13 === b4) {
        if (b4 = Wb(c2), null !== b4) {
          a3.blockedOn = b4;
          Ic(a3.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b4 && c2.stateNode.current.memoizedState.isDehydrated) {
        a3.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a3.blockedOn = null;
}
function Xc(a3) {
  if (null !== a3.blockedOn)
    return false;
  for (var b4 = a3.targetContainers; 0 < b4.length; ) {
    var c2 = Yc(a3.domEventName, a3.eventSystemFlags, b4[0], a3.nativeEvent);
    if (null === c2) {
      c2 = a3.nativeEvent;
      var d3 = new c2.constructor(c2.type, c2);
      wb = d3;
      c2.target.dispatchEvent(d3);
      wb = null;
    } else
      return b4 = Cb(c2), null !== b4 && Fc(b4), a3.blockedOn = c2, false;
    b4.shift();
  }
  return true;
}
function Zc(a3, b4, c2) {
  Xc(a3) && c2.delete(b4);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a3, b4) {
  a3.blockedOn === b4 && (a3.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a3) {
  function b4(b5) {
    return ad(b5, a3);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a3);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d3 = Kc[c2];
      d3.blockedOn === a3 && (d3.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a3);
  null !== Mc && ad(Mc, a3);
  null !== Nc && ad(Nc, a3);
  Oc.forEach(b4);
  Pc.forEach(b4);
  for (c2 = 0; c2 < Qc.length; c2++)
    d3 = Qc[c2], d3.blockedOn === a3 && (d3.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a3, b4, c2, d3) {
  var e2 = C, f4 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a3, b4, c2, d3);
  } finally {
    C = e2, cd.transition = f4;
  }
}
function gd(a3, b4, c2, d3) {
  var e2 = C, f4 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a3, b4, c2, d3);
  } finally {
    C = e2, cd.transition = f4;
  }
}
function fd(a3, b4, c2, d3) {
  if (dd) {
    var e2 = Yc(a3, b4, c2, d3);
    if (null === e2)
      hd(a3, b4, d3, id, c2), Sc(a3, d3);
    else if (Uc(e2, a3, b4, c2, d3))
      d3.stopPropagation();
    else if (Sc(a3, d3), b4 & 4 && -1 < Rc.indexOf(a3)) {
      for (; null !== e2; ) {
        var f4 = Cb(e2);
        null !== f4 && Ec(f4);
        f4 = Yc(a3, b4, c2, d3);
        null === f4 && hd(a3, b4, d3, id, c2);
        if (f4 === e2)
          break;
        e2 = f4;
      }
      null !== e2 && d3.stopPropagation();
    } else
      hd(a3, b4, d3, null, c2);
  }
}
var id = null;
function Yc(a3, b4, c2, d3) {
  id = null;
  a3 = xb(d3);
  a3 = Wc(a3);
  if (null !== a3)
    if (b4 = Vb(a3), null === b4)
      a3 = null;
    else if (c2 = b4.tag, 13 === c2) {
      a3 = Wb(b4);
      if (null !== a3)
        return a3;
      a3 = null;
    } else if (3 === c2) {
      if (b4.stateNode.current.memoizedState.isDehydrated)
        return 3 === b4.tag ? b4.stateNode.containerInfo : null;
      a3 = null;
    } else
      b4 !== a3 && (a3 = null);
  id = a3;
  return null;
}
function jd(a3) {
  switch (a3) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a3, b4 = ld, c2 = b4.length, d3, e2 = "value" in kd ? kd.value : kd.textContent, f4 = e2.length;
  for (a3 = 0; a3 < c2 && b4[a3] === e2[a3]; a3++)
    ;
  var g3 = c2 - a3;
  for (d3 = 1; d3 <= g3 && b4[c2 - d3] === e2[f4 - d3]; d3++)
    ;
  return md = e2.slice(a3, 1 < d3 ? 1 - d3 : void 0);
}
function od(a3) {
  var b4 = a3.keyCode;
  "charCode" in a3 ? (a3 = a3.charCode, 0 === a3 && 13 === b4 && (a3 = 13)) : a3 = b4;
  10 === a3 && (a3 = 13);
  return 32 <= a3 || 13 === a3 ? a3 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a3) {
  function b4(b5, d3, e2, f4, g3) {
    this._reactName = b5;
    this._targetInst = e2;
    this.type = d3;
    this.nativeEvent = f4;
    this.target = g3;
    this.currentTarget = null;
    for (var c2 in a3)
      a3.hasOwnProperty(c2) && (b5 = a3[c2], this[c2] = b5 ? b5(f4) : f4[c2]);
    this.isDefaultPrevented = (null != f4.defaultPrevented ? f4.defaultPrevented : false === f4.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A(b4.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a4 = this.nativeEvent;
    a4 && (a4.preventDefault ? a4.preventDefault() : "unknown" !== typeof a4.returnValue && (a4.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a4 = this.nativeEvent;
    a4 && (a4.stopPropagation ? a4.stopPropagation() : "unknown" !== typeof a4.cancelBubble && (a4.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b4;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a3) {
  return a3.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a3) {
  return void 0 === a3.relatedTarget ? a3.fromElement === a3.srcElement ? a3.toElement : a3.fromElement : a3.relatedTarget;
}, movementX: function(a3) {
  if ("movementX" in a3)
    return a3.movementX;
  a3 !== yd && (yd && "mousemove" === a3.type ? (wd = a3.screenX - yd.screenX, xd = a3.screenY - yd.screenY) : xd = wd = 0, yd = a3);
  return wd;
}, movementY: function(a3) {
  return "movementY" in a3 ? a3.movementY : xd;
} }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a3) {
  return "clipboardData" in a3 ? a3.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a3) {
  var b4 = this.nativeEvent;
  return b4.getModifierState ? b4.getModifierState(a3) : (a3 = Od[a3]) ? !!b4[a3] : false;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, { key: function(a3) {
  if (a3.key) {
    var b4 = Md[a3.key] || a3.key;
    if ("Unidentified" !== b4)
      return b4;
  }
  return "keypress" === a3.type ? (a3 = od(a3), 13 === a3 ? "Enter" : String.fromCharCode(a3)) : "keydown" === a3.type || "keyup" === a3.type ? Nd[a3.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a3) {
  return "keypress" === a3.type ? od(a3) : 0;
}, keyCode: function(a3) {
  return "keydown" === a3.type || "keyup" === a3.type ? a3.keyCode : 0;
}, which: function(a3) {
  return "keypress" === a3.type ? od(a3) : "keydown" === a3.type || "keyup" === a3.type ? a3.keyCode : 0;
} }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
  deltaX: function(a3) {
    return "deltaX" in a3 ? a3.deltaX : "wheelDeltaX" in a3 ? -a3.wheelDeltaX : 0;
  },
  deltaY: function(a3) {
    return "deltaY" in a3 ? a3.deltaY : "wheelDeltaY" in a3 ? -a3.wheelDeltaY : "wheelDelta" in a3 ? -a3.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a3, b4) {
  switch (a3) {
    case "keyup":
      return -1 !== $d.indexOf(b4.keyCode);
    case "keydown":
      return 229 !== b4.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a3) {
  a3 = a3.detail;
  return "object" === typeof a3 && "data" in a3 ? a3.data : null;
}
var ie = false;
function je(a3, b4) {
  switch (a3) {
    case "compositionend":
      return he(b4);
    case "keypress":
      if (32 !== b4.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a3 = b4.data, a3 === ee && fe ? null : a3;
    default:
      return null;
  }
}
function ke(a3, b4) {
  if (ie)
    return "compositionend" === a3 || !ae && ge(a3, b4) ? (a3 = nd(), md = ld = kd = null, ie = false, a3) : null;
  switch (a3) {
    case "paste":
      return null;
    case "keypress":
      if (!(b4.ctrlKey || b4.altKey || b4.metaKey) || b4.ctrlKey && b4.altKey) {
        if (b4.char && 1 < b4.char.length)
          return b4.char;
        if (b4.which)
          return String.fromCharCode(b4.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b4.locale ? null : b4.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a3) {
  var b4 = a3 && a3.nodeName && a3.nodeName.toLowerCase();
  return "input" === b4 ? !!le[a3.type] : "textarea" === b4 ? true : false;
}
function ne(a3, b4, c2, d3) {
  Eb(d3);
  b4 = oe(b4, "onChange");
  0 < b4.length && (c2 = new td("onChange", "change", null, c2, d3), a3.push({ event: c2, listeners: b4 }));
}
var pe = null, qe = null;
function re(a3) {
  se(a3, 0);
}
function te(a3) {
  var b4 = ue(a3);
  if (Wa(b4))
    return a3;
}
function ve(a3, b4) {
  if ("change" === a3)
    return b4;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a3) {
  if ("value" === a3.propertyName && te(qe)) {
    var b4 = [];
    ne(b4, qe, a3, xb(a3));
    Jb(re, b4);
  }
}
function Ce(a3, b4, c2) {
  "focusin" === a3 ? (Ae(), pe = b4, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a3 && Ae();
}
function De(a3) {
  if ("selectionchange" === a3 || "keyup" === a3 || "keydown" === a3)
    return te(qe);
}
function Ee(a3, b4) {
  if ("click" === a3)
    return te(b4);
}
function Fe(a3, b4) {
  if ("input" === a3 || "change" === a3)
    return te(b4);
}
function Ge(a3, b4) {
  return a3 === b4 && (0 !== a3 || 1 / a3 === 1 / b4) || a3 !== a3 && b4 !== b4;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a3, b4) {
  if (He(a3, b4))
    return true;
  if ("object" !== typeof a3 || null === a3 || "object" !== typeof b4 || null === b4)
    return false;
  var c2 = Object.keys(a3), d3 = Object.keys(b4);
  if (c2.length !== d3.length)
    return false;
  for (d3 = 0; d3 < c2.length; d3++) {
    var e2 = c2[d3];
    if (!ja.call(b4, e2) || !He(a3[e2], b4[e2]))
      return false;
  }
  return true;
}
function Je(a3) {
  for (; a3 && a3.firstChild; )
    a3 = a3.firstChild;
  return a3;
}
function Ke(a3, b4) {
  var c2 = Je(a3);
  a3 = 0;
  for (var d3; c2; ) {
    if (3 === c2.nodeType) {
      d3 = a3 + c2.textContent.length;
      if (a3 <= b4 && d3 >= b4)
        return { node: c2, offset: b4 - a3 };
      a3 = d3;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a3, b4) {
  return a3 && b4 ? a3 === b4 ? true : a3 && 3 === a3.nodeType ? false : b4 && 3 === b4.nodeType ? Le(a3, b4.parentNode) : "contains" in a3 ? a3.contains(b4) : a3.compareDocumentPosition ? !!(a3.compareDocumentPosition(b4) & 16) : false : false;
}
function Me() {
  for (var a3 = window, b4 = Xa(); b4 instanceof a3.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b4.contentWindow.location.href;
    } catch (d3) {
      c2 = false;
    }
    if (c2)
      a3 = b4.contentWindow;
    else
      break;
    b4 = Xa(a3.document);
  }
  return b4;
}
function Ne(a3) {
  var b4 = a3 && a3.nodeName && a3.nodeName.toLowerCase();
  return b4 && ("input" === b4 && ("text" === a3.type || "search" === a3.type || "tel" === a3.type || "url" === a3.type || "password" === a3.type) || "textarea" === b4 || "true" === a3.contentEditable);
}
function Oe(a3) {
  var b4 = Me(), c2 = a3.focusedElem, d3 = a3.selectionRange;
  if (b4 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d3 && Ne(c2)) {
      if (b4 = d3.start, a3 = d3.end, void 0 === a3 && (a3 = b4), "selectionStart" in c2)
        c2.selectionStart = b4, c2.selectionEnd = Math.min(a3, c2.value.length);
      else if (a3 = (b4 = c2.ownerDocument || document) && b4.defaultView || window, a3.getSelection) {
        a3 = a3.getSelection();
        var e2 = c2.textContent.length, f4 = Math.min(d3.start, e2);
        d3 = void 0 === d3.end ? f4 : Math.min(d3.end, e2);
        !a3.extend && f4 > d3 && (e2 = d3, d3 = f4, f4 = e2);
        e2 = Ke(c2, f4);
        var g3 = Ke(
          c2,
          d3
        );
        e2 && g3 && (1 !== a3.rangeCount || a3.anchorNode !== e2.node || a3.anchorOffset !== e2.offset || a3.focusNode !== g3.node || a3.focusOffset !== g3.offset) && (b4 = b4.createRange(), b4.setStart(e2.node, e2.offset), a3.removeAllRanges(), f4 > d3 ? (a3.addRange(b4), a3.extend(g3.node, g3.offset)) : (b4.setEnd(g3.node, g3.offset), a3.addRange(b4)));
      }
    }
    b4 = [];
    for (a3 = c2; a3 = a3.parentNode; )
      1 === a3.nodeType && b4.push({ element: a3, left: a3.scrollLeft, top: a3.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b4.length; c2++)
      a3 = b4[c2], a3.element.scrollLeft = a3.left, a3.element.scrollTop = a3.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a3, b4, c2) {
  var d3 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d3) || (d3 = Qe, "selectionStart" in d3 && Ne(d3) ? d3 = { start: d3.selectionStart, end: d3.selectionEnd } : (d3 = (d3.ownerDocument && d3.ownerDocument.defaultView || window).getSelection(), d3 = { anchorNode: d3.anchorNode, anchorOffset: d3.anchorOffset, focusNode: d3.focusNode, focusOffset: d3.focusOffset }), Se && Ie(Se, d3) || (Se = d3, d3 = oe(Re, "onSelect"), 0 < d3.length && (b4 = new td("onSelect", "select", null, b4, c2), a3.push({ event: b4, listeners: d3 }), b4.target = Qe)));
}
function Ve(a3, b4) {
  var c2 = {};
  c2[a3.toLowerCase()] = b4.toLowerCase();
  c2["Webkit" + a3] = "webkit" + b4;
  c2["Moz" + a3] = "moz" + b4;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a3) {
  if (Xe[a3])
    return Xe[a3];
  if (!We[a3])
    return a3;
  var b4 = We[a3], c2;
  for (c2 in b4)
    if (b4.hasOwnProperty(c2) && c2 in Ye)
      return Xe[a3] = b4[c2];
  return a3;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a3, b4) {
  df.set(a3, b4);
  fa(b4, [a3]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a3, b4, c2) {
  var d3 = a3.type || "unknown-event";
  a3.currentTarget = c2;
  Ub(d3, b4, void 0, a3);
  a3.currentTarget = null;
}
function se(a3, b4) {
  b4 = 0 !== (b4 & 4);
  for (var c2 = 0; c2 < a3.length; c2++) {
    var d3 = a3[c2], e2 = d3.event;
    d3 = d3.listeners;
    a: {
      var f4 = void 0;
      if (b4)
        for (var g3 = d3.length - 1; 0 <= g3; g3--) {
          var h5 = d3[g3], k3 = h5.instance, l2 = h5.currentTarget;
          h5 = h5.listener;
          if (k3 !== f4 && e2.isPropagationStopped())
            break a;
          nf(e2, h5, l2);
          f4 = k3;
        }
      else
        for (g3 = 0; g3 < d3.length; g3++) {
          h5 = d3[g3];
          k3 = h5.instance;
          l2 = h5.currentTarget;
          h5 = h5.listener;
          if (k3 !== f4 && e2.isPropagationStopped())
            break a;
          nf(e2, h5, l2);
          f4 = k3;
        }
    }
  }
  if (Qb)
    throw a3 = Rb, Qb = false, Rb = null, a3;
}
function D(a3, b4) {
  var c2 = b4[of];
  void 0 === c2 && (c2 = b4[of] = /* @__PURE__ */ new Set());
  var d3 = a3 + "__bubble";
  c2.has(d3) || (pf(b4, a3, 2, false), c2.add(d3));
}
function qf(a3, b4, c2) {
  var d3 = 0;
  b4 && (d3 |= 4);
  pf(c2, a3, d3, b4);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a3) {
  if (!a3[rf]) {
    a3[rf] = true;
    da.forEach(function(b5) {
      "selectionchange" !== b5 && (mf.has(b5) || qf(b5, false, a3), qf(b5, true, a3));
    });
    var b4 = 9 === a3.nodeType ? a3 : a3.ownerDocument;
    null === b4 || b4[rf] || (b4[rf] = true, qf("selectionchange", false, b4));
  }
}
function pf(a3, b4, c2, d3) {
  switch (jd(b4)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b4, c2, a3);
  e2 = void 0;
  !Lb || "touchstart" !== b4 && "touchmove" !== b4 && "wheel" !== b4 || (e2 = true);
  d3 ? void 0 !== e2 ? a3.addEventListener(b4, c2, { capture: true, passive: e2 }) : a3.addEventListener(b4, c2, true) : void 0 !== e2 ? a3.addEventListener(b4, c2, { passive: e2 }) : a3.addEventListener(b4, c2, false);
}
function hd(a3, b4, c2, d3, e2) {
  var f4 = d3;
  if (0 === (b4 & 1) && 0 === (b4 & 2) && null !== d3)
    a:
      for (; ; ) {
        if (null === d3)
          return;
        var g3 = d3.tag;
        if (3 === g3 || 4 === g3) {
          var h5 = d3.stateNode.containerInfo;
          if (h5 === e2 || 8 === h5.nodeType && h5.parentNode === e2)
            break;
          if (4 === g3)
            for (g3 = d3.return; null !== g3; ) {
              var k3 = g3.tag;
              if (3 === k3 || 4 === k3) {
                if (k3 = g3.stateNode.containerInfo, k3 === e2 || 8 === k3.nodeType && k3.parentNode === e2)
                  return;
              }
              g3 = g3.return;
            }
          for (; null !== h5; ) {
            g3 = Wc(h5);
            if (null === g3)
              return;
            k3 = g3.tag;
            if (5 === k3 || 6 === k3) {
              d3 = f4 = g3;
              continue a;
            }
            h5 = h5.parentNode;
          }
        }
        d3 = d3.return;
      }
  Jb(function() {
    var d4 = f4, e3 = xb(c2), g4 = [];
    a: {
      var h6 = df.get(a3);
      if (void 0 !== h6) {
        var k4 = td, n4 = a3;
        switch (a3) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k4 = Rd;
            break;
          case "focusin":
            n4 = "focus";
            k4 = Fd;
            break;
          case "focusout":
            n4 = "blur";
            k4 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k4 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k4 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k4 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k4 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k4 = Hd;
            break;
          case cf:
            k4 = Xd;
            break;
          case "scroll":
            k4 = vd;
            break;
          case "wheel":
            k4 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k4 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k4 = Td;
        }
        var t2 = 0 !== (b4 & 4), J2 = !t2 && "scroll" === a3, x2 = t2 ? null !== h6 ? h6 + "Capture" : null : h6;
        t2 = [];
        for (var w3 = d4, u3; null !== w3; ) {
          u3 = w3;
          var F2 = u3.stateNode;
          5 === u3.tag && null !== F2 && (u3 = F2, null !== x2 && (F2 = Kb(w3, x2), null != F2 && t2.push(tf(w3, F2, u3))));
          if (J2)
            break;
          w3 = w3.return;
        }
        0 < t2.length && (h6 = new k4(h6, n4, null, c2, e3), g4.push({ event: h6, listeners: t2 }));
      }
    }
    if (0 === (b4 & 7)) {
      a: {
        h6 = "mouseover" === a3 || "pointerover" === a3;
        k4 = "mouseout" === a3 || "pointerout" === a3;
        if (h6 && c2 !== wb && (n4 = c2.relatedTarget || c2.fromElement) && (Wc(n4) || n4[uf]))
          break a;
        if (k4 || h6) {
          h6 = e3.window === e3 ? e3 : (h6 = e3.ownerDocument) ? h6.defaultView || h6.parentWindow : window;
          if (k4) {
            if (n4 = c2.relatedTarget || c2.toElement, k4 = d4, n4 = n4 ? Wc(n4) : null, null !== n4 && (J2 = Vb(n4), n4 !== J2 || 5 !== n4.tag && 6 !== n4.tag))
              n4 = null;
          } else
            k4 = null, n4 = d4;
          if (k4 !== n4) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w3 = "mouse";
            if ("pointerout" === a3 || "pointerover" === a3)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w3 = "pointer";
            J2 = null == k4 ? h6 : ue(k4);
            u3 = null == n4 ? h6 : ue(n4);
            h6 = new t2(F2, w3 + "leave", k4, c2, e3);
            h6.target = J2;
            h6.relatedTarget = u3;
            F2 = null;
            Wc(e3) === d4 && (t2 = new t2(x2, w3 + "enter", n4, c2, e3), t2.target = u3, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k4 && n4)
              b: {
                t2 = k4;
                x2 = n4;
                w3 = 0;
                for (u3 = t2; u3; u3 = vf(u3))
                  w3++;
                u3 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u3++;
                for (; 0 < w3 - u3; )
                  t2 = vf(t2), w3--;
                for (; 0 < u3 - w3; )
                  x2 = vf(x2), u3--;
                for (; w3--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k4 && wf(g4, h6, k4, t2, false);
            null !== n4 && null !== J2 && wf(g4, J2, n4, t2, true);
          }
        }
      }
      a: {
        h6 = d4 ? ue(d4) : window;
        k4 = h6.nodeName && h6.nodeName.toLowerCase();
        if ("select" === k4 || "input" === k4 && "file" === h6.type)
          var na = ve;
        else if (me(h6))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa2 = Ce;
          }
        else
          (k4 = h6.nodeName) && "input" === k4.toLowerCase() && ("checkbox" === h6.type || "radio" === h6.type) && (na = Ee);
        if (na && (na = na(a3, d4))) {
          ne(g4, na, c2, e3);
          break a;
        }
        xa2 && xa2(a3, h6, d4);
        "focusout" === a3 && (xa2 = h6._wrapperState) && xa2.controlled && "number" === h6.type && cb(h6, "number", h6.value);
      }
      xa2 = d4 ? ue(d4) : window;
      switch (a3) {
        case "focusin":
          if (me(xa2) || "true" === xa2.contentEditable)
            Qe = xa2, Re = d4, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g4, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g4, c2, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a3) {
            case "compositionstart":
              var ba2 = "onCompositionStart";
              break b;
            case "compositionend":
              ba2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba2 = "onCompositionUpdate";
              break b;
          }
          ba2 = void 0;
        }
      else
        ie ? ge(a3, c2) && (ba2 = "onCompositionEnd") : "keydown" === a3 && 229 === c2.keyCode && (ba2 = "onCompositionStart");
      ba2 && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba2 ? "onCompositionEnd" === ba2 && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa2 = oe(d4, ba2), 0 < xa2.length && (ba2 = new Ld(ba2, a3, null, c2, e3), g4.push({ event: ba2, listeners: xa2 }), $a ? ba2.data = $a : ($a = he(c2), null !== $a && (ba2.data = $a))));
      if ($a = ce ? je(a3, c2) : ke(a3, c2))
        d4 = oe(d4, "onBeforeInput"), 0 < d4.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g4.push({ event: e3, listeners: d4 }), e3.data = $a);
    }
    se(g4, b4);
  });
}
function tf(a3, b4, c2) {
  return { instance: a3, listener: b4, currentTarget: c2 };
}
function oe(a3, b4) {
  for (var c2 = b4 + "Capture", d3 = []; null !== a3; ) {
    var e2 = a3, f4 = e2.stateNode;
    5 === e2.tag && null !== f4 && (e2 = f4, f4 = Kb(a3, c2), null != f4 && d3.unshift(tf(a3, f4, e2)), f4 = Kb(a3, b4), null != f4 && d3.push(tf(a3, f4, e2)));
    a3 = a3.return;
  }
  return d3;
}
function vf(a3) {
  if (null === a3)
    return null;
  do
    a3 = a3.return;
  while (a3 && 5 !== a3.tag);
  return a3 ? a3 : null;
}
function wf(a3, b4, c2, d3, e2) {
  for (var f4 = b4._reactName, g3 = []; null !== c2 && c2 !== d3; ) {
    var h5 = c2, k3 = h5.alternate, l2 = h5.stateNode;
    if (null !== k3 && k3 === d3)
      break;
    5 === h5.tag && null !== l2 && (h5 = l2, e2 ? (k3 = Kb(c2, f4), null != k3 && g3.unshift(tf(c2, k3, h5))) : e2 || (k3 = Kb(c2, f4), null != k3 && g3.push(tf(c2, k3, h5))));
    c2 = c2.return;
  }
  0 !== g3.length && a3.push({ event: b4, listeners: g3 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a3) {
  return ("string" === typeof a3 ? a3 : "" + a3).replace(xf, "\n").replace(yf, "");
}
function Af(a3, b4, c2) {
  b4 = zf(b4);
  if (zf(a3) !== b4 && c2)
    throw Error(p(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a3, b4) {
  return "textarea" === a3 || "noscript" === a3 || "string" === typeof b4.children || "number" === typeof b4.children || "object" === typeof b4.dangerouslySetInnerHTML && null !== b4.dangerouslySetInnerHTML && null != b4.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a3) {
  return Hf.resolve(null).then(a3).catch(If);
} : Ff;
function If(a3) {
  setTimeout(function() {
    throw a3;
  });
}
function Kf(a3, b4) {
  var c2 = b4, d3 = 0;
  do {
    var e2 = c2.nextSibling;
    a3.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d3) {
          a3.removeChild(e2);
          bd(b4);
          return;
        }
        d3--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d3++;
    c2 = e2;
  } while (c2);
  bd(b4);
}
function Lf(a3) {
  for (; null != a3; a3 = a3.nextSibling) {
    var b4 = a3.nodeType;
    if (1 === b4 || 3 === b4)
      break;
    if (8 === b4) {
      b4 = a3.data;
      if ("$" === b4 || "$!" === b4 || "$?" === b4)
        break;
      if ("/$" === b4)
        return null;
    }
  }
  return a3;
}
function Mf(a3) {
  a3 = a3.previousSibling;
  for (var b4 = 0; a3; ) {
    if (8 === a3.nodeType) {
      var c2 = a3.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b4)
          return a3;
        b4--;
      } else
        "/$" === c2 && b4++;
    }
    a3 = a3.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a3) {
  var b4 = a3[Of];
  if (b4)
    return b4;
  for (var c2 = a3.parentNode; c2; ) {
    if (b4 = c2[uf] || c2[Of]) {
      c2 = b4.alternate;
      if (null !== b4.child || null !== c2 && null !== c2.child)
        for (a3 = Mf(a3); null !== a3; ) {
          if (c2 = a3[Of])
            return c2;
          a3 = Mf(a3);
        }
      return b4;
    }
    a3 = c2;
    c2 = a3.parentNode;
  }
  return null;
}
function Cb(a3) {
  a3 = a3[Of] || a3[uf];
  return !a3 || 5 !== a3.tag && 6 !== a3.tag && 13 !== a3.tag && 3 !== a3.tag ? null : a3;
}
function ue(a3) {
  if (5 === a3.tag || 6 === a3.tag)
    return a3.stateNode;
  throw Error(p(33));
}
function Db(a3) {
  return a3[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a3) {
  return { current: a3 };
}
function E(a3) {
  0 > Tf || (a3.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a3, b4) {
  Tf++;
  Sf[Tf] = a3.current;
  a3.current = b4;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a3, b4) {
  var c2 = a3.type.contextTypes;
  if (!c2)
    return Vf;
  var d3 = a3.stateNode;
  if (d3 && d3.__reactInternalMemoizedUnmaskedChildContext === b4)
    return d3.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f4;
  for (f4 in c2)
    e2[f4] = b4[f4];
  d3 && (a3 = a3.stateNode, a3.__reactInternalMemoizedUnmaskedChildContext = b4, a3.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a3) {
  a3 = a3.childContextTypes;
  return null !== a3 && void 0 !== a3;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a3, b4, c2) {
  if (H.current !== Vf)
    throw Error(p(168));
  G(H, b4);
  G(Wf, c2);
}
function bg(a3, b4, c2) {
  var d3 = a3.stateNode;
  b4 = b4.childContextTypes;
  if ("function" !== typeof d3.getChildContext)
    return c2;
  d3 = d3.getChildContext();
  for (var e2 in d3)
    if (!(e2 in b4))
      throw Error(p(108, Ra(a3) || "Unknown", e2));
  return A({}, c2, d3);
}
function cg(a3) {
  a3 = (a3 = a3.stateNode) && a3.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a3);
  G(Wf, Wf.current);
  return true;
}
function dg(a3, b4, c2) {
  var d3 = a3.stateNode;
  if (!d3)
    throw Error(p(169));
  c2 ? (a3 = bg(a3, b4, Xf), d3.__reactInternalMemoizedMergedChildContext = a3, E(Wf), E(H), G(H, a3)) : E(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a3) {
  null === eg ? eg = [a3] : eg.push(a3);
}
function ig(a3) {
  fg = true;
  hg(a3);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a3 = 0, b4 = C;
    try {
      var c2 = eg;
      for (C = 1; a3 < c2.length; a3++) {
        var d3 = c2[a3];
        do
          d3 = d3(true);
        while (null !== d3);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a3 + 1)), ac(fc, jg), e2;
    } finally {
      C = b4, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a3, b4) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a3;
  ng = b4;
}
function ug(a3, b4, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a3;
  var d3 = rg;
  a3 = sg;
  var e2 = 32 - oc(d3) - 1;
  d3 &= ~(1 << e2);
  c2 += 1;
  var f4 = 32 - oc(b4) + e2;
  if (30 < f4) {
    var g3 = e2 - e2 % 5;
    f4 = (d3 & (1 << g3) - 1).toString(32);
    d3 >>= g3;
    e2 -= g3;
    rg = 1 << 32 - oc(b4) + e2 | c2 << e2 | d3;
    sg = f4 + a3;
  } else
    rg = 1 << f4 | c2 << e2 | d3, sg = a3;
}
function vg(a3) {
  null !== a3.return && (tg(a3, 1), ug(a3, 1, 0));
}
function wg(a3) {
  for (; a3 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a3 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a3, b4) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b4;
  c2.return = a3;
  b4 = a3.deletions;
  null === b4 ? (a3.deletions = [c2], a3.flags |= 16) : b4.push(c2);
}
function Cg(a3, b4) {
  switch (a3.tag) {
    case 5:
      var c2 = a3.type;
      b4 = 1 !== b4.nodeType || c2.toLowerCase() !== b4.nodeName.toLowerCase() ? null : b4;
      return null !== b4 ? (a3.stateNode = b4, xg = a3, yg = Lf(b4.firstChild), true) : false;
    case 6:
      return b4 = "" === a3.pendingProps || 3 !== b4.nodeType ? null : b4, null !== b4 ? (a3.stateNode = b4, xg = a3, yg = null, true) : false;
    case 13:
      return b4 = 8 !== b4.nodeType ? null : b4, null !== b4 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a3.memoizedState = { dehydrated: b4, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b4, c2.return = a3, a3.child = c2, xg = a3, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a3) {
  return 0 !== (a3.mode & 1) && 0 === (a3.flags & 128);
}
function Eg(a3) {
  if (I) {
    var b4 = yg;
    if (b4) {
      var c2 = b4;
      if (!Cg(a3, b4)) {
        if (Dg(a3))
          throw Error(p(418));
        b4 = Lf(c2.nextSibling);
        var d3 = xg;
        b4 && Cg(a3, b4) ? Ag(d3, c2) : (a3.flags = a3.flags & -4097 | 2, I = false, xg = a3);
      }
    } else {
      if (Dg(a3))
        throw Error(p(418));
      a3.flags = a3.flags & -4097 | 2;
      I = false;
      xg = a3;
    }
  }
}
function Fg(a3) {
  for (a3 = a3.return; null !== a3 && 5 !== a3.tag && 3 !== a3.tag && 13 !== a3.tag; )
    a3 = a3.return;
  xg = a3;
}
function Gg(a3) {
  if (a3 !== xg)
    return false;
  if (!I)
    return Fg(a3), I = true, false;
  var b4;
  (b4 = 3 !== a3.tag) && !(b4 = 5 !== a3.tag) && (b4 = a3.type, b4 = "head" !== b4 && "body" !== b4 && !Ef(a3.type, a3.memoizedProps));
  if (b4 && (b4 = yg)) {
    if (Dg(a3))
      throw Hg(), Error(p(418));
    for (; b4; )
      Ag(a3, b4), b4 = Lf(b4.nextSibling);
  }
  Fg(a3);
  if (13 === a3.tag) {
    a3 = a3.memoizedState;
    a3 = null !== a3 ? a3.dehydrated : null;
    if (!a3)
      throw Error(p(317));
    a: {
      a3 = a3.nextSibling;
      for (b4 = 0; a3; ) {
        if (8 === a3.nodeType) {
          var c2 = a3.data;
          if ("/$" === c2) {
            if (0 === b4) {
              yg = Lf(a3.nextSibling);
              break a;
            }
            b4--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b4++;
        }
        a3 = a3.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a3.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a3 = yg; a3; )
    a3 = Lf(a3.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a3) {
  null === zg ? zg = [a3] : zg.push(a3);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a3, b4) {
  if (a3 && a3.defaultProps) {
    b4 = A({}, b4);
    a3 = a3.defaultProps;
    for (var c2 in a3)
      void 0 === b4[c2] && (b4[c2] = a3[c2]);
    return b4;
  }
  return b4;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a3) {
  var b4 = Mg.current;
  E(Mg);
  a3._currentValue = b4;
}
function Sg(a3, b4, c2) {
  for (; null !== a3; ) {
    var d3 = a3.alternate;
    (a3.childLanes & b4) !== b4 ? (a3.childLanes |= b4, null !== d3 && (d3.childLanes |= b4)) : null !== d3 && (d3.childLanes & b4) !== b4 && (d3.childLanes |= b4);
    if (a3 === c2)
      break;
    a3 = a3.return;
  }
}
function Tg(a3, b4) {
  Ng = a3;
  Pg = Og = null;
  a3 = a3.dependencies;
  null !== a3 && null !== a3.firstContext && (0 !== (a3.lanes & b4) && (Ug = true), a3.firstContext = null);
}
function Vg(a3) {
  var b4 = a3._currentValue;
  if (Pg !== a3)
    if (a3 = { context: a3, memoizedValue: b4, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p(308));
      Og = a3;
      Ng.dependencies = { lanes: 0, firstContext: a3 };
    } else
      Og = Og.next = a3;
  return b4;
}
var Wg = null;
function Xg(a3) {
  null === Wg ? Wg = [a3] : Wg.push(a3);
}
function Yg(a3, b4, c2, d3) {
  var e2 = b4.interleaved;
  null === e2 ? (c2.next = c2, Xg(b4)) : (c2.next = e2.next, e2.next = c2);
  b4.interleaved = c2;
  return Zg(a3, d3);
}
function Zg(a3, b4) {
  a3.lanes |= b4;
  var c2 = a3.alternate;
  null !== c2 && (c2.lanes |= b4);
  c2 = a3;
  for (a3 = a3.return; null !== a3; )
    a3.childLanes |= b4, c2 = a3.alternate, null !== c2 && (c2.childLanes |= b4), c2 = a3, a3 = a3.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a3) {
  a3.updateQueue = { baseState: a3.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a3, b4) {
  a3 = a3.updateQueue;
  b4.updateQueue === a3 && (b4.updateQueue = { baseState: a3.baseState, firstBaseUpdate: a3.firstBaseUpdate, lastBaseUpdate: a3.lastBaseUpdate, shared: a3.shared, effects: a3.effects });
}
function ch(a3, b4) {
  return { eventTime: a3, lane: b4, tag: 0, payload: null, callback: null, next: null };
}
function dh(a3, b4, c2) {
  var d3 = a3.updateQueue;
  if (null === d3)
    return null;
  d3 = d3.shared;
  if (0 !== (K & 2)) {
    var e2 = d3.pending;
    null === e2 ? b4.next = b4 : (b4.next = e2.next, e2.next = b4);
    d3.pending = b4;
    return Zg(a3, c2);
  }
  e2 = d3.interleaved;
  null === e2 ? (b4.next = b4, Xg(d3)) : (b4.next = e2.next, e2.next = b4);
  d3.interleaved = b4;
  return Zg(a3, c2);
}
function eh(a3, b4, c2) {
  b4 = b4.updateQueue;
  if (null !== b4 && (b4 = b4.shared, 0 !== (c2 & 4194240))) {
    var d3 = b4.lanes;
    d3 &= a3.pendingLanes;
    c2 |= d3;
    b4.lanes = c2;
    Cc(a3, c2);
  }
}
function fh(a3, b4) {
  var c2 = a3.updateQueue, d3 = a3.alternate;
  if (null !== d3 && (d3 = d3.updateQueue, c2 === d3)) {
    var e2 = null, f4 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g3 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f4 ? e2 = f4 = g3 : f4 = f4.next = g3;
        c2 = c2.next;
      } while (null !== c2);
      null === f4 ? e2 = f4 = b4 : f4 = f4.next = b4;
    } else
      e2 = f4 = b4;
    c2 = { baseState: d3.baseState, firstBaseUpdate: e2, lastBaseUpdate: f4, shared: d3.shared, effects: d3.effects };
    a3.updateQueue = c2;
    return;
  }
  a3 = c2.lastBaseUpdate;
  null === a3 ? c2.firstBaseUpdate = b4 : a3.next = b4;
  c2.lastBaseUpdate = b4;
}
function gh(a3, b4, c2, d3) {
  var e2 = a3.updateQueue;
  $g = false;
  var f4 = e2.firstBaseUpdate, g3 = e2.lastBaseUpdate, h5 = e2.shared.pending;
  if (null !== h5) {
    e2.shared.pending = null;
    var k3 = h5, l2 = k3.next;
    k3.next = null;
    null === g3 ? f4 = l2 : g3.next = l2;
    g3 = k3;
    var m2 = a3.alternate;
    null !== m2 && (m2 = m2.updateQueue, h5 = m2.lastBaseUpdate, h5 !== g3 && (null === h5 ? m2.firstBaseUpdate = l2 : h5.next = l2, m2.lastBaseUpdate = k3));
  }
  if (null !== f4) {
    var q2 = e2.baseState;
    g3 = 0;
    m2 = l2 = k3 = null;
    h5 = f4;
    do {
      var r2 = h5.lane, y3 = h5.eventTime;
      if ((d3 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y3,
          lane: 0,
          tag: h5.tag,
          payload: h5.payload,
          callback: h5.callback,
          next: null
        });
        a: {
          var n4 = a3, t2 = h5;
          r2 = b4;
          y3 = c2;
          switch (t2.tag) {
            case 1:
              n4 = t2.payload;
              if ("function" === typeof n4) {
                q2 = n4.call(y3, q2, r2);
                break a;
              }
              q2 = n4;
              break a;
            case 3:
              n4.flags = n4.flags & -65537 | 128;
            case 0:
              n4 = t2.payload;
              r2 = "function" === typeof n4 ? n4.call(y3, q2, r2) : n4;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h5.callback && 0 !== h5.lane && (a3.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h5] : r2.push(h5));
      } else
        y3 = { eventTime: y3, lane: r2, tag: h5.tag, payload: h5.payload, callback: h5.callback, next: null }, null === m2 ? (l2 = m2 = y3, k3 = q2) : m2 = m2.next = y3, g3 |= r2;
      h5 = h5.next;
      if (null === h5)
        if (h5 = e2.shared.pending, null === h5)
          break;
        else
          r2 = h5, h5 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k3 = q2);
    e2.baseState = k3;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b4 = e2.shared.interleaved;
    if (null !== b4) {
      e2 = b4;
      do
        g3 |= e2.lane, e2 = e2.next;
      while (e2 !== b4);
    } else
      null === f4 && (e2.shared.lanes = 0);
    hh |= g3;
    a3.lanes = g3;
    a3.memoizedState = q2;
  }
}
function ih(a3, b4, c2) {
  a3 = b4.effects;
  b4.effects = null;
  if (null !== a3)
    for (b4 = 0; b4 < a3.length; b4++) {
      var d3 = a3[b4], e2 = d3.callback;
      if (null !== e2) {
        d3.callback = null;
        d3 = c2;
        if ("function" !== typeof e2)
          throw Error(p(191, e2));
        e2.call(d3);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a3, b4, c2, d3) {
  b4 = a3.memoizedState;
  c2 = c2(d3, b4);
  c2 = null === c2 || void 0 === c2 ? b4 : A({}, b4, c2);
  a3.memoizedState = c2;
  0 === a3.lanes && (a3.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a3) {
  return (a3 = a3._reactInternals) ? Vb(a3) === a3 : false;
}, enqueueSetState: function(a3, b4, c2) {
  a3 = a3._reactInternals;
  var d3 = L(), e2 = lh(a3), f4 = ch(d3, e2);
  f4.payload = b4;
  void 0 !== c2 && null !== c2 && (f4.callback = c2);
  b4 = dh(a3, f4, e2);
  null !== b4 && (mh(b4, a3, e2, d3), eh(b4, a3, e2));
}, enqueueReplaceState: function(a3, b4, c2) {
  a3 = a3._reactInternals;
  var d3 = L(), e2 = lh(a3), f4 = ch(d3, e2);
  f4.tag = 1;
  f4.payload = b4;
  void 0 !== c2 && null !== c2 && (f4.callback = c2);
  b4 = dh(a3, f4, e2);
  null !== b4 && (mh(b4, a3, e2, d3), eh(b4, a3, e2));
}, enqueueForceUpdate: function(a3, b4) {
  a3 = a3._reactInternals;
  var c2 = L(), d3 = lh(a3), e2 = ch(c2, d3);
  e2.tag = 2;
  void 0 !== b4 && null !== b4 && (e2.callback = b4);
  b4 = dh(a3, e2, d3);
  null !== b4 && (mh(b4, a3, d3, c2), eh(b4, a3, d3));
} };
function oh(a3, b4, c2, d3, e2, f4, g3) {
  a3 = a3.stateNode;
  return "function" === typeof a3.shouldComponentUpdate ? a3.shouldComponentUpdate(d3, f4, g3) : b4.prototype && b4.prototype.isPureReactComponent ? !Ie(c2, d3) || !Ie(e2, f4) : true;
}
function ph(a3, b4, c2) {
  var d3 = false, e2 = Vf;
  var f4 = b4.contextType;
  "object" === typeof f4 && null !== f4 ? f4 = Vg(f4) : (e2 = Zf(b4) ? Xf : H.current, d3 = b4.contextTypes, f4 = (d3 = null !== d3 && void 0 !== d3) ? Yf(a3, e2) : Vf);
  b4 = new b4(c2, f4);
  a3.memoizedState = null !== b4.state && void 0 !== b4.state ? b4.state : null;
  b4.updater = nh;
  a3.stateNode = b4;
  b4._reactInternals = a3;
  d3 && (a3 = a3.stateNode, a3.__reactInternalMemoizedUnmaskedChildContext = e2, a3.__reactInternalMemoizedMaskedChildContext = f4);
  return b4;
}
function qh(a3, b4, c2, d3) {
  a3 = b4.state;
  "function" === typeof b4.componentWillReceiveProps && b4.componentWillReceiveProps(c2, d3);
  "function" === typeof b4.UNSAFE_componentWillReceiveProps && b4.UNSAFE_componentWillReceiveProps(c2, d3);
  b4.state !== a3 && nh.enqueueReplaceState(b4, b4.state, null);
}
function rh(a3, b4, c2, d3) {
  var e2 = a3.stateNode;
  e2.props = c2;
  e2.state = a3.memoizedState;
  e2.refs = jh;
  ah(a3);
  var f4 = b4.contextType;
  "object" === typeof f4 && null !== f4 ? e2.context = Vg(f4) : (f4 = Zf(b4) ? Xf : H.current, e2.context = Yf(a3, f4));
  e2.state = a3.memoizedState;
  f4 = b4.getDerivedStateFromProps;
  "function" === typeof f4 && (kh(a3, b4, f4, c2), e2.state = a3.memoizedState);
  "function" === typeof b4.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b4 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b4 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a3, c2, e2, d3), e2.state = a3.memoizedState);
  "function" === typeof e2.componentDidMount && (a3.flags |= 4194308);
}
function sh(a3, b4, c2) {
  a3 = c2.ref;
  if (null !== a3 && "function" !== typeof a3 && "object" !== typeof a3) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p(309));
        var d3 = c2.stateNode;
      }
      if (!d3)
        throw Error(p(147, a3));
      var e2 = d3, f4 = "" + a3;
      if (null !== b4 && null !== b4.ref && "function" === typeof b4.ref && b4.ref._stringRef === f4)
        return b4.ref;
      b4 = function(a4) {
        var b5 = e2.refs;
        b5 === jh && (b5 = e2.refs = {});
        null === a4 ? delete b5[f4] : b5[f4] = a4;
      };
      b4._stringRef = f4;
      return b4;
    }
    if ("string" !== typeof a3)
      throw Error(p(284));
    if (!c2._owner)
      throw Error(p(290, a3));
  }
  return a3;
}
function th(a3, b4) {
  a3 = Object.prototype.toString.call(b4);
  throw Error(p(31, "[object Object]" === a3 ? "object with keys {" + Object.keys(b4).join(", ") + "}" : a3));
}
function uh(a3) {
  var b4 = a3._init;
  return b4(a3._payload);
}
function vh(a3) {
  function b4(b5, c3) {
    if (a3) {
      var d4 = b5.deletions;
      null === d4 ? (b5.deletions = [c3], b5.flags |= 16) : d4.push(c3);
    }
  }
  function c2(c3, d4) {
    if (!a3)
      return null;
    for (; null !== d4; )
      b4(c3, d4), d4 = d4.sibling;
    return null;
  }
  function d3(a4, b5) {
    for (a4 = /* @__PURE__ */ new Map(); null !== b5; )
      null !== b5.key ? a4.set(b5.key, b5) : a4.set(b5.index, b5), b5 = b5.sibling;
    return a4;
  }
  function e2(a4, b5) {
    a4 = wh(a4, b5);
    a4.index = 0;
    a4.sibling = null;
    return a4;
  }
  function f4(b5, c3, d4) {
    b5.index = d4;
    if (!a3)
      return b5.flags |= 1048576, c3;
    d4 = b5.alternate;
    if (null !== d4)
      return d4 = d4.index, d4 < c3 ? (b5.flags |= 2, c3) : d4;
    b5.flags |= 2;
    return c3;
  }
  function g3(b5) {
    a3 && null === b5.alternate && (b5.flags |= 2);
    return b5;
  }
  function h5(a4, b5, c3, d4) {
    if (null === b5 || 6 !== b5.tag)
      return b5 = xh(c3, a4.mode, d4), b5.return = a4, b5;
    b5 = e2(b5, c3);
    b5.return = a4;
    return b5;
  }
  function k3(a4, b5, c3, d4) {
    var f5 = c3.type;
    if (f5 === ya)
      return m2(a4, b5, c3.props.children, d4, c3.key);
    if (null !== b5 && (b5.elementType === f5 || "object" === typeof f5 && null !== f5 && f5.$$typeof === Ha && uh(f5) === b5.type))
      return d4 = e2(b5, c3.props), d4.ref = sh(a4, b5, c3), d4.return = a4, d4;
    d4 = yh(c3.type, c3.key, c3.props, null, a4.mode, d4);
    d4.ref = sh(a4, b5, c3);
    d4.return = a4;
    return d4;
  }
  function l2(a4, b5, c3, d4) {
    if (null === b5 || 4 !== b5.tag || b5.stateNode.containerInfo !== c3.containerInfo || b5.stateNode.implementation !== c3.implementation)
      return b5 = zh(c3, a4.mode, d4), b5.return = a4, b5;
    b5 = e2(b5, c3.children || []);
    b5.return = a4;
    return b5;
  }
  function m2(a4, b5, c3, d4, f5) {
    if (null === b5 || 7 !== b5.tag)
      return b5 = Ah(c3, a4.mode, d4, f5), b5.return = a4, b5;
    b5 = e2(b5, c3);
    b5.return = a4;
    return b5;
  }
  function q2(a4, b5, c3) {
    if ("string" === typeof b5 && "" !== b5 || "number" === typeof b5)
      return b5 = xh("" + b5, a4.mode, c3), b5.return = a4, b5;
    if ("object" === typeof b5 && null !== b5) {
      switch (b5.$$typeof) {
        case va:
          return c3 = yh(b5.type, b5.key, b5.props, null, a4.mode, c3), c3.ref = sh(a4, null, b5), c3.return = a4, c3;
        case wa:
          return b5 = zh(b5, a4.mode, c3), b5.return = a4, b5;
        case Ha:
          var d4 = b5._init;
          return q2(a4, d4(b5._payload), c3);
      }
      if (eb(b5) || Ka(b5))
        return b5 = Ah(b5, a4.mode, c3, null), b5.return = a4, b5;
      th(a4, b5);
    }
    return null;
  }
  function r2(a4, b5, c3, d4) {
    var e3 = null !== b5 ? b5.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h5(a4, b5, "" + c3, d4);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k3(a4, b5, c3, d4) : null;
        case wa:
          return c3.key === e3 ? l2(a4, b5, c3, d4) : null;
        case Ha:
          return e3 = c3._init, r2(
            a4,
            b5,
            e3(c3._payload),
            d4
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a4, b5, c3, d4, null);
      th(a4, c3);
    }
    return null;
  }
  function y3(a4, b5, c3, d4, e3) {
    if ("string" === typeof d4 && "" !== d4 || "number" === typeof d4)
      return a4 = a4.get(c3) || null, h5(b5, a4, "" + d4, e3);
    if ("object" === typeof d4 && null !== d4) {
      switch (d4.$$typeof) {
        case va:
          return a4 = a4.get(null === d4.key ? c3 : d4.key) || null, k3(b5, a4, d4, e3);
        case wa:
          return a4 = a4.get(null === d4.key ? c3 : d4.key) || null, l2(b5, a4, d4, e3);
        case Ha:
          var f5 = d4._init;
          return y3(a4, b5, c3, f5(d4._payload), e3);
      }
      if (eb(d4) || Ka(d4))
        return a4 = a4.get(c3) || null, m2(b5, a4, d4, e3, null);
      th(b5, d4);
    }
    return null;
  }
  function n4(e3, g4, h6, k4) {
    for (var l3 = null, m3 = null, u3 = g4, w3 = g4 = 0, x2 = null; null !== u3 && w3 < h6.length; w3++) {
      u3.index > w3 ? (x2 = u3, u3 = null) : x2 = u3.sibling;
      var n5 = r2(e3, u3, h6[w3], k4);
      if (null === n5) {
        null === u3 && (u3 = x2);
        break;
      }
      a3 && u3 && null === n5.alternate && b4(e3, u3);
      g4 = f4(n5, g4, w3);
      null === m3 ? l3 = n5 : m3.sibling = n5;
      m3 = n5;
      u3 = x2;
    }
    if (w3 === h6.length)
      return c2(e3, u3), I && tg(e3, w3), l3;
    if (null === u3) {
      for (; w3 < h6.length; w3++)
        u3 = q2(e3, h6[w3], k4), null !== u3 && (g4 = f4(u3, g4, w3), null === m3 ? l3 = u3 : m3.sibling = u3, m3 = u3);
      I && tg(e3, w3);
      return l3;
    }
    for (u3 = d3(e3, u3); w3 < h6.length; w3++)
      x2 = y3(u3, e3, w3, h6[w3], k4), null !== x2 && (a3 && null !== x2.alternate && u3.delete(null === x2.key ? w3 : x2.key), g4 = f4(x2, g4, w3), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a3 && u3.forEach(function(a4) {
      return b4(e3, a4);
    });
    I && tg(e3, w3);
    return l3;
  }
  function t2(e3, g4, h6, k4) {
    var l3 = Ka(h6);
    if ("function" !== typeof l3)
      throw Error(p(150));
    h6 = l3.call(h6);
    if (null == h6)
      throw Error(p(151));
    for (var u3 = l3 = null, m3 = g4, w3 = g4 = 0, x2 = null, n5 = h6.next(); null !== m3 && !n5.done; w3++, n5 = h6.next()) {
      m3.index > w3 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n5.value, k4);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a3 && m3 && null === t3.alternate && b4(e3, m3);
      g4 = f4(t3, g4, w3);
      null === u3 ? l3 = t3 : u3.sibling = t3;
      u3 = t3;
      m3 = x2;
    }
    if (n5.done)
      return c2(
        e3,
        m3
      ), I && tg(e3, w3), l3;
    if (null === m3) {
      for (; !n5.done; w3++, n5 = h6.next())
        n5 = q2(e3, n5.value, k4), null !== n5 && (g4 = f4(n5, g4, w3), null === u3 ? l3 = n5 : u3.sibling = n5, u3 = n5);
      I && tg(e3, w3);
      return l3;
    }
    for (m3 = d3(e3, m3); !n5.done; w3++, n5 = h6.next())
      n5 = y3(m3, e3, w3, n5.value, k4), null !== n5 && (a3 && null !== n5.alternate && m3.delete(null === n5.key ? w3 : n5.key), g4 = f4(n5, g4, w3), null === u3 ? l3 = n5 : u3.sibling = n5, u3 = n5);
    a3 && m3.forEach(function(a4) {
      return b4(e3, a4);
    });
    I && tg(e3, w3);
    return l3;
  }
  function J2(a4, d4, f5, h6) {
    "object" === typeof f5 && null !== f5 && f5.type === ya && null === f5.key && (f5 = f5.props.children);
    if ("object" === typeof f5 && null !== f5) {
      switch (f5.$$typeof) {
        case va:
          a: {
            for (var k4 = f5.key, l3 = d4; null !== l3; ) {
              if (l3.key === k4) {
                k4 = f5.type;
                if (k4 === ya) {
                  if (7 === l3.tag) {
                    c2(a4, l3.sibling);
                    d4 = e2(l3, f5.props.children);
                    d4.return = a4;
                    a4 = d4;
                    break a;
                  }
                } else if (l3.elementType === k4 || "object" === typeof k4 && null !== k4 && k4.$$typeof === Ha && uh(k4) === l3.type) {
                  c2(a4, l3.sibling);
                  d4 = e2(l3, f5.props);
                  d4.ref = sh(a4, l3, f5);
                  d4.return = a4;
                  a4 = d4;
                  break a;
                }
                c2(a4, l3);
                break;
              } else
                b4(a4, l3);
              l3 = l3.sibling;
            }
            f5.type === ya ? (d4 = Ah(f5.props.children, a4.mode, h6, f5.key), d4.return = a4, a4 = d4) : (h6 = yh(f5.type, f5.key, f5.props, null, a4.mode, h6), h6.ref = sh(a4, d4, f5), h6.return = a4, a4 = h6);
          }
          return g3(a4);
        case wa:
          a: {
            for (l3 = f5.key; null !== d4; ) {
              if (d4.key === l3)
                if (4 === d4.tag && d4.stateNode.containerInfo === f5.containerInfo && d4.stateNode.implementation === f5.implementation) {
                  c2(a4, d4.sibling);
                  d4 = e2(d4, f5.children || []);
                  d4.return = a4;
                  a4 = d4;
                  break a;
                } else {
                  c2(a4, d4);
                  break;
                }
              else
                b4(a4, d4);
              d4 = d4.sibling;
            }
            d4 = zh(f5, a4.mode, h6);
            d4.return = a4;
            a4 = d4;
          }
          return g3(a4);
        case Ha:
          return l3 = f5._init, J2(a4, d4, l3(f5._payload), h6);
      }
      if (eb(f5))
        return n4(a4, d4, f5, h6);
      if (Ka(f5))
        return t2(a4, d4, f5, h6);
      th(a4, f5);
    }
    return "string" === typeof f5 && "" !== f5 || "number" === typeof f5 ? (f5 = "" + f5, null !== d4 && 6 === d4.tag ? (c2(a4, d4.sibling), d4 = e2(d4, f5), d4.return = a4, a4 = d4) : (c2(a4, d4), d4 = xh(f5, a4.mode, h6), d4.return = a4, a4 = d4), g3(a4)) : c2(a4, d4);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a3) {
  if (a3 === Dh)
    throw Error(p(174));
  return a3;
}
function Ih(a3, b4) {
  G(Gh, b4);
  G(Fh, a3);
  G(Eh, Dh);
  a3 = b4.nodeType;
  switch (a3) {
    case 9:
    case 11:
      b4 = (b4 = b4.documentElement) ? b4.namespaceURI : lb(null, "");
      break;
    default:
      a3 = 8 === a3 ? b4.parentNode : b4, b4 = a3.namespaceURI || null, a3 = a3.tagName, b4 = lb(b4, a3);
  }
  E(Eh);
  G(Eh, b4);
}
function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}
function Kh(a3) {
  Hh(Gh.current);
  var b4 = Hh(Eh.current);
  var c2 = lb(b4, a3.type);
  b4 !== c2 && (G(Fh, a3), G(Eh, c2));
}
function Lh(a3) {
  Fh.current === a3 && (E(Eh), E(Fh));
}
var M = Uf(0);
function Mh(a3) {
  for (var b4 = a3; null !== b4; ) {
    if (13 === b4.tag) {
      var c2 = b4.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b4;
    } else if (19 === b4.tag && void 0 !== b4.memoizedProps.revealOrder) {
      if (0 !== (b4.flags & 128))
        return b4;
    } else if (null !== b4.child) {
      b4.child.return = b4;
      b4 = b4.child;
      continue;
    }
    if (b4 === a3)
      break;
    for (; null === b4.sibling; ) {
      if (null === b4.return || b4.return === a3)
        return null;
      b4 = b4.return;
    }
    b4.sibling.return = b4.return;
    b4 = b4.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a3 = 0; a3 < Nh.length; a3++)
    Nh[a3]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q() {
  throw Error(p(321));
}
function Wh(a3, b4) {
  if (null === b4)
    return false;
  for (var c2 = 0; c2 < b4.length && c2 < a3.length; c2++)
    if (!He(a3[c2], b4[c2]))
      return false;
  return true;
}
function Xh(a3, b4, c2, d3, e2, f4) {
  Rh = f4;
  N = b4;
  b4.memoizedState = null;
  b4.updateQueue = null;
  b4.lanes = 0;
  Ph.current = null === a3 || null === a3.memoizedState ? Yh : Zh;
  a3 = c2(d3, e2);
  if (Th) {
    f4 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f4)
        throw Error(p(301));
      f4 += 1;
      P = O = null;
      b4.updateQueue = null;
      Ph.current = $h;
      a3 = c2(d3, e2);
    } while (Th);
  }
  Ph.current = ai;
  b4 = null !== O && null !== O.next;
  Rh = 0;
  P = O = N = null;
  Sh = false;
  if (b4)
    throw Error(p(300));
  return a3;
}
function bi() {
  var a3 = 0 !== Uh;
  Uh = 0;
  return a3;
}
function ci() {
  var a3 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P ? N.memoizedState = P = a3 : P = P.next = a3;
  return P;
}
function di() {
  if (null === O) {
    var a3 = N.alternate;
    a3 = null !== a3 ? a3.memoizedState : null;
  } else
    a3 = O.next;
  var b4 = null === P ? N.memoizedState : P.next;
  if (null !== b4)
    P = b4, O = a3;
  else {
    if (null === a3)
      throw Error(p(310));
    O = a3;
    a3 = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
    null === P ? N.memoizedState = P = a3 : P = P.next = a3;
  }
  return P;
}
function ei(a3, b4) {
  return "function" === typeof b4 ? b4(a3) : b4;
}
function fi(a3) {
  var b4 = di(), c2 = b4.queue;
  if (null === c2)
    throw Error(p(311));
  c2.lastRenderedReducer = a3;
  var d3 = O, e2 = d3.baseQueue, f4 = c2.pending;
  if (null !== f4) {
    if (null !== e2) {
      var g3 = e2.next;
      e2.next = f4.next;
      f4.next = g3;
    }
    d3.baseQueue = e2 = f4;
    c2.pending = null;
  }
  if (null !== e2) {
    f4 = e2.next;
    d3 = d3.baseState;
    var h5 = g3 = null, k3 = null, l2 = f4;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k3 && (k3 = k3.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d3 = l2.hasEagerState ? l2.eagerState : a3(d3, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k3 ? (h5 = k3 = q2, g3 = d3) : k3 = k3.next = q2;
        N.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f4);
    null === k3 ? g3 = d3 : k3.next = h5;
    He(d3, b4.memoizedState) || (Ug = true);
    b4.memoizedState = d3;
    b4.baseState = g3;
    b4.baseQueue = k3;
    c2.lastRenderedState = d3;
  }
  a3 = c2.interleaved;
  if (null !== a3) {
    e2 = a3;
    do
      f4 = e2.lane, N.lanes |= f4, hh |= f4, e2 = e2.next;
    while (e2 !== a3);
  } else
    null === e2 && (c2.lanes = 0);
  return [b4.memoizedState, c2.dispatch];
}
function gi(a3) {
  var b4 = di(), c2 = b4.queue;
  if (null === c2)
    throw Error(p(311));
  c2.lastRenderedReducer = a3;
  var d3 = c2.dispatch, e2 = c2.pending, f4 = b4.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g3 = e2 = e2.next;
    do
      f4 = a3(f4, g3.action), g3 = g3.next;
    while (g3 !== e2);
    He(f4, b4.memoizedState) || (Ug = true);
    b4.memoizedState = f4;
    null === b4.baseQueue && (b4.baseState = f4);
    c2.lastRenderedState = f4;
  }
  return [f4, d3];
}
function hi() {
}
function ii(a3, b4) {
  var c2 = N, d3 = di(), e2 = b4(), f4 = !He(d3.memoizedState, e2);
  f4 && (d3.memoizedState = e2, Ug = true);
  d3 = d3.queue;
  ji(ki.bind(null, c2, d3, a3), [a3]);
  if (d3.getSnapshot !== b4 || f4 || null !== P && P.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d3, e2, b4), void 0, null);
    if (null === R)
      throw Error(p(349));
    0 !== (Rh & 30) || ni(c2, b4, e2);
  }
  return e2;
}
function ni(a3, b4, c2) {
  a3.flags |= 16384;
  a3 = { getSnapshot: b4, value: c2 };
  b4 = N.updateQueue;
  null === b4 ? (b4 = { lastEffect: null, stores: null }, N.updateQueue = b4, b4.stores = [a3]) : (c2 = b4.stores, null === c2 ? b4.stores = [a3] : c2.push(a3));
}
function mi(a3, b4, c2, d3) {
  b4.value = c2;
  b4.getSnapshot = d3;
  oi(b4) && pi(a3);
}
function ki(a3, b4, c2) {
  return c2(function() {
    oi(b4) && pi(a3);
  });
}
function oi(a3) {
  var b4 = a3.getSnapshot;
  a3 = a3.value;
  try {
    var c2 = b4();
    return !He(a3, c2);
  } catch (d3) {
    return true;
  }
}
function pi(a3) {
  var b4 = Zg(a3, 1);
  null !== b4 && mh(b4, a3, 1, -1);
}
function qi(a3) {
  var b4 = ci();
  "function" === typeof a3 && (a3 = a3());
  b4.memoizedState = b4.baseState = a3;
  a3 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a3 };
  b4.queue = a3;
  a3 = a3.dispatch = ri.bind(null, N, a3);
  return [b4.memoizedState, a3];
}
function li(a3, b4, c2, d3) {
  a3 = { tag: a3, create: b4, destroy: c2, deps: d3, next: null };
  b4 = N.updateQueue;
  null === b4 ? (b4 = { lastEffect: null, stores: null }, N.updateQueue = b4, b4.lastEffect = a3.next = a3) : (c2 = b4.lastEffect, null === c2 ? b4.lastEffect = a3.next = a3 : (d3 = c2.next, c2.next = a3, a3.next = d3, b4.lastEffect = a3));
  return a3;
}
function si() {
  return di().memoizedState;
}
function ti(a3, b4, c2, d3) {
  var e2 = ci();
  N.flags |= a3;
  e2.memoizedState = li(1 | b4, c2, void 0, void 0 === d3 ? null : d3);
}
function ui(a3, b4, c2, d3) {
  var e2 = di();
  d3 = void 0 === d3 ? null : d3;
  var f4 = void 0;
  if (null !== O) {
    var g3 = O.memoizedState;
    f4 = g3.destroy;
    if (null !== d3 && Wh(d3, g3.deps)) {
      e2.memoizedState = li(b4, c2, f4, d3);
      return;
    }
  }
  N.flags |= a3;
  e2.memoizedState = li(1 | b4, c2, f4, d3);
}
function vi(a3, b4) {
  return ti(8390656, 8, a3, b4);
}
function ji(a3, b4) {
  return ui(2048, 8, a3, b4);
}
function wi(a3, b4) {
  return ui(4, 2, a3, b4);
}
function xi(a3, b4) {
  return ui(4, 4, a3, b4);
}
function yi(a3, b4) {
  if ("function" === typeof b4)
    return a3 = a3(), b4(a3), function() {
      b4(null);
    };
  if (null !== b4 && void 0 !== b4)
    return a3 = a3(), b4.current = a3, function() {
      b4.current = null;
    };
}
function zi(a3, b4, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a3]) : null;
  return ui(4, 4, yi.bind(null, b4, a3), c2);
}
function Ai() {
}
function Bi(a3, b4) {
  var c2 = di();
  b4 = void 0 === b4 ? null : b4;
  var d3 = c2.memoizedState;
  if (null !== d3 && null !== b4 && Wh(b4, d3[1]))
    return d3[0];
  c2.memoizedState = [a3, b4];
  return a3;
}
function Ci(a3, b4) {
  var c2 = di();
  b4 = void 0 === b4 ? null : b4;
  var d3 = c2.memoizedState;
  if (null !== d3 && null !== b4 && Wh(b4, d3[1]))
    return d3[0];
  a3 = a3();
  c2.memoizedState = [a3, b4];
  return a3;
}
function Di(a3, b4, c2) {
  if (0 === (Rh & 21))
    return a3.baseState && (a3.baseState = false, Ug = true), a3.memoizedState = c2;
  He(c2, b4) || (c2 = yc(), N.lanes |= c2, hh |= c2, a3.baseState = true);
  return b4;
}
function Ei(a3, b4) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a3(true);
  var d3 = Qh.transition;
  Qh.transition = {};
  try {
    a3(false), b4();
  } finally {
    C = c2, Qh.transition = d3;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a3, b4, c2) {
  var d3 = lh(a3);
  c2 = { lane: d3, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a3))
    Ii(b4, c2);
  else if (c2 = Yg(a3, b4, c2, d3), null !== c2) {
    var e2 = L();
    mh(c2, a3, d3, e2);
    Ji(c2, b4, d3);
  }
}
function ri(a3, b4, c2) {
  var d3 = lh(a3), e2 = { lane: d3, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a3))
    Ii(b4, e2);
  else {
    var f4 = a3.alternate;
    if (0 === a3.lanes && (null === f4 || 0 === f4.lanes) && (f4 = b4.lastRenderedReducer, null !== f4))
      try {
        var g3 = b4.lastRenderedState, h5 = f4(g3, c2);
        e2.hasEagerState = true;
        e2.eagerState = h5;
        if (He(h5, g3)) {
          var k3 = b4.interleaved;
          null === k3 ? (e2.next = e2, Xg(b4)) : (e2.next = k3.next, k3.next = e2);
          b4.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a3, b4, e2, d3);
    null !== c2 && (e2 = L(), mh(c2, a3, d3, e2), Ji(c2, b4, d3));
  }
}
function Hi(a3) {
  var b4 = a3.alternate;
  return a3 === N || null !== b4 && b4 === N;
}
function Ii(a3, b4) {
  Th = Sh = true;
  var c2 = a3.pending;
  null === c2 ? b4.next = b4 : (b4.next = c2.next, c2.next = b4);
  a3.pending = b4;
}
function Ji(a3, b4, c2) {
  if (0 !== (c2 & 4194240)) {
    var d3 = b4.lanes;
    d3 &= a3.pendingLanes;
    c2 |= d3;
    b4.lanes = c2;
    Cc(a3, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a3, b4) {
  ci().memoizedState = [a3, void 0 === b4 ? null : b4];
  return a3;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a3, b4, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a3]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b4, a3),
    c2
  );
}, useLayoutEffect: function(a3, b4) {
  return ti(4194308, 4, a3, b4);
}, useInsertionEffect: function(a3, b4) {
  return ti(4, 2, a3, b4);
}, useMemo: function(a3, b4) {
  var c2 = ci();
  b4 = void 0 === b4 ? null : b4;
  a3 = a3();
  c2.memoizedState = [a3, b4];
  return a3;
}, useReducer: function(a3, b4, c2) {
  var d3 = ci();
  b4 = void 0 !== c2 ? c2(b4) : b4;
  d3.memoizedState = d3.baseState = b4;
  a3 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a3, lastRenderedState: b4 };
  d3.queue = a3;
  a3 = a3.dispatch = Gi.bind(null, N, a3);
  return [d3.memoizedState, a3];
}, useRef: function(a3) {
  var b4 = ci();
  a3 = { current: a3 };
  return b4.memoizedState = a3;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a3) {
  return ci().memoizedState = a3;
}, useTransition: function() {
  var a3 = qi(false), b4 = a3[0];
  a3 = Ei.bind(null, a3[1]);
  ci().memoizedState = a3;
  return [b4, a3];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a3, b4, c2) {
  var d3 = N, e2 = ci();
  if (I) {
    if (void 0 === c2)
      throw Error(p(407));
    c2 = c2();
  } else {
    c2 = b4();
    if (null === R)
      throw Error(p(349));
    0 !== (Rh & 30) || ni(d3, b4, c2);
  }
  e2.memoizedState = c2;
  var f4 = { value: c2, getSnapshot: b4 };
  e2.queue = f4;
  vi(ki.bind(
    null,
    d3,
    f4,
    a3
  ), [a3]);
  d3.flags |= 2048;
  li(9, mi.bind(null, d3, f4, c2, b4), void 0, null);
  return c2;
}, useId: function() {
  var a3 = ci(), b4 = R.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d3 = rg;
    c2 = (d3 & ~(1 << 32 - oc(d3) - 1)).toString(32) + c2;
    b4 = ":" + b4 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b4 += "H" + c2.toString(32));
    b4 += ":";
  } else
    c2 = Vh++, b4 = ":" + b4 + "r" + c2.toString(32) + ":";
  return a3.memoizedState = b4;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a3) {
    var b4 = di();
    return Di(b4, O.memoizedState, a3);
  },
  useTransition: function() {
    var a3 = fi(ei)[0], b4 = di().memoizedState;
    return [a3, b4];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a3) {
  var b4 = di();
  return null === O ? b4.memoizedState = a3 : Di(b4, O.memoizedState, a3);
}, useTransition: function() {
  var a3 = gi(ei)[0], b4 = di().memoizedState;
  return [a3, b4];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a3, b4) {
  try {
    var c2 = "", d3 = b4;
    do
      c2 += Pa(d3), d3 = d3.return;
    while (d3);
    var e2 = c2;
  } catch (f4) {
    e2 = "\nError generating stack: " + f4.message + "\n" + f4.stack;
  }
  return { value: a3, source: b4, stack: e2, digest: null };
}
function Li(a3, b4, c2) {
  return { value: a3, source: null, stack: null != c2 ? c2 : null, digest: null != b4 ? b4 : null };
}
function Mi(a3, b4) {
  try {
    console.error(b4.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a3, b4, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d3 = b4.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d3);
    Mi(a3, b4);
  };
  return c2;
}
function Ri(a3, b4, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d3 = a3.type.getDerivedStateFromError;
  if ("function" === typeof d3) {
    var e2 = b4.value;
    c2.payload = function() {
      return d3(e2);
    };
    c2.callback = function() {
      Mi(a3, b4);
    };
  }
  var f4 = a3.stateNode;
  null !== f4 && "function" === typeof f4.componentDidCatch && (c2.callback = function() {
    Mi(a3, b4);
    "function" !== typeof d3 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b4.stack;
    this.componentDidCatch(b4.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a3, b4, c2) {
  var d3 = a3.pingCache;
  if (null === d3) {
    d3 = a3.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d3.set(b4, e2);
  } else
    e2 = d3.get(b4), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d3.set(b4, e2));
  e2.has(c2) || (e2.add(c2), a3 = Ui.bind(null, a3, b4, c2), b4.then(a3, a3));
}
function Vi(a3) {
  do {
    var b4;
    if (b4 = 13 === a3.tag)
      b4 = a3.memoizedState, b4 = null !== b4 ? null !== b4.dehydrated ? true : false : true;
    if (b4)
      return a3;
    a3 = a3.return;
  } while (null !== a3);
  return null;
}
function Wi(a3, b4, c2, d3, e2) {
  if (0 === (a3.mode & 1))
    return a3 === b4 ? a3.flags |= 65536 : (a3.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b4 = ch(-1, 1), b4.tag = 2, dh(c2, b4, 1))), c2.lanes |= 1), a3;
  a3.flags |= 65536;
  a3.lanes = e2;
  return a3;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a3, b4, c2, d3) {
  b4.child = null === a3 ? Ch(b4, null, c2, d3) : Bh(b4, a3.child, c2, d3);
}
function Zi(a3, b4, c2, d3, e2) {
  c2 = c2.render;
  var f4 = b4.ref;
  Tg(b4, e2);
  d3 = Xh(a3, b4, c2, d3, f4, e2);
  c2 = bi();
  if (null !== a3 && !Ug)
    return b4.updateQueue = a3.updateQueue, b4.flags &= -2053, a3.lanes &= ~e2, $i(a3, b4, e2);
  I && c2 && vg(b4);
  b4.flags |= 1;
  Yi(a3, b4, d3, e2);
  return b4.child;
}
function aj(a3, b4, c2, d3, e2) {
  if (null === a3) {
    var f4 = c2.type;
    if ("function" === typeof f4 && !bj(f4) && void 0 === f4.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b4.tag = 15, b4.type = f4, cj(a3, b4, f4, d3, e2);
    a3 = yh(c2.type, null, d3, b4, b4.mode, e2);
    a3.ref = b4.ref;
    a3.return = b4;
    return b4.child = a3;
  }
  f4 = a3.child;
  if (0 === (a3.lanes & e2)) {
    var g3 = f4.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g3, d3) && a3.ref === b4.ref)
      return $i(a3, b4, e2);
  }
  b4.flags |= 1;
  a3 = wh(f4, d3);
  a3.ref = b4.ref;
  a3.return = b4;
  return b4.child = a3;
}
function cj(a3, b4, c2, d3, e2) {
  if (null !== a3) {
    var f4 = a3.memoizedProps;
    if (Ie(f4, d3) && a3.ref === b4.ref)
      if (Ug = false, b4.pendingProps = d3 = f4, 0 !== (a3.lanes & e2))
        0 !== (a3.flags & 131072) && (Ug = true);
      else
        return b4.lanes = a3.lanes, $i(a3, b4, e2);
  }
  return dj(a3, b4, c2, d3, e2);
}
function ej(a3, b4, c2) {
  var d3 = b4.pendingProps, e2 = d3.children, f4 = null !== a3 ? a3.memoizedState : null;
  if ("hidden" === d3.mode)
    if (0 === (b4.mode & 1))
      b4.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a3 = null !== f4 ? f4.baseLanes | c2 : c2, b4.lanes = b4.childLanes = 1073741824, b4.memoizedState = { baseLanes: a3, cachePool: null, transitions: null }, b4.updateQueue = null, G(fj, gj), gj |= a3, null;
      b4.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d3 = null !== f4 ? f4.baseLanes : c2;
      G(fj, gj);
      gj |= d3;
    }
  else
    null !== f4 ? (d3 = f4.baseLanes | c2, b4.memoizedState = null) : d3 = c2, G(fj, gj), gj |= d3;
  Yi(a3, b4, e2, c2);
  return b4.child;
}
function hj(a3, b4) {
  var c2 = b4.ref;
  if (null === a3 && null !== c2 || null !== a3 && a3.ref !== c2)
    b4.flags |= 512, b4.flags |= 2097152;
}
function dj(a3, b4, c2, d3, e2) {
  var f4 = Zf(c2) ? Xf : H.current;
  f4 = Yf(b4, f4);
  Tg(b4, e2);
  c2 = Xh(a3, b4, c2, d3, f4, e2);
  d3 = bi();
  if (null !== a3 && !Ug)
    return b4.updateQueue = a3.updateQueue, b4.flags &= -2053, a3.lanes &= ~e2, $i(a3, b4, e2);
  I && d3 && vg(b4);
  b4.flags |= 1;
  Yi(a3, b4, c2, e2);
  return b4.child;
}
function ij(a3, b4, c2, d3, e2) {
  if (Zf(c2)) {
    var f4 = true;
    cg(b4);
  } else
    f4 = false;
  Tg(b4, e2);
  if (null === b4.stateNode)
    jj(a3, b4), ph(b4, c2, d3), rh(b4, c2, d3, e2), d3 = true;
  else if (null === a3) {
    var g3 = b4.stateNode, h5 = b4.memoizedProps;
    g3.props = h5;
    var k3 = g3.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b4, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g3.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g3.UNSAFE_componentWillReceiveProps && "function" !== typeof g3.componentWillReceiveProps || (h5 !== d3 || k3 !== l2) && qh(b4, g3, d3, l2);
    $g = false;
    var r2 = b4.memoizedState;
    g3.state = r2;
    gh(b4, d3, g3, e2);
    k3 = b4.memoizedState;
    h5 !== d3 || r2 !== k3 || Wf.current || $g ? ("function" === typeof m2 && (kh(b4, c2, m2, d3), k3 = b4.memoizedState), (h5 = $g || oh(b4, c2, h5, d3, r2, k3, l2)) ? (q2 || "function" !== typeof g3.UNSAFE_componentWillMount && "function" !== typeof g3.componentWillMount || ("function" === typeof g3.componentWillMount && g3.componentWillMount(), "function" === typeof g3.UNSAFE_componentWillMount && g3.UNSAFE_componentWillMount()), "function" === typeof g3.componentDidMount && (b4.flags |= 4194308)) : ("function" === typeof g3.componentDidMount && (b4.flags |= 4194308), b4.memoizedProps = d3, b4.memoizedState = k3), g3.props = d3, g3.state = k3, g3.context = l2, d3 = h5) : ("function" === typeof g3.componentDidMount && (b4.flags |= 4194308), d3 = false);
  } else {
    g3 = b4.stateNode;
    bh(a3, b4);
    h5 = b4.memoizedProps;
    l2 = b4.type === b4.elementType ? h5 : Lg(b4.type, h5);
    g3.props = l2;
    q2 = b4.pendingProps;
    r2 = g3.context;
    k3 = c2.contextType;
    "object" === typeof k3 && null !== k3 ? k3 = Vg(k3) : (k3 = Zf(c2) ? Xf : H.current, k3 = Yf(b4, k3));
    var y3 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y3 || "function" === typeof g3.getSnapshotBeforeUpdate) || "function" !== typeof g3.UNSAFE_componentWillReceiveProps && "function" !== typeof g3.componentWillReceiveProps || (h5 !== q2 || r2 !== k3) && qh(b4, g3, d3, k3);
    $g = false;
    r2 = b4.memoizedState;
    g3.state = r2;
    gh(b4, d3, g3, e2);
    var n4 = b4.memoizedState;
    h5 !== q2 || r2 !== n4 || Wf.current || $g ? ("function" === typeof y3 && (kh(b4, c2, y3, d3), n4 = b4.memoizedState), (l2 = $g || oh(b4, c2, l2, d3, r2, n4, k3) || false) ? (m2 || "function" !== typeof g3.UNSAFE_componentWillUpdate && "function" !== typeof g3.componentWillUpdate || ("function" === typeof g3.componentWillUpdate && g3.componentWillUpdate(d3, n4, k3), "function" === typeof g3.UNSAFE_componentWillUpdate && g3.UNSAFE_componentWillUpdate(d3, n4, k3)), "function" === typeof g3.componentDidUpdate && (b4.flags |= 4), "function" === typeof g3.getSnapshotBeforeUpdate && (b4.flags |= 1024)) : ("function" !== typeof g3.componentDidUpdate || h5 === a3.memoizedProps && r2 === a3.memoizedState || (b4.flags |= 4), "function" !== typeof g3.getSnapshotBeforeUpdate || h5 === a3.memoizedProps && r2 === a3.memoizedState || (b4.flags |= 1024), b4.memoizedProps = d3, b4.memoizedState = n4), g3.props = d3, g3.state = n4, g3.context = k3, d3 = l2) : ("function" !== typeof g3.componentDidUpdate || h5 === a3.memoizedProps && r2 === a3.memoizedState || (b4.flags |= 4), "function" !== typeof g3.getSnapshotBeforeUpdate || h5 === a3.memoizedProps && r2 === a3.memoizedState || (b4.flags |= 1024), d3 = false);
  }
  return kj(a3, b4, c2, d3, f4, e2);
}
function kj(a3, b4, c2, d3, e2, f4) {
  hj(a3, b4);
  var g3 = 0 !== (b4.flags & 128);
  if (!d3 && !g3)
    return e2 && dg(b4, c2, false), $i(a3, b4, f4);
  d3 = b4.stateNode;
  Xi.current = b4;
  var h5 = g3 && "function" !== typeof c2.getDerivedStateFromError ? null : d3.render();
  b4.flags |= 1;
  null !== a3 && g3 ? (b4.child = Bh(b4, a3.child, null, f4), b4.child = Bh(b4, null, h5, f4)) : Yi(a3, b4, h5, f4);
  b4.memoizedState = d3.state;
  e2 && dg(b4, c2, true);
  return b4.child;
}
function lj(a3) {
  var b4 = a3.stateNode;
  b4.pendingContext ? ag(a3, b4.pendingContext, b4.pendingContext !== b4.context) : b4.context && ag(a3, b4.context, false);
  Ih(a3, b4.containerInfo);
}
function mj(a3, b4, c2, d3, e2) {
  Ig();
  Jg(e2);
  b4.flags |= 256;
  Yi(a3, b4, c2, d3);
  return b4.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a3) {
  return { baseLanes: a3, cachePool: null, transitions: null };
}
function pj(a3, b4, c2) {
  var d3 = b4.pendingProps, e2 = M.current, f4 = false, g3 = 0 !== (b4.flags & 128), h5;
  (h5 = g3) || (h5 = null !== a3 && null === a3.memoizedState ? false : 0 !== (e2 & 2));
  if (h5)
    f4 = true, b4.flags &= -129;
  else if (null === a3 || null !== a3.memoizedState)
    e2 |= 1;
  G(M, e2 & 1);
  if (null === a3) {
    Eg(b4);
    a3 = b4.memoizedState;
    if (null !== a3 && (a3 = a3.dehydrated, null !== a3))
      return 0 === (b4.mode & 1) ? b4.lanes = 1 : "$!" === a3.data ? b4.lanes = 8 : b4.lanes = 1073741824, null;
    g3 = d3.children;
    a3 = d3.fallback;
    return f4 ? (d3 = b4.mode, f4 = b4.child, g3 = { mode: "hidden", children: g3 }, 0 === (d3 & 1) && null !== f4 ? (f4.childLanes = 0, f4.pendingProps = g3) : f4 = qj(g3, d3, 0, null), a3 = Ah(a3, d3, c2, null), f4.return = b4, a3.return = b4, f4.sibling = a3, b4.child = f4, b4.child.memoizedState = oj(c2), b4.memoizedState = nj, a3) : rj(b4, g3);
  }
  e2 = a3.memoizedState;
  if (null !== e2 && (h5 = e2.dehydrated, null !== h5))
    return sj(a3, b4, g3, d3, h5, e2, c2);
  if (f4) {
    f4 = d3.fallback;
    g3 = b4.mode;
    e2 = a3.child;
    h5 = e2.sibling;
    var k3 = { mode: "hidden", children: d3.children };
    0 === (g3 & 1) && b4.child !== e2 ? (d3 = b4.child, d3.childLanes = 0, d3.pendingProps = k3, b4.deletions = null) : (d3 = wh(e2, k3), d3.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h5 ? f4 = wh(h5, f4) : (f4 = Ah(f4, g3, c2, null), f4.flags |= 2);
    f4.return = b4;
    d3.return = b4;
    d3.sibling = f4;
    b4.child = d3;
    d3 = f4;
    f4 = b4.child;
    g3 = a3.child.memoizedState;
    g3 = null === g3 ? oj(c2) : { baseLanes: g3.baseLanes | c2, cachePool: null, transitions: g3.transitions };
    f4.memoizedState = g3;
    f4.childLanes = a3.childLanes & ~c2;
    b4.memoizedState = nj;
    return d3;
  }
  f4 = a3.child;
  a3 = f4.sibling;
  d3 = wh(f4, { mode: "visible", children: d3.children });
  0 === (b4.mode & 1) && (d3.lanes = c2);
  d3.return = b4;
  d3.sibling = null;
  null !== a3 && (c2 = b4.deletions, null === c2 ? (b4.deletions = [a3], b4.flags |= 16) : c2.push(a3));
  b4.child = d3;
  b4.memoizedState = null;
  return d3;
}
function rj(a3, b4) {
  b4 = qj({ mode: "visible", children: b4 }, a3.mode, 0, null);
  b4.return = a3;
  return a3.child = b4;
}
function tj(a3, b4, c2, d3) {
  null !== d3 && Jg(d3);
  Bh(b4, a3.child, null, c2);
  a3 = rj(b4, b4.pendingProps.children);
  a3.flags |= 2;
  b4.memoizedState = null;
  return a3;
}
function sj(a3, b4, c2, d3, e2, f4, g3) {
  if (c2) {
    if (b4.flags & 256)
      return b4.flags &= -257, d3 = Li(Error(p(422))), tj(a3, b4, g3, d3);
    if (null !== b4.memoizedState)
      return b4.child = a3.child, b4.flags |= 128, null;
    f4 = d3.fallback;
    e2 = b4.mode;
    d3 = qj({ mode: "visible", children: d3.children }, e2, 0, null);
    f4 = Ah(f4, e2, g3, null);
    f4.flags |= 2;
    d3.return = b4;
    f4.return = b4;
    d3.sibling = f4;
    b4.child = d3;
    0 !== (b4.mode & 1) && Bh(b4, a3.child, null, g3);
    b4.child.memoizedState = oj(g3);
    b4.memoizedState = nj;
    return f4;
  }
  if (0 === (b4.mode & 1))
    return tj(a3, b4, g3, null);
  if ("$!" === e2.data) {
    d3 = e2.nextSibling && e2.nextSibling.dataset;
    if (d3)
      var h5 = d3.dgst;
    d3 = h5;
    f4 = Error(p(419));
    d3 = Li(f4, d3, void 0);
    return tj(a3, b4, g3, d3);
  }
  h5 = 0 !== (g3 & a3.childLanes);
  if (Ug || h5) {
    d3 = R;
    if (null !== d3) {
      switch (g3 & -g3) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d3.suspendedLanes | g3)) ? 0 : e2;
      0 !== e2 && e2 !== f4.retryLane && (f4.retryLane = e2, Zg(a3, e2), mh(d3, a3, e2, -1));
    }
    uj();
    d3 = Li(Error(p(421)));
    return tj(a3, b4, g3, d3);
  }
  if ("$?" === e2.data)
    return b4.flags |= 128, b4.child = a3.child, b4 = vj.bind(null, a3), e2._reactRetry = b4, null;
  a3 = f4.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b4;
  I = true;
  zg = null;
  null !== a3 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a3.id, sg = a3.overflow, qg = b4);
  b4 = rj(b4, d3.children);
  b4.flags |= 4096;
  return b4;
}
function wj(a3, b4, c2) {
  a3.lanes |= b4;
  var d3 = a3.alternate;
  null !== d3 && (d3.lanes |= b4);
  Sg(a3.return, b4, c2);
}
function xj(a3, b4, c2, d3, e2) {
  var f4 = a3.memoizedState;
  null === f4 ? a3.memoizedState = { isBackwards: b4, rendering: null, renderingStartTime: 0, last: d3, tail: c2, tailMode: e2 } : (f4.isBackwards = b4, f4.rendering = null, f4.renderingStartTime = 0, f4.last = d3, f4.tail = c2, f4.tailMode = e2);
}
function yj(a3, b4, c2) {
  var d3 = b4.pendingProps, e2 = d3.revealOrder, f4 = d3.tail;
  Yi(a3, b4, d3.children, c2);
  d3 = M.current;
  if (0 !== (d3 & 2))
    d3 = d3 & 1 | 2, b4.flags |= 128;
  else {
    if (null !== a3 && 0 !== (a3.flags & 128))
      a:
        for (a3 = b4.child; null !== a3; ) {
          if (13 === a3.tag)
            null !== a3.memoizedState && wj(a3, c2, b4);
          else if (19 === a3.tag)
            wj(a3, c2, b4);
          else if (null !== a3.child) {
            a3.child.return = a3;
            a3 = a3.child;
            continue;
          }
          if (a3 === b4)
            break a;
          for (; null === a3.sibling; ) {
            if (null === a3.return || a3.return === b4)
              break a;
            a3 = a3.return;
          }
          a3.sibling.return = a3.return;
          a3 = a3.sibling;
        }
    d3 &= 1;
  }
  G(M, d3);
  if (0 === (b4.mode & 1))
    b4.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b4.child;
        for (e2 = null; null !== c2; )
          a3 = c2.alternate, null !== a3 && null === Mh(a3) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b4.child, b4.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b4, false, e2, c2, f4);
        break;
      case "backwards":
        c2 = null;
        e2 = b4.child;
        for (b4.child = null; null !== e2; ) {
          a3 = e2.alternate;
          if (null !== a3 && null === Mh(a3)) {
            b4.child = e2;
            break;
          }
          a3 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a3;
        }
        xj(b4, true, c2, null, f4);
        break;
      case "together":
        xj(b4, false, null, null, void 0);
        break;
      default:
        b4.memoizedState = null;
    }
  return b4.child;
}
function jj(a3, b4) {
  0 === (b4.mode & 1) && null !== a3 && (a3.alternate = null, b4.alternate = null, b4.flags |= 2);
}
function $i(a3, b4, c2) {
  null !== a3 && (b4.dependencies = a3.dependencies);
  hh |= b4.lanes;
  if (0 === (c2 & b4.childLanes))
    return null;
  if (null !== a3 && b4.child !== a3.child)
    throw Error(p(153));
  if (null !== b4.child) {
    a3 = b4.child;
    c2 = wh(a3, a3.pendingProps);
    b4.child = c2;
    for (c2.return = b4; null !== a3.sibling; )
      a3 = a3.sibling, c2 = c2.sibling = wh(a3, a3.pendingProps), c2.return = b4;
    c2.sibling = null;
  }
  return b4.child;
}
function zj(a3, b4, c2) {
  switch (b4.tag) {
    case 3:
      lj(b4);
      Ig();
      break;
    case 5:
      Kh(b4);
      break;
    case 1:
      Zf(b4.type) && cg(b4);
      break;
    case 4:
      Ih(b4, b4.stateNode.containerInfo);
      break;
    case 10:
      var d3 = b4.type._context, e2 = b4.memoizedProps.value;
      G(Mg, d3._currentValue);
      d3._currentValue = e2;
      break;
    case 13:
      d3 = b4.memoizedState;
      if (null !== d3) {
        if (null !== d3.dehydrated)
          return G(M, M.current & 1), b4.flags |= 128, null;
        if (0 !== (c2 & b4.child.childLanes))
          return pj(a3, b4, c2);
        G(M, M.current & 1);
        a3 = $i(a3, b4, c2);
        return null !== a3 ? a3.sibling : null;
      }
      G(M, M.current & 1);
      break;
    case 19:
      d3 = 0 !== (c2 & b4.childLanes);
      if (0 !== (a3.flags & 128)) {
        if (d3)
          return yj(a3, b4, c2);
        b4.flags |= 128;
      }
      e2 = b4.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(M, M.current);
      if (d3)
        break;
      else
        return null;
    case 22:
    case 23:
      return b4.lanes = 0, ej(a3, b4, c2);
  }
  return $i(a3, b4, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a3, b4) {
  for (var c2 = b4.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a3.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b4)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b4)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a3, b4, c2, d3) {
  var e2 = a3.memoizedProps;
  if (e2 !== d3) {
    a3 = b4.stateNode;
    Hh(Eh.current);
    var f4 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a3, e2);
        d3 = Ya(a3, d3);
        f4 = [];
        break;
      case "select":
        e2 = A({}, e2, { value: void 0 });
        d3 = A({}, d3, { value: void 0 });
        f4 = [];
        break;
      case "textarea":
        e2 = gb(a3, e2);
        d3 = gb(a3, d3);
        f4 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d3.onClick && (a3.onclick = Bf);
    }
    ub(c2, d3);
    var g3;
    c2 = null;
    for (l2 in e2)
      if (!d3.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h5 = e2[l2];
          for (g3 in h5)
            h5.hasOwnProperty(g3) && (c2 || (c2 = {}), c2[g3] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f4 || (f4 = []) : (f4 = f4 || []).push(l2, null));
    for (l2 in d3) {
      var k3 = d3[l2];
      h5 = null != e2 ? e2[l2] : void 0;
      if (d3.hasOwnProperty(l2) && k3 !== h5 && (null != k3 || null != h5))
        if ("style" === l2)
          if (h5) {
            for (g3 in h5)
              !h5.hasOwnProperty(g3) || k3 && k3.hasOwnProperty(g3) || (c2 || (c2 = {}), c2[g3] = "");
            for (g3 in k3)
              k3.hasOwnProperty(g3) && h5[g3] !== k3[g3] && (c2 || (c2 = {}), c2[g3] = k3[g3]);
          } else
            c2 || (f4 || (f4 = []), f4.push(
              l2,
              c2
            )), c2 = k3;
        else
          "dangerouslySetInnerHTML" === l2 ? (k3 = k3 ? k3.__html : void 0, h5 = h5 ? h5.__html : void 0, null != k3 && h5 !== k3 && (f4 = f4 || []).push(l2, k3)) : "children" === l2 ? "string" !== typeof k3 && "number" !== typeof k3 || (f4 = f4 || []).push(l2, "" + k3) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k3 && "onScroll" === l2 && D("scroll", a3), f4 || h5 === k3 || (f4 = [])) : (f4 = f4 || []).push(l2, k3));
    }
    c2 && (f4 = f4 || []).push("style", c2);
    var l2 = f4;
    if (b4.updateQueue = l2)
      b4.flags |= 4;
  }
};
Dj = function(a3, b4, c2, d3) {
  c2 !== d3 && (b4.flags |= 4);
};
function Ej(a3, b4) {
  if (!I)
    switch (a3.tailMode) {
      case "hidden":
        b4 = a3.tail;
        for (var c2 = null; null !== b4; )
          null !== b4.alternate && (c2 = b4), b4 = b4.sibling;
        null === c2 ? a3.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a3.tail;
        for (var d3 = null; null !== c2; )
          null !== c2.alternate && (d3 = c2), c2 = c2.sibling;
        null === d3 ? b4 || null === a3.tail ? a3.tail = null : a3.tail.sibling = null : d3.sibling = null;
    }
}
function S(a3) {
  var b4 = null !== a3.alternate && a3.alternate.child === a3.child, c2 = 0, d3 = 0;
  if (b4)
    for (var e2 = a3.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d3 |= e2.subtreeFlags & 14680064, d3 |= e2.flags & 14680064, e2.return = a3, e2 = e2.sibling;
  else
    for (e2 = a3.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d3 |= e2.subtreeFlags, d3 |= e2.flags, e2.return = a3, e2 = e2.sibling;
  a3.subtreeFlags |= d3;
  a3.childLanes = c2;
  return b4;
}
function Fj(a3, b4, c2) {
  var d3 = b4.pendingProps;
  wg(b4);
  switch (b4.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b4), null;
    case 1:
      return Zf(b4.type) && $f(), S(b4), null;
    case 3:
      d3 = b4.stateNode;
      Jh();
      E(Wf);
      E(H);
      Oh();
      d3.pendingContext && (d3.context = d3.pendingContext, d3.pendingContext = null);
      if (null === a3 || null === a3.child)
        Gg(b4) ? b4.flags |= 4 : null === a3 || a3.memoizedState.isDehydrated && 0 === (b4.flags & 256) || (b4.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a3, b4);
      S(b4);
      return null;
    case 5:
      Lh(b4);
      var e2 = Hh(Gh.current);
      c2 = b4.type;
      if (null !== a3 && null != b4.stateNode)
        Cj(a3, b4, c2, d3, e2), a3.ref !== b4.ref && (b4.flags |= 512, b4.flags |= 2097152);
      else {
        if (!d3) {
          if (null === b4.stateNode)
            throw Error(p(166));
          S(b4);
          return null;
        }
        a3 = Hh(Eh.current);
        if (Gg(b4)) {
          d3 = b4.stateNode;
          c2 = b4.type;
          var f4 = b4.memoizedProps;
          d3[Of] = b4;
          d3[Pf] = f4;
          a3 = 0 !== (b4.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d3);
              D("close", d3);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d3);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D(lf[e2], d3);
              break;
            case "source":
              D("error", d3);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d3
              );
              D("load", d3);
              break;
            case "details":
              D("toggle", d3);
              break;
            case "input":
              Za(d3, f4);
              D("invalid", d3);
              break;
            case "select":
              d3._wrapperState = { wasMultiple: !!f4.multiple };
              D("invalid", d3);
              break;
            case "textarea":
              hb(d3, f4), D("invalid", d3);
          }
          ub(c2, f4);
          e2 = null;
          for (var g3 in f4)
            if (f4.hasOwnProperty(g3)) {
              var h5 = f4[g3];
              "children" === g3 ? "string" === typeof h5 ? d3.textContent !== h5 && (true !== f4.suppressHydrationWarning && Af(d3.textContent, h5, a3), e2 = ["children", h5]) : "number" === typeof h5 && d3.textContent !== "" + h5 && (true !== f4.suppressHydrationWarning && Af(
                d3.textContent,
                h5,
                a3
              ), e2 = ["children", "" + h5]) : ea.hasOwnProperty(g3) && null != h5 && "onScroll" === g3 && D("scroll", d3);
            }
          switch (c2) {
            case "input":
              Va(d3);
              db(d3, f4, true);
              break;
            case "textarea":
              Va(d3);
              jb(d3);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f4.onClick && (d3.onclick = Bf);
          }
          d3 = e2;
          b4.updateQueue = d3;
          null !== d3 && (b4.flags |= 4);
        } else {
          g3 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a3 && (a3 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a3 ? "script" === c2 ? (a3 = g3.createElement("div"), a3.innerHTML = "<script><\/script>", a3 = a3.removeChild(a3.firstChild)) : "string" === typeof d3.is ? a3 = g3.createElement(c2, { is: d3.is }) : (a3 = g3.createElement(c2), "select" === c2 && (g3 = a3, d3.multiple ? g3.multiple = true : d3.size && (g3.size = d3.size))) : a3 = g3.createElementNS(a3, c2);
          a3[Of] = b4;
          a3[Pf] = d3;
          Aj(a3, b4, false, false);
          b4.stateNode = a3;
          a: {
            g3 = vb(c2, d3);
            switch (c2) {
              case "dialog":
                D("cancel", a3);
                D("close", a3);
                e2 = d3;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a3);
                e2 = d3;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D(lf[e2], a3);
                e2 = d3;
                break;
              case "source":
                D("error", a3);
                e2 = d3;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a3
                );
                D("load", a3);
                e2 = d3;
                break;
              case "details":
                D("toggle", a3);
                e2 = d3;
                break;
              case "input":
                Za(a3, d3);
                e2 = Ya(a3, d3);
                D("invalid", a3);
                break;
              case "option":
                e2 = d3;
                break;
              case "select":
                a3._wrapperState = { wasMultiple: !!d3.multiple };
                e2 = A({}, d3, { value: void 0 });
                D("invalid", a3);
                break;
              case "textarea":
                hb(a3, d3);
                e2 = gb(a3, d3);
                D("invalid", a3);
                break;
              default:
                e2 = d3;
            }
            ub(c2, e2);
            h5 = e2;
            for (f4 in h5)
              if (h5.hasOwnProperty(f4)) {
                var k3 = h5[f4];
                "style" === f4 ? sb(a3, k3) : "dangerouslySetInnerHTML" === f4 ? (k3 = k3 ? k3.__html : void 0, null != k3 && nb(a3, k3)) : "children" === f4 ? "string" === typeof k3 ? ("textarea" !== c2 || "" !== k3) && ob(a3, k3) : "number" === typeof k3 && ob(a3, "" + k3) : "suppressContentEditableWarning" !== f4 && "suppressHydrationWarning" !== f4 && "autoFocus" !== f4 && (ea.hasOwnProperty(f4) ? null != k3 && "onScroll" === f4 && D("scroll", a3) : null != k3 && ta(a3, f4, k3, g3));
              }
            switch (c2) {
              case "input":
                Va(a3);
                db(a3, d3, false);
                break;
              case "textarea":
                Va(a3);
                jb(a3);
                break;
              case "option":
                null != d3.value && a3.setAttribute("value", "" + Sa(d3.value));
                break;
              case "select":
                a3.multiple = !!d3.multiple;
                f4 = d3.value;
                null != f4 ? fb(a3, !!d3.multiple, f4, false) : null != d3.defaultValue && fb(
                  a3,
                  !!d3.multiple,
                  d3.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a3.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d3 = !!d3.autoFocus;
                break a;
              case "img":
                d3 = true;
                break a;
              default:
                d3 = false;
            }
          }
          d3 && (b4.flags |= 4);
        }
        null !== b4.ref && (b4.flags |= 512, b4.flags |= 2097152);
      }
      S(b4);
      return null;
    case 6:
      if (a3 && null != b4.stateNode)
        Dj(a3, b4, a3.memoizedProps, d3);
      else {
        if ("string" !== typeof d3 && null === b4.stateNode)
          throw Error(p(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b4)) {
          d3 = b4.stateNode;
          c2 = b4.memoizedProps;
          d3[Of] = b4;
          if (f4 = d3.nodeValue !== c2) {
            if (a3 = xg, null !== a3)
              switch (a3.tag) {
                case 3:
                  Af(d3.nodeValue, c2, 0 !== (a3.mode & 1));
                  break;
                case 5:
                  true !== a3.memoizedProps.suppressHydrationWarning && Af(d3.nodeValue, c2, 0 !== (a3.mode & 1));
              }
          }
          f4 && (b4.flags |= 4);
        } else
          d3 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d3), d3[Of] = b4, b4.stateNode = d3;
      }
      S(b4);
      return null;
    case 13:
      E(M);
      d3 = b4.memoizedState;
      if (null === a3 || null !== a3.memoizedState && null !== a3.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b4.mode & 1) && 0 === (b4.flags & 128))
          Hg(), Ig(), b4.flags |= 98560, f4 = false;
        else if (f4 = Gg(b4), null !== d3 && null !== d3.dehydrated) {
          if (null === a3) {
            if (!f4)
              throw Error(p(318));
            f4 = b4.memoizedState;
            f4 = null !== f4 ? f4.dehydrated : null;
            if (!f4)
              throw Error(p(317));
            f4[Of] = b4;
          } else
            Ig(), 0 === (b4.flags & 128) && (b4.memoizedState = null), b4.flags |= 4;
          S(b4);
          f4 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f4 = true;
        if (!f4)
          return b4.flags & 65536 ? b4 : null;
      }
      if (0 !== (b4.flags & 128))
        return b4.lanes = c2, b4;
      d3 = null !== d3;
      d3 !== (null !== a3 && null !== a3.memoizedState) && d3 && (b4.child.flags |= 8192, 0 !== (b4.mode & 1) && (null === a3 || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
      null !== b4.updateQueue && (b4.flags |= 4);
      S(b4);
      return null;
    case 4:
      return Jh(), Bj(a3, b4), null === a3 && sf(b4.stateNode.containerInfo), S(b4), null;
    case 10:
      return Rg(b4.type._context), S(b4), null;
    case 17:
      return Zf(b4.type) && $f(), S(b4), null;
    case 19:
      E(M);
      f4 = b4.memoizedState;
      if (null === f4)
        return S(b4), null;
      d3 = 0 !== (b4.flags & 128);
      g3 = f4.rendering;
      if (null === g3)
        if (d3)
          Ej(f4, false);
        else {
          if (0 !== T || null !== a3 && 0 !== (a3.flags & 128))
            for (a3 = b4.child; null !== a3; ) {
              g3 = Mh(a3);
              if (null !== g3) {
                b4.flags |= 128;
                Ej(f4, false);
                d3 = g3.updateQueue;
                null !== d3 && (b4.updateQueue = d3, b4.flags |= 4);
                b4.subtreeFlags = 0;
                d3 = c2;
                for (c2 = b4.child; null !== c2; )
                  f4 = c2, a3 = d3, f4.flags &= 14680066, g3 = f4.alternate, null === g3 ? (f4.childLanes = 0, f4.lanes = a3, f4.child = null, f4.subtreeFlags = 0, f4.memoizedProps = null, f4.memoizedState = null, f4.updateQueue = null, f4.dependencies = null, f4.stateNode = null) : (f4.childLanes = g3.childLanes, f4.lanes = g3.lanes, f4.child = g3.child, f4.subtreeFlags = 0, f4.deletions = null, f4.memoizedProps = g3.memoizedProps, f4.memoizedState = g3.memoizedState, f4.updateQueue = g3.updateQueue, f4.type = g3.type, a3 = g3.dependencies, f4.dependencies = null === a3 ? null : { lanes: a3.lanes, firstContext: a3.firstContext }), c2 = c2.sibling;
                G(M, M.current & 1 | 2);
                return b4.child;
              }
              a3 = a3.sibling;
            }
          null !== f4.tail && B() > Hj && (b4.flags |= 128, d3 = true, Ej(f4, false), b4.lanes = 4194304);
        }
      else {
        if (!d3)
          if (a3 = Mh(g3), null !== a3) {
            if (b4.flags |= 128, d3 = true, c2 = a3.updateQueue, null !== c2 && (b4.updateQueue = c2, b4.flags |= 4), Ej(f4, true), null === f4.tail && "hidden" === f4.tailMode && !g3.alternate && !I)
              return S(b4), null;
          } else
            2 * B() - f4.renderingStartTime > Hj && 1073741824 !== c2 && (b4.flags |= 128, d3 = true, Ej(f4, false), b4.lanes = 4194304);
        f4.isBackwards ? (g3.sibling = b4.child, b4.child = g3) : (c2 = f4.last, null !== c2 ? c2.sibling = g3 : b4.child = g3, f4.last = g3);
      }
      if (null !== f4.tail)
        return b4 = f4.tail, f4.rendering = b4, f4.tail = b4.sibling, f4.renderingStartTime = B(), b4.sibling = null, c2 = M.current, G(M, d3 ? c2 & 1 | 2 : c2 & 1), b4;
      S(b4);
      return null;
    case 22:
    case 23:
      return Ij(), d3 = null !== b4.memoizedState, null !== a3 && null !== a3.memoizedState !== d3 && (b4.flags |= 8192), d3 && 0 !== (b4.mode & 1) ? 0 !== (gj & 1073741824) && (S(b4), b4.subtreeFlags & 6 && (b4.flags |= 8192)) : S(b4), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p(156, b4.tag));
}
function Jj(a3, b4) {
  wg(b4);
  switch (b4.tag) {
    case 1:
      return Zf(b4.type) && $f(), a3 = b4.flags, a3 & 65536 ? (b4.flags = a3 & -65537 | 128, b4) : null;
    case 3:
      return Jh(), E(Wf), E(H), Oh(), a3 = b4.flags, 0 !== (a3 & 65536) && 0 === (a3 & 128) ? (b4.flags = a3 & -65537 | 128, b4) : null;
    case 5:
      return Lh(b4), null;
    case 13:
      E(M);
      a3 = b4.memoizedState;
      if (null !== a3 && null !== a3.dehydrated) {
        if (null === b4.alternate)
          throw Error(p(340));
        Ig();
      }
      a3 = b4.flags;
      return a3 & 65536 ? (b4.flags = a3 & -65537 | 128, b4) : null;
    case 19:
      return E(M), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b4.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Mj(a3, b4) {
  var c2 = a3.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d3) {
        W(a3, b4, d3);
      }
    else
      c2.current = null;
}
function Nj(a3, b4, c2) {
  try {
    c2();
  } catch (d3) {
    W(a3, b4, d3);
  }
}
var Oj = false;
function Pj(a3, b4) {
  Cf = dd;
  a3 = Me();
  if (Ne(a3)) {
    if ("selectionStart" in a3)
      var c2 = { start: a3.selectionStart, end: a3.selectionEnd };
    else
      a: {
        c2 = (c2 = a3.ownerDocument) && c2.defaultView || window;
        var d3 = c2.getSelection && c2.getSelection();
        if (d3 && 0 !== d3.rangeCount) {
          c2 = d3.anchorNode;
          var e2 = d3.anchorOffset, f4 = d3.focusNode;
          d3 = d3.focusOffset;
          try {
            c2.nodeType, f4.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g3 = 0, h5 = -1, k3 = -1, l2 = 0, m2 = 0, q2 = a3, r2 = null;
          b:
            for (; ; ) {
              for (var y3; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h5 = g3 + e2);
                q2 !== f4 || 0 !== d3 && 3 !== q2.nodeType || (k3 = g3 + d3);
                3 === q2.nodeType && (g3 += q2.nodeValue.length);
                if (null === (y3 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y3;
              }
              for (; ; ) {
                if (q2 === a3)
                  break b;
                r2 === c2 && ++l2 === e2 && (h5 = g3);
                r2 === f4 && ++m2 === d3 && (k3 = g3);
                if (null !== (y3 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y3;
            }
          c2 = -1 === h5 || -1 === k3 ? null : { start: h5, end: k3 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a3, selectionRange: c2 };
  dd = false;
  for (V = b4; null !== V; )
    if (b4 = V, a3 = b4.child, 0 !== (b4.subtreeFlags & 1028) && null !== a3)
      a3.return = b4, V = a3;
    else
      for (; null !== V; ) {
        b4 = V;
        try {
          var n4 = b4.alternate;
          if (0 !== (b4.flags & 1024))
            switch (b4.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n4) {
                  var t2 = n4.memoizedProps, J2 = n4.memoizedState, x2 = b4.stateNode, w3 = x2.getSnapshotBeforeUpdate(b4.elementType === b4.type ? t2 : Lg(b4.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w3;
                }
                break;
              case 3:
                var u3 = b4.stateNode.containerInfo;
                1 === u3.nodeType ? u3.textContent = "" : 9 === u3.nodeType && u3.documentElement && u3.removeChild(u3.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p(163));
            }
        } catch (F2) {
          W(b4, b4.return, F2);
        }
        a3 = b4.sibling;
        if (null !== a3) {
          a3.return = b4.return;
          V = a3;
          break;
        }
        V = b4.return;
      }
  n4 = Oj;
  Oj = false;
  return n4;
}
function Qj(a3, b4, c2) {
  var d3 = b4.updateQueue;
  d3 = null !== d3 ? d3.lastEffect : null;
  if (null !== d3) {
    var e2 = d3 = d3.next;
    do {
      if ((e2.tag & a3) === a3) {
        var f4 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f4 && Nj(b4, c2, f4);
      }
      e2 = e2.next;
    } while (e2 !== d3);
  }
}
function Rj(a3, b4) {
  b4 = b4.updateQueue;
  b4 = null !== b4 ? b4.lastEffect : null;
  if (null !== b4) {
    var c2 = b4 = b4.next;
    do {
      if ((c2.tag & a3) === a3) {
        var d3 = c2.create;
        c2.destroy = d3();
      }
      c2 = c2.next;
    } while (c2 !== b4);
  }
}
function Sj(a3) {
  var b4 = a3.ref;
  if (null !== b4) {
    var c2 = a3.stateNode;
    switch (a3.tag) {
      case 5:
        a3 = c2;
        break;
      default:
        a3 = c2;
    }
    "function" === typeof b4 ? b4(a3) : b4.current = a3;
  }
}
function Tj(a3) {
  var b4 = a3.alternate;
  null !== b4 && (a3.alternate = null, Tj(b4));
  a3.child = null;
  a3.deletions = null;
  a3.sibling = null;
  5 === a3.tag && (b4 = a3.stateNode, null !== b4 && (delete b4[Of], delete b4[Pf], delete b4[of], delete b4[Qf], delete b4[Rf]));
  a3.stateNode = null;
  a3.return = null;
  a3.dependencies = null;
  a3.memoizedProps = null;
  a3.memoizedState = null;
  a3.pendingProps = null;
  a3.stateNode = null;
  a3.updateQueue = null;
}
function Uj(a3) {
  return 5 === a3.tag || 3 === a3.tag || 4 === a3.tag;
}
function Vj(a3) {
  a:
    for (; ; ) {
      for (; null === a3.sibling; ) {
        if (null === a3.return || Uj(a3.return))
          return null;
        a3 = a3.return;
      }
      a3.sibling.return = a3.return;
      for (a3 = a3.sibling; 5 !== a3.tag && 6 !== a3.tag && 18 !== a3.tag; ) {
        if (a3.flags & 2)
          continue a;
        if (null === a3.child || 4 === a3.tag)
          continue a;
        else
          a3.child.return = a3, a3 = a3.child;
      }
      if (!(a3.flags & 2))
        return a3.stateNode;
    }
}
function Wj(a3, b4, c2) {
  var d3 = a3.tag;
  if (5 === d3 || 6 === d3)
    a3 = a3.stateNode, b4 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a3, b4) : c2.insertBefore(a3, b4) : (8 === c2.nodeType ? (b4 = c2.parentNode, b4.insertBefore(a3, c2)) : (b4 = c2, b4.appendChild(a3)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b4.onclick || (b4.onclick = Bf));
  else if (4 !== d3 && (a3 = a3.child, null !== a3))
    for (Wj(a3, b4, c2), a3 = a3.sibling; null !== a3; )
      Wj(a3, b4, c2), a3 = a3.sibling;
}
function Xj(a3, b4, c2) {
  var d3 = a3.tag;
  if (5 === d3 || 6 === d3)
    a3 = a3.stateNode, b4 ? c2.insertBefore(a3, b4) : c2.appendChild(a3);
  else if (4 !== d3 && (a3 = a3.child, null !== a3))
    for (Xj(a3, b4, c2), a3 = a3.sibling; null !== a3; )
      Xj(a3, b4, c2), a3 = a3.sibling;
}
var X = null, Yj = false;
function Zj(a3, b4, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a3, b4, c2), c2 = c2.sibling;
}
function ak(a3, b4, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h5) {
    }
  switch (c2.tag) {
    case 5:
      U || Mj(c2, b4);
    case 6:
      var d3 = X, e2 = Yj;
      X = null;
      Zj(a3, b4, c2);
      X = d3;
      Yj = e2;
      null !== X && (Yj ? (a3 = X, c2 = c2.stateNode, 8 === a3.nodeType ? a3.parentNode.removeChild(c2) : a3.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Yj ? (a3 = X, c2 = c2.stateNode, 8 === a3.nodeType ? Kf(a3.parentNode, c2) : 1 === a3.nodeType && Kf(a3, c2), bd(a3)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d3 = X;
      e2 = Yj;
      X = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a3, b4, c2);
      X = d3;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d3 = c2.updateQueue, null !== d3 && (d3 = d3.lastEffect, null !== d3))) {
        e2 = d3 = d3.next;
        do {
          var f4 = e2, g3 = f4.destroy;
          f4 = f4.tag;
          void 0 !== g3 && (0 !== (f4 & 2) ? Nj(c2, b4, g3) : 0 !== (f4 & 4) && Nj(c2, b4, g3));
          e2 = e2.next;
        } while (e2 !== d3);
      }
      Zj(a3, b4, c2);
      break;
    case 1:
      if (!U && (Mj(c2, b4), d3 = c2.stateNode, "function" === typeof d3.componentWillUnmount))
        try {
          d3.props = c2.memoizedProps, d3.state = c2.memoizedState, d3.componentWillUnmount();
        } catch (h5) {
          W(c2, b4, h5);
        }
      Zj(a3, b4, c2);
      break;
    case 21:
      Zj(a3, b4, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d3 = U) || null !== c2.memoizedState, Zj(a3, b4, c2), U = d3) : Zj(a3, b4, c2);
      break;
    default:
      Zj(a3, b4, c2);
  }
}
function bk(a3) {
  var b4 = a3.updateQueue;
  if (null !== b4) {
    a3.updateQueue = null;
    var c2 = a3.stateNode;
    null === c2 && (c2 = a3.stateNode = new Lj());
    b4.forEach(function(b5) {
      var d3 = ck.bind(null, a3, b5);
      c2.has(b5) || (c2.add(b5), b5.then(d3, d3));
    });
  }
}
function dk(a3, b4) {
  var c2 = b4.deletions;
  if (null !== c2)
    for (var d3 = 0; d3 < c2.length; d3++) {
      var e2 = c2[d3];
      try {
        var f4 = a3, g3 = b4, h5 = g3;
        a:
          for (; null !== h5; ) {
            switch (h5.tag) {
              case 5:
                X = h5.stateNode;
                Yj = false;
                break a;
              case 3:
                X = h5.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X = h5.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h5 = h5.return;
          }
        if (null === X)
          throw Error(p(160));
        ak(f4, g3, e2);
        X = null;
        Yj = false;
        var k3 = e2.alternate;
        null !== k3 && (k3.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b4, l2);
      }
    }
  if (b4.subtreeFlags & 12854)
    for (b4 = b4.child; null !== b4; )
      ek(b4, a3), b4 = b4.sibling;
}
function ek(a3, b4) {
  var c2 = a3.alternate, d3 = a3.flags;
  switch (a3.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b4, a3);
      fk(a3);
      if (d3 & 4) {
        try {
          Qj(3, a3, a3.return), Rj(3, a3);
        } catch (t2) {
          W(a3, a3.return, t2);
        }
        try {
          Qj(5, a3, a3.return);
        } catch (t2) {
          W(a3, a3.return, t2);
        }
      }
      break;
    case 1:
      dk(b4, a3);
      fk(a3);
      d3 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b4, a3);
      fk(a3);
      d3 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a3.flags & 32) {
        var e2 = a3.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a3, a3.return, t2);
        }
      }
      if (d3 & 4 && (e2 = a3.stateNode, null != e2)) {
        var f4 = a3.memoizedProps, g3 = null !== c2 ? c2.memoizedProps : f4, h5 = a3.type, k3 = a3.updateQueue;
        a3.updateQueue = null;
        if (null !== k3)
          try {
            "input" === h5 && "radio" === f4.type && null != f4.name && ab(e2, f4);
            vb(h5, g3);
            var l2 = vb(h5, f4);
            for (g3 = 0; g3 < k3.length; g3 += 2) {
              var m2 = k3[g3], q2 = k3[g3 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h5) {
              case "input":
                bb(e2, f4);
                break;
              case "textarea":
                ib(e2, f4);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f4.multiple;
                var y3 = f4.value;
                null != y3 ? fb(e2, !!f4.multiple, y3, false) : r2 !== !!f4.multiple && (null != f4.defaultValue ? fb(
                  e2,
                  !!f4.multiple,
                  f4.defaultValue,
                  true
                ) : fb(e2, !!f4.multiple, f4.multiple ? [] : "", false));
            }
            e2[Pf] = f4;
          } catch (t2) {
            W(a3, a3.return, t2);
          }
      }
      break;
    case 6:
      dk(b4, a3);
      fk(a3);
      if (d3 & 4) {
        if (null === a3.stateNode)
          throw Error(p(162));
        e2 = a3.stateNode;
        f4 = a3.memoizedProps;
        try {
          e2.nodeValue = f4;
        } catch (t2) {
          W(a3, a3.return, t2);
        }
      }
      break;
    case 3:
      dk(b4, a3);
      fk(a3);
      if (d3 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b4.containerInfo);
        } catch (t2) {
          W(a3, a3.return, t2);
        }
      break;
    case 4:
      dk(b4, a3);
      fk(a3);
      break;
    case 13:
      dk(b4, a3);
      fk(a3);
      e2 = a3.child;
      e2.flags & 8192 && (f4 = null !== e2.memoizedState, e2.stateNode.isHidden = f4, !f4 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
      d3 & 4 && bk(a3);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a3.mode & 1 ? (U = (l2 = U) || m2, dk(b4, a3), U = l2) : dk(b4, a3);
      fk(a3);
      if (d3 & 8192) {
        l2 = null !== a3.memoizedState;
        if ((a3.stateNode.isHidden = l2) && !m2 && 0 !== (a3.mode & 1))
          for (V = a3, m2 = a3.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y3 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n4 = r2.stateNode;
                  if ("function" === typeof n4.componentWillUnmount) {
                    d3 = r2;
                    c2 = r2.return;
                    try {
                      b4 = d3, n4.props = b4.memoizedProps, n4.state = b4.memoizedState, n4.componentWillUnmount();
                    } catch (t2) {
                      W(d3, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y3 ? (y3.return = r2, V = y3) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a3; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f4 = e2.style, "function" === typeof f4.setProperty ? f4.setProperty("display", "none", "important") : f4.display = "none") : (h5 = q2.stateNode, k3 = q2.memoizedProps.style, g3 = void 0 !== k3 && null !== k3 && k3.hasOwnProperty("display") ? k3.display : null, h5.style.display = rb("display", g3));
                } catch (t2) {
                  W(a3, a3.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a3, a3.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a3) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a3)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a3)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b4, a3);
      fk(a3);
      d3 & 4 && bk(a3);
      break;
    case 21:
      break;
    default:
      dk(
        b4,
        a3
      ), fk(a3);
  }
}
function fk(a3) {
  var b4 = a3.flags;
  if (b4 & 2) {
    try {
      a: {
        for (var c2 = a3.return; null !== c2; ) {
          if (Uj(c2)) {
            var d3 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p(160));
      }
      switch (d3.tag) {
        case 5:
          var e2 = d3.stateNode;
          d3.flags & 32 && (ob(e2, ""), d3.flags &= -33);
          var f4 = Vj(a3);
          Xj(a3, f4, e2);
          break;
        case 3:
        case 4:
          var g3 = d3.stateNode.containerInfo, h5 = Vj(a3);
          Wj(a3, h5, g3);
          break;
        default:
          throw Error(p(161));
      }
    } catch (k3) {
      W(a3, a3.return, k3);
    }
    a3.flags &= -3;
  }
  b4 & 4096 && (a3.flags &= -4097);
}
function ik(a3, b4, c2) {
  V = a3;
  jk(a3);
}
function jk(a3, b4, c2) {
  for (var d3 = 0 !== (a3.mode & 1); null !== V; ) {
    var e2 = V, f4 = e2.child;
    if (22 === e2.tag && d3) {
      var g3 = null !== e2.memoizedState || Kj;
      if (!g3) {
        var h5 = e2.alternate, k3 = null !== h5 && null !== h5.memoizedState || U;
        h5 = Kj;
        var l2 = U;
        Kj = g3;
        if ((U = k3) && !l2)
          for (V = e2; null !== V; )
            g3 = V, k3 = g3.child, 22 === g3.tag && null !== g3.memoizedState ? kk(e2) : null !== k3 ? (k3.return = g3, V = k3) : kk(e2);
        for (; null !== f4; )
          V = f4, jk(f4), f4 = f4.sibling;
        V = e2;
        Kj = h5;
        U = l2;
      }
      lk(a3);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f4 ? (f4.return = e2, V = f4) : lk(a3);
  }
}
function lk(a3) {
  for (; null !== V; ) {
    var b4 = V;
    if (0 !== (b4.flags & 8772)) {
      var c2 = b4.alternate;
      try {
        if (0 !== (b4.flags & 8772))
          switch (b4.tag) {
            case 0:
            case 11:
            case 15:
              U || Rj(5, b4);
              break;
            case 1:
              var d3 = b4.stateNode;
              if (b4.flags & 4 && !U)
                if (null === c2)
                  d3.componentDidMount();
                else {
                  var e2 = b4.elementType === b4.type ? c2.memoizedProps : Lg(b4.type, c2.memoizedProps);
                  d3.componentDidUpdate(e2, c2.memoizedState, d3.__reactInternalSnapshotBeforeUpdate);
                }
              var f4 = b4.updateQueue;
              null !== f4 && ih(b4, f4, d3);
              break;
            case 3:
              var g3 = b4.updateQueue;
              if (null !== g3) {
                c2 = null;
                if (null !== b4.child)
                  switch (b4.child.tag) {
                    case 5:
                      c2 = b4.child.stateNode;
                      break;
                    case 1:
                      c2 = b4.child.stateNode;
                  }
                ih(b4, g3, c2);
              }
              break;
            case 5:
              var h5 = b4.stateNode;
              if (null === c2 && b4.flags & 4) {
                c2 = h5;
                var k3 = b4.memoizedProps;
                switch (b4.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k3.autoFocus && c2.focus();
                    break;
                  case "img":
                    k3.src && (c2.src = k3.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b4.memoizedState) {
                var l2 = b4.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p(163));
          }
        U || b4.flags & 512 && Sj(b4);
      } catch (r2) {
        W(b4, b4.return, r2);
      }
    }
    if (b4 === a3) {
      V = null;
      break;
    }
    c2 = b4.sibling;
    if (null !== c2) {
      c2.return = b4.return;
      V = c2;
      break;
    }
    V = b4.return;
  }
}
function hk(a3) {
  for (; null !== V; ) {
    var b4 = V;
    if (b4 === a3) {
      V = null;
      break;
    }
    var c2 = b4.sibling;
    if (null !== c2) {
      c2.return = b4.return;
      V = c2;
      break;
    }
    V = b4.return;
  }
}
function kk(a3) {
  for (; null !== V; ) {
    var b4 = V;
    try {
      switch (b4.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b4.return;
          try {
            Rj(4, b4);
          } catch (k3) {
            W(b4, c2, k3);
          }
          break;
        case 1:
          var d3 = b4.stateNode;
          if ("function" === typeof d3.componentDidMount) {
            var e2 = b4.return;
            try {
              d3.componentDidMount();
            } catch (k3) {
              W(b4, e2, k3);
            }
          }
          var f4 = b4.return;
          try {
            Sj(b4);
          } catch (k3) {
            W(b4, f4, k3);
          }
          break;
        case 5:
          var g3 = b4.return;
          try {
            Sj(b4);
          } catch (k3) {
            W(b4, g3, k3);
          }
      }
    } catch (k3) {
      W(b4, b4.return, k3);
    }
    if (b4 === a3) {
      V = null;
      break;
    }
    var h5 = b4.sibling;
    if (null !== h5) {
      h5.return = b4.return;
      V = h5;
      break;
    }
    V = b4.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L() {
  return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a3) {
  if (0 === (a3.mode & 1))
    return 1;
  if (0 !== (K & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a3 = C;
  if (0 !== a3)
    return a3;
  a3 = window.event;
  a3 = void 0 === a3 ? 16 : jd(a3.type);
  return a3;
}
function mh(a3, b4, c2, d3) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p(185));
  Ac(a3, c2, d3);
  if (0 === (K & 2) || a3 !== R)
    a3 === R && (0 === (K & 2) && (rk |= c2), 4 === T && Dk(a3, Z)), Ek(a3, d3), 1 === c2 && 0 === K && 0 === (b4.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a3, b4) {
  var c2 = a3.callbackNode;
  wc(a3, b4);
  var d3 = uc(a3, a3 === R ? Z : 0);
  if (0 === d3)
    null !== c2 && bc(c2), a3.callbackNode = null, a3.callbackPriority = 0;
  else if (b4 = d3 & -d3, a3.callbackPriority !== b4) {
    null != c2 && bc(c2);
    if (1 === b4)
      0 === a3.tag ? ig(Fk.bind(null, a3)) : hg(Fk.bind(null, a3)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d3)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a3));
    }
    a3.callbackPriority = b4;
    a3.callbackNode = c2;
  }
}
function Hk(a3, b4) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6))
    throw Error(p(327));
  var c2 = a3.callbackNode;
  if (Ik() && a3.callbackNode !== c2)
    return null;
  var d3 = uc(a3, a3 === R ? Z : 0);
  if (0 === d3)
    return null;
  if (0 !== (d3 & 30) || 0 !== (d3 & a3.expiredLanes) || b4)
    b4 = Jk(a3, d3);
  else {
    b4 = d3;
    var e2 = K;
    K |= 2;
    var f4 = Kk();
    if (R !== a3 || Z !== b4)
      vk = null, Hj = B() + 500, Lk(a3, b4);
    do
      try {
        Mk();
        break;
      } catch (h5) {
        Nk(a3, h5);
      }
    while (1);
    Qg();
    nk.current = f4;
    K = e2;
    null !== Y ? b4 = 0 : (R = null, Z = 0, b4 = T);
  }
  if (0 !== b4) {
    2 === b4 && (e2 = xc(a3), 0 !== e2 && (d3 = e2, b4 = Ok(a3, e2)));
    if (1 === b4)
      throw c2 = qk, Lk(a3, 0), Dk(a3, d3), Ek(a3, B()), c2;
    if (6 === b4)
      Dk(a3, d3);
    else {
      e2 = a3.current.alternate;
      if (0 === (d3 & 30) && !Pk(e2) && (b4 = Jk(a3, d3), 2 === b4 && (f4 = xc(a3), 0 !== f4 && (d3 = f4, b4 = Ok(a3, f4))), 1 === b4))
        throw c2 = qk, Lk(a3, 0), Dk(a3, d3), Ek(a3, B()), c2;
      a3.finishedWork = e2;
      a3.finishedLanes = d3;
      switch (b4) {
        case 0:
        case 1:
          throw Error(p(345));
        case 2:
          Qk(a3, uk, vk);
          break;
        case 3:
          Dk(a3, d3);
          if ((d3 & 130023424) === d3 && (b4 = gk + 500 - B(), 10 < b4)) {
            if (0 !== uc(a3, 0))
              break;
            e2 = a3.suspendedLanes;
            if ((e2 & d3) !== d3) {
              L();
              a3.pingedLanes |= a3.suspendedLanes & e2;
              break;
            }
            a3.timeoutHandle = Ff(Qk.bind(null, a3, uk, vk), b4);
            break;
          }
          Qk(a3, uk, vk);
          break;
        case 4:
          Dk(a3, d3);
          if ((d3 & 4194240) === d3)
            break;
          b4 = a3.eventTimes;
          for (e2 = -1; 0 < d3; ) {
            var g3 = 31 - oc(d3);
            f4 = 1 << g3;
            g3 = b4[g3];
            g3 > e2 && (e2 = g3);
            d3 &= ~f4;
          }
          d3 = e2;
          d3 = B() - d3;
          d3 = (120 > d3 ? 120 : 480 > d3 ? 480 : 1080 > d3 ? 1080 : 1920 > d3 ? 1920 : 3e3 > d3 ? 3e3 : 4320 > d3 ? 4320 : 1960 * mk(d3 / 1960)) - d3;
          if (10 < d3) {
            a3.timeoutHandle = Ff(Qk.bind(null, a3, uk, vk), d3);
            break;
          }
          Qk(a3, uk, vk);
          break;
        case 5:
          Qk(a3, uk, vk);
          break;
        default:
          throw Error(p(329));
      }
    }
  }
  Ek(a3, B());
  return a3.callbackNode === c2 ? Hk.bind(null, a3) : null;
}
function Ok(a3, b4) {
  var c2 = tk;
  a3.current.memoizedState.isDehydrated && (Lk(a3, b4).flags |= 256);
  a3 = Jk(a3, b4);
  2 !== a3 && (b4 = uk, uk = c2, null !== b4 && Gj(b4));
  return a3;
}
function Gj(a3) {
  null === uk ? uk = a3 : uk.push.apply(uk, a3);
}
function Pk(a3) {
  for (var b4 = a3; ; ) {
    if (b4.flags & 16384) {
      var c2 = b4.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d3 = 0; d3 < c2.length; d3++) {
          var e2 = c2[d3], f4 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f4(), e2))
              return false;
          } catch (g3) {
            return false;
          }
        }
    }
    c2 = b4.child;
    if (b4.subtreeFlags & 16384 && null !== c2)
      c2.return = b4, b4 = c2;
    else {
      if (b4 === a3)
        break;
      for (; null === b4.sibling; ) {
        if (null === b4.return || b4.return === a3)
          return true;
        b4 = b4.return;
      }
      b4.sibling.return = b4.return;
      b4 = b4.sibling;
    }
  }
  return true;
}
function Dk(a3, b4) {
  b4 &= ~sk;
  b4 &= ~rk;
  a3.suspendedLanes |= b4;
  a3.pingedLanes &= ~b4;
  for (a3 = a3.expirationTimes; 0 < b4; ) {
    var c2 = 31 - oc(b4), d3 = 1 << c2;
    a3[c2] = -1;
    b4 &= ~d3;
  }
}
function Fk(a3) {
  if (0 !== (K & 6))
    throw Error(p(327));
  Ik();
  var b4 = uc(a3, 0);
  if (0 === (b4 & 1))
    return Ek(a3, B()), null;
  var c2 = Jk(a3, b4);
  if (0 !== a3.tag && 2 === c2) {
    var d3 = xc(a3);
    0 !== d3 && (b4 = d3, c2 = Ok(a3, d3));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a3, 0), Dk(a3, b4), Ek(a3, B()), c2;
  if (6 === c2)
    throw Error(p(345));
  a3.finishedWork = a3.current.alternate;
  a3.finishedLanes = b4;
  Qk(a3, uk, vk);
  Ek(a3, B());
  return null;
}
function Rk(a3, b4) {
  var c2 = K;
  K |= 1;
  try {
    return a3(b4);
  } finally {
    K = c2, 0 === K && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a3) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b4 = K;
  K |= 1;
  var c2 = pk.transition, d3 = C;
  try {
    if (pk.transition = null, C = 1, a3)
      return a3();
  } finally {
    C = d3, pk.transition = c2, K = b4, 0 === (K & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E(fj);
}
function Lk(a3, b4) {
  a3.finishedWork = null;
  a3.finishedLanes = 0;
  var c2 = a3.timeoutHandle;
  -1 !== c2 && (a3.timeoutHandle = -1, Gf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d3 = c2;
      wg(d3);
      switch (d3.tag) {
        case 1:
          d3 = d3.type.childContextTypes;
          null !== d3 && void 0 !== d3 && $f();
          break;
        case 3:
          Jh();
          E(Wf);
          E(H);
          Oh();
          break;
        case 5:
          Lh(d3);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E(M);
          break;
        case 19:
          E(M);
          break;
        case 10:
          Rg(d3.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R = a3;
  Y = a3 = wh(a3.current, null);
  Z = gj = b4;
  T = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b4 = 0; b4 < Wg.length; b4++)
      if (c2 = Wg[b4], d3 = c2.interleaved, null !== d3) {
        c2.interleaved = null;
        var e2 = d3.next, f4 = c2.pending;
        if (null !== f4) {
          var g3 = f4.next;
          f4.next = e2;
          d3.next = g3;
        }
        c2.pending = d3;
      }
    Wg = null;
  }
  return a3;
}
function Nk(a3, b4) {
  do {
    var c2 = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d3 = N.memoizedState; null !== d3; ) {
          var e2 = d3.queue;
          null !== e2 && (e2.pending = null);
          d3 = d3.next;
        }
        Sh = false;
      }
      Rh = 0;
      P = O = N = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        qk = b4;
        Y = null;
        break;
      }
      a: {
        var f4 = a3, g3 = c2.return, h5 = c2, k3 = b4;
        b4 = Z;
        h5.flags |= 32768;
        if (null !== k3 && "object" === typeof k3 && "function" === typeof k3.then) {
          var l2 = k3, m2 = h5, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y3 = Vi(g3);
          if (null !== y3) {
            y3.flags &= -257;
            Wi(y3, g3, h5, f4, b4);
            y3.mode & 1 && Ti(f4, l2, b4);
            b4 = y3;
            k3 = l2;
            var n4 = b4.updateQueue;
            if (null === n4) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k3);
              b4.updateQueue = t2;
            } else
              n4.add(k3);
            break a;
          } else {
            if (0 === (b4 & 1)) {
              Ti(f4, l2, b4);
              uj();
              break a;
            }
            k3 = Error(p(426));
          }
        } else if (I && h5.mode & 1) {
          var J2 = Vi(g3);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g3, h5, f4, b4);
            Jg(Ki(k3, h5));
            break a;
          }
        }
        f4 = k3 = Ki(k3, h5);
        4 !== T && (T = 2);
        null === tk ? tk = [f4] : tk.push(f4);
        f4 = g3;
        do {
          switch (f4.tag) {
            case 3:
              f4.flags |= 65536;
              b4 &= -b4;
              f4.lanes |= b4;
              var x2 = Oi(f4, k3, b4);
              fh(f4, x2);
              break a;
            case 1:
              h5 = k3;
              var w3 = f4.type, u3 = f4.stateNode;
              if (0 === (f4.flags & 128) && ("function" === typeof w3.getDerivedStateFromError || null !== u3 && "function" === typeof u3.componentDidCatch && (null === Si || !Si.has(u3)))) {
                f4.flags |= 65536;
                b4 &= -b4;
                f4.lanes |= b4;
                var F2 = Ri(f4, h5, b4);
                fh(f4, F2);
                break a;
              }
          }
          f4 = f4.return;
        } while (null !== f4);
      }
      Tk(c2);
    } catch (na) {
      b4 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a3 = nk.current;
  nk.current = ai;
  return null === a3 ? ai : a3;
}
function uj() {
  if (0 === T || 3 === T || 2 === T)
    T = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
}
function Jk(a3, b4) {
  var c2 = K;
  K |= 2;
  var d3 = Kk();
  if (R !== a3 || Z !== b4)
    vk = null, Lk(a3, b4);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a3, e2);
    }
  while (1);
  Qg();
  K = c2;
  nk.current = d3;
  if (null !== Y)
    throw Error(p(261));
  R = null;
  Z = 0;
  return T;
}
function Uk() {
  for (; null !== Y; )
    Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); )
    Vk(Y);
}
function Vk(a3) {
  var b4 = Wk(a3.alternate, a3, gj);
  a3.memoizedProps = a3.pendingProps;
  null === b4 ? Tk(a3) : Y = b4;
  ok.current = null;
}
function Tk(a3) {
  var b4 = a3;
  do {
    var c2 = b4.alternate;
    a3 = b4.return;
    if (0 === (b4.flags & 32768)) {
      if (c2 = Fj(c2, b4, gj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b4);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a3)
        a3.flags |= 32768, a3.subtreeFlags = 0, a3.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b4 = b4.sibling;
    if (null !== b4) {
      Y = b4;
      return;
    }
    Y = b4 = a3;
  } while (null !== b4);
  0 === T && (T = 5);
}
function Qk(a3, b4, c2) {
  var d3 = C, e2 = pk.transition;
  try {
    pk.transition = null, C = 1, Xk(a3, b4, c2, d3);
  } finally {
    pk.transition = e2, C = d3;
  }
  return null;
}
function Xk(a3, b4, c2, d3) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K & 6))
    throw Error(p(327));
  c2 = a3.finishedWork;
  var e2 = a3.finishedLanes;
  if (null === c2)
    return null;
  a3.finishedWork = null;
  a3.finishedLanes = 0;
  if (c2 === a3.current)
    throw Error(p(177));
  a3.callbackNode = null;
  a3.callbackPriority = 0;
  var f4 = c2.lanes | c2.childLanes;
  Bc(a3, f4);
  a3 === R && (Y = R = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f4 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f4) {
    f4 = pk.transition;
    pk.transition = null;
    var g3 = C;
    C = 1;
    var h5 = K;
    K |= 4;
    ok.current = null;
    Pj(a3, c2);
    ek(c2, a3);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a3.current = c2;
    ik(c2);
    dc();
    K = h5;
    C = g3;
    pk.transition = f4;
  } else
    a3.current = c2;
  wk && (wk = false, xk = a3, yk = e2);
  f4 = a3.pendingLanes;
  0 === f4 && (Si = null);
  mc(c2.stateNode);
  Ek(a3, B());
  if (null !== b4)
    for (d3 = a3.onRecoverableError, c2 = 0; c2 < b4.length; c2++)
      e2 = b4[c2], d3(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a3 = Qi, Qi = null, a3;
  0 !== (yk & 1) && 0 !== a3.tag && Ik();
  f4 = a3.pendingLanes;
  0 !== (f4 & 1) ? a3 === Ak ? zk++ : (zk = 0, Ak = a3) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a3 = Dc(yk), b4 = pk.transition, c2 = C;
    try {
      pk.transition = null;
      C = 16 > a3 ? 16 : a3;
      if (null === xk)
        var d3 = false;
      else {
        a3 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6))
          throw Error(p(331));
        var e2 = K;
        K |= 4;
        for (V = a3.current; null !== V; ) {
          var f4 = V, g3 = f4.child;
          if (0 !== (V.flags & 16)) {
            var h5 = f4.deletions;
            if (null !== h5) {
              for (var k3 = 0; k3 < h5.length; k3++) {
                var l2 = h5[k3];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f4);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y3 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y3;
                        V = r2;
                        break;
                      }
                      V = y3;
                    }
                }
              }
              var n4 = f4.alternate;
              if (null !== n4) {
                var t2 = n4.child;
                if (null !== t2) {
                  n4.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f4;
            }
          }
          if (0 !== (f4.subtreeFlags & 2064) && null !== g3)
            g3.return = f4, V = g3;
          else
            b:
              for (; null !== V; ) {
                f4 = V;
                if (0 !== (f4.flags & 2048))
                  switch (f4.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f4, f4.return);
                  }
                var x2 = f4.sibling;
                if (null !== x2) {
                  x2.return = f4.return;
                  V = x2;
                  break b;
                }
                V = f4.return;
              }
        }
        var w3 = a3.current;
        for (V = w3; null !== V; ) {
          g3 = V;
          var u3 = g3.child;
          if (0 !== (g3.subtreeFlags & 2064) && null !== u3)
            u3.return = g3, V = u3;
          else
            b:
              for (g3 = w3; null !== V; ) {
                h5 = V;
                if (0 !== (h5.flags & 2048))
                  try {
                    switch (h5.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h5);
                    }
                  } catch (na) {
                    W(h5, h5.return, na);
                  }
                if (h5 === g3) {
                  V = null;
                  break b;
                }
                var F2 = h5.sibling;
                if (null !== F2) {
                  F2.return = h5.return;
                  V = F2;
                  break b;
                }
                V = h5.return;
              }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a3);
          } catch (na) {
          }
        d3 = true;
      }
      return d3;
    } finally {
      C = c2, pk.transition = b4;
    }
  }
  return false;
}
function Yk(a3, b4, c2) {
  b4 = Ki(c2, b4);
  b4 = Oi(a3, b4, 1);
  a3 = dh(a3, b4, 1);
  b4 = L();
  null !== a3 && (Ac(a3, 1, b4), Ek(a3, b4));
}
function W(a3, b4, c2) {
  if (3 === a3.tag)
    Yk(a3, a3, c2);
  else
    for (; null !== b4; ) {
      if (3 === b4.tag) {
        Yk(b4, a3, c2);
        break;
      } else if (1 === b4.tag) {
        var d3 = b4.stateNode;
        if ("function" === typeof b4.type.getDerivedStateFromError || "function" === typeof d3.componentDidCatch && (null === Si || !Si.has(d3))) {
          a3 = Ki(c2, a3);
          a3 = Ri(b4, a3, 1);
          b4 = dh(b4, a3, 1);
          a3 = L();
          null !== b4 && (Ac(b4, 1, a3), Ek(b4, a3));
          break;
        }
      }
      b4 = b4.return;
    }
}
function Ui(a3, b4, c2) {
  var d3 = a3.pingCache;
  null !== d3 && d3.delete(b4);
  b4 = L();
  a3.pingedLanes |= a3.suspendedLanes & c2;
  R === a3 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a3, 0) : sk |= c2);
  Ek(a3, b4);
}
function Zk(a3, b4) {
  0 === b4 && (0 === (a3.mode & 1) ? b4 = 1 : (b4 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L();
  a3 = Zg(a3, b4);
  null !== a3 && (Ac(a3, b4, c2), Ek(a3, c2));
}
function vj(a3) {
  var b4 = a3.memoizedState, c2 = 0;
  null !== b4 && (c2 = b4.retryLane);
  Zk(a3, c2);
}
function ck(a3, b4) {
  var c2 = 0;
  switch (a3.tag) {
    case 13:
      var d3 = a3.stateNode;
      var e2 = a3.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d3 = a3.stateNode;
      break;
    default:
      throw Error(p(314));
  }
  null !== d3 && d3.delete(b4);
  Zk(a3, c2);
}
var Wk;
Wk = function(a3, b4, c2) {
  if (null !== a3)
    if (a3.memoizedProps !== b4.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a3.lanes & c2) && 0 === (b4.flags & 128))
        return Ug = false, zj(a3, b4, c2);
      Ug = 0 !== (a3.flags & 131072) ? true : false;
    }
  else
    Ug = false, I && 0 !== (b4.flags & 1048576) && ug(b4, ng, b4.index);
  b4.lanes = 0;
  switch (b4.tag) {
    case 2:
      var d3 = b4.type;
      jj(a3, b4);
      a3 = b4.pendingProps;
      var e2 = Yf(b4, H.current);
      Tg(b4, c2);
      e2 = Xh(null, b4, d3, a3, e2, c2);
      var f4 = bi();
      b4.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b4.tag = 1, b4.memoizedState = null, b4.updateQueue = null, Zf(d3) ? (f4 = true, cg(b4)) : f4 = false, b4.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b4), e2.updater = nh, b4.stateNode = e2, e2._reactInternals = b4, rh(b4, d3, a3, c2), b4 = kj(null, b4, d3, true, f4, c2)) : (b4.tag = 0, I && f4 && vg(b4), Yi(null, b4, e2, c2), b4 = b4.child);
      return b4;
    case 16:
      d3 = b4.elementType;
      a: {
        jj(a3, b4);
        a3 = b4.pendingProps;
        e2 = d3._init;
        d3 = e2(d3._payload);
        b4.type = d3;
        e2 = b4.tag = $k(d3);
        a3 = Lg(d3, a3);
        switch (e2) {
          case 0:
            b4 = dj(null, b4, d3, a3, c2);
            break a;
          case 1:
            b4 = ij(null, b4, d3, a3, c2);
            break a;
          case 11:
            b4 = Zi(null, b4, d3, a3, c2);
            break a;
          case 14:
            b4 = aj(null, b4, d3, Lg(d3.type, a3), c2);
            break a;
        }
        throw Error(p(
          306,
          d3,
          ""
        ));
      }
      return b4;
    case 0:
      return d3 = b4.type, e2 = b4.pendingProps, e2 = b4.elementType === d3 ? e2 : Lg(d3, e2), dj(a3, b4, d3, e2, c2);
    case 1:
      return d3 = b4.type, e2 = b4.pendingProps, e2 = b4.elementType === d3 ? e2 : Lg(d3, e2), ij(a3, b4, d3, e2, c2);
    case 3:
      a: {
        lj(b4);
        if (null === a3)
          throw Error(p(387));
        d3 = b4.pendingProps;
        f4 = b4.memoizedState;
        e2 = f4.element;
        bh(a3, b4);
        gh(b4, d3, null, c2);
        var g3 = b4.memoizedState;
        d3 = g3.element;
        if (f4.isDehydrated)
          if (f4 = { element: d3, isDehydrated: false, cache: g3.cache, pendingSuspenseBoundaries: g3.pendingSuspenseBoundaries, transitions: g3.transitions }, b4.updateQueue.baseState = f4, b4.memoizedState = f4, b4.flags & 256) {
            e2 = Ki(Error(p(423)), b4);
            b4 = mj(a3, b4, d3, c2, e2);
            break a;
          } else if (d3 !== e2) {
            e2 = Ki(Error(p(424)), b4);
            b4 = mj(a3, b4, d3, c2, e2);
            break a;
          } else
            for (yg = Lf(b4.stateNode.containerInfo.firstChild), xg = b4, I = true, zg = null, c2 = Ch(b4, null, d3, c2), b4.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d3 === e2) {
            b4 = $i(a3, b4, c2);
            break a;
          }
          Yi(a3, b4, d3, c2);
        }
        b4 = b4.child;
      }
      return b4;
    case 5:
      return Kh(b4), null === a3 && Eg(b4), d3 = b4.type, e2 = b4.pendingProps, f4 = null !== a3 ? a3.memoizedProps : null, g3 = e2.children, Ef(d3, e2) ? g3 = null : null !== f4 && Ef(d3, f4) && (b4.flags |= 32), hj(a3, b4), Yi(a3, b4, g3, c2), b4.child;
    case 6:
      return null === a3 && Eg(b4), null;
    case 13:
      return pj(a3, b4, c2);
    case 4:
      return Ih(b4, b4.stateNode.containerInfo), d3 = b4.pendingProps, null === a3 ? b4.child = Bh(b4, null, d3, c2) : Yi(a3, b4, d3, c2), b4.child;
    case 11:
      return d3 = b4.type, e2 = b4.pendingProps, e2 = b4.elementType === d3 ? e2 : Lg(d3, e2), Zi(a3, b4, d3, e2, c2);
    case 7:
      return Yi(a3, b4, b4.pendingProps, c2), b4.child;
    case 8:
      return Yi(a3, b4, b4.pendingProps.children, c2), b4.child;
    case 12:
      return Yi(a3, b4, b4.pendingProps.children, c2), b4.child;
    case 10:
      a: {
        d3 = b4.type._context;
        e2 = b4.pendingProps;
        f4 = b4.memoizedProps;
        g3 = e2.value;
        G(Mg, d3._currentValue);
        d3._currentValue = g3;
        if (null !== f4)
          if (He(f4.value, g3)) {
            if (f4.children === e2.children && !Wf.current) {
              b4 = $i(a3, b4, c2);
              break a;
            }
          } else
            for (f4 = b4.child, null !== f4 && (f4.return = b4); null !== f4; ) {
              var h5 = f4.dependencies;
              if (null !== h5) {
                g3 = f4.child;
                for (var k3 = h5.firstContext; null !== k3; ) {
                  if (k3.context === d3) {
                    if (1 === f4.tag) {
                      k3 = ch(-1, c2 & -c2);
                      k3.tag = 2;
                      var l2 = f4.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k3.next = k3 : (k3.next = m2.next, m2.next = k3);
                        l2.pending = k3;
                      }
                    }
                    f4.lanes |= c2;
                    k3 = f4.alternate;
                    null !== k3 && (k3.lanes |= c2);
                    Sg(
                      f4.return,
                      c2,
                      b4
                    );
                    h5.lanes |= c2;
                    break;
                  }
                  k3 = k3.next;
                }
              } else if (10 === f4.tag)
                g3 = f4.type === b4.type ? null : f4.child;
              else if (18 === f4.tag) {
                g3 = f4.return;
                if (null === g3)
                  throw Error(p(341));
                g3.lanes |= c2;
                h5 = g3.alternate;
                null !== h5 && (h5.lanes |= c2);
                Sg(g3, c2, b4);
                g3 = f4.sibling;
              } else
                g3 = f4.child;
              if (null !== g3)
                g3.return = f4;
              else
                for (g3 = f4; null !== g3; ) {
                  if (g3 === b4) {
                    g3 = null;
                    break;
                  }
                  f4 = g3.sibling;
                  if (null !== f4) {
                    f4.return = g3.return;
                    g3 = f4;
                    break;
                  }
                  g3 = g3.return;
                }
              f4 = g3;
            }
        Yi(a3, b4, e2.children, c2);
        b4 = b4.child;
      }
      return b4;
    case 9:
      return e2 = b4.type, d3 = b4.pendingProps.children, Tg(b4, c2), e2 = Vg(e2), d3 = d3(e2), b4.flags |= 1, Yi(a3, b4, d3, c2), b4.child;
    case 14:
      return d3 = b4.type, e2 = Lg(d3, b4.pendingProps), e2 = Lg(d3.type, e2), aj(a3, b4, d3, e2, c2);
    case 15:
      return cj(a3, b4, b4.type, b4.pendingProps, c2);
    case 17:
      return d3 = b4.type, e2 = b4.pendingProps, e2 = b4.elementType === d3 ? e2 : Lg(d3, e2), jj(a3, b4), b4.tag = 1, Zf(d3) ? (a3 = true, cg(b4)) : a3 = false, Tg(b4, c2), ph(b4, d3, e2), rh(b4, d3, e2, c2), kj(null, b4, d3, true, a3, c2);
    case 19:
      return yj(a3, b4, c2);
    case 22:
      return ej(a3, b4, c2);
  }
  throw Error(p(156, b4.tag));
};
function Gk(a3, b4) {
  return ac(a3, b4);
}
function al(a3, b4, c2, d3) {
  this.tag = a3;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b4;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d3;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a3, b4, c2, d3) {
  return new al(a3, b4, c2, d3);
}
function bj(a3) {
  a3 = a3.prototype;
  return !(!a3 || !a3.isReactComponent);
}
function $k(a3) {
  if ("function" === typeof a3)
    return bj(a3) ? 1 : 0;
  if (void 0 !== a3 && null !== a3) {
    a3 = a3.$$typeof;
    if (a3 === Da)
      return 11;
    if (a3 === Ga)
      return 14;
  }
  return 2;
}
function wh(a3, b4) {
  var c2 = a3.alternate;
  null === c2 ? (c2 = Bg(a3.tag, b4, a3.key, a3.mode), c2.elementType = a3.elementType, c2.type = a3.type, c2.stateNode = a3.stateNode, c2.alternate = a3, a3.alternate = c2) : (c2.pendingProps = b4, c2.type = a3.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a3.flags & 14680064;
  c2.childLanes = a3.childLanes;
  c2.lanes = a3.lanes;
  c2.child = a3.child;
  c2.memoizedProps = a3.memoizedProps;
  c2.memoizedState = a3.memoizedState;
  c2.updateQueue = a3.updateQueue;
  b4 = a3.dependencies;
  c2.dependencies = null === b4 ? null : { lanes: b4.lanes, firstContext: b4.firstContext };
  c2.sibling = a3.sibling;
  c2.index = a3.index;
  c2.ref = a3.ref;
  return c2;
}
function yh(a3, b4, c2, d3, e2, f4) {
  var g3 = 2;
  d3 = a3;
  if ("function" === typeof a3)
    bj(a3) && (g3 = 1);
  else if ("string" === typeof a3)
    g3 = 5;
  else
    a:
      switch (a3) {
        case ya:
          return Ah(c2.children, e2, f4, b4);
        case za:
          g3 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a3 = Bg(12, c2, b4, e2 | 2), a3.elementType = Aa, a3.lanes = f4, a3;
        case Ea:
          return a3 = Bg(13, c2, b4, e2), a3.elementType = Ea, a3.lanes = f4, a3;
        case Fa:
          return a3 = Bg(19, c2, b4, e2), a3.elementType = Fa, a3.lanes = f4, a3;
        case Ia:
          return qj(c2, e2, f4, b4);
        default:
          if ("object" === typeof a3 && null !== a3)
            switch (a3.$$typeof) {
              case Ba:
                g3 = 10;
                break a;
              case Ca:
                g3 = 9;
                break a;
              case Da:
                g3 = 11;
                break a;
              case Ga:
                g3 = 14;
                break a;
              case Ha:
                g3 = 16;
                d3 = null;
                break a;
            }
          throw Error(p(130, null == a3 ? a3 : typeof a3, ""));
      }
  b4 = Bg(g3, c2, b4, e2);
  b4.elementType = a3;
  b4.type = d3;
  b4.lanes = f4;
  return b4;
}
function Ah(a3, b4, c2, d3) {
  a3 = Bg(7, a3, d3, b4);
  a3.lanes = c2;
  return a3;
}
function qj(a3, b4, c2, d3) {
  a3 = Bg(22, a3, d3, b4);
  a3.elementType = Ia;
  a3.lanes = c2;
  a3.stateNode = { isHidden: false };
  return a3;
}
function xh(a3, b4, c2) {
  a3 = Bg(6, a3, null, b4);
  a3.lanes = c2;
  return a3;
}
function zh(a3, b4, c2) {
  b4 = Bg(4, null !== a3.children ? a3.children : [], a3.key, b4);
  b4.lanes = c2;
  b4.stateNode = { containerInfo: a3.containerInfo, pendingChildren: null, implementation: a3.implementation };
  return b4;
}
function bl(a3, b4, c2, d3, e2) {
  this.tag = b4;
  this.containerInfo = a3;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d3;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a3, b4, c2, d3, e2, f4, g3, h5, k3) {
  a3 = new bl(a3, b4, c2, h5, k3);
  1 === b4 ? (b4 = 1, true === f4 && (b4 |= 8)) : b4 = 0;
  f4 = Bg(3, null, null, b4);
  a3.current = f4;
  f4.stateNode = a3;
  f4.memoizedState = { element: d3, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f4);
  return a3;
}
function dl(a3, b4, c2) {
  var d3 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d3 ? null : "" + d3, children: a3, containerInfo: b4, implementation: c2 };
}
function el(a3) {
  if (!a3)
    return Vf;
  a3 = a3._reactInternals;
  a: {
    if (Vb(a3) !== a3 || 1 !== a3.tag)
      throw Error(p(170));
    var b4 = a3;
    do {
      switch (b4.tag) {
        case 3:
          b4 = b4.stateNode.context;
          break a;
        case 1:
          if (Zf(b4.type)) {
            b4 = b4.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b4 = b4.return;
    } while (null !== b4);
    throw Error(p(171));
  }
  if (1 === a3.tag) {
    var c2 = a3.type;
    if (Zf(c2))
      return bg(a3, c2, b4);
  }
  return b4;
}
function fl(a3, b4, c2, d3, e2, f4, g3, h5, k3) {
  a3 = cl(c2, d3, true, a3, e2, f4, g3, h5, k3);
  a3.context = el(null);
  c2 = a3.current;
  d3 = L();
  e2 = lh(c2);
  f4 = ch(d3, e2);
  f4.callback = void 0 !== b4 && null !== b4 ? b4 : null;
  dh(c2, f4, e2);
  a3.current.lanes = e2;
  Ac(a3, e2, d3);
  Ek(a3, d3);
  return a3;
}
function gl(a3, b4, c2, d3) {
  var e2 = b4.current, f4 = L(), g3 = lh(e2);
  c2 = el(c2);
  null === b4.context ? b4.context = c2 : b4.pendingContext = c2;
  b4 = ch(f4, g3);
  b4.payload = { element: a3 };
  d3 = void 0 === d3 ? null : d3;
  null !== d3 && (b4.callback = d3);
  a3 = dh(e2, b4, g3);
  null !== a3 && (mh(a3, e2, g3, f4), eh(a3, e2, g3));
  return g3;
}
function hl(a3) {
  a3 = a3.current;
  if (!a3.child)
    return null;
  switch (a3.child.tag) {
    case 5:
      return a3.child.stateNode;
    default:
      return a3.child.stateNode;
  }
}
function il(a3, b4) {
  a3 = a3.memoizedState;
  if (null !== a3 && null !== a3.dehydrated) {
    var c2 = a3.retryLane;
    a3.retryLane = 0 !== c2 && c2 < b4 ? c2 : b4;
  }
}
function jl(a3, b4) {
  il(a3, b4);
  (a3 = a3.alternate) && il(a3, b4);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a3) {
  console.error(a3);
};
function ml(a3) {
  this._internalRoot = a3;
}
nl.prototype.render = ml.prototype.render = function(a3) {
  var b4 = this._internalRoot;
  if (null === b4)
    throw Error(p(409));
  gl(a3, b4, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a3 = this._internalRoot;
  if (null !== a3) {
    this._internalRoot = null;
    var b4 = a3.containerInfo;
    Sk(function() {
      gl(null, a3, null, null);
    });
    b4[uf] = null;
  }
};
function nl(a3) {
  this._internalRoot = a3;
}
nl.prototype.unstable_scheduleHydration = function(a3) {
  if (a3) {
    var b4 = Hc();
    a3 = { blockedOn: null, target: a3, priority: b4 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b4 && b4 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a3);
    0 === c2 && Vc(a3);
  }
};
function ol(a3) {
  return !(!a3 || 1 !== a3.nodeType && 9 !== a3.nodeType && 11 !== a3.nodeType);
}
function pl(a3) {
  return !(!a3 || 1 !== a3.nodeType && 9 !== a3.nodeType && 11 !== a3.nodeType && (8 !== a3.nodeType || " react-mount-point-unstable " !== a3.nodeValue));
}
function ql() {
}
function rl(a3, b4, c2, d3, e2) {
  if (e2) {
    if ("function" === typeof d3) {
      var f4 = d3;
      d3 = function() {
        var a4 = hl(g3);
        f4.call(a4);
      };
    }
    var g3 = fl(b4, d3, a3, 0, null, false, false, "", ql);
    a3._reactRootContainer = g3;
    a3[uf] = g3.current;
    sf(8 === a3.nodeType ? a3.parentNode : a3);
    Sk();
    return g3;
  }
  for (; e2 = a3.lastChild; )
    a3.removeChild(e2);
  if ("function" === typeof d3) {
    var h5 = d3;
    d3 = function() {
      var a4 = hl(k3);
      h5.call(a4);
    };
  }
  var k3 = cl(a3, 0, false, null, null, false, false, "", ql);
  a3._reactRootContainer = k3;
  a3[uf] = k3.current;
  sf(8 === a3.nodeType ? a3.parentNode : a3);
  Sk(function() {
    gl(b4, k3, c2, d3);
  });
  return k3;
}
function sl(a3, b4, c2, d3, e2) {
  var f4 = c2._reactRootContainer;
  if (f4) {
    var g3 = f4;
    if ("function" === typeof e2) {
      var h5 = e2;
      e2 = function() {
        var a4 = hl(g3);
        h5.call(a4);
      };
    }
    gl(b4, g3, a3, e2);
  } else
    g3 = rl(c2, b4, a3, e2, d3);
  return hl(g3);
}
Ec = function(a3) {
  switch (a3.tag) {
    case 3:
      var b4 = a3.stateNode;
      if (b4.current.memoizedState.isDehydrated) {
        var c2 = tc(b4.pendingLanes);
        0 !== c2 && (Cc(b4, c2 | 1), Ek(b4, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b5 = Zg(a3, 1);
        if (null !== b5) {
          var c3 = L();
          mh(b5, a3, 1, c3);
        }
      }), jl(a3, 1);
  }
};
Fc = function(a3) {
  if (13 === a3.tag) {
    var b4 = Zg(a3, 134217728);
    if (null !== b4) {
      var c2 = L();
      mh(b4, a3, 134217728, c2);
    }
    jl(a3, 134217728);
  }
};
Gc = function(a3) {
  if (13 === a3.tag) {
    var b4 = lh(a3), c2 = Zg(a3, b4);
    if (null !== c2) {
      var d3 = L();
      mh(c2, a3, b4, d3);
    }
    jl(a3, b4);
  }
};
Hc = function() {
  return C;
};
Ic = function(a3, b4) {
  var c2 = C;
  try {
    return C = a3, b4();
  } finally {
    C = c2;
  }
};
yb = function(a3, b4, c2) {
  switch (b4) {
    case "input":
      bb(a3, c2);
      b4 = c2.name;
      if ("radio" === c2.type && null != b4) {
        for (c2 = a3; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b4) + '][type="radio"]');
        for (b4 = 0; b4 < c2.length; b4++) {
          var d3 = c2[b4];
          if (d3 !== a3 && d3.form === a3.form) {
            var e2 = Db(d3);
            if (!e2)
              throw Error(p(90));
            Wa(d3);
            bb(d3, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a3, c2);
      break;
    case "select":
      b4 = c2.value, null != b4 && fb(a3, !!c2.multiple, b4, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a3) {
  a3 = Zb(a3);
  return null === a3 ? null : a3.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a3) {
    }
}
var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = reactDom_production_min$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
var createPortal = reactDom_production_min$1.createPortal = function(a3, b4) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b4))
    throw Error(p(200));
  return dl(a3, b4, null, c2);
};
var createRoot$1 = reactDom_production_min$1.createRoot = function(a3, b4) {
  if (!ol(a3))
    throw Error(p(299));
  var c2 = false, d3 = "", e2 = ll;
  null !== b4 && void 0 !== b4 && (true === b4.unstable_strictMode && (c2 = true), void 0 !== b4.identifierPrefix && (d3 = b4.identifierPrefix), void 0 !== b4.onRecoverableError && (e2 = b4.onRecoverableError));
  b4 = cl(a3, 1, false, null, null, c2, false, d3, e2);
  a3[uf] = b4.current;
  sf(8 === a3.nodeType ? a3.parentNode : a3);
  return new ml(b4);
};
var findDOMNode = reactDom_production_min$1.findDOMNode = function(a3) {
  if (null == a3)
    return null;
  if (1 === a3.nodeType)
    return a3;
  var b4 = a3._reactInternals;
  if (void 0 === b4) {
    if ("function" === typeof a3.render)
      throw Error(p(188));
    a3 = Object.keys(a3).join(",");
    throw Error(p(268, a3));
  }
  a3 = Zb(b4);
  a3 = null === a3 ? null : a3.stateNode;
  return a3;
};
var flushSync = reactDom_production_min$1.flushSync = function(a3) {
  return Sk(a3);
};
var hydrate = reactDom_production_min$1.hydrate = function(a3, b4, c2) {
  if (!pl(b4))
    throw Error(p(200));
  return sl(null, a3, b4, true, c2);
};
var hydrateRoot = reactDom_production_min$1.hydrateRoot = function(a3, b4, c2) {
  if (!ol(a3))
    throw Error(p(405));
  var d3 = null != c2 && c2.hydratedSources || null, e2 = false, f4 = "", g3 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f4 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g3 = c2.onRecoverableError));
  b4 = fl(b4, null, a3, 1, null != c2 ? c2 : null, e2, false, f4, g3);
  a3[uf] = b4.current;
  sf(a3);
  if (d3)
    for (a3 = 0; a3 < d3.length; a3++)
      c2 = d3[a3], e2 = c2._getVersion, e2 = e2(c2._source), null == b4.mutableSourceEagerHydrationData ? b4.mutableSourceEagerHydrationData = [c2, e2] : b4.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b4);
};
var render = reactDom_production_min$1.render = function(a3, b4, c2) {
  if (!pl(b4))
    throw Error(p(200));
  return sl(null, a3, b4, false, c2);
};
var unmountComponentAtNode = reactDom_production_min$1.unmountComponentAtNode = function(a3) {
  if (!pl(a3))
    throw Error(p(40));
  return a3._reactRootContainer ? (Sk(function() {
    sl(null, null, a3, false, function() {
      a3._reactRootContainer = null;
      a3[uf] = null;
    });
  }), true) : false;
};
var unstable_batchedUpdates = reactDom_production_min$1.unstable_batchedUpdates = Rk;
var unstable_renderSubtreeIntoContainer = reactDom_production_min$1.unstable_renderSubtreeIntoContainer = function(a3, b4, c2, d3) {
  if (!pl(c2))
    throw Error(p(200));
  if (null == a3 || void 0 === a3._reactInternals)
    throw Error(p(38));
  return sl(a3, b4, c2, false, d3);
};
var version = reactDom_production_min$1.version = "18.2.0-next-9e3b772b8-20220608";
const reactDom_production_min = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  createPortal,
  createRoot: createRoot$1,
  default: reactDom_production_min$1,
  findDOMNode,
  flushSync,
  hydrate,
  hydrateRoot,
  render,
  unmountComponentAtNode,
  unstable_batchedUpdates,
  unstable_renderSubtreeIntoContainer,
  version
}, [reactDom_production_min$1]);
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(reactDom_production_min);
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom$1.exports = require$$0$1;
}
var reactDomExports = reactDom$1.exports;
const index = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
const reactDom = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [reactDomExports]);
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(reactDom);
var createRoot;
var m = require$$0;
{
  createRoot = m.createRoot;
  m.hydrateRoot;
}
const tippy = "";
const ReactToastify = "";
const reactTabs = "";
const general = "";
const global$1 = "";
const container = document.getElementById("root");
if (!container)
  throw new Error("Missing `#root`.");
createRoot(container).render(
  /* @__PURE__ */ jsx(React$1.StrictMode, { children: /* @__PURE__ */ jsx(App, {}) })
);
export {
  WuiFlex as $,
  WuiInputText as A,
  WuiLink as B,
  WuiListItem as C,
  WuiTransactionListItem as D,
  WuiTransactionListItemLoader as E,
  WuiListWallet as F,
  WuiLogoSelect as G,
  WuiLogo as H,
  WuiNetworkButton as I,
  WuiNetworkImage as J,
  WuiOtp as K,
  WuiQrCode as L,
  WuiSearchBar as M,
  WuiSnackbar as N,
  WuiTabs as O,
  WuiTag as P,
  WuiTooltip as Q,
  WuiTransactionVisual as R,
  WuiVisualThumbnail as S,
  TransactionUtil as T,
  UiHelperUtil as U,
  WuiWalletImage as V,
  WuiCard as W,
  WuiNoticeCard as X,
  WuiListAccordion as Y,
  WuiListContent as Z,
  WuiListWalletTransaction as _,
  setThemeVariables as a,
  browser$b as a$,
  WuiGrid as a0,
  WuiSeparator as a1,
  React$1 as a2,
  useWeb3 as a3,
  reactExports as a4,
  jsxs as a5,
  HelmetExport as a6,
  jsx as a7,
  useParams as a8,
  createAnimation as a9,
  Source as aA,
  Kind as aB,
  OperationTypeNode as aC,
  Location as aD,
  getApolloContext as aE,
  invariant$1 as aF,
  canUseLayoutEffect as aG,
  React$2 as aH,
  canUseWeakSet as aI,
  maybeDeepFreeze as aJ,
  NetworkStatus as aK,
  canUseWeakMap as aL,
  equal as aM,
  compact as aN,
  mergeOptions as aO,
  __rest$1 as aP,
  __assign$1 as aQ,
  isNonEmptyArray as aR,
  ApolloError as aS,
  contractNetwork as aT,
  CID as aU,
  ipfsLinkPattern as aV,
  clsx as aW,
  getAugmentedNamespace as aX,
  getDefaultExportFromCjs as aY,
  require$$0$1z as aZ,
  _extends$1 as a_,
  parseLengthAndUnit as aa,
  cssValue as ab,
  NETWORKS as ac,
  useConfig as ad,
  Fragment$1 as ae,
  proxy as af,
  subscribe as ag,
  snapshot as ah,
  __vitePreload as ai,
  useSearchParams as aj,
  tokenPermissions as ak,
  Q$1 as al,
  rolePermissions as am,
  Link as an,
  ClimbingBoxLoader as ao,
  defaults as ap,
  useNavigate as aq,
  createSearchParams as ar,
  reactDomExports as as,
  nftBase as at,
  Token as au,
  isDigit as av,
  isNameStart as aw,
  dedentBlockStringLines as ax,
  isNameContinue as ay,
  isSource as az,
  WuiIcon as b,
  PropTypes as b0,
  customElement as c,
  WuiImage as d,
  WuiLoadingHexagon as e,
  WuiLoadingSpinner as f,
  WuiLoadingThumbnail as g,
  WuiShimmer as h,
  initializeTheming as i,
  WuiText as j,
  WuiVisual as k,
  WuiAccountButton as l,
  WuiAllWalletsImage as m,
  WuiAvatar as n,
  WuiButton as o,
  WuiCardSelectLoader as p,
  WuiCardSelect as q,
  WuiChip as r,
  setColorTheme as s,
  WuiConnectButton as t,
  WuiCtaButton as u,
  WuiEmailInput as v,
  WuiIconBox as w,
  WuiIconLink as x,
  WuiInputElement as y,
  WuiInputNumeric as z
};
//# sourceMappingURL=index-dc31a81c.js.map
