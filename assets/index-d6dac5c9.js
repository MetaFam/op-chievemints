function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min$1 = {};
var react = { exports: {} };
var react_production_min$1 = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$4 = Symbol.for("react.element"), n$5 = Symbol.for("react.portal"), p$7 = Symbol.for("react.fragment"), q$7 = Symbol.for("react.strict_mode"), r$4 = Symbol.for("react.profiler"), t$4 = Symbol.for("react.provider"), u$4 = Symbol.for("react.context"), v$6 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$3 = Symbol.for("react.lazy"), z$4 = Symbol.iterator;
function A$3(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$4 && a2[z$4] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$4 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$3 = Object.assign, D$3 = {};
function E$3(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e2 || B$4;
}
E$3.prototype.isReactComponent = {};
E$3.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$3.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$2() {
}
F$2.prototype = E$3.prototype;
function G$2(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e2 || B$4;
}
var H$3 = G$2.prototype = new F$2();
H$3.constructor = G$2;
C$3(H$3, E$3.prototype);
H$3.isPureReactComponent = true;
var I$3 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$3 = { key: true, ref: true, __self: true, __source: true };
function M$3(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$1.call(b2, d2) && !L$3.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$4, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
function N$3(a2, b2) {
  return { $$typeof: l$4, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$2(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$4;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$2 = /\/+/g;
function Q$3(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
}
function R$3(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$4:
          case n$5:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$3(h2, 0) : d2, I$3(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$2, "$&/") + "/"), R$3(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$2(c2) && (c2 = N$3(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$3(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$3(k2, g2);
      h2 += R$3(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$3(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$3(k2, g2++), h2 += R$3(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$4(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$3(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$3(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$2 = { current: null }, V$2 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$2 };
var Children = react_production_min$1.Children = { map: S$4, forEach: function(a2, b2, e2) {
  S$4(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$4(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$4(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$2(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
var Component = react_production_min$1.Component = E$3;
var Fragment$4 = react_production_min$1.Fragment = p$7;
var Profiler$2 = react_production_min$1.Profiler = r$4;
var PureComponent = react_production_min$1.PureComponent = G$2;
var StrictMode$2 = react_production_min$1.StrictMode = q$7;
var Suspense$2 = react_production_min$1.Suspense = w$3;
var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED$1 = react_production_min$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
var cloneElement = react_production_min$1.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$3({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$2.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$1.call(b2, f2) && !L$3.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$4, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
var createContext = react_production_min$1.createContext = function(a2) {
  a2 = { $$typeof: u$4, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$4, _context: a2 };
  return a2.Consumer = a2;
};
var createElement = react_production_min$1.createElement = M$3;
var createFactory = react_production_min$1.createFactory = function(a2) {
  var b2 = M$3.bind(null, a2);
  b2.type = a2;
  return b2;
};
var createRef = react_production_min$1.createRef = function() {
  return { current: null };
};
var forwardRef = react_production_min$1.forwardRef = function(a2) {
  return { $$typeof: v$6, render: a2 };
};
var isValidElement = react_production_min$1.isValidElement = O$2;
var lazy = react_production_min$1.lazy = function(a2) {
  return { $$typeof: y$3, _payload: { _status: -1, _result: a2 }, _init: T$3 };
};
var memo = react_production_min$1.memo = function(a2, b2) {
  return { $$typeof: x$2, type: a2, compare: void 0 === b2 ? null : b2 };
};
var startTransition = react_production_min$1.startTransition = function(a2) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a2();
  } finally {
    V$2.transition = b2;
  }
};
var unstable_act = react_production_min$1.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
var useCallback = react_production_min$1.useCallback = function(a2, b2) {
  return U$2.current.useCallback(a2, b2);
};
var useContext$1 = react_production_min$1.useContext = function(a2) {
  return U$2.current.useContext(a2);
};
var useDebugValue = react_production_min$1.useDebugValue = function() {
};
var useDeferredValue = react_production_min$1.useDeferredValue = function(a2) {
  return U$2.current.useDeferredValue(a2);
};
var useEffect = react_production_min$1.useEffect = function(a2, b2) {
  return U$2.current.useEffect(a2, b2);
};
var useId$1 = react_production_min$1.useId = function() {
  return U$2.current.useId();
};
var useImperativeHandle = react_production_min$1.useImperativeHandle = function(a2, b2, e2) {
  return U$2.current.useImperativeHandle(a2, b2, e2);
};
var useInsertionEffect = react_production_min$1.useInsertionEffect = function(a2, b2) {
  return U$2.current.useInsertionEffect(a2, b2);
};
var useLayoutEffect = react_production_min$1.useLayoutEffect = function(a2, b2) {
  return U$2.current.useLayoutEffect(a2, b2);
};
var useMemo = react_production_min$1.useMemo = function(a2, b2) {
  return U$2.current.useMemo(a2, b2);
};
var useReducer = react_production_min$1.useReducer = function(a2, b2, e2) {
  return U$2.current.useReducer(a2, b2, e2);
};
var useRef = react_production_min$1.useRef = function(a2) {
  return U$2.current.useRef(a2);
};
var useState = react_production_min$1.useState = function(a2) {
  return U$2.current.useState(a2);
};
var useSyncExternalStore$2 = react_production_min$1.useSyncExternalStore = function(a2, b2, e2) {
  return U$2.current.useSyncExternalStore(a2, b2, e2);
};
var useTransition$1 = react_production_min$1.useTransition = function() {
  return U$2.current.useTransition();
};
var version$c = react_production_min$1.version = "18.2.0";
const react_production_min = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  Children,
  Component,
  Fragment: Fragment$4,
  Profiler: Profiler$2,
  PureComponent,
  StrictMode: StrictMode$2,
  Suspense: Suspense$2,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED$1,
  cloneElement,
  createContext,
  createElement,
  createFactory,
  createRef,
  default: react_production_min$1,
  forwardRef,
  isValidElement,
  lazy,
  memo,
  startTransition,
  unstable_act,
  useCallback,
  useContext: useContext$1,
  useDebugValue,
  useDeferredValue,
  useEffect,
  useId: useId$1,
  useImperativeHandle,
  useInsertionEffect,
  useLayoutEffect,
  useMemo,
  useReducer,
  useRef,
  useState,
  useSyncExternalStore: useSyncExternalStore$2,
  useTransition: useTransition$1,
  version: version$c
}, [react_production_min$1]);
const require$$0$1j = /* @__PURE__ */ getAugmentedNamespace(react_production_min);
{
  react.exports = require$$0$1j;
}
var reactExports = react.exports;
const React$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React$1
}, [reactExports]);
const require$$0$1i = /* @__PURE__ */ getAugmentedNamespace(React$2);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$4 = require$$0$1i, k$5 = Symbol.for("react.element"), l$3 = Symbol.for("react.fragment"), m$6 = Object.prototype.hasOwnProperty, n$4 = f$4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$6 = { key: true, ref: true, __self: true, __source: true };
function q$6(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$6.call(a2, b2) && !p$6.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$5, type: c2, key: e2, ref: h2, props: d2, _owner: n$4.current };
}
var Fragment$3 = reactJsxRuntime_production_min$1.Fragment = l$3;
var jsx$1 = reactJsxRuntime_production_min$1.jsx = q$6;
var jsxs$1 = reactJsxRuntime_production_min$1.jsxs = q$6;
const reactJsxRuntime_production_min = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  Fragment: Fragment$3,
  default: reactJsxRuntime_production_min$1,
  jsx: jsx$1,
  jsxs: jsxs$1
}, [reactJsxRuntime_production_min$1]);
const require$$0$1h = /* @__PURE__ */ getAugmentedNamespace(reactJsxRuntime_production_min);
{
  jsxRuntime.exports = require$$0$1h;
}
var jsxRuntimeExports = jsxRuntime.exports;
const Fragment$2 = jsxRuntimeExports.Fragment;
const jsx = jsxRuntimeExports.jsx;
const jsxs = jsxRuntimeExports.jsxs;
const scriptRel = function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep2) {
  return "/" + dep2;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links2 = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep2) => {
    dep2 = assetsURL(dep2);
    if (dep2 in seen)
      return;
    seen[dep2] = true;
    const isCss = dep2.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links2.length - 1; i2 >= 0; i2--) {
        const link2 = links2[i2];
        if (link2.href === dep2 && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep2}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep2;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep2}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
const ReactPropTypesSecret$2 = /* @__PURE__ */ getDefaultExportFromCjs(ReactPropTypesSecret_1);
const ReactPropTypesSecret$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ReactPropTypesSecret$2
}, [ReactPropTypesSecret_1]);
const require$$0$1g = /* @__PURE__ */ getAugmentedNamespace(ReactPropTypesSecret$3);
var ReactPropTypesSecret = require$$0$1g;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim2(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bigint: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
const factoryWithThrowingShims$1 = /* @__PURE__ */ getDefaultExportFromCjs(factoryWithThrowingShims);
const factoryWithThrowingShims$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: factoryWithThrowingShims$1
}, [factoryWithThrowingShims]);
const require$$0$1f = /* @__PURE__ */ getAugmentedNamespace(factoryWithThrowingShims$2);
{
  propTypes.exports = require$$0$1f();
}
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
function _interopDefault(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var React = require$$0$1i;
var React__default = _interopDefault(React);
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var canUseDOM$1 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function withSideEffect(reducePropsToState3, handleStateChangeOnClient, mapStateOnServer3) {
  if (typeof reducePropsToState3 !== "function") {
    throw new Error("Expected reducePropsToState to be a function.");
  }
  if (typeof handleStateChangeOnClient !== "function") {
    throw new Error("Expected handleStateChangeOnClient to be a function.");
  }
  if (typeof mapStateOnServer3 !== "undefined" && typeof mapStateOnServer3 !== "function") {
    throw new Error("Expected mapStateOnServer to either be undefined or a function.");
  }
  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || "Component";
  }
  return function wrap2(WrappedComponent) {
    if (typeof WrappedComponent !== "function") {
      throw new Error("Expected WrappedComponent to be a React component.");
    }
    var mountedInstances = [];
    var state;
    function emitChange() {
      state = reducePropsToState3(mountedInstances.map(function(instance) {
        return instance.props;
      }));
      if (SideEffect.canUseDOM) {
        handleStateChangeOnClient(state);
      } else if (mapStateOnServer3) {
        state = mapStateOnServer3(state);
      }
    }
    var SideEffect = /* @__PURE__ */ function(_PureComponent) {
      _inheritsLoose(SideEffect2, _PureComponent);
      function SideEffect2() {
        return _PureComponent.apply(this, arguments) || this;
      }
      SideEffect2.peek = function peek() {
        return state;
      };
      SideEffect2.rewind = function rewind() {
        if (SideEffect2.canUseDOM) {
          throw new Error("You may only call rewind() on the server. Call peek() to read the current state.");
        }
        var recordedState = state;
        state = void 0;
        mountedInstances = [];
        return recordedState;
      };
      var _proto = SideEffect2.prototype;
      _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {
        mountedInstances.push(this);
        emitChange();
      };
      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        var index2 = mountedInstances.indexOf(this);
        mountedInstances.splice(index2, 1);
        emitChange();
      };
      _proto.render = function render3() {
        return React__default.createElement(WrappedComponent, this.props);
      };
      return SideEffect2;
    }(React.PureComponent);
    _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");
    _defineProperty(SideEffect, "canUseDOM", canUseDOM$1);
    return SideEffect;
  };
}
var lib = withSideEffect;
const withSideEffect$1 = /* @__PURE__ */ getDefaultExportFromCjs(lib);
var hasElementType = typeof Element !== "undefined";
var hasMap = typeof Map === "function";
var hasSet = typeof Set === "function";
var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
function equal$3(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    var length2, i2, keys2;
    if (Array.isArray(a2)) {
      length2 = a2.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!equal$3(a2[i2], b2[i2]))
          return false;
      return true;
    }
    var it;
    if (hasMap && a2 instanceof Map && b2 instanceof Map) {
      if (a2.size !== b2.size)
        return false;
      it = a2.entries();
      while (!(i2 = it.next()).done)
        if (!b2.has(i2.value[0]))
          return false;
      it = a2.entries();
      while (!(i2 = it.next()).done)
        if (!equal$3(i2.value[1], b2.get(i2.value[0])))
          return false;
      return true;
    }
    if (hasSet && a2 instanceof Set && b2 instanceof Set) {
      if (a2.size !== b2.size)
        return false;
      it = a2.entries();
      while (!(i2 = it.next()).done)
        if (!b2.has(i2.value[0]))
          return false;
      return true;
    }
    if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
      length2 = a2.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (a2[i2] !== b2[i2])
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b2.valueOf === "function")
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b2.toString === "function")
      return a2.toString() === b2.toString();
    keys2 = Object.keys(a2);
    length2 = keys2.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i2 = length2; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
        return false;
    if (hasElementType && a2 instanceof Element)
      return false;
    for (i2 = length2; i2-- !== 0; ) {
      if ((keys2[i2] === "_owner" || keys2[i2] === "__v" || keys2[i2] === "__o") && a2.$$typeof) {
        continue;
      }
      if (!equal$3(a2[keys2[i2]], b2[keys2[i2]]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
var reactFastCompare = function isEqual2(a2, b2) {
  try {
    return equal$3(a2, b2);
  } catch (error) {
    if ((error.message || "").match(/stack|recursion/i)) {
      console.warn("react-fast-compare cannot handle circular refs");
      return false;
    }
    throw error;
  }
};
const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
var hasOwnProperty$9 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i2 = 0; i2 < 10; i2++) {
      test2["_" + String.fromCharCode(i2)] = i2;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from2;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from2 = Object(arguments[s]);
    for (var key in from2) {
      if (hasOwnProperty$9.call(from2, key)) {
        to[key] = from2[key];
      }
    }
    if (getOwnPropertySymbols$1) {
      symbols = getOwnPropertySymbols$1(from2);
      for (var i2 = 0; i2 < symbols.length; i2++) {
        if (propIsEnumerable.call(from2, symbols[i2])) {
          to[symbols[i2]] = from2[symbols[i2]];
        }
      }
    }
  }
  return to;
};
const objectAssign$1 = /* @__PURE__ */ getDefaultExportFromCjs(objectAssign);
var ATTRIBUTE_NAMES = {
  BODY: "bodyAttributes",
  HTML: "htmlAttributes",
  TITLE: "titleAttributes"
};
var TAG_NAMES = {
  BASE: "base",
  BODY: "body",
  HEAD: "head",
  HTML: "html",
  LINK: "link",
  META: "meta",
  NOSCRIPT: "noscript",
  SCRIPT: "script",
  STYLE: "style",
  TITLE: "title"
};
Object.keys(TAG_NAMES).map(function(name2) {
  return TAG_NAMES[name2];
});
var TAG_PROPERTIES = {
  CHARSET: "charset",
  CSS_TEXT: "cssText",
  HREF: "href",
  HTTPEQUIV: "http-equiv",
  INNER_HTML: "innerHTML",
  ITEM_PROP: "itemprop",
  NAME: "name",
  PROPERTY: "property",
  REL: "rel",
  SRC: "src",
  TARGET: "target"
};
var REACT_TAG_MAP = {
  accesskey: "accessKey",
  charset: "charSet",
  class: "className",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  "http-equiv": "httpEquiv",
  itemprop: "itemProp",
  tabindex: "tabIndex"
};
var HELMET_PROPS = {
  DEFAULT_TITLE: "defaultTitle",
  DEFER: "defer",
  ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
  ON_CHANGE_CLIENT_STATE: "onChangeClientState",
  TITLE_TEMPLATE: "titleTemplate"
};
var HTML_TAG_MAP = Object.keys(REACT_TAG_MAP).reduce(function(obj, key) {
  obj[REACT_TAG_MAP[key]] = key;
  return obj;
}, {});
var SELF_CLOSING_TAGS = [TAG_NAMES.NOSCRIPT, TAG_NAMES.SCRIPT, TAG_NAMES.STYLE];
var HELMET_ATTRIBUTE = "data-react-helmet";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var _extends$3 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var objectWithoutProperties = function(obj, keys2) {
  var target = {};
  for (var i2 in obj) {
    if (keys2.indexOf(i2) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i2))
      continue;
    target[i2] = obj[i2];
  }
  return target;
};
var possibleConstructorReturn = function(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
};
var encodeSpecialCharacters = function encodeSpecialCharacters2(str) {
  var encode3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (encode3 === false) {
    return String(str);
  }
  return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
};
var getTitleFromPropsList = function getTitleFromPropsList2(propsList) {
  var innermostTitle = getInnermostProperty(propsList, TAG_NAMES.TITLE);
  var innermostTemplate = getInnermostProperty(propsList, HELMET_PROPS.TITLE_TEMPLATE);
  if (innermostTemplate && innermostTitle) {
    return innermostTemplate.replace(/%s/g, function() {
      return Array.isArray(innermostTitle) ? innermostTitle.join("") : innermostTitle;
    });
  }
  var innermostDefaultTitle = getInnermostProperty(propsList, HELMET_PROPS.DEFAULT_TITLE);
  return innermostTitle || innermostDefaultTitle || void 0;
};
var getOnChangeClientState = function getOnChangeClientState2(propsList) {
  return getInnermostProperty(propsList, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || function() {
  };
};
var getAttributesFromPropsList = function getAttributesFromPropsList2(tagType, propsList) {
  return propsList.filter(function(props) {
    return typeof props[tagType] !== "undefined";
  }).map(function(props) {
    return props[tagType];
  }).reduce(function(tagAttrs, current) {
    return _extends$3({}, tagAttrs, current);
  }, {});
};
var getBaseTagFromPropsList = function getBaseTagFromPropsList2(primaryAttributes, propsList) {
  return propsList.filter(function(props) {
    return typeof props[TAG_NAMES.BASE] !== "undefined";
  }).map(function(props) {
    return props[TAG_NAMES.BASE];
  }).reverse().reduce(function(innermostBaseTag, tag) {
    if (!innermostBaseTag.length) {
      var keys2 = Object.keys(tag);
      for (var i2 = 0; i2 < keys2.length; i2++) {
        var attributeKey = keys2[i2];
        var lowerCaseAttributeKey = attributeKey.toLowerCase();
        if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
          return innermostBaseTag.concat(tag);
        }
      }
    }
    return innermostBaseTag;
  }, []);
};
var getTagsFromPropsList = function getTagsFromPropsList2(tagName, primaryAttributes, propsList) {
  var approvedSeenTags = {};
  return propsList.filter(function(props) {
    if (Array.isArray(props[tagName])) {
      return true;
    }
    if (typeof props[tagName] !== "undefined") {
      warn("Helmet: " + tagName + ' should be of type "Array". Instead found type "' + _typeof(props[tagName]) + '"');
    }
    return false;
  }).map(function(props) {
    return props[tagName];
  }).reverse().reduce(function(approvedTags, instanceTags) {
    var instanceSeenTags = {};
    instanceTags.filter(function(tag) {
      var primaryAttributeKey = void 0;
      var keys3 = Object.keys(tag);
      for (var i3 = 0; i3 < keys3.length; i3++) {
        var attributeKey2 = keys3[i3];
        var lowerCaseAttributeKey = attributeKey2.toLowerCase();
        if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === TAG_PROPERTIES.REL && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === TAG_PROPERTIES.REL && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
          primaryAttributeKey = lowerCaseAttributeKey;
        }
        if (primaryAttributes.indexOf(attributeKey2) !== -1 && (attributeKey2 === TAG_PROPERTIES.INNER_HTML || attributeKey2 === TAG_PROPERTIES.CSS_TEXT || attributeKey2 === TAG_PROPERTIES.ITEM_PROP)) {
          primaryAttributeKey = attributeKey2;
        }
      }
      if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
        return false;
      }
      var value = tag[primaryAttributeKey].toLowerCase();
      if (!approvedSeenTags[primaryAttributeKey]) {
        approvedSeenTags[primaryAttributeKey] = {};
      }
      if (!instanceSeenTags[primaryAttributeKey]) {
        instanceSeenTags[primaryAttributeKey] = {};
      }
      if (!approvedSeenTags[primaryAttributeKey][value]) {
        instanceSeenTags[primaryAttributeKey][value] = true;
        return true;
      }
      return false;
    }).reverse().forEach(function(tag) {
      return approvedTags.push(tag);
    });
    var keys2 = Object.keys(instanceSeenTags);
    for (var i2 = 0; i2 < keys2.length; i2++) {
      var attributeKey = keys2[i2];
      var tagUnion = objectAssign$1({}, approvedSeenTags[attributeKey], instanceSeenTags[attributeKey]);
      approvedSeenTags[attributeKey] = tagUnion;
    }
    return approvedTags;
  }, []).reverse();
};
var getInnermostProperty = function getInnermostProperty2(propsList, property) {
  for (var i2 = propsList.length - 1; i2 >= 0; i2--) {
    var props = propsList[i2];
    if (props.hasOwnProperty(property)) {
      return props[property];
    }
  }
  return null;
};
var reducePropsToState = function reducePropsToState2(propsList) {
  return {
    baseTag: getBaseTagFromPropsList([TAG_PROPERTIES.HREF, TAG_PROPERTIES.TARGET], propsList),
    bodyAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.BODY, propsList),
    defer: getInnermostProperty(propsList, HELMET_PROPS.DEFER),
    encode: getInnermostProperty(propsList, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
    htmlAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.HTML, propsList),
    linkTags: getTagsFromPropsList(TAG_NAMES.LINK, [TAG_PROPERTIES.REL, TAG_PROPERTIES.HREF], propsList),
    metaTags: getTagsFromPropsList(TAG_NAMES.META, [TAG_PROPERTIES.NAME, TAG_PROPERTIES.CHARSET, TAG_PROPERTIES.HTTPEQUIV, TAG_PROPERTIES.PROPERTY, TAG_PROPERTIES.ITEM_PROP], propsList),
    noscriptTags: getTagsFromPropsList(TAG_NAMES.NOSCRIPT, [TAG_PROPERTIES.INNER_HTML], propsList),
    onChangeClientState: getOnChangeClientState(propsList),
    scriptTags: getTagsFromPropsList(TAG_NAMES.SCRIPT, [TAG_PROPERTIES.SRC, TAG_PROPERTIES.INNER_HTML], propsList),
    styleTags: getTagsFromPropsList(TAG_NAMES.STYLE, [TAG_PROPERTIES.CSS_TEXT], propsList),
    title: getTitleFromPropsList(propsList),
    titleAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.TITLE, propsList)
  };
};
var rafPolyfill = function() {
  var clock = Date.now();
  return function(callback) {
    var currentTime = Date.now();
    if (currentTime - clock > 16) {
      clock = currentTime;
      callback(currentTime);
    } else {
      setTimeout(function() {
        rafPolyfill(callback);
      }, 0);
    }
  };
}();
var cafPolyfill = function cafPolyfill2(id2) {
  return clearTimeout(id2);
};
var requestAnimationFrame$2 = typeof window !== "undefined" ? window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || rafPolyfill : global.requestAnimationFrame || rafPolyfill;
var cancelAnimationFrame = typeof window !== "undefined" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || cafPolyfill : global.cancelAnimationFrame || cafPolyfill;
var warn = function warn2(msg) {
  return console && typeof console.warn === "function" && console.warn(msg);
};
var _helmetCallback = null;
var handleClientStateChange = function handleClientStateChange2(newState) {
  if (_helmetCallback) {
    cancelAnimationFrame(_helmetCallback);
  }
  if (newState.defer) {
    _helmetCallback = requestAnimationFrame$2(function() {
      commitTagChanges(newState, function() {
        _helmetCallback = null;
      });
    });
  } else {
    commitTagChanges(newState);
    _helmetCallback = null;
  }
};
var commitTagChanges = function commitTagChanges2(newState, cb2) {
  var baseTag = newState.baseTag, bodyAttributes = newState.bodyAttributes, htmlAttributes = newState.htmlAttributes, linkTags = newState.linkTags, metaTags = newState.metaTags, noscriptTags = newState.noscriptTags, onChangeClientState = newState.onChangeClientState, scriptTags = newState.scriptTags, styleTags = newState.styleTags, title = newState.title, titleAttributes = newState.titleAttributes;
  updateAttributes(TAG_NAMES.BODY, bodyAttributes);
  updateAttributes(TAG_NAMES.HTML, htmlAttributes);
  updateTitle(title, titleAttributes);
  var tagUpdates = {
    baseTag: updateTags(TAG_NAMES.BASE, baseTag),
    linkTags: updateTags(TAG_NAMES.LINK, linkTags),
    metaTags: updateTags(TAG_NAMES.META, metaTags),
    noscriptTags: updateTags(TAG_NAMES.NOSCRIPT, noscriptTags),
    scriptTags: updateTags(TAG_NAMES.SCRIPT, scriptTags),
    styleTags: updateTags(TAG_NAMES.STYLE, styleTags)
  };
  var addedTags = {};
  var removedTags = {};
  Object.keys(tagUpdates).forEach(function(tagType) {
    var _tagUpdates$tagType = tagUpdates[tagType], newTags = _tagUpdates$tagType.newTags, oldTags = _tagUpdates$tagType.oldTags;
    if (newTags.length) {
      addedTags[tagType] = newTags;
    }
    if (oldTags.length) {
      removedTags[tagType] = tagUpdates[tagType].oldTags;
    }
  });
  cb2 && cb2();
  onChangeClientState(newState, addedTags, removedTags);
};
var flattenArray = function flattenArray2(possibleArray) {
  return Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
};
var updateTitle = function updateTitle2(title, attributes) {
  if (typeof title !== "undefined" && document.title !== title) {
    document.title = flattenArray(title);
  }
  updateAttributes(TAG_NAMES.TITLE, attributes);
};
var updateAttributes = function updateAttributes2(tagName, attributes) {
  var elementTag = document.getElementsByTagName(tagName)[0];
  if (!elementTag) {
    return;
  }
  var helmetAttributeString = elementTag.getAttribute(HELMET_ATTRIBUTE);
  var helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
  var attributesToRemove = [].concat(helmetAttributes);
  var attributeKeys = Object.keys(attributes);
  for (var i2 = 0; i2 < attributeKeys.length; i2++) {
    var attribute = attributeKeys[i2];
    var value = attributes[attribute] || "";
    if (elementTag.getAttribute(attribute) !== value) {
      elementTag.setAttribute(attribute, value);
    }
    if (helmetAttributes.indexOf(attribute) === -1) {
      helmetAttributes.push(attribute);
    }
    var indexToSave = attributesToRemove.indexOf(attribute);
    if (indexToSave !== -1) {
      attributesToRemove.splice(indexToSave, 1);
    }
  }
  for (var _i = attributesToRemove.length - 1; _i >= 0; _i--) {
    elementTag.removeAttribute(attributesToRemove[_i]);
  }
  if (helmetAttributes.length === attributesToRemove.length) {
    elementTag.removeAttribute(HELMET_ATTRIBUTE);
  } else if (elementTag.getAttribute(HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
    elementTag.setAttribute(HELMET_ATTRIBUTE, attributeKeys.join(","));
  }
};
var updateTags = function updateTags2(type, tags) {
  var headElement = document.head || document.querySelector(TAG_NAMES.HEAD);
  var tagNodes = headElement.querySelectorAll(type + "[" + HELMET_ATTRIBUTE + "]");
  var oldTags = Array.prototype.slice.call(tagNodes);
  var newTags = [];
  var indexToDelete = void 0;
  if (tags && tags.length) {
    tags.forEach(function(tag) {
      var newElement = document.createElement(type);
      for (var attribute in tag) {
        if (tag.hasOwnProperty(attribute)) {
          if (attribute === TAG_PROPERTIES.INNER_HTML) {
            newElement.innerHTML = tag.innerHTML;
          } else if (attribute === TAG_PROPERTIES.CSS_TEXT) {
            if (newElement.styleSheet) {
              newElement.styleSheet.cssText = tag.cssText;
            } else {
              newElement.appendChild(document.createTextNode(tag.cssText));
            }
          } else {
            var value = typeof tag[attribute] === "undefined" ? "" : tag[attribute];
            newElement.setAttribute(attribute, value);
          }
        }
      }
      newElement.setAttribute(HELMET_ATTRIBUTE, "true");
      if (oldTags.some(function(existingTag, index2) {
        indexToDelete = index2;
        return newElement.isEqualNode(existingTag);
      })) {
        oldTags.splice(indexToDelete, 1);
      } else {
        newTags.push(newElement);
      }
    });
  }
  oldTags.forEach(function(tag) {
    return tag.parentNode.removeChild(tag);
  });
  newTags.forEach(function(tag) {
    return headElement.appendChild(tag);
  });
  return {
    oldTags,
    newTags
  };
};
var generateElementAttributesAsString = function generateElementAttributesAsString2(attributes) {
  return Object.keys(attributes).reduce(function(str, key) {
    var attr = typeof attributes[key] !== "undefined" ? key + '="' + attributes[key] + '"' : "" + key;
    return str ? str + " " + attr : attr;
  }, "");
};
var generateTitleAsString = function generateTitleAsString2(type, title, attributes, encode3) {
  var attributeString = generateElementAttributesAsString(attributes);
  var flattenedTitle = flattenArray(title);
  return attributeString ? "<" + type + " " + HELMET_ATTRIBUTE + '="true" ' + attributeString + ">" + encodeSpecialCharacters(flattenedTitle, encode3) + "</" + type + ">" : "<" + type + " " + HELMET_ATTRIBUTE + '="true">' + encodeSpecialCharacters(flattenedTitle, encode3) + "</" + type + ">";
};
var generateTagsAsString = function generateTagsAsString2(type, tags, encode3) {
  return tags.reduce(function(str, tag) {
    var attributeHtml = Object.keys(tag).filter(function(attribute) {
      return !(attribute === TAG_PROPERTIES.INNER_HTML || attribute === TAG_PROPERTIES.CSS_TEXT);
    }).reduce(function(string2, attribute) {
      var attr = typeof tag[attribute] === "undefined" ? attribute : attribute + '="' + encodeSpecialCharacters(tag[attribute], encode3) + '"';
      return string2 ? string2 + " " + attr : attr;
    }, "");
    var tagContent = tag.innerHTML || tag.cssText || "";
    var isSelfClosing = SELF_CLOSING_TAGS.indexOf(type) === -1;
    return str + "<" + type + " " + HELMET_ATTRIBUTE + '="true" ' + attributeHtml + (isSelfClosing ? "/>" : ">" + tagContent + "</" + type + ">");
  }, "");
};
var convertElementAttributestoReactProps = function convertElementAttributestoReactProps2(attributes) {
  var initProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Object.keys(attributes).reduce(function(obj, key) {
    obj[REACT_TAG_MAP[key] || key] = attributes[key];
    return obj;
  }, initProps);
};
var convertReactPropstoHtmlAttributes = function convertReactPropstoHtmlAttributes2(props) {
  var initAttributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Object.keys(props).reduce(function(obj, key) {
    obj[HTML_TAG_MAP[key] || key] = props[key];
    return obj;
  }, initAttributes);
};
var generateTitleAsReactComponent = function generateTitleAsReactComponent2(type, title, attributes) {
  var _initProps;
  var initProps = (_initProps = {
    key: title
  }, _initProps[HELMET_ATTRIBUTE] = true, _initProps);
  var props = convertElementAttributestoReactProps(attributes, initProps);
  return [React$1.createElement(TAG_NAMES.TITLE, props, title)];
};
var generateTagsAsReactComponent = function generateTagsAsReactComponent2(type, tags) {
  return tags.map(function(tag, i2) {
    var _mappedTag;
    var mappedTag = (_mappedTag = {
      key: i2
    }, _mappedTag[HELMET_ATTRIBUTE] = true, _mappedTag);
    Object.keys(tag).forEach(function(attribute) {
      var mappedAttribute = REACT_TAG_MAP[attribute] || attribute;
      if (mappedAttribute === TAG_PROPERTIES.INNER_HTML || mappedAttribute === TAG_PROPERTIES.CSS_TEXT) {
        var content = tag.innerHTML || tag.cssText;
        mappedTag.dangerouslySetInnerHTML = { __html: content };
      } else {
        mappedTag[mappedAttribute] = tag[attribute];
      }
    });
    return React$1.createElement(type, mappedTag);
  });
};
var getMethodsForTag = function getMethodsForTag2(type, tags, encode3) {
  switch (type) {
    case TAG_NAMES.TITLE:
      return {
        toComponent: function toComponent() {
          return generateTitleAsReactComponent(type, tags.title, tags.titleAttributes);
        },
        toString: function toString3() {
          return generateTitleAsString(type, tags.title, tags.titleAttributes, encode3);
        }
      };
    case ATTRIBUTE_NAMES.BODY:
    case ATTRIBUTE_NAMES.HTML:
      return {
        toComponent: function toComponent() {
          return convertElementAttributestoReactProps(tags);
        },
        toString: function toString3() {
          return generateElementAttributesAsString(tags);
        }
      };
    default:
      return {
        toComponent: function toComponent() {
          return generateTagsAsReactComponent(type, tags);
        },
        toString: function toString3() {
          return generateTagsAsString(type, tags, encode3);
        }
      };
  }
};
var mapStateOnServer = function mapStateOnServer2(_ref) {
  var baseTag = _ref.baseTag, bodyAttributes = _ref.bodyAttributes, encode3 = _ref.encode, htmlAttributes = _ref.htmlAttributes, linkTags = _ref.linkTags, metaTags = _ref.metaTags, noscriptTags = _ref.noscriptTags, scriptTags = _ref.scriptTags, styleTags = _ref.styleTags, _ref$title = _ref.title, title = _ref$title === void 0 ? "" : _ref$title, titleAttributes = _ref.titleAttributes;
  return {
    base: getMethodsForTag(TAG_NAMES.BASE, baseTag, encode3),
    bodyAttributes: getMethodsForTag(ATTRIBUTE_NAMES.BODY, bodyAttributes, encode3),
    htmlAttributes: getMethodsForTag(ATTRIBUTE_NAMES.HTML, htmlAttributes, encode3),
    link: getMethodsForTag(TAG_NAMES.LINK, linkTags, encode3),
    meta: getMethodsForTag(TAG_NAMES.META, metaTags, encode3),
    noscript: getMethodsForTag(TAG_NAMES.NOSCRIPT, noscriptTags, encode3),
    script: getMethodsForTag(TAG_NAMES.SCRIPT, scriptTags, encode3),
    style: getMethodsForTag(TAG_NAMES.STYLE, styleTags, encode3),
    title: getMethodsForTag(TAG_NAMES.TITLE, { title, titleAttributes }, encode3)
  };
};
var Helmet = function Helmet2(Component2) {
  var _class, _temp;
  return _temp = _class = function(_React$Component) {
    inherits(HelmetWrapper, _React$Component);
    function HelmetWrapper() {
      classCallCheck(this, HelmetWrapper);
      return possibleConstructorReturn(this, _React$Component.apply(this, arguments));
    }
    HelmetWrapper.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return !isEqual(this.props, nextProps);
    };
    HelmetWrapper.prototype.mapNestedChildrenToProps = function mapNestedChildrenToProps(child, nestedChildren) {
      if (!nestedChildren) {
        return null;
      }
      switch (child.type) {
        case TAG_NAMES.SCRIPT:
        case TAG_NAMES.NOSCRIPT:
          return {
            innerHTML: nestedChildren
          };
        case TAG_NAMES.STYLE:
          return {
            cssText: nestedChildren
          };
      }
      throw new Error("<" + child.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.");
    };
    HelmetWrapper.prototype.flattenArrayTypeChildren = function flattenArrayTypeChildren(_ref) {
      var _babelHelpers$extends;
      var child = _ref.child, arrayTypeChildren = _ref.arrayTypeChildren, newChildProps = _ref.newChildProps, nestedChildren = _ref.nestedChildren;
      return _extends$3({}, arrayTypeChildren, (_babelHelpers$extends = {}, _babelHelpers$extends[child.type] = [].concat(arrayTypeChildren[child.type] || [], [_extends$3({}, newChildProps, this.mapNestedChildrenToProps(child, nestedChildren))]), _babelHelpers$extends));
    };
    HelmetWrapper.prototype.mapObjectTypeChildren = function mapObjectTypeChildren(_ref2) {
      var _babelHelpers$extends2, _babelHelpers$extends3;
      var child = _ref2.child, newProps = _ref2.newProps, newChildProps = _ref2.newChildProps, nestedChildren = _ref2.nestedChildren;
      switch (child.type) {
        case TAG_NAMES.TITLE:
          return _extends$3({}, newProps, (_babelHelpers$extends2 = {}, _babelHelpers$extends2[child.type] = nestedChildren, _babelHelpers$extends2.titleAttributes = _extends$3({}, newChildProps), _babelHelpers$extends2));
        case TAG_NAMES.BODY:
          return _extends$3({}, newProps, {
            bodyAttributes: _extends$3({}, newChildProps)
          });
        case TAG_NAMES.HTML:
          return _extends$3({}, newProps, {
            htmlAttributes: _extends$3({}, newChildProps)
          });
      }
      return _extends$3({}, newProps, (_babelHelpers$extends3 = {}, _babelHelpers$extends3[child.type] = _extends$3({}, newChildProps), _babelHelpers$extends3));
    };
    HelmetWrapper.prototype.mapArrayTypeChildrenToProps = function mapArrayTypeChildrenToProps(arrayTypeChildren, newProps) {
      var newFlattenedProps = _extends$3({}, newProps);
      Object.keys(arrayTypeChildren).forEach(function(arrayChildName) {
        var _babelHelpers$extends4;
        newFlattenedProps = _extends$3({}, newFlattenedProps, (_babelHelpers$extends4 = {}, _babelHelpers$extends4[arrayChildName] = arrayTypeChildren[arrayChildName], _babelHelpers$extends4));
      });
      return newFlattenedProps;
    };
    HelmetWrapper.prototype.warnOnInvalidChildren = function warnOnInvalidChildren(child, nestedChildren) {
      return true;
    };
    HelmetWrapper.prototype.mapChildrenToProps = function mapChildrenToProps(children, newProps) {
      var _this2 = this;
      var arrayTypeChildren = {};
      React$1.Children.forEach(children, function(child) {
        if (!child || !child.props) {
          return;
        }
        var _child$props = child.props, nestedChildren = _child$props.children, childProps = objectWithoutProperties(_child$props, ["children"]);
        var newChildProps = convertReactPropstoHtmlAttributes(childProps);
        _this2.warnOnInvalidChildren(child, nestedChildren);
        switch (child.type) {
          case TAG_NAMES.LINK:
          case TAG_NAMES.META:
          case TAG_NAMES.NOSCRIPT:
          case TAG_NAMES.SCRIPT:
          case TAG_NAMES.STYLE:
            arrayTypeChildren = _this2.flattenArrayTypeChildren({
              child,
              arrayTypeChildren,
              newChildProps,
              nestedChildren
            });
            break;
          default:
            newProps = _this2.mapObjectTypeChildren({
              child,
              newProps,
              newChildProps,
              nestedChildren
            });
            break;
        }
      });
      newProps = this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);
      return newProps;
    };
    HelmetWrapper.prototype.render = function render3() {
      var _props = this.props, children = _props.children, props = objectWithoutProperties(_props, ["children"]);
      var newProps = _extends$3({}, props);
      if (children) {
        newProps = this.mapChildrenToProps(children, newProps);
      }
      return React$1.createElement(Component2, newProps);
    };
    createClass(HelmetWrapper, null, [{
      key: "canUseDOM",
      // Component.peek comes from react-side-effect:
      // For testing, you may use a static peek() method available on the returned component.
      // It lets you get the current state without resetting the mounted instance stack.
      // Don’t use it for anything other than testing.
      /**
       * @param {Object} base: {"target": "_blank", "href": "http://mysite.com/"}
       * @param {Object} bodyAttributes: {"className": "root"}
       * @param {String} defaultTitle: "Default Title"
       * @param {Boolean} defer: true
       * @param {Boolean} encodeSpecialCharacters: true
       * @param {Object} htmlAttributes: {"lang": "en", "amp": undefined}
       * @param {Array} link: [{"rel": "canonical", "href": "http://mysite.com/example"}]
       * @param {Array} meta: [{"name": "description", "content": "Test description"}]
       * @param {Array} noscript: [{"innerHTML": "<img src='http://mysite.com/js/test.js'"}]
       * @param {Function} onChangeClientState: "(newState) => console.log(newState)"
       * @param {Array} script: [{"type": "text/javascript", "src": "http://mysite.com/js/test.js"}]
       * @param {Array} style: [{"type": "text/css", "cssText": "div { display: block; color: blue; }"}]
       * @param {String} title: "Title"
       * @param {Object} titleAttributes: {"itemprop": "name"}
       * @param {String} titleTemplate: "MySite.com - %s"
       */
      set: function set$$1(canUseDOM2) {
        Component2.canUseDOM = canUseDOM2;
      }
    }]);
    return HelmetWrapper;
  }(React$1.Component), _class.propTypes = {
    base: PropTypes.object,
    bodyAttributes: PropTypes.object,
    children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),
    defaultTitle: PropTypes.string,
    defer: PropTypes.bool,
    encodeSpecialCharacters: PropTypes.bool,
    htmlAttributes: PropTypes.object,
    link: PropTypes.arrayOf(PropTypes.object),
    meta: PropTypes.arrayOf(PropTypes.object),
    noscript: PropTypes.arrayOf(PropTypes.object),
    onChangeClientState: PropTypes.func,
    script: PropTypes.arrayOf(PropTypes.object),
    style: PropTypes.arrayOf(PropTypes.object),
    title: PropTypes.string,
    titleAttributes: PropTypes.object,
    titleTemplate: PropTypes.string
  }, _class.defaultProps = {
    defer: true,
    encodeSpecialCharacters: true
  }, _class.peek = Component2.peek, _class.rewind = function() {
    var mappedState = Component2.rewind();
    if (!mappedState) {
      mappedState = mapStateOnServer({
        baseTag: [],
        bodyAttributes: {},
        encodeSpecialCharacters: true,
        htmlAttributes: {},
        linkTags: [],
        metaTags: [],
        noscriptTags: [],
        scriptTags: [],
        styleTags: [],
        title: "",
        titleAttributes: {}
      });
    }
    return mappedState;
  }, _temp;
};
var NullComponent = function NullComponent2() {
  return null;
};
var HelmetSideEffects = withSideEffect$1(reducePropsToState, handleClientStateChange, mapStateOnServer)(NullComponent);
var HelmetExport = Helmet(HelmetSideEffects);
HelmetExport.renderStatic = HelmetExport.rewind;
var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$1(d2, b2);
};
function __extends$1(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$2 = function() {
  __assign$2 = Object.assign || function __assign2(t2) {
    for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s = arguments[i2];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
function __rest$2(s, e2) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
        t2[p2[i2]] = s[p2[i2]];
    }
  return t2;
}
function __decorate$2(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param$1(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context = {};
    for (var p2 in contextIn)
      context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x2) {
  return typeof x2 === "symbol" ? x2 : "".concat(x2);
}
function __setFunctionName(f2, name2, prefix) {
  if (typeof name2 === "symbol")
    name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
}
function __metadata$1(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter$2(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding$1 = Object.create ? function(o, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o, k22, desc);
} : function(o, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o[k22] = m2[k2];
};
function __exportStar$1(m2, o) {
  for (var p2 in m2)
    if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o, p2))
      __createBinding$1(o, m2, p2);
}
function __values$1(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i2 = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$1(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i2 = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spread$1() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read$1(arguments[i2]));
  return ar;
}
function __spreadArrays$1() {
  for (var s = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++)
    s += arguments[i2].length;
  for (var r2 = Array(s), k2 = 0, i2 = 0; i2 < il2; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __spreadArray$1(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await$1(v2) {
  return this instanceof __await$1 ? (this.v = v2, this) : new __await$1(v2);
}
function __asyncGenerator$1(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await$1 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator$1(o) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f2) {
    i2[n2] = o[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await$1(o[n2](v2)), done: false } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues$1(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o) : (o = typeof __values$1 === "function" ? __values$1(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject$1(cooked, raw2) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw2 });
  } else {
    cooked.raw = raw2;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? function(o, v2) {
  Object.defineProperty(o, "default", { enumerable: true, value: v2 });
} : function(o, v2) {
  o["default"] = v2;
};
function __importStar$1(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k2 in mod2)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
        __createBinding$1(result, mod2, k2);
  }
  __setModuleDefault(result, mod2);
  return result;
}
function __importDefault$4(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet$1(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet$1(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env2, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function __disposeResources(env2) {
  function fail(e2) {
    env2.error = env2.hasError ? new _SuppressedError(e2, env2.error, "An error was suppressed during disposal.") : e2;
    env2.hasError = true;
  }
  function next() {
    while (env2.stack.length) {
      var rec = env2.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next, function(e2) {
            fail(e2);
            return next();
          });
      } catch (e2) {
        fail(e2);
      }
    }
    if (env2.hasError)
      throw env2.error;
  }
  return next();
}
const tslib_es6$1 = {
  __extends: __extends$1,
  __assign: __assign$2,
  __rest: __rest$2,
  __decorate: __decorate$2,
  __param: __param$1,
  __metadata: __metadata$1,
  __awaiter: __awaiter$2,
  __generator: __generator$1,
  __createBinding: __createBinding$1,
  __exportStar: __exportStar$1,
  __values: __values$1,
  __read: __read$1,
  __spread: __spread$1,
  __spreadArrays: __spreadArrays$1,
  __spreadArray: __spreadArray$1,
  __await: __await$1,
  __asyncGenerator: __asyncGenerator$1,
  __asyncDelegator: __asyncDelegator$1,
  __asyncValues: __asyncValues$1,
  __makeTemplateObject: __makeTemplateObject$1,
  __importStar: __importStar$1,
  __importDefault: __importDefault$4,
  __classPrivateFieldGet: __classPrivateFieldGet$1,
  __classPrivateFieldSet: __classPrivateFieldSet$1,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
};
const tslib_es6$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign$2;
  },
  __asyncDelegator: __asyncDelegator$1,
  __asyncGenerator: __asyncGenerator$1,
  __asyncValues: __asyncValues$1,
  __await: __await$1,
  __awaiter: __awaiter$2,
  __classPrivateFieldGet: __classPrivateFieldGet$1,
  __classPrivateFieldIn,
  __classPrivateFieldSet: __classPrivateFieldSet$1,
  __createBinding: __createBinding$1,
  __decorate: __decorate$2,
  __disposeResources,
  __esDecorate,
  __exportStar: __exportStar$1,
  __extends: __extends$1,
  __generator: __generator$1,
  __importDefault: __importDefault$4,
  __importStar: __importStar$1,
  __makeTemplateObject: __makeTemplateObject$1,
  __metadata: __metadata$1,
  __param: __param$1,
  __propKey,
  __read: __read$1,
  __rest: __rest$2,
  __runInitializers,
  __setFunctionName,
  __spread: __spread$1,
  __spreadArray: __spreadArray$1,
  __spreadArrays: __spreadArrays$1,
  __values: __values$1,
  default: tslib_es6$1
}, Symbol.toStringTag, { value: "Module" }));
var genericMessage = "Invariant Violation";
var _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function(obj, proto) {
  obj.__proto__ = proto;
  return obj;
} : _a;
var InvariantError = (
  /** @class */
  function(_super) {
    __extends$1(InvariantError2, _super);
    function InvariantError2(message) {
      if (message === void 0) {
        message = genericMessage;
      }
      var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
      _this.framesToPop = 1;
      _this.name = genericMessage;
      setPrototypeOf(_this, InvariantError2.prototype);
      return _this;
    }
    return InvariantError2;
  }(Error)
);
function invariant$3(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}
var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
var verbosityLevel = verbosityLevels.indexOf("log");
function wrapConsoleMethod(name2) {
  return function() {
    if (verbosityLevels.indexOf(name2) >= verbosityLevel) {
      var method = console[name2] || console.log;
      return method.apply(console, arguments);
    }
  };
}
(function(invariant3) {
  invariant3.debug = wrapConsoleMethod("debug");
  invariant3.log = wrapConsoleMethod("log");
  invariant3.warn = wrapConsoleMethod("warn");
  invariant3.error = wrapConsoleMethod("error");
})(invariant$3 || (invariant$3 = {}));
var version$b = "3.8.10";
function maybe$1(thunk) {
  try {
    return thunk();
  } catch (_a2) {
  }
}
const global$2 = maybe$1(function() {
  return globalThis;
}) || maybe$1(function() {
  return window;
}) || maybe$1(function() {
  return self;
}) || maybe$1(function() {
  return global;
}) || // We don't expect the Function constructor ever to be invoked at runtime, as
// long as at least one of globalThis, window, self, or global is defined, so
// we are under no obligation to make it easy for static analysis tools to
// detect syntactic usage of the Function constructor. If you think you can
// improve your static analysis to detect this obfuscation, think again. This
// is an arms race you cannot win, at least not in JavaScript.
maybe$1(function() {
  return maybe$1.constructor("return this")();
});
var prefixCounts = /* @__PURE__ */ new Map();
function makeUniqueId(prefix) {
  var count = prefixCounts.get(prefix) || 1;
  prefixCounts.set(prefix, count + 1);
  return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
}
function stringifyForDisplay(value, space) {
  if (space === void 0) {
    space = 0;
  }
  var undefId = makeUniqueId("stringifyForDisplay");
  return JSON.stringify(value, function(key, value2) {
    return value2 === void 0 ? undefId : value2;
  }, space).split(JSON.stringify(undefId)).join("<undefined>");
}
function wrap$2(fn) {
  return function(message) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (typeof message === "number") {
      var arg0 = message;
      message = getHandledErrorMsg(arg0);
      if (!message) {
        message = getFallbackErrorMsg(arg0, args);
        args = [];
      }
    }
    fn.apply(void 0, [message].concat(args));
  };
}
var invariant$2 = Object.assign(function invariant2(condition, message) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (!condition) {
    invariant$3(condition, getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args));
  }
}, {
  debug: wrap$2(invariant$3.debug),
  log: wrap$2(invariant$3.log),
  warn: wrap$2(invariant$3.warn),
  error: wrap$2(invariant$3.error)
});
function newInvariantError(message) {
  var optionalParams = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    optionalParams[_i - 1] = arguments[_i];
  }
  return new InvariantError(getHandledErrorMsg(message, optionalParams) || getFallbackErrorMsg(message, optionalParams));
}
var ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + version$b);
function stringify$5(arg) {
  return typeof arg == "string" ? arg : stringifyForDisplay(arg, 2).slice(0, 1e3);
}
function getHandledErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return global$2[ApolloErrorMessageHandler] && global$2[ApolloErrorMessageHandler](message, messageArgs.map(stringify$5));
}
function getFallbackErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
    version: version$b,
    message,
    args: messageArgs.map(stringify$5)
  })));
}
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
class Location {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
let Token$2 = class Token2 {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end2, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end2;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
const QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
const kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));
function isWhiteSpace(code2) {
  return code2 === 9 || code2 === 32;
}
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isLetter(code2) {
  return code2 >= 97 && code2 <= 122 || // A-Z
  code2 >= 65 && code2 <= 90;
}
function isNameStart(code2) {
  return isLetter(code2) || code2 === 95;
}
function isNameContinue(code2) {
  return isLetter(code2) || isDigit(code2) || code2 === 95;
}
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i2 = 0; i2 < lines.length; ++i2) {
    var _firstNonEmptyLine;
    const line = lines[i2];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i2;
    lastNonEmptyLine = i2;
    if (i2 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i2) => i2 === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i2 = 0;
  while (i2 < str.length && isWhiteSpace(str.charCodeAt(i2))) {
    ++i2;
  }
  return i2;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
const MAX_ARRAY_LENGTH = 10;
const MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len2 = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len2;
  const items = [];
  for (let i2 = 0; i2 < len2; ++i2) {
    items.push(formatValue(array[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name2 = object.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
const escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];
const BREAK$1 = Object.freeze({});
function visit(root2, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root2);
  let keys2 = [root2];
  let index2 = -1;
  let edits = [];
  let node2 = root2;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index2++;
    const isLeaving = index2 === keys2.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node2 = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node2 = node2.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node2.splice(arrayKey, 1);
              editOffset++;
            } else {
              node2[arrayKey] = editValue;
            }
          }
        } else {
          node2 = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node2)
          );
          for (const [editKey, editValue] of edits) {
            node2[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys2 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index2 : keys2[index2];
      node2 = parent[key];
      if (node2 === null || node2 === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node2)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node2) || devAssert(false, `Invalid AST Node: ${inspect(node2)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node2, key, parent, path, ancestors);
      if (result === BREAK$1) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node2 = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node2]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index2,
        keys: keys2,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node2);
      keys2 = inArray ? node2 : (_node$kind = visitorKeys[node2.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index2 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node2;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root2;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
function print$1(ast) {
  return visit(ast, printDocASTReducer);
}
const MAX_LINE_LENGTH = 80;
const printDocASTReducer = {
  Name: {
    leave: (node2) => node2.value
  },
  Variable: {
    leave: (node2) => "$" + node2.name
  },
  // Document
  Document: {
    leave: (node2) => join(node2.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node2) {
      const varDefs = wrap$1("(", join(node2.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node2.operation,
          join([node2.name, varDefs]),
          join(node2.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node2.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap$1(" = ", defaultValue) + wrap$1(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block$4(selections)
  },
  Field: {
    leave({ alias, name: name2, arguments: args, directives, selectionSet }) {
      const prefix = wrap$1("", alias, ": ") + name2;
      let argsLine = prefix + wrap$1("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap$1("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name: name2, value }) => name2 + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: name2, directives }) => "..." + name2 + wrap$1(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap$1("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: name2, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name2}${wrap$1("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap$1("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: name2, value }) => name2 + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap$1("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: name2 }) => name2
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: description2, directives, operationTypes }) => wrap$1("", description2, "\n") + join(["schema", join(directives, " "), block$4(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description: description2, name: name2, directives }) => wrap$1("", description2, "\n") + join(["scalar", name2, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: description2, name: name2, interfaces, directives, fields }) => wrap$1("", description2, "\n") + join(
      [
        "type",
        name2,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block$4(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: description2, name: name2, arguments: args, type, directives }) => wrap$1("", description2, "\n") + name2 + (hasMultilineItems(args) ? wrap$1("(\n", indent(join(args, "\n")), "\n)") : wrap$1("(", join(args, ", "), ")")) + ": " + type + wrap$1(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description: description2, name: name2, type, defaultValue, directives }) => wrap$1("", description2, "\n") + join(
      [name2 + ": " + type, wrap$1("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: description2, name: name2, interfaces, directives, fields }) => wrap$1("", description2, "\n") + join(
      [
        "interface",
        name2,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block$4(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: description2, name: name2, directives, types: types2 }) => wrap$1("", description2, "\n") + join(
      ["union", name2, join(directives, " "), wrap$1("= ", join(types2, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: description2, name: name2, directives, values }) => wrap$1("", description2, "\n") + join(["enum", name2, join(directives, " "), block$4(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: description2, name: name2, directives }) => wrap$1("", description2, "\n") + join([name2, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: description2, name: name2, directives, fields }) => wrap$1("", description2, "\n") + join(["input", name2, join(directives, " "), block$4(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: description2, name: name2, arguments: args, repeatable, locations }) => wrap$1("", description2, "\n") + "directive @" + name2 + (hasMultilineItems(args) ? wrap$1("(\n", indent(join(args, "\n")), "\n)") : wrap$1("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block$4(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives }) => join(["extend scalar", name2, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join(
      [
        "extend type",
        name2,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block$4(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name2,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block$4(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives, types: types2 }) => join(
      [
        "extend union",
        name2,
        join(directives, " "),
        wrap$1("= ", join(types2, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives, values }) => join(["extend enum", name2, join(directives, " "), block$4(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives, fields }) => join(["extend input", name2, join(directives, " "), block$4(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x2) => x2).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block$4(array) {
  return wrap$1("{\n", indent(join(array, "\n")), "\n}");
}
function wrap$1(start, maybeString, end2 = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end2 : "";
}
function indent(str) {
  return wrap$1("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
function isSelectionNode(node2) {
  return node2.kind === Kind.FIELD || node2.kind === Kind.FRAGMENT_SPREAD || node2.kind === Kind.INLINE_FRAGMENT;
}
function shouldInclude(_a2, variables) {
  var directives = _a2.directives;
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives(directives).every(function(_a3) {
    var directive = _a3.directive, ifArgument = _a3.ifArgument;
    var evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      invariant$2(evaledValue !== void 0, 66, directive.name.value);
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function hasDirectives(names2, root2, all2) {
  var nameSet = new Set(names2);
  var uniqueCount = nameSet.size;
  visit(root2, {
    Directive: function(node2) {
      if (nameSet.delete(node2.name.value) && (!all2 || !nameSet.size)) {
        return BREAK$1;
      }
    }
  });
  return all2 ? !nameSet.size : nameSet.size < uniqueCount;
}
function hasClientExports(document2) {
  return document2 && hasDirectives(["client", "export"], document2, true);
}
function isInclusionDirective(_a2) {
  var value = _a2.name.value;
  return value === "skip" || value === "include";
}
function getInclusionDirectives(directives) {
  var result = [];
  if (directives && directives.length) {
    directives.forEach(function(directive) {
      if (!isInclusionDirective(directive))
        return;
      var directiveArguments = directive.arguments;
      var directiveName = directive.name.value;
      invariant$2(directiveArguments && directiveArguments.length === 1, 67, directiveName);
      var ifArgument = directiveArguments[0];
      invariant$2(ifArgument.name && ifArgument.name.value === "if", 68, directiveName);
      var ifValue = ifArgument.value;
      invariant$2(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 69, directiveName);
      result.push({ directive, ifArgument });
    });
  }
  return result;
}
const defaultMakeData$1 = () => /* @__PURE__ */ Object.create(null);
const { forEach: forEach$1, slice: slice$6 } = Array.prototype;
const { hasOwnProperty: hasOwnProperty$8 } = Object.prototype;
let Trie$1 = class Trie2 {
  constructor(weakness = true, makeData = defaultMakeData$1) {
    this.weakness = weakness;
    this.makeData = makeData;
  }
  lookup() {
    return this.lookupArray(arguments);
  }
  lookupArray(array) {
    let node2 = this;
    forEach$1.call(array, (key) => node2 = node2.getChildTrie(key));
    return hasOwnProperty$8.call(node2, "data") ? node2.data : node2.data = this.makeData(slice$6.call(array));
  }
  peek() {
    return this.peekArray(arguments);
  }
  peekArray(array) {
    let node2 = this;
    for (let i2 = 0, len2 = array.length; node2 && i2 < len2; ++i2) {
      const map2 = node2.mapFor(array[i2], false);
      node2 = map2 && map2.get(array[i2]);
    }
    return node2 && node2.data;
  }
  remove() {
    return this.removeArray(arguments);
  }
  removeArray(array) {
    let data2;
    if (array.length) {
      const head = array[0];
      const map2 = this.mapFor(head, false);
      const child = map2 && map2.get(head);
      if (child) {
        data2 = child.removeArray(slice$6.call(array, 1));
        if (!child.data && !child.weak && !(child.strong && child.strong.size)) {
          map2.delete(head);
        }
      }
    } else {
      data2 = this.data;
      delete this.data;
    }
    return data2;
  }
  getChildTrie(key) {
    const map2 = this.mapFor(key, true);
    let child = map2.get(key);
    if (!child)
      map2.set(key, child = new Trie2(this.weakness, this.makeData));
    return child;
  }
  mapFor(key, create5) {
    return this.weakness && isObjRef$1(key) ? this.weak || (create5 ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (create5 ? this.strong = /* @__PURE__ */ new Map() : void 0);
  }
};
function isObjRef$1(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
var canUseWeakMap = typeof WeakMap === "function" && maybe$1(function() {
  return navigator.product;
}) !== "ReactNative";
var canUseWeakSet = typeof WeakSet === "function";
var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
var canUseDOM = typeof maybe$1(function() {
  return window.document.createElement;
}) === "function";
var usingJSDOM = (
  // Following advice found in this comment from @domenic (maintainer of jsdom):
  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327
  //
  // Since we control the version of Jest and jsdom used when running Apollo
  // Client tests, and that version is recent enought to include " jsdom/x.y.z"
  // at the end of the user agent string, I believe this case is all we need to
  // check. Testing for "Node.js" was recommended for backwards compatibility
  // with older version of jsdom, but we don't have that problem.
  maybe$1(function() {
    return navigator.userAgent.indexOf("jsdom") >= 0;
  }) || false
);
var canUseLayoutEffect = canUseDOM && !usingJSDOM;
function isNonNullObject(obj) {
  return obj !== null && typeof obj === "object";
}
function getFragmentQueryDocument(document2, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document2.definitions.forEach(function(definition) {
    if (definition.kind === "OperationDefinition") {
      throw newInvariantError(
        70,
        definition.operation,
        definition.name ? " named '".concat(definition.name.value, "'") : ""
      );
    }
    if (definition.kind === "FragmentDefinition") {
      fragments.push(definition);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    invariant$2(fragments.length === 1, 71, fragments.length);
    actualFragmentName = fragments[0].name.value;
  }
  var query = __assign$2(__assign$2({}, document2), { definitions: __spreadArray$1([
    {
      kind: "OperationDefinition",
      // OperationTypeNode is an enum
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: actualFragmentName
            }
          }
        ]
      }
    }
  ], document2.definitions, true) });
  return query;
}
function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }
  var symTable = {};
  fragments.forEach(function(fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      var fragmentName = selection.name.value;
      if (typeof fragmentMap === "function") {
        return fragmentMap(fragmentName);
      }
      var fragment = fragmentMap && fragmentMap[fragmentName];
      invariant$2(fragment, 72, fragmentName);
      return fragment || null;
    }
    default:
      return null;
  }
}
function makeReference(id2) {
  return { __ref: String(id2) };
}
function isReference(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}
function isDocumentNode(value) {
  return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
}
function isStringValue(value) {
  return value.kind === "StringValue";
}
function isBooleanValue(value) {
  return value.kind === "BooleanValue";
}
function isIntValue(value) {
  return value.kind === "IntValue";
}
function isFloatValue(value) {
  return value.kind === "FloatValue";
}
function isVariable(value) {
  return value.kind === "Variable";
}
function isObjectValue(value) {
  return value.kind === "ObjectValue";
}
function isListValue(value) {
  return value.kind === "ListValue";
}
function isEnumValue(value) {
  return value.kind === "EnumValue";
}
function isNullValue(value) {
  return value.kind === "NullValue";
}
function valueToObjectRepresentation(argObj, name2, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name2.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name2.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function(obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name2.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name2.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name2.value] = value.values.map(function(listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name2, listValue, variables);
      return nestedArgArrayObj[name2.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name2.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name2.value] = null;
  } else {
    throw newInvariantError(81, name2.value, value.kind);
  }
}
function storeKeyNameFromField(field, variables) {
  var directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function(directive) {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(function(_a2) {
          var name2 = _a2.name, value = _a2.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name2, value, variables);
        });
      }
    });
  }
  var argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function(_a2) {
      var name2 = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj, name2, value, variables);
    });
  }
  return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export",
  "nonreactive"
];
var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
  if (args && directives && directives["connection"] && directives["connection"]["key"]) {
    if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
      var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
      filterKeys.sort();
      var filteredArgs_1 = {};
      filterKeys.forEach(function(key) {
        filteredArgs_1[key] = args[key];
      });
      return "".concat(directives["connection"]["key"], "(").concat(stringify$4(filteredArgs_1), ")");
    } else {
      return directives["connection"]["key"];
    }
  }
  var completeFieldName = fieldName;
  if (args) {
    var stringifiedArgs = stringify$4(args);
    completeFieldName += "(".concat(stringifiedArgs, ")");
  }
  if (directives) {
    Object.keys(directives).forEach(function(key) {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
        return;
      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@".concat(key, "(").concat(stringify$4(directives[key]), ")");
      } else {
        completeFieldName += "@".concat(key);
      }
    });
  }
  return completeFieldName;
}, {
  setStringify: function(s) {
    var previous = stringify$4;
    stringify$4 = s;
    return previous;
  }
});
var stringify$4 = function defaultStringify(value) {
  return JSON.stringify(value, stringifyReplacer);
};
function stringifyReplacer(_key, value) {
  if (isNonNullObject(value) && !Array.isArray(value)) {
    value = Object.keys(value).sort().reduce(function(copy2, key) {
      copy2[key] = value[key];
      return copy2;
    }, {});
  }
  return value;
}
function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function(_a2) {
      var name2 = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj_1, name2, value, variables);
    });
    return argObj_1;
  }
  return null;
}
function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result, selectionSet, fragmentMap) {
  var fragments;
  for (var _i = 0, _a2 = selectionSet.selections; _i < _a2.length; _i++) {
    var selection = _a2[_i];
    if (isField(selection)) {
      if (selection.name.value === "__typename") {
        return result[resultKeyNameFromField(selection)];
      }
    } else if (fragments) {
      fragments.push(selection);
    } else {
      fragments = [selection];
    }
  }
  if (typeof result.__typename === "string") {
    return result.__typename;
  }
  if (fragments) {
    for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {
      var selection = fragments_1[_b];
      var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}
function isField(selection) {
  return selection.kind === "Field";
}
function isInlineFragment(selection) {
  return selection.kind === "InlineFragment";
}
function checkDocument(doc) {
  invariant$2(doc && doc.kind === "Document", 73);
  var operations = doc.definitions.filter(function(d2) {
    return d2.kind !== "FragmentDefinition";
  }).map(function(definition) {
    if (definition.kind !== "OperationDefinition") {
      throw newInvariantError(74, definition.kind);
    }
    return definition;
  });
  invariant$2(operations.length <= 1, 75, operations.length);
  return doc;
}
function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition";
  })[0];
}
function getOperationName(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition" && !!definition.name;
  }).map(function(x2) {
    return x2.name.value;
  })[0] || null;
}
function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "FragmentDefinition";
  });
}
function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
  invariant$2(queryDef && queryDef.operation === "query", 76);
  return queryDef;
}
function getFragmentDefinition(doc) {
  invariant$2(doc.kind === "Document", 77);
  invariant$2(doc.definitions.length <= 1, 78);
  var fragmentDef = doc.definitions[0];
  invariant$2(fragmentDef.kind === "FragmentDefinition", 79);
  return fragmentDef;
}
function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;
  for (var _i = 0, _a2 = queryDoc.definitions; _i < _a2.length; _i++) {
    var definition = _a2[_i];
    if (definition.kind === "OperationDefinition") {
      var operation = definition.operation;
      if (operation === "query" || operation === "mutation" || operation === "subscription") {
        return definition;
      }
    }
    if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw newInvariantError(80);
}
function getDefaultValues(definition) {
  var defaultValues = /* @__PURE__ */ Object.create(null);
  var defs = definition && definition.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach(function(def) {
      if (def.defaultValue) {
        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}
function identity$1(document2) {
  return document2;
}
var DocumentTransform = (
  /** @class */
  function() {
    function DocumentTransform2(transform2, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      this.resultCache = canUseWeakSet ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
      this.transform = transform2;
      if (options.getCacheKey) {
        this.getCacheKey = options.getCacheKey;
      }
      if (options.cache !== false) {
        this.stableCacheKeys = new Trie$1(canUseWeakMap, function(key) {
          return { key };
        });
      }
    }
    DocumentTransform2.prototype.getCacheKey = function(document2) {
      return [document2];
    };
    DocumentTransform2.identity = function() {
      return new DocumentTransform2(identity$1, { cache: false });
    };
    DocumentTransform2.split = function(predicate, left, right) {
      if (right === void 0) {
        right = DocumentTransform2.identity();
      }
      return new DocumentTransform2(
        function(document2) {
          var documentTransform = predicate(document2) ? left : right;
          return documentTransform.transformDocument(document2);
        },
        // Reasonably assume both `left` and `right` transforms handle their own caching
        { cache: false }
      );
    };
    DocumentTransform2.prototype.transformDocument = function(document2) {
      if (this.resultCache.has(document2)) {
        return document2;
      }
      var cacheEntry = this.getStableCacheEntry(document2);
      if (cacheEntry && cacheEntry.value) {
        return cacheEntry.value;
      }
      checkDocument(document2);
      var transformedDocument = this.transform(document2);
      this.resultCache.add(transformedDocument);
      if (cacheEntry) {
        cacheEntry.value = transformedDocument;
      }
      return transformedDocument;
    };
    DocumentTransform2.prototype.concat = function(otherTransform) {
      var _this = this;
      return new DocumentTransform2(
        function(document2) {
          return otherTransform.transformDocument(_this.transformDocument(document2));
        },
        // Reasonably assume both transforms handle their own caching
        { cache: false }
      );
    };
    DocumentTransform2.prototype.getStableCacheEntry = function(document2) {
      if (!this.stableCacheKeys)
        return;
      var cacheKeys = this.getCacheKey(document2);
      if (cacheKeys) {
        invariant$2(Array.isArray(cacheKeys), 65);
        return this.stableCacheKeys.lookupArray(cacheKeys);
      }
    };
    return DocumentTransform2;
  }()
);
var printCache = canUseWeakMap ? /* @__PURE__ */ new WeakMap() : void 0;
var print = function(ast) {
  var result;
  result = printCache === null || printCache === void 0 ? void 0 : printCache.get(ast);
  if (!result) {
    result = print$1(ast);
    printCache === null || printCache === void 0 ? void 0 : printCache.set(ast, result);
  }
  return result;
};
var isArray = Array.isArray;
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
var TYPENAME_FIELD = {
  kind: Kind.FIELD,
  name: {
    kind: Kind.NAME,
    value: "__typename"
  }
};
function isEmpty(op, fragmentMap) {
  return !op || op.selectionSet.selections.every(function(selection) {
    return selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);
  });
}
function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}
function getDirectiveMatcher(configs) {
  var names2 = /* @__PURE__ */ new Map();
  var tests = /* @__PURE__ */ new Map();
  configs.forEach(function(directive) {
    if (directive) {
      if (directive.name) {
        names2.set(directive.name, directive);
      } else if (directive.test) {
        tests.set(directive.test, directive);
      }
    }
  });
  return function(directive) {
    var config2 = names2.get(directive.name.value);
    if (!config2 && tests.size) {
      tests.forEach(function(testConfig, test2) {
        if (test2(directive)) {
          config2 = testConfig;
        }
      });
    }
    return config2;
  };
}
function makeInUseGetterFunction(defaultKey) {
  var map2 = /* @__PURE__ */ new Map();
  return function inUseGetterFunction(key) {
    if (key === void 0) {
      key = defaultKey;
    }
    var inUse = map2.get(key);
    if (!inUse) {
      map2.set(key, inUse = {
        // Variable and fragment spread names used directly within this
        // operation or fragment definition, as identified by key. These sets
        // will be populated during the first traversal of the document in
        // removeDirectivesFromDocument below.
        variables: /* @__PURE__ */ new Set(),
        fragmentSpreads: /* @__PURE__ */ new Set()
      });
    }
    return inUse;
  };
}
function removeDirectivesFromDocument(directives, doc) {
  checkDocument(doc);
  var getInUseByOperationName = makeInUseGetterFunction("");
  var getInUseByFragmentName = makeInUseGetterFunction("");
  var getInUse = function(ancestors) {
    for (var p2 = 0, ancestor = void 0; p2 < ancestors.length && (ancestor = ancestors[p2]); ++p2) {
      if (isArray(ancestor))
        continue;
      if (ancestor.kind === Kind.OPERATION_DEFINITION) {
        return getInUseByOperationName(ancestor.name && ancestor.name.value);
      }
      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {
        return getInUseByFragmentName(ancestor.name.value);
      }
    }
    globalThis.__DEV__ !== false && invariant$2.error(82);
    return null;
  };
  var operationCount = 0;
  for (var i2 = doc.definitions.length - 1; i2 >= 0; --i2) {
    if (doc.definitions[i2].kind === Kind.OPERATION_DEFINITION) {
      ++operationCount;
    }
  }
  var directiveMatcher = getDirectiveMatcher(directives);
  var shouldRemoveField = function(nodeDirectives) {
    return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config2) {
      return config2 && config2.remove;
    });
  };
  var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
  var firstVisitMadeChanges = false;
  var fieldOrInlineFragmentVisitor = {
    enter: function(node2) {
      if (shouldRemoveField(node2.directives)) {
        firstVisitMadeChanges = true;
        return null;
      }
    }
  };
  var docWithoutDirectiveSubtrees = visit(doc, {
    // These two AST node types share the same implementation, defined above.
    Field: fieldOrInlineFragmentVisitor,
    InlineFragment: fieldOrInlineFragmentVisitor,
    VariableDefinition: {
      enter: function() {
        return false;
      }
    },
    Variable: {
      enter: function(node2, _key, _parent, _path, ancestors) {
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.variables.add(node2.name.value);
        }
      }
    },
    FragmentSpread: {
      enter: function(node2, _key, _parent, _path, ancestors) {
        if (shouldRemoveField(node2.directives)) {
          firstVisitMadeChanges = true;
          return null;
        }
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.fragmentSpreads.add(node2.name.value);
        }
      }
    },
    FragmentDefinition: {
      enter: function(node2, _key, _parent, path) {
        originalFragmentDefsByPath.set(JSON.stringify(path), node2);
      },
      leave: function(node2, _key, _parent, path) {
        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
        if (node2 === originalNode) {
          return node2;
        }
        if (
          // This logic applies only if the document contains one or more
          // operations, since removing all fragments from a document containing
          // only fragments makes the document useless.
          operationCount > 0 && node2.selectionSet.selections.every(function(selection) {
            return selection.kind === Kind.FIELD && selection.name.value === "__typename";
          })
        ) {
          getInUseByFragmentName(node2.name.value).removed = true;
          firstVisitMadeChanges = true;
          return null;
        }
      }
    },
    Directive: {
      leave: function(node2) {
        if (directiveMatcher(node2)) {
          firstVisitMadeChanges = true;
          return null;
        }
      }
    }
  });
  if (!firstVisitMadeChanges) {
    return doc;
  }
  var populateTransitiveVars = function(inUse) {
    if (!inUse.transitiveVars) {
      inUse.transitiveVars = new Set(inUse.variables);
      if (!inUse.removed) {
        inUse.fragmentSpreads.forEach(function(childFragmentName) {
          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
            inUse.transitiveVars.add(varName);
          });
        });
      }
    }
    return inUse;
  };
  var allFragmentNamesUsed = /* @__PURE__ */ new Set();
  docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
    if (def.kind === Kind.OPERATION_DEFINITION) {
      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
        allFragmentNamesUsed.add(childFragmentName);
      });
    } else if (def.kind === Kind.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
    // definitions count as usages of their own fragment names. This heuristic
    // prevents accidentally removing all fragment definitions from the
    // document just because it contains no operations that use the fragments.
    operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
      allFragmentNamesUsed.add(def.name.value);
    }
  });
  allFragmentNamesUsed.forEach(function(fragmentName) {
    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
      allFragmentNamesUsed.add(childFragmentName);
    });
  });
  var fragmentWillBeRemoved = function(fragmentName) {
    return !!// A fragment definition will be removed if there are no spreads that refer
    // to it, or the fragment was explicitly removed because it had no fields
    // other than __typename.
    (!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
  };
  var enterVisitor = {
    enter: function(node2) {
      if (fragmentWillBeRemoved(node2.name.value)) {
        return null;
      }
    }
  };
  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {
    // If the fragment is going to be removed, then leaving any dangling
    // FragmentSpread nodes with the same name would be a mistake.
    FragmentSpread: enterVisitor,
    // This is where the fragment definition is actually removed.
    FragmentDefinition: enterVisitor,
    OperationDefinition: {
      leave: function(node2) {
        if (node2.variableDefinitions) {
          var usedVariableNames_1 = populateTransitiveVars(
            // If an operation is anonymous, we use the empty string as its key.
            getInUseByOperationName(node2.name && node2.name.value)
          ).transitiveVars;
          if (usedVariableNames_1.size < node2.variableDefinitions.length) {
            return __assign$2(__assign$2({}, node2), { variableDefinitions: node2.variableDefinitions.filter(function(varDef) {
              return usedVariableNames_1.has(varDef.variable.name.value);
            }) });
          }
        }
      }
    }
  }));
}
var addTypenameToDocument = Object.assign(function(doc) {
  return visit(doc, {
    SelectionSet: {
      enter: function(node2, _key, parent) {
        if (parent && parent.kind === Kind.OPERATION_DEFINITION) {
          return;
        }
        var selections = node2.selections;
        if (!selections) {
          return;
        }
        var skip2 = selections.some(function(selection) {
          return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
        });
        if (skip2) {
          return;
        }
        var field = parent;
        if (isField(field) && field.directives && field.directives.some(function(d2) {
          return d2.name.value === "export";
        })) {
          return;
        }
        return __assign$2(__assign$2({}, node2), { selections: __spreadArray$1(__spreadArray$1([], selections, true), [TYPENAME_FIELD], false) });
      }
    }
  });
}, {
  added: function(field) {
    return field === TYPENAME_FIELD;
  }
});
function buildQueryFromSelectionSet(document2) {
  var definition = getMainDefinition(document2);
  var definitionOperation = definition.operation;
  if (definitionOperation === "query") {
    return document2;
  }
  var modifiedDoc = visit(document2, {
    OperationDefinition: {
      enter: function(node2) {
        return __assign$2(__assign$2({}, node2), { operation: "query" });
      }
    }
  });
  return modifiedDoc;
}
function removeClientSetsFromDocument(document2) {
  checkDocument(document2);
  var modifiedDoc = removeDirectivesFromDocument([
    {
      test: function(directive) {
        return directive.name.value === "client";
      },
      remove: true
    }
  ], document2);
  return modifiedDoc;
}
var hasOwnProperty$7 = Object.prototype.hasOwnProperty;
function mergeDeep() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count = sources.length;
  if (count > 1) {
    var merger = new DeepMerger();
    for (var i2 = 1; i2 < count; ++i2) {
      target = merger.merge(target, sources[i2]);
    }
  }
  return target;
}
var defaultReconciler = function(target, source, property) {
  return this.merge(target[property], source[property]);
};
var DeepMerger = (
  /** @class */
  function() {
    function DeepMerger2(reconciler) {
      if (reconciler === void 0) {
        reconciler = defaultReconciler;
      }
      this.reconciler = reconciler;
      this.isObject = isNonNullObject;
      this.pastCopies = /* @__PURE__ */ new Set();
    }
    DeepMerger2.prototype.merge = function(target, source) {
      var _this = this;
      var context = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        context[_i - 2] = arguments[_i];
      }
      if (isNonNullObject(source) && isNonNullObject(target)) {
        Object.keys(source).forEach(function(sourceKey) {
          if (hasOwnProperty$7.call(target, sourceKey)) {
            var targetValue = target[sourceKey];
            if (source[sourceKey] !== targetValue) {
              var result = _this.reconciler.apply(_this, __spreadArray$1([
                target,
                source,
                sourceKey
              ], context, false));
              if (result !== targetValue) {
                target = _this.shallowCopyForMerge(target);
                target[sourceKey] = result;
              }
            }
          } else {
            target = _this.shallowCopyForMerge(target);
            target[sourceKey] = source[sourceKey];
          }
        });
        return target;
      }
      return source;
    };
    DeepMerger2.prototype.shallowCopyForMerge = function(value) {
      if (isNonNullObject(value)) {
        if (!this.pastCopies.has(value)) {
          if (Array.isArray(value)) {
            value = value.slice(0);
          } else {
            value = __assign$2({ __proto__: Object.getPrototypeOf(value) }, value);
          }
          this.pastCopies.add(value);
        }
      }
      return value;
    };
    return DeepMerger2;
  }()
);
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i2 = 0;
    return function() {
      if (i2 >= o.length)
        return { done: true };
      return { done: false, value: o[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var hasSymbols = function() {
  return typeof Symbol === "function";
};
var hasSymbol = function(name2) {
  return hasSymbols() && Boolean(Symbol[name2]);
};
var getSymbol = function(name2) {
  return hasSymbol(name2) ? Symbol[name2] : "@@" + name2;
};
if (hasSymbols() && !hasSymbol("observable")) {
  Symbol.observable = Symbol("observable");
}
var SymbolIterator = getSymbol("iterator");
var SymbolObservable = getSymbol("observable");
var SymbolSpecies = getSymbol("species");
function getMethod(obj, key) {
  var value = obj[key];
  if (value == null)
    return void 0;
  if (typeof value !== "function")
    throw new TypeError(value + " is not a function");
  return value;
}
function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable;
}
function isObservable(x2) {
  return x2 instanceof Observable;
}
function hostReportError(e2) {
  if (hostReportError.log) {
    hostReportError.log(e2);
  } else {
    setTimeout(function() {
      throw e2;
    });
  }
}
function enqueue(fn) {
  Promise.resolve().then(function() {
    try {
      fn();
    } catch (e2) {
      hostReportError(e2);
    }
  });
}
function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === void 0)
    return;
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, "unsubscribe");
      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e2) {
    hostReportError(e2);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  var queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (var i2 = 0; i2 < queue.length; ++i2) {
    notifySubscription(subscription, queue[i2].type, queue[i2].value);
    if (subscription._state === "closed")
      break;
  }
}
function notifySubscription(subscription, type, value) {
  subscription._state = "running";
  var observer = subscription._observer;
  try {
    var m2 = getMethod(observer, type);
    switch (type) {
      case "next":
        if (m2)
          m2.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m2)
          m2.call(observer, value);
        else
          throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m2)
          m2.call(observer);
        break;
    }
  } catch (e2) {
    hostReportError(e2);
  }
  if (subscription._state === "closed")
    cleanupSubscription(subscription);
  else if (subscription._state === "running")
    subscription._state = "ready";
}
function onNotify(subscription, type, value) {
  if (subscription._state === "closed")
    return;
  if (subscription._state === "buffering") {
    subscription._queue.push({
      type,
      value
    });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{
      type,
      value
    }];
    enqueue(function() {
      return flushSubscription(subscription);
    });
    return;
  }
  notifySubscription(subscription, type, value);
}
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(observer, subscriber) {
    this._cleanup = void 0;
    this._observer = observer;
    this._queue = void 0;
    this._state = "initializing";
    var subscriptionObserver = new SubscriptionObserver(this);
    try {
      this._cleanup = subscriber.call(void 0, subscriptionObserver);
    } catch (e2) {
      subscriptionObserver.error(e2);
    }
    if (this._state === "initializing")
      this._state = "ready";
  }
  var _proto = Subscription2.prototype;
  _proto.unsubscribe = function unsubscribe() {
    if (this._state !== "closed") {
      closeSubscription(this);
      cleanupSubscription(this);
    }
  };
  _createClass(Subscription2, [{
    key: "closed",
    get: function() {
      return this._state === "closed";
    }
  }]);
  return Subscription2;
}();
var SubscriptionObserver = /* @__PURE__ */ function() {
  function SubscriptionObserver2(subscription) {
    this._subscription = subscription;
  }
  var _proto2 = SubscriptionObserver2.prototype;
  _proto2.next = function next(value) {
    onNotify(this._subscription, "next", value);
  };
  _proto2.error = function error(value) {
    onNotify(this._subscription, "error", value);
  };
  _proto2.complete = function complete() {
    onNotify(this._subscription, "complete");
  };
  _createClass(SubscriptionObserver2, [{
    key: "closed",
    get: function() {
      return this._subscription._state === "closed";
    }
  }]);
  return SubscriptionObserver2;
}();
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscriber) {
    if (!(this instanceof Observable2))
      throw new TypeError("Observable cannot be called as a function");
    if (typeof subscriber !== "function")
      throw new TypeError("Observable initializer must be a function");
    this._subscriber = subscriber;
  }
  var _proto3 = Observable2.prototype;
  _proto3.subscribe = function subscribe(observer) {
    if (typeof observer !== "object" || observer === null) {
      observer = {
        next: observer,
        error: arguments[1],
        complete: arguments[2]
      };
    }
    return new Subscription(observer, this._subscriber);
  };
  _proto3.forEach = function forEach2(fn) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      if (typeof fn !== "function") {
        reject(new TypeError(fn + " is not a function"));
        return;
      }
      function done() {
        subscription.unsubscribe();
        resolve();
      }
      var subscription = _this.subscribe({
        next: function(value) {
          try {
            fn(value, done);
          } catch (e2) {
            reject(e2);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  };
  _proto3.map = function map2(fn) {
    var _this2 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      return _this2.subscribe({
        next: function(value) {
          try {
            value = fn(value);
          } catch (e2) {
            return observer.error(e2);
          }
          observer.next(value);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.filter = function filter2(fn) {
    var _this3 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      return _this3.subscribe({
        next: function(value) {
          try {
            if (!fn(value))
              return;
          } catch (e2) {
            return observer.error(e2);
          }
          observer.next(value);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.reduce = function reduce2(fn) {
    var _this4 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C2 = getSpecies(this);
    var hasSeed = arguments.length > 1;
    var hasValue = false;
    var seed = arguments[1];
    var acc = seed;
    return new C2(function(observer) {
      return _this4.subscribe({
        next: function(value) {
          var first = !hasValue;
          hasValue = true;
          if (!first || hasSeed) {
            try {
              acc = fn(acc, value);
            } catch (e2) {
              return observer.error(e2);
            }
          } else {
            acc = value;
          }
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          if (!hasValue && !hasSeed)
            return observer.error(new TypeError("Cannot reduce an empty sequence"));
          observer.next(acc);
          observer.complete();
        }
      });
    });
  };
  _proto3.concat = function concat2() {
    var _this5 = this;
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      var subscription;
      var index2 = 0;
      function startNext(next) {
        subscription = next.subscribe({
          next: function(v2) {
            observer.next(v2);
          },
          error: function(e2) {
            observer.error(e2);
          },
          complete: function() {
            if (index2 === sources.length) {
              subscription = void 0;
              observer.complete();
            } else {
              startNext(C2.from(sources[index2++]));
            }
          }
        });
      }
      startNext(_this5);
      return function() {
        if (subscription) {
          subscription.unsubscribe();
          subscription = void 0;
        }
      };
    });
  };
  _proto3.flatMap = function flatMap(fn) {
    var _this6 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      var subscriptions = [];
      var outer = _this6.subscribe({
        next: function(value) {
          if (fn) {
            try {
              value = fn(value);
            } catch (e2) {
              return observer.error(e2);
            }
          }
          var inner = C2.from(value).subscribe({
            next: function(value2) {
              observer.next(value2);
            },
            error: function(e2) {
              observer.error(e2);
            },
            complete: function() {
              var i2 = subscriptions.indexOf(inner);
              if (i2 >= 0)
                subscriptions.splice(i2, 1);
              completeIfDone();
            }
          });
          subscriptions.push(inner);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          completeIfDone();
        }
      });
      function completeIfDone() {
        if (outer.closed && subscriptions.length === 0)
          observer.complete();
      }
      return function() {
        subscriptions.forEach(function(s) {
          return s.unsubscribe();
        });
        outer.unsubscribe();
      };
    });
  };
  _proto3[SymbolObservable] = function() {
    return this;
  };
  Observable2.from = function from2(x2) {
    var C2 = typeof this === "function" ? this : Observable2;
    if (x2 == null)
      throw new TypeError(x2 + " is not an object");
    var method = getMethod(x2, SymbolObservable);
    if (method) {
      var observable = method.call(x2);
      if (Object(observable) !== observable)
        throw new TypeError(observable + " is not an object");
      if (isObservable(observable) && observable.constructor === C2)
        return observable;
      return new C2(function(observer) {
        return observable.subscribe(observer);
      });
    }
    if (hasSymbol("iterator")) {
      method = getMethod(x2, SymbolIterator);
      if (method) {
        return new C2(function(observer) {
          enqueue(function() {
            if (observer.closed)
              return;
            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x2)), _step; !(_step = _iterator()).done; ) {
              var item = _step.value;
              observer.next(item);
              if (observer.closed)
                return;
            }
            observer.complete();
          });
        });
      }
    }
    if (Array.isArray(x2)) {
      return new C2(function(observer) {
        enqueue(function() {
          if (observer.closed)
            return;
          for (var i2 = 0; i2 < x2.length; ++i2) {
            observer.next(x2[i2]);
            if (observer.closed)
              return;
          }
          observer.complete();
        });
      });
    }
    throw new TypeError(x2 + " is not observable");
  };
  Observable2.of = function of2() {
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    var C2 = typeof this === "function" ? this : Observable2;
    return new C2(function(observer) {
      enqueue(function() {
        if (observer.closed)
          return;
        for (var i2 = 0; i2 < items.length; ++i2) {
          observer.next(items[i2]);
          if (observer.closed)
            return;
        }
        observer.complete();
      });
    });
  };
  _createClass(Observable2, null, [{
    key: SymbolSpecies,
    get: function() {
      return this;
    }
  }]);
  return Observable2;
}();
if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol("extensions"), {
    value: {
      symbol: SymbolObservable,
      hostReportError
    },
    configurable: true
  });
}
function symbolObservablePonyfill(root2) {
  var result;
  var Symbol2 = root2.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result = Symbol2.observable;
    } else {
      if (typeof Symbol2.for === "function") {
        result = Symbol2.for("https://github.com/benlesh/symbol-observable");
      } else {
        result = Symbol2("https://github.com/benlesh/symbol-observable");
      }
      try {
        Symbol2.observable = result;
      } catch (err) {
      }
    }
  } else {
    result = "@@observable";
  }
  return result;
}
var root;
if (typeof self !== "undefined") {
  root = self;
} else if (typeof window !== "undefined") {
  root = window;
} else if (typeof global !== "undefined") {
  root = global;
} else if (typeof module !== "undefined") {
  root = module;
} else {
  root = Function("return this")();
}
symbolObservablePonyfill(root);
var prototype = Observable.prototype;
var fakeObsSymbol = "@@observable";
if (!prototype[fakeObsSymbol]) {
  prototype[fakeObsSymbol] = function() {
    return this;
  };
}
var toString$4 = Object.prototype.toString;
function cloneDeep(value) {
  return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen2) {
  switch (toString$4.call(val)) {
    case "[object Array]": {
      seen2 = seen2 || /* @__PURE__ */ new Map();
      if (seen2.has(val))
        return seen2.get(val);
      var copy_1 = val.slice(0);
      seen2.set(val, copy_1);
      copy_1.forEach(function(child, i2) {
        copy_1[i2] = cloneDeepHelper(child, seen2);
      });
      return copy_1;
    }
    case "[object Object]": {
      seen2 = seen2 || /* @__PURE__ */ new Map();
      if (seen2.has(val))
        return seen2.get(val);
      var copy_2 = Object.create(Object.getPrototypeOf(val));
      seen2.set(val, copy_2);
      Object.keys(val).forEach(function(key) {
        copy_2[key] = cloneDeepHelper(val[key], seen2);
      });
      return copy_2;
    }
    default:
      return val;
  }
}
function deepFreeze(value) {
  var workSet = /* @__PURE__ */ new Set([value]);
  workSet.forEach(function(obj) {
    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
      Object.getOwnPropertyNames(obj).forEach(function(name2) {
        if (isNonNullObject(obj[name2]))
          workSet.add(obj[name2]);
      });
    }
  });
  return value;
}
function shallowFreeze(obj) {
  if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
    try {
      Object.freeze(obj);
    } catch (e2) {
      if (e2 instanceof TypeError)
        return null;
      throw e2;
    }
  }
  return obj;
}
function maybeDeepFreeze(obj) {
  if (globalThis.__DEV__ !== false) {
    deepFreeze(obj);
  }
  return obj;
}
function iterateObserversSafely(observers2, method, argument) {
  var observersWithMethod = [];
  observers2.forEach(function(obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method](argument);
  });
}
function asyncMap(observable, mapFn, catchFn) {
  return new Observable(function(observer) {
    var promiseQueue = {
      // Normally we would initialize promiseQueue to Promise.resolve(), but
      // in this case, for backwards compatibility, we need to be careful to
      // invoke the first callback synchronously.
      then: function(callback) {
        return new Promise(function(resolve) {
          return resolve(callback());
        });
      }
    };
    function makeCallback(examiner, key) {
      return function(arg) {
        if (examiner) {
          var both = function() {
            return observer.closed ? (
              /* will be swallowed */
              0
            ) : examiner(arg);
          };
          promiseQueue = promiseQueue.then(both, both).then(function(result) {
            return observer.next(result);
          }, function(error) {
            return observer.error(error);
          });
        } else {
          observer[key](arg);
        }
      };
    }
    var handler = {
      next: makeCallback(mapFn, "next"),
      error: makeCallback(catchFn, "error"),
      complete: function() {
        promiseQueue.then(function() {
          return observer.complete();
        });
      }
    };
    var sub = observable.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}
function fixObservableSubclass(subclass) {
  function set(key) {
    Object.defineProperty(subclass, key, { value: Observable });
  }
  if (canUseSymbol && Symbol.species) {
    set(Symbol.species);
  }
  set("@@species");
  return subclass;
}
function isPromiseLike(value) {
  return value && typeof value.then === "function";
}
var Concast = (
  /** @class */
  function(_super) {
    __extends$1(Concast2, _super);
    function Concast2(sources) {
      var _this = _super.call(this, function(observer) {
        _this.addObserver(observer);
        return function() {
          return _this.removeObserver(observer);
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
      _this.handlers = {
        next: function(result) {
          if (_this.sub !== null) {
            _this.latest = ["next", result];
            _this.notify("next", result);
            iterateObserversSafely(_this.observers, "next", result);
          }
        },
        error: function(error) {
          var sub = _this.sub;
          if (sub !== null) {
            if (sub)
              setTimeout(function() {
                return sub.unsubscribe();
              });
            _this.sub = null;
            _this.latest = ["error", error];
            _this.reject(error);
            _this.notify("error", error);
            iterateObserversSafely(_this.observers, "error", error);
          }
        },
        complete: function() {
          var _a2 = _this, sub = _a2.sub, _b = _a2.sources, sources2 = _b === void 0 ? [] : _b;
          if (sub !== null) {
            var value = sources2.shift();
            if (!value) {
              if (sub)
                setTimeout(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              if (_this.latest && _this.latest[0] === "next") {
                _this.resolve(_this.latest[1]);
              } else {
                _this.resolve();
              }
              _this.notify("complete");
              iterateObserversSafely(_this.observers, "complete");
            } else if (isPromiseLike(value)) {
              value.then(function(obs) {
                return _this.sub = obs.subscribe(_this.handlers);
              });
            } else {
              _this.sub = value.subscribe(_this.handlers);
            }
          }
        }
      };
      _this.nextResultListeners = /* @__PURE__ */ new Set();
      _this.cancel = function(reason) {
        _this.reject(reason);
        _this.sources = [];
        _this.handlers.complete();
      };
      _this.promise.catch(function(_2) {
      });
      if (typeof sources === "function") {
        sources = [new Observable(sources)];
      }
      if (isPromiseLike(sources)) {
        sources.then(function(iterable) {
          return _this.start(iterable);
        }, _this.handlers.error);
      } else {
        _this.start(sources);
      }
      return _this;
    }
    Concast2.prototype.start = function(sources) {
      if (this.sub !== void 0)
        return;
      this.sources = Array.from(sources);
      this.handlers.complete();
    };
    Concast2.prototype.deliverLastMessage = function(observer) {
      if (this.latest) {
        var nextOrError = this.latest[0];
        var method = observer[nextOrError];
        if (method) {
          method.call(observer, this.latest[1]);
        }
        if (this.sub === null && nextOrError === "next" && observer.complete) {
          observer.complete();
        }
      }
    };
    Concast2.prototype.addObserver = function(observer) {
      if (!this.observers.has(observer)) {
        this.deliverLastMessage(observer);
        this.observers.add(observer);
      }
    };
    Concast2.prototype.removeObserver = function(observer) {
      if (this.observers.delete(observer) && this.observers.size < 1) {
        this.handlers.complete();
      }
    };
    Concast2.prototype.notify = function(method, arg) {
      var nextResultListeners = this.nextResultListeners;
      if (nextResultListeners.size) {
        this.nextResultListeners = /* @__PURE__ */ new Set();
        nextResultListeners.forEach(function(listener) {
          return listener(method, arg);
        });
      }
    };
    Concast2.prototype.beforeNext = function(callback) {
      var called = false;
      this.nextResultListeners.add(function(method, arg) {
        if (!called) {
          called = true;
          callback(method, arg);
        }
      });
    };
    return Concast2;
  }(Observable)
);
fixObservableSubclass(Concast);
function isExecutionPatchIncrementalResult(value) {
  return "incremental" in value;
}
function isExecutionPatchInitialResult(value) {
  return "hasNext" in value && "data" in value;
}
function isExecutionPatchResult(value) {
  return isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value);
}
function isApolloPayloadResult(value) {
  return isNonNullObject(value) && "payload" in value;
}
function mergeIncrementalData(prevResult, result) {
  var mergedData = prevResult;
  var merger = new DeepMerger();
  if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
    result.incremental.forEach(function(_a2) {
      var data2 = _a2.data, path = _a2.path;
      for (var i2 = path.length - 1; i2 >= 0; --i2) {
        var key = path[i2];
        var isNumericKey = !isNaN(+key);
        var parent_1 = isNumericKey ? [] : {};
        parent_1[key] = data2;
        data2 = parent_1;
      }
      mergedData = merger.merge(mergedData, data2);
    });
  }
  return mergedData;
}
function graphQLResultHasError(result) {
  var errors2 = getGraphQLErrorsFromResult(result);
  return isNonEmptyArray(errors2);
}
function getGraphQLErrorsFromResult(result) {
  var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
  if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
    result.incremental.forEach(function(incrementalResult) {
      if (incrementalResult.errors) {
        graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
      }
    });
  }
  return graphQLErrors;
}
function compact() {
  var objects = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    objects[_i] = arguments[_i];
  }
  var result = /* @__PURE__ */ Object.create(null);
  objects.forEach(function(obj) {
    if (!obj)
      return;
    Object.keys(obj).forEach(function(key) {
      var value = obj[key];
      if (value !== void 0) {
        result[key] = value;
      }
    });
  });
  return result;
}
function mergeOptions$2(defaults2, options) {
  return compact(defaults2, options, options.variables && {
    variables: compact(__assign$2(__assign$2({}, defaults2 && defaults2.variables), options.variables))
  });
}
function fromError(errorValue) {
  return new Observable(function(observer) {
    observer.error(errorValue);
  });
}
var throwServerError = function(response, result, message) {
  var error = new Error(message);
  error.name = "ServerError";
  error.response = response;
  error.statusCode = response.status;
  error.result = result;
  throw error;
};
function validateOperation(operation) {
  var OPERATION_FIELDS = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ];
  for (var _i = 0, _a2 = Object.keys(operation); _i < _a2.length; _i++) {
    var key = _a2[_i];
    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw newInvariantError(43, key);
    }
  }
  return operation;
}
function createOperation(starting, operation) {
  var context = __assign$2({}, starting);
  var setContext = function(next) {
    if (typeof next === "function") {
      context = __assign$2(__assign$2({}, context), next(context));
    } else {
      context = __assign$2(__assign$2({}, context), next);
    }
  };
  var getContext = function() {
    return __assign$2({}, context);
  };
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext
  });
  return operation;
}
function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };
  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
  }
  return transformedOperation;
}
function filterOperationVariables(variables, query) {
  var result = __assign$2({}, variables);
  var unusedNames = new Set(Object.keys(variables));
  visit(query, {
    Variable: function(node2, _key, parent) {
      if (parent && parent.kind !== "VariableDefinition") {
        unusedNames.delete(node2.name.value);
      }
    }
  });
  unusedNames.forEach(function(name2) {
    delete result[name2];
  });
  return result;
}
function passthrough(op, forward) {
  return forward ? forward(op) : Observable.of();
}
function toLink(handler) {
  return typeof handler === "function" ? new ApolloLink(handler) : handler;
}
function isTerminating(link) {
  return link.request.length <= 1;
}
var ApolloLink = (
  /** @class */
  function() {
    function ApolloLink2(request2) {
      if (request2)
        this.request = request2;
    }
    ApolloLink2.empty = function() {
      return new ApolloLink2(function() {
        return Observable.of();
      });
    };
    ApolloLink2.from = function(links2) {
      if (links2.length === 0)
        return ApolloLink2.empty();
      return links2.map(toLink).reduce(function(x2, y2) {
        return x2.concat(y2);
      });
    };
    ApolloLink2.split = function(test2, left, right) {
      var leftLink = toLink(left);
      var rightLink = toLink(right || new ApolloLink2(passthrough));
      if (isTerminating(leftLink) && isTerminating(rightLink)) {
        return new ApolloLink2(function(operation) {
          return test2(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
        });
      } else {
        return new ApolloLink2(function(operation, forward) {
          return test2(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
        });
      }
    };
    ApolloLink2.execute = function(link, operation) {
      return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();
    };
    ApolloLink2.concat = function(first, second) {
      var firstLink = toLink(first);
      if (isTerminating(firstLink)) {
        globalThis.__DEV__ !== false && invariant$2.warn(35, firstLink);
        return firstLink;
      }
      var nextLink = toLink(second);
      if (isTerminating(nextLink)) {
        return new ApolloLink2(function(operation) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op) || Observable.of();
          }) || Observable.of();
        });
      } else {
        return new ApolloLink2(function(operation, forward) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op, forward) || Observable.of();
          }) || Observable.of();
        });
      }
    };
    ApolloLink2.prototype.split = function(test2, left, right) {
      return this.concat(ApolloLink2.split(test2, left, right || new ApolloLink2(passthrough)));
    };
    ApolloLink2.prototype.concat = function(next) {
      return ApolloLink2.concat(this, next);
    };
    ApolloLink2.prototype.request = function(operation, forward) {
      throw newInvariantError(36);
    };
    ApolloLink2.prototype.onError = function(error, observer) {
      if (observer && observer.error) {
        observer.error(error);
        return false;
      }
      throw error;
    };
    ApolloLink2.prototype.setOnError = function(fn) {
      this.onError = fn;
      return this;
    };
    return ApolloLink2;
  }()
);
var execute = ApolloLink.execute;
function asyncIterator(source) {
  var _a2;
  var iterator = source[Symbol.asyncIterator]();
  return _a2 = {
    next: function() {
      return iterator.next();
    }
  }, _a2[Symbol.asyncIterator] = function() {
    return this;
  }, _a2;
}
function nodeStreamIterator(stream2) {
  var cleanup = null;
  var error = null;
  var done = false;
  var data2 = [];
  var waiting = [];
  function onData(chunk) {
    if (error)
      return;
    if (waiting.length) {
      var shiftedArr = waiting.shift();
      if (Array.isArray(shiftedArr) && shiftedArr[0]) {
        return shiftedArr[0]({ value: chunk, done: false });
      }
    }
    data2.push(chunk);
  }
  function onError(err) {
    error = err;
    var all2 = waiting.slice();
    all2.forEach(function(pair) {
      pair[1](err);
    });
    !cleanup || cleanup();
  }
  function onEnd() {
    done = true;
    var all2 = waiting.slice();
    all2.forEach(function(pair) {
      pair[0]({ value: void 0, done: true });
    });
    !cleanup || cleanup();
  }
  cleanup = function() {
    cleanup = null;
    stream2.removeListener("data", onData);
    stream2.removeListener("error", onError);
    stream2.removeListener("end", onEnd);
    stream2.removeListener("finish", onEnd);
    stream2.removeListener("close", onEnd);
  };
  stream2.on("data", onData);
  stream2.on("error", onError);
  stream2.on("end", onEnd);
  stream2.on("finish", onEnd);
  stream2.on("close", onEnd);
  function getNext() {
    return new Promise(function(resolve, reject) {
      if (error)
        return reject(error);
      if (data2.length)
        return resolve({ value: data2.shift(), done: false });
      if (done)
        return resolve({ value: void 0, done: true });
      waiting.push([resolve, reject]);
    });
  }
  var iterator = {
    next: function() {
      return getNext();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function promiseIterator(promise) {
  var resolved = false;
  var iterator = {
    next: function() {
      if (resolved)
        return Promise.resolve({
          value: void 0,
          done: true
        });
      resolved = true;
      return new Promise(function(resolve, reject) {
        promise.then(function(value) {
          resolve({ value, done: false });
        }).catch(reject);
      });
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function readerIterator(reader2) {
  var iterator = {
    next: function() {
      return reader2.read();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function isNodeResponse(value) {
  return !!value.body;
}
function isReadableStream$1(value) {
  return !!value.getReader;
}
function isAsyncIterableIterator(value) {
  return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
}
function isStreamableBlob(value) {
  return !!value.stream;
}
function isBlob$3(value) {
  return !!value.arrayBuffer;
}
function isNodeReadableStream(value) {
  return !!value.pipe;
}
function responseIterator(response) {
  var body = response;
  if (isNodeResponse(response))
    body = response.body;
  if (isAsyncIterableIterator(body))
    return asyncIterator(body);
  if (isReadableStream$1(body))
    return readerIterator(body.getReader());
  if (isStreamableBlob(body)) {
    return readerIterator(body.stream().getReader());
  }
  if (isBlob$3(body))
    return promiseIterator(body.arrayBuffer());
  if (isNodeReadableStream(body))
    return nodeStreamIterator(body);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}
var PROTOCOL_ERRORS_SYMBOL = Symbol();
function graphQLResultHasProtocolErrors(result) {
  if (result.extensions) {
    return Array.isArray(result.extensions[PROTOCOL_ERRORS_SYMBOL]);
  }
  return false;
}
function isApolloError(err) {
  return err.hasOwnProperty("graphQLErrors");
}
var generateErrorMessage = function(err) {
  var errors2 = __spreadArray$1(__spreadArray$1(__spreadArray$1([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);
  if (err.networkError)
    errors2.push(err.networkError);
  return errors2.map(function(err2) {
    return isNonNullObject(err2) && err2.message || "Error message not found.";
  }).join("\n");
};
var ApolloError = (
  /** @class */
  function(_super) {
    __extends$1(ApolloError2, _super);
    function ApolloError2(_a2) {
      var graphQLErrors = _a2.graphQLErrors, protocolErrors = _a2.protocolErrors, clientErrors = _a2.clientErrors, networkError = _a2.networkError, errorMessage = _a2.errorMessage, extraInfo = _a2.extraInfo;
      var _this = _super.call(this, errorMessage) || this;
      _this.name = "ApolloError";
      _this.graphQLErrors = graphQLErrors || [];
      _this.protocolErrors = protocolErrors || [];
      _this.clientErrors = clientErrors || [];
      _this.networkError = networkError || null;
      _this.message = errorMessage || generateErrorMessage(_this);
      _this.extraInfo = extraInfo;
      _this.__proto__ = ApolloError2.prototype;
      return _this;
    }
    return ApolloError2;
  }(Error)
);
var hasOwnProperty$6 = Object.prototype.hasOwnProperty;
function readMultipartBody(response, nextValue) {
  var _a2;
  return __awaiter$2(this, void 0, void 0, function() {
    var decoder, contentType, delimiter, boundaryVal, boundary, buffer2, iterator, running, _b, value, done, chunk, searchFrom, bi2, message, i2, headers, contentType_1, body, result, next;
    var _c, _d;
    return __generator$1(this, function(_e2) {
      switch (_e2.label) {
        case 0:
          if (TextDecoder === void 0) {
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          }
          decoder = new TextDecoder("utf-8");
          contentType = (_a2 = response.headers) === null || _a2 === void 0 ? void 0 : _a2.get("content-type");
          delimiter = "boundary=";
          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
          boundary = "\r\n--".concat(boundaryVal);
          buffer2 = "";
          iterator = responseIterator(response);
          running = true;
          _e2.label = 1;
        case 1:
          if (!running)
            return [3, 3];
          return [4, iterator.next()];
        case 2:
          _b = _e2.sent(), value = _b.value, done = _b.done;
          chunk = typeof value === "string" ? value : decoder.decode(value);
          searchFrom = buffer2.length - boundary.length + 1;
          running = !done;
          buffer2 += chunk;
          bi2 = buffer2.indexOf(boundary, searchFrom);
          while (bi2 > -1) {
            message = void 0;
            _c = [
              buffer2.slice(0, bi2),
              buffer2.slice(bi2 + boundary.length)
            ], message = _c[0], buffer2 = _c[1];
            i2 = message.indexOf("\r\n\r\n");
            headers = parseHeaders(message.slice(0, i2));
            contentType_1 = headers["content-type"];
            if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
              throw new Error("Unsupported patch content type: application/json is required.");
            }
            body = message.slice(i2);
            if (body) {
              result = parseJsonBody(response, body);
              if (Object.keys(result).length > 1 || "data" in result || "incremental" in result || "errors" in result || "payload" in result) {
                if (isApolloPayloadResult(result)) {
                  next = {};
                  if ("payload" in result) {
                    next = __assign$2({}, result.payload);
                  }
                  if ("errors" in result) {
                    next = __assign$2(__assign$2({}, next), { extensions: __assign$2(__assign$2({}, "extensions" in next ? next.extensions : null), (_d = {}, _d[PROTOCOL_ERRORS_SYMBOL] = result.errors, _d)) });
                  }
                  nextValue(next);
                } else {
                  nextValue(result);
                }
              } else if (
                // If the chunk contains only a "hasNext: false", we can call
                // observer.complete() immediately.
                Object.keys(result).length === 1 && "hasNext" in result && !result.hasNext
              ) {
                return [
                  2
                  /*return*/
                ];
              }
            }
            bi2 = buffer2.indexOf(boundary);
          }
          return [3, 1];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function parseHeaders(headerText) {
  var headersInit = {};
  headerText.split("\n").forEach(function(line) {
    var i2 = line.indexOf(":");
    if (i2 > -1) {
      var name_1 = line.slice(0, i2).trim().toLowerCase();
      var value = line.slice(i2 + 1).trim();
      headersInit[name_1] = value;
    }
  });
  return headersInit;
}
function parseJsonBody(response, bodyText) {
  if (response.status >= 300) {
    var getResult = function() {
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        return bodyText;
      }
    };
    throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
  }
  try {
    return JSON.parse(bodyText);
  } catch (err) {
    var parseError = err;
    parseError.name = "ServerParseError";
    parseError.response = response;
    parseError.statusCode = response.status;
    parseError.bodyText = bodyText;
    throw parseError;
  }
}
function handleError(err, observer) {
  if (err.result && err.result.errors && err.result.data) {
    observer.next(err.result);
  }
  observer.error(err);
}
function parseAndCheckHttpResponse(operations) {
  return function(response) {
    return response.text().then(function(bodyText) {
      return parseJsonBody(response, bodyText);
    }).then(function(result) {
      if (!Array.isArray(result) && !hasOwnProperty$6.call(result, "data") && !hasOwnProperty$6.call(result, "errors")) {
        throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
          return op.operationName;
        }) : operations.operationName, "'."));
      }
      return result;
    });
  };
}
var serializeFetchParameter = function(p2, label) {
  var serialized;
  try {
    serialized = JSON.stringify(p2);
  } catch (e2) {
    var parseError = newInvariantError(39, label, e2.message);
    parseError.parseError = e2;
    throw parseError;
  }
  return serialized;
};
var defaultHttpOptions = {
  includeQuery: true,
  includeExtensions: false,
  preserveHeaderCase: false
};
var defaultHeaders = {
  // headers are case insensitive (https://stackoverflow.com/a/5259004)
  accept: "*/*",
  // The content-type header describes the type of the body of the request, and
  // so it typically only is sent with requests that actually have bodies. One
  // could imagine that Apollo Client would remove this header when constructing
  // a GET request (which has no body), but we historically have not done that.
  // This means that browsers will preflight all Apollo Client requests (even
  // GET requests). Apollo Server's CSRF prevention feature (introduced in
  // AS3.7) takes advantage of this fact and does not block requests with this
  // header. If you want to drop this header from GET requests, then you should
  // probably replace it with a `apollo-require-preflight` header, or servers
  // with CSRF prevention enabled might block your GET request. See
  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
  // for more details.
  "content-type": "application/json"
};
var defaultOptions$2 = {
  method: "POST"
};
var fallbackHttpConfig = {
  http: defaultHttpOptions,
  headers: defaultHeaders,
  options: defaultOptions$2
};
var defaultPrinter = function(ast, printer) {
  return printer(ast);
};
function selectHttpOptionsAndBodyInternal(operation, printer) {
  var configs = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    configs[_i - 2] = arguments[_i];
  }
  var options = {};
  var http2 = {};
  configs.forEach(function(config2) {
    options = __assign$2(__assign$2(__assign$2({}, options), config2.options), { headers: __assign$2(__assign$2({}, options.headers), config2.headers) });
    if (config2.credentials) {
      options.credentials = config2.credentials;
    }
    http2 = __assign$2(__assign$2({}, http2), config2.http);
  });
  if (options.headers) {
    options.headers = removeDuplicateHeaders(options.headers, http2.preserveHeaderCase);
  }
  var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
  var body = { operationName, variables };
  if (http2.includeExtensions)
    body.extensions = extensions;
  if (http2.includeQuery)
    body.query = printer(query, print);
  return {
    options,
    body
  };
}
function removeDuplicateHeaders(headers, preserveHeaderCase) {
  if (!preserveHeaderCase) {
    var normalizedHeaders_1 = /* @__PURE__ */ Object.create(null);
    Object.keys(Object(headers)).forEach(function(name2) {
      normalizedHeaders_1[name2.toLowerCase()] = headers[name2];
    });
    return normalizedHeaders_1;
  }
  var headerData = /* @__PURE__ */ Object.create(null);
  Object.keys(Object(headers)).forEach(function(name2) {
    headerData[name2.toLowerCase()] = {
      originalName: name2,
      value: headers[name2]
    };
  });
  var normalizedHeaders = /* @__PURE__ */ Object.create(null);
  Object.keys(headerData).forEach(function(name2) {
    normalizedHeaders[headerData[name2].originalName] = headerData[name2].value;
  });
  return normalizedHeaders;
}
var checkFetcher = function(fetcher) {
  if (!fetcher && typeof fetch === "undefined") {
    throw newInvariantError(37);
  }
};
var selectURI = function(operation, fallbackURI) {
  var context = operation.getContext();
  var contextURI = context.uri;
  if (contextURI) {
    return contextURI;
  } else if (typeof fallbackURI === "function") {
    return fallbackURI(operation);
  } else {
    return fallbackURI || "/graphql";
  }
};
function rewriteURIForGET(chosenURI, body) {
  var queryParams = [];
  var addQueryParam = function(key, value) {
    queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
  };
  if ("query" in body) {
    addQueryParam("query", body.query);
  }
  if (body.operationName) {
    addQueryParam("operationName", body.operationName);
  }
  if (body.variables) {
    var serializedVariables = void 0;
    try {
      serializedVariables = serializeFetchParameter(body.variables, "Variables map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body.extensions) {
    var serializedExtensions = void 0;
    try {
      serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("extensions", serializedExtensions);
  }
  var fragment = "", preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return { newURI };
}
var backupFetch = maybe$1(function() {
  return fetch;
});
var createHttpLink = function(linkOptions) {
  if (linkOptions === void 0) {
    linkOptions = {};
  }
  var _a2 = linkOptions.uri, uri = _a2 === void 0 ? "/graphql" : _a2, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print2 = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest$2(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
  if (globalThis.__DEV__ !== false) {
    checkFetcher(preferredFetch || backupFetch);
  }
  var linkConfig = {
    http: { includeExtensions, preserveHeaderCase },
    options: requestOptions.fetchOptions,
    credentials: requestOptions.credentials,
    headers: requestOptions.headers
  };
  return new ApolloLink(function(operation) {
    var chosenURI = selectURI(operation, uri);
    var context = operation.getContext();
    var clientAwarenessHeaders = {};
    if (context.clientAwareness) {
      var _a3 = context.clientAwareness, name_1 = _a3.name, version2 = _a3.version;
      if (name_1) {
        clientAwarenessHeaders["apollographql-client-name"] = name_1;
      }
      if (version2) {
        clientAwarenessHeaders["apollographql-client-version"] = version2;
      }
    }
    var contextHeaders = __assign$2(__assign$2({}, clientAwarenessHeaders), context.headers);
    var contextConfig = {
      http: context.http,
      options: context.fetchOptions,
      credentials: context.credentials,
      headers: contextHeaders
    };
    if (hasDirectives(["client"], operation.query)) {
      var transformedQuery = removeClientSetsFromDocument(operation.query);
      if (!transformedQuery) {
        return fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
      }
      operation.query = transformedQuery;
    }
    var _b2 = selectHttpOptionsAndBodyInternal(operation, print2, fallbackHttpConfig, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
    if (body.variables && !includeUnusedVariables) {
      body.variables = filterOperationVariables(body.variables, operation.query);
    }
    var controller;
    if (!options.signal && typeof AbortController !== "undefined") {
      controller = new AbortController();
      options.signal = controller.signal;
    }
    var definitionIsMutation = function(d2) {
      return d2.kind === "OperationDefinition" && d2.operation === "mutation";
    };
    var definitionIsSubscription = function(d2) {
      return d2.kind === "OperationDefinition" && d2.operation === "subscription";
    };
    var isSubscription = definitionIsSubscription(getMainDefinition(operation.query));
    var hasDefer = hasDirectives(["defer"], operation.query);
    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
      options.method = "GET";
    }
    if (hasDefer || isSubscription) {
      options.headers = options.headers || {};
      var acceptHeader = "multipart/mixed;";
      if (isSubscription && hasDefer) {
        globalThis.__DEV__ !== false && invariant$2.warn(38);
      }
      if (isSubscription) {
        acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
      } else if (hasDefer) {
        acceptHeader += "deferSpec=20220824,application/json";
      }
      options.headers.accept = acceptHeader;
    }
    if (options.method === "GET") {
      var _c2 = rewriteURIForGET(chosenURI, body), newURI = _c2.newURI, parseError = _c2.parseError;
      if (parseError) {
        return fromError(parseError);
      }
      chosenURI = newURI;
    } else {
      try {
        options.body = serializeFetchParameter(body, "Payload");
      } catch (parseError2) {
        return fromError(parseError2);
      }
    }
    return new Observable(function(observer) {
      var currentFetch = preferredFetch || maybe$1(function() {
        return fetch;
      }) || backupFetch;
      var observerNext = observer.next.bind(observer);
      currentFetch(chosenURI, options).then(function(response) {
        var _a4;
        operation.setContext({ response });
        var ctype = (_a4 = response.headers) === null || _a4 === void 0 ? void 0 : _a4.get("content-type");
        if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
          return readMultipartBody(response, observerNext);
        } else {
          return parseAndCheckHttpResponse(operation)(response).then(observerNext);
        }
      }).then(function() {
        controller = void 0;
        observer.complete();
      }).catch(function(err) {
        controller = void 0;
        handleError(err, observer);
      });
      return function() {
        if (controller)
          controller.abort();
      };
    });
  });
};
var HttpLink = (
  /** @class */
  function(_super) {
    __extends$1(HttpLink2, _super);
    function HttpLink2(options) {
      if (options === void 0) {
        options = {};
      }
      var _this = _super.call(this, createHttpLink(options).request) || this;
      _this.options = options;
      return _this;
    }
    return HttpLink2;
  }(ApolloLink)
);
const { toString: toString$3, hasOwnProperty: hasOwnProperty$5 } = Object.prototype;
const fnToStr = Function.prototype.toString;
const previousComparisons = /* @__PURE__ */ new Map();
function equal$2(a2, b2) {
  try {
    return check(a2, b2);
  } finally {
    previousComparisons.clear();
  }
}
function check(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  const aTag = toString$3.call(a2);
  const bTag = toString$3.call(b2);
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case "[object Array]":
      if (a2.length !== b2.length)
        return false;
    case "[object Object]": {
      if (previouslyCompared(a2, b2))
        return true;
      const aKeys = definedKeys(a2);
      const bKeys = definedKeys(b2);
      const keyCount = aKeys.length;
      if (keyCount !== bKeys.length)
        return false;
      for (let k2 = 0; k2 < keyCount; ++k2) {
        if (!hasOwnProperty$5.call(b2, aKeys[k2])) {
          return false;
        }
      }
      for (let k2 = 0; k2 < keyCount; ++k2) {
        const key = aKeys[k2];
        if (!check(a2[key], b2[key])) {
          return false;
        }
      }
      return true;
    }
    case "[object Error]":
      return a2.name === b2.name && a2.message === b2.message;
    case "[object Number]":
      if (a2 !== a2)
        return b2 !== b2;
    case "[object Boolean]":
    case "[object Date]":
      return +a2 === +b2;
    case "[object RegExp]":
    case "[object String]":
      return a2 == `${b2}`;
    case "[object Map]":
    case "[object Set]": {
      if (a2.size !== b2.size)
        return false;
      if (previouslyCompared(a2, b2))
        return true;
      const aIterator = a2.entries();
      const isMap = aTag === "[object Map]";
      while (true) {
        const info = aIterator.next();
        if (info.done)
          break;
        const [aKey, aValue] = info.value;
        if (!b2.has(aKey)) {
          return false;
        }
        if (isMap && !check(aValue, b2.get(aKey))) {
          return false;
        }
      }
      return true;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      a2 = new Uint8Array(a2);
      b2 = new Uint8Array(b2);
    case "[object DataView]": {
      let len2 = a2.byteLength;
      if (len2 === b2.byteLength) {
        while (len2-- && a2[len2] === b2[len2]) {
        }
      }
      return len2 === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      const aCode = fnToStr.call(a2);
      if (aCode !== fnToStr.call(b2)) {
        return false;
      }
      return !endsWith(aCode, nativeCodeSuffix);
    }
  }
  return false;
}
function definedKeys(obj) {
  return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key) {
  return this[key] !== void 0;
}
const nativeCodeSuffix = "{ [native code] }";
function endsWith(full, suffix) {
  const fromIndex = full.length - suffix.length;
  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a2, b2) {
  let bSet = previousComparisons.get(a2);
  if (bSet) {
    if (bSet.has(b2))
      return true;
  } else {
    previousComparisons.set(a2, bSet = /* @__PURE__ */ new Set());
  }
  bSet.add(b2);
  return false;
}
const defaultMakeData = () => /* @__PURE__ */ Object.create(null);
const { forEach, slice: slice$5 } = Array.prototype;
const { hasOwnProperty: hasOwnProperty$4 } = Object.prototype;
class Trie {
  constructor(weakness = true, makeData = defaultMakeData) {
    this.weakness = weakness;
    this.makeData = makeData;
  }
  lookup(...array) {
    return this.lookupArray(array);
  }
  lookupArray(array) {
    let node2 = this;
    forEach.call(array, (key) => node2 = node2.getChildTrie(key));
    return hasOwnProperty$4.call(node2, "data") ? node2.data : node2.data = this.makeData(slice$5.call(array));
  }
  peek(...array) {
    return this.peekArray(array);
  }
  peekArray(array) {
    let node2 = this;
    for (let i2 = 0, len2 = array.length; node2 && i2 < len2; ++i2) {
      const map2 = this.weakness && isObjRef(array[i2]) ? node2.weak : node2.strong;
      node2 = map2 && map2.get(array[i2]);
    }
    return node2 && node2.data;
  }
  getChildTrie(key) {
    const map2 = this.weakness && isObjRef(key) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
    let child = map2.get(key);
    if (!child)
      map2.set(key, child = new Trie(this.weakness, this.makeData));
    return child;
  }
}
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
function defaultDispose() {
}
class StrongCache {
  constructor(max = Infinity, dispose = defaultDispose) {
    this.max = max;
    this.dispose = dispose;
    this.map = /* @__PURE__ */ new Map();
    this.newest = null;
    this.oldest = null;
  }
  has(key) {
    return this.map.has(key);
  }
  get(key) {
    const node2 = this.getNode(key);
    return node2 && node2.value;
  }
  get size() {
    return this.map.size;
  }
  getNode(key) {
    const node2 = this.map.get(key);
    if (node2 && node2 !== this.newest) {
      const { older, newer } = node2;
      if (newer) {
        newer.older = older;
      }
      if (older) {
        older.newer = newer;
      }
      node2.older = this.newest;
      node2.older.newer = node2;
      node2.newer = null;
      this.newest = node2;
      if (node2 === this.oldest) {
        this.oldest = newer;
      }
    }
    return node2;
  }
  set(key, value) {
    let node2 = this.getNode(key);
    if (node2) {
      return node2.value = value;
    }
    node2 = {
      key,
      value,
      newer: null,
      older: this.newest
    };
    if (this.newest) {
      this.newest.newer = node2;
    }
    this.newest = node2;
    this.oldest = this.oldest || node2;
    this.map.set(key, node2);
    return node2.value;
  }
  clean() {
    while (this.oldest && this.map.size > this.max) {
      this.delete(this.oldest.key);
    }
  }
  delete(key) {
    const node2 = this.map.get(key);
    if (node2) {
      if (node2 === this.newest) {
        this.newest = node2.older;
      }
      if (node2 === this.oldest) {
        this.oldest = node2.newer;
      }
      if (node2.newer) {
        node2.newer.older = node2.older;
      }
      if (node2.older) {
        node2.older.newer = node2.newer;
      }
      this.map.delete(key);
      this.dispose(node2.value, key);
      return true;
    }
    return false;
  }
}
let currentContext = null;
const MISSING_VALUE = {};
let idCounter = 1;
const makeSlotClass = () => class Slot {
  constructor() {
    this.id = [
      "slot",
      idCounter++,
      Date.now(),
      Math.random().toString(36).slice(2)
    ].join(":");
  }
  hasValue() {
    for (let context = currentContext; context; context = context.parent) {
      if (this.id in context.slots) {
        const value = context.slots[this.id];
        if (value === MISSING_VALUE)
          break;
        if (context !== currentContext) {
          currentContext.slots[this.id] = value;
        }
        return true;
      }
    }
    if (currentContext) {
      currentContext.slots[this.id] = MISSING_VALUE;
    }
    return false;
  }
  getValue() {
    if (this.hasValue()) {
      return currentContext.slots[this.id];
    }
  }
  withValue(value, callback, args, thisArg) {
    const slots = {
      __proto__: null,
      [this.id]: value
    };
    const parent = currentContext;
    currentContext = { parent, slots };
    try {
      return callback.apply(thisArg, args);
    } finally {
      currentContext = parent;
    }
  }
  // Capture the current context and wrap a callback function so that it
  // reestablishes the captured context when called.
  static bind(callback) {
    const context = currentContext;
    return function() {
      const saved = currentContext;
      try {
        currentContext = context;
        return callback.apply(this, arguments);
      } finally {
        currentContext = saved;
      }
    };
  }
  // Immediately run a callback function without any captured context.
  static noContext(callback, args, thisArg) {
    if (currentContext) {
      const saved = currentContext;
      try {
        currentContext = null;
        return callback.apply(thisArg, args);
      } finally {
        currentContext = saved;
      }
    } else {
      return callback.apply(thisArg, args);
    }
  }
};
function maybe(fn) {
  try {
    return fn();
  } catch (ignored) {
  }
}
const globalKey = "@wry/context:Slot";
const host = (
  // Prefer globalThis when available.
  // https://github.com/benjamn/wryware/issues/347
  maybe(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some
  // bundlers to the appropriate identifier (window, self, ...) depending on the
  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
  maybe(() => global) || // Otherwise, use a dummy host that's local to this module. We used to fall
  // back to using the Array constructor as a namespace, but that was flagged in
  // https://github.com/benjamn/wryware/issues/347, and can be avoided.
  /* @__PURE__ */ Object.create(null)
);
const globalHost = host;
const Slot = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array
// constructor, so we check there as well, to prevent Slot class duplication.
Array[globalKey] || function(Slot2) {
  try {
    Object.defineProperty(globalHost, globalKey, {
      value: Slot2,
      enumerable: false,
      writable: false,
      // When it was possible for globalHost to be the Array constructor (a
      // legacy Slot dedup strategy), it was important for the property to be
      // configurable:true so it could be deleted. That does not seem to be as
      // important when globalHost is the global object, but I don't want to
      // cause similar problems again, and configurable:true seems safest.
      // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
      configurable: true
    });
  } finally {
    return Slot2;
  }
}(makeSlotClass());
const parentEntrySlot = new Slot();
const { hasOwnProperty: hasOwnProperty$3 } = Object.prototype;
const arrayFromSet = Array.from || function(set) {
  const array = [];
  set.forEach((item) => array.push(item));
  return array;
};
function maybeUnsubscribe(entryOrDep) {
  const { unsubscribe } = entryOrDep;
  if (typeof unsubscribe === "function") {
    entryOrDep.unsubscribe = void 0;
    unsubscribe();
  }
}
const emptySetPool = [];
const POOL_TARGET_SIZE = 100;
function assert$1(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a2, b2) {
  const len2 = a2.length;
  return (
    // Unknown values are not equal to each other.
    len2 > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    len2 === b2.length && // The underlying value or exception must be the same.
    a2[len2 - 1] === b2[len2 - 1]
  );
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
class Entry {
  constructor(fn) {
    this.fn = fn;
    this.parents = /* @__PURE__ */ new Set();
    this.childValues = /* @__PURE__ */ new Map();
    this.dirtyChildren = null;
    this.dirty = true;
    this.recomputing = false;
    this.value = [];
    this.deps = null;
    ++Entry.count;
  }
  peek() {
    if (this.value.length === 1 && !mightBeDirty(this)) {
      rememberParent(this);
      return this.value[0];
    }
  }
  // This is the most important method of the Entry API, because it
  // determines whether the cached this.value can be returned immediately,
  // or must be recomputed. The overall performance of the caching system
  // depends on the truth of the following observations: (1) this.dirty is
  // usually false, (2) this.dirtyChildren is usually null/empty, and thus
  // (3) valueGet(this.value) is usually returned without recomputation.
  recompute(args) {
    assert$1(!this.recomputing, "already recomputing");
    rememberParent(this);
    return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
  }
  setDirty() {
    if (this.dirty)
      return;
    this.dirty = true;
    reportDirty(this);
    maybeUnsubscribe(this);
  }
  dispose() {
    this.setDirty();
    forgetChildren(this);
    eachParent(this, (parent, child) => {
      parent.setDirty();
      forgetChild(parent, this);
    });
  }
  forget() {
    this.dispose();
  }
  dependOn(dep2) {
    dep2.add(this);
    if (!this.deps) {
      this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
    }
    this.deps.add(dep2);
  }
  forgetDeps() {
    if (this.deps) {
      arrayFromSet(this.deps).forEach((dep2) => dep2.delete(this));
      this.deps.clear();
      emptySetPool.push(this.deps);
      this.deps = null;
    }
  }
}
Entry.count = 0;
function rememberParent(child) {
  const parent = parentEntrySlot.getValue();
  if (parent) {
    child.parents.add(parent);
    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }
    return parent;
  }
}
function reallyRecompute(entry, args) {
  forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
  if (maybeSubscribe(entry, args)) {
    setClean(entry);
  }
  return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
  entry.recomputing = true;
  const { normalizeResult } = entry;
  let oldValueCopy;
  if (normalizeResult && entry.value.length === 1) {
    oldValueCopy = valueCopy(entry.value);
  }
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, args);
    if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {
      try {
        entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);
      } catch (_a2) {
      }
    }
  } catch (e2) {
    entry.value[1] = e2;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  eachParent(child, reportDirtyChild);
}
function reportClean(child) {
  eachParent(child, reportCleanChild);
}
function eachParent(child, callback) {
  const parentCount = child.parents.size;
  if (parentCount) {
    const parents = arrayFromSet(child.parents);
    for (let i2 = 0; i2 < parentCount; ++i2) {
      callback(parents[i2], child);
    }
  }
}
function reportDirtyChild(parent, child) {
  assert$1(parent.childValues.has(child));
  assert$1(mightBeDirty(child));
  const parentWasClean = !mightBeDirty(parent);
  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
  } else if (parent.dirtyChildren.has(child)) {
    return;
  }
  parent.dirtyChildren.add(child);
  if (parentWasClean) {
    reportDirty(parent);
  }
}
function reportCleanChild(parent, child) {
  assert$1(parent.childValues.has(child));
  assert$1(!mightBeDirty(child));
  const childValue = parent.childValues.get(child);
  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }
  removeDirtyChild(parent, child);
  if (mightBeDirty(parent)) {
    return;
  }
  reportClean(parent);
}
function removeDirtyChild(parent, child) {
  const dc2 = parent.dirtyChildren;
  if (dc2) {
    dc2.delete(child);
    if (dc2.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc2);
      }
      parent.dirtyChildren = null;
    }
  }
}
function forgetChildren(parent) {
  if (parent.childValues.size > 0) {
    parent.childValues.forEach((_value, child) => {
      forgetChild(parent, child);
    });
  }
  parent.forgetDeps();
  assert$1(parent.dirtyChildren === null);
}
function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}
function maybeSubscribe(entry, args) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, args);
    } catch (e2) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}
const EntryMethods = {
  setDirty: true,
  dispose: true,
  forget: true
  // Fully remove parent Entry from LRU cache and computation graph
};
function dep(options) {
  const depsByKey = /* @__PURE__ */ new Map();
  const subscribe = options && options.subscribe;
  function depend(key) {
    const parent = parentEntrySlot.getValue();
    if (parent) {
      let dep2 = depsByKey.get(key);
      if (!dep2) {
        depsByKey.set(key, dep2 = /* @__PURE__ */ new Set());
      }
      parent.dependOn(dep2);
      if (typeof subscribe === "function") {
        maybeUnsubscribe(dep2);
        dep2.unsubscribe = subscribe(key);
      }
    }
  }
  depend.dirty = function dirty(key, entryMethodName) {
    const dep2 = depsByKey.get(key);
    if (dep2) {
      const m2 = entryMethodName && hasOwnProperty$3.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
      arrayFromSet(dep2).forEach((entry) => entry[m2]());
      depsByKey.delete(key);
      maybeUnsubscribe(dep2);
    }
  };
  return depend;
}
let defaultKeyTrie;
function defaultMakeCacheKey(...args) {
  const trie = defaultKeyTrie || (defaultKeyTrie = new Trie(typeof WeakMap === "function"));
  return trie.lookupArray(args);
}
const caches = /* @__PURE__ */ new Set();
function wrap(originalFunction, { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = StrongCache } = /* @__PURE__ */ Object.create(null)) {
  const cache2 = typeof cacheOption === "function" ? new cacheOption(max, (entry) => entry.dispose()) : cacheOption;
  const optimistic = function() {
    const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }
    let entry = cache2.get(key);
    if (!entry) {
      cache2.set(key, entry = new Entry(originalFunction));
      entry.normalizeResult = normalizeResult;
      entry.subscribe = subscribe;
      entry.forget = () => cache2.delete(key);
    }
    const value = entry.recompute(Array.prototype.slice.call(arguments));
    cache2.set(key, entry);
    caches.add(cache2);
    if (!parentEntrySlot.hasValue()) {
      caches.forEach((cache3) => cache3.clean());
      caches.clear();
    }
    return value;
  };
  Object.defineProperty(optimistic, "size", {
    get: () => cache2.size,
    configurable: false,
    enumerable: false
  });
  Object.freeze(optimistic.options = {
    max,
    keyArgs,
    makeCacheKey,
    normalizeResult,
    subscribe,
    cache: cache2
  });
  function dirtyKey(key) {
    const entry = key && cache2.get(key);
    if (entry) {
      entry.setDirty();
    }
  }
  optimistic.dirtyKey = dirtyKey;
  optimistic.dirty = function dirty() {
    dirtyKey(makeCacheKey.apply(null, arguments));
  };
  function peekKey(key) {
    const entry = key && cache2.get(key);
    if (entry) {
      return entry.peek();
    }
  }
  optimistic.peekKey = peekKey;
  optimistic.peek = function peek() {
    return peekKey(makeCacheKey.apply(null, arguments));
  };
  function forgetKey(key) {
    return key ? cache2.delete(key) : false;
  }
  optimistic.forgetKey = forgetKey;
  optimistic.forget = function forget() {
    return forgetKey(makeCacheKey.apply(null, arguments));
  };
  optimistic.makeCacheKey = makeCacheKey;
  optimistic.getKey = keyArgs ? function getKey() {
    return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
  } : makeCacheKey;
  return Object.freeze(optimistic);
}
var ApolloCache = (
  /** @class */
  function() {
    function ApolloCache2() {
      this.assumeImmutableResults = false;
      this.getFragmentDoc = wrap(getFragmentQueryDocument);
    }
    ApolloCache2.prototype.batch = function(options) {
      var _this = this;
      var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
      var updateResult;
      this.performTransaction(function() {
        return updateResult = options.update(_this);
      }, optimisticId);
      return updateResult;
    };
    ApolloCache2.prototype.recordOptimisticTransaction = function(transaction2, optimisticId) {
      this.performTransaction(transaction2, optimisticId);
    };
    ApolloCache2.prototype.transformDocument = function(document2) {
      return document2;
    };
    ApolloCache2.prototype.transformForLink = function(document2) {
      return document2;
    };
    ApolloCache2.prototype.identify = function(object) {
      return;
    };
    ApolloCache2.prototype.gc = function() {
      return [];
    };
    ApolloCache2.prototype.modify = function(options) {
      return false;
    };
    ApolloCache2.prototype.readQuery = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options.optimistic;
      }
      return this.read(__assign$2(__assign$2({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
    };
    ApolloCache2.prototype.readFragment = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options.optimistic;
      }
      return this.read(__assign$2(__assign$2({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
    };
    ApolloCache2.prototype.writeQuery = function(_a2) {
      var id2 = _a2.id, data2 = _a2.data, options = __rest$2(_a2, ["id", "data"]);
      return this.write(Object.assign(options, {
        dataId: id2 || "ROOT_QUERY",
        result: data2
      }));
    };
    ApolloCache2.prototype.writeFragment = function(_a2) {
      var id2 = _a2.id, data2 = _a2.data, fragment = _a2.fragment, fragmentName = _a2.fragmentName, options = __rest$2(_a2, ["id", "data", "fragment", "fragmentName"]);
      return this.write(Object.assign(options, {
        query: this.getFragmentDoc(fragment, fragmentName),
        dataId: id2,
        result: data2
      }));
    };
    ApolloCache2.prototype.updateQuery = function(options, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readQuery(options);
          var data2 = update(value);
          if (data2 === void 0 || data2 === null)
            return value;
          cache2.writeQuery(__assign$2(__assign$2({}, options), { data: data2 }));
          return data2;
        }
      });
    };
    ApolloCache2.prototype.updateFragment = function(options, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readFragment(options);
          var data2 = update(value);
          if (data2 === void 0 || data2 === null)
            return value;
          cache2.writeFragment(__assign$2(__assign$2({}, options), { data: data2 }));
          return data2;
        }
      });
    };
    return ApolloCache2;
  }()
);
var MissingFieldError = (
  /** @class */
  function(_super) {
    __extends$1(MissingFieldError2, _super);
    function MissingFieldError2(message, path, query, variables) {
      var _a2;
      var _this = _super.call(this, message) || this;
      _this.message = message;
      _this.path = path;
      _this.query = query;
      _this.variables = variables;
      if (Array.isArray(_this.path)) {
        _this.missing = _this.message;
        for (var i2 = _this.path.length - 1; i2 >= 0; --i2) {
          _this.missing = (_a2 = {}, _a2[_this.path[i2]] = _this.missing, _a2);
        }
      } else {
        _this.missing = _this.path;
      }
      _this.__proto__ = MissingFieldError2.prototype;
      return _this;
    }
    return MissingFieldError2;
  }(Error)
);
var hasOwn = Object.prototype.hasOwnProperty;
function isNullish(value) {
  return value === null || value === void 0;
}
function defaultDataIdFromObject(_a2, context) {
  var __typename = _a2.__typename, id2 = _a2.id, _id = _a2._id;
  if (typeof __typename === "string") {
    if (context) {
      context.keyObject = !isNullish(id2) ? { id: id2 } : !isNullish(_id) ? { _id } : void 0;
    }
    if (isNullish(id2) && !isNullish(_id)) {
      id2 = _id;
    }
    if (!isNullish(id2)) {
      return "".concat(__typename, ":").concat(typeof id2 === "number" || typeof id2 === "string" ? id2 : JSON.stringify(id2));
    }
  }
}
var defaultConfig$1 = {
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  // Thanks to the shouldCanonizeResults helper, this should be the only line
  // you have to change to reenable canonization by default in the future.
  canonizeResults: false
};
function normalizeConfig(config2) {
  return compact(defaultConfig$1, config2);
}
function shouldCanonizeResults(config2) {
  var value = config2.canonizeResults;
  return value === void 0 ? defaultConfig$1.canonizeResults : value;
}
function getTypenameFromStoreObject(store, objectOrReference) {
  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
}
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
  var match = storeFieldName.match(TypeOrFieldNameRegExp);
  return match ? match[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result, variables) {
  if (isNonNullObject(result)) {
    return isArray(result) ? result.every(function(item) {
      return selectionSetMatchesResult(selectionSet, item, variables);
    }) : selectionSet.selections.every(function(field) {
      if (isField(field) && shouldInclude(field, variables)) {
        var key = resultKeyNameFromField(field);
        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));
      }
      return true;
    });
  }
  return false;
}
function storeValueIsStoreObject(value) {
  return isNonNullObject(value) && !isReference(value) && !isArray(value);
}
function makeProcessedFieldsMerger() {
  return new DeepMerger();
}
function extractFragmentContext(document2, fragments) {
  var fragmentMap = createFragmentMap(getFragmentDefinitions(document2));
  return {
    fragmentMap,
    lookupFragment: function(name2) {
      var def = fragmentMap[name2];
      if (!def && fragments) {
        def = fragments.lookup(name2);
      }
      return def || null;
    }
  };
}
var DELETE = /* @__PURE__ */ Object.create(null);
var delModifier = function() {
  return DELETE;
};
var INVALIDATE = /* @__PURE__ */ Object.create(null);
var EntityStore = (
  /** @class */
  function() {
    function EntityStore2(policies, group) {
      var _this = this;
      this.policies = policies;
      this.group = group;
      this.data = /* @__PURE__ */ Object.create(null);
      this.rootIds = /* @__PURE__ */ Object.create(null);
      this.refs = /* @__PURE__ */ Object.create(null);
      this.getFieldValue = function(objectOrReference, storeFieldName) {
        return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
      };
      this.canRead = function(objOrRef) {
        return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
      };
      this.toReference = function(objOrIdOrRef, mergeIntoStore) {
        if (typeof objOrIdOrRef === "string") {
          return makeReference(objOrIdOrRef);
        }
        if (isReference(objOrIdOrRef)) {
          return objOrIdOrRef;
        }
        var id2 = _this.policies.identify(objOrIdOrRef)[0];
        if (id2) {
          var ref = makeReference(id2);
          if (mergeIntoStore) {
            _this.merge(id2, objOrIdOrRef);
          }
          return ref;
        }
      };
    }
    EntityStore2.prototype.toObject = function() {
      return __assign$2({}, this.data);
    };
    EntityStore2.prototype.has = function(dataId) {
      return this.lookup(dataId, true) !== void 0;
    };
    EntityStore2.prototype.get = function(dataId, fieldName) {
      this.group.depend(dataId, fieldName);
      if (hasOwn.call(this.data, dataId)) {
        var storeObject = this.data[dataId];
        if (storeObject && hasOwn.call(storeObject, fieldName)) {
          return storeObject[fieldName];
        }
      }
      if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
        return this.policies.rootTypenamesById[dataId];
      }
      if (this instanceof Layer) {
        return this.parent.get(dataId, fieldName);
      }
    };
    EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
      if (dependOnExistence)
        this.group.depend(dataId, "__exists");
      if (hasOwn.call(this.data, dataId)) {
        return this.data[dataId];
      }
      if (this instanceof Layer) {
        return this.parent.lookup(dataId, dependOnExistence);
      }
      if (this.policies.rootTypenamesById[dataId]) {
        return /* @__PURE__ */ Object.create(null);
      }
    };
    EntityStore2.prototype.merge = function(older, newer) {
      var _this = this;
      var dataId;
      if (isReference(older))
        older = older.__ref;
      if (isReference(newer))
        newer = newer.__ref;
      var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
      var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
      if (!incoming)
        return;
      invariant$2(typeof dataId === "string", 1);
      var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
      this.data[dataId] = merged;
      if (merged !== existing) {
        delete this.refs[dataId];
        if (this.group.caching) {
          var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
          if (!existing)
            fieldsToDirty_1.__exists = 1;
          Object.keys(incoming).forEach(function(storeFieldName) {
            if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
              fieldsToDirty_1[storeFieldName] = 1;
              var fieldName = fieldNameFromStoreName(storeFieldName);
              if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                fieldsToDirty_1[fieldName] = 1;
              }
              if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                delete merged[storeFieldName];
              }
            }
          });
          if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && // Since we return default root __typename strings
          // automatically from store.get, we don't need to dirty the
          // ROOT_QUERY.__typename field if merged.__typename is equal
          // to the default string (usually "Query").
          this.policies.rootTypenamesById[dataId] === merged.__typename) {
            delete fieldsToDirty_1.__typename;
          }
          Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
            return _this.group.dirty(dataId, fieldName);
          });
        }
      }
    };
    EntityStore2.prototype.modify = function(dataId, fields) {
      var _this = this;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var changedFields_1 = /* @__PURE__ */ Object.create(null);
        var needToMerge_1 = false;
        var allDeleted_1 = true;
        var sharedDetails_1 = {
          DELETE,
          INVALIDATE,
          isReference,
          toReference: this.toReference,
          canRead: this.canRead,
          readField: function(fieldNameOrOptions, from2) {
            return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
              fieldName: fieldNameOrOptions,
              from: from2 || makeReference(dataId)
            } : fieldNameOrOptions, { store: _this });
          }
        };
        Object.keys(storeObject).forEach(function(storeFieldName) {
          var fieldName = fieldNameFromStoreName(storeFieldName);
          var fieldValue = storeObject[storeFieldName];
          if (fieldValue === void 0)
            return;
          var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
          if (modify) {
            var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign$2(__assign$2({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
            if (newValue === INVALIDATE) {
              _this.group.dirty(dataId, storeFieldName);
            } else {
              if (newValue === DELETE)
                newValue = void 0;
              if (newValue !== fieldValue) {
                changedFields_1[storeFieldName] = newValue;
                needToMerge_1 = true;
                fieldValue = newValue;
                if (globalThis.__DEV__ !== false) {
                  var checkReference = function(ref) {
                    if (_this.lookup(ref.__ref) === void 0) {
                      globalThis.__DEV__ !== false && invariant$2.warn(2, ref);
                      return true;
                    }
                  };
                  if (isReference(newValue)) {
                    checkReference(newValue);
                  } else if (Array.isArray(newValue)) {
                    var seenReference = false;
                    var someNonReference = void 0;
                    for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {
                      var value = newValue_1[_i];
                      if (isReference(value)) {
                        seenReference = true;
                        if (checkReference(value))
                          break;
                      } else {
                        if (typeof value === "object" && !!value) {
                          var id2 = _this.policies.identify(value)[0];
                          if (id2) {
                            someNonReference = value;
                          }
                        }
                      }
                      if (seenReference && someNonReference !== void 0) {
                        globalThis.__DEV__ !== false && invariant$2.warn(3, someNonReference);
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          if (fieldValue !== void 0) {
            allDeleted_1 = false;
          }
        });
        if (needToMerge_1) {
          this.merge(dataId, changedFields_1);
          if (allDeleted_1) {
            if (this instanceof Layer) {
              this.data[dataId] = void 0;
            } else {
              delete this.data[dataId];
            }
            this.group.dirty(dataId, "__exists");
          }
          return true;
        }
      }
      return false;
    };
    EntityStore2.prototype.delete = function(dataId, fieldName, args) {
      var _a2;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var typename = this.getFieldValue(storeObject, "__typename");
        var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
        return this.modify(dataId, storeFieldName ? (_a2 = {}, _a2[storeFieldName] = delModifier, _a2) : delModifier);
      }
      return false;
    };
    EntityStore2.prototype.evict = function(options, limit) {
      var evicted = false;
      if (options.id) {
        if (hasOwn.call(this.data, options.id)) {
          evicted = this.delete(options.id, options.fieldName, options.args);
        }
        if (this instanceof Layer && this !== limit) {
          evicted = this.parent.evict(options, limit) || evicted;
        }
        if (options.fieldName || evicted) {
          this.group.dirty(options.id, options.fieldName || "__exists");
        }
      }
      return evicted;
    };
    EntityStore2.prototype.clear = function() {
      this.replace(null);
    };
    EntityStore2.prototype.extract = function() {
      var _this = this;
      var obj = this.toObject();
      var extraRootIds = [];
      this.getRootIdSet().forEach(function(id2) {
        if (!hasOwn.call(_this.policies.rootTypenamesById, id2)) {
          extraRootIds.push(id2);
        }
      });
      if (extraRootIds.length) {
        obj.__META = { extraRootIds: extraRootIds.sort() };
      }
      return obj;
    };
    EntityStore2.prototype.replace = function(newData) {
      var _this = this;
      Object.keys(this.data).forEach(function(dataId) {
        if (!(newData && hasOwn.call(newData, dataId))) {
          _this.delete(dataId);
        }
      });
      if (newData) {
        var __META = newData.__META, rest_1 = __rest$2(newData, ["__META"]);
        Object.keys(rest_1).forEach(function(dataId) {
          _this.merge(dataId, rest_1[dataId]);
        });
        if (__META) {
          __META.extraRootIds.forEach(this.retain, this);
        }
      }
    };
    EntityStore2.prototype.retain = function(rootId) {
      return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
    };
    EntityStore2.prototype.release = function(rootId) {
      if (this.rootIds[rootId] > 0) {
        var count = --this.rootIds[rootId];
        if (!count)
          delete this.rootIds[rootId];
        return count;
      }
      return 0;
    };
    EntityStore2.prototype.getRootIdSet = function(ids) {
      if (ids === void 0) {
        ids = /* @__PURE__ */ new Set();
      }
      Object.keys(this.rootIds).forEach(ids.add, ids);
      if (this instanceof Layer) {
        this.parent.getRootIdSet(ids);
      } else {
        Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
      }
      return ids;
    };
    EntityStore2.prototype.gc = function() {
      var _this = this;
      var ids = this.getRootIdSet();
      var snapshot2 = this.toObject();
      ids.forEach(function(id2) {
        if (hasOwn.call(snapshot2, id2)) {
          Object.keys(_this.findChildRefIds(id2)).forEach(ids.add, ids);
          delete snapshot2[id2];
        }
      });
      var idsToRemove = Object.keys(snapshot2);
      if (idsToRemove.length) {
        var root_1 = this;
        while (root_1 instanceof Layer)
          root_1 = root_1.parent;
        idsToRemove.forEach(function(id2) {
          return root_1.delete(id2);
        });
      }
      return idsToRemove;
    };
    EntityStore2.prototype.findChildRefIds = function(dataId) {
      if (!hasOwn.call(this.refs, dataId)) {
        var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
        var root2 = this.data[dataId];
        if (!root2)
          return found_1;
        var workSet_1 = /* @__PURE__ */ new Set([root2]);
        workSet_1.forEach(function(obj) {
          if (isReference(obj)) {
            found_1[obj.__ref] = true;
          }
          if (isNonNullObject(obj)) {
            Object.keys(obj).forEach(function(key) {
              var child = obj[key];
              if (isNonNullObject(child)) {
                workSet_1.add(child);
              }
            });
          }
        });
      }
      return this.refs[dataId];
    };
    EntityStore2.prototype.makeCacheKey = function() {
      return this.group.keyMaker.lookupArray(arguments);
    };
    return EntityStore2;
  }()
);
var CacheGroup = (
  /** @class */
  function() {
    function CacheGroup2(caching, parent) {
      if (parent === void 0) {
        parent = null;
      }
      this.caching = caching;
      this.parent = parent;
      this.d = null;
      this.resetCaching();
    }
    CacheGroup2.prototype.resetCaching = function() {
      this.d = this.caching ? dep() : null;
      this.keyMaker = new Trie$1(canUseWeakMap);
    };
    CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
      if (this.d) {
        this.d(makeDepKey(dataId, storeFieldName));
        var fieldName = fieldNameFromStoreName(storeFieldName);
        if (fieldName !== storeFieldName) {
          this.d(makeDepKey(dataId, fieldName));
        }
        if (this.parent) {
          this.parent.depend(dataId, storeFieldName);
        }
      }
    };
    CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
      if (this.d) {
        this.d.dirty(
          makeDepKey(dataId, storeFieldName),
          // When storeFieldName === "__exists", that means the entity identified
          // by dataId has either disappeared from the cache or was newly added,
          // so the result caching system would do well to "forget everything it
          // knows" about that object. To achieve that kind of invalidation, we
          // not only dirty the associated result cache entry, but also remove it
          // completely from the dependency graph. For the optimism implementation
          // details, see https://github.com/benjamn/optimism/pull/195.
          storeFieldName === "__exists" ? "forget" : "setDirty"
        );
      }
    };
    return CacheGroup2;
  }()
);
function makeDepKey(dataId, storeFieldName) {
  return storeFieldName + "#" + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
  if (supportsResultCaching(store)) {
    store.group.depend(entityId, "__exists");
  }
}
(function(EntityStore2) {
  var Root2 = (
    /** @class */
    function(_super) {
      __extends$1(Root3, _super);
      function Root3(_a2) {
        var policies = _a2.policies, _b = _a2.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a2.seed;
        var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
        _this.stump = new Stump(_this);
        _this.storageTrie = new Trie$1(canUseWeakMap);
        if (seed)
          _this.replace(seed);
        return _this;
      }
      Root3.prototype.addLayer = function(layerId, replay) {
        return this.stump.addLayer(layerId, replay);
      };
      Root3.prototype.removeLayer = function() {
        return this;
      };
      Root3.prototype.getStorage = function() {
        return this.storageTrie.lookupArray(arguments);
      };
      return Root3;
    }(EntityStore2)
  );
  EntityStore2.Root = Root2;
})(EntityStore || (EntityStore = {}));
var Layer = (
  /** @class */
  function(_super) {
    __extends$1(Layer2, _super);
    function Layer2(id2, parent, replay, group) {
      var _this = _super.call(this, parent.policies, group) || this;
      _this.id = id2;
      _this.parent = parent;
      _this.replay = replay;
      _this.group = group;
      replay(_this);
      return _this;
    }
    Layer2.prototype.addLayer = function(layerId, replay) {
      return new Layer2(layerId, this, replay, this.group);
    };
    Layer2.prototype.removeLayer = function(layerId) {
      var _this = this;
      var parent = this.parent.removeLayer(layerId);
      if (layerId === this.id) {
        if (this.group.caching) {
          Object.keys(this.data).forEach(function(dataId) {
            var ownStoreObject = _this.data[dataId];
            var parentStoreObject = parent["lookup"](dataId);
            if (!parentStoreObject) {
              _this.delete(dataId);
            } else if (!ownStoreObject) {
              _this.group.dirty(dataId, "__exists");
              Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                _this.group.dirty(dataId, storeFieldName);
              });
            } else if (ownStoreObject !== parentStoreObject) {
              Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                if (!equal$2(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                  _this.group.dirty(dataId, storeFieldName);
                }
              });
            }
          });
        }
        return parent;
      }
      if (parent === this.parent)
        return this;
      return parent.addLayer(this.id, this.replay);
    };
    Layer2.prototype.toObject = function() {
      return __assign$2(__assign$2({}, this.parent.toObject()), this.data);
    };
    Layer2.prototype.findChildRefIds = function(dataId) {
      var fromParent = this.parent.findChildRefIds(dataId);
      return hasOwn.call(this.data, dataId) ? __assign$2(__assign$2({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
    };
    Layer2.prototype.getStorage = function() {
      var p2 = this.parent;
      while (p2.parent)
        p2 = p2.parent;
      return p2.getStorage.apply(
        p2,
        // @ts-expect-error
        arguments
      );
    };
    return Layer2;
  }(EntityStore)
);
var Stump = (
  /** @class */
  function(_super) {
    __extends$1(Stump2, _super);
    function Stump2(root2) {
      return _super.call(this, "EntityStore.Stump", root2, function() {
      }, new CacheGroup(root2.group.caching, root2.group)) || this;
    }
    Stump2.prototype.removeLayer = function() {
      return this;
    };
    Stump2.prototype.merge = function(older, newer) {
      return this.parent.merge(older, newer);
    };
    return Stump2;
  }(Layer)
);
function storeObjectReconciler(existingObject, incomingObject, property) {
  var existingValue = existingObject[property];
  var incomingValue = incomingObject[property];
  return equal$2(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
  return !!(store instanceof EntityStore && store.group.caching);
}
function shallowCopy(value) {
  if (isNonNullObject(value)) {
    return isArray(value) ? value.slice(0) : __assign$2({ __proto__: Object.getPrototypeOf(value) }, value);
  }
  return value;
}
var ObjectCanon = (
  /** @class */
  function() {
    function ObjectCanon2() {
      this.known = new (canUseWeakSet ? WeakSet : Set)();
      this.pool = new Trie$1(canUseWeakMap);
      this.passes = /* @__PURE__ */ new WeakMap();
      this.keysByJSON = /* @__PURE__ */ new Map();
      this.empty = this.admit({});
    }
    ObjectCanon2.prototype.isKnown = function(value) {
      return isNonNullObject(value) && this.known.has(value);
    };
    ObjectCanon2.prototype.pass = function(value) {
      if (isNonNullObject(value)) {
        var copy2 = shallowCopy(value);
        this.passes.set(copy2, value);
        return copy2;
      }
      return value;
    };
    ObjectCanon2.prototype.admit = function(value) {
      var _this = this;
      if (isNonNullObject(value)) {
        var original = this.passes.get(value);
        if (original)
          return original;
        var proto = Object.getPrototypeOf(value);
        switch (proto) {
          case Array.prototype: {
            if (this.known.has(value))
              return value;
            var array = value.map(this.admit, this);
            var node2 = this.pool.lookupArray(array);
            if (!node2.array) {
              this.known.add(node2.array = array);
              if (globalThis.__DEV__ !== false) {
                Object.freeze(array);
              }
            }
            return node2.array;
          }
          case null:
          case Object.prototype: {
            if (this.known.has(value))
              return value;
            var proto_1 = Object.getPrototypeOf(value);
            var array_1 = [proto_1];
            var keys2 = this.sortedKeys(value);
            array_1.push(keys2.json);
            var firstValueIndex_1 = array_1.length;
            keys2.sorted.forEach(function(key) {
              array_1.push(_this.admit(value[key]));
            });
            var node2 = this.pool.lookupArray(array_1);
            if (!node2.object) {
              var obj_1 = node2.object = Object.create(proto_1);
              this.known.add(obj_1);
              keys2.sorted.forEach(function(key, i2) {
                obj_1[key] = array_1[firstValueIndex_1 + i2];
              });
              if (globalThis.__DEV__ !== false) {
                Object.freeze(obj_1);
              }
            }
            return node2.object;
          }
        }
      }
      return value;
    };
    ObjectCanon2.prototype.sortedKeys = function(obj) {
      var keys2 = Object.keys(obj);
      var node2 = this.pool.lookupArray(keys2);
      if (!node2.keys) {
        keys2.sort();
        var json = JSON.stringify(keys2);
        if (!(node2.keys = this.keysByJSON.get(json))) {
          this.keysByJSON.set(json, node2.keys = { sorted: keys2, json });
        }
      }
      return node2.keys;
    };
    return ObjectCanon2;
  }()
);
var canonicalStringify = Object.assign(function(value) {
  if (isNonNullObject(value)) {
    if (stringifyCanon === void 0) {
      resetCanonicalStringify();
    }
    var canonical = stringifyCanon.admit(value);
    var json = stringifyCache.get(canonical);
    if (json === void 0) {
      stringifyCache.set(canonical, json = JSON.stringify(canonical));
    }
    return json;
  }
  return JSON.stringify(value);
}, {
  reset: resetCanonicalStringify
});
var stringifyCanon;
var stringifyCache;
function resetCanonicalStringify() {
  stringifyCanon = new ObjectCanon();
  stringifyCache = new (canUseWeakMap ? WeakMap : Map)();
}
function execSelectionSetKeyArgs(options) {
  return [
    options.selectionSet,
    options.objectOrReference,
    options.context,
    // We split out this property so we can pass different values
    // independently without modifying options.context itself.
    options.context.canonizeResults
  ];
}
var StoreReader = (
  /** @class */
  function() {
    function StoreReader2(config2) {
      var _this = this;
      this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
      this.config = compact(config2, {
        addTypename: config2.addTypename !== false,
        canonizeResults: shouldCanonizeResults(config2)
      });
      this.canon = config2.canon || new ObjectCanon();
      this.executeSelectionSet = wrap(function(options) {
        var _a2;
        var canonizeResults = options.context.canonizeResults;
        var peekArgs = execSelectionSetKeyArgs(options);
        peekArgs[3] = !canonizeResults;
        var other = (_a2 = _this.executeSelectionSet).peek.apply(_a2, peekArgs);
        if (other) {
          if (canonizeResults) {
            return __assign$2(__assign$2({}, other), {
              // If we previously read this result without canonizing it, we can
              // reuse that result simply by canonizing it now.
              result: _this.canon.admit(other.result)
            });
          }
          return other;
        }
        maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
        return _this.execSelectionSetImpl(options);
      }, {
        max: this.config.resultCacheMaxSize,
        keyArgs: execSelectionSetKeyArgs,
        // Note that the parameters of makeCacheKey are determined by the
        // array returned by keyArgs.
        makeCacheKey: function(selectionSet, parent, context, canonizeResults) {
          if (supportsResultCaching(context.store)) {
            return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
          }
        }
      });
      this.executeSubSelectedArray = wrap(function(options) {
        maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
        return _this.execSubSelectedArrayImpl(options);
      }, {
        max: this.config.resultCacheMaxSize,
        makeCacheKey: function(_a2) {
          var field = _a2.field, array = _a2.array, context = _a2.context;
          if (supportsResultCaching(context.store)) {
            return context.store.makeCacheKey(field, array, context.varString);
          }
        }
      });
    }
    StoreReader2.prototype.resetCanon = function() {
      this.canon = new ObjectCanon();
    };
    StoreReader2.prototype.diffQueryAgainstStore = function(_a2) {
      var store = _a2.store, query = _a2.query, _b = _a2.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a2.variables, _c = _a2.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a2.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
      var policies = this.config.cache.policies;
      variables = __assign$2(__assign$2({}, getDefaultValues(getQueryDefinition(query))), variables);
      var rootRef = makeReference(rootId);
      var execResult = this.executeSelectionSet({
        selectionSet: getMainDefinition(query).selectionSet,
        objectOrReference: rootRef,
        enclosingRef: rootRef,
        context: __assign$2({ store, query, policies, variables, varString: canonicalStringify(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))
      });
      var missing;
      if (execResult.missing) {
        missing = [
          new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)
        ];
        if (!returnPartialData) {
          throw missing[0];
        }
      }
      return {
        result: execResult.result,
        complete: !missing,
        missing
      };
    };
    StoreReader2.prototype.isFresh = function(result, parent, selectionSet, context) {
      if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {
        var latest = this.executeSelectionSet.peek(
          selectionSet,
          parent,
          context,
          // If result is canonical, then it could only have been previously
          // cached by the canonizing version of executeSelectionSet, so we can
          // avoid checking both possibilities here.
          this.canon.isKnown(result)
        );
        if (latest && result === latest.result) {
          return true;
        }
      }
      return false;
    };
    StoreReader2.prototype.execSelectionSetImpl = function(_a2) {
      var _this = this;
      var selectionSet = _a2.selectionSet, objectOrReference = _a2.objectOrReference, enclosingRef = _a2.enclosingRef, context = _a2.context;
      if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
        return {
          result: this.canon.empty,
          missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
        };
      }
      var variables = context.variables, policies = context.policies, store = context.store;
      var typename = store.getFieldValue(objectOrReference, "__typename");
      var objectsToMerge = [];
      var missing;
      var missingMerger = new DeepMerger();
      if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
        objectsToMerge.push({ __typename: typename });
      }
      function handleMissing(result2, resultName) {
        var _a3;
        if (result2.missing) {
          missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = result2.missing, _a3));
        }
        return result2.result;
      }
      var workSet = new Set(selectionSet.selections);
      workSet.forEach(function(selection) {
        var _a3, _b;
        if (!shouldInclude(selection, variables))
          return;
        if (isField(selection)) {
          var fieldValue = policies.readField({
            fieldName: selection.name.value,
            field: selection,
            variables: context.variables,
            from: objectOrReference
          }, context);
          var resultName = resultKeyNameFromField(selection);
          if (fieldValue === void 0) {
            if (!addTypenameToDocument.added(selection)) {
              missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a3));
            }
          } else if (isArray(fieldValue)) {
            fieldValue = handleMissing(_this.executeSubSelectedArray({
              field: selection,
              array: fieldValue,
              enclosingRef,
              context
            }), resultName);
          } else if (!selection.selectionSet) {
            if (context.canonizeResults) {
              fieldValue = _this.canon.pass(fieldValue);
            }
          } else if (fieldValue != null) {
            fieldValue = handleMissing(_this.executeSelectionSet({
              selectionSet: selection.selectionSet,
              objectOrReference: fieldValue,
              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
              context
            }), resultName);
          }
          if (fieldValue !== void 0) {
            objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
          }
        } else {
          var fragment = getFragmentFromSelection(selection, context.lookupFragment);
          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
            throw newInvariantError(9, selection.name.value);
          }
          if (fragment && policies.fragmentMatches(fragment, typename)) {
            fragment.selectionSet.selections.forEach(workSet.add, workSet);
          }
        }
      });
      var result = mergeDeepArray(objectsToMerge);
      var finalResult = { result, missing };
      var frozen = context.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);
      if (frozen.result) {
        this.knownResults.set(frozen.result, selectionSet);
      }
      return frozen;
    };
    StoreReader2.prototype.execSubSelectedArrayImpl = function(_a2) {
      var _this = this;
      var field = _a2.field, array = _a2.array, enclosingRef = _a2.enclosingRef, context = _a2.context;
      var missing;
      var missingMerger = new DeepMerger();
      function handleMissing(childResult, i2) {
        var _a3;
        if (childResult.missing) {
          missing = missingMerger.merge(missing, (_a3 = {}, _a3[i2] = childResult.missing, _a3));
        }
        return childResult.result;
      }
      if (field.selectionSet) {
        array = array.filter(context.store.canRead);
      }
      array = array.map(function(item, i2) {
        if (item === null) {
          return null;
        }
        if (isArray(item)) {
          return handleMissing(_this.executeSubSelectedArray({
            field,
            array: item,
            enclosingRef,
            context
          }), i2);
        }
        if (field.selectionSet) {
          return handleMissing(_this.executeSelectionSet({
            selectionSet: field.selectionSet,
            objectOrReference: item,
            enclosingRef: isReference(item) ? item : enclosingRef,
            context
          }), i2);
        }
        if (globalThis.__DEV__ !== false) {
          assertSelectionSetForIdValue(context.store, field, item);
        }
        return item;
      });
      return {
        result: context.canonizeResults ? this.canon.admit(array) : array,
        missing
      };
    };
    return StoreReader2;
  }()
);
function firstMissing(tree2) {
  try {
    JSON.stringify(tree2, function(_2, value) {
      if (typeof value === "string")
        throw value;
      return value;
    });
  } catch (result) {
    return result;
  }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
  if (!field.selectionSet) {
    var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
    workSet_1.forEach(function(value) {
      if (isNonNullObject(value)) {
        invariant$2(
          !isReference(value),
          10,
          getTypenameFromStoreObject(store, value),
          field.name.value
        );
        Object.values(value).forEach(workSet_1.add, workSet_1);
      }
    });
  }
}
var cacheSlot = new Slot();
var cacheInfoMap = /* @__PURE__ */ new WeakMap();
function getCacheInfo(cache2) {
  var info = cacheInfoMap.get(cache2);
  if (!info) {
    cacheInfoMap.set(cache2, info = {
      vars: /* @__PURE__ */ new Set(),
      dep: dep()
    });
  }
  return info;
}
function forgetCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.forgetCache(cache2);
  });
}
function recallCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.attachCache(cache2);
  });
}
function makeVar(value) {
  var caches2 = /* @__PURE__ */ new Set();
  var listeners2 = /* @__PURE__ */ new Set();
  var rv = function(newValue) {
    if (arguments.length > 0) {
      if (value !== newValue) {
        value = newValue;
        caches2.forEach(function(cache3) {
          getCacheInfo(cache3).dep.dirty(rv);
          broadcast(cache3);
        });
        var oldListeners = Array.from(listeners2);
        listeners2.clear();
        oldListeners.forEach(function(listener) {
          return listener(value);
        });
      }
    } else {
      var cache2 = cacheSlot.getValue();
      if (cache2) {
        attach(cache2);
        getCacheInfo(cache2).dep(rv);
      }
    }
    return value;
  };
  rv.onNextChange = function(listener) {
    listeners2.add(listener);
    return function() {
      listeners2.delete(listener);
    };
  };
  var attach = rv.attachCache = function(cache2) {
    caches2.add(cache2);
    getCacheInfo(cache2).vars.add(rv);
    return rv;
  };
  rv.forgetCache = function(cache2) {
    return caches2.delete(cache2);
  };
  return rv;
}
function broadcast(cache2) {
  if (cache2.broadcastWatches) {
    cache2.broadcastWatches();
  }
}
var specifierInfoCache = /* @__PURE__ */ Object.create(null);
function lookupSpecifierInfo(spec) {
  var cacheKey2 = JSON.stringify(spec);
  return specifierInfoCache[cacheKey2] || (specifierInfoCache[cacheKey2] = /* @__PURE__ */ Object.create(null));
}
function keyFieldsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyFieldsFn || (info.keyFieldsFn = function(object, context) {
    var extract2 = function(from2, key) {
      return context.readField(key, from2);
    };
    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
      var extracted = extractKeyPath(
        context.storeObject,
        schemaKeyPath,
        // Using context.readField to extract paths from context.storeObject
        // allows the extraction to see through Reference objects and respect
        // custom read functions.
        extract2
      );
      if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {
        extracted = extractKeyPath(object, schemaKeyPath, extractKey);
      }
      invariant$2(extracted !== void 0, 4, schemaKeyPath.join("."), object);
      return extracted;
    });
    return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
  });
}
function keyArgsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyArgsFn || (info.keyArgsFn = function(args, _a2) {
    var field = _a2.field, variables = _a2.variables, fieldName = _a2.fieldName;
    var collected = collectSpecifierPaths(specifier, function(keyPath) {
      var firstKey = keyPath[0];
      var firstChar = firstKey.charAt(0);
      if (firstChar === "@") {
        if (field && isNonEmptyArray(field.directives)) {
          var directiveName_1 = firstKey.slice(1);
          var d2 = field.directives.find(function(d3) {
            return d3.name.value === directiveName_1;
          });
          var directiveArgs = d2 && argumentsObjectFromField(d2, variables);
          return directiveArgs && extractKeyPath(
            directiveArgs,
            // If keyPath.length === 1, this code calls extractKeyPath with an
            // empty path, which works because it uses directiveArgs as the
            // extracted value.
            keyPath.slice(1)
          );
        }
        return;
      }
      if (firstChar === "$") {
        var variableName = firstKey.slice(1);
        if (variables && hasOwn.call(variables, variableName)) {
          var varKeyPath = keyPath.slice(0);
          varKeyPath[0] = variableName;
          return extractKeyPath(variables, varKeyPath);
        }
        return;
      }
      if (args) {
        return extractKeyPath(args, keyPath);
      }
    });
    var suffix = JSON.stringify(collected);
    if (args || suffix !== "{}") {
      fieldName += ":" + suffix;
    }
    return fieldName;
  });
}
function collectSpecifierPaths(specifier, extractor) {
  var merger = new DeepMerger();
  return getSpecifierPaths(specifier).reduce(function(collected, path) {
    var _a2;
    var toMerge = extractor(path);
    if (toMerge !== void 0) {
      for (var i2 = path.length - 1; i2 >= 0; --i2) {
        toMerge = (_a2 = {}, _a2[path[i2]] = toMerge, _a2);
      }
      collected = merger.merge(collected, toMerge);
    }
    return collected;
  }, /* @__PURE__ */ Object.create(null));
}
function getSpecifierPaths(spec) {
  var info = lookupSpecifierInfo(spec);
  if (!info.paths) {
    var paths_1 = info.paths = [];
    var currentPath_1 = [];
    spec.forEach(function(s, i2) {
      if (isArray(s)) {
        getSpecifierPaths(s).forEach(function(p2) {
          return paths_1.push(currentPath_1.concat(p2));
        });
        currentPath_1.length = 0;
      } else {
        currentPath_1.push(s);
        if (!isArray(spec[i2 + 1])) {
          paths_1.push(currentPath_1.slice(0));
          currentPath_1.length = 0;
        }
      }
    });
  }
  return info.paths;
}
function extractKey(object, key) {
  return object[key];
}
function extractKeyPath(object, path, extract2) {
  extract2 = extract2 || extractKey;
  return normalize(path.reduce(function reducer(obj, key) {
    return isArray(obj) ? obj.map(function(child) {
      return reducer(child, key);
    }) : obj && extract2(obj, key);
  }, object));
}
function normalize(value) {
  if (isNonNullObject(value)) {
    if (isArray(value)) {
      return value.map(normalize);
    }
    return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
      return extractKeyPath(value, path);
    });
  }
  return value;
}
getStoreKeyName.setStringify(canonicalStringify);
function argsFromFieldSpecifier(spec) {
  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
}
var nullKeyFieldsFn = function() {
  return void 0;
};
var simpleKeyArgsFn = function(_args, context) {
  return context.fieldName;
};
var mergeTrueFn = function(existing, incoming, _a2) {
  var mergeObjects = _a2.mergeObjects;
  return mergeObjects(existing, incoming);
};
var mergeFalseFn = function(_2, incoming) {
  return incoming;
};
var Policies = (
  /** @class */
  function() {
    function Policies2(config2) {
      this.config = config2;
      this.typePolicies = /* @__PURE__ */ Object.create(null);
      this.toBeAdded = /* @__PURE__ */ Object.create(null);
      this.supertypeMap = /* @__PURE__ */ new Map();
      this.fuzzySubtypes = /* @__PURE__ */ new Map();
      this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
      this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
      this.usingPossibleTypes = false;
      this.config = __assign$2({ dataIdFromObject: defaultDataIdFromObject }, config2);
      this.cache = this.config.cache;
      this.setRootTypename("Query");
      this.setRootTypename("Mutation");
      this.setRootTypename("Subscription");
      if (config2.possibleTypes) {
        this.addPossibleTypes(config2.possibleTypes);
      }
      if (config2.typePolicies) {
        this.addTypePolicies(config2.typePolicies);
      }
    }
    Policies2.prototype.identify = function(object, partialContext) {
      var _a2;
      var policies = this;
      var typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) === null || _a2 === void 0 ? void 0 : _a2.__typename)) || object.__typename;
      if (typename === this.rootTypenamesById.ROOT_QUERY) {
        return ["ROOT_QUERY"];
      }
      var storeObject = partialContext && partialContext.storeObject || object;
      var context = __assign$2(__assign$2({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
        var options = normalizeReadFieldOptions(arguments, storeObject);
        return policies.readField(options, {
          store: policies.cache["data"],
          variables: options.variables
        });
      } });
      var id2;
      var policy = typename && this.getTypePolicy(typename);
      var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
      while (keyFn) {
        var specifierOrId = keyFn(__assign$2(__assign$2({}, object), storeObject), context);
        if (isArray(specifierOrId)) {
          keyFn = keyFieldsFnFromSpecifier(specifierOrId);
        } else {
          id2 = specifierOrId;
          break;
        }
      }
      id2 = id2 ? String(id2) : void 0;
      return context.keyObject ? [id2, context.keyObject] : [id2];
    };
    Policies2.prototype.addTypePolicies = function(typePolicies) {
      var _this = this;
      Object.keys(typePolicies).forEach(function(typename) {
        var _a2 = typePolicies[typename], queryType = _a2.queryType, mutationType = _a2.mutationType, subscriptionType = _a2.subscriptionType, incoming = __rest$2(_a2, ["queryType", "mutationType", "subscriptionType"]);
        if (queryType)
          _this.setRootTypename("Query", typename);
        if (mutationType)
          _this.setRootTypename("Mutation", typename);
        if (subscriptionType)
          _this.setRootTypename("Subscription", typename);
        if (hasOwn.call(_this.toBeAdded, typename)) {
          _this.toBeAdded[typename].push(incoming);
        } else {
          _this.toBeAdded[typename] = [incoming];
        }
      });
    };
    Policies2.prototype.updateTypePolicy = function(typename, incoming) {
      var _this = this;
      var existing = this.getTypePolicy(typename);
      var keyFields = incoming.keyFields, fields = incoming.fields;
      function setMerge(existing2, merge2) {
        existing2.merge = typeof merge2 === "function" ? merge2 : merge2 === true ? mergeTrueFn : merge2 === false ? mergeFalseFn : existing2.merge;
      }
      setMerge(existing, incoming.merge);
      existing.keyFn = // Pass false to disable normalization for this typename.
      keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
      if (fields) {
        Object.keys(fields).forEach(function(fieldName) {
          var existing2 = _this.getFieldPolicy(typename, fieldName, true);
          var incoming2 = fields[fieldName];
          if (typeof incoming2 === "function") {
            existing2.read = incoming2;
          } else {
            var keyArgs = incoming2.keyArgs, read2 = incoming2.read, merge2 = incoming2.merge;
            existing2.keyFn = // Pass false to disable argument-based differentiation of
            // field identities.
            keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
            if (typeof read2 === "function") {
              existing2.read = read2;
            }
            setMerge(existing2, merge2);
          }
          if (existing2.read && existing2.merge) {
            existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
          }
        });
      }
    };
    Policies2.prototype.setRootTypename = function(which, typename) {
      if (typename === void 0) {
        typename = which;
      }
      var rootId = "ROOT_" + which.toUpperCase();
      var old = this.rootTypenamesById[rootId];
      if (typename !== old) {
        invariant$2(!old || old === which, 5, which);
        if (old)
          delete this.rootIdsByTypename[old];
        this.rootIdsByTypename[typename] = rootId;
        this.rootTypenamesById[rootId] = typename;
      }
    };
    Policies2.prototype.addPossibleTypes = function(possibleTypes) {
      var _this = this;
      this.usingPossibleTypes = true;
      Object.keys(possibleTypes).forEach(function(supertype) {
        _this.getSupertypeSet(supertype, true);
        possibleTypes[supertype].forEach(function(subtype) {
          _this.getSupertypeSet(subtype, true).add(supertype);
          var match = subtype.match(TypeOrFieldNameRegExp);
          if (!match || match[0] !== subtype) {
            _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
          }
        });
      });
    };
    Policies2.prototype.getTypePolicy = function(typename) {
      var _this = this;
      if (!hasOwn.call(this.typePolicies, typename)) {
        var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
        policy_1.fields = /* @__PURE__ */ Object.create(null);
        var supertypes_1 = this.supertypeMap.get(typename);
        if (!supertypes_1 && this.fuzzySubtypes.size) {
          supertypes_1 = this.getSupertypeSet(typename, true);
          this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
            if (regExp.test(typename)) {
              var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
              if (fuzzySupertypes) {
                fuzzySupertypes.forEach(function(supertype) {
                  return supertypes_1.add(supertype);
                });
              }
            }
          });
        }
        if (supertypes_1 && supertypes_1.size) {
          supertypes_1.forEach(function(supertype) {
            var _a2 = _this.getTypePolicy(supertype), fields = _a2.fields, rest = __rest$2(_a2, ["fields"]);
            Object.assign(policy_1, rest);
            Object.assign(policy_1.fields, fields);
          });
        }
      }
      var inbox = this.toBeAdded[typename];
      if (inbox && inbox.length) {
        inbox.splice(0).forEach(function(policy) {
          _this.updateTypePolicy(typename, policy);
        });
      }
      return this.typePolicies[typename];
    };
    Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
      if (typename) {
        var fieldPolicies = this.getTypePolicy(typename).fields;
        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
      }
    };
    Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
      var supertypeSet = this.supertypeMap.get(subtype);
      if (!supertypeSet && createIfMissing) {
        this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
      }
      return supertypeSet;
    };
    Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {
      var _this = this;
      if (!fragment.typeCondition)
        return true;
      if (!typename)
        return false;
      var supertype = fragment.typeCondition.name.value;
      if (typename === supertype)
        return true;
      if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
        var typenameSupertypeSet = this.getSupertypeSet(typename, true);
        var workQueue_1 = [typenameSupertypeSet];
        var maybeEnqueue_1 = function(subtype) {
          var supertypeSet2 = _this.getSupertypeSet(subtype, false);
          if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
            workQueue_1.push(supertypeSet2);
          }
        };
        var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
        var checkingFuzzySubtypes = false;
        for (var i2 = 0; i2 < workQueue_1.length; ++i2) {
          var supertypeSet = workQueue_1[i2];
          if (supertypeSet.has(supertype)) {
            if (!typenameSupertypeSet.has(supertype)) {
              if (checkingFuzzySubtypes) {
                globalThis.__DEV__ !== false && invariant$2.warn(6, typename, supertype);
              }
              typenameSupertypeSet.add(supertype);
            }
            return true;
          }
          supertypeSet.forEach(maybeEnqueue_1);
          if (needToCheckFuzzySubtypes && // Start checking fuzzy subtypes only after exhausting all
          // non-fuzzy subtypes (after the final iteration of the loop).
          i2 === workQueue_1.length - 1 && // We could wait to compare fragment.selectionSet to result
          // after we verify the supertype, but this check is often less
          // expensive than that search, and we will have to do the
          // comparison anyway whenever we find a potential match.
          selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
            needToCheckFuzzySubtypes = false;
            checkingFuzzySubtypes = true;
            this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
              var match = typename.match(regExp);
              if (match && match[0] === typename) {
                maybeEnqueue_1(fuzzyString);
              }
            });
          }
        }
      }
      return false;
    };
    Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return !!(policy && policy.keyFn);
    };
    Policies2.prototype.getStoreFieldName = function(fieldSpec) {
      var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
      var policy = this.getFieldPolicy(typename, fieldName, false);
      var storeFieldName;
      var keyFn = policy && policy.keyFn;
      if (keyFn && typename) {
        var context = {
          typename,
          fieldName,
          field: fieldSpec.field || null,
          variables: fieldSpec.variables
        };
        var args = argsFromFieldSpecifier(fieldSpec);
        while (keyFn) {
          var specifierOrString = keyFn(args, context);
          if (isArray(specifierOrString)) {
            keyFn = keyArgsFnFromSpecifier(specifierOrString);
          } else {
            storeFieldName = specifierOrString || fieldName;
            break;
          }
        }
      }
      if (storeFieldName === void 0) {
        storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
      }
      if (storeFieldName === false) {
        return fieldName;
      }
      return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
    };
    Policies2.prototype.readField = function(options, context) {
      var objectOrReference = options.from;
      if (!objectOrReference)
        return;
      var nameOrField = options.field || options.fieldName;
      if (!nameOrField)
        return;
      if (options.typename === void 0) {
        var typename = context.store.getFieldValue(objectOrReference, "__typename");
        if (typename)
          options.typename = typename;
      }
      var storeFieldName = this.getStoreFieldName(options);
      var fieldName = fieldNameFromStoreName(storeFieldName);
      var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
      var policy = this.getFieldPolicy(options.typename, fieldName, false);
      var read2 = policy && policy.read;
      if (read2) {
        var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
        return cacheSlot.withValue(this.cache, read2, [
          existing,
          readOptions
        ]);
      }
      return existing;
    };
    Policies2.prototype.getReadFunction = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return policy && policy.read;
    };
    Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
      var policy = this.getFieldPolicy(parentTypename, fieldName, false);
      var merge2 = policy && policy.merge;
      if (!merge2 && childTypename) {
        policy = this.getTypePolicy(childTypename);
        merge2 = policy && policy.merge;
      }
      return merge2;
    };
    Policies2.prototype.runMergeFunction = function(existing, incoming, _a2, context, storage) {
      var field = _a2.field, typename = _a2.typename, merge2 = _a2.merge;
      if (merge2 === mergeTrueFn) {
        return makeMergeObjectsFunction(context.store)(existing, incoming);
      }
      if (merge2 === mergeFalseFn) {
        return incoming;
      }
      if (context.overwrite) {
        existing = void 0;
      }
      return merge2(existing, incoming, makeFieldFunctionOptions(
        this,
        // Unlike options.readField for read functions, we do not fall
        // back to the current object if no foreignObjOrRef is provided,
        // because it's not clear what the current object should be for
        // merge functions: the (possibly undefined) existing object, or
        // the incoming object? If you think your merge function needs
        // to read sibling fields in order to produce a new value for
        // the current field, you might want to rethink your strategy,
        // because that's a recipe for making merge behavior sensitive
        // to the order in which fields are written into the cache.
        // However, readField(name, ref) is useful for merge functions
        // that need to deduplicate child objects and references.
        void 0,
        {
          typename,
          fieldName: field.name.value,
          field,
          variables: context.variables
        },
        context,
        storage || /* @__PURE__ */ Object.create(null)
      ));
    };
    return Policies2;
  }()
);
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
  var storeFieldName = policies.getStoreFieldName(fieldSpec);
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var variables = fieldSpec.variables || context.variables;
  var _a2 = context.store, toReference = _a2.toReference, canRead = _a2.canRead;
  return {
    args: argsFromFieldSpecifier(fieldSpec),
    field: fieldSpec.field || null,
    fieldName,
    storeFieldName,
    variables,
    isReference,
    toReference,
    storage,
    cache: policies.cache,
    canRead,
    readField: function() {
      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);
    },
    mergeObjects: makeMergeObjectsFunction(context.store)
  };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
  var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
  var options;
  if (typeof fieldNameOrOptions === "string") {
    options = {
      fieldName: fieldNameOrOptions,
      // Default to objectOrReference only when no second argument was
      // passed for the from parameter, not when undefined is explicitly
      // passed as the second argument.
      from: argc > 1 ? from2 : objectOrReference
    };
  } else {
    options = __assign$2({}, fieldNameOrOptions);
    if (!hasOwn.call(options, "from")) {
      options.from = objectOrReference;
    }
  }
  if (globalThis.__DEV__ !== false && options.from === void 0) {
    globalThis.__DEV__ !== false && invariant$2.warn(7, stringifyForDisplay(Array.from(readFieldArgs)));
  }
  if (void 0 === options.variables) {
    options.variables = variables;
  }
  return options;
}
function makeMergeObjectsFunction(store) {
  return function mergeObjects(existing, incoming) {
    if (isArray(existing) || isArray(incoming)) {
      throw newInvariantError(8);
    }
    if (isNonNullObject(existing) && isNonNullObject(incoming)) {
      var eType = store.getFieldValue(existing, "__typename");
      var iType = store.getFieldValue(incoming, "__typename");
      var typesDiffer = eType && iType && eType !== iType;
      if (typesDiffer) {
        return incoming;
      }
      if (isReference(existing) && storeValueIsStoreObject(incoming)) {
        store.merge(existing.__ref, incoming);
        return existing;
      }
      if (storeValueIsStoreObject(existing) && isReference(incoming)) {
        store.merge(existing, incoming.__ref);
        return incoming;
      }
      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
        return __assign$2(__assign$2({}, existing), incoming);
      }
    }
    return incoming;
  };
}
function getContextFlavor(context, clientOnly, deferred) {
  var key = "".concat(clientOnly).concat(deferred);
  var flavored = context.flavors.get(key);
  if (!flavored) {
    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign$2(__assign$2({}, context), { clientOnly, deferred }));
  }
  return flavored;
}
var StoreWriter = (
  /** @class */
  function() {
    function StoreWriter2(cache2, reader2, fragments) {
      this.cache = cache2;
      this.reader = reader2;
      this.fragments = fragments;
    }
    StoreWriter2.prototype.writeToStore = function(store, _a2) {
      var _this = this;
      var query = _a2.query, result = _a2.result, dataId = _a2.dataId, variables = _a2.variables, overwrite = _a2.overwrite;
      var operationDefinition = getOperationDefinition(query);
      var merger = makeProcessedFieldsMerger();
      variables = __assign$2(__assign$2({}, getDefaultValues(operationDefinition)), variables);
      var context = __assign$2(__assign$2({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
        return merger.merge(existing, incoming);
      }, variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
      var ref = this.processSelectionSet({
        result: result || /* @__PURE__ */ Object.create(null),
        dataId,
        selectionSet: operationDefinition.selectionSet,
        mergeTree: { map: /* @__PURE__ */ new Map() },
        context
      });
      if (!isReference(ref)) {
        throw newInvariantError(11, result);
      }
      context.incomingById.forEach(function(_a3, dataId2) {
        var storeObject = _a3.storeObject, mergeTree = _a3.mergeTree, fieldNodeSet = _a3.fieldNodeSet;
        var entityRef = makeReference(dataId2);
        if (mergeTree && mergeTree.map.size) {
          var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
          if (isReference(applied)) {
            return;
          }
          storeObject = applied;
        }
        if (globalThis.__DEV__ !== false && !context.overwrite) {
          var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
          fieldNodeSet.forEach(function(field) {
            if (field.selectionSet) {
              fieldsWithSelectionSets_1[field.name.value] = true;
            }
          });
          var hasSelectionSet_1 = function(storeFieldName) {
            return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
          };
          var hasMergeFunction_1 = function(storeFieldName) {
            var childTree = mergeTree && mergeTree.map.get(storeFieldName);
            return Boolean(childTree && childTree.info && childTree.info.merge);
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
              warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
            }
          });
        }
        store.merge(dataId2, storeObject);
      });
      store.retain(ref.__ref);
      return ref;
    };
    StoreWriter2.prototype.processSelectionSet = function(_a2) {
      var _this = this;
      var dataId = _a2.dataId, result = _a2.result, selectionSet = _a2.selectionSet, context = _a2.context, mergeTree = _a2.mergeTree;
      var policies = this.cache.policies;
      var incoming = /* @__PURE__ */ Object.create(null);
      var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, "__typename");
      if ("string" === typeof typename) {
        incoming.__typename = typename;
      }
      var readField = function() {
        var options = normalizeReadFieldOptions(arguments, incoming, context.variables);
        if (isReference(options.from)) {
          var info = context.incomingById.get(options.from.__ref);
          if (info) {
            var result_1 = policies.readField(__assign$2(__assign$2({}, options), { from: info.storeObject }), context);
            if (result_1 !== void 0) {
              return result_1;
            }
          }
        }
        return policies.readField(options, context);
      };
      var fieldNodeSet = /* @__PURE__ */ new Set();
      this.flattenFields(
        selectionSet,
        result,
        // This WriteContext will be the default context value for fields returned
        // by the flattenFields method, but some fields may be assigned a modified
        // context, depending on the presence of @client and other directives.
        context,
        typename
      ).forEach(function(context2, field) {
        var _a3;
        var resultFieldKey = resultKeyNameFromField(field);
        var value = result[resultFieldKey];
        fieldNodeSet.add(field);
        if (value !== void 0) {
          var storeFieldName = policies.getStoreFieldName({
            typename,
            fieldName: field.name.value,
            field,
            variables: context2.variables
          });
          var childTree = getChildMergeTree(mergeTree, storeFieldName);
          var incomingValue = _this.processFieldValue(
            value,
            field,
            // Reset context.clientOnly and context.deferred to their default
            // values before processing nested selection sets.
            field.selectionSet ? getContextFlavor(context2, false, false) : context2,
            childTree
          );
          var childTypename = void 0;
          if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
            childTypename = readField("__typename", incomingValue);
          }
          var merge2 = policies.getMergeFunction(typename, field.name.value, childTypename);
          if (merge2) {
            childTree.info = {
              // TODO Check compatibility against any existing childTree.field?
              field,
              typename,
              merge: merge2
            };
          } else {
            maybeRecycleChildMergeTree(mergeTree, storeFieldName);
          }
          incoming = context2.merge(incoming, (_a3 = {}, _a3[storeFieldName] = incomingValue, _a3));
        } else if (globalThis.__DEV__ !== false && !context2.clientOnly && !context2.deferred && !addTypenameToDocument.added(field) && // If the field has a read function, it may be a synthetic field or
        // provide a default value, so its absence from the written data should
        // not be cause for alarm.
        !policies.getReadFunction(typename, field.name.value)) {
          globalThis.__DEV__ !== false && invariant$2.error(12, resultKeyNameFromField(field), result);
        }
      });
      try {
        var _b = policies.identify(result, {
          typename,
          selectionSet,
          fragmentMap: context.fragmentMap,
          storeObject: incoming,
          readField
        }), id2 = _b[0], keyObject = _b[1];
        dataId = dataId || id2;
        if (keyObject) {
          incoming = context.merge(incoming, keyObject);
        }
      } catch (e2) {
        if (!dataId)
          throw e2;
      }
      if ("string" === typeof dataId) {
        var dataRef = makeReference(dataId);
        var sets = context.written[dataId] || (context.written[dataId] = []);
        if (sets.indexOf(selectionSet) >= 0)
          return dataRef;
        sets.push(selectionSet);
        if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {
          return dataRef;
        }
        var previous_1 = context.incomingById.get(dataId);
        if (previous_1) {
          previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
          previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
          fieldNodeSet.forEach(function(field) {
            return previous_1.fieldNodeSet.add(field);
          });
        } else {
          context.incomingById.set(dataId, {
            storeObject: incoming,
            // Save a reference to mergeTree only if it is not empty, because
            // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
            // reused for entirely different parts of the result tree.
            mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
            fieldNodeSet
          });
        }
        return dataRef;
      }
      return incoming;
    };
    StoreWriter2.prototype.processFieldValue = function(value, field, context, mergeTree) {
      var _this = this;
      if (!field.selectionSet || value === null) {
        return globalThis.__DEV__ !== false ? cloneDeep(value) : value;
      }
      if (isArray(value)) {
        return value.map(function(item, i2) {
          var value2 = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i2));
          maybeRecycleChildMergeTree(mergeTree, i2);
          return value2;
        });
      }
      return this.processSelectionSet({
        result: value,
        selectionSet: field.selectionSet,
        context,
        mergeTree
      });
    };
    StoreWriter2.prototype.flattenFields = function(selectionSet, result, context, typename) {
      if (typename === void 0) {
        typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);
      }
      var fieldMap = /* @__PURE__ */ new Map();
      var policies = this.cache.policies;
      var limitingTrie = new Trie$1(false);
      (function flatten(selectionSet2, inheritedContext) {
        var visitedNode = limitingTrie.lookup(
          selectionSet2,
          // Because we take inheritedClientOnly and inheritedDeferred into
          // consideration here (in addition to selectionSet), it's possible for
          // the same selection set to be flattened more than once, if it appears
          // in the query with different @client and/or @directive configurations.
          inheritedContext.clientOnly,
          inheritedContext.deferred
        );
        if (visitedNode.visited)
          return;
        visitedNode.visited = true;
        selectionSet2.selections.forEach(function(selection) {
          if (!shouldInclude(selection, context.variables))
            return;
          var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
          if (
            // Since the presence of @client or @defer on this field can only
            // cause clientOnly or deferred to become true, we can skip the
            // forEach loop if both clientOnly and deferred are already true.
            !(clientOnly && deferred) && isNonEmptyArray(selection.directives)
          ) {
            selection.directives.forEach(function(dir) {
              var name2 = dir.name.value;
              if (name2 === "client")
                clientOnly = true;
              if (name2 === "defer") {
                var args = argumentsObjectFromField(dir, context.variables);
                if (!args || args.if !== false) {
                  deferred = true;
                }
              }
            });
          }
          if (isField(selection)) {
            var existing = fieldMap.get(selection);
            if (existing) {
              clientOnly = clientOnly && existing.clientOnly;
              deferred = deferred && existing.deferred;
            }
            fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
          } else {
            var fragment = getFragmentFromSelection(selection, context.lookupFragment);
            if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
              throw newInvariantError(13, selection.name.value);
            }
            if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {
              flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
            }
          }
        });
      })(selectionSet, context);
      return fieldMap;
    };
    StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {
      var _a2;
      var _this = this;
      if (mergeTree.map.size && !isReference(incoming)) {
        var e_1 = (
          // Items in the same position in different arrays are not
          // necessarily related to each other, so when incoming is an array
          // we process its elements as if there was no existing data.
          !isArray(incoming) && // Likewise, existing must be either a Reference or a StoreObject
          // in order for its fields to be safe to merge with the fields of
          // the incoming object.
          (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0
        );
        var i_1 = incoming;
        if (e_1 && !getStorageArgs) {
          getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
        }
        var changedFields_1;
        var getValue_1 = function(from2, name2) {
          return isArray(from2) ? typeof name2 === "number" ? from2[name2] : void 0 : context.store.getFieldValue(from2, String(name2));
        };
        mergeTree.map.forEach(function(childTree, storeFieldName) {
          var eVal = getValue_1(e_1, storeFieldName);
          var iVal = getValue_1(i_1, storeFieldName);
          if (void 0 === iVal)
            return;
          if (getStorageArgs) {
            getStorageArgs.push(storeFieldName);
          }
          var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
          if (aVal !== iVal) {
            changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
            changedFields_1.set(storeFieldName, aVal);
          }
          if (getStorageArgs) {
            invariant$2(getStorageArgs.pop() === storeFieldName);
          }
        });
        if (changedFields_1) {
          incoming = isArray(i_1) ? i_1.slice(0) : __assign$2({}, i_1);
          changedFields_1.forEach(function(value, name2) {
            incoming[name2] = value;
          });
        }
      }
      if (mergeTree.info) {
        return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a2 = context.store).getStorage.apply(_a2, getStorageArgs));
      }
      return incoming;
    };
    return StoreWriter2;
  }()
);
var emptyMergeTreePool = [];
function getChildMergeTree(_a2, name2) {
  var map2 = _a2.map;
  if (!map2.has(name2)) {
    map2.set(name2, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
  }
  return map2.get(name2);
}
function mergeMergeTrees(left, right) {
  if (left === right || !right || mergeTreeIsEmpty(right))
    return left;
  if (!left || mergeTreeIsEmpty(left))
    return right;
  var info = left.info && right.info ? __assign$2(__assign$2({}, left.info), right.info) : left.info || right.info;
  var needToMergeMaps = left.map.size && right.map.size;
  var map2 = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
  var merged = { info, map: map2 };
  if (needToMergeMaps) {
    var remainingRightKeys_1 = new Set(right.map.keys());
    left.map.forEach(function(leftTree, key) {
      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
      remainingRightKeys_1.delete(key);
    });
    remainingRightKeys_1.forEach(function(key) {
      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
    });
  }
  return merged;
}
function mergeTreeIsEmpty(tree2) {
  return !tree2 || !(tree2.info || tree2.map.size);
}
function maybeRecycleChildMergeTree(_a2, name2) {
  var map2 = _a2.map;
  var childTree = map2.get(name2);
  if (childTree && mergeTreeIsEmpty(childTree)) {
    emptyMergeTreePool.push(childTree);
    map2.delete(name2);
  }
}
var warnings = /* @__PURE__ */ new Set();
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
  var getChild = function(objOrRef) {
    var child = store.getFieldValue(objOrRef, storeFieldName);
    return typeof child === "object" && child;
  };
  var existing = getChild(existingRef);
  if (!existing)
    return;
  var incoming = getChild(incomingObj);
  if (!incoming)
    return;
  if (isReference(existing))
    return;
  if (equal$2(existing, incoming))
    return;
  if (Object.keys(existing).every(function(key) {
    return store.getFieldValue(incoming, key) !== void 0;
  })) {
    return;
  }
  var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var typeDotName = "".concat(parentType, ".").concat(fieldName);
  if (warnings.has(typeDotName))
    return;
  warnings.add(typeDotName);
  var childTypenames = [];
  if (!isArray(existing) && !isArray(incoming)) {
    [existing, incoming].forEach(function(child) {
      var typename = store.getFieldValue(child, "__typename");
      if (typeof typename === "string" && !childTypenames.includes(typename)) {
        childTypenames.push(typename);
      }
    });
  }
  globalThis.__DEV__ !== false && invariant$2.warn(14, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, existing, incoming);
}
var InMemoryCache = (
  /** @class */
  function(_super) {
    __extends$1(InMemoryCache2, _super);
    function InMemoryCache2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      var _this = _super.call(this) || this;
      _this.watches = /* @__PURE__ */ new Set();
      _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);
      _this.assumeImmutableResults = true;
      _this.makeVar = makeVar;
      _this.txCount = 0;
      _this.config = normalizeConfig(config2);
      _this.addTypename = !!_this.config.addTypename;
      _this.policies = new Policies({
        cache: _this,
        dataIdFromObject: _this.config.dataIdFromObject,
        possibleTypes: _this.config.possibleTypes,
        typePolicies: _this.config.typePolicies
      });
      _this.init();
      return _this;
    }
    InMemoryCache2.prototype.init = function() {
      var rootStore = this.data = new EntityStore.Root({
        policies: this.policies,
        resultCaching: this.config.resultCaching
      });
      this.optimisticData = rootStore.stump;
      this.resetResultCache();
    };
    InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
      var _this = this;
      var previousReader = this.storeReader;
      var fragments = this.config.fragments;
      this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
        cache: this,
        addTypename: this.addTypename,
        resultCacheMaxSize: this.config.resultCacheMaxSize,
        canonizeResults: shouldCanonizeResults(this.config),
        canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
        fragments
      }), fragments);
      this.maybeBroadcastWatch = wrap(function(c2, options) {
        return _this.broadcastWatch(c2, options);
      }, {
        max: this.config.resultCacheMaxSize,
        makeCacheKey: function(c2) {
          var store = c2.optimistic ? _this.optimisticData : _this.data;
          if (supportsResultCaching(store)) {
            var optimistic = c2.optimistic, id2 = c2.id, variables = c2.variables;
            return store.makeCacheKey(
              c2.query,
              // Different watches can have the same query, optimistic
              // status, rootId, and variables, but if their callbacks are
              // different, the (identical) result needs to be delivered to
              // each distinct callback. The easiest way to achieve that
              // separation is to include c.callback in the cache key for
              // maybeBroadcastWatch calls. See issue #5733.
              c2.callback,
              canonicalStringify({ optimistic, id: id2, variables })
            );
          }
        }
      });
      (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(group) {
        return group.resetCaching();
      });
    };
    InMemoryCache2.prototype.restore = function(data2) {
      this.init();
      if (data2)
        this.data.replace(data2);
      return this;
    };
    InMemoryCache2.prototype.extract = function(optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return (optimistic ? this.optimisticData : this.data).extract();
    };
    InMemoryCache2.prototype.read = function(options) {
      var _a2 = options.returnPartialData, returnPartialData = _a2 === void 0 ? false : _a2;
      try {
        return this.storeReader.diffQueryAgainstStore(__assign$2(__assign$2({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
      } catch (e2) {
        if (e2 instanceof MissingFieldError) {
          return null;
        }
        throw e2;
      }
    };
    InMemoryCache2.prototype.write = function(options) {
      try {
        ++this.txCount;
        return this.storeWriter.writeToStore(this.data, options);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.modify = function(options) {
      if (hasOwn.call(options, "id") && !options.id) {
        return false;
      }
      var store = options.optimistic ? this.optimisticData : this.data;
      try {
        ++this.txCount;
        return store.modify(options.id || "ROOT_QUERY", options.fields);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.diff = function(options) {
      return this.storeReader.diffQueryAgainstStore(__assign$2(__assign$2({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
    };
    InMemoryCache2.prototype.watch = function(watch2) {
      var _this = this;
      if (!this.watches.size) {
        recallCache(this);
      }
      this.watches.add(watch2);
      if (watch2.immediate) {
        this.maybeBroadcastWatch(watch2);
      }
      return function() {
        if (_this.watches.delete(watch2) && !_this.watches.size) {
          forgetCache(_this);
        }
        _this.maybeBroadcastWatch.forget(watch2);
      };
    };
    InMemoryCache2.prototype.gc = function(options) {
      canonicalStringify.reset();
      var ids = this.optimisticData.gc();
      if (options && !this.txCount) {
        if (options.resetResultCache) {
          this.resetResultCache(options.resetResultIdentities);
        } else if (options.resetResultIdentities) {
          this.storeReader.resetCanon();
        }
      }
      return ids;
    };
    InMemoryCache2.prototype.retain = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).retain(rootId);
    };
    InMemoryCache2.prototype.release = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).release(rootId);
    };
    InMemoryCache2.prototype.identify = function(object) {
      if (isReference(object))
        return object.__ref;
      try {
        return this.policies.identify(object)[0];
      } catch (e2) {
        globalThis.__DEV__ !== false && invariant$2.warn(e2);
      }
    };
    InMemoryCache2.prototype.evict = function(options) {
      if (!options.id) {
        if (hasOwn.call(options, "id")) {
          return false;
        }
        options = __assign$2(__assign$2({}, options), { id: "ROOT_QUERY" });
      }
      try {
        ++this.txCount;
        return this.optimisticData.evict(options, this.data);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.reset = function(options) {
      var _this = this;
      this.init();
      canonicalStringify.reset();
      if (options && options.discardWatches) {
        this.watches.forEach(function(watch2) {
          return _this.maybeBroadcastWatch.forget(watch2);
        });
        this.watches.clear();
        forgetCache(this);
      } else {
        this.broadcastWatches();
      }
      return Promise.resolve();
    };
    InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
      var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
      if (newOptimisticData !== this.optimisticData) {
        this.optimisticData = newOptimisticData;
        this.broadcastWatches();
      }
    };
    InMemoryCache2.prototype.batch = function(options) {
      var _this = this;
      var update = options.update, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
      var updateResult;
      var perform = function(layer) {
        var _a3 = _this, data2 = _a3.data, optimisticData = _a3.optimisticData;
        ++_this.txCount;
        if (layer) {
          _this.data = _this.optimisticData = layer;
        }
        try {
          return updateResult = update(_this);
        } finally {
          --_this.txCount;
          _this.data = data2;
          _this.optimisticData = optimisticData;
        }
      };
      var alreadyDirty = /* @__PURE__ */ new Set();
      if (onWatchUpdated && !this.txCount) {
        this.broadcastWatches(__assign$2(__assign$2({}, options), { onWatchUpdated: function(watch2) {
          alreadyDirty.add(watch2);
          return false;
        } }));
      }
      if (typeof optimistic === "string") {
        this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
      } else if (optimistic === false) {
        perform(this.data);
      } else {
        perform();
      }
      if (typeof removeOptimistic === "string") {
        this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
      }
      if (onWatchUpdated && alreadyDirty.size) {
        this.broadcastWatches(__assign$2(__assign$2({}, options), { onWatchUpdated: function(watch2, diff) {
          var result = onWatchUpdated.call(this, watch2, diff);
          if (result !== false) {
            alreadyDirty.delete(watch2);
          }
          return result;
        } }));
        if (alreadyDirty.size) {
          alreadyDirty.forEach(function(watch2) {
            return _this.maybeBroadcastWatch.dirty(watch2);
          });
        }
      } else {
        this.broadcastWatches(options);
      }
      return updateResult;
    };
    InMemoryCache2.prototype.performTransaction = function(update, optimisticId) {
      return this.batch({
        update,
        optimistic: optimisticId || optimisticId !== null
      });
    };
    InMemoryCache2.prototype.transformDocument = function(document2) {
      return this.addTypenameToDocument(this.addFragmentsToDocument(document2));
    };
    InMemoryCache2.prototype.broadcastWatches = function(options) {
      var _this = this;
      if (!this.txCount) {
        this.watches.forEach(function(c2) {
          return _this.maybeBroadcastWatch(c2, options);
        });
      }
    };
    InMemoryCache2.prototype.addFragmentsToDocument = function(document2) {
      var fragments = this.config.fragments;
      return fragments ? fragments.transform(document2) : document2;
    };
    InMemoryCache2.prototype.addTypenameToDocument = function(document2) {
      if (this.addTypename) {
        return this.addTypenameTransform.transformDocument(document2);
      }
      return document2;
    };
    InMemoryCache2.prototype.broadcastWatch = function(c2, options) {
      var lastDiff = c2.lastDiff;
      var diff = this.diff(c2);
      if (options) {
        if (c2.optimistic && typeof options.optimistic === "string") {
          diff.fromOptimisticTransaction = true;
        }
        if (options.onWatchUpdated && options.onWatchUpdated.call(this, c2, diff, lastDiff) === false) {
          return;
        }
      }
      if (!lastDiff || !equal$2(lastDiff.result, diff.result)) {
        c2.callback(c2.lastDiff = diff, lastDiff);
      }
    };
    return InMemoryCache2;
  }(ApolloCache)
);
var NetworkStatus;
(function(NetworkStatus2) {
  NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
  NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
  NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
  NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
  NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
  NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
  NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
  return networkStatus ? networkStatus < 7 : false;
}
function equalByQuery(query, _a2, _b, variables) {
  var aData = _a2.data, aRest = __rest$2(_a2, ["data"]);
  var bData = _b.data, bRest = __rest$2(_b, ["data"]);
  return equal$2(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {
    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),
    variables
  });
}
function equalBySelectionSet(selectionSet, aResult, bResult, context) {
  if (aResult === bResult) {
    return true;
  }
  var seenSelections = /* @__PURE__ */ new Set();
  return selectionSet.selections.every(function(selection) {
    if (seenSelections.has(selection))
      return true;
    seenSelections.add(selection);
    if (!shouldInclude(selection, context.variables))
      return true;
    if (selectionHasNonreactiveDirective(selection))
      return true;
    if (isField(selection)) {
      var resultKey = resultKeyNameFromField(selection);
      var aResultChild = aResult && aResult[resultKey];
      var bResultChild = bResult && bResult[resultKey];
      var childSelectionSet = selection.selectionSet;
      if (!childSelectionSet) {
        return equal$2(aResultChild, bResultChild);
      }
      var aChildIsArray = Array.isArray(aResultChild);
      var bChildIsArray = Array.isArray(bResultChild);
      if (aChildIsArray !== bChildIsArray)
        return false;
      if (aChildIsArray && bChildIsArray) {
        var length_1 = aResultChild.length;
        if (bResultChild.length !== length_1) {
          return false;
        }
        for (var i2 = 0; i2 < length_1; ++i2) {
          if (!equalBySelectionSet(childSelectionSet, aResultChild[i2], bResultChild[i2], context)) {
            return false;
          }
        }
        return true;
      }
      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);
    } else {
      var fragment = getFragmentFromSelection(selection, context.fragmentMap);
      if (fragment) {
        if (selectionHasNonreactiveDirective(fragment))
          return true;
        return equalBySelectionSet(
          fragment.selectionSet,
          // Notice that we reuse the same aResult and bResult values here,
          // since the fragment ...spread does not specify a field name, but
          // consists of multiple fields (within the fragment's selection set)
          // that should be applied to the current result value(s).
          aResult,
          bResult,
          context
        );
      }
    }
  });
}
function selectionHasNonreactiveDirective(selection) {
  return !!selection.directives && selection.directives.some(directiveIsNonreactive);
}
function directiveIsNonreactive(dir) {
  return dir.name.value === "nonreactive";
}
var assign$1 = Object.assign, hasOwnProperty$2 = Object.hasOwnProperty;
var ObservableQuery = (
  /** @class */
  function(_super) {
    __extends$1(ObservableQuery2, _super);
    function ObservableQuery2(_a2) {
      var queryManager = _a2.queryManager, queryInfo = _a2.queryInfo, options = _a2.options;
      var _this = _super.call(this, function(observer) {
        try {
          var subObserver = observer._subscription._observer;
          if (subObserver && !subObserver.error) {
            subObserver.error = defaultSubscriptionObserverErrorCallback;
          }
        } catch (_a3) {
        }
        var first = !_this.observers.size;
        _this.observers.add(observer);
        var last2 = _this.last;
        if (last2 && last2.error) {
          observer.error && observer.error(last2.error);
        } else if (last2 && last2.result) {
          observer.next && observer.next(last2.result);
        }
        if (first) {
          _this.reobserve().catch(function() {
          });
        }
        return function() {
          if (_this.observers.delete(observer) && !_this.observers.size) {
            _this.tearDownQuery();
          }
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.subscriptions = /* @__PURE__ */ new Set();
      _this.queryInfo = queryInfo;
      _this.queryManager = queryManager;
      _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);
      _this.isTornDown = false;
      var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
      var _e2 = options.fetchPolicy, fetchPolicy = _e2 === void 0 ? defaultFetchPolicy : _e2, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
      _this.options = __assign$2(__assign$2({}, options), {
        // Remember the initial options.fetchPolicy so we can revert back to this
        // policy when variables change. This information can also be specified
        // (or overridden) by providing options.initialFetchPolicy explicitly.
        initialFetchPolicy,
        // This ensures this.options.fetchPolicy always has a string value, in
        // case options.fetchPolicy was not provided.
        fetchPolicy
      });
      _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
      var opDef = getOperationDefinition(_this.query);
      _this.queryName = opDef && opDef.name && opDef.name.value;
      return _this;
    }
    Object.defineProperty(ObservableQuery2.prototype, "query", {
      // The `query` computed property will always reflect the document transformed
      // by the last run query. `this.options.query` will always reflect the raw
      // untransformed query to ensure document transforms with runtime conditionals
      // are run on the original document.
      get: function() {
        return this.lastQuery || this.options.query;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObservableQuery2.prototype, "variables", {
      // Computed shorthand for this.options.variables, preserved for
      // backwards compatibility.
      get: function() {
        return this.options.variables;
      },
      enumerable: false,
      configurable: true
    });
    ObservableQuery2.prototype.result = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var observer = {
          next: function(result) {
            resolve(result);
            _this.observers.delete(observer);
            if (!_this.observers.size) {
              _this.queryManager.removeQuery(_this.queryId);
            }
            setTimeout(function() {
              subscription.unsubscribe();
            }, 0);
          },
          error: reject
        };
        var subscription = _this.subscribe(observer);
      });
    };
    ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
      if (saveAsLastResult === void 0) {
        saveAsLastResult = true;
      }
      var lastResult = this.getLastResult(true);
      var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
      var result = __assign$2(__assign$2({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
      var _a2 = this.options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2;
      if (
        // These fetch policies should never deliver data from the cache, unless
        // redelivering a previously delivered result.
        skipCacheDataFor(fetchPolicy) || // If this.options.query has @client(always: true) fields, we cannot
        // trust diff.result, since it was read from the cache without running
        // local resolvers (and it's too late to run resolvers now, since we must
        // return a result synchronously).
        this.queryManager.getDocumentInfo(this.query).hasForcedResolvers
      )
        ;
      else if (this.waitForOwnResult) {
        this.queryInfo["updateWatch"]();
      } else {
        var diff = this.queryInfo.getDiff();
        if (diff.complete || this.options.returnPartialData) {
          result.data = diff.result;
        }
        if (equal$2(result.data, {})) {
          result.data = void 0;
        }
        if (diff.complete) {
          delete result.partial;
          if (diff.complete && result.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
            result.networkStatus = NetworkStatus.ready;
            result.loading = false;
          }
        } else {
          result.partial = true;
        }
        if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
          logMissingFieldErrors(diff.missing);
        }
      }
      if (saveAsLastResult) {
        this.updateLastResult(result);
      }
      return result;
    };
    ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {
      if (!this.last) {
        return true;
      }
      var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !equalByQuery(this.query, this.last.result, newResult, this.variables) : !equal$2(this.last.result, newResult);
      return resultIsDifferent || variables && !equal$2(this.last.variables, variables);
    };
    ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
      var last2 = this.last;
      if (last2 && last2[key] && (!variablesMustMatch || equal$2(last2.variables, this.variables))) {
        return last2[key];
      }
    };
    ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
      return this.getLast("result", variablesMustMatch);
    };
    ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
      return this.getLast("error", variablesMustMatch);
    };
    ObservableQuery2.prototype.resetLastResults = function() {
      delete this.last;
      this.isTornDown = false;
    };
    ObservableQuery2.prototype.resetQueryStoreErrors = function() {
      this.queryManager.resetErrors(this.queryId);
    };
    ObservableQuery2.prototype.refetch = function(variables) {
      var _a2;
      var reobserveOptions = {
        // Always disable polling for refetches.
        pollInterval: 0
      };
      var fetchPolicy = this.options.fetchPolicy;
      if (fetchPolicy === "cache-and-network") {
        reobserveOptions.fetchPolicy = fetchPolicy;
      } else if (fetchPolicy === "no-cache") {
        reobserveOptions.fetchPolicy = "no-cache";
      } else {
        reobserveOptions.fetchPolicy = "network-only";
      }
      if (globalThis.__DEV__ !== false && variables && hasOwnProperty$2.call(variables, "variables")) {
        var queryDef = getQueryDefinition(this.query);
        var vars = queryDef.variableDefinitions;
        if (!vars || !vars.some(function(v2) {
          return v2.variable.name.value === "variables";
        })) {
          globalThis.__DEV__ !== false && invariant$2.warn(
            20,
            variables,
            ((_a2 = queryDef.name) === null || _a2 === void 0 ? void 0 : _a2.value) || queryDef
          );
        }
      }
      if (variables && !equal$2(this.options.variables, variables)) {
        reobserveOptions.variables = this.options.variables = __assign$2(__assign$2({}, this.options.variables), variables);
      }
      this.queryInfo.resetLastWrite();
      return this.reobserve(reobserveOptions, NetworkStatus.refetch);
    };
    ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
      var _this = this;
      var combinedOptions = __assign$2(__assign$2({}, fetchMoreOptions.query ? fetchMoreOptions : __assign$2(__assign$2(__assign$2(__assign$2({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign$2(__assign$2({}, this.options.variables), fetchMoreOptions.variables) })), {
        // The fetchMore request goes immediately to the network and does
        // not automatically write its result to the cache (hence no-cache
        // instead of network-only), because we allow the caller of
        // fetchMore to provide an updateQuery callback that determines how
        // the data gets written to the cache.
        fetchPolicy: "no-cache"
      });
      combinedOptions.query = this.transformDocument(combinedOptions.query);
      var qid = this.queryManager.generateQueryId();
      this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
      var queryInfo = this.queryInfo;
      var originalNetworkStatus = queryInfo.networkStatus;
      queryInfo.networkStatus = NetworkStatus.fetchMore;
      if (combinedOptions.notifyOnNetworkStatusChange) {
        this.observe();
      }
      var updatedQuerySet = /* @__PURE__ */ new Set();
      return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
        _this.queryManager.removeQuery(qid);
        if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
          queryInfo.networkStatus = originalNetworkStatus;
        }
        _this.queryManager.cache.batch({
          update: function(cache2) {
            var updateQuery = fetchMoreOptions.updateQuery;
            if (updateQuery) {
              cache2.updateQuery({
                query: _this.query,
                variables: _this.variables,
                returnPartialData: true,
                optimistic: false
              }, function(previous) {
                return updateQuery(previous, {
                  fetchMoreResult: fetchMoreResult.data,
                  variables: combinedOptions.variables
                });
              });
            } else {
              cache2.writeQuery({
                query: combinedOptions.query,
                variables: combinedOptions.variables,
                data: fetchMoreResult.data
              });
            }
          },
          onWatchUpdated: function(watch2) {
            updatedQuerySet.add(watch2.query);
          }
        });
        return fetchMoreResult;
      }).finally(function() {
        if (!updatedQuerySet.has(_this.query)) {
          reobserveCacheFirst(_this);
        }
      });
    };
    ObservableQuery2.prototype.subscribeToMore = function(options) {
      var _this = this;
      var subscription = this.queryManager.startGraphQLSubscription({
        query: options.document,
        variables: options.variables,
        context: options.context
      }).subscribe({
        next: function(subscriptionData) {
          var updateQuery = options.updateQuery;
          if (updateQuery) {
            _this.updateQuery(function(previous, _a2) {
              var variables = _a2.variables;
              return updateQuery(previous, {
                subscriptionData,
                variables
              });
            });
          }
        },
        error: function(err) {
          if (options.onError) {
            options.onError(err);
            return;
          }
          globalThis.__DEV__ !== false && invariant$2.error(21, err);
        }
      });
      this.subscriptions.add(subscription);
      return function() {
        if (_this.subscriptions.delete(subscription)) {
          subscription.unsubscribe();
        }
      };
    };
    ObservableQuery2.prototype.setOptions = function(newOptions) {
      return this.reobserve(newOptions);
    };
    ObservableQuery2.prototype.silentSetOptions = function(newOptions) {
      var mergedOptions = compact(this.options, newOptions || {});
      assign$1(this.options, mergedOptions);
    };
    ObservableQuery2.prototype.setVariables = function(variables) {
      if (equal$2(this.variables, variables)) {
        return this.observers.size ? this.result() : Promise.resolve();
      }
      this.options.variables = variables;
      if (!this.observers.size) {
        return Promise.resolve();
      }
      return this.reobserve({
        // Reset options.fetchPolicy to its original value.
        fetchPolicy: this.options.initialFetchPolicy,
        variables
      }, NetworkStatus.setVariables);
    };
    ObservableQuery2.prototype.updateQuery = function(mapFn) {
      var queryManager = this.queryManager;
      var result = queryManager.cache.diff({
        query: this.options.query,
        variables: this.variables,
        returnPartialData: true,
        optimistic: false
      }).result;
      var newResult = mapFn(result, {
        variables: this.variables
      });
      if (newResult) {
        queryManager.cache.writeQuery({
          query: this.options.query,
          data: newResult,
          variables: this.variables
        });
        queryManager.broadcastQueries();
      }
    };
    ObservableQuery2.prototype.startPolling = function(pollInterval) {
      this.options.pollInterval = pollInterval;
      this.updatePolling();
    };
    ObservableQuery2.prototype.stopPolling = function() {
      this.options.pollInterval = 0;
      this.updatePolling();
    };
    ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {
      if (options.nextFetchPolicy) {
        var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
        if (fetchPolicy === "standby")
          ;
        else if (typeof options.nextFetchPolicy === "function") {
          options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
            reason,
            options,
            observable: this,
            initialFetchPolicy
          });
        } else if (reason === "variables-changed") {
          options.fetchPolicy = initialFetchPolicy;
        } else {
          options.fetchPolicy = options.nextFetchPolicy;
        }
      }
      return options.fetchPolicy;
    };
    ObservableQuery2.prototype.fetch = function(options, newNetworkStatus, query) {
      this.queryManager.setObservableQuery(this);
      return this.queryManager["fetchConcastWithInfo"](this.queryId, options, newNetworkStatus, query);
    };
    ObservableQuery2.prototype.updatePolling = function() {
      var _this = this;
      if (this.queryManager.ssrMode) {
        return;
      }
      var _a2 = this, pollingInfo = _a2.pollingInfo, pollInterval = _a2.options.pollInterval;
      if (!pollInterval) {
        if (pollingInfo) {
          clearTimeout(pollingInfo.timeout);
          delete this.pollingInfo;
        }
        return;
      }
      if (pollingInfo && pollingInfo.interval === pollInterval) {
        return;
      }
      invariant$2(pollInterval, 22);
      var info = pollingInfo || (this.pollingInfo = {});
      info.interval = pollInterval;
      var maybeFetch = function() {
        if (_this.pollingInfo) {
          if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {
            _this.reobserve({
              // Most fetchPolicy options don't make sense to use in a polling context, as
              // users wouldn't want to be polling the cache directly. However, network-only and
              // no-cache are both useful for when the user wants to control whether or not the
              // polled results are written to the cache.
              fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
            }, NetworkStatus.poll).then(poll2, poll2);
          } else {
            poll2();
          }
        }
      };
      var poll2 = function() {
        var info2 = _this.pollingInfo;
        if (info2) {
          clearTimeout(info2.timeout);
          info2.timeout = setTimeout(maybeFetch, info2.interval);
        }
      };
      poll2();
    };
    ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
      if (variables === void 0) {
        variables = this.variables;
      }
      var error = this.getLastError();
      if (error && this.last && !equal$2(variables, this.last.variables)) {
        error = void 0;
      }
      return this.last = __assign$2({ result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult), variables }, error ? { error } : null);
    };
    ObservableQuery2.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
      var _this = this;
      this.isTornDown = false;
      var useDisposableConcast = (
        // Refetching uses a disposable Concast to allow refetches using different
        // options/variables, without permanently altering the options of the
        // original ObservableQuery.
        newNetworkStatus === NetworkStatus.refetch || // The fetchMore method does not actually call the reobserve method, but,
        // if it did, it would definitely use a disposable Concast.
        newNetworkStatus === NetworkStatus.fetchMore || // Polling uses a disposable Concast so the polling options (which force
        // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
        newNetworkStatus === NetworkStatus.poll
      );
      var oldVariables = this.options.variables;
      var oldFetchPolicy = this.options.fetchPolicy;
      var mergedOptions = compact(this.options, newOptions || {});
      var options = useDisposableConcast ? (
        // Disposable Concast fetches receive a shallow copy of this.options
        // (merged with newOptions), leaving this.options unmodified.
        mergedOptions
      ) : assign$1(this.options, mergedOptions);
      var query = this.transformDocument(options.query);
      this.lastQuery = query;
      if (!useDisposableConcast) {
        this.updatePolling();
        if (newOptions && newOptions.variables && !equal$2(newOptions.variables, oldVariables) && // Don't mess with the fetchPolicy if it's currently "standby".
        options.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
        options.fetchPolicy === oldFetchPolicy) {
          this.applyNextFetchPolicy("variables-changed", options);
          if (newNetworkStatus === void 0) {
            newNetworkStatus = NetworkStatus.setVariables;
          }
        }
      }
      this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));
      var finishWaitingForOwnResult = function() {
        if (_this.concast === concast) {
          _this.waitForOwnResult = false;
        }
      };
      var variables = options.variables && __assign$2({}, options.variables);
      var _a2 = this.fetch(options, newNetworkStatus, query), concast = _a2.concast, fromLink = _a2.fromLink;
      var observer = {
        next: function(result) {
          finishWaitingForOwnResult();
          _this.reportResult(result, variables);
        },
        error: function(error) {
          finishWaitingForOwnResult();
          _this.reportError(error, variables);
        }
      };
      if (!useDisposableConcast && (fromLink || !this.concast)) {
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
        }
        this.concast = concast;
        this.observer = observer;
      }
      concast.addObserver(observer);
      return concast;
    };
    ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
      return this.reobserveAsConcast(newOptions, newNetworkStatus).promise;
    };
    ObservableQuery2.prototype.resubscribeAfterError = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var last2 = this.last;
      this.resetLastResults();
      var subscription = this.subscribe.apply(this, args);
      this.last = last2;
      return subscription;
    };
    ObservableQuery2.prototype.observe = function() {
      this.reportResult(
        // Passing false is important so that this.getCurrentResult doesn't
        // save the fetchMore result as this.lastResult, causing it to be
        // ignored due to the this.isDifferentFromLastResult check in
        // this.reportResult.
        this.getCurrentResult(false),
        this.variables
      );
    };
    ObservableQuery2.prototype.reportResult = function(result, variables) {
      var lastError = this.getLastError();
      var isDifferent = this.isDifferentFromLastResult(result, variables);
      if (lastError || !result.partial || this.options.returnPartialData) {
        this.updateLastResult(result, variables);
      }
      if (lastError || isDifferent) {
        iterateObserversSafely(this.observers, "next", result);
      }
    };
    ObservableQuery2.prototype.reportError = function(error, variables) {
      var errorResult = __assign$2(__assign$2({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
      this.updateLastResult(errorResult, variables);
      iterateObserversSafely(this.observers, "error", this.last.error = error);
    };
    ObservableQuery2.prototype.hasObservers = function() {
      return this.observers.size > 0;
    };
    ObservableQuery2.prototype.tearDownQuery = function() {
      if (this.isTornDown)
        return;
      if (this.concast && this.observer) {
        this.concast.removeObserver(this.observer);
        delete this.concast;
        delete this.observer;
      }
      this.stopPolling();
      this.subscriptions.forEach(function(sub) {
        return sub.unsubscribe();
      });
      this.subscriptions.clear();
      this.queryManager.stopQuery(this.queryId);
      this.observers.clear();
      this.isTornDown = true;
    };
    ObservableQuery2.prototype.transformDocument = function(document2) {
      return this.queryManager.transform(document2);
    };
    return ObservableQuery2;
  }(Observable)
);
fixObservableSubclass(ObservableQuery);
function reobserveCacheFirst(obsQuery) {
  var _a2 = obsQuery.options, fetchPolicy = _a2.fetchPolicy, nextFetchPolicy = _a2.nextFetchPolicy;
  if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
    return obsQuery.reobserve({
      fetchPolicy: "cache-first",
      // Use a temporary nextFetchPolicy function that replaces itself with the
      // previous nextFetchPolicy value and returns the original fetchPolicy.
      nextFetchPolicy: function(currentFetchPolicy, context) {
        this.nextFetchPolicy = nextFetchPolicy;
        if (typeof this.nextFetchPolicy === "function") {
          return this.nextFetchPolicy(currentFetchPolicy, context);
        }
        return fetchPolicy;
      }
    });
  }
  return obsQuery.reobserve();
}
function defaultSubscriptionObserverErrorCallback(error) {
  globalThis.__DEV__ !== false && invariant$2.error(23, error.message, error.stack);
}
function logMissingFieldErrors(missing) {
  if (globalThis.__DEV__ !== false && missing) {
    globalThis.__DEV__ !== false && invariant$2.debug(24, missing);
  }
}
function skipCacheDataFor(fetchPolicy) {
  return fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby";
}
var LocalState = (
  /** @class */
  function() {
    function LocalState2(_a2) {
      var cache2 = _a2.cache, client2 = _a2.client, resolvers = _a2.resolvers, fragmentMatcher = _a2.fragmentMatcher;
      this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
      this.cache = cache2;
      if (client2) {
        this.client = client2;
      }
      if (resolvers) {
        this.addResolvers(resolvers);
      }
      if (fragmentMatcher) {
        this.setFragmentMatcher(fragmentMatcher);
      }
    }
    LocalState2.prototype.addResolvers = function(resolvers) {
      var _this = this;
      this.resolvers = this.resolvers || {};
      if (Array.isArray(resolvers)) {
        resolvers.forEach(function(resolverGroup) {
          _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
        });
      } else {
        this.resolvers = mergeDeep(this.resolvers, resolvers);
      }
    };
    LocalState2.prototype.setResolvers = function(resolvers) {
      this.resolvers = {};
      this.addResolvers(resolvers);
    };
    LocalState2.prototype.getResolvers = function() {
      return this.resolvers || {};
    };
    LocalState2.prototype.runResolvers = function(_a2) {
      var document2 = _a2.document, remoteResult = _a2.remoteResult, context = _a2.context, variables = _a2.variables, _b = _a2.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
      return __awaiter$2(this, void 0, void 0, function() {
        return __generator$1(this, function(_c) {
          if (document2) {
            return [2, this.resolveDocument(document2, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
              return __assign$2(__assign$2({}, remoteResult), { data: localResult.result });
            })];
          }
          return [2, remoteResult];
        });
      });
    };
    LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
      this.fragmentMatcher = fragmentMatcher;
    };
    LocalState2.prototype.getFragmentMatcher = function() {
      return this.fragmentMatcher;
    };
    LocalState2.prototype.clientQuery = function(document2) {
      if (hasDirectives(["client"], document2)) {
        if (this.resolvers) {
          return document2;
        }
      }
      return null;
    };
    LocalState2.prototype.serverQuery = function(document2) {
      return removeClientSetsFromDocument(document2);
    };
    LocalState2.prototype.prepareContext = function(context) {
      var cache2 = this.cache;
      return __assign$2(__assign$2({}, context), {
        cache: cache2,
        // Getting an entry's cache key is useful for local state resolvers.
        getCacheKey: function(obj) {
          return cache2.identify(obj);
        }
      });
    };
    LocalState2.prototype.addExportedVariables = function(document2, variables, context) {
      if (variables === void 0) {
        variables = {};
      }
      if (context === void 0) {
        context = {};
      }
      return __awaiter$2(this, void 0, void 0, function() {
        return __generator$1(this, function(_a2) {
          if (document2) {
            return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context), variables).then(function(data2) {
              return __assign$2(__assign$2({}, variables), data2.exportedVariables);
            })];
          }
          return [2, __assign$2({}, variables)];
        });
      });
    };
    LocalState2.prototype.shouldForceResolvers = function(document2) {
      var forceResolvers = false;
      visit(document2, {
        Directive: {
          enter: function(node2) {
            if (node2.name.value === "client" && node2.arguments) {
              forceResolvers = node2.arguments.some(function(arg) {
                return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
              });
              if (forceResolvers) {
                return BREAK$1;
              }
            }
          }
        }
      });
      return forceResolvers;
    };
    LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
      return this.cache.diff({
        query: buildQueryFromSelectionSet(document2),
        variables,
        returnPartialData: true,
        optimistic: false
      }).result;
    };
    LocalState2.prototype.resolveDocument = function(document2, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
      if (context === void 0) {
        context = {};
      }
      if (variables === void 0) {
        variables = {};
      }
      if (fragmentMatcher === void 0) {
        fragmentMatcher = function() {
          return true;
        };
      }
      if (onlyRunForcedResolvers === void 0) {
        onlyRunForcedResolvers = false;
      }
      return __awaiter$2(this, void 0, void 0, function() {
        var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a2, cache2, client2, execContext, isClientFieldDescendant;
        return __generator$1(this, function(_b) {
          mainDefinition = getMainDefinition(document2);
          fragments = getFragmentDefinitions(document2);
          fragmentMap = createFragmentMap(fragments);
          selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
          definitionOperation = mainDefinition.operation;
          defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
          _a2 = this, cache2 = _a2.cache, client2 = _a2.client;
          execContext = {
            fragmentMap,
            context: __assign$2(__assign$2({}, context), { cache: cache2, client: client2 }),
            variables,
            fragmentMatcher,
            defaultOperationType,
            exportedVariables: {},
            selectionsToResolve,
            onlyRunForcedResolvers
          };
          isClientFieldDescendant = false;
          return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result) {
            return {
              result,
              exportedVariables: execContext.exportedVariables
            };
          })];
        });
      });
    };
    LocalState2.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
      return __awaiter$2(this, void 0, void 0, function() {
        var fragmentMap, context, variables, resultsToMerge, execute2;
        var _this = this;
        return __generator$1(this, function(_a2) {
          fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
          resultsToMerge = [rootValue];
          execute2 = function(selection) {
            return __awaiter$2(_this, void 0, void 0, function() {
              var fragment, typeCondition;
              return __generator$1(this, function(_a3) {
                if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                  return [
                    2
                    /*return*/
                  ];
                }
                if (!shouldInclude(selection, variables)) {
                  return [
                    2
                    /*return*/
                  ];
                }
                if (isField(selection)) {
                  return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                    var _a4;
                    if (typeof fieldResult !== "undefined") {
                      resultsToMerge.push((_a4 = {}, _a4[resultKeyNameFromField(selection)] = fieldResult, _a4));
                    }
                  })];
                }
                if (isInlineFragment(selection)) {
                  fragment = selection;
                } else {
                  fragment = fragmentMap[selection.name.value];
                  invariant$2(fragment, 18, selection.name.value);
                }
                if (fragment && fragment.typeCondition) {
                  typeCondition = fragment.typeCondition.name.value;
                  if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                    return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                      resultsToMerge.push(fragmentResult);
                    })];
                  }
                }
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
            return mergeDeepArray(resultsToMerge);
          })];
        });
      });
    };
    LocalState2.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
      return __awaiter$2(this, void 0, void 0, function() {
        var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
        var _this = this;
        return __generator$1(this, function(_a2) {
          if (!rootValue) {
            return [2, null];
          }
          variables = execContext.variables;
          fieldName = field.name.value;
          aliasedFieldName = resultKeyNameFromField(field);
          aliasUsed = fieldName !== aliasedFieldName;
          defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
          resultPromise = Promise.resolve(defaultResult);
          if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
            resolverType = rootValue.__typename || execContext.defaultOperationType;
            resolverMap = this.resolvers && this.resolvers[resolverType];
            if (resolverMap) {
              resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
              if (resolve) {
                resultPromise = Promise.resolve(
                  // In case the resolve function accesses reactive variables,
                  // set cacheSlot to the current cache instance.
                  cacheSlot.withValue(this.cache, resolve, [
                    rootValue,
                    argumentsObjectFromField(field, variables),
                    execContext.context,
                    { field, fragmentMap: execContext.fragmentMap }
                  ])
                );
              }
            }
          }
          return [2, resultPromise.then(function(result) {
            var _a3, _b;
            if (result === void 0) {
              result = defaultResult;
            }
            if (field.directives) {
              field.directives.forEach(function(directive) {
                if (directive.name.value === "export" && directive.arguments) {
                  directive.arguments.forEach(function(arg) {
                    if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                      execContext.exportedVariables[arg.value.value] = result;
                    }
                  });
                }
              });
            }
            if (!field.selectionSet) {
              return result;
            }
            if (result == null) {
              return result;
            }
            var isClientField = (_b = (_a3 = field.directives) === null || _a3 === void 0 ? void 0 : _a3.some(function(d2) {
              return d2.name.value === "client";
            })) !== null && _b !== void 0 ? _b : false;
            if (Array.isArray(result)) {
              return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);
            }
            if (field.selectionSet) {
              return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);
            }
          })];
        });
      });
    };
    LocalState2.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result, execContext) {
      var _this = this;
      return Promise.all(result.map(function(item) {
        if (item === null) {
          return null;
        }
        if (Array.isArray(item)) {
          return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
        }
        if (field.selectionSet) {
          return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
        }
      }));
    };
    LocalState2.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
      var isSingleASTNode = function(node2) {
        return !Array.isArray(node2);
      };
      var selectionsToResolveCache = this.selectionsToResolveCache;
      function collectByDefinition(definitionNode) {
        if (!selectionsToResolveCache.has(definitionNode)) {
          var matches_1 = /* @__PURE__ */ new Set();
          selectionsToResolveCache.set(definitionNode, matches_1);
          visit(definitionNode, {
            Directive: function(node2, _2, __, ___, ancestors) {
              if (node2.name.value === "client") {
                ancestors.forEach(function(node3) {
                  if (isSingleASTNode(node3) && isSelectionNode(node3)) {
                    matches_1.add(node3);
                  }
                });
              }
            },
            FragmentSpread: function(spread, _2, __, ___, ancestors) {
              var fragment = fragmentMap[spread.name.value];
              invariant$2(fragment, 19, spread.name.value);
              var fragmentSelections = collectByDefinition(fragment);
              if (fragmentSelections.size > 0) {
                ancestors.forEach(function(node2) {
                  if (isSingleASTNode(node2) && isSelectionNode(node2)) {
                    matches_1.add(node2);
                  }
                });
                matches_1.add(spread);
                fragmentSelections.forEach(function(selection) {
                  matches_1.add(selection);
                });
              }
            }
          });
        }
        return selectionsToResolveCache.get(definitionNode);
      }
      return collectByDefinition(mainDefinition);
    };
    return LocalState2;
  }()
);
var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
function wrapDestructiveCacheMethod(cache2, methodName) {
  var original = cache2[methodName];
  if (typeof original === "function") {
    cache2[methodName] = function() {
      destructiveMethodCounts.set(
        cache2,
        // The %1e15 allows the count to wrap around to 0 safely every
        // quadrillion evictions, so there's no risk of overflow. To be
        // clear, this is more of a pedantic principle than something
        // that matters in any conceivable practical scenario.
        (destructiveMethodCounts.get(cache2) + 1) % 1e15
      );
      return original.apply(this, arguments);
    };
  }
}
function cancelNotifyTimeout(info) {
  if (info["notifyTimeout"]) {
    clearTimeout(info["notifyTimeout"]);
    info["notifyTimeout"] = void 0;
  }
}
var QueryInfo = (
  /** @class */
  function() {
    function QueryInfo2(queryManager, queryId) {
      if (queryId === void 0) {
        queryId = queryManager.generateQueryId();
      }
      this.queryId = queryId;
      this.listeners = /* @__PURE__ */ new Set();
      this.document = null;
      this.lastRequestId = 1;
      this.stopped = false;
      this.dirty = false;
      this.observableQuery = null;
      var cache2 = this.cache = queryManager.cache;
      if (!destructiveMethodCounts.has(cache2)) {
        destructiveMethodCounts.set(cache2, 0);
        wrapDestructiveCacheMethod(cache2, "evict");
        wrapDestructiveCacheMethod(cache2, "modify");
        wrapDestructiveCacheMethod(cache2, "reset");
      }
    }
    QueryInfo2.prototype.init = function(query) {
      var networkStatus = query.networkStatus || NetworkStatus.loading;
      if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal$2(this.variables, query.variables)) {
        networkStatus = NetworkStatus.setVariables;
      }
      if (!equal$2(query.variables, this.variables)) {
        this.lastDiff = void 0;
      }
      Object.assign(this, {
        document: query.document,
        variables: query.variables,
        networkError: null,
        graphQLErrors: this.graphQLErrors || [],
        networkStatus
      });
      if (query.observableQuery) {
        this.setObservableQuery(query.observableQuery);
      }
      if (query.lastRequestId) {
        this.lastRequestId = query.lastRequestId;
      }
      return this;
    };
    QueryInfo2.prototype.reset = function() {
      cancelNotifyTimeout(this);
      this.dirty = false;
    };
    QueryInfo2.prototype.getDiff = function() {
      var options = this.getDiffOptions();
      if (this.lastDiff && equal$2(options, this.lastDiff.options)) {
        return this.lastDiff.diff;
      }
      this.updateWatch(this.variables);
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return { complete: false };
      }
      var diff = this.cache.diff(options);
      this.updateLastDiff(diff, options);
      return diff;
    };
    QueryInfo2.prototype.updateLastDiff = function(diff, options) {
      this.lastDiff = diff ? {
        diff,
        options: options || this.getDiffOptions()
      } : void 0;
    };
    QueryInfo2.prototype.getDiffOptions = function(variables) {
      var _a2;
      if (variables === void 0) {
        variables = this.variables;
      }
      return {
        query: this.document,
        variables,
        returnPartialData: true,
        optimistic: true,
        canonizeResults: (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.options.canonizeResults
      };
    };
    QueryInfo2.prototype.setDiff = function(diff) {
      var _this = this;
      var oldDiff = this.lastDiff && this.lastDiff.diff;
      this.updateLastDiff(diff);
      if (!this.dirty && !equal$2(oldDiff && oldDiff.result, diff && diff.result)) {
        this.dirty = true;
        if (!this.notifyTimeout) {
          this.notifyTimeout = setTimeout(function() {
            return _this.notify();
          }, 0);
        }
      }
    };
    QueryInfo2.prototype.setObservableQuery = function(oq) {
      var _this = this;
      if (oq === this.observableQuery)
        return;
      if (this.oqListener) {
        this.listeners.delete(this.oqListener);
      }
      this.observableQuery = oq;
      if (oq) {
        oq["queryInfo"] = this;
        this.listeners.add(this.oqListener = function() {
          var diff = _this.getDiff();
          if (diff.fromOptimisticTransaction) {
            oq["observe"]();
          } else {
            reobserveCacheFirst(oq);
          }
        });
      } else {
        delete this.oqListener;
      }
    };
    QueryInfo2.prototype.notify = function() {
      var _this = this;
      cancelNotifyTimeout(this);
      if (this.shouldNotify()) {
        this.listeners.forEach(function(listener) {
          return listener(_this);
        });
      }
      this.dirty = false;
    };
    QueryInfo2.prototype.shouldNotify = function() {
      if (!this.dirty || !this.listeners.size) {
        return false;
      }
      if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
        var fetchPolicy = this.observableQuery.options.fetchPolicy;
        if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
          return false;
        }
      }
      return true;
    };
    QueryInfo2.prototype.stop = function() {
      if (!this.stopped) {
        this.stopped = true;
        this.reset();
        this.cancel();
        this.cancel = QueryInfo2.prototype.cancel;
        var oq = this.observableQuery;
        if (oq)
          oq.stopPolling();
      }
    };
    QueryInfo2.prototype.cancel = function() {
    };
    QueryInfo2.prototype.updateWatch = function(variables) {
      var _this = this;
      if (variables === void 0) {
        variables = this.variables;
      }
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return;
      }
      var watchOptions = __assign$2(__assign$2({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
        return _this.setDiff(diff);
      } });
      if (!this.lastWatch || !equal$2(watchOptions, this.lastWatch)) {
        this.cancel();
        this.cancel = this.cache.watch(this.lastWatch = watchOptions);
      }
    };
    QueryInfo2.prototype.resetLastWrite = function() {
      this.lastWrite = void 0;
    };
    QueryInfo2.prototype.shouldWrite = function(result, variables) {
      var lastWrite = this.lastWrite;
      return !(lastWrite && // If cache.evict has been called since the last time we wrote this
      // data into the cache, there's a chance writing this result into
      // the cache will repair what was evicted.
      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal$2(variables, lastWrite.variables) && equal$2(result.data, lastWrite.result.data));
    };
    QueryInfo2.prototype.markResult = function(result, document2, options, cacheWriteBehavior) {
      var _this = this;
      var merger = new DeepMerger();
      var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
      this.reset();
      if ("incremental" in result && isNonEmptyArray(result.incremental)) {
        var mergedData = mergeIncrementalData(this.getDiff().result, result);
        result.data = mergedData;
      } else if ("hasNext" in result && result.hasNext) {
        var diff = this.getDiff();
        result.data = merger.merge(diff.result, result.data);
      }
      this.graphQLErrors = graphQLErrors;
      if (options.fetchPolicy === "no-cache") {
        this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));
      } else if (cacheWriteBehavior !== 0) {
        if (shouldWriteResult(result, options.errorPolicy)) {
          this.cache.performTransaction(function(cache2) {
            if (_this.shouldWrite(result, options.variables)) {
              cache2.writeQuery({
                query: document2,
                data: result.data,
                variables: options.variables,
                overwrite: cacheWriteBehavior === 1
              });
              _this.lastWrite = {
                result,
                variables: options.variables,
                dmCount: destructiveMethodCounts.get(_this.cache)
              };
            } else {
              if (_this.lastDiff && _this.lastDiff.diff.complete) {
                result.data = _this.lastDiff.diff.result;
                return;
              }
            }
            var diffOptions = _this.getDiffOptions(options.variables);
            var diff2 = cache2.diff(diffOptions);
            if (!_this.stopped && equal$2(_this.variables, options.variables)) {
              _this.updateWatch(options.variables);
            }
            _this.updateLastDiff(diff2, diffOptions);
            if (diff2.complete) {
              result.data = diff2.result;
            }
          });
        } else {
          this.lastWrite = void 0;
        }
      }
    };
    QueryInfo2.prototype.markReady = function() {
      this.networkError = null;
      return this.networkStatus = NetworkStatus.ready;
    };
    QueryInfo2.prototype.markError = function(error) {
      this.networkStatus = NetworkStatus.error;
      this.lastWrite = void 0;
      this.reset();
      if (error.graphQLErrors) {
        this.graphQLErrors = error.graphQLErrors;
      }
      if (error.networkError) {
        this.networkError = error.networkError;
      }
      return error;
    };
    return QueryInfo2;
  }()
);
function shouldWriteResult(result, errorPolicy) {
  if (errorPolicy === void 0) {
    errorPolicy = "none";
  }
  var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
  var writeWithErrors = !graphQLResultHasError(result);
  if (!writeWithErrors && ignoreErrors && result.data) {
    writeWithErrors = true;
  }
  return writeWithErrors;
}
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var QueryManager = (
  /** @class */
  function() {
    function QueryManager2(_a2) {
      var cache2 = _a2.cache, link = _a2.link, defaultOptions2 = _a2.defaultOptions, documentTransform = _a2.documentTransform, _b = _a2.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a2.onBroadcast, _c = _a2.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a2.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a2.localState, _e2 = _a2.assumeImmutableResults, assumeImmutableResults = _e2 === void 0 ? !!cache2.assumeImmutableResults : _e2;
      var _this = this;
      this.clientAwareness = {};
      this.queries = /* @__PURE__ */ new Map();
      this.fetchCancelFns = /* @__PURE__ */ new Map();
      this.transformCache = new (canUseWeakMap ? WeakMap : Map)();
      this.queryIdCounter = 1;
      this.requestIdCounter = 1;
      this.mutationIdCounter = 1;
      this.inFlightLinkObservables = /* @__PURE__ */ new Map();
      var defaultDocumentTransform = new DocumentTransform(
        function(document2) {
          return _this.cache.transformDocument(document2);
        },
        // Allow the apollo cache to manage its own transform caches
        { cache: false }
      );
      this.cache = cache2;
      this.link = link;
      this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
      this.queryDeduplication = queryDeduplication;
      this.clientAwareness = clientAwareness;
      this.localState = localState || new LocalState({ cache: cache2 });
      this.ssrMode = ssrMode;
      this.assumeImmutableResults = assumeImmutableResults;
      this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
      if (this.onBroadcast = onBroadcast) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
    }
    QueryManager2.prototype.stop = function() {
      var _this = this;
      this.queries.forEach(function(_info, queryId) {
        _this.stopQueryNoBroadcast(queryId);
      });
      this.cancelPendingFetches(newInvariantError(25));
    };
    QueryManager2.prototype.cancelPendingFetches = function(error) {
      this.fetchCancelFns.forEach(function(cancel) {
        return cancel(error);
      });
      this.fetchCancelFns.clear();
    };
    QueryManager2.prototype.mutate = function(_a2) {
      var _b, _c;
      var mutation = _a2.mutation, variables = _a2.variables, optimisticResponse = _a2.optimisticResponse, updateQueries = _a2.updateQueries, _d = _a2.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e2 = _a2.awaitRefetchQueries, awaitRefetchQueries = _e2 === void 0 ? false : _e2, updateWithProxyFn = _a2.update, onQueryUpdated = _a2.onQueryUpdated, _f = _a2.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || "network-only" : _f, _g = _a2.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || "none" : _g, keepRootFields = _a2.keepRootFields, context = _a2.context;
      return __awaiter$2(this, void 0, void 0, function() {
        var mutationId, hasClientExports2, mutationStoreValue, self2;
        return __generator$1(this, function(_h) {
          switch (_h.label) {
            case 0:
              invariant$2(mutation, 26);
              invariant$2(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 27);
              mutationId = this.generateMutationId();
              mutation = this.cache.transformForLink(this.transform(mutation));
              hasClientExports2 = this.getDocumentInfo(mutation).hasClientExports;
              variables = this.getVariables(mutation, variables);
              if (!hasClientExports2)
                return [3, 2];
              return [4, this.localState.addExportedVariables(mutation, variables, context)];
            case 1:
              variables = _h.sent();
              _h.label = 2;
            case 2:
              mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                mutation,
                variables,
                loading: true,
                error: null
              });
              if (optimisticResponse) {
                this.markMutationOptimistic(optimisticResponse, {
                  mutationId,
                  document: mutation,
                  variables,
                  fetchPolicy,
                  errorPolicy,
                  context,
                  updateQueries,
                  update: updateWithProxyFn,
                  keepRootFields
                });
              }
              this.broadcastQueries();
              self2 = this;
              return [2, new Promise(function(resolve, reject) {
                return asyncMap(self2.getObservableFromLink(mutation, __assign$2(__assign$2({}, context), { optimisticResponse }), variables, false), function(result) {
                  if (graphQLResultHasError(result) && errorPolicy === "none") {
                    throw new ApolloError({
                      graphQLErrors: getGraphQLErrorsFromResult(result)
                    });
                  }
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = null;
                  }
                  var storeResult = __assign$2({}, result);
                  if (typeof refetchQueries === "function") {
                    refetchQueries = refetchQueries(storeResult);
                  }
                  if (errorPolicy === "ignore" && graphQLResultHasError(storeResult)) {
                    delete storeResult.errors;
                  }
                  return self2.markMutationResult({
                    mutationId,
                    result: storeResult,
                    document: mutation,
                    variables,
                    fetchPolicy,
                    errorPolicy,
                    context,
                    update: updateWithProxyFn,
                    updateQueries,
                    awaitRefetchQueries,
                    refetchQueries,
                    removeOptimistic: optimisticResponse ? mutationId : void 0,
                    onQueryUpdated,
                    keepRootFields
                  });
                }).subscribe({
                  next: function(storeResult) {
                    self2.broadcastQueries();
                    if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                      resolve(storeResult);
                    }
                  },
                  error: function(err) {
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = err;
                    }
                    if (optimisticResponse) {
                      self2.cache.removeOptimistic(mutationId);
                    }
                    self2.broadcastQueries();
                    reject(err instanceof ApolloError ? err : new ApolloError({
                      networkError: err
                    }));
                  }
                });
              })];
          }
        });
      });
    };
    QueryManager2.prototype.markMutationResult = function(mutation, cache2) {
      var _this = this;
      if (cache2 === void 0) {
        cache2 = this.cache;
      }
      var result = mutation.result;
      var cacheWrites = [];
      var skipCache = mutation.fetchPolicy === "no-cache";
      if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
        if (!isExecutionPatchIncrementalResult(result)) {
          cacheWrites.push({
            result: result.data,
            dataId: "ROOT_MUTATION",
            query: mutation.document,
            variables: mutation.variables
          });
        }
        if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
          var diff = cache2.diff({
            id: "ROOT_MUTATION",
            // The cache complains if passed a mutation where it expects a
            // query, so we transform mutations and subscriptions to queries
            // (only once, thanks to this.transformCache).
            query: this.getDocumentInfo(mutation.document).asQuery,
            variables: mutation.variables,
            optimistic: false,
            returnPartialData: true
          });
          var mergedData = void 0;
          if (diff.result) {
            mergedData = mergeIncrementalData(diff.result, result);
          }
          if (typeof mergedData !== "undefined") {
            result.data = mergedData;
            cacheWrites.push({
              result: mergedData,
              dataId: "ROOT_MUTATION",
              query: mutation.document,
              variables: mutation.variables
            });
          }
        }
        var updateQueries_1 = mutation.updateQueries;
        if (updateQueries_1) {
          this.queries.forEach(function(_a2, queryId) {
            var observableQuery = _a2.observableQuery;
            var queryName = observableQuery && observableQuery.queryName;
            if (!queryName || !hasOwnProperty$1.call(updateQueries_1, queryName)) {
              return;
            }
            var updater = updateQueries_1[queryName];
            var _b = _this.queries.get(queryId), document2 = _b.document, variables = _b.variables;
            var _c = cache2.diff({
              query: document2,
              variables,
              returnPartialData: true,
              optimistic: false
            }), currentQueryResult = _c.result, complete = _c.complete;
            if (complete && currentQueryResult) {
              var nextQueryResult = updater(currentQueryResult, {
                mutationResult: result,
                queryName: document2 && getOperationName(document2) || void 0,
                queryVariables: variables
              });
              if (nextQueryResult) {
                cacheWrites.push({
                  result: nextQueryResult,
                  dataId: "ROOT_QUERY",
                  query: document2,
                  variables
                });
              }
            }
          });
        }
      }
      if (cacheWrites.length > 0 || mutation.refetchQueries || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
        var results_1 = [];
        this.refetchQueries({
          updateCache: function(cache3) {
            if (!skipCache) {
              cacheWrites.forEach(function(write4) {
                return cache3.write(write4);
              });
            }
            var update = mutation.update;
            var isFinalResult = !isExecutionPatchResult(result) || isExecutionPatchIncrementalResult(result) && !result.hasNext;
            if (update) {
              if (!skipCache) {
                var diff2 = cache3.diff({
                  id: "ROOT_MUTATION",
                  // The cache complains if passed a mutation where it expects a
                  // query, so we transform mutations and subscriptions to queries
                  // (only once, thanks to this.transformCache).
                  query: _this.getDocumentInfo(mutation.document).asQuery,
                  variables: mutation.variables,
                  optimistic: false,
                  returnPartialData: true
                });
                if (diff2.complete) {
                  result = __assign$2(__assign$2({}, result), { data: diff2.result });
                  if ("incremental" in result) {
                    delete result.incremental;
                  }
                  if ("hasNext" in result) {
                    delete result.hasNext;
                  }
                }
              }
              if (isFinalResult) {
                update(cache3, result, {
                  context: mutation.context,
                  variables: mutation.variables
                });
              }
            }
            if (!skipCache && !mutation.keepRootFields && isFinalResult) {
              cache3.modify({
                id: "ROOT_MUTATION",
                fields: function(value, _a2) {
                  var fieldName = _a2.fieldName, DELETE2 = _a2.DELETE;
                  return fieldName === "__typename" ? value : DELETE2;
                }
              });
            }
          },
          include: mutation.refetchQueries,
          // Write the final mutation.result to the root layer of the cache.
          optimistic: false,
          // Remove the corresponding optimistic layer at the same time as we
          // write the final non-optimistic result.
          removeOptimistic: mutation.removeOptimistic,
          // Let the caller of client.mutate optionally determine the refetching
          // behavior for watched queries after the mutation.update function runs.
          // If no onQueryUpdated function was provided for this mutation, pass
          // null instead of undefined to disable the default refetching behavior.
          onQueryUpdated: mutation.onQueryUpdated || null
        }).forEach(function(result2) {
          return results_1.push(result2);
        });
        if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
          return Promise.all(results_1).then(function() {
            return result;
          });
        }
      }
      return Promise.resolve(result);
    };
    QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
      var _this = this;
      var data2 = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables) : optimisticResponse;
      return this.cache.recordOptimisticTransaction(function(cache2) {
        try {
          _this.markMutationResult(__assign$2(__assign$2({}, mutation), { result: { data: data2 } }), cache2);
        } catch (error) {
          globalThis.__DEV__ !== false && invariant$2.error(error);
        }
      }, mutation.mutationId);
    };
    QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
      return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;
    };
    QueryManager2.prototype.getQueryStore = function() {
      var store = /* @__PURE__ */ Object.create(null);
      this.queries.forEach(function(info, queryId) {
        store[queryId] = {
          variables: info.variables,
          networkStatus: info.networkStatus,
          networkError: info.networkError,
          graphQLErrors: info.graphQLErrors
        };
      });
      return store;
    };
    QueryManager2.prototype.resetErrors = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo) {
        queryInfo.networkError = void 0;
        queryInfo.graphQLErrors = [];
      }
    };
    QueryManager2.prototype.transform = function(document2) {
      return this.documentTransform.transformDocument(document2);
    };
    QueryManager2.prototype.getDocumentInfo = function(document2) {
      var transformCache = this.transformCache;
      if (!transformCache.has(document2)) {
        var cacheEntry = {
          // TODO These three calls (hasClientExports, shouldForceResolvers, and
          // usesNonreactiveDirective) are performing independent full traversals
          // of the transformed document. We should consider merging these
          // traversals into a single pass in the future, though the work is
          // cached after the first time.
          hasClientExports: hasClientExports(document2),
          hasForcedResolvers: this.localState.shouldForceResolvers(document2),
          hasNonreactiveDirective: hasDirectives(["nonreactive"], document2),
          clientQuery: this.localState.clientQuery(document2),
          serverQuery: removeDirectivesFromDocument([
            { name: "client", remove: true },
            { name: "connection" },
            { name: "nonreactive" }
          ], document2),
          defaultVars: getDefaultValues(getOperationDefinition(document2)),
          // Transform any mutation or subscription operations to query operations
          // so we can read/write them from/to the cache.
          asQuery: __assign$2(__assign$2({}, document2), { definitions: document2.definitions.map(function(def) {
            if (def.kind === "OperationDefinition" && def.operation !== "query") {
              return __assign$2(__assign$2({}, def), { operation: "query" });
            }
            return def;
          }) })
        };
        transformCache.set(document2, cacheEntry);
      }
      return transformCache.get(document2);
    };
    QueryManager2.prototype.getVariables = function(document2, variables) {
      return __assign$2(__assign$2({}, this.getDocumentInfo(document2).defaultVars), variables);
    };
    QueryManager2.prototype.watchQuery = function(options) {
      var query = this.transform(options.query);
      options = __assign$2(__assign$2({}, options), { variables: this.getVariables(query, options.variables) });
      if (typeof options.notifyOnNetworkStatusChange === "undefined") {
        options.notifyOnNetworkStatusChange = false;
      }
      var queryInfo = new QueryInfo(this);
      var observable = new ObservableQuery({
        queryManager: this,
        queryInfo,
        options
      });
      observable["lastQuery"] = query;
      this.queries.set(observable.queryId, queryInfo);
      queryInfo.init({
        document: query,
        observableQuery: observable,
        variables: observable.variables
      });
      return observable;
    };
    QueryManager2.prototype.query = function(options, queryId) {
      var _this = this;
      if (queryId === void 0) {
        queryId = this.generateQueryId();
      }
      invariant$2(options.query, 28);
      invariant$2(options.query.kind === "Document", 29);
      invariant$2(!options.returnPartialData, 30);
      invariant$2(!options.pollInterval, 31);
      return this.fetchQuery(queryId, __assign$2(__assign$2({}, options), { query: this.transform(options.query) })).finally(function() {
        return _this.stopQuery(queryId);
      });
    };
    QueryManager2.prototype.generateQueryId = function() {
      return String(this.queryIdCounter++);
    };
    QueryManager2.prototype.generateRequestId = function() {
      return this.requestIdCounter++;
    };
    QueryManager2.prototype.generateMutationId = function() {
      return String(this.mutationIdCounter++);
    };
    QueryManager2.prototype.stopQueryInStore = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo)
        queryInfo.stop();
    };
    QueryManager2.prototype.clearStore = function(options) {
      if (options === void 0) {
        options = {
          discardWatches: true
        };
      }
      this.cancelPendingFetches(newInvariantError(32));
      this.queries.forEach(function(queryInfo) {
        if (queryInfo.observableQuery) {
          queryInfo.networkStatus = NetworkStatus.loading;
        } else {
          queryInfo.stop();
        }
      });
      if (this.mutationStore) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
      return this.cache.reset(options);
    };
    QueryManager2.prototype.getObservableQueries = function(include) {
      var _this = this;
      if (include === void 0) {
        include = "active";
      }
      var queries = /* @__PURE__ */ new Map();
      var queryNamesAndDocs = /* @__PURE__ */ new Map();
      var legacyQueryOptions = /* @__PURE__ */ new Set();
      if (Array.isArray(include)) {
        include.forEach(function(desc) {
          if (typeof desc === "string") {
            queryNamesAndDocs.set(desc, false);
          } else if (isDocumentNode(desc)) {
            queryNamesAndDocs.set(_this.transform(desc), false);
          } else if (isNonNullObject(desc) && desc.query) {
            legacyQueryOptions.add(desc);
          }
        });
      }
      this.queries.forEach(function(_a2, queryId) {
        var oq = _a2.observableQuery, document2 = _a2.document;
        if (oq) {
          if (include === "all") {
            queries.set(queryId, oq);
            return;
          }
          var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
          if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
            return;
          }
          if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document2 && queryNamesAndDocs.has(document2)) {
            queries.set(queryId, oq);
            if (queryName)
              queryNamesAndDocs.set(queryName, true);
            if (document2)
              queryNamesAndDocs.set(document2, true);
          }
        }
      });
      if (legacyQueryOptions.size) {
        legacyQueryOptions.forEach(function(options) {
          var queryId = makeUniqueId("legacyOneTimeQuery");
          var queryInfo = _this.getQuery(queryId).init({
            document: options.query,
            variables: options.variables
          });
          var oq = new ObservableQuery({
            queryManager: _this,
            queryInfo,
            options: __assign$2(__assign$2({}, options), { fetchPolicy: "network-only" })
          });
          invariant$2(oq.queryId === queryId);
          queryInfo.setObservableQuery(oq);
          queries.set(queryId, oq);
        });
      }
      if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {
        queryNamesAndDocs.forEach(function(included, nameOrDoc) {
          if (!included) {
            globalThis.__DEV__ !== false && invariant$2.warn(typeof nameOrDoc === "string" ? 33 : 34, nameOrDoc);
          }
        });
      }
      return queries;
    };
    QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
      var _this = this;
      if (includeStandby === void 0) {
        includeStandby = false;
      }
      var observableQueryPromises = [];
      this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
        var fetchPolicy = observableQuery.options.fetchPolicy;
        observableQuery.resetLastResults();
        if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
          observableQueryPromises.push(observableQuery.refetch());
        }
        _this.getQuery(queryId).setDiff(null);
      });
      this.broadcastQueries();
      return Promise.all(observableQueryPromises);
    };
    QueryManager2.prototype.setObservableQuery = function(observableQuery) {
      this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
    };
    QueryManager2.prototype.startGraphQLSubscription = function(_a2) {
      var _this = this;
      var query = _a2.query, fetchPolicy = _a2.fetchPolicy, _b = _a2.errorPolicy, errorPolicy = _b === void 0 ? "none" : _b, variables = _a2.variables, _c = _a2.context, context = _c === void 0 ? {} : _c;
      query = this.transform(query);
      variables = this.getVariables(query, variables);
      var makeObservable = function(variables2) {
        return _this.getObservableFromLink(query, context, variables2).map(function(result) {
          if (fetchPolicy !== "no-cache") {
            if (shouldWriteResult(result, errorPolicy)) {
              _this.cache.write({
                query,
                result: result.data,
                dataId: "ROOT_SUBSCRIPTION",
                variables: variables2
              });
            }
            _this.broadcastQueries();
          }
          var hasErrors = graphQLResultHasError(result);
          var hasProtocolErrors = graphQLResultHasProtocolErrors(result);
          if (hasErrors || hasProtocolErrors) {
            var errors2 = {};
            if (hasErrors) {
              errors2.graphQLErrors = result.errors;
            }
            if (hasProtocolErrors) {
              errors2.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];
            }
            if (errorPolicy === "none" || hasProtocolErrors) {
              throw new ApolloError(errors2);
            }
          }
          if (errorPolicy === "ignore") {
            delete result.errors;
          }
          return result;
        });
      };
      if (this.getDocumentInfo(query).hasClientExports) {
        var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
        return new Observable(function(observer) {
          var sub = null;
          observablePromise_1.then(function(observable) {
            return sub = observable.subscribe(observer);
          }, observer.error);
          return function() {
            return sub && sub.unsubscribe();
          };
        });
      }
      return makeObservable(variables);
    };
    QueryManager2.prototype.stopQuery = function(queryId) {
      this.stopQueryNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.removeQuery(queryId);
    };
    QueryManager2.prototype.removeQuery = function(queryId) {
      this.fetchCancelFns.delete(queryId);
      if (this.queries.has(queryId)) {
        this.getQuery(queryId).stop();
        this.queries.delete(queryId);
      }
    };
    QueryManager2.prototype.broadcastQueries = function() {
      if (this.onBroadcast)
        this.onBroadcast();
      this.queries.forEach(function(info) {
        return info.notify();
      });
    };
    QueryManager2.prototype.getLocalState = function() {
      return this.localState;
    };
    QueryManager2.prototype.getObservableFromLink = function(query, context, variables, deduplication) {
      var _this = this;
      var _a2;
      if (deduplication === void 0) {
        deduplication = (_a2 = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a2 !== void 0 ? _a2 : this.queryDeduplication;
      }
      var observable;
      var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;
      if (serverQuery) {
        var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;
        var operation = {
          query: serverQuery,
          variables,
          operationName: getOperationName(serverQuery) || void 0,
          context: this.prepareContext(__assign$2(__assign$2({}, context), { forceFetch: !deduplication }))
        };
        context = operation.context;
        if (deduplication) {
          var printedServerQuery_1 = print(serverQuery);
          var byVariables_1 = inFlightLinkObservables_1.get(printedServerQuery_1) || /* @__PURE__ */ new Map();
          inFlightLinkObservables_1.set(printedServerQuery_1, byVariables_1);
          var varJson_1 = canonicalStringify(variables);
          observable = byVariables_1.get(varJson_1);
          if (!observable) {
            var concast = new Concast([
              execute(link, operation)
            ]);
            byVariables_1.set(varJson_1, observable = concast);
            concast.beforeNext(function() {
              if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {
                inFlightLinkObservables_1.delete(printedServerQuery_1);
              }
            });
          }
        } else {
          observable = new Concast([
            execute(link, operation)
          ]);
        }
      } else {
        observable = new Concast([Observable.of({ data: {} })]);
        context = this.prepareContext(context);
      }
      if (clientQuery) {
        observable = asyncMap(observable, function(result) {
          return _this.localState.runResolvers({
            document: clientQuery,
            remoteResult: result,
            context,
            variables
          });
        });
      }
      return observable;
    };
    QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
      var requestId = queryInfo.lastRequestId = this.generateRequestId();
      var linkDocument = this.cache.transformForLink(options.query);
      return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result) {
        var graphQLErrors = getGraphQLErrorsFromResult(result);
        var hasErrors = graphQLErrors.length > 0;
        if (requestId >= queryInfo.lastRequestId) {
          if (hasErrors && options.errorPolicy === "none") {
            throw queryInfo.markError(new ApolloError({
              graphQLErrors
            }));
          }
          queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);
          queryInfo.markReady();
        }
        var aqr = {
          data: result.data,
          loading: false,
          networkStatus: NetworkStatus.ready
        };
        if (hasErrors && options.errorPolicy !== "ignore") {
          aqr.errors = graphQLErrors;
          aqr.networkStatus = NetworkStatus.error;
        }
        return aqr;
      }, function(networkError) {
        var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
        if (requestId >= queryInfo.lastRequestId) {
          queryInfo.markError(error);
        }
        throw error;
      });
    };
    QueryManager2.prototype.fetchConcastWithInfo = function(queryId, options, networkStatus, query) {
      var _this = this;
      if (networkStatus === void 0) {
        networkStatus = NetworkStatus.loading;
      }
      if (query === void 0) {
        query = options.query;
      }
      var variables = this.getVariables(query, options.variables);
      var queryInfo = this.getQuery(queryId);
      var defaults2 = this.defaultOptions.watchQuery;
      var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? defaults2 && defaults2.fetchPolicy || "cache-first" : _a2, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults2 && defaults2.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e2 = options.context, context = _e2 === void 0 ? {} : _e2;
      var normalized = Object.assign({}, options, {
        query,
        variables,
        fetchPolicy,
        errorPolicy,
        returnPartialData,
        notifyOnNetworkStatusChange,
        context
      });
      var fromVariables = function(variables2) {
        normalized.variables = variables2;
        var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
        if (
          // If we're in standby, postpone advancing options.fetchPolicy using
          // applyNextFetchPolicy.
          normalized.fetchPolicy !== "standby" && // The "standby" policy currently returns [] from fetchQueryByPolicy, so
          // this is another way to detect when nothing was done/fetched.
          sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery
        ) {
          queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
        }
        return sourcesWithInfo2;
      };
      var cleanupCancelFn = function() {
        return _this.fetchCancelFns.delete(queryId);
      };
      this.fetchCancelFns.set(queryId, function(reason) {
        cleanupCancelFn();
        setTimeout(function() {
          return concast.cancel(reason);
        });
      });
      var concast, containsDataFromLink;
      if (this.getDocumentInfo(normalized.query).hasClientExports) {
        concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {
          return sourcesWithInfo2.sources;
        }));
        containsDataFromLink = true;
      } else {
        var sourcesWithInfo = fromVariables(normalized.variables);
        containsDataFromLink = sourcesWithInfo.fromLink;
        concast = new Concast(sourcesWithInfo.sources);
      }
      concast.promise.then(cleanupCancelFn, cleanupCancelFn);
      return {
        concast,
        fromLink: containsDataFromLink
      };
    };
    QueryManager2.prototype.refetchQueries = function(_a2) {
      var _this = this;
      var updateCache = _a2.updateCache, include = _a2.include, _b = _a2.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a2.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a2.onQueryUpdated;
      var includedQueriesById = /* @__PURE__ */ new Map();
      if (include) {
        this.getObservableQueries(include).forEach(function(oq, queryId) {
          includedQueriesById.set(queryId, {
            oq,
            lastDiff: _this.getQuery(queryId).getDiff()
          });
        });
      }
      var results = /* @__PURE__ */ new Map();
      if (updateCache) {
        this.cache.batch({
          update: updateCache,
          // Since you can perform any combination of cache reads and/or writes in
          // the cache.batch update function, its optimistic option can be either
          // a boolean or a string, representing three distinct modes of
          // operation:
          //
          // * false: read/write only the root layer
          // * true: read/write the topmost layer
          // * string: read/write a fresh optimistic layer with that ID string
          //
          // When typeof optimistic === "string", a new optimistic layer will be
          // temporarily created within cache.batch with that string as its ID. If
          // we then pass that same string as the removeOptimistic option, we can
          // make cache.batch immediately remove the optimistic layer after
          // running the updateCache function, triggering only one broadcast.
          //
          // However, the refetchQueries method accepts only true or false for its
          // optimistic option (not string). We interpret true to mean a temporary
          // optimistic layer should be created, to allow efficiently rolling back
          // the effect of the updateCache function, which involves passing a
          // string instead of true as the optimistic option to cache.batch, when
          // refetchQueries receives optimistic: true.
          //
          // In other words, we are deliberately not supporting the use case of
          // writing to an *existing* optimistic layer (using the refetchQueries
          // updateCache function), since that would potentially interfere with
          // other optimistic updates in progress. Instead, you can read/write
          // only the root layer by passing optimistic: false to refetchQueries,
          // or you can read/write a brand new optimistic layer that will be
          // automatically removed by passing optimistic: true.
          optimistic: optimistic && removeOptimistic || false,
          // The removeOptimistic option can also be provided by itself, even if
          // optimistic === false, to remove some previously-added optimistic
          // layer safely and efficiently, like we do in markMutationResult.
          //
          // If an explicit removeOptimistic string is provided with optimistic:
          // true, the removeOptimistic string will determine the ID of the
          // temporary optimistic layer, in case that ever matters.
          removeOptimistic,
          onWatchUpdated: function(watch2, diff, lastDiff) {
            var oq = watch2.watcher instanceof QueryInfo && watch2.watcher.observableQuery;
            if (oq) {
              if (onQueryUpdated) {
                includedQueriesById.delete(oq.queryId);
                var result = onQueryUpdated(oq, diff, lastDiff);
                if (result === true) {
                  result = oq.refetch();
                }
                if (result !== false) {
                  results.set(oq, result);
                }
                return result;
              }
              if (onQueryUpdated !== null) {
                includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
              }
            }
          }
        });
      }
      if (includedQueriesById.size) {
        includedQueriesById.forEach(function(_a3, queryId) {
          var oq = _a3.oq, lastDiff = _a3.lastDiff, diff = _a3.diff;
          var result;
          if (onQueryUpdated) {
            if (!diff) {
              var info = oq["queryInfo"];
              info.reset();
              diff = info.getDiff();
            }
            result = onQueryUpdated(oq, diff, lastDiff);
          }
          if (!onQueryUpdated || result === true) {
            result = oq.refetch();
          }
          if (result !== false) {
            results.set(oq, result);
          }
          if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
            _this.stopQueryNoBroadcast(queryId);
          }
        });
      }
      if (removeOptimistic) {
        this.cache.removeOptimistic(removeOptimistic);
      }
      return results;
    };
    QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a2, networkStatus) {
      var _this = this;
      var query = _a2.query, variables = _a2.variables, fetchPolicy = _a2.fetchPolicy, refetchWritePolicy = _a2.refetchWritePolicy, errorPolicy = _a2.errorPolicy, returnPartialData = _a2.returnPartialData, context = _a2.context, notifyOnNetworkStatusChange = _a2.notifyOnNetworkStatusChange;
      var oldNetworkStatus = queryInfo.networkStatus;
      queryInfo.init({
        document: query,
        variables,
        networkStatus
      });
      var readCache = function() {
        return queryInfo.getDiff();
      };
      var resultsFromCache = function(diff2, networkStatus2) {
        if (networkStatus2 === void 0) {
          networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
        }
        var data2 = diff2.result;
        if (globalThis.__DEV__ !== false && !returnPartialData && !equal$2(data2, {})) {
          logMissingFieldErrors(diff2.missing);
        }
        var fromData = function(data3) {
          return Observable.of(__assign$2({ data: data3, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
        };
        if (data2 && _this.getDocumentInfo(query).hasForcedResolvers) {
          return _this.localState.runResolvers({
            document: query,
            remoteResult: { data: data2 },
            context,
            variables,
            onlyRunForcedResolvers: true
          }).then(function(resolved) {
            return fromData(resolved.data || void 0);
          });
        }
        if (errorPolicy === "none" && networkStatus2 === NetworkStatus.refetch && Array.isArray(diff2.missing)) {
          return fromData(void 0);
        }
        return fromData(data2);
      };
      var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
      var resultsFromLink = function() {
        return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
          query,
          variables,
          context,
          fetchPolicy,
          errorPolicy
        });
      };
      var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
      switch (fetchPolicy) {
        default:
        case "cache-first": {
          var diff = readCache();
          if (diff.complete) {
            return {
              fromLink: false,
              sources: [resultsFromCache(diff, queryInfo.markReady())]
            };
          }
          if (returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-and-network": {
          var diff = readCache();
          if (diff.complete || returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-only":
          return {
            fromLink: false,
            sources: [resultsFromCache(readCache(), queryInfo.markReady())]
          };
        case "network-only":
          if (shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(readCache()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "no-cache":
          if (shouldNotify) {
            return {
              fromLink: true,
              // Note that queryInfo.getDiff() for no-cache queries does not call
              // cache.diff, but instead returns a { complete: false } stub result
              // when there is no queryInfo.diff already defined.
              sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "standby":
          return { fromLink: false, sources: [] };
      }
    };
    QueryManager2.prototype.getQuery = function(queryId) {
      if (queryId && !this.queries.has(queryId)) {
        this.queries.set(queryId, new QueryInfo(this, queryId));
      }
      return this.queries.get(queryId);
    };
    QueryManager2.prototype.prepareContext = function(context) {
      if (context === void 0) {
        context = {};
      }
      var newContext = this.localState.prepareContext(context);
      return __assign$2(__assign$2({}, newContext), { clientAwareness: this.clientAwareness });
    };
    return QueryManager2;
  }()
);
var hasSuggestedDevtools = false;
var ApolloClient = (
  /** @class */
  function() {
    function ApolloClient2(options) {
      var _this = this;
      this.resetStoreCallbacks = [];
      this.clearStoreCallbacks = [];
      if (!options.cache) {
        throw newInvariantError(15);
      }
      var uri = options.uri, credentials = options.credentials, headers = options.headers, cache2 = options.cache, documentTransform = options.documentTransform, _a2 = options.ssrMode, ssrMode = _a2 === void 0 ? false : _a2, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options.connectToDevTools, connectToDevTools = _c === void 0 ? typeof window === "object" && !window.__APOLLO_CLIENT__ && globalThis.__DEV__ !== false : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions2 = options.defaultOptions, _e2 = options.assumeImmutableResults, assumeImmutableResults = _e2 === void 0 ? cache2.assumeImmutableResults : _e2, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
      var link = options.link;
      if (!link) {
        link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();
      }
      this.link = link;
      this.cache = cache2;
      this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
      this.queryDeduplication = queryDeduplication;
      this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
      this.typeDefs = typeDefs;
      if (ssrForceFetchDelay) {
        setTimeout(function() {
          return _this.disableNetworkFetches = false;
        }, ssrForceFetchDelay);
      }
      this.watchQuery = this.watchQuery.bind(this);
      this.query = this.query.bind(this);
      this.mutate = this.mutate.bind(this);
      this.resetStore = this.resetStore.bind(this);
      this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
      this.version = version$b;
      this.localState = new LocalState({
        cache: cache2,
        client: this,
        resolvers,
        fragmentMatcher
      });
      this.queryManager = new QueryManager({
        cache: this.cache,
        link: this.link,
        defaultOptions: this.defaultOptions,
        documentTransform,
        queryDeduplication,
        ssrMode,
        clientAwareness: {
          name: clientAwarenessName,
          version: clientAwarenessVersion
        },
        localState: this.localState,
        assumeImmutableResults,
        onBroadcast: connectToDevTools ? function() {
          if (_this.devToolsHookCb) {
            _this.devToolsHookCb({
              action: {},
              state: {
                queries: _this.queryManager.getQueryStore(),
                mutations: _this.queryManager.mutationStore || {}
              },
              dataWithOptimisticResults: _this.cache.extract(true)
            });
          }
        } : void 0
      });
      if (connectToDevTools)
        this.connectToDevTools();
    }
    ApolloClient2.prototype.connectToDevTools = function() {
      if (typeof window === "object") {
        var windowWithDevTools = window;
        var devtoolsSymbol = Symbol.for("apollo.devtools");
        (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
        windowWithDevTools.__APOLLO_CLIENT__ = this;
      }
      if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {
        hasSuggestedDevtools = true;
        setTimeout(function() {
          if (typeof window !== "undefined" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
            var nav = window.navigator;
            var ua2 = nav && nav.userAgent;
            var url = void 0;
            if (typeof ua2 === "string") {
              if (ua2.indexOf("Chrome/") > -1) {
                url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
              } else if (ua2.indexOf("Firefox/") > -1) {
                url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
              }
            }
            if (url) {
              globalThis.__DEV__ !== false && invariant$2.log("Download the Apollo DevTools for a better development experience: %s", url);
            }
          }
        }, 1e4);
      }
    };
    Object.defineProperty(ApolloClient2.prototype, "documentTransform", {
      /**
       * The `DocumentTransform` used to modify GraphQL documents before a request
       * is made. If a custom `DocumentTransform` is not provided, this will be the
       * default document transform.
       */
      get: function() {
        return this.queryManager.documentTransform;
      },
      enumerable: false,
      configurable: true
    });
    ApolloClient2.prototype.stop = function() {
      this.queryManager.stop();
    };
    ApolloClient2.prototype.watchQuery = function(options) {
      if (this.defaultOptions.watchQuery) {
        options = mergeOptions$2(this.defaultOptions.watchQuery, options);
      }
      if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
        options = __assign$2(__assign$2({}, options), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.watchQuery(options);
    };
    ApolloClient2.prototype.query = function(options) {
      if (this.defaultOptions.query) {
        options = mergeOptions$2(this.defaultOptions.query, options);
      }
      invariant$2(options.fetchPolicy !== "cache-and-network", 16);
      if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
        options = __assign$2(__assign$2({}, options), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.query(options);
    };
    ApolloClient2.prototype.mutate = function(options) {
      if (this.defaultOptions.mutate) {
        options = mergeOptions$2(this.defaultOptions.mutate, options);
      }
      return this.queryManager.mutate(options);
    };
    ApolloClient2.prototype.subscribe = function(options) {
      return this.queryManager.startGraphQLSubscription(options);
    };
    ApolloClient2.prototype.readQuery = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readQuery(options, optimistic);
    };
    ApolloClient2.prototype.readFragment = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readFragment(options, optimistic);
    };
    ApolloClient2.prototype.writeQuery = function(options) {
      var ref = this.cache.writeQuery(options);
      if (options.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient2.prototype.writeFragment = function(options) {
      var ref = this.cache.writeFragment(options);
      if (options.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient2.prototype.__actionHookForDevTools = function(cb2) {
      this.devToolsHookCb = cb2;
    };
    ApolloClient2.prototype.__requestRaw = function(payload) {
      return execute(this.link, payload);
    };
    ApolloClient2.prototype.resetStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: false
        });
      }).then(function() {
        return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
          return fn();
        }));
      }).then(function() {
        return _this.reFetchObservableQueries();
      });
    };
    ApolloClient2.prototype.clearStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: true
        });
      }).then(function() {
        return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
          return fn();
        }));
      });
    };
    ApolloClient2.prototype.onResetStore = function(cb2) {
      var _this = this;
      this.resetStoreCallbacks.push(cb2);
      return function() {
        _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c2) {
          return c2 !== cb2;
        });
      };
    };
    ApolloClient2.prototype.onClearStore = function(cb2) {
      var _this = this;
      this.clearStoreCallbacks.push(cb2);
      return function() {
        _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c2) {
          return c2 !== cb2;
        });
      };
    };
    ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
      return this.queryManager.reFetchObservableQueries(includeStandby);
    };
    ApolloClient2.prototype.refetchQueries = function(options) {
      var map2 = this.queryManager.refetchQueries(options);
      var queries = [];
      var results = [];
      map2.forEach(function(result2, obsQuery) {
        queries.push(obsQuery);
        results.push(result2);
      });
      var result = Promise.all(results);
      result.queries = queries;
      result.results = results;
      result.catch(function(error) {
        globalThis.__DEV__ !== false && invariant$2.debug(17, error);
      });
      return result;
    };
    ApolloClient2.prototype.getObservableQueries = function(include) {
      if (include === void 0) {
        include = "active";
      }
      return this.queryManager.getObservableQueries(include);
    };
    ApolloClient2.prototype.extract = function(optimistic) {
      return this.cache.extract(optimistic);
    };
    ApolloClient2.prototype.restore = function(serializedState) {
      return this.cache.restore(serializedState);
    };
    ApolloClient2.prototype.addResolvers = function(resolvers) {
      this.localState.addResolvers(resolvers);
    };
    ApolloClient2.prototype.setResolvers = function(resolvers) {
      this.localState.setResolvers(resolvers);
    };
    ApolloClient2.prototype.getResolvers = function() {
      return this.localState.getResolvers();
    };
    ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
      this.localState.setFragmentMatcher(fragmentMatcher);
    };
    ApolloClient2.prototype.setLink = function(newLink) {
      this.link = this.queryManager.link = newLink;
    };
    return ApolloClient2;
  }()
);
var contextKey = canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
function getApolloContext() {
  invariant$2("createContext" in React$2, 45);
  var context = reactExports.createContext[contextKey];
  if (!context) {
    Object.defineProperty(reactExports.createContext, contextKey, {
      value: context = reactExports.createContext({}),
      enumerable: false,
      writable: false,
      configurable: true
    });
    context.displayName = "ApolloContext";
  }
  return context;
}
var ApolloProvider = function(_a2) {
  var client2 = _a2.client, children = _a2.children;
  var ApolloContext = getApolloContext();
  var parentContext = reactExports.useContext(ApolloContext);
  var context = reactExports.useMemo(function() {
    return __assign$2(__assign$2({}, parentContext), { client: client2 || parentContext.client });
  }, [parentContext, client2]);
  invariant$2(context.client, 46);
  return reactExports.createElement(ApolloContext.Provider, { value: context }, children);
};
var reactDom$1 = { exports: {} };
var reactDom_production_min$1 = {};
var scheduler$1 = { exports: {} };
var scheduler_production_min$2 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N10 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N10 = false, O2 = null);
      }
    } else
      N10 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N10 || (N10 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min$2);
const scheduler_production_min = /* @__PURE__ */ getDefaultExportFromCjs(scheduler_production_min$2);
const scheduler_production_min$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: scheduler_production_min
}, [scheduler_production_min$2]);
const require$$0$1e = /* @__PURE__ */ getAugmentedNamespace(scheduler_production_min$1);
{
  scheduler$1.exports = require$$0$1e;
}
var schedulerExports = scheduler$1.exports;
const index$q = /* @__PURE__ */ getDefaultExportFromCjs(schedulerExports);
const scheduler = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$q
}, [schedulerExports]);
const require$$1$F = /* @__PURE__ */ getAugmentedNamespace(scheduler);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = require$$0$1i, ca$1 = require$$1$F;
function p$5(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$5(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$3 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$3[a2] = new v$5(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$3[b2] = new v$5(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$3[a2] = new v$5(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$3[b2] = new v$5(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$3[b2] = new v$5(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$3[b2] = new v$5(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$3.xlinkHref = new v$5("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$3.hasOwnProperty(b2) ? z$3[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$2 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb$1(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb$1(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb$1(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$5(91));
  return A$2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$5(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$5(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A$2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$5(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$5(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$5(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$5(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$5(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$5(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$5(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$5(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$5(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$5(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$5(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$5(190));
  }
  if (3 !== c2.tag)
    throw Error(p$5(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca$1.unstable_scheduleCallback, bc = ca$1.unstable_cancelCallback, cc$1 = ca$1.unstable_shouldYield, dc = ca$1.unstable_requestPaint, B$3 = ca$1.unstable_now, ec = ca$1.unstable_getCurrentPriorityLevel, fc = ca$1.unstable_ImmediatePriority, gc = ca$1.unstable_UserBlockingPriority, hc = ca$1.unstable_NormalPriority, ic = ca$1.unstable_LowPriority, jc = ca$1.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C$2 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca$1.unstable_scheduleCallback(ca$1.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id$2, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id$2, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id$2 = null;
function Yc(a2, b2, c2, d2) {
  id$2 = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id$2 = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$2(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id$1 = A$2({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id$1), Kd = A$2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$2({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$2({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce$1 = ia && "TextEvent" in window && !be$1, de$1 = ia && (!ae$1 || be$1 && 8 < be$1 && 11 >= be$1), ee$1 = String.fromCharCode(32), fe$2 = false;
function ge$2(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$1 = false;
function je$1(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$2 = true;
      return ee$1;
    case "textInput":
      return a2 = b2.data, a2 === ee$1 && fe$2 ? null : a2;
    default:
      return null;
  }
}
function ke$1(a2, b2) {
  if (ie$1)
    return "compositionend" === a2 || !ae$1 && ge$2(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$1 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$1[a2.type] : "textarea" === b2 ? true : false;
}
function ne$1(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$2(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$1 = null, qe$1 = null;
function re$1(a2) {
  se$2(a2, 0);
}
function te$1(a2) {
  var b2 = ue(a2);
  if (Wa(b2))
    return a2;
}
function ve$1(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we$1 = false;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze$1.oninput;
    }
    xe$1 = ye$1;
  } else
    xe$1 = false;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), qe$1 = pe$1 = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$1(qe$1)) {
    var b2 = [];
    ne$1(b2, qe$1, a2, xb(a2));
    Jb(re$1, b2);
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae$1(), pe$1 = b2, qe$1 = c2, pe$1.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae$1();
}
function De$1(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$1(qe$1);
}
function Ee$1(a2, b2) {
  if ("click" === a2)
    return te$1(b2);
}
function Fe$1(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$1(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a2, b2) {
  if (He(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le$1(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le$1(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$1() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe$1(a2) {
  var b2 = Me$1(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le$1(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne$1(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re$1 = null, Se$1 = null, Te$1 = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$1 || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne$1(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie(Se$1, d2) || (Se$1 = d2, d2 = oe$2(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve$1(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe = {}, Ye$2 = {};
ia && (Ye$2 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze(a2) {
  if (Xe[a2])
    return Xe[a2];
  if (!We$1[a2])
    return a2;
  var b2 = We$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$2)
      return Xe[a2] = b2[c2];
  return a2;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$2(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$2(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$1;
        else if (me(h3))
          if (we$1)
            na = Fe$1;
          else {
            na = De$1;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$1);
        if (na && (na = na(a2, d3))) {
          ne$1(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb$1(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re$1 = d3, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re$1 = Qe = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae$1)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$1 ? ge$2(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$1 && "ko" !== c2.locale && (ie$1 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$1 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa = oe$2(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$1(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$1 ? je$1(a2, c2) : ke$1(a2, c2))
        d3 = oe$2(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se$2(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$2(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$5(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$5(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$2(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$1(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$2(Wf);
  E$2(H$2);
}
function ag(a2, b2, c2) {
  if (H$2.current !== Vf)
    throw Error(p$5(168));
  G$1(H$2, b2);
  G$1(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$5(108, Ra(a2) || "Unknown", e2));
  return A$2({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$1(H$2, a2);
  G$1(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$5(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$2(Wf), E$2(H$2), G$1(H$2, a2)) : E$2(Wf);
  G$1(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$2;
    try {
      var c2 = eg;
      for (C$2 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$2 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$2 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$2) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$5(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$2 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$5(418));
      a2.flags = a2.flags & -4097 | 2;
      I$2 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$2)
    return Fg(a2), I$2 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$5(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$5(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$2 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$2({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$2(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$5(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$1 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$2({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$5(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$2({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$2(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$5(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$5(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$5(284));
    if (!c2._owner)
      throw Error(p$5(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$5(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh$1(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$2 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$5(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$5(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$2 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh$1(true), Ch = vh$1(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$5(174));
  return a2;
}
function Ih(a2, b2) {
  G$1(Gh, b2);
  G$1(Fh, a2);
  G$1(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$2(Eh);
  G$1(Eh, b2);
}
function Jh() {
  E$2(Eh);
  E$2(Fh);
  E$2(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$1(Fh, a2), G$1(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$2(Eh), E$2(Fh));
}
var M$2 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$2 = null, O$1 = null, P$1 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$2() {
  throw Error(p$5(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f2) {
  Rh = f2;
  N$2 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$5(301));
      f2 += 1;
      P$1 = O$1 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O$1 && null !== O$1.next;
  Rh = 0;
  P$1 = O$1 = N$2 = null;
  Sh = false;
  if (b2)
    throw Error(p$5(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$1 ? N$2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  return P$1;
}
function di() {
  if (null === O$1) {
    var a2 = N$2.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$1.next;
  var b2 = null === P$1 ? N$2.memoizedState : P$1.next;
  if (null !== b2)
    P$1 = b2, O$1 = a2;
  else {
    if (null === a2)
      throw Error(p$5(310));
    O$1 = a2;
    a2 = { memoizedState: O$1.memoizedState, baseState: O$1.baseState, baseQueue: O$1.baseQueue, queue: O$1.queue, next: null };
    null === P$1 ? N$2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  }
  return P$1;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$5(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$1, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$2.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N$2.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$5(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N$2, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$1 && P$1.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R$2)
      throw Error(p$5(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N$2, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d2) {
  var e2 = ci();
  N$2.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$1) {
    var g2 = O$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N$2.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), N$2.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C$2;
  C$2 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$2 = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L$2();
    mh(c2, a2, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L$2(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N$2 || null !== b2 && b2 === N$2;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q$2, useContext: Q$2, useEffect: Q$2, useImperativeHandle: Q$2, useInsertionEffect: Q$2, useLayoutEffect: Q$2, useMemo: Q$2, useReducer: Q$2, useRef: Q$2, useState: Q$2, useDebugValue: Q$2, useDeferredValue: Q$2, useTransition: Q$2, useMutableSource: Q$2, useSyncExternalStore: Q$2, useId: Q$2, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N$2, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$2, e2 = ci();
  if (I$2) {
    if (void 0 === c2)
      throw Error(p$5(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$2)
      throw Error(p$5(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b2 = R$2.identifierPrefix;
  if (I$2) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di();
    return Di(b2, O$1.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di();
  return null === O$1 ? b2.memoizedState = a2 : Di(b2, O$1.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b2 = di().memoizedState;
  return [a2, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi$1 || (Pi$1 = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$2 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$1(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$1(fj, gj), gj |= d2;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$2 && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i(a2, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$2.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G$1(M$2, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$5(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$5(419));
    d2 = Li(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R$2;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$5(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$2 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M$2.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$1(M$2, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$5(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$1(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$1(M$2, M$2.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$1(M$2, M$2.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$1(M$2, M$2.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$1(M$2, M$2.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$2({}, e2, { value: void 0 });
        d2 = A$2({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$2)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$3(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$3(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$3(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$2(Wf);
      E$2(H$2);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$3(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$5(166));
          S$3(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$2("cancel", d2);
              D$2("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$2("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$2(lf[e2], d2);
              break;
            case "source":
              D$2("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$2(
                "error",
                d2
              );
              D$2("load", d2);
              break;
            case "details":
              D$2("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$2("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$2("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$2("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$2("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$2("cancel", a2);
                D$2("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$2("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$2(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$2("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$2(
                  "error",
                  a2
                );
                D$2("load", a2);
                e2 = d2;
                break;
              case "details":
                D$2("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$2("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$2({}, d2, { value: void 0 });
                D$2("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$2("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$2("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$3(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$5(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$3(b2);
      return null;
    case 13:
      E$2(M$2);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$2 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$5(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$5(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$3(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$2.current & 1) ? 0 === T$2 && (T$2 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$3(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$3(b2), null;
    case 10:
      return Rg(b2.type._context), S$3(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$3(b2), null;
    case 19:
      E$2(M$2);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$3(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$2 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$1(M$2, M$2.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$3() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$2)
              return S$3(b2), null;
          } else
            2 * B$3() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$3(), b2.sibling = null, c2 = M$2.current, G$1(M$2, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$3(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$3(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$3(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$5(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$2(Wf), E$2(H$2), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$2(M$2);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$5(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$2(M$2), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$1 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me$1();
  if (Ne$1(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$1 = b2; null !== V$1; )
    if (b2 = V$1, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$1 = a2;
    else
      for (; null !== V$1; ) {
        b2 = V$1;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$5(163));
            }
        } catch (F2) {
          W$1(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$1 = a2;
          break;
        }
        V$1 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$1 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$1 || Mj(c2, b2);
    case 6:
      var d2 = X$1, e2 = Yj;
      X$1 = null;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e2;
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d2 = X$1;
      e2 = Yj;
      X$1 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$1 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Zj(a2, b2, c2), U$1 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$1 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$1)
          throw Error(p$5(160));
        ak(f2, g2, e2);
        X$1 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$1(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$5(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$3()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$1 = (l2 = U$1) || m2, dk(b2, a2), U$1 = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$1 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$1 = m2; null !== V$1; ) {
              r2 = V$1;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$1 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$5(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$5(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$1 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$1; ) {
    var e2 = V$1, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
        h2 = Kj;
        var l2 = U$1;
        Kj = g2;
        if ((U$1 = k2) && !l2)
          for (V$1 = e2; null !== V$1; )
            g2 = V$1, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$1 = k2) : kk(e2);
        for (; null !== f2; )
          V$1 = f2, jk(f2), f2 = f2.sibling;
        V$1 = e2;
        Kj = h2;
        U$1 = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$1 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$1 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$1)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$5(163));
          }
        U$1 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$1 = h2;
      break;
    }
    V$1 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$1 = 0, R$2 = null, Y$1 = null, Z$1 = 0, gj = 0, fj = Uf(0), T$2 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi$1 = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$2() {
  return 0 !== (K$1 & 6) ? B$3() : -1 !== Bk ? Bk : Bk = B$3();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z$1)
    return Z$1 & -Z$1;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$2;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$5(185));
  Ac(a2, c2, d2);
  if (0 === (K$1 & 2) || a2 !== R$2)
    a2 === R$2 && (0 === (K$1 & 2) && (rk |= c2), 4 === T$2 && Dk(a2, Z$1)), Ek(a2, d2), 1 === c2 && 0 === K$1 && 0 === (b2.mode & 1) && (Hj = B$3() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$2 ? Z$1 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$5(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$2 ? Z$1 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    if (R$2 !== a2 || Z$1 !== b2)
      vk = null, Hj = B$3() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$1 = e2;
    null !== Y$1 ? b2 = 0 : (R$2 = null, Z$1 = 0, b2 = T$2);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$3()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$3()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$5(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$3(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L$2();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B$3() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$5(329));
      }
    }
  }
  Ek(a2, B$3());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$1 & 6))
    throw Error(p$5(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$3()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$3()), c2;
  if (6 === c2)
    throw Error(p$5(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$3());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, 0 === K$1 && (Hj = B$3() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d2 = C$2;
  try {
    if (pk.transition = null, C$2 = 1, a2)
      return a2();
  } finally {
    C$2 = d2, pk.transition = c2, K$1 = b2, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$2(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$1)
    for (c2 = Y$1.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$2(Wf);
          E$2(H$2);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$2(M$2);
          break;
        case 19:
          E$2(M$2);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$2 = a2;
  Y$1 = a2 = wh(a2.current, null);
  Z$1 = gj = b2;
  T$2 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N$2.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$1 = O$1 = N$2 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$2 = 1;
        qk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$1;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$5(426));
          }
        } else if (I$2 && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$2 && (T$2 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T$2 || 3 === T$2 || 2 === T$2)
    T$2 = 4;
  null === R$2 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$2, Z$1);
}
function Jk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Kk();
  if (R$2 !== a2 || Z$1 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K$1 = c2;
  nk.current = d2;
  if (null !== Y$1)
    throw Error(p$5(261));
  R$2 = null;
  Z$1 = 0;
  return T$2;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc$1(); )
    Vk(Y$1);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$1 = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$1 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$1 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$2 = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (null !== b2);
  0 === T$2 && (T$2 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$2, e2 = pk.transition;
  try {
    pk.transition = null, C$2 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C$2 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p$5(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$5(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R$2 && (Y$1 = R$2 = null, Z$1 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$2;
    C$2 = 1;
    var h2 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe$1(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$1 = h2;
    C$2 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B$3());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi$1)
    throw Pi$1 = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$2;
    try {
      pk.transition = null;
      C$2 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$5(331));
        var e2 = K$1;
        K$1 |= 4;
        for (V$1 = a2.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$1 = l2; null !== V$1; ) {
                  var m2 = V$1;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$1 = q2;
                  else
                    for (; null !== V$1; ) {
                      m2 = V$1;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$1 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$1 = r2;
                        break;
                      }
                      V$1 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$1 = g2;
          else
            b:
              for (; null !== V$1; ) {
                f2 = V$1;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$1 = x2;
                  break b;
                }
                V$1 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$1 = w2; null !== V$1; ) {
          g2 = V$1;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$1 = u2;
          else
            b:
              for (g2 = w2; null !== V$1; ) {
                h2 = V$1;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$1 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$1 = F2;
                  break b;
                }
                V$1 = h2.return;
              }
        }
        K$1 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$2 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$2();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$1(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$2();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$2();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$2 === a2 && (Z$1 & c2) === c2 && (4 === T$2 || 3 === T$2 && (Z$1 & 130023424) === Z$1 && 500 > B$3() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$2();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$5(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$2 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$2.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$2 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$5(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$5(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$5(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$5(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$2 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$1(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$5(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$5(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$5(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$5(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$5(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$2();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L$2(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g2);
  null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$5(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$3()), 0 === (K$1 & 6) && (Hj = B$3() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$2();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$2();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L$2();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$2;
};
Ic = function(a2, b2) {
  var c2 = C$2;
  try {
    return C$2 = a2, b2();
  } finally {
    C$2 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$5(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = reactDom_production_min$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
var createPortal = reactDom_production_min$1.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$5(200));
  return dl(a2, b2, null, c2);
};
var createRoot$1 = reactDom_production_min$1.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$5(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
var findDOMNode = reactDom_production_min$1.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$5(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$5(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
var flushSync$1 = reactDom_production_min$1.flushSync = function(a2) {
  return Sk(a2);
};
var hydrate$1 = reactDom_production_min$1.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$5(200));
  return sl(null, a2, b2, true, c2);
};
var hydrateRoot = reactDom_production_min$1.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$5(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
var render$1 = reactDom_production_min$1.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$5(200));
  return sl(null, a2, b2, false, c2);
};
var unmountComponentAtNode = reactDom_production_min$1.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$5(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
var unstable_batchedUpdates = reactDom_production_min$1.unstable_batchedUpdates = Rk;
var unstable_renderSubtreeIntoContainer = reactDom_production_min$1.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$5(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$5(38));
  return sl(a2, b2, c2, false, d2);
};
var version$a = reactDom_production_min$1.version = "18.2.0-next-9e3b772b8-20220608";
const reactDom_production_min = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  createPortal,
  createRoot: createRoot$1,
  default: reactDom_production_min$1,
  findDOMNode,
  flushSync: flushSync$1,
  hydrate: hydrate$1,
  hydrateRoot,
  render: render$1,
  unmountComponentAtNode,
  unstable_batchedUpdates,
  unstable_renderSubtreeIntoContainer,
  version: version$a
}, [reactDom_production_min$1]);
const require$$0$1d = /* @__PURE__ */ getAugmentedNamespace(reactDom_production_min);
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom$1.exports = require$$0$1d;
}
var reactDomExports = reactDom$1.exports;
const index$p = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
const reactDom = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$p
}, [reactDomExports]);
/**
 * @remix-run/router v1.14.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window2, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash: hash2 = ""
    } = parsePath(window2.location.hash.substr(1));
    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
      pathname = "/" + pathname;
    }
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createHashHref(window2, to) {
    let base3 = window2.document.querySelector("base");
    let href = "";
    if (base3 && base3.getAttribute("href")) {
      let url = window2.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning$1(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant$1(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning$1(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$2({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation2, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$2({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push2(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base3 = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    invariant$1(base3, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base3);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation2(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push: push2,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes2, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes2);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    matches = matchRouteBranch(
      branches[i2],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant$1(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant$1(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes2.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments2 = path.split("/");
  if (segments2.length === 0)
    return [];
  let [first, ...rest] = segments2;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s) => s === "*";
function computeScore(path, index2) {
  let segments2 = path.split("/");
  let initialScore = segments2.length;
  if (segments2.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments2.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end2 = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce((memo2, _ref, index2) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index2];
    if (isOptional && !value) {
      memo2[paramName] = void 0;
    } else {
      memo2[paramName] = safelyDecodeURIComponent(value || "", paramName);
    }
    return memo2;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  warning$1(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_2, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning$1(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning$1(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments2 = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments2.length > 1)
        segments2.pop();
    } else if (segment !== ".") {
      segments2.push(segment);
    }
  });
  return segments2.length > 1 ? segments2.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match, index2) => index2 === 0 || match.route.path && match.route.path.length > 0);
}
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);
  }
  return pathMatches.map((match) => match.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$2({}, toArg);
    invariant$1(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant$1(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant$1(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.21.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant$1(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant$1(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect$2(cb2) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb2);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant$1(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$2(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
function useParams() {
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    future
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes2, locationArg) {
  return useRoutesImpl(routes2, locationArg);
}
function useRoutesImpl(routes2, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant$1(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$1(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes2, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
    ]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$1({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState, future) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors2 = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors2 != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors2 == null ? void 0 : errors2[m2.route.id]));
    !(errorIndex >= 0) ? invariant$1(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i2 = 0; i2 < renderedMatches.length; i2++) {
      let match = renderedMatches[i2];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i2;
      }
      if (match.route.id) {
        let {
          loaderData,
          errors: errors3
        } = dataRouterState;
        let needsToRunLoader = match.route.loader && loaderData[match.route.id] === void 0 && (!errors3 || errors3[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index2) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors2 && match.route.id ? errors2[match.route.id] : void 0;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index2 === 0) {
          warningOnce("route-fallback", false);
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index2) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant$1(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant$1(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant$1(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant$1(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error !== void 0) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$2(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends$1({
        fromRouteId: id2
      }, options));
    }
  }, [router, id2]);
  return navigate;
}
const alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
  }
}
function Route(_props) {
  invariant$1(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant$1(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends$1({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes2 = [];
  reactExports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === reactExports.Fragment) {
      routes2.push.apply(routes2, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant$1(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant$1(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes2.push(route);
  });
  return routes2;
}
/**
 * React Router DOM v6.21.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }
  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) => {
    let value = init[key];
    return memo2.concat(Array.isArray(value) ? value.map((v2) => [key, v2]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    defaultSearchParams.forEach((_2, key) => {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach((value) => {
          searchParams.append(key, value);
        });
      }
    });
  }
  return searchParams;
}
const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"];
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$2[START_TRANSITION];
function HashRouter(_ref5) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref5;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future
  });
}
const isBrowser$2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref7, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace,
    state,
    target,
    to,
    preventScrollReset,
    unstable_viewTransition
  } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
    absoluteHref = to;
    if (isBrowser$2) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e2) {
      }
    }
  }
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative,
    unstable_viewTransition
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    unstable_viewTransition
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative,
        unstable_viewTransition
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);
}
function useSearchParams(defaultInit) {
  let defaultSearchParamsRef = reactExports.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = reactExports.useRef(false);
  let location = useLocation();
  let searchParams = reactExports.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)
  ), [location.search]);
  let navigate = useNavigate();
  let setSearchParams = reactExports.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = true;
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
function createSyncStoragePersister({
  storage,
  key = "REACT_QUERY_OFFLINE_CACHE",
  throttleTime = 1e3,
  serialize: serialize2 = JSON.stringify,
  deserialize: deserialize2 = JSON.parse,
  retry: retry2
}) {
  if (storage) {
    const trySave = (persistedClient) => {
      try {
        storage.setItem(key, serialize2(persistedClient));
        return;
      } catch (error) {
        return error;
      }
    };
    return {
      persistClient: throttle$1((persistedClient) => {
        let client2 = persistedClient;
        let error = trySave(client2);
        let errorCount = 0;
        while (error && client2) {
          errorCount++;
          client2 = retry2 == null ? void 0 : retry2({
            persistedClient: client2,
            error,
            errorCount
          });
          if (client2) {
            error = trySave(client2);
          }
        }
      }, throttleTime),
      restoreClient: () => {
        const cacheString = storage.getItem(key);
        if (!cacheString) {
          return;
        }
        return deserialize2(cacheString);
      },
      removeClient: () => {
        storage.removeItem(key);
      }
    };
  }
  return {
    persistClient: noop$5,
    restoreClient: () => void 0,
    removeClient: noop$5
  };
}
function throttle$1(func, wait2 = 100) {
  let timer = null;
  let params;
  return function(...args) {
    params = args;
    if (timer === null) {
      timer = setTimeout(() => {
        func(...params);
        timer = null;
      }, wait2);
    }
  };
}
function noop$5() {
}
class Subscribable {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    const identity2 = {
      listener
    };
    this.listeners.add(identity2);
    this.onSubscribe();
    return () => {
      this.listeners.delete(identity2);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}
const isServer = typeof window === "undefined" || "Deno" in window;
function noop$4() {
  return void 0;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function parseQueryArgs$1(arg1, arg2, arg3) {
  if (!isQueryKey$1(arg1)) {
    return arg1;
  }
  if (typeof arg2 === "function") {
    return {
      ...arg3,
      queryKey: arg1,
      queryFn: arg2
    };
  }
  return {
    ...arg2,
    queryKey: arg1
  };
}
function parseMutationArgs(arg1, arg2, arg3) {
  if (isQueryKey$1(arg1)) {
    if (typeof arg2 === "function") {
      return {
        ...arg3,
        mutationKey: arg1,
        mutationFn: arg2
      };
    }
    return {
      ...arg2,
      mutationKey: arg1
    };
  }
  if (typeof arg1 === "function") {
    return {
      ...arg2,
      mutationFn: arg1
    };
  }
  return {
    ...arg1
  };
}
function parseFilterArgs(arg1, arg2, arg3) {
  return isQueryKey$1(arg1) ? [{
    ...arg2,
    queryKey: arg1
  }, arg3] : [arg1 || {}, arg2];
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (isQueryKey$1(queryKey)) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const {
    exact,
    fetching,
    predicate,
    mutationKey: mutationKey3
  } = filters;
  if (isQueryKey$1(mutationKey3)) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey3)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey3)) {
      return false;
    }
  }
  if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
  return hashFn(queryKey);
}
function hashQueryKey(queryKey) {
  return JSON.stringify(queryKey, (_2, val) => isPlainObject$1(val) ? Object.keys(val).sort().reduce((result, key) => {
    result[key] = val[key];
    return result;
  }, {}) : val);
}
function partialMatchKey(a2, b2) {
  return partialDeepEqual(a2, b2);
}
function partialDeepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some((key) => !partialDeepEqual(a2[key], b2[key]));
  }
  return false;
}
function replaceEqualDeep(a2, b2) {
  if (a2 === b2) {
    return a2;
  }
  const array = isPlainArray(a2) && isPlainArray(b2);
  if (array || isPlainObject$1(a2) && isPlainObject$1(b2)) {
    const aSize = array ? a2.length : Object.keys(a2).length;
    const bItems = array ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy2 = array ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < bSize; i2++) {
      const key = array ? i2 : bItems[i2];
      copy2[key] = replaceEqualDeep(a2[key], b2[key]);
      if (copy2[key] === a2[key]) {
        equalItems++;
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy2;
  }
  return b2;
}
function shallowEqualObjects(a2, b2) {
  if (a2 && !b2 || b2 && !a2) {
    return false;
  }
  for (const key in a2) {
    if (a2[key] !== b2[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject$1(o) {
  if (!hasObjectPrototype$1(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype$1(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype$1(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isQueryKey$1(value) {
  return Array.isArray(value);
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function scheduleMicrotask(callback) {
  sleep(0).then(callback);
}
function getAbortController() {
  if (typeof AbortController === "function") {
    return new AbortController();
  }
  return;
}
function replaceData(prevData, data2, options) {
  if (options.isDataEqual != null && options.isDataEqual(prevData, data2)) {
    return prevData;
  } else if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data2);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data2);
  }
  return data2;
}
class FocusManager extends Subscribable {
  constructor() {
    super();
    this.setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        window.addEventListener("focus", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
          window.removeEventListener("focus", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    const changed = this.focused !== focused;
    if (changed) {
      this.focused = focused;
      this.onFocus();
    }
  }
  onFocus() {
    this.listeners.forEach(({
      listener
    }) => {
      listener();
    });
  }
  isFocused() {
    if (typeof this.focused === "boolean") {
      return this.focused;
    }
    if (typeof document === "undefined") {
      return true;
    }
    return [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
}
const focusManager = new FocusManager();
const onlineEvents = ["online", "offline"];
class OnlineManager extends Subscribable {
  constructor() {
    super();
    this.setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onOnline();
        onlineEvents.forEach((event) => {
          window.addEventListener(event, listener, false);
        });
        return () => {
          onlineEvents.forEach((event) => {
            window.removeEventListener(event, listener);
          });
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((online) => {
      if (typeof online === "boolean") {
        this.setOnline(online);
      } else {
        this.onOnline();
      }
    });
  }
  setOnline(online) {
    const changed = this.online !== online;
    if (changed) {
      this.online = online;
      this.onOnline();
    }
  }
  onOnline() {
    this.listeners.forEach(({
      listener
    }) => {
      listener();
    });
  }
  isOnline() {
    if (typeof this.online === "boolean") {
      return this.online;
    }
    if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
      return true;
    }
    return navigator.onLine;
  }
}
const onlineManager = new OnlineManager();
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
}
class CancelledError {
  constructor(options) {
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
}
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      config2.abort == null ? void 0 : config2.abort();
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const shouldPause = () => !focusManager.isFocused() || config2.networkMode !== "always" && !onlineManager.isOnline();
  const resolve = (value) => {
    if (!isResolved) {
      isResolved = true;
      config2.onSuccess == null ? void 0 : config2.onSuccess(value);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved) {
      isResolved = true;
      config2.onError == null ? void 0 : config2.onError(value);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        const canContinue = isResolved || !shouldPause();
        if (canContinue) {
          continueResolve(value);
        }
        return canContinue;
      };
      config2.onPause == null ? void 0 : config2.onPause();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved) {
        config2.onContinue == null ? void 0 : config2.onContinue();
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    try {
      promiseOrValue = config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _config$retry, _config$retryDelay;
      if (isResolved) {
        return;
      }
      const retry2 = (_config$retry = config2.retry) != null ? _config$retry : 3;
      const retryDelay = (_config$retryDelay = config2.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
      const delay2 = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry2 === true || typeof retry2 === "number" && failureCount < retry2 || typeof retry2 === "function" && retry2(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config2.onFail == null ? void 0 : config2.onFail(failureCount, error);
      sleep(delay2).then(() => {
        if (shouldPause()) {
          return pause();
        }
        return;
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  if (canFetch(config2.networkMode)) {
    run();
  } else {
    pause().then(run);
  }
  return {
    promise,
    cancel,
    continue: () => {
      const didContinue = continueFn == null ? void 0 : continueFn();
      return didContinue ? promise : Promise.resolve();
    },
    cancelRetry,
    continueRetry
  };
}
const defaultLogger = console;
function createNotifyManager() {
  let queue = [];
  let transactions2 = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  const batch2 = (callback) => {
    let result;
    transactions2++;
    try {
      result = callback();
    } finally {
      transactions2--;
      if (!transactions2) {
        flush2();
      }
    }
    return result;
  };
  const schedule = (callback) => {
    if (transactions2) {
      queue.push(callback);
    } else {
      scheduleMicrotask(() => {
        notifyFn(callback);
      });
    }
  };
  const batchCalls = (callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args);
      });
    };
  };
  const flush2 = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleMicrotask(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  const setNotifyFunction = (fn) => {
    notifyFn = fn;
  };
  const setBatchNotifyFunction = (fn) => {
    batchNotifyFn = fn;
  };
  return {
    batch: batch2,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction
  };
}
const notifyManager = createNotifyManager();
class Removable {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.cacheTime)) {
      this.gcTimeout = setTimeout(() => {
        this.optionalRemove();
      }, this.cacheTime);
    }
  }
  updateCacheTime(newCacheTime) {
    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1e3);
  }
  clearGcTimeout() {
    if (this.gcTimeout) {
      clearTimeout(this.gcTimeout);
      this.gcTimeout = void 0;
    }
  }
}
class Query extends Removable {
  constructor(config2) {
    super();
    this.abortSignalConsumed = false;
    this.defaultOptions = config2.defaultOptions;
    this.setOptions(config2.options);
    this.observers = [];
    this.cache = config2.cache;
    this.logger = config2.logger || defaultLogger;
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    this.initialState = config2.state || getDefaultState$1(this.options);
    this.state = this.initialState;
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(options) {
    this.options = {
      ...this.defaultOptions,
      ...options
    };
    this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.cache.remove(this);
    }
  }
  setData(newData, options) {
    const data2 = replaceData(this.state.data, newData, this.options);
    this.dispatch({
      data: data2,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data2;
  }
  setState(state, setStateOptions) {
    this.dispatch({
      type: "setState",
      state,
      setStateOptions
    });
  }
  cancel(options) {
    var _this$retryer;
    const promise = this.promise;
    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
    return promise ? promise.then(noop$4).catch(noop$4) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({
      silent: true
    });
  }
  reset() {
    this.destroy();
    this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((observer) => observer.options.enabled !== false);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _this$retryer2;
    const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
  }
  onOnline() {
    var _this$retryer3;
    const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.cache.notify({
        type: "observerAdded",
        query: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x2) => x2 !== observer);
      if (!this.observers.length) {
        if (this.retryer) {
          if (this.abortSignalConsumed) {
            this.retryer.cancel({
              revert: true
            });
          } else {
            this.retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.cache.notify({
        type: "observerRemoved",
        query: this,
        observer
      });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.dispatch({
        type: "invalidate"
      });
    }
  }
  fetch(options, fetchOptions) {
    var _this$options$behavio, _context$fetchOptions;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
        this.cancel({
          silent: true
        });
      } else if (this.promise) {
        var _this$retryer4;
        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
        return this.promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x2) => x2.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = getAbortController();
    const queryFnContext = {
      queryKey: this.queryKey,
      pageParam: void 0,
      meta: this.meta
    };
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          if (abortController) {
            this.abortSignalConsumed = true;
            return abortController.signal;
          }
          return void 0;
        }
      });
    };
    addSignalProperty(queryFnContext);
    const fetchFn = () => {
      if (!this.options.queryFn) {
        return Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'");
      }
      this.abortSignalConsumed = false;
      return this.options.queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
    this.revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
      var _context$fetchOptions2;
      this.dispatch({
        type: "fetch",
        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
      });
    }
    const onError = (error) => {
      if (!(isCancelledError(error) && error.silent)) {
        this.dispatch({
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;
        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };
    this.retryer = createRetryer({
      fn: context.fetchFn,
      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
      onSuccess: (data2) => {
        var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;
        if (typeof data2 === "undefined") {
          onError(new Error(this.queryHash + " data is undefined"));
          return;
        }
        this.setData(data2);
        (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data2, this);
        (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data2, this.state.error, this);
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError,
      onFail: (failureCount, error) => {
        this.dispatch({
          type: "failed",
          failureCount,
          error
        });
      },
      onPause: () => {
        this.dispatch({
          type: "pause"
        });
      },
      onContinue: () => {
        this.dispatch({
          type: "continue"
        });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode
    });
    this.promise = this.retryer.promise;
    return this.promise;
  }
  dispatch(action) {
    const reducer = (state) => {
      var _action$meta, _action$dataUpdatedAt;
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
            fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
            ...!state.dataUpdatedAt && {
              error: null,
              status: "loading"
            }
          };
        case "success":
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const error = action.error;
          if (isCancelledError(error) && error.revert && this.revertState) {
            return {
              ...this.revertState,
              fetchStatus: "idle"
            };
          }
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate(action);
      });
      this.cache.notify({
        query: this,
        type: "updated",
        action
      });
    });
  }
}
function getDefaultState$1(options) {
  const data2 = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = typeof data2 !== "undefined";
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data: data2,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "loading",
    fetchStatus: "idle"
  };
}
class QueryCache extends Subscribable {
  constructor(config2) {
    super();
    this.config = config2 || {};
    this.queries = [];
    this.queriesMap = {};
  }
  build(client2, options, state) {
    var _options$queryHash;
    const queryKey = options.queryKey;
    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        logger: client2.getLogger(),
        queryKey,
        queryHash,
        options: client2.defaultQueryOptions(options),
        state,
        defaultOptions: client2.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.queriesMap[query.queryHash]) {
      this.queriesMap[query.queryHash] = query;
      this.queries.push(query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.queriesMap[query.queryHash];
    if (queryInMap) {
      query.destroy();
      this.queries = this.queries.filter((x2) => x2 !== query);
      if (queryInMap === query) {
        delete this.queriesMap[query.queryHash];
      }
      this.notify({
        type: "removed",
        query
      });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.queriesMap[queryHash];
  }
  getAll() {
    return this.queries;
  }
  find(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.queries.find((query) => matchQuery(filters, query));
  }
  findAll(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    return Object.keys(filters).length > 0 ? this.queries.filter((query) => matchQuery(filters, query)) : this.queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach(({
        listener
      }) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onOnline();
      });
    });
  }
}
class Mutation extends Removable {
  constructor(config2) {
    super();
    this.defaultOptions = config2.defaultOptions;
    this.mutationId = config2.mutationId;
    this.mutationCache = config2.mutationCache;
    this.logger = config2.logger || defaultLogger;
    this.observers = [];
    this.state = config2.state || getDefaultState();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = {
      ...this.defaultOptions,
      ...options
    };
    this.updateCacheTime(this.options.cacheTime);
  }
  get meta() {
    return this.options.meta;
  }
  setState(state) {
    this.dispatch({
      type: "setState",
      state
    });
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.observers = this.observers.filter((x2) => x2 !== observer);
    this.scheduleGc();
    this.mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.observers.length) {
      if (this.state.status === "loading") {
        this.scheduleGc();
      } else {
        this.mutationCache.remove(this);
      }
    }
  }
  continue() {
    var _this$retryer$continu, _this$retryer;
    return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();
  }
  async execute() {
    const executeMutation = () => {
      var _this$options$retry;
      this.retryer = createRetryer({
        fn: () => {
          if (!this.options.mutationFn) {
            return Promise.reject("No mutationFn found");
          }
          return this.options.mutationFn(this.state.variables);
        },
        onFail: (failureCount, error) => {
          this.dispatch({
            type: "failed",
            failureCount,
            error
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode
      });
      return this.retryer.promise;
    };
    const restored = this.state.status === "loading";
    try {
      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;
      if (!restored) {
        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
        this.dispatch({
          type: "loading",
          variables: this.options.variables
        });
        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
        if (context !== this.state.context) {
          this.dispatch({
            type: "loading",
            context,
            variables: this.state.variables
          });
        }
      }
      const data2 = await executeMutation();
      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data2, this.state.variables, this.state.context, this));
      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data2, this.state.variables, this.state.context));
      await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data2, null, this.state.variables, this.state.context, this));
      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data2, null, this.state.variables, this.state.context));
      this.dispatch({
        type: "success",
        data: data2
      });
      return data2;
    } catch (error) {
      try {
        var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;
        await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));
        if (false)
          ;
        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
        await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, void 0, error, this.state.variables, this.state.context, this));
        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
        throw error;
      } finally {
        this.dispatch({
          type: "error",
          error
        });
      }
    }
  }
  dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "loading":
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !canFetch(this.options.networkMode),
            status: "loading",
            variables: action.variables
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
}
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}
class MutationCache extends Subscribable {
  constructor(config2) {
    super();
    this.config = config2 || {};
    this.mutations = [];
    this.mutationId = 0;
  }
  build(client2, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      logger: client2.getLogger(),
      mutationId: ++this.mutationId,
      options: client2.defaultMutationOptions(options),
      state,
      defaultOptions: options.mutationKey ? client2.getMutationDefaults(options.mutationKey) : void 0
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.mutations.push(mutation);
    this.notify({
      type: "added",
      mutation
    });
  }
  remove(mutation) {
    this.mutations = this.mutations.filter((x2) => x2 !== mutation);
    this.notify({
      type: "removed",
      mutation
    });
  }
  clear() {
    notifyManager.batch(() => {
      this.mutations.forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(filters) {
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.mutations.find((mutation) => matchMutation(filters, mutation));
  }
  findAll(filters) {
    return this.mutations.filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach(({
        listener
      }) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    var _this$resuming;
    this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {
      const pausedMutations = this.mutations.filter((x2) => x2.state.isPaused);
      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop$4)), Promise.resolve()));
    }).then(() => {
      this.resuming = void 0;
    });
    return this.resuming;
  }
}
function infiniteQueryBehavior() {
  return {
    onFetch: (context) => {
      context.fetchFn = () => {
        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
        let newPageParams = oldPageParams;
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              var _context$signal;
              if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                cancelled = true;
              } else {
                var _context$signal2;
                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + context.options.queryHash + "'"));
        const buildNewPages = (pages, param, page, previous) => {
          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
          return previous ? [page, ...pages] : [...pages, page];
        };
        const fetchPage = (pages, manual, param, previous) => {
          if (cancelled) {
            return Promise.reject("Cancelled");
          }
          if (typeof param === "undefined" && !manual && pages.length) {
            return Promise.resolve(pages);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const queryFnResult = queryFn(queryFnContext);
          const promise2 = Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous));
          return promise2;
        };
        let promise;
        if (!oldPages.length) {
          promise = fetchPage([]);
        } else if (isFetchingNextPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param);
        } else if (isFetchingPreviousPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param, true);
        } else {
          newPageParams = [];
          const manual = typeof context.options.getNextPageParam === "undefined";
          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
          for (let i2 = 1; i2 < oldPages.length; i2++) {
            promise = promise.then((pages) => {
              const shouldFetchNextPage = refetchPage && oldPages[i2] ? refetchPage(oldPages[i2], i2, oldPages) : true;
              if (shouldFetchNextPage) {
                const param = manual ? oldPageParams[i2] : getNextPageParam(context.options, pages);
                return fetchPage(pages, manual, param);
              }
              return Promise.resolve(buildNewPages(pages, oldPageParams[i2], oldPages[i2]));
            });
          }
        }
        const finalPromise = promise.then((pages) => ({
          pages,
          pageParams: newPageParams
        }));
        return finalPromise;
      };
    }
  };
}
function getNextPageParam(options, pages) {
  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
}
function getPreviousPageParam(options, pages) {
  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
}
class QueryClient {
  constructor(config2 = {}) {
    this.queryCache = config2.queryCache || new QueryCache();
    this.mutationCache = config2.mutationCache || new MutationCache();
    this.logger = config2.logger || defaultLogger;
    this.defaultOptions = config2.defaultOptions || {};
    this.queryDefaults = [];
    this.mutationDefaults = [];
    this.mountCount = 0;
  }
  mount() {
    this.mountCount++;
    if (this.mountCount !== 1)
      return;
    this.unsubscribeFocus = focusManager.subscribe(() => {
      if (focusManager.isFocused()) {
        this.resumePausedMutations();
        this.queryCache.onFocus();
      }
    });
    this.unsubscribeOnline = onlineManager.subscribe(() => {
      if (onlineManager.isOnline()) {
        this.resumePausedMutations();
        this.queryCache.onOnline();
      }
    });
  }
  unmount() {
    var _this$unsubscribeFocu, _this$unsubscribeOnli;
    this.mountCount--;
    if (this.mountCount !== 0)
      return;
    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
    this.unsubscribeFocus = void 0;
    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
    this.unsubscribeOnline = void 0;
  }
  isFetching(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    filters.fetchStatus = "fetching";
    return this.queryCache.findAll(filters).length;
  }
  isMutating(filters) {
    return this.mutationCache.findAll({
      ...filters,
      fetching: true
    }).length;
  }
  getQueryData(queryKey, filters) {
    var _this$queryCache$find;
    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
  }
  ensureQueryData(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs$1(arg1, arg2, arg3);
    const cachedData = this.getQueryData(parsedOptions.queryKey);
    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
  }
  getQueriesData(queryKeyOrFilters) {
    return this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey,
      state
    }) => {
      const data2 = state.data;
      return [queryKey, data2];
    });
  }
  setQueryData(queryKey, updater, options) {
    const query = this.queryCache.find(queryKey);
    const prevData = query == null ? void 0 : query.state.data;
    const data2 = functionalUpdate(updater, prevData);
    if (typeof data2 === "undefined") {
      return void 0;
    }
    const parsedOptions = parseQueryArgs$1(queryKey);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    return this.queryCache.build(this, defaultedOptions).setData(data2, {
      ...options,
      manual: true
    });
  }
  setQueriesData(queryKeyOrFilters, updater, options) {
    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey
    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
  }
  getQueryState(queryKey, filters) {
    var _this$queryCache$find2;
    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
  }
  removeQueries(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    const queryCache = this.queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    const queryCache = this.queryCache;
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(arg1, arg2, arg3) {
    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);
    if (typeof cancelOptions.revert === "undefined") {
      cancelOptions.revert = true;
    }
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
    return Promise.all(promises).then(noop$4).catch(noop$4);
  }
  invalidateQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    return notifyManager.batch(() => {
      var _ref, _filters$refetchType;
      this.queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
      var _options$cancelRefetc;
      return query.fetch(void 0, {
        ...options,
        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
        meta: {
          refetchPage: filters.refetchPage
        }
      });
    }));
    let promise = Promise.all(promises).then(noop$4);
    if (!(options != null && options.throwOnError)) {
      promise = promise.catch(noop$4);
    }
    return promise;
  }
  fetchQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs$1(arg1, arg2, arg3);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    if (typeof defaultedOptions.retry === "undefined") {
      defaultedOptions.retry = false;
    }
    const query = this.queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(arg1, arg2, arg3) {
    return this.fetchQuery(arg1, arg2, arg3).then(noop$4).catch(noop$4);
  }
  fetchInfiniteQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs$1(arg1, arg2, arg3);
    parsedOptions.behavior = infiniteQueryBehavior();
    return this.fetchQuery(parsedOptions);
  }
  prefetchInfiniteQuery(arg1, arg2, arg3) {
    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop$4).catch(noop$4);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(options) {
    this.defaultOptions = options;
  }
  setQueryDefaults(queryKey, options) {
    const result = this.queryDefaults.find((x2) => hashQueryKey(queryKey) === hashQueryKey(x2.queryKey));
    if (result) {
      result.defaultOptions = options;
    } else {
      this.queryDefaults.push({
        queryKey,
        defaultOptions: options
      });
    }
  }
  getQueryDefaults(queryKey) {
    if (!queryKey) {
      return void 0;
    }
    const firstMatchingDefaults = this.queryDefaults.find((x2) => partialMatchKey(queryKey, x2.queryKey));
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  setMutationDefaults(mutationKey3, options) {
    const result = this.mutationDefaults.find((x2) => hashQueryKey(mutationKey3) === hashQueryKey(x2.mutationKey));
    if (result) {
      result.defaultOptions = options;
    } else {
      this.mutationDefaults.push({
        mutationKey: mutationKey3,
        defaultOptions: options
      });
    }
  }
  getMutationDefaults(mutationKey3) {
    if (!mutationKey3) {
      return void 0;
    }
    const firstMatchingDefaults = this.mutationDefaults.find((x2) => partialMatchKey(mutationKey3, x2.mutationKey));
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  defaultQueryOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
    }
    if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (typeof defaultedOptions.useErrorBoundary === "undefined") {
      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    return {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    this.queryCache.clear();
    this.mutationCache.clear();
  }
}
class QueryObserver extends Subscribable {
  constructor(client2, options) {
    super();
    this.client = client2;
    this.options = options;
    this.trackedProps = /* @__PURE__ */ new Set();
    this.selectError = null;
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.remove = this.remove.bind(this);
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      this.currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.currentQuery, this.options)) {
        this.executeFetch();
      }
      this.updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    this.clearStaleTimeout();
    this.clearRefetchInterval();
    this.currentQuery.removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = this.currentQuery;
    this.options = this.client.defaultQueryOptions(options);
    if (!shallowEqualObjects(prevOptions, this.options)) {
      this.client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.currentQuery,
        observer: this
      });
    }
    if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
      throw new Error("Expected enabled to be a boolean");
    }
    if (!this.options.queryKey) {
      this.options.queryKey = prevOptions.queryKey;
    }
    this.updateQuery();
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
      this.executeFetch();
    }
    this.updateResult(notifyOptions);
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
      this.updateStaleTimeout();
    }
    const nextRefetchInterval = this.computeRefetchInterval();
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
      this.updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = this.client.getQueryCache().build(this.client, options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result, options)) {
      this.currentResult = result;
      this.currentResultOptions = this.options;
      this.currentResultState = this.currentQuery.state;
    }
    return result;
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(result) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackedProps.add(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({
    refetchPage,
    ...options
  } = {}) {
    return this.fetch({
      ...options,
      meta: {
        refetchPage
      }
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = this.client.defaultQueryOptions(options);
    const query = this.client.getQueryCache().build(this.client, defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    var _fetchOptions$cancelR;
    return this.executeFetch({
      ...fetchOptions,
      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
    }).then(() => {
      this.updateResult();
      return this.currentResult;
    });
  }
  executeFetch(fetchOptions) {
    this.updateQuery();
    let promise = this.currentQuery.fetch(this.options, fetchOptions);
    if (!(fetchOptions != null && fetchOptions.throwOnError)) {
      promise = promise.catch(noop$4);
    }
    return promise;
  }
  updateStaleTimeout() {
    this.clearStaleTimeout();
    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
      return;
    }
    const time2 = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
    const timeout = time2 + 1;
    this.staleTimeoutId = setTimeout(() => {
      if (!this.currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  computeRefetchInterval() {
    var _this$options$refetch;
    return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
  }
  updateRefetchInterval(nextInterval) {
    this.clearRefetchInterval();
    this.currentRefetchInterval = nextInterval;
    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
      return;
    }
    this.refetchIntervalId = setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.executeFetch();
      }
    }, this.currentRefetchInterval);
  }
  updateTimers() {
    this.updateStaleTimeout();
    this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    if (this.staleTimeoutId) {
      clearTimeout(this.staleTimeoutId);
      this.staleTimeoutId = void 0;
    }
  }
  clearRefetchInterval() {
    if (this.refetchIntervalId) {
      clearInterval(this.refetchIntervalId);
      this.refetchIntervalId = void 0;
    }
  }
  createResult(query, options) {
    const prevQuery = this.currentQuery;
    const prevOptions = this.options;
    const prevResult = this.currentResult;
    const prevResultState = this.currentResultState;
    const prevResultOptions = this.currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
    const {
      state
    } = query;
    let {
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      fetchStatus,
      status
    } = state;
    let isPreviousData = false;
    let isPlaceholderData = false;
    let data2;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        fetchStatus = canFetch(query.options.networkMode) ? "fetching" : "paused";
        if (!dataUpdatedAt) {
          status = "loading";
        }
      }
      if (options._optimisticResults === "isRestoring") {
        fetchStatus = "idle";
      }
    }
    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
      data2 = prevQueryResult.data;
      dataUpdatedAt = prevQueryResult.dataUpdatedAt;
      status = prevQueryResult.status;
      isPreviousData = true;
    } else if (options.select && typeof state.data !== "undefined") {
      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
        data2 = this.selectResult;
      } else {
        try {
          this.selectFn = options.select;
          data2 = options.select(state.data);
          data2 = replaceData(prevResult == null ? void 0 : prevResult.data, data2, options);
          this.selectResult = data2;
          this.selectError = null;
        } catch (selectError) {
          this.selectError = selectError;
        }
      }
    } else {
      data2 = state.data;
    }
    if (typeof options.placeholderData !== "undefined" && typeof data2 === "undefined" && status === "loading") {
      let placeholderData;
      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
        if (options.select && typeof placeholderData !== "undefined") {
          try {
            placeholderData = options.select(placeholderData);
            this.selectError = null;
          } catch (selectError) {
            this.selectError = selectError;
          }
        }
      }
      if (typeof placeholderData !== "undefined") {
        status = "success";
        data2 = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);
        isPlaceholderData = true;
      }
    }
    if (this.selectError) {
      error = this.selectError;
      data2 = this.selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = fetchStatus === "fetching";
    const isLoading = status === "loading";
    const isError = status === "error";
    const result = {
      status,
      fetchStatus,
      isLoading,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading && isFetching,
      data: data2,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: state.fetchFailureCount,
      failureReason: state.fetchFailureReason,
      errorUpdateCount: state.errorUpdateCount,
      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isLoading,
      isLoadingError: isError && state.dataUpdatedAt === 0,
      isPaused: fetchStatus === "paused",
      isPlaceholderData,
      isPreviousData,
      isRefetchError: isError && state.dataUpdatedAt !== 0,
      isStale: isStale(query, options),
      refetch: this.refetch,
      remove: this.remove
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = this.currentResult;
    const nextResult = this.createResult(this.currentQuery, this.options);
    this.currentResultState = this.currentQuery.state;
    this.currentResultOptions = this.options;
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.currentResult = nextResult;
    const defaultNotifyOptions = {
      cache: true
    };
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const {
        notifyOnChangeProps
      } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.trackedProps.size) {
        return true;
      }
      const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);
      if (this.options.useErrorBoundary) {
        includedProps.add("error");
      }
      return Object.keys(this.currentResult).some((key) => {
        const typedKey = key;
        const changed = this.currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    this.notify({
      ...defaultNotifyOptions,
      ...notifyOptions
    });
  }
  updateQuery() {
    const query = this.client.getQueryCache().build(this.client, this.options);
    if (query === this.currentQuery) {
      return;
    }
    const prevQuery = this.currentQuery;
    this.currentQuery = query;
    this.currentQueryInitialState = query.state;
    this.previousQueryResult = this.currentResult;
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate(action) {
    const notifyOptions = {};
    if (action.type === "success") {
      notifyOptions.onSuccess = !action.manual;
    } else if (action.type === "error" && !isCancelledError(action.error)) {
      notifyOptions.onError = true;
    }
    this.updateResult(notifyOptions);
    if (this.hasListeners()) {
      this.updateTimers();
    }
  }
  notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.onSuccess) {
        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
      } else if (notifyOptions.onError) {
        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
      }
      if (notifyOptions.listeners) {
        this.listeners.forEach(({
          listener
        }) => {
          listener(this.currentResult);
        });
      }
      if (notifyOptions.cache) {
        this.client.getQueryCache().notify({
          query: this.currentQuery,
          type: "observerResultsUpdated"
        });
      }
    });
  }
}
function shouldLoadOnMount(query, options) {
  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (options.enabled !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return query.isStaleByTime(options.staleTime);
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {
  if (options.keepPreviousData) {
    return false;
  }
  if (options.placeholderData !== void 0) {
    return optimisticResult.isPlaceholderData;
  }
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}
let MutationObserver$1 = class MutationObserver2 extends Subscribable {
  constructor(client2, options) {
    super();
    this.client = client2;
    this.setOptions(options);
    this.bindMethods();
    this.updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _this$currentMutation;
    const prevOptions = this.options;
    this.options = this.client.defaultMutationOptions(options);
    if (!shallowEqualObjects(prevOptions, this.options)) {
      this.client.getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: this.currentMutation,
        observer: this
      });
    }
    (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$currentMutation2;
      (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.updateResult();
    const notifyOptions = {
      listeners: true
    };
    if (action.type === "success") {
      notifyOptions.onSuccess = true;
    } else if (action.type === "error") {
      notifyOptions.onError = true;
    }
    this.notify(notifyOptions);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  reset() {
    this.currentMutation = void 0;
    this.updateResult();
    this.notify({
      listeners: true
    });
  }
  mutate(variables, options) {
    this.mutateOptions = options;
    if (this.currentMutation) {
      this.currentMutation.removeObserver(this);
    }
    this.currentMutation = this.client.getMutationCache().build(this.client, {
      ...this.options,
      variables: typeof variables !== "undefined" ? variables : this.options.variables
    });
    this.currentMutation.addObserver(this);
    return this.currentMutation.execute();
  }
  updateResult() {
    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();
    const result = {
      ...state,
      isLoading: state.status === "loading",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
    this.currentResult = result;
  }
  notify(options) {
    notifyManager.batch(() => {
      if (this.mutateOptions && this.hasListeners()) {
        if (options.onSuccess) {
          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
        } else if (options.onError) {
          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
        }
      }
      if (options.listeners) {
        this.listeners.forEach(({
          listener
        }) => {
          listener(this.currentResult);
        });
      }
    });
  }
};
function dehydrateMutation(mutation) {
  return {
    mutationKey: mutation.options.mutationKey,
    state: mutation.state
  };
}
function dehydrateQuery(query) {
  return {
    state: query.state,
    queryKey: query.queryKey,
    queryHash: query.queryHash
  };
}
function defaultShouldDehydrateMutation(mutation) {
  return mutation.state.isPaused;
}
function defaultShouldDehydrateQuery(query) {
  return query.state.status === "success";
}
function dehydrate(client2, options = {}) {
  const mutations = [];
  const queries = [];
  if (options.dehydrateMutations !== false) {
    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;
    client2.getMutationCache().getAll().forEach((mutation) => {
      if (shouldDehydrateMutation(mutation)) {
        mutations.push(dehydrateMutation(mutation));
      }
    });
  }
  if (options.dehydrateQueries !== false) {
    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;
    client2.getQueryCache().getAll().forEach((query) => {
      if (shouldDehydrateQuery(query)) {
        queries.push(dehydrateQuery(query));
      }
    });
  }
  return {
    mutations,
    queries
  };
}
function hydrate(client2, dehydratedState, options) {
  if (typeof dehydratedState !== "object" || dehydratedState === null) {
    return;
  }
  const mutationCache = client2.getMutationCache();
  const queryCache = client2.getQueryCache();
  const mutations = dehydratedState.mutations || [];
  const queries = dehydratedState.queries || [];
  mutations.forEach((dehydratedMutation) => {
    var _options$defaultOptio;
    mutationCache.build(client2, {
      ...options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations,
      mutationKey: dehydratedMutation.mutationKey
    }, dehydratedMutation.state);
  });
  queries.forEach(({
    queryKey,
    state,
    queryHash
  }) => {
    var _options$defaultOptio2;
    const query = queryCache.get(queryHash);
    if (query) {
      if (query.state.dataUpdatedAt < state.dataUpdatedAt) {
        const {
          fetchStatus: _ignored,
          ...dehydratedQueryState
        } = state;
        query.setState(dehydratedQueryState);
      }
      return;
    }
    queryCache.build(
      client2,
      {
        ...options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries,
        queryKey,
        queryHash
      },
      // Reset fetch status to idle to avoid
      // query being stuck in fetching state upon hydration
      {
        ...state,
        fetchStatus: "idle"
      }
    );
  });
}
var shim$1 = { exports: {} };
var useSyncExternalStoreShim_production_min$1 = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$2 = require$$0$1i;
function h$4(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k$4 = "function" === typeof Object.is ? Object.is : h$4, l$2 = e$2.useState, m$5 = e$2.useEffect, n$3 = e$2.useLayoutEffect, p$4 = e$2.useDebugValue;
function q$5(a2, b2) {
  var d2 = b2(), f2 = l$2({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$3(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$3(c2) && g2({ inst: c2 });
  }, [a2, d2, b2]);
  m$5(function() {
    r$3(c2) && g2({ inst: c2 });
    return a2(function() {
      r$3(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$4(d2);
  return d2;
}
function r$3(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k$4(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$3(a2, b2) {
  return b2();
}
var u$3 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$3 : q$5;
var useSyncExternalStore$1 = useSyncExternalStoreShim_production_min$1.useSyncExternalStore = void 0 !== e$2.useSyncExternalStore ? e$2.useSyncExternalStore : u$3;
const useSyncExternalStoreShim_production_min = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: useSyncExternalStoreShim_production_min$1,
  useSyncExternalStore: useSyncExternalStore$1
}, [useSyncExternalStoreShim_production_min$1]);
const require$$0$1c = /* @__PURE__ */ getAugmentedNamespace(useSyncExternalStoreShim_production_min);
{
  shim$1.exports = require$$0$1c;
}
var shimExports = shim$1.exports;
const index$o = /* @__PURE__ */ getDefaultExportFromCjs(shimExports);
const shim = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$o
}, [shimExports]);
const useSyncExternalStore = shimExports.useSyncExternalStore;
const defaultContext = /* @__PURE__ */ reactExports.createContext(void 0);
const QueryClientSharingContext = /* @__PURE__ */ reactExports.createContext(false);
function getQueryClientContext(context, contextSharing) {
  if (context) {
    return context;
  }
  if (contextSharing && typeof window !== "undefined") {
    if (!window.ReactQueryClientContext) {
      window.ReactQueryClientContext = defaultContext;
    }
    return window.ReactQueryClientContext;
  }
  return defaultContext;
}
const useQueryClient = ({
  context
} = {}) => {
  const queryClient = reactExports.useContext(getQueryClientContext(context, reactExports.useContext(QueryClientSharingContext)));
  if (!queryClient) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return queryClient;
};
const QueryClientProvider = ({
  client: client2,
  children,
  context,
  contextSharing = false
}) => {
  reactExports.useEffect(() => {
    client2.mount();
    return () => {
      client2.unmount();
    };
  }, [client2]);
  const Context2 = getQueryClientContext(context, contextSharing);
  return /* @__PURE__ */ reactExports.createElement(QueryClientSharingContext.Provider, {
    value: !context && contextSharing
  }, /* @__PURE__ */ reactExports.createElement(Context2.Provider, {
    value: client2
  }, children));
};
const IsRestoringContext = /* @__PURE__ */ reactExports.createContext(false);
const useIsRestoring = () => reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
const QueryErrorResetBoundaryContext = /* @__PURE__ */ reactExports.createContext(createValue());
const useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
function shouldThrowError$1(_useErrorBoundary, params) {
  if (typeof _useErrorBoundary === "function") {
    return _useErrorBoundary(...params);
  }
  return !!_useErrorBoundary;
}
function useMutation$1(arg1, arg2, arg3) {
  const options = parseMutationArgs(arg1, arg2, arg3);
  const queryClient = useQueryClient({
    context: options.context
  });
  const [observer] = reactExports.useState(() => new MutationObserver$1(queryClient, options));
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = useSyncExternalStore(reactExports.useCallback((onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  const mutate = reactExports.useCallback((variables, mutateOptions) => {
    observer.mutate(variables, mutateOptions).catch(noop$3);
  }, [observer]);
  if (result.error && shouldThrowError$1(observer.options.useErrorBoundary, [result.error])) {
    throw result.error;
  }
  return {
    ...result,
    mutate,
    mutateAsync: result.mutate
  };
}
function noop$3() {
}
const cacheableEventTypes = ["added", "removed", "updated"];
function isCacheableEventType(eventType) {
  return cacheableEventTypes.includes(eventType);
}
async function persistQueryClientRestore({
  queryClient,
  persister,
  maxAge = 1e3 * 60 * 60 * 24,
  buster = "",
  hydrateOptions
}) {
  try {
    const persistedClient = await persister.restoreClient();
    if (persistedClient) {
      if (persistedClient.timestamp) {
        const expired = Date.now() - persistedClient.timestamp > maxAge;
        const busted = persistedClient.buster !== buster;
        if (expired || busted) {
          persister.removeClient();
        } else {
          hydrate(queryClient, persistedClient.clientState, hydrateOptions);
        }
      } else {
        persister.removeClient();
      }
    }
  } catch (err) {
    persister.removeClient();
  }
}
async function persistQueryClientSave({
  queryClient,
  persister,
  buster = "",
  dehydrateOptions
}) {
  const persistClient = {
    buster,
    timestamp: Date.now(),
    clientState: dehydrate(queryClient, dehydrateOptions)
  };
  await persister.persistClient(persistClient);
}
function persistQueryClientSubscribe(props) {
  const unsubscribeQueryCache = props.queryClient.getQueryCache().subscribe((event) => {
    if (isCacheableEventType(event.type)) {
      persistQueryClientSave(props);
    }
  });
  const unusbscribeMutationCache = props.queryClient.getMutationCache().subscribe((event) => {
    if (isCacheableEventType(event.type)) {
      persistQueryClientSave(props);
    }
  });
  return () => {
    unsubscribeQueryCache();
    unusbscribeMutationCache();
  };
}
function persistQueryClient(props) {
  let hasUnsubscribed = false;
  let persistQueryClientUnsubscribe;
  const unsubscribe = () => {
    hasUnsubscribed = true;
    persistQueryClientUnsubscribe == null ? void 0 : persistQueryClientUnsubscribe();
  };
  const restorePromise = persistQueryClientRestore(props).then(() => {
    if (!hasUnsubscribed) {
      persistQueryClientUnsubscribe = persistQueryClientSubscribe(props);
    }
  });
  return [unsubscribe, restorePromise];
}
function defineChain$3(chain2, config2 = {}) {
  const { fees = chain2.fees, formatters = chain2.formatters, serializers = chain2.serializers } = config2;
  return {
    ...chain2,
    fees,
    formatters,
    serializers
  };
}
const arbitrum = /* @__PURE__ */ defineChain$3({
  id: 42161,
  name: "Arbitrum One",
  network: "arbitrum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://arb-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://arbitrum-mainnet.infura.io/v3"],
      webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    },
    public: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    etherscan: { name: "Arbiscan", url: "https://arbiscan.io" },
    default: { name: "Arbiscan", url: "https://arbiscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});
const version$9 = "1.21.3";
const getContractAddress$2 = (address2) => address2;
const getUrl$1 = (url) => url;
const getVersion$1 = () => `viem@${version$9}`;
let BaseError$2 = class BaseError2 extends Error {
  constructor(shortMessage, args = {}) {
    super();
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ViemError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getVersion$1()
    });
    const details = args.cause instanceof BaseError2 ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
    const docsPath2 = args.cause instanceof BaseError2 ? args.cause.docsPath || args.docsPath : args.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath2 ? [
        `Docs: https://viem.sh${docsPath2}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
      ] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn) {
    return walk$1(this, fn);
  }
};
function walk$1(err, fn) {
  if (fn?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err)
    return walk$1(err.cause, fn);
  return fn ? null : err;
}
let IntegerOutOfRangeError$1 = class IntegerOutOfRangeError2 extends BaseError$2 {
  constructor({ max, min, signed, size: size2, value }) {
    super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntegerOutOfRangeError"
    });
  }
};
let InvalidHexBooleanError$1 = class InvalidHexBooleanError2 extends BaseError$2 {
  constructor(hex2) {
    super(`Hex value "${hex2}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidHexBooleanError"
    });
  }
};
let SizeOverflowError$1 = class SizeOverflowError2 extends BaseError$2 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SizeOverflowError"
    });
  }
};
function isHex$3(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
function size$5(value) {
  if (isHex$3(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
function trim$3(hexOrBytes, { dir = "left" } = {}) {
  let data2 = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i2 = 0; i2 < data2.length - 1; i2++) {
    if (data2[dir === "left" ? i2 : data2.length - i2 - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data2 = dir === "left" ? data2.slice(sliceLength) : data2.slice(0, data2.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data2.length === 1 && dir === "right")
      data2 = `${data2}0`;
    return `0x${data2.length % 2 === 1 ? `0${data2}` : data2}`;
  }
  return data2;
}
let SliceOffsetOutOfBoundsError$1 = class SliceOffsetOutOfBoundsError2 extends BaseError$2 {
  constructor({ offset, position, size: size2 }) {
    super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size2}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SliceOffsetOutOfBoundsError"
    });
  }
};
let SizeExceedsPaddingSizeError$1 = class SizeExceedsPaddingSizeError2 extends BaseError$2 {
  constructor({ size: size2, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SizeExceedsPaddingSizeError"
    });
  }
};
function pad$3(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex$1(hexOrBytes, { dir, size: size2 });
  return padBytes$1(hexOrBytes, { dir, size: size2 });
}
function padHex$1(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex2 = hex_.replace("0x", "");
  if (hex2.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError$1({
      size: Math.ceil(hex2.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex2[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes$1(bytes2, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes2;
  if (bytes2.length > size2)
    throw new SizeExceedsPaddingSizeError$1({
      size: bytes2.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i2 = 0; i2 < size2; i2++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i2 : size2 - i2 - 1] = bytes2[padEnd ? i2 : bytes2.length - i2 - 1];
  }
  return paddedBytes;
}
const hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i2) => i2.toString(16).padStart(2, "0"));
function toHex$1(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex$1(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex2 = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex2, { size: opts.size });
    return pad$3(hex2, { size: opts.size });
  }
  return hex2;
}
function bytesToHex$1(value, opts = {}) {
  let string2 = "";
  for (let i2 = 0; i2 < value.length; i2++) {
    string2 += hexes$1[value[i2]];
  }
  const hex2 = `0x${string2}`;
  if (typeof opts.size === "number") {
    assertSize(hex2, { size: opts.size });
    return pad$3(hex2, { dir: "right", size: opts.size });
  }
  return hex2;
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size2) {
    if (signed)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError$1({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex2 = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad$3(hex2, { size: size2 });
  return hex2;
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function stringToHex(value_, opts = {}) {
  const value = encoder$1.encode(value_);
  return bytesToHex$1(value, opts);
}
const encoder = /* @__PURE__ */ new TextEncoder();
function toBytes$4(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex$3(value))
    return hexToBytes$1(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes2 = new Uint8Array(1);
  bytes2[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad$3(bytes2, { size: opts.size });
  }
  return bytes2;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes$1(hex_, opts = {}) {
  let hex2 = hex_;
  if (opts.size) {
    assertSize(hex2, { size: opts.size });
    hex2 = pad$3(hex2, { dir: "right", size: opts.size });
  }
  let hexString = hex2.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length2 = hexString.length / 2;
  const bytes2 = new Uint8Array(length2);
  for (let index2 = 0, j2 = 0; index2 < length2; index2++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j2++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j2++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError$2(`Invalid byte sequence ("${hexString[j2 - 2]}${hexString[j2 - 1]}" in "${hexString}").`);
    }
    bytes2[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes2;
}
function numberToBytes(value, opts) {
  const hex2 = numberToHex(value, opts);
  return hexToBytes$1(hex2);
}
function stringToBytes(value, opts = {}) {
  const bytes2 = encoder.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad$3(bytes2, { dir: "right", size: opts.size });
  }
  return bytes2;
}
function assertSize(hexOrBytes, { size: size2 }) {
  if (size$5(hexOrBytes) > size2)
    throw new SizeOverflowError$1({
      givenSize: size$5(hexOrBytes),
      maxSize: size2
    });
}
function hexToBigInt(hex2, opts = {}) {
  const { signed } = opts;
  if (opts.size)
    assertSize(hex2, { size: opts.size });
  const value = BigInt(hex2);
  if (!signed)
    return value;
  const size2 = (hex2.length - 2) / 2;
  const max = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToBool(hex_, opts = {}) {
  let hex2 = hex_;
  if (opts.size) {
    assertSize(hex2, { size: opts.size });
    hex2 = trim$3(hex2);
  }
  if (trim$3(hex2) === "0x00")
    return false;
  if (trim$3(hex2) === "0x01")
    return true;
  throw new InvalidHexBooleanError$1(hex2);
}
function hexToNumber$1(hex2, opts = {}) {
  return Number(hexToBigInt(hex2, opts));
}
function hexToString(hex2, opts = {}) {
  let bytes2 = hexToBytes$1(hex2);
  if (opts.size) {
    assertSize(bytes2, { size: opts.size });
    bytes2 = trim$3(bytes2, { dir: "right" });
  }
  return new TextDecoder().decode(bytes2);
}
function defineFormatter$1(type, format) {
  return ({ exclude, format: overrides }) => {
    return {
      exclude,
      format: (args) => {
        const formatted = format(args);
        if (exclude) {
          for (const key of exclude) {
            delete formatted[key];
          }
        }
        return {
          ...formatted,
          ...overrides(args)
        };
      },
      type
    };
  };
}
const transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559"
};
function formatTransaction(transaction2) {
  const transaction_ = {
    ...transaction2,
    blockHash: transaction2.blockHash ? transaction2.blockHash : null,
    blockNumber: transaction2.blockNumber ? BigInt(transaction2.blockNumber) : null,
    chainId: transaction2.chainId ? hexToNumber$1(transaction2.chainId) : void 0,
    gas: transaction2.gas ? BigInt(transaction2.gas) : void 0,
    gasPrice: transaction2.gasPrice ? BigInt(transaction2.gasPrice) : void 0,
    maxFeePerGas: transaction2.maxFeePerGas ? BigInt(transaction2.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction2.maxPriorityFeePerGas ? BigInt(transaction2.maxPriorityFeePerGas) : void 0,
    nonce: transaction2.nonce ? hexToNumber$1(transaction2.nonce) : void 0,
    to: transaction2.to ? transaction2.to : null,
    transactionIndex: transaction2.transactionIndex ? Number(transaction2.transactionIndex) : null,
    type: transaction2.type ? transactionType[transaction2.type] : void 0,
    typeHex: transaction2.type ? transaction2.type : void 0,
    value: transaction2.value ? BigInt(transaction2.value) : void 0,
    v: transaction2.v ? BigInt(transaction2.v) : void 0
  };
  transaction_.yParity = (() => {
    if (transaction2.yParity)
      return Number(transaction2.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  return transaction_;
}
const defineTransaction = /* @__PURE__ */ defineFormatter$1("transaction", formatTransaction);
function formatBlock$1(block2) {
  const transactions2 = block2.transactions?.map((transaction2) => {
    if (typeof transaction2 === "string")
      return transaction2;
    return formatTransaction(transaction2);
  });
  return {
    ...block2,
    baseFeePerGas: block2.baseFeePerGas ? BigInt(block2.baseFeePerGas) : null,
    difficulty: block2.difficulty ? BigInt(block2.difficulty) : void 0,
    gasLimit: block2.gasLimit ? BigInt(block2.gasLimit) : void 0,
    gasUsed: block2.gasUsed ? BigInt(block2.gasUsed) : void 0,
    hash: block2.hash ? block2.hash : null,
    logsBloom: block2.logsBloom ? block2.logsBloom : null,
    nonce: block2.nonce ? block2.nonce : null,
    number: block2.number ? BigInt(block2.number) : null,
    size: block2.size ? BigInt(block2.size) : void 0,
    timestamp: block2.timestamp ? BigInt(block2.timestamp) : void 0,
    transactions: transactions2,
    totalDifficulty: block2.totalDifficulty ? BigInt(block2.totalDifficulty) : null
  };
}
const defineBlock$1 = /* @__PURE__ */ defineFormatter$1("block", formatBlock$1);
function formatLog$1(log3, { args, eventName } = {}) {
  return {
    ...log3,
    blockHash: log3.blockHash ? log3.blockHash : null,
    blockNumber: log3.blockNumber ? BigInt(log3.blockNumber) : null,
    logIndex: log3.logIndex ? Number(log3.logIndex) : null,
    transactionHash: log3.transactionHash ? log3.transactionHash : null,
    transactionIndex: log3.transactionIndex ? Number(log3.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}
const statuses$1 = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt$1(transactionReceipt2) {
  return {
    ...transactionReceipt2,
    blockNumber: transactionReceipt2.blockNumber ? BigInt(transactionReceipt2.blockNumber) : null,
    contractAddress: transactionReceipt2.contractAddress ? transactionReceipt2.contractAddress : null,
    cumulativeGasUsed: transactionReceipt2.cumulativeGasUsed ? BigInt(transactionReceipt2.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt2.effectiveGasPrice ? BigInt(transactionReceipt2.effectiveGasPrice) : null,
    gasUsed: transactionReceipt2.gasUsed ? BigInt(transactionReceipt2.gasUsed) : null,
    logs: transactionReceipt2.logs ? transactionReceipt2.logs.map((log3) => formatLog$1(log3)) : null,
    to: transactionReceipt2.to ? transactionReceipt2.to : null,
    transactionIndex: transactionReceipt2.transactionIndex ? hexToNumber$1(transactionReceipt2.transactionIndex) : null,
    status: transactionReceipt2.status ? statuses$1[transactionReceipt2.status] : null,
    type: transactionReceipt2.type ? transactionType[transactionReceipt2.type] || transactionReceipt2.type : null
  };
}
const defineTransactionReceipt$1 = /* @__PURE__ */ defineFormatter$1("transactionReceipt", formatTransactionReceipt$1);
const formattersOptimism = {
  block: /* @__PURE__ */ defineBlock$1({
    format(args) {
      const transactions2 = args.transactions?.map((transaction2) => {
        if (typeof transaction2 === "string")
          return transaction2;
        const formatted = formatTransaction(transaction2);
        if (formatted.typeHex === "0x7e") {
          formatted.isSystemTx = transaction2.isSystemTx;
          formatted.mint = transaction2.mint ? hexToBigInt(transaction2.mint) : void 0;
          formatted.sourceHash = transaction2.sourceHash;
          formatted.type = "deposit";
        }
        return formatted;
      });
      return {
        transactions: transactions2,
        stateRoot: args.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ defineTransaction({
    format(args) {
      const transaction2 = {};
      if (args.type === "0x7e") {
        transaction2.isSystemTx = args.isSystemTx;
        transaction2.mint = args.mint ? hexToBigInt(args.mint) : void 0;
        transaction2.sourceHash = args.sourceHash;
        transaction2.type = "deposit";
      }
      return transaction2;
    }
  }),
  transactionReceipt: /* @__PURE__ */ defineTransactionReceipt$1({
    format(args) {
      return {
        l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
        l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
        l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
      };
    }
  })
};
const rpcTransactionType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2"
};
function formatTransactionRequest(transactionRequest2) {
  return {
    ...transactionRequest2,
    gas: typeof transactionRequest2.gas !== "undefined" ? numberToHex(transactionRequest2.gas) : void 0,
    gasPrice: typeof transactionRequest2.gasPrice !== "undefined" ? numberToHex(transactionRequest2.gasPrice) : void 0,
    maxFeePerGas: typeof transactionRequest2.maxFeePerGas !== "undefined" ? numberToHex(transactionRequest2.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: typeof transactionRequest2.maxPriorityFeePerGas !== "undefined" ? numberToHex(transactionRequest2.maxPriorityFeePerGas) : void 0,
    nonce: typeof transactionRequest2.nonce !== "undefined" ? numberToHex(transactionRequest2.nonce) : void 0,
    type: typeof transactionRequest2.type !== "undefined" ? rpcTransactionType[transactionRequest2.type] : void 0,
    value: typeof transactionRequest2.value !== "undefined" ? numberToHex(transactionRequest2.value) : void 0
  };
}
let InvalidAddressError$1 = class InvalidAddressError2 extends BaseError$2 {
  constructor({ address: address2 }) {
    super(`Address "${address2}" is invalid.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAddressError"
    });
  }
};
let ChainDoesNotSupportContract$1 = class ChainDoesNotSupportContract2 extends BaseError$2 {
  constructor({ blockNumber, chain: chain2, contract: contract2 }) {
    super(`Chain "${chain2.name}" does not support contract "${contract2.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...blockNumber && contract2.blockCreated && contract2.blockCreated > blockNumber ? [
          `- The contract "${contract2.name}" was not deployed until block ${contract2.blockCreated} (current block ${blockNumber}).`
        ] : [
          `- The chain does not have the contract "${contract2.name}" configured.`
        ]
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainDoesNotSupportContract"
    });
  }
};
let ChainMismatchError$1 = class ChainMismatchError2 extends BaseError$2 {
  constructor({ chain: chain2, currentChainId }) {
    super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain2.id} – ${chain2.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${currentChainId}`,
        `Expected Chain ID: ${chain2.id} – ${chain2.name}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainMismatchError"
    });
  }
};
let ChainNotFoundError$1 = class ChainNotFoundError2 extends BaseError$2 {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainNotFoundError"
    });
  }
};
let ClientChainNotConfiguredError$1 = class ClientChainNotConfiguredError2 extends BaseError$2 {
  constructor() {
    super("No chain was provided to the Client.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ClientChainNotConfiguredError"
    });
  }
};
const etherUnits$1 = {
  gwei: 9,
  wei: 18
};
const gweiUnits$1 = {
  ether: -9,
  wei: 9
};
const weiUnits$1 = {
  ether: -18,
  gwei: -9
};
function formatUnits$3(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatGwei$3(wei, unit2 = "wei") {
  return formatUnits$3(wei, gweiUnits$1[unit2]);
}
let ExecutionRevertedError$1 = class ExecutionRevertedError2 extends BaseError$2 {
  constructor({ cause, message } = {}) {
    const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
    super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ExecutionRevertedError"
    });
  }
};
Object.defineProperty(ExecutionRevertedError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 3
});
Object.defineProperty(ExecutionRevertedError$1, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
let FeeCapTooHighError$1 = class FeeCapTooHighError2 extends BaseError$2 {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei$3(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeCapTooHigh"
    });
  }
};
Object.defineProperty(FeeCapTooHighError$1, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
let FeeCapTooLowError$1 = class FeeCapTooLowError2 extends BaseError$2 {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei$3(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeCapTooLow"
    });
  }
};
Object.defineProperty(FeeCapTooLowError$1, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
let NonceTooHighError$1 = class NonceTooHighError2 extends BaseError$2 {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceTooHighError"
    });
  }
};
Object.defineProperty(NonceTooHighError$1, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too high/
});
let NonceTooLowError$1 = class NonceTooLowError2 extends BaseError$2 {
  constructor({ cause, nonce } = {}) {
    super([
      `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join("\n"), { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceTooLowError"
    });
  }
};
Object.defineProperty(NonceTooLowError$1, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too low|transaction already imported|already known/
});
let NonceMaxValueError$1 = class NonceMaxValueError2 extends BaseError$2 {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceMaxValueError"
    });
  }
};
Object.defineProperty(NonceMaxValueError$1, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce has max value/
});
let InsufficientFundsError$1 = class InsufficientFundsError2 extends BaseError$2 {
  constructor({ cause } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join("\n"), {
      cause,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InsufficientFundsError"
    });
  }
};
Object.defineProperty(InsufficientFundsError$1, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /insufficient funds/
});
let IntrinsicGasTooHighError$1 = class IntrinsicGasTooHighError2 extends BaseError$2 {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntrinsicGasTooHighError"
    });
  }
};
Object.defineProperty(IntrinsicGasTooHighError$1, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too high|gas limit reached/
});
let IntrinsicGasTooLowError$1 = class IntrinsicGasTooLowError2 extends BaseError$2 {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntrinsicGasTooLowError"
    });
  }
};
Object.defineProperty(IntrinsicGasTooLowError$1, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too low/
});
let TransactionTypeNotSupportedError$1 = class TransactionTypeNotSupportedError2 extends BaseError$2 {
  constructor({ cause }) {
    super("The transaction type is not supported for this chain.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionTypeNotSupportedError"
    });
  }
};
Object.defineProperty(TransactionTypeNotSupportedError$1, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /transaction type not valid/
});
let TipAboveFeeCapError$1 = class TipAboveFeeCapError2 extends BaseError$2 {
  constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei$3(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei$3(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"), {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TipAboveFeeCapError"
    });
  }
};
Object.defineProperty(TipAboveFeeCapError$1, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
let UnknownNodeError$1 = class UnknownNodeError2 extends BaseError$2 {
  constructor({ cause }) {
    super(`An error occurred while executing: ${cause?.shortMessage}`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownNodeError"
    });
  }
};
const addressRegex$1 = /^0x[a-fA-F0-9]{40}$/;
function isAddress$3(address2) {
  return addressRegex$1.test(address2);
}
function concat$6(values) {
  if (typeof values[0] === "string")
    return concatHex$1(values);
  return concatBytes$3(values);
}
function concatBytes$3(values) {
  let length2 = 0;
  for (const arr of values) {
    length2 += arr.length;
  }
  const result = new Uint8Array(length2);
  let offset = 0;
  for (const arr of values) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function concatHex$1(values) {
  return `0x${values.reduce((acc, x2) => acc + x2.replace("0x", ""), "")}`;
}
function execTyped$1(regex2, string2) {
  const match = regex2.exec(string2);
  return match?.groups;
}
const tupleRegex$1 = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter$3(abiParameter2) {
  let type = abiParameter2.type;
  if (tupleRegex$1.test(abiParameter2.type) && "components" in abiParameter2) {
    type = "(";
    const length2 = abiParameter2.components.length;
    for (let i2 = 0; i2 < length2; i2++) {
      const component = abiParameter2.components[i2];
      type += formatAbiParameter$3(component);
      if (i2 < length2 - 1)
        type += ", ";
    }
    const result = execTyped$1(tupleRegex$1, abiParameter2.type);
    type += `)${result?.array ?? ""}`;
    return formatAbiParameter$3({
      ...abiParameter2,
      type
    });
  }
  if ("indexed" in abiParameter2 && abiParameter2.indexed)
    type = `${type} indexed`;
  if (abiParameter2.name)
    return `${type} ${abiParameter2.name}`;
  return type;
}
function formatAbiParameters$3(abiParameters) {
  let params = "";
  const length2 = abiParameters.length;
  for (let i2 = 0; i2 < length2; i2++) {
    const abiParameter2 = abiParameters[i2];
    params += formatAbiParameter$3(abiParameter2);
    if (i2 !== length2 - 1)
      params += ", ";
  }
  return params;
}
function formatAbiItem$5(abiItem2) {
  if (abiItem2.type === "function")
    return `function ${abiItem2.name}(${formatAbiParameters$3(abiItem2.inputs)})${abiItem2.stateMutability && abiItem2.stateMutability !== "nonpayable" ? ` ${abiItem2.stateMutability}` : ""}${abiItem2.outputs.length ? ` returns (${formatAbiParameters$3(abiItem2.outputs)})` : ""}`;
  else if (abiItem2.type === "event")
    return `event ${abiItem2.name}(${formatAbiParameters$3(abiItem2.inputs)})`;
  else if (abiItem2.type === "error")
    return `error ${abiItem2.name}(${formatAbiParameters$3(abiItem2.inputs)})`;
  else if (abiItem2.type === "constructor")
    return `constructor(${formatAbiParameters$3(abiItem2.inputs)})${abiItem2.stateMutability === "payable" ? " payable" : ""}`;
  else if (abiItem2.type === "fallback")
    return "fallback()";
  return "receive() external payable";
}
function getAction$3(client2, action, name2) {
  return (params) => client2[action.name || name2]?.(params) ?? action(client2, params);
}
function formatAbiItem$4(abiItem2, { includeName = false } = {}) {
  if (abiItem2.type !== "function" && abiItem2.type !== "event" && abiItem2.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem2.type);
  return `${abiItem2.name}(${formatAbiParams(abiItem2.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}
class AbiConstructorNotFoundError extends BaseError$2 {
  constructor({ docsPath: docsPath2 }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiConstructorNotFoundError"
    });
  }
}
class AbiConstructorParamsNotFoundError extends BaseError$2 {
  constructor({ docsPath: docsPath2 }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiConstructorParamsNotFoundError"
    });
  }
}
class AbiDecodingDataSizeTooSmallError extends BaseError$2 {
  constructor({ data: data2, params, size: size2 }) {
    super([`Data size of ${size2} bytes is too small for given parameters.`].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data2} (${size2} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiDecodingDataSizeTooSmallError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data2;
    this.params = params;
    this.size = size2;
  }
}
class AbiDecodingZeroDataError extends BaseError$2 {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.');
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiDecodingZeroDataError"
    });
  }
}
class AbiEncodingArrayLengthMismatchError extends BaseError$2 {
  constructor({ expectedLength, givenLength, type }) {
    super([
      `ABI encoding array length mismatch for type ${type}.`,
      `Expected length: ${expectedLength}`,
      `Given length: ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingArrayLengthMismatchError"
    });
  }
}
class AbiEncodingBytesSizeMismatchError extends BaseError$2 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size$5(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingBytesSizeMismatchError"
    });
  }
}
class AbiEncodingLengthMismatchError extends BaseError$2 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingLengthMismatchError"
    });
  }
}
class AbiErrorSignatureNotFoundError extends BaseError$2 {
  constructor(signature2, { docsPath: docsPath2 }) {
    super([
      `Encoded error signature "${signature2}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiErrorSignatureNotFoundError"
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.signature = signature2;
  }
}
class AbiEventSignatureEmptyTopicsError extends BaseError$2 {
  constructor({ docsPath: docsPath2 }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class AbiEventSignatureNotFoundError extends BaseError$2 {
  constructor(signature2, { docsPath: docsPath2 }) {
    super([
      `Encoded event signature "${signature2}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${signature2}.`
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventSignatureNotFoundError"
    });
  }
}
class AbiEventNotFoundError extends BaseError$2 {
  constructor(eventName, { docsPath: docsPath2 } = {}) {
    super([
      `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventNotFoundError"
    });
  }
}
class AbiFunctionNotFoundError extends BaseError$2 {
  constructor(functionName, { docsPath: docsPath2 } = {}) {
    super([
      `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiFunctionNotFoundError"
    });
  }
}
class AbiFunctionOutputsNotFoundError extends BaseError$2 {
  constructor(functionName, { docsPath: docsPath2 }) {
    super([
      `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class AbiItemAmbiguityError extends BaseError$2 {
  constructor(x2, y2) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${x2.type}\` in \`${formatAbiItem$4(x2.abiItem)}\`, and`,
        `\`${y2.type}\` in \`${formatAbiItem$4(y2.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItemAmbiguityError"
    });
  }
}
class BytesSizeMismatchError extends BaseError$2 {
  constructor({ expectedSize, givenSize }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BytesSizeMismatchError"
    });
  }
}
class DecodeLogDataMismatch extends BaseError$2 {
  constructor({ abiItem: abiItem2, data: data2, params, size: size2 }) {
    super([
      `Data size of ${size2} bytes is too small for non-indexed event parameters.`
    ].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data2} (${size2} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "DecodeLogDataMismatch"
    });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiItem = abiItem2;
    this.data = data2;
    this.params = params;
    this.size = size2;
  }
}
class DecodeLogTopicsMismatch extends BaseError$2 {
  constructor({ abiItem: abiItem2, param }) {
    super([
      `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem$4(abiItem2, { includeName: true })}".`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "DecodeLogTopicsMismatch"
    });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiItem = abiItem2;
  }
}
class InvalidAbiEncodingTypeError extends BaseError$2 {
  constructor(type, { docsPath: docsPath2 }) {
    super([
      `Type "${type}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath: docsPath2 });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiEncodingType"
    });
  }
}
class InvalidAbiDecodingTypeError extends BaseError$2 {
  constructor(type, { docsPath: docsPath2 }) {
    super([
      `Type "${type}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath: docsPath2 });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiDecodingType"
    });
  }
}
class InvalidArrayError extends BaseError$2 {
  constructor(value) {
    super([`Value "${value}" is not a valid array.`].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidArrayError"
    });
  }
}
class InvalidDefinitionTypeError extends BaseError$2 {
  constructor(type) {
    super([
      `"${type}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidDefinitionTypeError"
    });
  }
}
let FilterTypeNotSupportedError$1 = class FilterTypeNotSupportedError2 extends BaseError$2 {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FilterTypeNotSupportedError"
    });
  }
};
function normalizeSignature$3(signature2) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i2 = 0; i2 < signature2.length; i2++) {
    const char = signature2[i2];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature2[i2 - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError$2("Unable to normalize signature.");
  return result;
}
const getFunctionSignature$3 = (fn_) => {
  const fn = (() => {
    if (typeof fn_ === "string")
      return fn_;
    return formatAbiItem$5(fn_);
  })();
  return normalizeSignature$3(fn);
};
const getEventSignature$3 = (fn) => {
  return getFunctionSignature$3(fn);
};
function number$5(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes$4(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function exists$3(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$2(out, instance) {
  bytes$4(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const U32_MASK64$1 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n$1 = /* @__PURE__ */ BigInt(32);
function fromBig$1(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64$1), l: Number(n2 >> _32n$1 & U32_MASK64$1) };
  return { h: Number(n2 >> _32n$1 & U32_MASK64$1) | 0, l: Number(n2 & U32_MASK64$1) | 0 };
}
function split$1(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h: h2, l: l2 } = fromBig$1(lst[i2], le2);
    [Ah2[i2], Al[i2]] = [h2, l2];
  }
  return [Ah2, Al];
}
const rotlSH$1 = (h2, l2, s) => h2 << s | l2 >>> 32 - s;
const rotlSL$1 = (h2, l2, s) => l2 << s | h2 >>> 32 - s;
const rotlBH$1 = (h2, l2, s) => l2 << s - 32 | h2 >>> 64 - s;
const rotlBL$1 = (h2, l2, s) => h2 << s - 32 | l2 >>> 64 - s;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$2 = (a2) => a2 instanceof Uint8Array;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$1)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$3(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes$3(data2);
  if (!u8a$2(data2))
    throw new Error(`expected Uint8Array, got ${typeof data2}`);
  return data2;
}
let Hash$1 = class Hash2 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$1(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
const [SHA3_PI$1, SHA3_ROTL$1, _SHA3_IOTA$1] = [[], [], []];
const _0n$6 = /* @__PURE__ */ BigInt(0);
const _1n$6 = /* @__PURE__ */ BigInt(1);
const _2n$5 = /* @__PURE__ */ BigInt(2);
const _7n$1 = /* @__PURE__ */ BigInt(7);
const _256n$1 = /* @__PURE__ */ BigInt(256);
const _0x71n$1 = /* @__PURE__ */ BigInt(113);
for (let round = 0, R2 = _1n$6, x2 = 1, y2 = 0; round < 24; round++) {
  [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
  SHA3_PI$1.push(2 * (5 * y2 + x2));
  SHA3_ROTL$1.push((round + 1) * (round + 2) / 2 % 64);
  let t2 = _0n$6;
  for (let j2 = 0; j2 < 7; j2++) {
    R2 = (R2 << _1n$6 ^ (R2 >> _7n$1) * _0x71n$1) % _256n$1;
    if (R2 & _2n$5)
      t2 ^= _1n$6 << (_1n$6 << /* @__PURE__ */ BigInt(j2)) - _1n$6;
  }
  _SHA3_IOTA$1.push(t2);
}
const [SHA3_IOTA_H$1, SHA3_IOTA_L$1] = /* @__PURE__ */ split$1(_SHA3_IOTA$1, true);
const rotlH$1 = (h2, l2, s) => s > 32 ? rotlBH$1(h2, l2, s) : rotlSH$1(h2, l2, s);
const rotlL$1 = (h2, l2, s) => s > 32 ? rotlBL$1(h2, l2, s) : rotlSL$1(h2, l2, s);
function keccakP$1(s, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x2 = 0; x2 < 10; x2++)
      B2[x2] = s[x2] ^ s[x2 + 10] ^ s[x2 + 20] ^ s[x2 + 30] ^ s[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th2 = rotlH$1(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL$1(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s[x2 + y2] ^= Th2;
        s[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL$1[t2];
      const Th2 = rotlH$1(curH, curL, shift);
      const Tl = rotlL$1(curH, curL, shift);
      const PI = SHA3_PI$1[t2];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th2;
      s[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H$1[round];
    s[1] ^= SHA3_IOTA_L$1[round];
  }
  B2.fill(0);
}
let Keccak$1 = class Keccak2 extends Hash$1 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number$5(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP$1(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data2) {
    exists$3(this);
    const { blockLen, state } = this;
    data2 = toBytes$3(data2);
    const len2 = data2.length;
    for (let pos = 0; pos < len2; ) {
      const take2 = Math.min(blockLen - this.pos, len2 - pos);
      for (let i2 = 0; i2 < take2; i2++)
        state[this.pos++] ^= data2[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists$3(this, false);
    bytes$4(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len2 = out.length; pos < len2; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take2 = Math.min(blockLen - this.posOut, len2 - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take2), pos);
      this.posOut += take2;
      pos += take2;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number$5(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output$2(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
const gen$1 = (suffix, blockLen, outputLen) => wrapConstructor$1(() => new Keccak$1(blockLen, suffix, outputLen));
const keccak_256$1 = /* @__PURE__ */ gen$1(1, 136, 256 / 8);
function keccak256$3(value, to_) {
  const to = to_ || "hex";
  const bytes2 = keccak_256$1(isHex$3(value, { strict: false }) ? toBytes$4(value) : value);
  if (to === "bytes")
    return bytes2;
  return toHex$1(bytes2);
}
const hash$7 = (value) => keccak256$3(toBytes$4(value));
const getEventSelector$3 = (fn) => hash$7(getEventSignature$3(fn));
function slice$4(value, start, end2, { strict } = {}) {
  if (isHex$3(value, { strict: false }))
    return sliceHex$1(value, start, end2, {
      strict
    });
  return sliceBytes$1(value, start, end2, {
    strict
  });
}
function assertStartOffset$1(value, start) {
  if (typeof start === "number" && start > 0 && start > size$5(value) - 1)
    throw new SliceOffsetOutOfBoundsError$1({
      offset: start,
      position: "start",
      size: size$5(value)
    });
}
function assertEndOffset$1(value, start, end2) {
  if (typeof start === "number" && typeof end2 === "number" && size$5(value) !== end2 - start) {
    throw new SliceOffsetOutOfBoundsError$1({
      offset: end2,
      position: "end",
      size: size$5(value)
    });
  }
}
function sliceBytes$1(value_, start, end2, { strict } = {}) {
  assertStartOffset$1(value_, start);
  const value = value_.slice(start, end2);
  if (strict)
    assertEndOffset$1(value, start, end2);
  return value;
}
function sliceHex$1(value_, start, end2, { strict } = {}) {
  assertStartOffset$1(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end2 ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset$1(value, start, end2);
  return value;
}
function encodeAbiParameters$3(params, values) {
  if (params.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values.length
    });
  const preparedParams = prepareParams$1({
    params,
    values
  });
  const data2 = encodeParams$1(preparedParams);
  if (data2.length === 0)
    return "0x";
  return data2;
}
function prepareParams$1({ params, values }) {
  const preparedParams = [];
  for (let i2 = 0; i2 < params.length; i2++) {
    preparedParams.push(prepareParam$1({ param: params[i2], value: values[i2] }));
  }
  return preparedParams;
}
function prepareParam$1({ param, value }) {
  const arrayComponents = getArrayComponents$1(param.type);
  if (arrayComponents) {
    const [length2, type] = arrayComponents;
    return encodeArray$2(value, { length: length2, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple$1(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress$1(value);
  }
  if (param.type === "bool") {
    return encodeBool$1(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed = param.type.startsWith("int");
    return encodeNumber$1(value, { signed });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes$2(value, { param });
  }
  if (param.type === "string") {
    return encodeString$2(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams$1(preparedParams) {
  let staticSize = 0;
  for (let i2 = 0; i2 < preparedParams.length; i2++) {
    const { dynamic, encoded } = preparedParams[i2];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size$5(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i2 = 0; i2 < preparedParams.length; i2++) {
    const { dynamic, encoded } = preparedParams[i2];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += size$5(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat$6([...staticParams, ...dynamicParams]);
}
function encodeAddress$1(value) {
  if (!isAddress$3(value))
    throw new InvalidAddressError$1({ address: value });
  return { dynamic: false, encoded: padHex$1(value.toLowerCase()) };
}
function encodeArray$2(value, { length: length2, param }) {
  const dynamic = length2 === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length2)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length2,
      givenLength: value.length,
      type: `${param.type}[${length2}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i2 = 0; i2 < value.length; i2++) {
    const preparedParam = prepareParam$1({ param, value: value[i2] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data2 = encodeParams$1(preparedParams);
    if (dynamic) {
      const length3 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat$6([length3, data2]) : length3
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data2 };
  }
  return {
    dynamic: false,
    encoded: concat$6(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes$2(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = size$5(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex$1(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: concat$6([padHex$1(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== parseInt(paramSize))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: parseInt(paramSize),
      value
    });
  return { dynamic: false, encoded: padHex$1(value, { dir: "right" }) };
}
function encodeBool$1(value) {
  return { dynamic: false, encoded: padHex$1(boolToHex(value)) };
}
function encodeNumber$1(value, { signed }) {
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed
    })
  };
}
function encodeString$2(value) {
  const hexValue = stringToHex(value);
  const partsLength = Math.ceil(size$5(hexValue) / 32);
  const parts = [];
  for (let i2 = 0; i2 < partsLength; i2++) {
    parts.push(padHex$1(slice$4(hexValue, i2 * 32, (i2 + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat$6([
      padHex$1(numberToHex(size$5(hexValue), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple$1(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i2 = 0; i2 < param.components.length; i2++) {
    const param_ = param.components[i2];
    const index2 = Array.isArray(value) ? i2 : param_.name;
    const preparedParam = prepareParam$1({
      param: param_,
      value: value[index2]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams$1(preparedParams) : concat$6(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents$1(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
}
const hash$6 = (value) => keccak256$3(toBytes$4(value));
const getFunctionSelector$3 = (fn) => slice$4(hash$6(getFunctionSignature$3(fn)), 0, 4);
function getAbiItem$3({ abi: abi2, args = [], name: name2 }) {
  const isSelector = isHex$3(name2, { strict: false });
  const abiItems = abi2.filter((abiItem2) => {
    if (isSelector) {
      if (abiItem2.type === "function")
        return getFunctionSelector$3(abiItem2) === name2;
      if (abiItem2.type === "event")
        return getEventSelector$3(abiItem2) === name2;
      return false;
    }
    return "name" in abiItem2 && abiItem2.name === name2;
  });
  if (abiItems.length === 0)
    return void 0;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem = void 0;
  for (const abiItem2 of abiItems) {
    if (!("inputs" in abiItem2))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem2.inputs || abiItem2.inputs.length === 0)
        return abiItem2;
      continue;
    }
    if (!abiItem2.inputs)
      continue;
    if (abiItem2.inputs.length === 0)
      continue;
    if (abiItem2.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index2) => {
      const abiParameter2 = "inputs" in abiItem2 && abiItem2.inputs[index2];
      if (!abiParameter2)
        return false;
      return isArgOfType$1(arg, abiParameter2);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes$1(abiItem2.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AbiItemAmbiguityError({
            abiItem: abiItem2,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem2;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
function isArgOfType$1(arg, abiParameter2) {
  const argType = typeof arg;
  const abiParameterType = abiParameter2.type;
  switch (abiParameterType) {
    case "address":
      return isAddress$3(arg);
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter2)
        return Object.values(abiParameter2.components).every((component, index2) => {
          return isArgOfType$1(Object.values(arg)[index2], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x2) => isArgOfType$1(x2, {
          ...abiParameter2,
          // Pop off `[]` or `[M]` from end of type
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes$1(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes$1(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types2 = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types2.includes("address") && types2.includes("bytes20"))
        return true;
      if (types2.includes("address") && types2.includes("string"))
        return isAddress$3(args[parameterIndex]);
      if (types2.includes("address") && types2.includes("bytes"))
        return isAddress$3(args[parameterIndex]);
      return false;
    })();
    if (ambiguous)
      return types2;
  }
  return;
}
function encodeEventTopics$3({ abi: abi2, eventName, args }) {
  let abiItem2 = abi2[0];
  if (eventName) {
    abiItem2 = getAbiItem$3({
      abi: abi2,
      args,
      name: eventName
    });
    if (!abiItem2)
      throw new AbiEventNotFoundError(eventName, {
        docsPath: "/docs/contract/encodeEventTopics"
      });
  }
  if (abiItem2.type !== "event")
    throw new AbiEventNotFoundError(void 0, {
      docsPath: "/docs/contract/encodeEventTopics"
    });
  const definition = formatAbiItem$4(abiItem2);
  const signature2 = getEventSelector$3(definition);
  let topics = [];
  if (args && "inputs" in abiItem2) {
    const indexedInputs = abiItem2.inputs?.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x2) => args[x2.name]) ?? [] : [];
    if (args_.length > 0) {
      topics = indexedInputs?.map((param, i2) => Array.isArray(args_[i2]) ? args_[i2].map((_2, j2) => encodeArg$1({ param, value: args_[i2][j2] })) : args_[i2] ? encodeArg$1({ param, value: args_[i2] }) : null) ?? [];
    }
  }
  return [signature2, ...topics];
}
function encodeArg$1({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256$3(toBytes$4(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError$1(param.type);
  return encodeAbiParameters$3([param], [value]);
}
function createFilterRequestScope$3(client2, { method }) {
  const requestMap = {};
  if (client2.transport.type === "fallback")
    client2.transport.onResponse?.(({ method: method_, response: id2, status, transport: transport2 }) => {
      if (status === "success" && method === method_)
        requestMap[id2] = transport2.request;
    });
  return (id2) => requestMap[id2] || client2.request;
}
async function createContractEventFilter$3(client2, { address: address2, abi: abi2, args, eventName, fromBlock, strict, toBlock }) {
  const getRequest = createFilterRequestScope$3(client2, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics$3({
    abi: abi2,
    args,
    eventName
  }) : void 0;
  const id2 = await client2.request({
    method: "eth_newFilter",
    params: [
      {
        address: address2,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi: abi2,
    args,
    eventName,
    id: id2,
    request: getRequest(id2),
    strict,
    type: "event"
  };
}
function parseAccount$3(account2) {
  if (typeof account2 === "string")
    return { address: account2, type: "json-rpc" };
  return account2;
}
function encodeFunctionData$3({ abi: abi2, args, functionName }) {
  let abiItem2 = abi2[0];
  if (functionName) {
    abiItem2 = getAbiItem$3({
      abi: abi2,
      args,
      name: functionName
    });
    if (!abiItem2)
      throw new AbiFunctionNotFoundError(functionName, {
        docsPath: "/docs/contract/encodeFunctionData"
      });
  }
  if (abiItem2.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, {
      docsPath: "/docs/contract/encodeFunctionData"
    });
  const definition = formatAbiItem$4(abiItem2);
  const signature2 = getFunctionSelector$3(definition);
  const data2 = "inputs" in abiItem2 && abiItem2.inputs ? encodeAbiParameters$3(abiItem2.inputs, args ?? []) : void 0;
  return concatHex$1([signature2, data2 ?? "0x"]);
}
const panicReasons$1 = {
  1: "An `assert` condition failed.",
  17: "Arithmic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
};
const solidityError$1 = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
};
const solidityPanic$1 = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function checksumAddress$1(address_, chainId) {
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash2 = keccak256$3(stringToBytes(hexAddress), "bytes");
  const address2 = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hash2[i2 >> 1] >> 4 >= 8 && address2[i2]) {
      address2[i2] = address2[i2].toUpperCase();
    }
    if ((hash2[i2 >> 1] & 15) >= 8 && address2[i2 + 1]) {
      address2[i2 + 1] = address2[i2 + 1].toUpperCase();
    }
  }
  return `0x${address2.join("")}`;
}
function getAddress$3(address2, chainId) {
  if (!isAddress$3(address2))
    throw new InvalidAddressError$1({ address: address2 });
  return checksumAddress$1(address2, chainId);
}
function decodeAbiParameters$3(params, data2) {
  if (data2 === "0x" && params.length > 0)
    throw new AbiDecodingZeroDataError();
  if (size$5(data2) && size$5(data2) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: data2,
      params,
      size: size$5(data2)
    });
  return decodeParams$1({
    data: data2,
    params
  });
}
function decodeParams$1({ data: data2, params }) {
  const decodedValues = [];
  let position = 0;
  for (let i2 = 0; i2 < params.length; i2++) {
    if (position >= size$5(data2))
      throw new AbiDecodingDataSizeTooSmallError({
        data: data2,
        params,
        size: size$5(data2)
      });
    const param = params[i2];
    const { consumed, value } = decodeParam$1({ data: data2, param, position });
    decodedValues.push(value);
    position += consumed;
  }
  return decodedValues;
}
function decodeParam$1({ data: data2, param, position }) {
  const arrayComponents = getArrayComponents$1(param.type);
  if (arrayComponents) {
    const [length2, type] = arrayComponents;
    return decodeArray$1(data2, {
      length: length2,
      param: { ...param, type },
      position
    });
  }
  if (param.type === "tuple") {
    return decodeTuple$1(data2, { param, position });
  }
  if (param.type === "string") {
    return decodeString$1(data2, { position });
  }
  if (param.type.startsWith("bytes")) {
    return decodeBytes$2(data2, { param, position });
  }
  const value = slice$4(data2, position, position + 32, { strict: true });
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return decodeNumber$1(value, { param });
  }
  if (param.type === "address") {
    return decodeAddress$1(value);
  }
  if (param.type === "bool") {
    return decodeBool$1(value);
  }
  throw new InvalidAbiDecodingTypeError(param.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
function decodeAddress$1(value) {
  return { consumed: 32, value: checksumAddress$1(slice$4(value, -20)) };
}
function decodeArray$1(data2, { param, length: length2, position }) {
  if (!length2) {
    const offset = hexToNumber$1(slice$4(data2, position, position + 32, { strict: true }));
    const length3 = hexToNumber$1(slice$4(data2, offset, offset + 32, { strict: true }));
    let consumed2 = 0;
    const value2 = [];
    for (let i2 = 0; i2 < length3; ++i2) {
      const decodedChild = decodeParam$1({
        data: slice$4(data2, offset + 32),
        param,
        position: consumed2
      });
      consumed2 += decodedChild.consumed;
      value2.push(decodedChild.value);
    }
    return { value: value2, consumed: 32 };
  }
  if (hasDynamicChild$1(param)) {
    const arrayComponents = getArrayComponents$1(param.type);
    const dynamicChild = !arrayComponents?.[0];
    let consumed2 = 0;
    const value2 = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      const offset = hexToNumber$1(slice$4(data2, position, position + 32, { strict: true }));
      const decodedChild = decodeParam$1({
        data: slice$4(data2, offset),
        param,
        position: dynamicChild ? consumed2 : i2 * 32
      });
      consumed2 += decodedChild.consumed;
      value2.push(decodedChild.value);
    }
    return { value: value2, consumed: 32 };
  }
  let consumed = 0;
  const value = [];
  for (let i2 = 0; i2 < length2; ++i2) {
    const decodedChild = decodeParam$1({
      data: data2,
      param,
      position: position + consumed
    });
    consumed += decodedChild.consumed;
    value.push(decodedChild.value);
  }
  return { value, consumed };
}
function decodeBool$1(value) {
  return { consumed: 32, value: hexToBool(value) };
}
function decodeBytes$2(data2, { param, position }) {
  const [_2, size2] = param.type.split("bytes");
  if (!size2) {
    const offset = hexToNumber$1(slice$4(data2, position, position + 32, { strict: true }));
    const length2 = hexToNumber$1(slice$4(data2, offset, offset + 32, { strict: true }));
    if (length2 === 0)
      return { consumed: 32, value: "0x" };
    const value2 = slice$4(data2, offset + 32, offset + 32 + length2, {
      strict: true
    });
    return { consumed: 32, value: value2 };
  }
  const value = slice$4(data2, position, position + parseInt(size2), {
    strict: true
  });
  return { consumed: 32, value };
}
function decodeNumber$1(value, { param }) {
  const signed = param.type.startsWith("int");
  const size2 = parseInt(param.type.split("int")[1] || "256");
  return {
    consumed: 32,
    value: size2 > 48 ? hexToBigInt(value, { signed }) : hexToNumber$1(value, { signed })
  };
}
function decodeString$1(data2, { position }) {
  const offset = hexToNumber$1(slice$4(data2, position, position + 32, { strict: true }));
  const length2 = hexToNumber$1(slice$4(data2, offset, offset + 32, { strict: true }));
  if (length2 === 0)
    return { consumed: 32, value: "" };
  const value = hexToString(trim$3(slice$4(data2, offset + 32, offset + 32 + length2, { strict: true })));
  return { consumed: 32, value };
}
function decodeTuple$1(data2, { param, position }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name: name2 }) => !name2);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild$1(param)) {
    const offset = hexToNumber$1(slice$4(data2, position, position + 32, { strict: true }));
    for (let i2 = 0; i2 < param.components.length; ++i2) {
      const component = param.components[i2];
      const decodedChild = decodeParam$1({
        data: slice$4(data2, offset),
        param: component,
        position: consumed
      });
      consumed += decodedChild.consumed;
      value[hasUnnamedChild ? i2 : component?.name] = decodedChild.value;
    }
    return { consumed: 32, value };
  }
  for (let i2 = 0; i2 < param.components.length; ++i2) {
    const component = param.components[i2];
    const decodedChild = decodeParam$1({
      data: data2,
      param: component,
      position: position + consumed
    });
    consumed += decodedChild.consumed;
    value[hasUnnamedChild ? i2 : component?.name] = decodedChild.value;
  }
  return { consumed, value };
}
function hasDynamicChild$1(param) {
  const { type } = param;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return param.components?.some(hasDynamicChild$1);
  const arrayComponents = getArrayComponents$1(param.type);
  if (arrayComponents && hasDynamicChild$1({ ...param, type: arrayComponents[1] }))
    return true;
  return false;
}
function decodeErrorResult$3({ abi: abi2, data: data2 }) {
  const signature2 = slice$4(data2, 0, 4);
  if (signature2 === "0x")
    throw new AbiDecodingZeroDataError();
  const abi_ = [...abi2 || [], solidityError$1, solidityPanic$1];
  const abiItem2 = abi_.find((x2) => x2.type === "error" && signature2 === getFunctionSelector$3(formatAbiItem$4(x2)));
  if (!abiItem2)
    throw new AbiErrorSignatureNotFoundError(signature2, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: abiItem2,
    args: "inputs" in abiItem2 && abiItem2.inputs && abiItem2.inputs.length > 0 ? decodeAbiParameters$3(abiItem2.inputs, slice$4(data2, 4)) : void 0,
    errorName: abiItem2.name
  };
}
const stringify$3 = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return typeof replacer === "function" ? replacer(key, value2) : value2;
}, space);
function formatAbiItemWithArgs$3({ abiItem: abiItem2, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem2))
    return;
  if (!("inputs" in abiItem2))
    return;
  if (!abiItem2.inputs)
    return;
  return `${includeFunctionName ? abiItem2.name : ""}(${abiItem2.inputs.map((input, i2) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i2] === "object" ? stringify$3(args[i2]) : args[i2]}`).join(", ")})`;
}
function formatEther$3(wei, unit2 = "wei") {
  return formatUnits$3(wei, etherUnits$1[unit2]);
}
function prettyPrint$1(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === void 0 || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
let FeeConflictError$1 = class FeeConflictError2 extends BaseError$2 {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeConflictError"
    });
  }
};
let InvalidSerializableTransactionError$1 = class InvalidSerializableTransactionError2 extends BaseError$2 {
  constructor({ transaction: transaction2 }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint$1(transaction2),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidSerializableTransactionError"
    });
  }
};
let TransactionExecutionError$1 = class TransactionExecutionError2 extends BaseError$2 {
  constructor(cause, { account: account2, docsPath: docsPath2, chain: chain2, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint$1({
      chain: chain2 && `${chain2?.name} (id: ${chain2?.id})`,
      from: account2?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther$3(value)} ${chain2?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei$3(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei$3(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei$3(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Request Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionExecutionError"
    });
    this.cause = cause;
  }
};
let TransactionNotFoundError$1 = class TransactionNotFoundError2 extends BaseError$2 {
  constructor({ blockHash, blockNumber, blockTag, hash: hash2, index: index2 }) {
    let identifier = "Transaction";
    if (blockTag && index2 !== void 0)
      identifier = `Transaction at block time "${blockTag}" at index "${index2}"`;
    if (blockHash && index2 !== void 0)
      identifier = `Transaction at block hash "${blockHash}" at index "${index2}"`;
    if (blockNumber && index2 !== void 0)
      identifier = `Transaction at block number "${blockNumber}" at index "${index2}"`;
    if (hash2)
      identifier = `Transaction with hash "${hash2}"`;
    super(`${identifier} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionNotFoundError"
    });
  }
};
let TransactionReceiptNotFoundError$1 = class TransactionReceiptNotFoundError2 extends BaseError$2 {
  constructor({ hash: hash2 }) {
    super(`Transaction receipt with hash "${hash2}" could not be found. The Transaction may not be processed on a block yet.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionReceiptNotFoundError"
    });
  }
};
let WaitForTransactionReceiptTimeoutError$1 = class WaitForTransactionReceiptTimeoutError2 extends BaseError$2 {
  constructor({ hash: hash2 }) {
    super(`Timed out while waiting for transaction with hash "${hash2}" to be confirmed.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WaitForTransactionReceiptTimeoutError"
    });
  }
};
let CallExecutionError$1 = class CallExecutionError2 extends BaseError$2 {
  constructor(cause, { account: account_, docsPath: docsPath2, chain: chain2, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const account2 = account_ ? parseAccount$3(account_) : void 0;
    const prettyArgs = prettyPrint$1({
      from: account2?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther$3(value)} ${chain2?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei$3(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei$3(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei$3(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Raw Call Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "CallExecutionError"
    });
    this.cause = cause;
  }
};
let ContractFunctionExecutionError$1 = class ContractFunctionExecutionError2 extends BaseError$2 {
  constructor(cause, { abi: abi2, args, contractAddress, docsPath: docsPath2, functionName, sender }) {
    const abiItem2 = getAbiItem$3({ abi: abi2, args, name: functionName });
    const formattedArgs = abiItem2 ? formatAbiItemWithArgs$3({
      abiItem: abiItem2,
      args,
      includeFunctionName: false,
      includeName: false
    }) : void 0;
    const functionWithParams = abiItem2 ? formatAbiItem$4(abiItem2, { includeName: true }) : void 0;
    const prettyArgs = prettyPrint$1({
      address: contractAddress && getContractAddress$2(contractAddress),
      function: functionWithParams,
      args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
      sender
    });
    super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Contract Call:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "abi", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "args", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "contractAddress", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "formattedArgs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "functionName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "sender", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionExecutionError"
    });
    this.abi = abi2;
    this.args = args;
    this.cause = cause;
    this.contractAddress = contractAddress;
    this.functionName = functionName;
    this.sender = sender;
  }
};
let ContractFunctionRevertedError$1 = class ContractFunctionRevertedError2 extends BaseError$2 {
  constructor({ abi: abi2, data: data2, functionName, message }) {
    let cause;
    let decodedData2 = void 0;
    let metaMessages;
    let reason;
    if (data2 && data2 !== "0x") {
      try {
        decodedData2 = decodeErrorResult$3({ abi: abi2, data: data2 });
        const { abiItem: abiItem2, errorName, args: errorArgs } = decodedData2;
        if (errorName === "Error") {
          reason = errorArgs[0];
        } else if (errorName === "Panic") {
          const [firstArg] = errorArgs;
          reason = panicReasons$1[firstArg];
        } else {
          const errorWithParams = abiItem2 ? formatAbiItem$4(abiItem2, { includeName: true }) : void 0;
          const formattedArgs = abiItem2 && errorArgs ? formatAbiItemWithArgs$3({
            abiItem: abiItem2,
            args: errorArgs,
            includeFunctionName: false,
            includeName: false
          }) : void 0;
          metaMessages = [
            errorWithParams ? `Error: ${errorWithParams}` : "",
            formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
          ];
        }
      } catch (err) {
        cause = err;
      }
    } else if (message)
      reason = message;
    let signature2;
    if (cause instanceof AbiErrorSignatureNotFoundError) {
      signature2 = cause.signature;
      metaMessages = [
        `Unable to decode signature "${signature2}" as it was not found on the provided ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
      ];
    }
    super(reason && reason !== "execution reverted" || signature2 ? [
      `The contract function "${functionName}" reverted with the following ${signature2 ? "signature" : "reason"}:`,
      reason || signature2
    ].join("\n") : `The contract function "${functionName}" reverted.`, {
      cause,
      metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionRevertedError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "reason", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = decodedData2;
    this.reason = reason;
    this.signature = signature2;
  }
};
let ContractFunctionZeroDataError$1 = class ContractFunctionZeroDataError2 extends BaseError$2 {
  constructor({ functionName }) {
    super(`The contract function "${functionName}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${functionName}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionZeroDataError"
    });
  }
};
let RawContractError$1 = class RawContractError2 extends BaseError$2 {
  constructor({ data: data2, message }) {
    super(message || "");
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RawContractError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data2;
  }
};
let HttpRequestError$1 = class HttpRequestError2 extends BaseError$2 {
  constructor({ body, details, headers, status, url }) {
    super("HTTP request failed.", {
      details,
      metaMessages: [
        status && `Status: ${status}`,
        `URL: ${getUrl$1(url)}`,
        body && `Request body: ${stringify$3(body)}`
      ].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "HttpRequestError"
    });
    Object.defineProperty(this, "body", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "url", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.body = body;
    this.headers = headers;
    this.status = status;
    this.url = url;
  }
};
let WebSocketRequestError$1 = class WebSocketRequestError2 extends BaseError$2 {
  constructor({ body, details, url }) {
    super("WebSocket request failed.", {
      details,
      metaMessages: [`URL: ${getUrl$1(url)}`, `Request body: ${stringify$3(body)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebSocketRequestError"
    });
  }
};
let RpcRequestError$1 = class RpcRequestError2 extends BaseError$2 {
  constructor({ body, error, url }) {
    super("RPC Request failed.", {
      cause: error,
      details: error.message,
      metaMessages: [`URL: ${getUrl$1(url)}`, `Request body: ${stringify$3(body)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcRequestError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = error.code;
  }
};
let TimeoutError$1 = class TimeoutError2 extends BaseError$2 {
  constructor({ body, url }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl$1(url)}`, `Request body: ${stringify$3(body)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TimeoutError"
    });
  }
};
const unknownErrorCode$1 = -1;
let RpcError$1 = class RpcError2 extends BaseError$2 {
  constructor(cause, { code: code2, docsPath: docsPath2, metaMessages, shortMessage }) {
    super(shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: metaMessages || cause?.metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = cause.name;
    this.code = cause instanceof RpcRequestError$1 ? cause.code : code2 ?? unknownErrorCode$1;
  }
};
let ProviderRpcError$1 = class ProviderRpcError2 extends RpcError$1 {
  constructor(cause, options) {
    super(cause, options);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderRpcError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = options.data;
  }
};
let ParseRpcError$1 = class ParseRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: ParseRpcError2.code,
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ParseRpcError"
    });
  }
};
Object.defineProperty(ParseRpcError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});
let InvalidRequestRpcError$1 = class InvalidRequestRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: InvalidRequestRpcError2.code,
      shortMessage: "JSON is not a valid request object."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidRequestRpcError"
    });
  }
};
Object.defineProperty(InvalidRequestRpcError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
let MethodNotFoundRpcError$1 = class MethodNotFoundRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: MethodNotFoundRpcError2.code,
      shortMessage: "The method does not exist / is not available."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MethodNotFoundRpcError"
    });
  }
};
Object.defineProperty(MethodNotFoundRpcError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
let InvalidParamsRpcError$1 = class InvalidParamsRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: InvalidParamsRpcError2.code,
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParamsRpcError"
    });
  }
};
Object.defineProperty(InvalidParamsRpcError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
let InternalRpcError$1 = class InternalRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: InternalRpcError2.code,
      shortMessage: "An internal error was received."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InternalRpcError"
    });
  }
};
Object.defineProperty(InternalRpcError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
let InvalidInputRpcError$1 = class InvalidInputRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: InvalidInputRpcError2.code,
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidInputRpcError"
    });
  }
};
Object.defineProperty(InvalidInputRpcError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
let ResourceNotFoundRpcError$1 = class ResourceNotFoundRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: ResourceNotFoundRpcError2.code,
      shortMessage: "Requested resource not found."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceNotFoundRpcError"
    });
  }
};
Object.defineProperty(ResourceNotFoundRpcError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
let ResourceUnavailableRpcError$1 = class ResourceUnavailableRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: ResourceUnavailableRpcError2.code,
      shortMessage: "Requested resource not available."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceUnavailableRpcError"
    });
  }
};
Object.defineProperty(ResourceUnavailableRpcError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
let TransactionRejectedRpcError$1 = class TransactionRejectedRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: TransactionRejectedRpcError2.code,
      shortMessage: "Transaction creation failed."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionRejectedRpcError"
    });
  }
};
Object.defineProperty(TransactionRejectedRpcError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
let MethodNotSupportedRpcError$1 = class MethodNotSupportedRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: MethodNotSupportedRpcError2.code,
      shortMessage: "Method is not implemented."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MethodNotSupportedRpcError"
    });
  }
};
Object.defineProperty(MethodNotSupportedRpcError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
let LimitExceededRpcError$1 = class LimitExceededRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: LimitExceededRpcError2.code,
      shortMessage: "Request exceeds defined limit."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "LimitExceededRpcError"
    });
  }
};
Object.defineProperty(LimitExceededRpcError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
let JsonRpcVersionUnsupportedError$1 = class JsonRpcVersionUnsupportedError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      code: JsonRpcVersionUnsupportedError2.code,
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "JsonRpcVersionUnsupportedError"
    });
  }
};
Object.defineProperty(JsonRpcVersionUnsupportedError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
let UserRejectedRequestError$1 = class UserRejectedRequestError2 extends ProviderRpcError$1 {
  constructor(cause) {
    super(cause, {
      code: UserRejectedRequestError2.code,
      shortMessage: "User rejected the request."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UserRejectedRequestError"
    });
  }
};
Object.defineProperty(UserRejectedRequestError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
let UnauthorizedProviderError$1 = class UnauthorizedProviderError2 extends ProviderRpcError$1 {
  constructor(cause) {
    super(cause, {
      code: UnauthorizedProviderError2.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnauthorizedProviderError"
    });
  }
};
Object.defineProperty(UnauthorizedProviderError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
let UnsupportedProviderMethodError$1 = class UnsupportedProviderMethodError2 extends ProviderRpcError$1 {
  constructor(cause) {
    super(cause, {
      code: UnsupportedProviderMethodError2.code,
      shortMessage: "The Provider does not support the requested method."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnsupportedProviderMethodError"
    });
  }
};
Object.defineProperty(UnsupportedProviderMethodError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
let ProviderDisconnectedError$1 = class ProviderDisconnectedError2 extends ProviderRpcError$1 {
  constructor(cause) {
    super(cause, {
      code: ProviderDisconnectedError2.code,
      shortMessage: "The Provider is disconnected from all chains."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderDisconnectedError"
    });
  }
};
Object.defineProperty(ProviderDisconnectedError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
let ChainDisconnectedError$1 = class ChainDisconnectedError2 extends ProviderRpcError$1 {
  constructor(cause) {
    super(cause, {
      code: ChainDisconnectedError2.code,
      shortMessage: "The Provider is not connected to the requested chain."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainDisconnectedError"
    });
  }
};
Object.defineProperty(ChainDisconnectedError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
let SwitchChainError$1 = class SwitchChainError2 extends ProviderRpcError$1 {
  constructor(cause) {
    super(cause, {
      code: SwitchChainError2.code,
      shortMessage: "An error occurred when attempting to switch chain."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SwitchChainError"
    });
  }
};
Object.defineProperty(SwitchChainError$1, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
let UnknownRpcError$1 = class UnknownRpcError2 extends RpcError$1 {
  constructor(cause) {
    super(cause, {
      shortMessage: "An unknown RPC error occurred."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownRpcError"
    });
  }
};
const EXECUTION_REVERTED_ERROR_CODE$1 = 3;
function getContractError$3(err, { abi: abi2, address: address2, args, docsPath: docsPath2, functionName, sender }) {
  const { code: code2, data: data2, message, shortMessage } = err instanceof RawContractError$1 ? err : err instanceof BaseError$2 ? err.walk((err2) => "data" in err2) || err.walk() : {};
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError$1({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE$1, InternalRpcError$1.code].includes(code2) && (data2 || message || shortMessage)) {
      return new ContractFunctionRevertedError$1({
        abi: abi2,
        data: typeof data2 === "object" ? data2.data : data2,
        functionName,
        message: shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError$1(cause, {
    abi: abi2,
    args,
    contractAddress: address2,
    docsPath: docsPath2,
    functionName,
    sender
  });
}
let AccountNotFoundError$1 = class AccountNotFoundError2 extends BaseError$2 {
  constructor({ docsPath: docsPath2 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
    ].join("\n"), {
      docsPath: docsPath2,
      docsSlug: "account"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccountNotFoundError"
    });
  }
};
let EstimateGasExecutionError$1 = class EstimateGasExecutionError2 extends BaseError$2 {
  constructor(cause, { account: account2, docsPath: docsPath2, chain: chain2, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint$1({
      from: account2?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther$3(value)} ${chain2?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei$3(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei$3(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei$3(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EstimateGasExecutionError"
    });
    this.cause = cause;
  }
};
function getNodeError$3(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err.walk((e2) => e2.code === ExecutionRevertedError$1.code);
  if (executionRevertedError instanceof BaseError$2) {
    return new ExecutionRevertedError$1({
      cause: err,
      message: executionRevertedError.details
    });
  }
  if (ExecutionRevertedError$1.nodeMessage.test(message))
    return new ExecutionRevertedError$1({
      cause: err,
      message: err.details
    });
  if (FeeCapTooHighError$1.nodeMessage.test(message))
    return new FeeCapTooHighError$1({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (FeeCapTooLowError$1.nodeMessage.test(message))
    return new FeeCapTooLowError$1({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (NonceTooHighError$1.nodeMessage.test(message))
    return new NonceTooHighError$1({ cause: err, nonce: args?.nonce });
  if (NonceTooLowError$1.nodeMessage.test(message))
    return new NonceTooLowError$1({ cause: err, nonce: args?.nonce });
  if (NonceMaxValueError$1.nodeMessage.test(message))
    return new NonceMaxValueError$1({ cause: err, nonce: args?.nonce });
  if (InsufficientFundsError$1.nodeMessage.test(message))
    return new InsufficientFundsError$1({ cause: err });
  if (IntrinsicGasTooHighError$1.nodeMessage.test(message))
    return new IntrinsicGasTooHighError$1({ cause: err, gas: args?.gas });
  if (IntrinsicGasTooLowError$1.nodeMessage.test(message))
    return new IntrinsicGasTooLowError$1({ cause: err, gas: args?.gas });
  if (TransactionTypeNotSupportedError$1.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError$1({ cause: err });
  if (TipAboveFeeCapError$1.nodeMessage.test(message))
    return new TipAboveFeeCapError$1({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
      maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
  return new UnknownNodeError$1({
    cause: err
  });
}
function getEstimateGasError$3(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError$3(err, args);
    if (cause2 instanceof UnknownNodeError$1)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError$1(cause, {
    docsPath: docsPath2,
    ...args
  });
}
function extract$3(value_, { format }) {
  if (!format)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys2 = Object.keys(formatted2);
    for (const key of keys2) {
      if (key in value_)
        value[key] = value_[key];
      if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
        extract_(formatted2[key]);
    }
  }
  const formatted = format(value_ || {});
  extract_(formatted);
  return value;
}
function assertRequest$3(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  const account2 = account_ ? parseAccount$3(account_) : void 0;
  if (account2 && !isAddress$3(account2.address))
    throw new InvalidAddressError$1({ address: account2.address });
  if (to && !isAddress$3(to))
    throw new InvalidAddressError$1({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError$1();
  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
    throw new FeeCapTooHighError$1({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError$1({ maxFeePerGas, maxPriorityFeePerGas });
}
let BaseFeeScalarError$1 = class BaseFeeScalarError2 extends BaseError$2 {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseFeeScalarError"
    });
  }
};
let Eip1559FeesNotSupportedError$1 = class Eip1559FeesNotSupportedError2 extends BaseError$2 {
  constructor() {
    super("Chain does not support EIP-1559 fees.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Eip1559FeesNotSupportedError"
    });
  }
};
let MaxFeePerGasTooLowError$1 = class MaxFeePerGasTooLowError2 extends BaseError$2 {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei$3(maxPriorityFeePerGas)} gwei).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MaxFeePerGasTooLowError"
    });
  }
};
let BlockNotFoundError$1 = class BlockNotFoundError2 extends BaseError$2 {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BlockNotFoundError"
    });
  }
};
async function getBlock$3(client2, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block2 = null;
  if (blockHash) {
    block2 = await client2.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    });
  } else {
    block2 = await client2.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    });
  }
  if (!block2)
    throw new BlockNotFoundError$1({ blockHash, blockNumber });
  const format = client2.chain?.formatters?.block?.format || formatBlock$1;
  return format(block2);
}
async function getGasPrice$3(client2) {
  const gasPrice = await client2.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}
async function estimateMaxPriorityFeePerGas$3(client2, args) {
  return internal_estimateMaxPriorityFeePerGas$1(client2, args);
}
async function internal_estimateMaxPriorityFeePerGas$1(client2, args) {
  const { block: block_, chain: chain2 = client2.chain, request: request2 } = args || {};
  if (typeof chain2?.fees?.defaultPriorityFee === "function") {
    const block2 = block_ || await getAction$3(client2, getBlock$3, "getBlock")({});
    return chain2.fees.defaultPriorityFee({
      block: block2,
      client: client2,
      request: request2
    });
  }
  if (typeof chain2?.fees?.defaultPriorityFee !== "undefined")
    return chain2?.fees?.defaultPriorityFee;
  try {
    const maxPriorityFeePerGasHex = await client2.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block2, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction$3(client2, getBlock$3, "getBlock")({}),
      getAction$3(client2, getGasPrice$3, "getGasPrice")({})
    ]);
    if (typeof block2.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError$1();
    const maxPriorityFeePerGas = gasPrice - block2.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}
async function estimateFeesPerGas$3(client2, args) {
  return internal_estimateFeesPerGas$1(client2, args);
}
async function internal_estimateFeesPerGas$1(client2, args) {
  const { block: block_, chain: chain2 = client2.chain, request: request2, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain2?.fees?.baseFeeMultiplier === "function")
      return chain2.fees.baseFeeMultiplier({
        block: block_,
        client: client2,
        request: request2
      });
    return chain2?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError$1();
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base3) => base3 * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block2 = block_ ? block_ : await getAction$3(client2, getBlock$3, "getBlock")({});
  if (typeof chain2?.fees?.estimateFeesPerGas === "function")
    return chain2.fees.estimateFeesPerGas({
      block: block_,
      client: client2,
      multiply,
      request: request2,
      type
    });
  if (type === "eip1559") {
    if (typeof block2.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError$1();
    const maxPriorityFeePerGas = request2?.maxPriorityFeePerGas ? request2.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas$1(client2, {
      block: block2,
      chain: chain2,
      request: request2
    });
    const baseFeePerGas = multiply(block2.baseFeePerGas);
    const maxFeePerGas = request2?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request2?.gasPrice ?? multiply(await getAction$3(client2, getGasPrice$3, "getGasPrice")({}));
  return {
    gasPrice
  };
}
async function getTransactionCount$3(client2, { address: address2, blockTag = "latest", blockNumber }) {
  const count = await client2.request({
    method: "eth_getTransactionCount",
    params: [address2, blockNumber ? numberToHex(blockNumber) : blockTag]
  });
  return hexToNumber$1(count);
}
function getTransactionType$3(transaction2) {
  if (transaction2.type)
    return transaction2.type;
  if (typeof transaction2.maxFeePerGas !== "undefined" || typeof transaction2.maxPriorityFeePerGas !== "undefined")
    return "eip1559";
  if (typeof transaction2.gasPrice !== "undefined") {
    if (typeof transaction2.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError$1({ transaction: transaction2 });
}
async function prepareTransactionRequest$1(client2, args) {
  const { account: account_ = client2.account, chain: chain2, gas, nonce, type } = args;
  if (!account_)
    throw new AccountNotFoundError$1();
  const account2 = parseAccount$3(account_);
  const block2 = await getAction$3(client2, getBlock$3, "getBlock")({ blockTag: "latest" });
  const request2 = { ...args, from: account2.address };
  if (typeof nonce === "undefined")
    request2.nonce = await getAction$3(client2, getTransactionCount$3, "getTransactionCount")({
      address: account2.address,
      blockTag: "pending"
    });
  if (typeof type === "undefined") {
    try {
      request2.type = getTransactionType$3(request2);
    } catch {
      request2.type = typeof block2.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
    }
  }
  if (request2.type === "eip1559") {
    const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas$1(client2, {
      block: block2,
      chain: chain2,
      request: request2
    });
    if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
      throw new MaxFeePerGasTooLowError$1({
        maxPriorityFeePerGas
      });
    request2.maxPriorityFeePerGas = maxPriorityFeePerGas;
    request2.maxFeePerGas = maxFeePerGas;
  } else {
    if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
      throw new Eip1559FeesNotSupportedError$1();
    const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas$1(client2, {
      block: block2,
      chain: chain2,
      request: request2,
      type: "legacy"
    });
    request2.gasPrice = gasPrice_;
  }
  if (typeof gas === "undefined")
    request2.gas = await getAction$3(client2, estimateGas$3, "estimateGas")({
      ...request2,
      account: { address: account2.address, type: "json-rpc" }
    });
  assertRequest$3(request2);
  return request2;
}
async function estimateGas$3(client2, args) {
  const account_ = args.account ?? client2.account;
  if (!account_)
    throw new AccountNotFoundError$1({
      docsPath: "/docs/actions/public/estimateGas"
    });
  const account2 = parseAccount$3(account_);
  try {
    const { accessList, blockNumber, blockTag, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account2.type === "local" ? await prepareTransactionRequest$1(client2, args) : args;
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block2 = blockNumberHex || blockTag;
    assertRequest$3(args);
    const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request2 = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract$3(rest, { format: chainFormat }),
      from: account2.address,
      accessList,
      data: data2,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    const balance = await client2.request({
      method: "eth_estimateGas",
      params: block2 ? [request2, block2] : [request2]
    });
    return BigInt(balance);
  } catch (err) {
    throw getEstimateGasError$3(err, {
      ...args,
      account: account2,
      chain: client2.chain
    });
  }
}
async function estimateContractGas$3(client2, { abi: abi2, address: address2, args, functionName, ...request2 }) {
  const data2 = encodeFunctionData$3({
    abi: abi2,
    args,
    functionName
  });
  try {
    const gas = await getAction$3(client2, estimateGas$3, "estimateGas")({
      data: data2,
      to: address2,
      ...request2
    });
    return gas;
  } catch (err) {
    const account2 = request2.account ? parseAccount$3(request2.account) : void 0;
    throw getContractError$3(err, {
      abi: abi2,
      address: address2,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account2?.address
    });
  }
}
const docsPath$8 = "/docs/contract/decodeEventLog";
function decodeEventLog$3({ abi: abi2, data: data2, strict: strict_, topics }) {
  const strict = strict_ ?? true;
  const [signature2, ...argTopics] = topics;
  if (!signature2)
    throw new AbiEventSignatureEmptyTopicsError({
      docsPath: docsPath$8
    });
  const abiItem2 = abi2.find((x2) => x2.type === "event" && signature2 === getEventSelector$3(formatAbiItem$4(x2)));
  if (!(abiItem2 && "name" in abiItem2) || abiItem2.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature2, {
      docsPath: docsPath$8
    });
  const { name: name2, inputs } = abiItem2;
  const isUnnamed = inputs?.some((x2) => !("name" in x2 && x2.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x2) => "indexed" in x2 && x2.indexed);
  for (let i2 = 0; i2 < indexedInputs.length; i2++) {
    const param = indexedInputs[i2];
    const topic = argTopics[i2];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem: abiItem2,
        param
      });
    args[param.name || i2] = decodeTopic$1({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x2) => !("indexed" in x2 && x2.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data2 && data2 !== "0x") {
      try {
        const decodedData2 = decodeAbiParameters$3(nonIndexedInputs, data2);
        if (decodedData2) {
          if (isUnnamed)
            args = [...args, ...decodedData2];
          else {
            for (let i2 = 0; i2 < nonIndexedInputs.length; i2++) {
              args[nonIndexedInputs[i2].name] = decodedData2[i2];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError)
            throw new DecodeLogDataMismatch({
              abiItem: abiItem2,
              data: err.data,
              params: err.params,
              size: err.size
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem: abiItem2,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name2,
    args: Object.values(args).length > 0 ? args : void 0
  };
}
function decodeTopic$1({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters$3([param], value) || [];
  return decodedArg[0];
}
async function getLogs$3(client2, { address: address2, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events2 = events_ ?? (event ? [event] : void 0);
  let topics = [];
  if (events2) {
    topics = [
      events2.flatMap((event2) => encodeEventTopics$3({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client2.request({
      method: "eth_getLogs",
      params: [{ address: address2, topics, blockHash }]
    });
  } else {
    logs = await client2.request({
      method: "eth_getLogs",
      params: [
        {
          address: address2,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  return logs.map((log3) => {
    try {
      const { eventName, args: args2 } = events2 ? decodeEventLog$3({
        abi: events2,
        data: log3.data,
        topics: log3.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog$1(log3, { args: args2, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
      }
      return formatLog$1(log3, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
async function getContractEvents$3(client2, { abi: abi2, address: address2, args, blockHash, eventName, fromBlock, toBlock, strict }) {
  const event = eventName ? getAbiItem$3({ abi: abi2, name: eventName }) : void 0;
  const events2 = !event ? abi2.filter((x2) => x2.type === "event") : void 0;
  return getAction$3(client2, getLogs$3, "getLogs")({
    address: address2,
    args,
    blockHash,
    event,
    events: events2,
    fromBlock,
    toBlock,
    strict
  });
}
const docsPath$7 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult$3({ abi: abi2, args, functionName, data: data2 }) {
  let abiItem2 = abi2[0];
  if (functionName) {
    abiItem2 = getAbiItem$3({
      abi: abi2,
      args,
      name: functionName
    });
    if (!abiItem2)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath$7 });
  }
  if (abiItem2.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$7 });
  if (!abiItem2.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem2.name, { docsPath: docsPath$7 });
  const values = decodeAbiParameters$3(abiItem2.outputs, data2);
  if (values && values.length > 1)
    return values;
  if (values && values.length === 1)
    return values[0];
  return void 0;
}
const multicall3Abi$1 = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const universalResolverErrors$1 = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  }
];
const universalResolverResolveAbi$1 = [
  ...universalResolverErrors$1,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
];
const universalResolverReverseAbi$1 = [
  ...universalResolverErrors$1,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
];
const textResolverAbi$1 = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
];
const addressResolverAbi$1 = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
];
const universalSignatureValidatorAbi$1 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_signer",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_hash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
];
const aggregate3Signature$1 = "0x82ad56cb";
function getChainContractAddress$3({ blockNumber, chain: chain2, contract: name2 }) {
  const contract2 = chain2?.contracts?.[name2];
  if (!contract2)
    throw new ChainDoesNotSupportContract$1({
      chain: chain2,
      contract: { name: name2 }
    });
  if (blockNumber && contract2.blockCreated && contract2.blockCreated > blockNumber)
    throw new ChainDoesNotSupportContract$1({
      blockNumber,
      chain: chain2,
      contract: {
        name: name2,
        blockCreated: contract2.blockCreated
      }
    });
  return contract2.address;
}
function getCallError$3(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError$3(err, args);
    if (cause2 instanceof UnknownNodeError$1)
      return err;
    return cause2;
  })();
  return new CallExecutionError$1(cause, {
    docsPath: docsPath2,
    ...args
  });
}
const schedulerCache$1 = /* @__PURE__ */ new Map();
function createBatchScheduler$3({ fn, id: id2, shouldSplitBatch, wait: wait2 = 0, sort }) {
  const exec = async () => {
    const scheduler2 = getScheduler();
    flush2();
    const args = scheduler2.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn(args).then((data2) => {
      if (sort && Array.isArray(data2))
        data2.sort(sort);
      for (let i2 = 0; i2 < scheduler2.length; i2++) {
        const { pendingPromise } = scheduler2[i2];
        pendingPromise.resolve?.([data2[i2], data2]);
      }
    }).catch((err) => {
      for (let i2 = 0; i2 < scheduler2.length; i2++) {
        const { pendingPromise } = scheduler2[i2];
        pendingPromise.reject?.(err);
      }
    });
  };
  const flush2 = () => schedulerCache$1.delete(id2);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache$1.get(id2) || [];
  const setScheduler = (item) => schedulerCache$1.set(id2, [...getScheduler(), item]);
  return {
    flush: flush2,
    async schedule(args) {
      const pendingPromise = {};
      const promise = new Promise((resolve, reject) => {
        pendingPromise.resolve = resolve;
        pendingPromise.reject = reject;
      });
      const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, pendingPromise });
        return promise;
      }
      setScheduler({ args, pendingPromise });
      setTimeout(exec, wait2);
      return promise;
    }
  };
}
async function call$1(client2, args) {
  const { account: account_ = client2.account, batch: batch2 = Boolean(client2.batch?.multicall), blockNumber, blockTag = "latest", accessList, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
  const account2 = account_ ? parseAccount$3(account_) : void 0;
  try {
    assertRequest$3(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block2 = blockNumberHex || blockTag;
    const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request2 = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract$3(rest, { format: chainFormat }),
      from: account2?.address,
      accessList,
      data: data2,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    if (batch2 && shouldPerformMulticall({ request: request2 })) {
      try {
        return await scheduleMulticall(client2, {
          ...request2,
          blockNumber,
          blockTag
        });
      } catch (err) {
        if (!(err instanceof ClientChainNotConfiguredError$1) && !(err instanceof ChainDoesNotSupportContract$1))
          throw err;
      }
    }
    const response = await client2.request({
      method: "eth_call",
      params: block2 ? [request2, block2] : [request2]
    });
    if (response === "0x")
      return { data: void 0 };
    return { data: response };
  } catch (err) {
    const data3 = getRevertErrorData(err);
    const { offchainLookup, offchainLookupSignature } = await __vitePreload(() => import("./ccip-d92c4d19.js"), true ? [] : void 0);
    if (data3?.slice(0, 10) === offchainLookupSignature && to) {
      return { data: await offchainLookup(client2, { data: data3, to }) };
    }
    throw getCallError$3(err, {
      ...args,
      account: account2,
      chain: client2.chain
    });
  }
}
function shouldPerformMulticall({ request: request2 }) {
  const { data: data2, to, ...request_ } = request2;
  if (!data2)
    return false;
  if (data2.startsWith(aggregate3Signature$1))
    return false;
  if (!to)
    return false;
  if (Object.values(request_).filter((x2) => typeof x2 !== "undefined").length > 0)
    return false;
  return true;
}
async function scheduleMulticall(client2, args) {
  const { batchSize = 1024, wait: wait2 = 0 } = typeof client2.batch?.multicall === "object" ? client2.batch.multicall : {};
  const { blockNumber, blockTag = "latest", data: data2, multicallAddress: multicallAddress_, to } = args;
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client2.chain)
      throw new ClientChainNotConfiguredError$1();
    multicallAddress = getChainContractAddress$3({
      blockNumber,
      chain: client2.chain,
      contract: "multicall3"
    });
  }
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const block2 = blockNumberHex || blockTag;
  const { schedule } = createBatchScheduler$3({
    id: `${client2.uid}.${block2}`,
    wait: wait2,
    shouldSplitBatch(args2) {
      const size2 = args2.reduce((size3, { data: data3 }) => size3 + (data3.length - 2), 0);
      return size2 > batchSize * 2;
    },
    fn: async (requests) => {
      const calls = requests.map((request2) => ({
        allowFailure: true,
        callData: request2.data,
        target: request2.to
      }));
      const calldata = encodeFunctionData$3({
        abi: multicall3Abi$1,
        args: [calls],
        functionName: "aggregate3"
      });
      const data3 = await client2.request({
        method: "eth_call",
        params: [
          {
            data: calldata,
            to: multicallAddress
          },
          block2
        ]
      });
      return decodeFunctionResult$3({
        abi: multicall3Abi$1,
        args: [calls],
        functionName: "aggregate3",
        data: data3 || "0x"
      });
    }
  });
  const [{ returnData, success }] = await schedule({ data: data2, to });
  if (!success)
    throw new RawContractError$1({ data: returnData });
  if (returnData === "0x")
    return { data: void 0 };
  return { data: returnData };
}
function getRevertErrorData(err) {
  if (!(err instanceof BaseError$2))
    return void 0;
  const error = err.walk();
  return typeof error.data === "object" ? error.data.data : error.data;
}
async function readContract$4(client2, { abi: abi2, address: address2, args, functionName, ...callRequest }) {
  const calldata = encodeFunctionData$3({
    abi: abi2,
    args,
    functionName
  });
  try {
    const { data: data2 } = await getAction$3(client2, call$1, "call")({
      data: calldata,
      to: address2,
      ...callRequest
    });
    return decodeFunctionResult$3({
      abi: abi2,
      args,
      functionName,
      data: data2 || "0x"
    });
  } catch (err) {
    throw getContractError$3(err, {
      abi: abi2,
      address: address2,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}
async function simulateContract$3(client2, { abi: abi2, address: address2, args, dataSuffix, functionName, ...callRequest }) {
  const account2 = callRequest.account ? parseAccount$3(callRequest.account) : void 0;
  const calldata = encodeFunctionData$3({
    abi: abi2,
    args,
    functionName
  });
  try {
    const { data: data2 } = await getAction$3(client2, call$1, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address2,
      ...callRequest
    });
    const result = decodeFunctionResult$3({
      abi: abi2,
      args,
      functionName,
      data: data2 || "0x"
    });
    return {
      result,
      request: {
        abi: abi2,
        address: address2,
        args,
        dataSuffix,
        functionName,
        ...callRequest
      }
    };
  } catch (err) {
    throw getContractError$3(err, {
      abi: abi2,
      address: address2,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account2?.address
    });
  }
}
const listenersCache = /* @__PURE__ */ new Map();
const cleanupCache = /* @__PURE__ */ new Map();
let callbackCount = 0;
function observe$3(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners3 = getListeners();
    listenersCache.set(observerId, listeners3.filter((cb2) => cb2.id !== callbackId));
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners2 = getListeners();
  listenersCache.set(observerId, [
    ...listeners2,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners2 && listeners2.length > 0)
    return unwatch;
  const emit3 = {};
  for (const key in callbacks) {
    emit3[key] = (...args) => {
      const listeners3 = getListeners();
      if (listeners3.length === 0)
        return;
      for (const listener of listeners3)
        listener.fns[key]?.(...args);
    };
  }
  const cleanup = fn(emit3);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}
async function wait$3(time2) {
  return new Promise((res) => setTimeout(res, time2));
}
function poll$3(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch2 = async () => {
    let data2 = void 0;
    if (emitOnBegin)
      data2 = await fn({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data2) ?? interval;
    await wait$3(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait$3(interval);
      poll2();
    };
    poll2();
  };
  watch2();
  return unwatch;
}
const promiseCache = /* @__PURE__ */ new Map();
const responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache2) => ({
    clear: () => cache2.delete(cacheKey3),
    get: () => cache2.get(cacheKey3),
    set: (data2) => cache2.set(cacheKey3, data2)
  });
  const promise = buildCache(cacheKey2, promiseCache);
  const response = buildCache(cacheKey2, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache$3(fn, { cacheKey: cacheKey2, cacheTime = Infinity }) {
  const cache2 = getCache(cacheKey2);
  const response = cache2.response.get();
  if (response && cacheTime > 0) {
    const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache2.promise.get();
  if (!promise) {
    promise = fn();
    cache2.promise.set(promise);
  }
  try {
    const data2 = await promise;
    cache2.response.set({ created: /* @__PURE__ */ new Date(), data: data2 });
    return data2;
  } finally {
    cache2.promise.clear();
  }
}
const cacheKey$1 = (id2) => `blockNumber.${id2}`;
async function getBlockNumber$3(client2, { cacheTime = client2.cacheTime, maxAge } = {}) {
  const blockNumberHex = await withCache$3(() => client2.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey$1(client2.uid), cacheTime: maxAge ?? cacheTime });
  return BigInt(blockNumberHex);
}
async function getFilterChanges$3(_client2, { filter: filter2 }) {
  const strict = "strict" in filter2 && filter2.strict;
  const logs = await filter2.request({
    method: "eth_getFilterChanges",
    params: [filter2.id]
  });
  return logs.map((log3) => {
    if (typeof log3 === "string")
      return log3;
    try {
      const { eventName, args } = "abi" in filter2 && filter2.abi ? decodeEventLog$3({
        abi: filter2.abi,
        data: log3.data,
        topics: log3.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog$1(log3, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if ("strict" in filter2 && filter2.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
      }
      return formatLog$1(log3, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
async function uninstallFilter$3(_client2, { filter: filter2 }) {
  return filter2.request({
    method: "eth_uninstallFilter",
    params: [filter2.id]
  });
}
function watchContractEvent$3(client2, { abi: abi2, address: address2, args, batch: batch2 = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client2.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const pollContractEvent = () => {
    const observerId = stringify$3([
      "watchContractEvent",
      address2,
      args,
      batch2,
      client2.uid,
      eventName,
      pollingInterval
    ]);
    const strict = strict_ ?? false;
    return observe$3(observerId, { onLogs, onError }, (emit3) => {
      let previousBlockNumber;
      let filter2;
      let initialized = false;
      const unwatch = poll$3(async () => {
        if (!initialized) {
          try {
            filter2 = await getAction$3(client2, createContractEventFilter$3, "createContractEventFilter")({
              abi: abi2,
              address: address2,
              args,
              eventName,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getAction$3(client2, getFilterChanges$3, "getFilterChanges")({ filter: filter2 });
          } else {
            const blockNumber = await getAction$3(client2, getBlockNumber$3, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction$3(client2, getContractEvents$3, "getContractEvents")({
                abi: abi2,
                address: address2,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch2)
            emit3.onLogs(logs);
          else
            for (const log3 of logs)
              emit3.onLogs([log3]);
        } catch (err) {
          if (filter2 && err instanceof InvalidInputRpcError$1)
            initialized = false;
          emit3.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction$3(client2, uninstallFilter$3, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const topics = eventName ? encodeEventTopics$3({
          abi: abi2,
          eventName,
          args
        }) : [];
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["logs", { address: address2, topics }],
          onData(data2) {
            if (!active)
              return;
            const log3 = data2.result;
            try {
              const { eventName: eventName2, args: args2 } = decodeEventLog$3({
                abi: abi2,
                data: log3.data,
                topics: log3.topics,
                strict: strict_
              });
              const formatted = formatLog$1(log3, {
                args: args2,
                eventName: eventName2
              });
              onLogs([formatted]);
            } catch (err) {
              let eventName2;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName2 = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
              }
              const formatted = formatLog$1(log3, {
                args: isUnnamed ? [] : {},
                eventName: eventName2
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}
function assertCurrentChain$3({ chain: chain2, currentChainId }) {
  if (!chain2)
    throw new ChainNotFoundError$1();
  if (currentChainId !== chain2.id)
    throw new ChainMismatchError$1({ chain: chain2, currentChainId });
}
function getTransactionError$3(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError$3(err, args);
    if (cause2 instanceof UnknownNodeError$1)
      return err;
    return cause2;
  })();
  return new TransactionExecutionError$1(cause, {
    docsPath: docsPath2,
    ...args
  });
}
async function getChainId$3(client2) {
  const chainIdHex = await client2.request({
    method: "eth_chainId"
  });
  return hexToNumber$1(chainIdHex);
}
async function sendRawTransaction$3(client2, { serializedTransaction }) {
  return client2.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  });
}
async function sendTransaction$3(client2, args) {
  const { account: account_ = client2.account, chain: chain2 = client2.chain, accessList, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
  if (!account_)
    throw new AccountNotFoundError$1({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account2 = parseAccount$3(account_);
  try {
    assertRequest$3(args);
    let chainId;
    if (chain2 !== null) {
      chainId = await getAction$3(client2, getChainId$3, "getChainId")({});
      assertCurrentChain$3({
        currentChainId: chainId,
        chain: chain2
      });
    }
    if (account2.type === "local") {
      const request3 = await getAction$3(client2, prepareTransactionRequest$1, "prepareTransactionRequest")({
        account: account2,
        accessList,
        chain: chain2,
        data: data2,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        ...rest
      });
      if (!chainId)
        chainId = await getAction$3(client2, getChainId$3, "getChainId")({});
      const serializer = chain2?.serializers?.transaction;
      const serializedTransaction = await account2.signTransaction({
        ...request3,
        chainId
      }, { serializer });
      return await getAction$3(client2, sendRawTransaction$3, "sendRawTransaction")({
        serializedTransaction
      });
    }
    const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request2 = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract$3(rest, { format: chainFormat }),
      accessList,
      data: data2,
      from: account2.address,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    return await client2.request({
      method: "eth_sendTransaction",
      params: [request2]
    });
  } catch (err) {
    throw getTransactionError$3(err, {
      ...args,
      account: account2,
      chain: args.chain || void 0
    });
  }
}
async function writeContract$3(client2, { abi: abi2, address: address2, args, dataSuffix, functionName, ...request2 }) {
  const data2 = encodeFunctionData$3({
    abi: abi2,
    args,
    functionName
  });
  const hash2 = await getAction$3(client2, sendTransaction$3, "sendTransaction")({
    data: `${data2}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
    to: address2,
    ...request2
  });
  return hash2;
}
async function addChain$3(client2, { chain: chain2 }) {
  const { id: id2, name: name2, nativeCurrency, rpcUrls, blockExplorers } = chain2;
  await client2.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(id2),
        chainName: name2,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
      }
    ]
  });
}
const size$4 = 256;
let index$n = size$4;
let buffer$5;
function uid$3(length2 = 11) {
  if (!buffer$5 || index$n + length2 > size$4 * 2) {
    buffer$5 = "";
    index$n = 0;
    for (let i2 = 0; i2 < size$4; i2++) {
      buffer$5 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer$5.substring(index$n, index$n++ + length2);
}
function createClient$3(parameters) {
  const { batch: batch2, cacheTime = parameters.pollingInterval ?? 4e3, key = "base", name: name2 = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
  const chain2 = parameters.chain;
  const account2 = parameters.account ? parseAccount$3(parameters.account) : void 0;
  const { config: config2, request: request2, value } = parameters.transport({
    chain: chain2,
    pollingInterval
  });
  const transport2 = { ...config2, ...value };
  const client2 = {
    account: account2,
    batch: batch2,
    cacheTime,
    chain: chain2,
    key,
    name: name2,
    pollingInterval,
    request: request2,
    transport: transport2,
    type,
    uid: uid$3()
  };
  function extend(base3) {
    return (extendFn) => {
      const extended = extendFn(base3);
      for (const key2 in client2)
        delete extended[key2];
      const combined = { ...base3, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client2, { extend: extend(client2) });
}
function withRetry$3(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry2 = async ({ error }) => {
        const delay2 = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay2)
          await wait$3(delay2);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data2 = await fn();
        resolve(data2);
      } catch (err) {
        if (count < retryCount && await shouldRetry({ count, error: err }))
          return retry2({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}
const isDeterministicError = (error) => {
  if ("code" in error)
    return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
  if (error instanceof HttpRequestError$1 && error.status)
    return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
  return false;
};
function buildRequest$3(request2, { retryDelay = 150, retryCount = 3 } = {}) {
  return async (args) => withRetry$3(async () => {
    try {
      return await request2(args);
    } catch (err_) {
      const err = err_;
      switch (err.code) {
        case ParseRpcError$1.code:
          throw new ParseRpcError$1(err);
        case InvalidRequestRpcError$1.code:
          throw new InvalidRequestRpcError$1(err);
        case MethodNotFoundRpcError$1.code:
          throw new MethodNotFoundRpcError$1(err);
        case InvalidParamsRpcError$1.code:
          throw new InvalidParamsRpcError$1(err);
        case InternalRpcError$1.code:
          throw new InternalRpcError$1(err);
        case InvalidInputRpcError$1.code:
          throw new InvalidInputRpcError$1(err);
        case ResourceNotFoundRpcError$1.code:
          throw new ResourceNotFoundRpcError$1(err);
        case ResourceUnavailableRpcError$1.code:
          throw new ResourceUnavailableRpcError$1(err);
        case TransactionRejectedRpcError$1.code:
          throw new TransactionRejectedRpcError$1(err);
        case MethodNotSupportedRpcError$1.code:
          throw new MethodNotSupportedRpcError$1(err);
        case LimitExceededRpcError$1.code:
          throw new LimitExceededRpcError$1(err);
        case JsonRpcVersionUnsupportedError$1.code:
          throw new JsonRpcVersionUnsupportedError$1(err);
        case UserRejectedRequestError$1.code:
          throw new UserRejectedRequestError$1(err);
        case UnauthorizedProviderError$1.code:
          throw new UnauthorizedProviderError$1(err);
        case UnsupportedProviderMethodError$1.code:
          throw new UnsupportedProviderMethodError$1(err);
        case ProviderDisconnectedError$1.code:
          throw new ProviderDisconnectedError$1(err);
        case ChainDisconnectedError$1.code:
          throw new ChainDisconnectedError$1(err);
        case SwitchChainError$1.code:
          throw new SwitchChainError$1(err);
        case 5e3:
          throw new UserRejectedRequestError$1(err);
        default:
          if (err_ instanceof BaseError$2)
            throw err_;
          throw new UnknownRpcError$1(err);
      }
    }
  }, {
    delay: ({ count, error }) => {
      if (error && error instanceof HttpRequestError$1) {
        const retryAfter = error?.headers?.get("Retry-After");
        if (retryAfter?.match(/\d/))
          return parseInt(retryAfter) * 1e3;
      }
      return ~~(1 << count) * retryDelay;
    },
    retryCount,
    shouldRetry: ({ error }) => !isDeterministicError(error)
  });
}
function createTransport$3({ key, name: name2, request: request2, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  return {
    config: { key, name: name2, request: request2, retryCount, retryDelay, timeout, type },
    request: buildRequest$3(request2, { retryCount, retryDelay }),
    value
  };
}
function custom$3(provider2, config2 = {}) {
  const { key = "custom", name: name2 = "Custom Provider", retryDelay } = config2;
  return ({ retryCount: defaultRetryCount }) => createTransport$3({
    key,
    name: name2,
    request: provider2.request.bind(provider2),
    retryCount: config2.retryCount ?? defaultRetryCount,
    retryDelay,
    type: "custom"
  });
}
function fallback$3(transports_, config2 = {}) {
  const { key = "fallback", name: name2 = "Fallback", rank = false, retryCount, retryDelay } = config2;
  return ({ chain: chain2, pollingInterval = 4e3, timeout }) => {
    let transports = transports_;
    let onResponse = () => {
    };
    const transport2 = createTransport$3({
      key,
      name: name2,
      async request({ method, params }) {
        const fetch2 = async (i2 = 0) => {
          const transport3 = transports[i2]({ chain: chain2, retryCount: 0, timeout });
          try {
            const response = await transport3.request({
              method,
              params
            });
            onResponse({
              method,
              params,
              response,
              transport: transport3,
              status: "success"
            });
            return response;
          } catch (err) {
            onResponse({
              error: err,
              method,
              params,
              transport: transport3,
              status: "error"
            });
            if (isDeterministicError(err))
              throw err;
            if (i2 === transports.length - 1)
              throw err;
            return fetch2(i2 + 1);
          }
        };
        return fetch2();
      },
      retryCount,
      retryDelay,
      type: "fallback"
    }, {
      onResponse: (fn) => onResponse = fn,
      transports: transports.map((fn) => fn({ chain: chain2, retryCount: 0 }))
    });
    if (rank) {
      const rankOptions = typeof rank === "object" ? rank : {};
      rankTransports$1({
        chain: chain2,
        interval: rankOptions.interval ?? pollingInterval,
        onTransports: (transports_2) => transports = transports_2,
        sampleCount: rankOptions.sampleCount,
        timeout: rankOptions.timeout,
        transports,
        weights: rankOptions.weights
      });
    }
    return transport2;
  };
}
function rankTransports$1({ chain: chain2, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
  const samples = [];
  const rankTransports_ = async () => {
    const sample = await Promise.all(transports.map(async (transport2) => {
      const transport_ = transport2({ chain: chain2, retryCount: 0, timeout });
      const start = Date.now();
      let end2;
      let success;
      try {
        await transport_.request({ method: "net_listening" });
        success = 1;
      } catch {
        success = 0;
      } finally {
        end2 = Date.now();
      }
      const latency = end2 - start;
      return { latency, success };
    }));
    samples.push(sample);
    if (samples.length > sampleCount)
      samples.shift();
    const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
    const scores = transports.map((_2, i2) => {
      const latencies = samples.map((sample2) => sample2[i2].latency);
      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
      const latencyScore = 1 - meanLatency / maxLatency;
      const successes = samples.map((sample2) => sample2[i2].success);
      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
      if (stabilityScore === 0)
        return [0, i2];
      return [
        latencyWeight * latencyScore + stabilityWeight * stabilityScore,
        i2
      ];
    }).sort((a2, b2) => b2[0] - a2[0]);
    onTransports(scores.map(([, i2]) => transports[i2]));
    await wait$3(interval);
    rankTransports_();
  };
  rankTransports_();
}
let UrlRequiredError$1 = class UrlRequiredError2 extends BaseError$2 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro"
    });
  }
};
function getNativeWebSocket() {
  if (typeof WebSocket !== "undefined")
    return WebSocket;
  if (typeof window.WebSocket !== "undefined")
    return window.WebSocket;
  if (typeof window.WebSocket !== "undefined")
    return window.WebSocket;
  if (typeof self.WebSocket !== "undefined")
    return self.WebSocket;
  throw new Error("`WebSocket` is not supported in this environment");
}
const WebSocket$1 = getNativeWebSocket();
const native = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WebSocket: WebSocket$1
}, Symbol.toStringTag, { value: "Module" }));
function withTimeout$3(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn({ signal: controller?.signal }));
      } catch (err) {
        if (err.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
let id$1 = 0;
async function http$4(url, { body, fetchOptions = {}, timeout = 1e4 }) {
  const { headers, method, signal: signal_ } = fetchOptions;
  try {
    const response = await withTimeout$3(async ({ signal }) => {
      const response2 = await fetch(url, {
        ...fetchOptions,
        body: Array.isArray(body) ? stringify$3(body.map((body2) => ({
          jsonrpc: "2.0",
          id: body2.id ?? id$1++,
          ...body2
        }))) : stringify$3({ jsonrpc: "2.0", id: body.id ?? id$1++, ...body }),
        headers: {
          ...headers,
          "Content-Type": "application/json"
        },
        method: method || "POST",
        signal: signal_ || (timeout > 0 ? signal : void 0)
      });
      return response2;
    }, {
      errorInstance: new TimeoutError$1({ body, url }),
      timeout,
      signal: true
    });
    let data2;
    if (response.headers.get("Content-Type")?.startsWith("application/json")) {
      data2 = await response.json();
    } else {
      data2 = await response.text();
    }
    if (!response.ok) {
      throw new HttpRequestError$1({
        body,
        details: stringify$3(data2.error) || response.statusText,
        headers: response.headers,
        status: response.status,
        url
      });
    }
    return data2;
  } catch (err) {
    if (err instanceof HttpRequestError$1)
      throw err;
    if (err instanceof TimeoutError$1)
      throw err;
    throw new HttpRequestError$1({
      body,
      details: err.message,
      url
    });
  }
}
const socketsCache = /* @__PURE__ */ new Map();
async function getSocket(url) {
  let socket = socketsCache.get(url);
  if (socket)
    return socket;
  const { schedule } = createBatchScheduler$3({
    id: url,
    fn: async () => {
      const webSocket2 = new WebSocket$1(url);
      const requests = /* @__PURE__ */ new Map();
      const subscriptions = /* @__PURE__ */ new Map();
      const onMessage = ({ data: data2 }) => {
        const message = JSON.parse(data2);
        const isSubscription = message.method === "eth_subscription";
        const id2 = isSubscription ? message.params.subscription : message.id;
        const cache2 = isSubscription ? subscriptions : requests;
        const callback = cache2.get(id2);
        if (callback)
          callback({ data: data2 });
        if (!isSubscription)
          cache2.delete(id2);
      };
      const onClose = () => {
        socketsCache.delete(url);
        webSocket2.removeEventListener("close", onClose);
        webSocket2.removeEventListener("message", onMessage);
      };
      webSocket2.addEventListener("close", onClose);
      webSocket2.addEventListener("message", onMessage);
      if (webSocket2.readyState === WebSocket$1.CONNECTING) {
        await new Promise((resolve, reject) => {
          if (!webSocket2)
            return;
          webSocket2.onopen = resolve;
          webSocket2.onerror = reject;
        });
      }
      socket = Object.assign(webSocket2, {
        requests,
        subscriptions
      });
      socketsCache.set(url, socket);
      return [socket];
    }
  });
  const [_2, [socket_]] = await schedule();
  return socket_;
}
function webSocket$4(socket, { body, onResponse }) {
  if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
    throw new WebSocketRequestError$1({
      body,
      url: socket.url,
      details: "Socket is closed."
    });
  const id_ = id$1++;
  const callback = ({ data: data2 }) => {
    const message = JSON.parse(data2);
    if (typeof message.id === "number" && id_ !== message.id)
      return;
    onResponse?.(message);
    if (body.method === "eth_subscribe" && typeof message.result === "string") {
      socket.subscriptions.set(message.result, callback);
    }
    if (body.method === "eth_unsubscribe") {
      socket.subscriptions.delete(body.params?.[0]);
    }
  };
  socket.requests.set(id_, callback);
  socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
  return socket;
}
async function webSocketAsync(socket, { body, timeout = 1e4 }) {
  return withTimeout$3(() => new Promise((onResponse) => rpc$a.webSocket(socket, {
    body,
    onResponse
  })), {
    errorInstance: new TimeoutError$1({ body, url: socket.url }),
    timeout
  });
}
const rpc$a = {
  http: http$4,
  webSocket: webSocket$4,
  webSocketAsync
};
function http$3(url, config2 = {}) {
  const { batch: batch2, fetchOptions, key = "http", name: name2 = "HTTP JSON-RPC", retryDelay } = config2;
  return ({ chain: chain2, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch2 === "object" ? batch2 : {};
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = url || chain2?.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError$1();
    return createTransport$3({
      key,
      name: name2,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler$3({
          id: `${url}`,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpc$a.http(url_, {
            body: body2,
            fetchOptions,
            timeout
          }),
          sort: (a2, b2) => a2.id - b2.id
        });
        const fn = async (body2) => batch2 ? schedule(body2) : [await rpc$a.http(url_, { body: body2, fetchOptions, timeout })];
        const [{ error, result }] = await fn(body);
        if (error)
          throw new RpcRequestError$1({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url
    });
  };
}
function isNullUniversalResolverError$1(err, callType) {
  if (!(err instanceof BaseError$2))
    return false;
  const cause = err.walk((e2) => e2 instanceof ContractFunctionRevertedError$1);
  if (!(cause instanceof ContractFunctionRevertedError$1))
    return false;
  if (cause.data?.errorName === "ResolverNotFound")
    return true;
  if (cause.data?.errorName === "ResolverWildcardNotSupported")
    return true;
  if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons$1[50])
    return true;
  return false;
}
function encodedLabelToLabelhash$3(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash2 = `0x${label.slice(1, 65)}`;
  if (!isHex$3(hash2))
    return null;
  return hash2;
}
function namehash$3(name2) {
  let result = new Uint8Array(32).fill(0);
  if (!name2)
    return bytesToHex$1(result);
  const labels = name2.split(".");
  for (let i2 = labels.length - 1; i2 >= 0; i2 -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash$3(labels[i2]);
    const hashed = hashFromEncodedLabel ? toBytes$4(hashFromEncodedLabel) : keccak256$3(stringToBytes(labels[i2]), "bytes");
    result = keccak256$3(concat$6([result, hashed]), "bytes");
  }
  return bytesToHex$1(result);
}
function encodeLabelhash$3(hash2) {
  return `[${hash2.slice(2)}]`;
}
function labelhash$3(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex$1(result);
  return encodedLabelToLabelhash$3(label) || keccak256$3(stringToBytes(label));
}
function packetToBytes$3(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes2 = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (let i2 = 0; i2 < list.length; i2++) {
    let encoded = stringToBytes(list[i2]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash$3(labelhash$3(list[i2])));
    bytes2[offset] = encoded.length;
    bytes2.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes2.byteLength !== offset + 1)
    return bytes2.slice(0, offset + 1);
  return bytes2;
}
async function getEnsAddress$3(client2, { blockNumber, blockTag, coinType, name: name2, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress$3({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = encodeFunctionData$3({
      abi: addressResolverAbi$1,
      functionName: "addr",
      ...coinType != null ? { args: [namehash$3(name2), BigInt(coinType)] } : { args: [namehash$3(name2)] }
    });
    const res = await getAction$3(client2, readContract$4, "readContract")({
      address: universalResolverAddress,
      abi: universalResolverResolveAbi$1,
      functionName: "resolve",
      args: [toHex$1(packetToBytes$3(name2)), functionData],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const address2 = decodeFunctionResult$3({
      abi: addressResolverAbi$1,
      args: coinType != null ? [namehash$3(name2), BigInt(coinType)] : void 0,
      functionName: "addr",
      data: res[0]
    });
    if (address2 === "0x")
      return null;
    if (trim$3(address2) === "0x00")
      return null;
    return address2;
  } catch (err) {
    if (isNullUniversalResolverError$1(err, "resolve"))
      return null;
    throw err;
  }
}
let EnsAvatarInvalidMetadataError$1 = class EnsAvatarInvalidMetadataError2 extends BaseError$2 {
  constructor({ data: data2 }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data2)}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidMetadataError"
    });
  }
};
let EnsAvatarInvalidNftUriError$1 = class EnsAvatarInvalidNftUriError2 extends BaseError$2 {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidNftUriError"
    });
  }
};
let EnsAvatarUriResolutionError$1 = class EnsAvatarUriResolutionError2 extends BaseError$2 {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUriResolutionError"
    });
  }
};
let EnsAvatarUnsupportedNamespaceError$1 = class EnsAvatarUnsupportedNamespaceError2 extends BaseError$2 {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUnsupportedNamespaceError"
    });
  }
};
const networkRegex$1 = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
const ipfsHashRegex$1 = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
const base64Regex$1 = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
const dataURIRegex$1 = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri$1(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType?.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        resolve(true);
      };
      img.onerror = () => {
        resolve(false);
      };
      img.src = uri;
    });
  }
}
function getGateway$1(custom2, defaultGateway) {
  if (!custom2)
    return defaultGateway;
  if (custom2.endsWith("/"))
    return custom2.slice(0, -1);
  return custom2;
}
function resolveAvatarUri$1({ uri, gatewayUrls }) {
  const isEncoded = base64Regex$1.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway$1(gatewayUrls?.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway$1(gatewayUrls?.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex$1);
  const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex$1.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls?.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex$1, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError$1({ uri });
}
function getJsonImage$1(data2) {
  if (typeof data2 !== "object" || !("image" in data2) && !("image_url" in data2) && !("image_data" in data2)) {
    throw new EnsAvatarInvalidMetadataError$1({ data: data2 });
  }
  return data2.image || data2.image_url || data2.image_data;
}
async function getMetadataAvatarUri$1({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri$1({
      gatewayUrls,
      uri: getJsonImage$1(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError$1({ uri });
  }
}
async function parseAvatarUri$1({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri$1({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri$1(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError$1({ uri });
}
function parseNftUri$1(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError$1({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError$1({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError$1({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError$1({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError$1({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri$1(client2, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract$4(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract$4(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError$1({ namespace: nft.namespace });
}
async function parseAvatarRecord$3(client2, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri$1(client2, { gatewayUrls, record });
  return parseAvatarUri$1({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri$1(client2, { gatewayUrls, record }) {
  const nft = parseNftUri$1(record);
  const nftUri = await getNftTokenUri$1(client2, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri$1({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? (
      // if it is encoded, decode it
      atob(resolvedNftUri.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      resolvedNftUri
    );
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri$1({ uri: getJsonImage$1(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri$1({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}
async function getEnsText$3(client2, { blockNumber, blockTag, name: name2, key, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress$3({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const res = await getAction$3(client2, readContract$4, "readContract")({
      address: universalResolverAddress,
      abi: universalResolverResolveAbi$1,
      functionName: "resolve",
      args: [
        toHex$1(packetToBytes$3(name2)),
        encodeFunctionData$3({
          abi: textResolverAbi$1,
          functionName: "text",
          args: [namehash$3(name2), key]
        })
      ],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult$3({
      abi: textResolverAbi$1,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if (isNullUniversalResolverError$1(err, "resolve"))
      return null;
    throw err;
  }
}
async function getEnsAvatar$3(client2, { blockNumber, blockTag, gatewayUrls, name: name2, universalResolverAddress }) {
  const record = await getAction$3(client2, getEnsText$3, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name: name2,
    universalResolverAddress
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord$3(client2, { record, gatewayUrls });
  } catch {
    return null;
  }
}
async function getEnsName$3(client2, { address: address2, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress$3({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address2.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const [name2, resolvedAddress] = await getAction$3(client2, readContract$4, "readContract")({
      address: universalResolverAddress,
      abi: universalResolverReverseAbi$1,
      functionName: "reverse",
      args: [toHex$1(packetToBytes$3(reverseNode))],
      blockNumber,
      blockTag
    });
    if (address2.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name2;
  } catch (err) {
    if (isNullUniversalResolverError$1(err, "reverse"))
      return null;
    throw err;
  }
}
async function getEnsResolver$3(client2, { blockNumber, blockTag, name: name2, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress$3({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await getAction$3(client2, readContract$4, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex$1(packetToBytes$3(name2))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}
async function createBlockFilter$3(client2) {
  const getRequest = createFilterRequestScope$3(client2, {
    method: "eth_newBlockFilter"
  });
  const id2 = await client2.request({
    method: "eth_newBlockFilter"
  });
  return { id: id2, request: getRequest(id2), type: "block" };
}
async function createEventFilter$3(client2, { address: address2, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events2 = events_ ?? (event ? [event] : void 0);
  const getRequest = createFilterRequestScope$3(client2, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events2) {
    topics = [
      events2.flatMap((event2) => encodeEventTopics$3({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  const id2 = await client2.request({
    method: "eth_newFilter",
    params: [
      {
        address: address2,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events2,
    args,
    eventName: event ? event.name : void 0,
    fromBlock,
    id: id2,
    request: getRequest(id2),
    strict,
    toBlock,
    type: "event"
  };
}
async function createPendingTransactionFilter$3(client2) {
  const getRequest = createFilterRequestScope$3(client2, {
    method: "eth_newPendingTransactionFilter"
  });
  const id2 = await client2.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: id2, request: getRequest(id2), type: "transaction" };
}
async function getBalance$3(client2, { address: address2, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const balance = await client2.request({
    method: "eth_getBalance",
    params: [address2, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}
async function getBlockTransactionCount$3(client2, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let count;
  if (blockHash) {
    count = await client2.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  } else {
    count = await client2.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    });
  }
  return hexToNumber$1(count);
}
async function getBytecode$3(client2, { address: address2, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const hex2 = await client2.request({
    method: "eth_getCode",
    params: [address2, blockNumberHex || blockTag]
  });
  if (hex2 === "0x")
    return void 0;
  return hex2;
}
function formatFeeHistory$1(feeHistory2) {
  return {
    baseFeePerGas: feeHistory2.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory2.gasUsedRatio,
    oldestBlock: BigInt(feeHistory2.oldestBlock),
    reward: feeHistory2.reward?.map((reward) => reward.map((value) => BigInt(value)))
  };
}
async function getFeeHistory$3(client2, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const feeHistory2 = await client2.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  });
  return formatFeeHistory$1(feeHistory2);
}
async function getFilterLogs$3(_client2, { filter: filter2 }) {
  const strict = filter2.strict ?? false;
  const logs = await filter2.request({
    method: "eth_getFilterLogs",
    params: [filter2.id]
  });
  return logs.map((log3) => {
    try {
      const { eventName, args } = "abi" in filter2 && filter2.abi ? decodeEventLog$3({
        abi: filter2.abi,
        data: log3.data,
        topics: log3.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog$1(log3, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if ("strict" in filter2 && filter2.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
      }
      return formatLog$1(log3, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
const bytesRegex$2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex$2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function hashTypedData$1({ domain: domain_, message, primaryType, types: types_ }) {
  const domain = typeof domain_ === "undefined" ? {} : domain_;
  const types2 = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...types_
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types: types2
  });
  const parts = ["0x1901"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types: types2
    }));
  if (primaryType !== "EIP712Domain") {
    parts.push(hashStruct({
      data: message,
      primaryType,
      types: types2
    }));
  }
  return keccak256$3(concat$6(parts));
}
function hashDomain({ domain, types: types2 }) {
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types: types2
  });
}
function hashStruct({ data: data2, primaryType, types: types2 }) {
  const encoded = encodeData({
    data: data2,
    primaryType,
    types: types2
  });
  return keccak256$3(encoded);
}
function encodeData({ data: data2, primaryType, types: types2 }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types: types2 })];
  for (const field of types2[primaryType]) {
    const [type, value] = encodeField({
      types: types2,
      name: field.name,
      type: field.type,
      value: data2[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters$3(encodedTypes, encodedValues);
}
function hashType({ primaryType, types: types2 }) {
  const encodedHashType = toHex$1(encodeType({ primaryType, types: types2 }));
  return keccak256$3(encodedHashType);
}
function encodeType({ primaryType, types: types2 }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types: types2 });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type of deps) {
    result += `${type}(${types2[type].map(({ name: name2, type: t2 }) => `${t2} ${name2}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types: types2 }, results = /* @__PURE__ */ new Set()) {
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match?.[0];
  if (results.has(primaryType) || types2[primaryType] === void 0) {
    return results;
  }
  results.add(primaryType);
  for (const field of types2[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types: types2 }, results);
  }
  return results;
}
function encodeField({ types: types2, name: name2, type, value }) {
  if (types2[type] !== void 0) {
    return [
      { type: "bytes32" },
      keccak256$3(encodeData({ data: value, primaryType: type, types: types2 }))
    ];
  }
  if (type === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256$3(value)];
  }
  if (type === "string")
    return [{ type: "bytes32" }, keccak256$3(toHex$1(value))];
  if (type.lastIndexOf("]") === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name: name2,
      type: parsedType,
      types: types2,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak256$3(encodeAbiParameters$3(typeValuePairs.map(([t2]) => t2), typeValuePairs.map(([, v2]) => v2)))
    ];
  }
  return [{ type }, value];
}
function validateTypedData({ domain, message, primaryType, types: types_ }) {
  const types2 = types_;
  const validateData = (struct2, value_) => {
    for (const param of struct2) {
      const { name: name2, type: type_ } = param;
      const type = type_;
      const value = value_[name2];
      const integerMatch = type.match(integerRegex$2);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base3, size_] = integerMatch;
        numberToHex(value, {
          signed: base3 === "int",
          size: parseInt(size_) / 8
        });
      }
      if (type === "address" && typeof value === "string" && !isAddress$3(value))
        throw new InvalidAddressError$1({ address: value });
      const bytesMatch = type.match(bytesRegex$2);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size$5(value) !== parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: parseInt(size_),
            givenSize: size$5(value)
          });
      }
      const struct3 = types2[type];
      if (struct3)
        validateData(struct3, value);
    }
  };
  if (types2.EIP712Domain && domain)
    validateData(types2.EIP712Domain, domain);
  if (primaryType !== "EIP712Domain") {
    const type = types2[primaryType];
    validateData(type, message);
  }
}
function getTypesForEIP712Domain({ domain }) {
  return [
    typeof domain?.name === "string" && { name: "name", type: "string" },
    domain?.version && { name: "version", type: "string" },
    typeof domain?.chainId === "number" && {
      name: "chainId",
      type: "uint256"
    },
    domain?.verifyingContract && {
      name: "verifyingContract",
      type: "address"
    },
    domain?.salt && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
const docsPath$6 = "/docs/contract/encodeDeployData";
function encodeDeployData$3({ abi: abi2, args, bytecode }) {
  if (!args || args.length === 0)
    return bytecode;
  const description2 = abi2.find((x2) => "type" in x2 && x2.type === "constructor");
  if (!description2)
    throw new AbiConstructorNotFoundError({ docsPath: docsPath$6 });
  if (!("inputs" in description2))
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath$6 });
  if (!description2.inputs || description2.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath$6 });
  const data2 = encodeAbiParameters$3(description2.inputs, args);
  return concatHex$1([bytecode, data2]);
}
const presignMessagePrefix$1 = "Ethereum Signed Message:\n";
function hashMessage$3(message, to_) {
  const messageBytes = (() => {
    if (typeof message === "string")
      return stringToBytes(message);
    if (message.raw instanceof Uint8Array)
      return message.raw;
    return toBytes$4(message.raw);
  })();
  const prefixBytes = stringToBytes(`${presignMessagePrefix$1}${messageBytes.length}`);
  return keccak256$3(concat$6([prefixBytes, messageBytes]), to_);
}
function formatStorageProof(storageProof) {
  return storageProof.map((proof2) => ({
    ...proof2,
    value: BigInt(proof2.value)
  }));
}
function formatProof(proof2) {
  return {
    ...proof2,
    balance: proof2.balance ? BigInt(proof2.balance) : void 0,
    nonce: proof2.nonce ? hexToNumber$1(proof2.nonce) : void 0,
    storageProof: proof2.storageProof ? formatStorageProof(proof2.storageProof) : void 0
  };
}
async function getProof$1(client2, { address: address2, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const proof2 = await client2.request({
    method: "eth_getProof",
    params: [address2, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof2);
}
async function getStorageAt$3(client2, { address: address2, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const data2 = await client2.request({
    method: "eth_getStorageAt",
    params: [address2, slot, blockNumberHex || blockTag]
  });
  return data2;
}
async function getTransaction$3(client2, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let transaction2 = null;
  if (hash2) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByHash",
      params: [hash2]
    });
  } else if (blockHash) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    });
  } else if (blockNumberHex || blockTag) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    });
  }
  if (!transaction2)
    throw new TransactionNotFoundError$1({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash2,
      index: index2
    });
  const format = client2.chain?.formatters?.transaction?.format || formatTransaction;
  return format(transaction2);
}
async function getTransactionConfirmations$3(client2, { hash: hash2, transactionReceipt: transactionReceipt2 }) {
  const [blockNumber, transaction2] = await Promise.all([
    getAction$3(client2, getBlockNumber$3, "getBlockNumber")({}),
    hash2 ? getAction$3(client2, getTransaction$3, "getBlockNumber")({ hash: hash2 }) : void 0
  ]);
  const transactionBlockNumber = transactionReceipt2?.blockNumber || transaction2?.blockNumber;
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}
async function getTransactionReceipt$3(client2, { hash: hash2 }) {
  const receipt = await client2.request({
    method: "eth_getTransactionReceipt",
    params: [hash2]
  });
  if (!receipt)
    throw new TransactionReceiptNotFoundError$1({ hash: hash2 });
  const format = client2.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt$1;
  return format(receipt);
}
async function multicall$4(client2, args) {
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts: contracts2, multicallAddress: multicallAddress_ } = args;
  const batchSize = batchSize_ ?? (typeof client2.batch?.multicall === "object" && client2.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress$3({
      blockNumber,
      chain: client2.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i2 = 0; i2 < contracts2.length; i2++) {
    const { abi: abi2, address: address2, args: args2, functionName } = contracts2[i2];
    try {
      const callData = encodeFunctionData$3({
        abi: abi2,
        args: args2,
        functionName
      });
      currentChunkSize += (callData.length - 2) / 2;
      if (
        // Check if batching is enabled.
        batchSize > 0 && // Check if the current size of the batch exceeds the size limit.
        currentChunkSize > batchSize && // Check if the current chunk is not already empty.
        chunkedCalls[currentChunk].length > 0
      ) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address2
        }
      ];
    } catch (err) {
      const error = getContractError$3(err, {
        abi: abi2,
        address: address2,
        args: args2,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address2
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction$3(client2, readContract$4, "readContract")({
    abi: multicall3Abi$1,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3"
  })));
  const results = [];
  for (let i2 = 0; i2 < aggregate3Results.length; i2++) {
    const result = aggregate3Results[i2];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j2 = 0; j2 < chunkedCalls[i2].length; j2++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: void 0
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j2 = 0; j2 < aggregate3Result.length; j2++) {
      const { returnData, success } = aggregate3Result[j2];
      const { callData } = chunkedCalls[i2][j2];
      const { abi: abi2, address: address2, functionName, args: args2 } = contracts2[results.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError();
        if (!success)
          throw new RawContractError$1({ data: returnData });
        const result2 = decodeFunctionResult$3({
          abi: abi2,
          args: args2,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err) {
        const error = getContractError$3(err, {
          abi: abi2,
          address: address2,
          args: args2,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results.push({ error, result: void 0, status: "failure" });
      }
    }
  }
  if (results.length !== contracts2.length)
    throw new BaseError$2("multicall results mismatch");
  return results;
}
const universalSignatureValidatorByteCode$1 = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$5 = BigInt(0);
const _1n$5 = BigInt(1);
const _2n$4 = BigInt(2);
const u8a$1 = (a2) => a2 instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  if (!u8a$1(bytes2))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i2 = 0; i2 < bytes2.length; i2++) {
    hex2 += hexes[bytes2[i2]];
  }
  return hex2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const len2 = hex2.length;
  if (len2 % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len2);
  const array = new Uint8Array(len2 / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j2 = i2 * 2;
    const hexByte = hex2.slice(j2, j2 + 2);
    const byte2 = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte2) || byte2 < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte2;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a$1(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n2, len2) {
  return hexToBytes(n2.toString(16).padStart(len2 * 2, "0"));
}
function numberToBytesLE(n2, len2) {
  return numberToBytesBE(n2, len2).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e2) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e2}`);
    }
  } else if (u8a$1(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len2 = res.length;
  if (typeof expectedLength === "number" && len2 !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len2}`);
  return res;
}
function concatBytes$2(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad2 = 0;
  arrays.forEach((a2) => {
    if (!u8a$1(a2))
      throw new Error("Uint8Array expected");
    r2.set(a2, pad2);
    pad2 += a2.length;
  });
  return r2;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i2 = 0; i2 < b1.length; i2++)
    if (b1[i2] !== b2[i2])
      return false;
  return true;
}
function utf8ToBytes$2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len2;
  for (len2 = 0; n2 > _0n$5; n2 >>= _1n$5, len2 += 1)
    ;
  return len2;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n$5;
}
const bitSet = (n2, pos, value) => {
  return n2 | (value ? _1n$5 : _0n$5) << BigInt(pos);
};
const bitMask = (n2) => (_2n$4 << BigInt(n2 - 1)) - _1n$5;
const u8n = (data2) => new Uint8Array(data2);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n(hashLen);
  let k2 = u8n(hashLen);
  let i2 = 0;
  const reset3 = () => {
    v2.fill(1);
    k2.fill(0);
    i2 = 0;
  };
  const h2 = (...b2) => hmacFn(k2, v2, ...b2);
  const reseed = (seed = u8n()) => {
    k2 = h2(u8fr([0]), seed);
    v2 = h2();
    if (seed.length === 0)
      return;
    k2 = h2(u8fr([1]), seed);
    v2 = h2();
  };
  const gen2 = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len2 = 0;
    const out = [];
    while (len2 < qByteLen) {
      v2 = h2();
      const sl2 = v2.slice();
      out.push(sl2);
      len2 += v2.length;
    }
    return concatBytes$2(...out);
  };
  const genUntil = (seed, pred) => {
    reset3();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset3();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
const utils$o = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes: concatBytes$2,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes: utf8ToBytes$2,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
function isBytesEqual$3(a_, b_) {
  const a2 = isHex$3(a_) ? toBytes$4(a_) : a_;
  const b2 = isHex$3(b_) ? toBytes$4(b_) : b_;
  return equalBytes(a2, b2);
}
async function verifyHash$1(client2, { address: address2, hash: hash2, signature: signature2, ...callRequest }) {
  const signatureHex = isHex$3(signature2) ? signature2 : toHex$1(signature2);
  try {
    const { data: data2 } = await getAction$3(client2, call$1, "call")({
      data: encodeDeployData$3({
        abi: universalSignatureValidatorAbi$1,
        args: [address2, hash2, signatureHex],
        bytecode: universalSignatureValidatorByteCode$1
      }),
      ...callRequest
    });
    return isBytesEqual$3(data2 ?? "0x0", "0x1");
  } catch (error) {
    if (error instanceof CallExecutionError$1) {
      return false;
    }
    throw error;
  }
}
async function verifyMessage$4(client2, { address: address2, message, signature: signature2, ...callRequest }) {
  const hash2 = hashMessage$3(message);
  return verifyHash$1(client2, {
    address: address2,
    hash: hash2,
    signature: signature2,
    ...callRequest
  });
}
async function verifyTypedData$4(client2, { address: address2, signature: signature2, message, primaryType, types: types2, domain, ...callRequest }) {
  const hash2 = hashTypedData$1({ message, primaryType, types: types2, domain });
  return verifyHash$1(client2, {
    address: address2,
    hash: hash2,
    signature: signature2,
    ...callRequest
  });
}
function watchBlockNumber$3(client2, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify$3([
      "watchBlockNumber",
      client2.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe$3(observerId, { onBlockNumber, onError }, (emit3) => poll$3(async () => {
      try {
        const blockNumber = await getAction$3(client2, getBlockNumber$3, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i2 = prevBlockNumber + 1n; i2 < blockNumber; i2++) {
              emit3.onBlockNumber(i2, prevBlockNumber);
              prevBlockNumber = i2;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit3.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        emit3.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["newHeads"],
          onData(data2) {
            if (!active)
              return;
            const blockNumber = hexToBigInt(data2.result?.number);
            onBlockNumber(blockNumber, prevBlockNumber);
            prevBlockNumber = blockNumber;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}
async function waitForTransactionReceipt$3(client2, { confirmations = 1, hash: hash2, onReplaced, pollingInterval = client2.pollingInterval, timeout }) {
  const observerId = stringify$3(["waitForTransactionReceipt", client2.uid, hash2]);
  let transaction2;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  return new Promise((resolve, reject) => {
    if (timeout)
      setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError$1({ hash: hash2 })), timeout);
    const _unobserve = observe$3(observerId, { onReplaced, resolve, reject }, (emit3) => {
      const _unwatch = getAction$3(client2, watchBlockNumber$3, "watchBlockNumber")({
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          if (retrying)
            return;
          let blockNumber = blockNumber_;
          const done = (fn) => {
            _unwatch();
            fn();
            _unobserve();
          };
          try {
            if (receipt) {
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit3.resolve(receipt));
              return;
            }
            if (!transaction2) {
              retrying = true;
              await withRetry$3(async () => {
                transaction2 = await getAction$3(client2, getTransaction$3, "getTransaction")({ hash: hash2 });
                if (transaction2.blockNumber)
                  blockNumber = transaction2.blockNumber;
              }, {
                // exponential backoff
                delay: ({ count }) => ~~(1 << count) * 200,
                retryCount: 6
              });
              retrying = false;
            }
            receipt = await getAction$3(client2, getTransactionReceipt$3, "getTransactionReceipt")({ hash: hash2 });
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit3.resolve(receipt));
          } catch (err) {
            if (transaction2 && (err instanceof TransactionNotFoundError$1 || err instanceof TransactionReceiptNotFoundError$1)) {
              try {
                replacedTransaction = transaction2;
                retrying = true;
                const block2 = await withRetry$3(() => getAction$3(client2, getBlock$3, "getBlock")({
                  blockNumber,
                  includeTransactions: true
                }), {
                  // exponential backoff
                  delay: ({ count }) => ~~(1 << count) * 200,
                  retryCount: 6,
                  shouldRetry: ({ error }) => error instanceof BlockNotFoundError$1
                });
                retrying = false;
                const replacementTransaction = block2.transactions.find(({ from: from2, nonce }) => from2 === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getAction$3(client2, getTransactionReceipt$3, "getTransactionReceipt")({
                  hash: replacementTransaction.hash
                });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  emit3.onReplaced?.({
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit3.resolve(receipt);
                });
              } catch (err_) {
                done(() => emit3.reject(err_));
              }
            } else {
              done(() => emit3.reject(err));
            }
          }
        }
      });
    });
  });
}
function watchBlocks$3(client2, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify$3([
      "watchBlocks",
      client2.uid,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe$3(observerId, { onBlock, onError }, (emit3) => poll$3(async () => {
      try {
        const block2 = await getAction$3(client2, getBlock$3, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block2.number && prevBlock?.number) {
          if (block2.number === prevBlock.number)
            return;
          if (block2.number - prevBlock.number > 1 && emitMissed) {
            for (let i2 = prevBlock?.number + 1n; i2 < block2.number; i2++) {
              const block3 = await getAction$3(client2, getBlock$3, "getBlock")({
                blockNumber: i2,
                includeTransactions
              });
              emit3.onBlock(block3, prevBlock);
              prevBlock = block3;
            }
          }
        }
        if (
          // If no previous block exists, emit.
          !prevBlock?.number || // If the block tag is "pending" with no block number, emit.
          blockTag === "pending" && !block2?.number || // If the next block number is greater than the previous block number, emit.
          // We don't want to emit blocks in the past.
          block2.number && block2.number > prevBlock.number
        ) {
          emit3.onBlock(block2, prevBlock);
          prevBlock = block2;
        }
      } catch (err) {
        emit3.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["newHeads"],
          onData(data2) {
            if (!active)
              return;
            const format = client2.chain?.formatters?.block?.format || formatBlock$1;
            const block2 = format(data2.result);
            onBlock(block2, prevBlock);
            prevBlock = block2;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}
function watchEvent$1(client2, { address: address2, args, batch: batch2 = true, event, events: events2, onError, onLogs, poll: poll_, pollingInterval = client2.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify$3([
      "watchEvent",
      address2,
      args,
      batch2,
      client2.uid,
      event,
      pollingInterval
    ]);
    return observe$3(observerId, { onLogs, onError }, (emit3) => {
      let previousBlockNumber;
      let filter2;
      let initialized = false;
      const unwatch = poll$3(async () => {
        if (!initialized) {
          try {
            filter2 = await getAction$3(client2, createEventFilter$3, "createEventFilter")({
              address: address2,
              args,
              event,
              events: events2,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getAction$3(client2, getFilterChanges$3, "getFilterChanges")({ filter: filter2 });
          } else {
            const blockNumber = await getAction$3(client2, getBlockNumber$3, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction$3(client2, getLogs$3, "getLogs")({
                address: address2,
                args,
                event,
                events: events2,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch2)
            emit3.onLogs(logs);
          else
            for (const log3 of logs)
              emit3.onLogs([log3]);
        } catch (err) {
          if (filter2 && err instanceof InvalidInputRpcError$1)
            initialized = false;
          emit3.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction$3(client2, uninstallFilter$3, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const events_ = events2 ?? (event ? [event] : void 0);
        let topics = [];
        if (events_) {
          topics = [
            events_.flatMap((event2) => encodeEventTopics$3({
              abi: [event2],
              eventName: event2.name,
              args
            }))
          ];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["logs", { address: address2, topics }],
          onData(data2) {
            if (!active)
              return;
            const log3 = data2.result;
            try {
              const { eventName, args: args2 } = decodeEventLog$3({
                abi: events_,
                data: log3.data,
                topics: log3.topics,
                strict
              });
              const formatted = formatLog$1(log3, {
                args: args2,
                eventName
              });
              onLogs([formatted]);
            } catch (err) {
              let eventName;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
              }
              const formatted = formatLog$1(log3, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}
function watchPendingTransactions$3(client2, { batch: batch2 = true, onError, onTransactions, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = stringify$3([
      "watchPendingTransactions",
      client2.uid,
      batch2,
      pollingInterval
    ]);
    return observe$3(observerId, { onTransactions, onError }, (emit3) => {
      let filter2;
      const unwatch = poll$3(async () => {
        try {
          if (!filter2) {
            try {
              filter2 = await getAction$3(client2, createPendingTransactionFilter$3, "createPendingTransactionFilter")({});
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await getAction$3(client2, getFilterChanges$3, "getFilterChanges")({ filter: filter2 });
          if (hashes.length === 0)
            return;
          if (batch2)
            emit3.onTransactions(hashes);
          else
            for (const hash2 of hashes)
              emit3.onTransactions([hash2]);
        } catch (err) {
          emit3.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction$3(client2, uninstallFilter$3, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data2) {
            if (!active)
              return;
            const transaction2 = data2.result;
            onTransactions([transaction2]);
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}
function publicActions(client2) {
  return {
    call: (args) => call$1(client2, args),
    createBlockFilter: () => createBlockFilter$3(client2),
    createContractEventFilter: (args) => createContractEventFilter$3(client2, args),
    createEventFilter: (args) => createEventFilter$3(client2, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter$3(client2),
    estimateContractGas: (args) => estimateContractGas$3(client2, args),
    estimateGas: (args) => estimateGas$3(client2, args),
    getBalance: (args) => getBalance$3(client2, args),
    getBlock: (args) => getBlock$3(client2, args),
    getBlockNumber: (args) => getBlockNumber$3(client2, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount$3(client2, args),
    getBytecode: (args) => getBytecode$3(client2, args),
    getChainId: () => getChainId$3(client2),
    getContractEvents: (args) => getContractEvents$3(client2, args),
    getEnsAddress: (args) => getEnsAddress$3(client2, args),
    getEnsAvatar: (args) => getEnsAvatar$3(client2, args),
    getEnsName: (args) => getEnsName$3(client2, args),
    getEnsResolver: (args) => getEnsResolver$3(client2, args),
    getEnsText: (args) => getEnsText$3(client2, args),
    getFeeHistory: (args) => getFeeHistory$3(client2, args),
    estimateFeesPerGas: (args) => estimateFeesPerGas$3(client2, args),
    getFilterChanges: (args) => getFilterChanges$3(client2, args),
    getFilterLogs: (args) => getFilterLogs$3(client2, args),
    getGasPrice: () => getGasPrice$3(client2),
    getLogs: (args) => getLogs$3(client2, args),
    getProof: (args) => getProof$1(client2, args),
    estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas$3(client2, args),
    getStorageAt: (args) => getStorageAt$3(client2, args),
    getTransaction: (args) => getTransaction$3(client2, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations$3(client2, args),
    getTransactionCount: (args) => getTransactionCount$3(client2, args),
    getTransactionReceipt: (args) => getTransactionReceipt$3(client2, args),
    multicall: (args) => multicall$4(client2, args),
    prepareTransactionRequest: (args) => prepareTransactionRequest$1(client2, args),
    readContract: (args) => readContract$4(client2, args),
    sendRawTransaction: (args) => sendRawTransaction$3(client2, args),
    simulateContract: (args) => simulateContract$3(client2, args),
    verifyMessage: (args) => verifyMessage$4(client2, args),
    verifyTypedData: (args) => verifyTypedData$4(client2, args),
    uninstallFilter: (args) => uninstallFilter$3(client2, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt$3(client2, args),
    watchBlocks: (args) => watchBlocks$3(client2, args),
    watchBlockNumber: (args) => watchBlockNumber$3(client2, args),
    watchContractEvent: (args) => watchContractEvent$3(client2, args),
    watchEvent: (args) => watchEvent$1(client2, args),
    watchPendingTransactions: (args) => watchPendingTransactions$3(client2, args)
  };
}
function createPublicClient$1(parameters) {
  const { key = "public", name: name2 = "Public Client" } = parameters;
  const client2 = createClient$3({
    ...parameters,
    key,
    name: name2,
    type: "publicClient"
  });
  return client2.extend(publicActions);
}
function deployContract$3(walletClient, { abi: abi2, args, bytecode, ...request2 }) {
  const calldata = encodeDeployData$3({
    abi: abi2,
    args,
    bytecode
  });
  return sendTransaction$3(walletClient, {
    ...request2,
    data: calldata
  });
}
async function getAddresses$3(client2) {
  if (client2.account?.type === "local")
    return [client2.account.address];
  const addresses = await client2.request({ method: "eth_accounts" });
  return addresses.map((address2) => checksumAddress$1(address2));
}
async function getPermissions$3(client2) {
  const permissions2 = await client2.request({ method: "wallet_getPermissions" });
  return permissions2;
}
async function requestAddresses$3(client2) {
  const addresses = await client2.request({ method: "eth_requestAccounts" });
  return addresses.map((address2) => getAddress$3(address2));
}
async function requestPermissions$3(client2, permissions2) {
  return client2.request({
    method: "wallet_requestPermissions",
    params: [permissions2]
  });
}
async function signMessage$3(client2, { account: account_ = client2.account, message }) {
  if (!account_)
    throw new AccountNotFoundError$1({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account2 = parseAccount$3(account_);
  if (account2.type === "local")
    return account2.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return stringToHex(message);
    if (message.raw instanceof Uint8Array)
      return toHex$1(message.raw);
    return message.raw;
  })();
  return client2.request({
    method: "personal_sign",
    params: [message_, account2.address]
  });
}
async function signTransaction$1(client2, args) {
  const { account: account_ = client2.account, chain: chain2 = client2.chain, ...transaction2 } = args;
  if (!account_)
    throw new AccountNotFoundError$1({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const account2 = parseAccount$3(account_);
  assertRequest$3({
    account: account2,
    ...args
  });
  const chainId = await getAction$3(client2, getChainId$3, "getChainId")({});
  if (chain2 !== null)
    assertCurrentChain$3({
      currentChainId: chainId,
      chain: chain2
    });
  const formatters = chain2?.formatters || client2.chain?.formatters;
  const format = formatters?.transactionRequest?.format || formatTransactionRequest;
  if (account2.type === "local")
    return account2.signTransaction({
      ...transaction2,
      chainId
    }, { serializer: client2.chain?.serializers?.transaction });
  return await client2.request({
    method: "eth_signTransaction",
    params: [
      {
        ...format(transaction2),
        chainId: numberToHex(chainId),
        from: account2.address
      }
    ]
  });
}
async function signTypedData$3(client2, { account: account_ = client2.account, domain, message, primaryType, types: types_ }) {
  if (!account_)
    throw new AccountNotFoundError$1({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const account2 = parseAccount$3(account_);
  const types2 = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...types_
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types: types2
  });
  if (account2.type === "local")
    return account2.signTypedData({
      domain,
      primaryType,
      types: types2,
      message
    });
  const typedData2 = stringify$3({ domain: domain ?? {}, primaryType, types: types2, message }, (_2, value) => isHex$3(value) ? value.toLowerCase() : value);
  return client2.request({
    method: "eth_signTypedData_v4",
    params: [account2.address, typedData2]
  });
}
async function switchChain$3(client2, { id: id2 }) {
  await client2.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(id2)
      }
    ]
  });
}
async function watchAsset$3(client2, params) {
  const added = await client2.request({
    method: "wallet_watchAsset",
    params
  });
  return added;
}
function walletActions(client2) {
  return {
    addChain: (args) => addChain$3(client2, args),
    deployContract: (args) => deployContract$3(client2, args),
    getAddresses: () => getAddresses$3(client2),
    getChainId: () => getChainId$3(client2),
    getPermissions: () => getPermissions$3(client2),
    prepareTransactionRequest: (args) => prepareTransactionRequest$1(client2, args),
    requestAddresses: () => requestAddresses$3(client2),
    requestPermissions: (args) => requestPermissions$3(client2, args),
    sendRawTransaction: (args) => sendRawTransaction$3(client2, args),
    sendTransaction: (args) => sendTransaction$3(client2, args),
    signMessage: (args) => signMessage$3(client2, args),
    signTransaction: (args) => signTransaction$1(client2, args),
    signTypedData: (args) => signTypedData$3(client2, args),
    switchChain: (args) => switchChain$3(client2, args),
    watchAsset: (args) => watchAsset$3(client2, args),
    writeContract: (args) => writeContract$3(client2, args)
  };
}
function createWalletClient$1(parameters) {
  const { key = "wallet", name: name2 = "Wallet Client", transport: transport2 } = parameters;
  const client2 = createClient$3({
    ...parameters,
    key,
    name: name2,
    transport: (opts) => transport2({ ...opts, retryCount: 0 }),
    type: "walletClient"
  });
  return client2.extend(walletActions);
}
function webSocket$3(url, config2 = {}) {
  const { key = "webSocket", name: name2 = "WebSocket JSON-RPC", retryDelay } = config2;
  return ({ chain: chain2, retryCount: retryCount_, timeout: timeout_ }) => {
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = url || chain2?.rpcUrls.default.webSocket?.[0];
    if (!url_)
      throw new UrlRequiredError$1();
    return createTransport$3({
      key,
      name: name2,
      async request({ method, params }) {
        const body = { method, params };
        const socket = await getSocket(url_);
        const { error, result } = await rpc$a.webSocketAsync(socket, {
          body,
          timeout
        });
        if (error)
          throw new RpcRequestError$1({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "webSocket"
    }, {
      getSocket() {
        return getSocket(url_);
      },
      async subscribe({ params, onData, onError }) {
        const socket = await getSocket(url_);
        const { result: subscriptionId } = await new Promise((resolve, reject) => rpc$a.webSocket(socket, {
          body: {
            method: "eth_subscribe",
            params
          },
          onResponse(response) {
            if (response.error) {
              reject(response.error);
              onError?.(response.error);
              return;
            }
            if (typeof response.id === "number") {
              resolve(response);
              return;
            }
            if (response.method !== "eth_subscription")
              return;
            onData(response.params);
          }
        }));
        return {
          subscriptionId,
          async unsubscribe() {
            return new Promise((resolve) => rpc$a.webSocket(socket, {
              body: {
                method: "eth_unsubscribe",
                params: [subscriptionId]
              },
              onResponse: resolve
            }));
          }
        };
      }
    });
  };
}
function number$4(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes$3(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash$5(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$4(hash2.outputLen);
  number$4(hash2.blockLen);
}
function exists$2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$1(out, instance) {
  bytes$3(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const crypto$3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a = (a2) => a2 instanceof Uint8Array;
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift) => word << 32 - shift | word >>> shift;
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$2(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes$1(data2);
  if (!u8a(data2))
    throw new Error(`expected Uint8Array, got ${typeof data2}`);
  return data2;
}
function concatBytes$1(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad2 = 0;
  arrays.forEach((a2) => {
    if (!u8a(a2))
      throw new Error("Uint8Array expected");
    r2.set(a2, pad2);
    pad2 += a2.length;
  });
  return r2;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto$3 && typeof crypto$3.getRandomValues === "function") {
    return crypto$3.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64$1(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n2 & _u32_max);
  const wl2 = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl2, isLE2);
}
let SHA2$1 = class SHA22 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data2) {
    exists$2(this);
    const { view, buffer: buffer2, blockLen } = this;
    data2 = toBytes$2(data2);
    const len2 = data2.length;
    for (let pos = 0; pos < len2; ) {
      const take2 = Math.min(blockLen - this.pos, len2 - pos);
      if (take2 === blockLen) {
        const dataView2 = createView(data2);
        for (; blockLen <= len2 - pos; pos += blockLen)
          this.process(dataView2, pos);
        continue;
      }
      buffer2.set(data2.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data2.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists$2(this);
    output$1(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer2[i2] = 0;
    setBigUint64$1(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len2 = this.outputLen;
    if (len2 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len2 / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length2, finished, destroyed, pos } = this;
    to.length = length2;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length2 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};
const Chi$1 = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
const Maj$1 = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
const SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$1 = class SHA2562 extends SHA2$1 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV$1[0] | 0;
    this.B = IV$1[1] | 0;
    this.C = IV$1[2] | 0;
    this.D = IV$1[3] | 0;
    this.E = IV$1[4] | 0;
    this.F = IV$1[5] | 0;
    this.G = IV$1[6] | 0;
    this.H = IV$1[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W$1[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W$1[i2 - 15];
      const W2 = SHA256_W$1[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W$1[i2] = s1 + SHA256_W$1[i2 - 7] + s0 + SHA256_W$1[i2 - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H2 + sigma1 + Chi$1(E2, F2, G2) + SHA256_K$1[i2] + SHA256_W$1[i2] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T2 = sigma0 + Maj$1(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
const sha256$7 = /* @__PURE__ */ wrapConstructor(() => new SHA256$1());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = BigInt(0), _1n$4 = BigInt(1), _2n$3 = BigInt(2), _3n$1 = BigInt(3);
const _4n$1 = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a2, b2) {
  const result = a2 % b2;
  return result >= _0n$4 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$4 || power < _0n$4)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$4)
    return _0n$4;
  let res = _1n$4;
  while (power > _0n$4) {
    if (power & _1n$4)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$4;
  }
  return res;
}
function pow2(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n$4) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$4 || modulo <= _0n$4) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a2 = mod(number2, modulo);
  let b2 = modulo;
  let x2 = _0n$4, u2 = _1n$4;
  while (a2 !== _0n$4) {
    const q2 = b2 / a2;
    const r2 = b2 % a2;
    const m2 = x2 - u2 * q2;
    b2 = a2, a2 = r2, x2 = u2, u2 = m2;
  }
  const gcd = b2;
  if (gcd !== _1n$4)
    throw new Error("invert: does not exist");
  return mod(x2, modulo);
}
function tonelliShanks(P2) {
  const legendreC = (P2 - _1n$4) / _2n$3;
  let Q2, S2, Z2;
  for (Q2 = P2 - _1n$4, S2 = 0; Q2 % _2n$3 === _0n$4; Q2 /= _2n$3, S2++)
    ;
  for (Z2 = _2n$3; Z2 < P2 && pow(Z2, legendreC, P2) !== P2 - _1n$4; Z2++)
    ;
  if (S2 === 1) {
    const p1div4 = (P2 + _1n$4) / _4n$1;
    return function tonelliFast(Fp2, n2) {
      const root2 = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  const Q1div2 = (Q2 + _1n$4) / _2n$3;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g2 = Fp2.pow(Fp2.mul(Fp2.ONE, Z2), Q2);
    let x2 = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q2);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m2 = 1;
      for (let t2 = Fp2.sqr(b2); m2 < r2; m2++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g2, _1n$4 << BigInt(r2 - m2 - 1));
      g2 = Fp2.sqr(ge2);
      x2 = Fp2.mul(x2, ge2);
      b2 = Fp2.mul(b2, g2);
      r2 = m2;
    }
    return x2;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n$1 === _3n$1) {
    const p1div4 = (P2 + _1n$4) / _4n$1;
    return function sqrt3mod4(Fp2, n2) {
      const root2 = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  if (P2 % _8n === _5n) {
    const c1 = (P2 - _5n) / _8n;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n$3);
      const v2 = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v2);
      const i2 = Fp2.mul(Fp2.mul(nv, _2n$3), v2);
      const root2 = Fp2.mul(nv, Fp2.sub(i2, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  return tonelliShanks(P2);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n$4)
    throw new Error("Expected power > 0");
  if (power === _0n$4)
    return f2.ONE;
  if (power === _1n$4)
    return num;
  let p2 = f2.ONE;
  let d2 = num;
  while (power > _0n$4) {
    if (power & _1n$4)
      p2 = f2.mul(p2, d2);
    d2 = f2.sqr(d2);
    power >>= _1n$4;
  }
  return p2;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (f2.is0(num))
      return acc;
    tmp[i2] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i2) => {
    if (f2.is0(num))
      return acc;
    tmp[i2] = f2.mul(acc, tmp[i2]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$4)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$4,
    ONE: _1n$4,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$4 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$4,
    isOdd: (num) => (num & _1n$4) === _1n$4,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a2, b2, c2) => c2 ? b2 : a2,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length2 = getFieldBytesLength(fieldOrder);
  return length2 + Math.ceil(length2 / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len2 = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len2 < 16 || len2 < minLen || len2 > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len2}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n$4) + _1n$4;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0);
const _1n$3 = BigInt(1);
function wNAF(c2, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W2) => {
    const windows = Math.ceil(bits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p2 = c2.ZERO;
      let d2 = elm;
      while (n2 > _0n$3) {
        if (n2 & _1n$3)
          p2 = p2.add(d2);
        d2 = d2.double();
        n2 >>= _1n$3;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = opts(W2);
      const points = [];
      let p2 = elm;
      let base3 = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base3 = p2;
        points.push(base3);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base3 = base3.add(p2);
          points.push(base3);
        }
        p2 = base3.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n2) {
      const { windows, windowSize } = opts(W2);
      let p2 = c2.ZERO;
      let f2 = c2.BASE;
      const mask = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n2 & mask);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p2, f: f2 };
    },
    wNAFCached(P2, precomputesMap, n2, transform2) {
      const W2 = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W2);
        if (W2 !== 1) {
          precomputesMap.set(P2, transform2(comp));
        }
      }
      return this.wNAF(W2, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a: a2 } = opts;
  if (endo) {
    if (!Fp2.eql(a2, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = utils$o;
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data2) {
    const { Err: E2 } = DER;
    if (data2.length < 2 || data2[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len2 = data2[1];
    const res = data2.subarray(2, len2 + 2);
    if (!len2 || res.length !== len2)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data2.subarray(len2 + 2) };
  },
  toSig(hex2) {
    const { Err: E2 } = DER;
    const data2 = typeof hex2 === "string" ? h2b(hex2) : hex2;
    if (!(data2 instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l2 = data2.length;
    if (l2 < 2 || data2[0] != 48)
      throw new E2("Invalid signature tag");
    if (data2[1] !== l2 - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r2, l: sBytes } = DER._parseInt(data2.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r: r2, s };
  },
  hexFromSig(sig) {
    const slice3 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h2 = (num) => {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s = slice3(h2(sig.s));
    const r2 = slice3(h2(sig.r));
    const shl = s.length / 2;
    const rhl = r2.length / 2;
    const sl2 = h2(shl);
    const rl2 = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl2}${r2}02${sl2}${s}`;
  }
};
const _0n$2 = BigInt(0), _1n$2 = BigInt(1), _2n$2 = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a2 = point.toAffine();
    return concatBytes$2(Uint8Array.from([4]), Fp2.toBytes(a2.x), Fp2.toBytes(a2.y));
  });
  const fromBytes2 = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y: y2 };
  });
  function weierstrassEquation(x2) {
    const { a: a2, b: b2 } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a2)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n$2 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px2, py, pz) {
      this.px = px2;
      this.py = py;
      this.pz = pz;
      if (px2 == null || !Fp2.isValid(px2))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x2, y: y2 } = p2 || {};
      if (!p2 || !Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("invalid affine point");
      if (p2 instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i2) => Fp2.eql(i2, Fp2.ZERO);
      if (is0(x2) && is0(y2))
        return Point2.ZERO;
      return new Point2(x2, y2, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P2 = Point2.fromAffine(fromBytes2(ensureBytes("pointHex", hex2)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x2, y: y2 } = this.toAffine();
      if (!Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y2);
      const right = weierstrassEquation(x2);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a2, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a2, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a2, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a2, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p2) => p2.pz));
        return comp.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I2 = Point2.ZERO;
      if (n2 === _0n$2)
        return I2;
      assertGE(n2);
      if (n2 === _1n$2)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I2;
      let k2p = I2;
      let d2 = this;
      while (k1 > _0n$2 || k2 > _0n$2) {
        if (k1 & _1n$2)
          k1p = k1p.add(d2);
        if (k2 & _1n$2)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n$2;
        k2 >>= _1n$2;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f2 } = this.wNAF(n2);
        point = p2;
        fake = f2;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a2, b2) {
      const G2 = Point2.BASE;
      const mul3 = (P2, a3) => a3 === _0n$2 || a3 === _1n$2 || !P2.equals(G2) ? P2.multiplyUnsafe(a3) : P2.multiply(a3);
      const sum = mul3(this, a2).add(mul3(Q2, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x2, py: y2, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z2);
      const ax = Fp2.mul(x2, iz);
      const ay = Fp2.mul(y2, iz);
      const zz = Fp2.mul(z2, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$2)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$2)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n$2 < num && num < Fp2.ORDER;
  }
  function modN2(a2) {
    return mod(a2, CURVE_ORDER);
  }
  function invN(a2) {
    return invert(a2, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a2 = point.toAffine();
      const x2 = Fp2.toBytes(a2.x);
      const cat = concatBytes$2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp2.toBytes(a2.y));
      }
    },
    fromBytes(bytes2) {
      const len2 = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len2 === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE(tail);
        if (!isValidFieldElement(x2))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y3 = Fp2.sqrt(y2);
        const isYOdd = (y3 & _1n$2) === _1n$2;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp2.neg(y3);
        return { x: x2, y: y3 };
      } else if (len2 === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y: y2 };
      } else {
        throw new Error(`Point of length ${len2} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$2;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b2, from2, to) => bytesToNumberBE(b2.slice(from2, to));
  class Signature {
    constructor(r2, s, recovery) {
      this.r = r2;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l2 = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l2 * 2);
      return new Signature(slcNum(hex2, 0, l2), slcNum(hex2, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r2, s } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature(r2, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h2 * ir);
      const u2 = modN2(s * ir);
      const Q2 = Point2.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length2 = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length2), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len2 = (arr || str) && item.length;
    if (arr)
      return len2 === compressedLen || len2 === uncompressedLen;
    if (str)
      return len2 === 2 * compressedLen || len2 === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point2.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN2(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n$2 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null) {
      const e2 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed = concatBytes$2(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik2 = invN(k2);
      const q2 = Point2.BASE.multiply(k2).toAffine();
      const r2 = modN2(q2.x);
      if (r2 === _0n$2)
        return;
      const s = modN2(ik2 * modN2(m2 + r2 * d2));
      if (s === _0n$2)
        return;
      let recovery = (q2.x === r2 ? 0 : 2) | Number(q2.y & _1n$2);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature2, msgHash, publicKey, opts = defaultVerOpts) {
    const sg2 = signature2;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P2;
    try {
      if (typeof sg2 === "string" || sg2 instanceof Uint8Array) {
        try {
          _sig = Signature.fromDER(sg2);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg2);
        }
      } else if (typeof sg2 === "object" && typeof sg2.r === "bigint" && typeof sg2.s === "bigint") {
        const { r: r3, s: s2 } = sg2;
        _sig = new Signature(r3, s2);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is2 = invN(s);
    const u1 = modN2(h2 * is2);
    const u2 = modN2(r2 * is2);
    const R2 = Point2.BASE.multiplyAndAddUnsafe(P2, u1, u2)?.toAffine();
    if (!R2)
      return false;
    const v2 = modN2(R2.x);
    return v2 === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils: utils2
  };
}
function SWUFpSqrtRatio(Fp2, Z2) {
  const q2 = Fp2.ORDER;
  let l2 = _0n$2;
  for (let o = q2 - _1n$2; o % _2n$2 === _0n$2; o /= _2n$2)
    l2 += _1n$2;
  const c1 = l2;
  const _2n_pow_c1_1 = _2n$2 << c1 - _1n$2 - _1n$2;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n$2;
  const c2 = (q2 - _1n$2) / _2n_pow_c1;
  const c3 = (c2 - _1n$2) / _2n$2;
  const c4 = _2n_pow_c1 - _1n$2;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp2.pow(Z2, c2);
  const c7 = Fp2.pow(Z2, (c2 + _1n$2) / _2n$2);
  let sqrtRatio = (u2, v2) => {
    let tv1 = c6;
    let tv2 = Fp2.pow(v2, c4);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v2);
    let tv5 = Fp2.mul(u2, tv3);
    tv5 = Fp2.pow(tv5, c3);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v2);
    tv3 = Fp2.mul(tv5, u2);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c5);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c7);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i2 = c1; i2 > _1n$2; i2--) {
      let tv52 = i2 - _2n$2;
      tv52 = _2n$2 << tv52 - _1n$2;
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n === _3n) {
    const c12 = (Fp2.ORDER - _3n) / _4n;
    const c22 = Fp2.sqrt(Fp2.neg(Z2));
    sqrtRatio = (u2, v2) => {
      let tv1 = Fp2.sqr(v2);
      const tv2 = Fp2.mul(u2, v2);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y2 = Fp2.mul(y1, c22);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v2);
      const isQR = Fp2.eql(tv3, u2);
      let y3 = Fp2.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y3 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
  if (!Fp2.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u2) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x2, y2;
    tv1 = Fp2.sqr(u2);
    tv1 = Fp2.mul(tv1, opts.Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, opts.B);
    tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, opts.A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, opts.A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, opts.B);
    tv2 = Fp2.add(tv2, tv5);
    x2 = Fp2.mul(tv1, tv3);
    const { isValid: isValid3, value } = sqrtRatio(tv2, tv6);
    y2 = Fp2.mul(tv1, u2);
    y2 = Fp2.mul(y2, value);
    x2 = Fp2.cmov(x2, tv3, isValid3);
    y2 = Fp2.cmov(y2, value, isValid3);
    const e1 = Fp2.isOdd(u2) === Fp2.isOdd(y2);
    y2 = Fp2.cmov(Fp2.neg(y2), y2, e1);
    x2 = Fp2.div(x2, tv4);
    return { x: x2, y: y2 };
  };
}
function validateDST(dst) {
  if (dst instanceof Uint8Array)
    return dst;
  if (typeof dst === "string")
    return utf8ToBytes$2(dst);
  throw new Error("DST must be Uint8Array or string");
}
const os2ip = bytesToNumberBE;
function i2osp(value, length2) {
  if (value < 0 || value >= 1 << 8 * length2) {
    throw new Error(`bad I2OSP call: value=${value} length=${length2}`);
  }
  const res = Array.from({ length: length2 }).fill(0);
  for (let i2 = length2 - 1; i2 >= 0; i2--) {
    res[i2] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a2, b2) {
  const arr = new Uint8Array(a2.length);
  for (let i2 = 0; i2 < a2.length; i2++) {
    arr[i2] = a2[i2] ^ b2[i2];
  }
  return arr;
}
function isBytes$5(item) {
  if (!(item instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function isNum$1(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H2) {
  isBytes$5(msg);
  isBytes$5(DST);
  isNum$1(lenInBytes);
  if (DST.length > 255)
    DST = H2(concatBytes$2(utf8ToBytes$2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H2;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes$2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b2 = new Array(ell);
  const b_0 = H2(concatBytes$2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b2[0] = H2(concatBytes$2(b_0, i2osp(1, 1), DST_prime));
  for (let i2 = 1; i2 <= ell; i2++) {
    const args = [strxor(b_0, b2[i2 - 1]), i2osp(i2 + 1, 1), DST_prime];
    b2[i2] = H2(concatBytes$2(...args));
  }
  const pseudo_random_bytes = concatBytes$2(...b2);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k2, H2) {
  isBytes$5(msg);
  isBytes$5(DST);
  isNum$1(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k2 / 8);
    DST = H2.create({ dkLen }).update(utf8ToBytes$2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H2.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: p2, k: k2, m: m2, hash: hash2, expand, DST: _DST } = options;
  isBytes$5(msg);
  isNum$1(count);
  const DST = validateDST(_DST);
  const log2p = p2.toString(2).length;
  const L2 = Math.ceil((log2p + k2) / 8);
  const len_in_bytes = count * m2 * L2;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k2, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u2 = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const e2 = new Array(m2);
    for (let j2 = 0; j2 < m2; j2++) {
      const elm_offset = L2 * (j2 + i2 * m2);
      const tv = prb.subarray(elm_offset, elm_offset + L2);
      e2[j2] = mod(os2ip(tv), p2);
    }
    u2[i2] = e2;
  }
  return u2;
}
function isogenyMap(field, map2) {
  const COEFF = map2.map((i2) => Array.from(i2).reverse());
  return (x2, y2) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x2), i2)));
    x2 = field.div(xNum, xDen);
    y2 = field.mul(y2, field.div(yNum, yDen));
    return { x: x2, y: y2 };
  };
}
function createHasher(Point2, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u2 = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point2.fromAffine(mapToCurve(u2[0]));
      const u1 = Point2.fromAffine(mapToCurve(u2[1]));
      const P2 = u0.add(u1).clearCofactor();
      P2.assertValidity();
      return P2;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u2 = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P2 = Point2.fromAffine(mapToCurve(u2[0])).clearCofactor();
      P2.assertValidity();
      return P2;
    }
  };
}
let HMAC$1 = class HMAC2 extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash$5(hash2);
    const key = toBytes$2(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash2.create();
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf2) {
    exists$2(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    exists$2(this);
    bytes$3(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
const hmac$3 = (hash2, key, message) => new HMAC$1(hash2, key).update(message).digest();
hmac$3.create = (hash2, key) => new HMAC$1(hash2, key);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac$3(hash2, key, concatBytes$1(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create5 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create5(defHash), create: create5 });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n$1 = BigInt(1);
const _2n$1 = BigInt(2);
const divNearest = (a2, b2) => (a2 + b2 / _2n$1) / b2;
function sqrtMod(y2) {
  const P2 = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P2;
  const b3 = b2 * b2 * y2 % P2;
  const b6 = pow2(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2(b9, _2n$1, P2) * b2 % P2;
  const b22 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2(t1, _6n, P2) * b2 % P2;
  const root2 = pow2(t2, _2n$1, P2);
  if (!Fp.eql(Fp.sqr(root2), y2))
    throw new Error("Cannot find square root");
  return root2;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n$1 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k2, n2);
      const c2 = divNearest(-b1 * k2, n2);
      let k1 = mod(k2 - c1 * a1 - c2 * a2, n2);
      let k22 = mod(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k22 = n2 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256$7);
const _0n$1 = BigInt(0);
const fe$1 = (x2) => typeof x2 === "bigint" && _0n$1 < x2 && x2 < secp256k1P;
const ge$1 = (x2) => typeof x2 === "bigint" && _0n$1 < x2 && x2 < secp256k1N;
const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256$7(Uint8Array.from(tag, (c2) => c2.charCodeAt(0)));
    tagP = concatBytes$2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256$7(concatBytes$2(tagP, ...messages));
}
const pointToBytes = (point) => point.toRawBytes(true).slice(1);
const numTo32b = (n2) => numberToBytesBE(n2, 32);
const modP = (x2) => mod(x2, secp256k1P);
const modN = (x2) => mod(x2, secp256k1N);
const Point = secp256k1.ProjectivePoint;
const GmulAdd = (Q2, a2, b2) => Point.BASE.multiplyAndAddUnsafe(Q2, a2, b2);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p2 = Point.fromPrivateKey(d_);
  const scalar = p2.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p2) };
}
function lift_x(x2) {
  if (!fe$1(x2))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x2 * x2);
  const c2 = modP(xx * x2 + BigInt(7));
  let y2 = sqrtMod(c2);
  if (y2 % _2n$1 !== _0n$1)
    y2 = modP(-y2);
  const p2 = new Point(x2, y2, _1n$1);
  p2.assertValidity();
  return p2;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m2 = ensureBytes("message", message);
  const { bytes: px2, scalar: d2 } = schnorrGetExtPubKey(privateKey);
  const a2 = ensureBytes("auxRand", auxRand, 32);
  const t2 = numTo32b(d2 ^ bytesToNumberBE(taggedHash("BIP0340/aux", a2)));
  const rand = taggedHash("BIP0340/nonce", t2, px2, m2);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n$1)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k2 } = schnorrGetExtPubKey(k_);
  const e2 = challenge(rx, px2, m2);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k2 + e2 * d2)), 32);
  if (!schnorrVerify(sig, m2, px2))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature2, message, publicKey) {
  const sig = ensureBytes("signature", signature2, 64);
  const m2 = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P2 = lift_x(bytesToNumberBE(pub));
    const r2 = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe$1(r2))
      return false;
    const s = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge$1(s))
      return false;
    const e2 = challenge(numTo32b(r2), pointToBytes(P2), m2);
    const R2 = GmulAdd(P2, s, modN(-e2));
    if (!R2 || !R2.hasEvenY() || R2.toAffine().x !== r2)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
const schnorr = /* @__PURE__ */ (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
const isoMap = /* @__PURE__ */ (() => isogenyMap(Fp, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i2) => i2.map((j2) => BigInt(j2)))))();
const mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
}))();
const htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x: x2, y: y2 } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x2, y2);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256$7
}))();
const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();
const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();
const secp256k1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  encodeToCurve,
  hashToCurve,
  schnorr,
  secp256k1
}, Symbol.toStringTag, { value: "Module" }));
const goerli = /* @__PURE__ */ defineChain$3({
  id: 5,
  network: "goerli",
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://eth-goerli.g.alchemy.com/v2"],
      webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://goerli.infura.io/v3"],
      webSocket: ["wss://goerli.infura.io/ws/v3"]
    },
    default: {
      http: ["https://rpc.ankr.com/eth_goerli"]
    },
    public: {
      http: ["https://rpc.ankr.com/eth_goerli"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0x56522D00C410a43BFfDF00a9A569489297385790",
      blockCreated: 8765204
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: true
});
const gnosis = /* @__PURE__ */ defineChain$3({
  id: 100,
  name: "Gnosis",
  network: "gnosis",
  nativeCurrency: {
    decimals: 18,
    name: "Gnosis",
    symbol: "xDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gnosischain.com"],
      webSocket: ["wss://rpc.gnosischain.com/wss"]
    },
    public: {
      http: ["https://rpc.gnosischain.com"],
      webSocket: ["wss://rpc.gnosischain.com/wss"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Gnosisscan",
      url: "https://gnosisscan.io"
    },
    default: {
      name: "Gnosis Chain Explorer",
      url: "https://blockscout.com/xdai/mainnet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 21022491
    }
  }
});
const localhost = /* @__PURE__ */ defineChain$3({
  id: 1337,
  name: "Localhost",
  network: "localhost",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] },
    public: { http: ["http://127.0.0.1:8545"] }
  }
});
const mainnet = /* @__PURE__ */ defineChain$3({
  id: 1,
  network: "homestead",
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://eth-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://mainnet.infura.io/v3"],
      webSocket: ["wss://mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://cloudflare-eth.com"]
    },
    public: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://etherscan.io"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
      blockCreated: 16966585
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
const optimism = /* @__PURE__ */ defineChain$3({
  id: 10,
  name: "OP Mainnet",
  network: "optimism",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://opt-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://opt-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://optimism-mainnet.infura.io/v3"],
      webSocket: ["wss://optimism-mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://mainnet.optimism.io"]
    },
    public: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://optimistic.etherscan.io"
    },
    default: {
      name: "Optimism Explorer",
      url: "https://explorer.optimism.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    }
  }
}, {
  formatters: formattersOptimism
});
const polygon = /* @__PURE__ */ defineChain$3({
  id: 137,
  name: "Polygon",
  network: "matic",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://polygon-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://polygon-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://polygon-mainnet.infura.io/v3"],
      webSocket: ["wss://polygon-mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://polygon-rpc.com"]
    },
    public: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "PolygonScan",
      url: "https://polygonscan.com"
    },
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});
const polygonMumbai = /* @__PURE__ */ defineChain$3({
  id: 80001,
  name: "Polygon Mumbai",
  network: "maticmum",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://polygon-mumbai.g.alchemy.com/v2"],
      webSocket: ["wss://polygon-mumbai.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://polygon-mumbai.infura.io/v3"],
      webSocket: ["wss://polygon-mumbai.infura.io/ws/v3"]
    },
    default: {
      http: ["https://rpc.ankr.com/polygon_mumbai"]
    },
    public: {
      http: ["https://rpc.ankr.com/polygon_mumbai"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com"
    },
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: true
});
var ChainNotConfiguredForConnectorError = class extends Error {
  constructor({
    chainId,
    connectorId
  }) {
    super(`Chain "${chainId}" not configured for connector "${connectorId}".`);
    this.name = "ChainNotConfiguredForConnectorError";
  }
};
var ConnectorNotFoundError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConnectorNotFoundError";
    this.message = "Connector not found";
  }
};
function normalizeChainId(chainId) {
  if (typeof chainId === "string")
    return Number.parseInt(
      chainId,
      chainId.trim().substring(0, 2) === "0x" ? 16 : 10
    );
  if (typeof chainId === "bigint")
    return Number(chainId);
  return chainId;
}
var eventemitter3 = { exports: {} };
(function(module2) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once3) {
    this.fn = fn;
    this.context = context;
    this.once = once3 || false;
  }
  function addListener2(emitter, event, fn, context, once3) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once3), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names2 = [], events2, name2;
    if (this._eventsCount === 0)
      return names2;
    for (name2 in events2 = this._events) {
      if (has.call(events2, name2))
        names2.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events2));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
      ee2[i2] = handlers[i2].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit3(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len2 = arguments.length, args, i2;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len2) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len2 - 1); i2 < len2; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length2 = listeners2.length, j2;
      for (i2 = 0; i2 < length2; i2++) {
        if (listeners2[i2].once)
          this.removeListener(event, listeners2[i2].fn, void 0, true);
        switch (len2) {
          case 1:
            listeners2[i2].fn.call(listeners2[i2].context);
            break;
          case 2:
            listeners2[i2].fn.call(listeners2[i2].context, a1);
            break;
          case 3:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2);
            break;
          case 4:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len2 - 1); j2 < len2; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners2[i2].fn.apply(listeners2[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn, context) {
    return addListener2(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once3(event, fn, context) {
    return addListener2(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once3) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once3 || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events2 = [], length2 = listeners2.length; i2 < length2; i2++) {
        if (listeners2[i2].fn !== fn || once3 && !listeners2[i2].once || context && listeners2[i2].context !== context) {
          events2.push(listeners2[i2]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter$3 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var __accessCheck$1 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$1(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$1(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$1 = (obj, member, method) => {
  __accessCheck$1(obj, member, "access private method");
  return method;
};
var Connector = class extends EventEmitter$3 {
  constructor({
    chains: chains2 = [mainnet, goerli],
    options
  }) {
    super();
    this.chains = chains2;
    this.options = options;
  }
  getBlockExplorerUrls(chain2) {
    const { default: blockExplorer, ...blockExplorers } = chain2.blockExplorers ?? {};
    if (blockExplorer)
      return [
        blockExplorer.url,
        ...Object.values(blockExplorers).map((x2) => x2.url)
      ];
  }
  isChainUnsupported(chainId) {
    return !this.chains.some((x2) => x2.id === chainId);
  }
  setStorage(storage) {
    this.storage = storage;
  }
};
function getInjectedName(ethereum) {
  if (!ethereum)
    return "Injected";
  const getName = (provider2) => {
    if (provider2.isApexWallet)
      return "Apex Wallet";
    if (provider2.isAvalanche)
      return "Core Wallet";
    if (provider2.isBackpack)
      return "Backpack";
    if (provider2.isBifrost)
      return "Bifrost Wallet";
    if (provider2.isBitKeep)
      return "BitKeep";
    if (provider2.isBitski)
      return "Bitski";
    if (provider2.isBlockWallet)
      return "BlockWallet";
    if (provider2.isBraveWallet)
      return "Brave Wallet";
    if (provider2.isCoin98)
      return "Coin98 Wallet";
    if (provider2.isCoinbaseWallet)
      return "Coinbase Wallet";
    if (provider2.isDawn)
      return "Dawn Wallet";
    if (provider2.isDefiant)
      return "Defiant";
    if (provider2.isDesig)
      return "Desig Wallet";
    if (provider2.isEnkrypt)
      return "Enkrypt";
    if (provider2.isExodus)
      return "Exodus";
    if (provider2.isFordefi)
      return "Fordefi";
    if (provider2.isFrame)
      return "Frame";
    if (provider2.isFrontier)
      return "Frontier Wallet";
    if (provider2.isGamestop)
      return "GameStop Wallet";
    if (provider2.isHaqqWallet)
      return "HAQQ Wallet";
    if (provider2.isHyperPay)
      return "HyperPay Wallet";
    if (provider2.isImToken)
      return "ImToken";
    if (provider2.isHaloWallet)
      return "Halo Wallet";
    if (provider2.isKuCoinWallet)
      return "KuCoin Wallet";
    if (provider2.isMathWallet)
      return "MathWallet";
    if (provider2.isNovaWallet)
      return "Nova Wallet";
    if (provider2.isOkxWallet || provider2.isOKExWallet)
      return "OKX Wallet";
    if (provider2.isOktoWallet)
      return "Okto Wallet";
    if (provider2.isOneInchIOSWallet || provider2.isOneInchAndroidWallet)
      return "1inch Wallet";
    if (provider2.isOneKey)
      return "OneKey Wallet";
    if (provider2.isOpera)
      return "Opera";
    if (provider2.isPhantom)
      return "Phantom";
    if (provider2.isPortal)
      return "Ripio Portal";
    if (provider2.isRabby)
      return "Rabby Wallet";
    if (provider2.isRainbow)
      return "Rainbow";
    if (provider2.isSafePal)
      return "SafePal Wallet";
    if (provider2.isStatus)
      return "Status";
    if (provider2.isSubWallet)
      return "SubWallet";
    if (provider2.isTalisman)
      return "Talisman";
    if (provider2.isTally)
      return "Taho";
    if (provider2.isTokenPocket)
      return "TokenPocket";
    if (provider2.isTokenary)
      return "Tokenary";
    if (provider2.isTrust || provider2.isTrustWallet)
      return "Trust Wallet";
    if (provider2.isTTWallet)
      return "TTWallet";
    if (provider2.isXDEFI)
      return "XDEFI Wallet";
    if (provider2.isZeal)
      return "Zeal";
    if (provider2.isZerion)
      return "Zerion";
    if (provider2.isMetaMask)
      return "MetaMask";
  };
  if (ethereum.providers?.length) {
    const nameSet = /* @__PURE__ */ new Set();
    let unknownCount = 1;
    for (const provider2 of ethereum.providers) {
      let name2 = getName(provider2);
      if (!name2) {
        name2 = `Unknown Wallet #${unknownCount}`;
        unknownCount += 1;
      }
      nameSet.add(name2);
    }
    const names2 = [...nameSet];
    if (names2.length)
      return names2;
    return names2[0] ?? "Injected";
  }
  return getName(ethereum) ?? "Injected";
}
var _provider$4;
var InjectedConnector = class extends Connector {
  constructor({
    chains: chains2,
    options: options_
  } = {}) {
    const options = {
      shimDisconnect: true,
      getProvider() {
        if (typeof window === "undefined")
          return;
        const ethereum = window.ethereum;
        if (ethereum?.providers && ethereum.providers.length > 0)
          return ethereum.providers[0];
        return ethereum;
      },
      ...options_
    };
    super({ chains: chains2, options });
    this.id = "injected";
    __privateAdd$1(this, _provider$4, void 0);
    this.shimDisconnectKey = `${this.id}.shimDisconnect`;
    this.onAccountsChanged = (accounts2) => {
      if (accounts2.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: getAddress$3(accounts2[0])
        });
    };
    this.onChainChanged = (chainId) => {
      const id2 = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", { chain: { id: id2, unsupported } });
    };
    this.onDisconnect = async (error) => {
      if (error.code === 1013) {
        const provider3 = await this.getProvider();
        if (provider3) {
          const isAuthorized = await this.getAccount();
          if (isAuthorized)
            return;
        }
      }
      this.emit("disconnect");
      if (this.options.shimDisconnect)
        this.storage?.removeItem(this.shimDisconnectKey);
    };
    const provider2 = options.getProvider();
    if (typeof options.name === "string")
      this.name = options.name;
    else if (provider2) {
      const detectedName = getInjectedName(provider2);
      if (options.name)
        this.name = options.name(detectedName);
      else {
        if (typeof detectedName === "string")
          this.name = detectedName;
        else
          this.name = detectedName[0];
      }
    } else
      this.name = "Injected";
    this.ready = !!provider2;
  }
  async connect({ chainId } = {}) {
    try {
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ConnectorNotFoundError();
      if (provider2.on) {
        provider2.on("accountsChanged", this.onAccountsChanged);
        provider2.on("chainChanged", this.onChainChanged);
        provider2.on("disconnect", this.onDisconnect);
      }
      this.emit("message", { type: "connecting" });
      const accounts2 = await provider2.request({
        method: "eth_requestAccounts"
      });
      const account2 = getAddress$3(accounts2[0]);
      let id2 = await this.getChainId();
      let unsupported = this.isChainUnsupported(id2);
      if (chainId && id2 !== chainId) {
        const chain2 = await this.switchChain(chainId);
        id2 = chain2.id;
        unsupported = this.isChainUnsupported(id2);
      }
      if (this.options.shimDisconnect)
        this.storage?.setItem(this.shimDisconnectKey, true);
      return { account: account2, chain: { id: id2, unsupported } };
    } catch (error) {
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError$1(error);
      if (error.code === -32002)
        throw new ResourceUnavailableRpcError$1(error);
      throw error;
    }
  }
  async disconnect() {
    const provider2 = await this.getProvider();
    if (!provider2?.removeListener)
      return;
    provider2.removeListener("accountsChanged", this.onAccountsChanged);
    provider2.removeListener("chainChanged", this.onChainChanged);
    provider2.removeListener("disconnect", this.onDisconnect);
    if (this.options.shimDisconnect)
      this.storage?.removeItem(this.shimDisconnectKey);
  }
  async getAccount() {
    const provider2 = await this.getProvider();
    if (!provider2)
      throw new ConnectorNotFoundError();
    const accounts2 = await provider2.request({
      method: "eth_accounts"
    });
    return getAddress$3(accounts2[0]);
  }
  async getChainId() {
    const provider2 = await this.getProvider();
    if (!provider2)
      throw new ConnectorNotFoundError();
    return provider2.request({ method: "eth_chainId" }).then(normalizeChainId);
  }
  async getProvider() {
    const provider2 = this.options.getProvider();
    if (provider2)
      __privateSet$1(this, _provider$4, provider2);
    return __privateGet$1(this, _provider$4);
  }
  async getWalletClient({
    chainId
  } = {}) {
    const [provider2, account2] = await Promise.all([
      this.getProvider(),
      this.getAccount()
    ]);
    const chain2 = this.chains.find((x2) => x2.id === chainId);
    if (!provider2)
      throw new Error("provider is required.");
    return createWalletClient$1({
      account: account2,
      chain: chain2,
      transport: custom$3(provider2)
    });
  }
  async isAuthorized() {
    try {
      if (this.options.shimDisconnect && !this.storage?.getItem(this.shimDisconnectKey))
        return false;
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ConnectorNotFoundError();
      const account2 = await this.getAccount();
      return !!account2;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    const provider2 = await this.getProvider();
    if (!provider2)
      throw new ConnectorNotFoundError();
    const id2 = numberToHex(chainId);
    try {
      await Promise.all([
        provider2.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: id2 }]
        }),
        new Promise(
          (res) => this.on("change", ({ chain: chain2 }) => {
            if (chain2?.id === chainId)
              res();
          })
        )
      ]);
      return this.chains.find((x2) => x2.id === chainId) ?? {
        id: chainId,
        name: `Chain ${id2}`,
        network: `${id2}`,
        nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
        rpcUrls: { default: { http: [""] }, public: { http: [""] } }
      };
    } catch (error) {
      const chain2 = this.chains.find((x2) => x2.id === chainId);
      if (!chain2)
        throw new ChainNotConfiguredForConnectorError({
          chainId,
          connectorId: this.id
        });
      if (error.code === 4902 || error?.data?.originalError?.code === 4902) {
        try {
          await provider2.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: id2,
                chainName: chain2.name,
                nativeCurrency: chain2.nativeCurrency,
                rpcUrls: [chain2.rpcUrls.public?.http[0] ?? ""],
                blockExplorerUrls: this.getBlockExplorerUrls(chain2)
              }
            ]
          });
          const currentChainId = await this.getChainId();
          if (currentChainId !== chainId)
            throw new UserRejectedRequestError$1(
              new Error("User rejected switch after adding network.")
            );
          return chain2;
        } catch (error2) {
          throw new UserRejectedRequestError$1(error2);
        }
      }
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError$1(error);
      throw new SwitchChainError$1(error);
    }
  }
  async watchAsset({
    address: address2,
    decimals = 18,
    image,
    symbol: symbol2
  }) {
    const provider2 = await this.getProvider();
    if (!provider2)
      throw new ConnectorNotFoundError();
    return provider2.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address: address2,
          decimals,
          image,
          symbol: symbol2
        }
      }
    });
  }
  isUserRejectedRequestError(error) {
    return error.code === 4001;
  }
};
_provider$4 = /* @__PURE__ */ new WeakMap();
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
const subscribeWithSelectorImpl = (fn) => (set, get3, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get3, api);
  return initialState;
};
const subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e2) {
    return;
  }
  const persistStorage = {
    getItem: (name2) => {
      var _a2;
      const parse2 = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, options == null ? void 0 : options.reviver);
      };
      const str = (_a2 = storage.getItem(name2)) != null ? _a2 : null;
      if (str instanceof Promise) {
        return str.then(parse2);
      }
      return parse2(str);
    },
    setItem: (name2, newValue) => storage.setItem(
      name2,
      JSON.stringify(newValue, options == null ? void 0 : options.replacer)
    ),
    removeItem: (name2) => storage.removeItem(name2)
  };
  return persistStorage;
}
const toThenable = (fn) => (input) => {
  try {
    const result = fn(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e2) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e2);
      }
    };
  }
};
const oldImpl = (config2, baseOptions) => (set, get3, api) => {
  let options = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (e2) {
  }
  if (!storage) {
    return config2(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get3,
      api
    );
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state = options.partialize({ ...get3() });
    let errorInSync;
    const thenable = thenableSerialize({ state, version: options.version }).then(
      (serializedValue) => storage.setItem(options.name, serializedValue)
    ).catch((e2) => {
      errorInSync = e2;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config2(
    (...args) => {
      set(...args);
      void setItem();
    },
    get3,
    api
  );
  let stateFromStorage;
  const hydrate2 = () => {
    var _a2;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => cb2(get3()));
    const postRehydrationCallback = ((_a2 = options.onRehydrateStorage) == null ? void 0 : _a2.call(options, get3())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a22;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get3()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate2(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  hydrate2();
  return stateFromStorage || configResult;
};
const newImpl = (config2, baseOptions) => (set, get3, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config2(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get3,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get3() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config2(
    (...args) => {
      set(...args);
      void setItem();
    },
    get3,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate2 = () => {
    var _a2, _b;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => {
      var _a22;
      return cb2((_a22 = get3()) != null ? _a22 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a2 = get3()) != null ? _a2 : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a22;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get3()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get3();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate2(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate2();
  }
  return stateFromStorage || configResult;
};
const persistImpl = (config2, baseOptions) => {
  if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
    if (({ "VITE_CHAIN_NAME": "optimisticEthereum", "VITE_process.env.NODE_DEBUG": "", "VITE_RAW_global.WebSocket": "window.WebSocket", "VITE_INFURA_ID": "781d8466252d47508e177b8637b1c2fd", "VITE_ALCHEMY_ID": "ACDn1Kz28R_1VPRp44aW2zf85imtUyey", "VITE_IPFS_AUTH_USERNAME": "1xds8y1D4cqT4rt77cC1jBLOrQk", "VITE_IPFS_AUTH_PASSWORD": "858749f19398b5ae89787172852c179b", "VITE_WALLET_CONNECT_PROJECT_ID": "806b7118ca48eec75f6cf7981bfca00d", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
      );
    }
    return oldImpl(config2, baseOptions);
  }
  return newImpl(config2, baseOptions);
};
const persist$1 = persistImpl;
const createStoreImpl = (createState2) => {
  let state;
  const listeners2 = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners2.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners2.add(listener);
    return () => listeners2.delete(listener);
  };
  const destroy = () => {
    if (({ "VITE_CHAIN_NAME": "optimisticEthereum", "VITE_process.env.NODE_DEBUG": "", "VITE_RAW_global.WebSocket": "window.WebSocket", "VITE_INFURA_ID": "781d8466252d47508e177b8637b1c2fd", "VITE_ALCHEMY_ID": "ACDn1Kz28R_1VPRp44aW2zf85imtUyey", "VITE_IPFS_AUTH_USERNAME": "1xds8y1D4cqT4rt77cC1jBLOrQk", "VITE_IPFS_AUTH_PASSWORD": "858749f19398b5ae89787172852c179b", "VITE_WALLET_CONNECT_PROJECT_ID": "806b7118ca48eec75f6cf7981bfca00d", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners2.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState2(setState, getState, api);
  return api;
};
const createStore$1 = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;
function shallow$1(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size)
      return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size)
      return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i2 = 0; i2 < keysA.length; i2++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !Object.is(objA[keysA[i2]], objB[keysA[i2]])) {
      return false;
    }
  }
  return true;
}
function configureChains(defaultChains2, providers, {
  batch: batch2 = { multicall: { wait: 32 } },
  pollingInterval = 4e3,
  rank,
  retryCount,
  retryDelay,
  stallTimeout
} = {}) {
  if (!defaultChains2.length)
    throw new Error("must have at least one chain");
  let chains2 = [];
  const httpUrls = {};
  const wsUrls = {};
  for (const chain2 of defaultChains2) {
    let configExists = false;
    for (const provider2 of providers) {
      const apiConfig = provider2(chain2);
      if (!apiConfig)
        continue;
      configExists = true;
      if (!chains2.some(({ id: id2 }) => id2 === chain2.id)) {
        chains2 = [...chains2, apiConfig.chain];
      }
      httpUrls[chain2.id] = [
        ...httpUrls[chain2.id] || [],
        ...apiConfig.rpcUrls.http
      ];
      if (apiConfig.rpcUrls.webSocket) {
        wsUrls[chain2.id] = [
          ...wsUrls[chain2.id] || [],
          ...apiConfig.rpcUrls.webSocket
        ];
      }
    }
    if (!configExists) {
      throw new Error(
        [
          `Could not find valid provider configuration for chain "${chain2.name}".
`,
          "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.",
          "Read more: https://wagmi.sh/core/providers/jsonRpc"
        ].join("\n")
      );
    }
  }
  return {
    chains: chains2,
    publicClient: ({ chainId }) => {
      const activeChain = chains2.find((x2) => x2.id === chainId) ?? defaultChains2[0];
      const chainHttpUrls = httpUrls[activeChain.id];
      if (!chainHttpUrls || !chainHttpUrls[0])
        throw new Error(`No providers configured for chain "${activeChain.id}"`);
      const publicClient = createPublicClient$1({
        batch: batch2,
        chain: activeChain,
        transport: fallback$3(
          chainHttpUrls.map((url) => http$3(url, { timeout: stallTimeout })),
          { rank, retryCount, retryDelay }
        ),
        pollingInterval
      });
      return Object.assign(publicClient, {
        chains: chains2
      });
    },
    webSocketPublicClient: ({ chainId }) => {
      const activeChain = chains2.find((x2) => x2.id === chainId) ?? defaultChains2[0];
      const chainWsUrls = wsUrls[activeChain.id];
      if (!chainWsUrls || !chainWsUrls[0])
        return void 0;
      const publicClient = createPublicClient$1({
        batch: batch2,
        chain: activeChain,
        transport: fallback$3(
          chainWsUrls.map((url) => webSocket$3(url, { timeout: stallTimeout })),
          { rank, retryCount, retryDelay }
        ),
        pollingInterval
      });
      return Object.assign(publicClient, {
        chains: chains2
      });
    }
  };
}
var ChainNotConfiguredError = class extends Error {
  constructor({
    chainId,
    connectorId
  }) {
    super(
      `Chain "${chainId}" not configured${connectorId ? ` for connector "${connectorId}"` : ""}.`
    );
    this.name = "ChainNotConfigured";
  }
};
var ConnectorAlreadyConnectedError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConnectorAlreadyConnectedError";
    this.message = "Connector already connected";
  }
};
var ConfigChainsNotFound = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConfigChainsNotFound";
    this.message = "No chains were found on the wagmi config. Some functions that require a chain may not work.";
  }
};
var SwitchChainNotSupportedError = class extends Error {
  constructor({ connector }) {
    super(`"${connector.name}" does not support programmatic chain switching.`);
    this.name = "SwitchChainNotSupportedError";
  }
};
function deepEqual(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    let length2;
    let i2;
    if (Array.isArray(a2) && Array.isArray(b2)) {
      length2 = a2.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!deepEqual(a2[i2], b2[i2]))
          return false;
      return true;
    }
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    const keys2 = Object.keys(a2);
    length2 = keys2.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i2 = length2; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
        return false;
    for (i2 = length2; i2-- !== 0; ) {
      const key = keys2[i2];
      if (key && !deepEqual(a2[key], b2[key]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
var findAndReplace = (cacheRef, {
  find,
  replace
}) => {
  if (cacheRef && find(cacheRef)) {
    return replace(cacheRef);
  }
  if (typeof cacheRef !== "object") {
    return cacheRef;
  }
  if (Array.isArray(cacheRef)) {
    return cacheRef.map((item) => findAndReplace(item, { find, replace }));
  }
  if (cacheRef instanceof Object) {
    return Object.entries(cacheRef).reduce(
      (curr, [key, value]) => ({
        ...curr,
        [key]: findAndReplace(value, { find, replace })
      }),
      {}
    );
  }
  return cacheRef;
};
function deserialize(cachedString) {
  const cache2 = JSON.parse(cachedString);
  const deserializedCacheWithBigInts = findAndReplace(cache2, {
    find: (data2) => typeof data2 === "string" && data2.startsWith("#bigint."),
    replace: (data2) => BigInt(data2.replace("#bigint.", ""))
  });
  return deserializedCacheWithBigInts;
}
function getUnit(unit2) {
  if (typeof unit2 === "number")
    return unit2;
  if (unit2 === "wei")
    return 0;
  return Math.abs(weiUnits$1[unit2]);
}
function getReferenceKey(keys2, cutoff) {
  return keys2.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
  const { length: length2 } = array;
  for (let index2 = 0; index2 < length2; ++index2) {
    if (array[index2] === value) {
      return index2 + 1;
    }
  }
  return 0;
}
function createReplacer(replacer, circularReplacer) {
  const hasReplacer = typeof replacer === "function";
  const hasCircularReplacer = typeof circularReplacer === "function";
  const cache2 = [];
  const keys2 = [];
  return function replace(key, value) {
    if (typeof value === "object") {
      if (cache2.length) {
        const thisCutoff = getCutoff(cache2, this);
        if (thisCutoff === 0) {
          cache2[cache2.length] = this;
        } else {
          cache2.splice(thisCutoff);
          keys2.splice(thisCutoff);
        }
        keys2[keys2.length] = key;
        const valueCutoff = getCutoff(cache2, value);
        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(
            this,
            key,
            value,
            getReferenceKey(keys2, valueCutoff)
          ) : `[ref=${getReferenceKey(keys2, valueCutoff)}]`;
        }
      } else {
        cache2[0] = value;
        keys2[0] = key;
      }
    }
    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
function serialize(value, replacer, indent2, circularReplacer) {
  return JSON.stringify(
    value,
    createReplacer((key, value_) => {
      const value2 = typeof value_ === "bigint" ? `#bigint.${value_.toString()}` : value_;
      return replacer?.(key, value2) || value2;
    }, circularReplacer),
    indent2 ?? void 0
  );
}
var noopStorage = {
  getItem: (_key) => "",
  setItem: (_key, _value) => null,
  removeItem: (_key) => null
};
function createStorage({
  deserialize: deserialize2 = deserialize,
  key: prefix = "wagmi",
  serialize: serialize2 = serialize,
  storage
}) {
  return {
    ...storage,
    getItem: (key, defaultState = null) => {
      const value = storage.getItem(`${prefix}.${key}`);
      try {
        return value ? deserialize2(value) : defaultState;
      } catch (error) {
        console.warn(error);
        return defaultState;
      }
    },
    setItem: (key, value) => {
      if (value === null) {
        storage.removeItem(`${prefix}.${key}`);
      } else {
        try {
          storage.setItem(`${prefix}.${key}`, serialize2(value));
        } catch (err) {
          console.error(err);
        }
      }
    },
    removeItem: (key) => storage.removeItem(`${prefix}.${key}`)
  };
}
var storeKey = "store";
var _isAutoConnecting, _lastUsedConnector, _addEffects, addEffects_fn;
var Config = class {
  constructor({
    autoConnect = false,
    connectors = [new InjectedConnector()],
    publicClient,
    storage = createStorage({
      storage: typeof window !== "undefined" ? window.localStorage : noopStorage
    }),
    logger = {
      warn: console.warn
    },
    webSocketPublicClient
  }) {
    __privateAdd(this, _addEffects);
    this.publicClients = /* @__PURE__ */ new Map();
    this.webSocketPublicClients = /* @__PURE__ */ new Map();
    __privateAdd(this, _isAutoConnecting, void 0);
    __privateAdd(this, _lastUsedConnector, void 0);
    this.args = {
      autoConnect,
      connectors,
      logger,
      publicClient,
      storage,
      webSocketPublicClient
    };
    let status = "disconnected";
    let chainId;
    if (autoConnect) {
      try {
        const rawState = storage.getItem(storeKey);
        const data2 = rawState?.state?.data;
        status = data2?.account ? "reconnecting" : "connecting";
        chainId = data2?.chain?.id;
      } catch (_error) {
      }
    }
    const connectors_ = typeof connectors === "function" ? connectors() : connectors;
    connectors_.forEach((connector) => connector.setStorage(storage));
    this.store = createStore$1(
      subscribeWithSelector(
        persist$1(
          () => ({
            connectors: connectors_,
            publicClient: this.getPublicClient({ chainId }),
            status,
            webSocketPublicClient: this.getWebSocketPublicClient({ chainId })
          }),
          {
            name: storeKey,
            storage,
            partialize: (state) => ({
              ...autoConnect && {
                data: {
                  account: state?.data?.account,
                  chain: state?.data?.chain
                }
              },
              chains: state?.chains
            }),
            version: 2
          }
        )
      )
    );
    this.storage = storage;
    __privateSet(this, _lastUsedConnector, storage?.getItem("wallet"));
    __privateMethod(this, _addEffects, addEffects_fn).call(this);
    if (autoConnect && typeof window !== "undefined")
      setTimeout(async () => await this.autoConnect(), 0);
  }
  get chains() {
    return this.store.getState().chains;
  }
  get connectors() {
    return this.store.getState().connectors;
  }
  get connector() {
    return this.store.getState().connector;
  }
  get data() {
    return this.store.getState().data;
  }
  get error() {
    return this.store.getState().error;
  }
  get lastUsedChainId() {
    return this.data?.chain?.id;
  }
  get publicClient() {
    return this.store.getState().publicClient;
  }
  get status() {
    return this.store.getState().status;
  }
  get subscribe() {
    return this.store.subscribe;
  }
  get webSocketPublicClient() {
    return this.store.getState().webSocketPublicClient;
  }
  setState(updater) {
    const newState = typeof updater === "function" ? updater(this.store.getState()) : updater;
    this.store.setState(newState, true);
  }
  clearState() {
    this.setState((x2) => ({
      ...x2,
      chains: void 0,
      connector: void 0,
      data: void 0,
      error: void 0,
      status: "disconnected"
    }));
  }
  async destroy() {
    if (this.connector)
      await this.connector.disconnect?.();
    __privateSet(this, _isAutoConnecting, false);
    this.clearState();
    this.store.destroy();
  }
  async autoConnect() {
    if (__privateGet(this, _isAutoConnecting))
      return;
    __privateSet(this, _isAutoConnecting, true);
    this.setState((x2) => ({
      ...x2,
      status: x2.data?.account ? "reconnecting" : "connecting"
    }));
    const sorted = __privateGet(this, _lastUsedConnector) ? [...this.connectors].sort(
      (x2) => x2.id === __privateGet(this, _lastUsedConnector) ? -1 : 1
    ) : this.connectors;
    let connected = false;
    for (const connector of sorted) {
      if (!connector.ready || !connector.isAuthorized)
        continue;
      const isAuthorized = await connector.isAuthorized();
      if (!isAuthorized)
        continue;
      const data2 = await connector.connect();
      this.setState((x2) => ({
        ...x2,
        connector,
        chains: connector?.chains,
        data: data2,
        status: "connected"
      }));
      connected = true;
      break;
    }
    if (!connected)
      this.setState((x2) => ({
        ...x2,
        data: void 0,
        status: "disconnected"
      }));
    __privateSet(this, _isAutoConnecting, false);
    return this.data;
  }
  setConnectors(connectors) {
    this.args = {
      ...this.args,
      connectors
    };
    const connectors_ = typeof connectors === "function" ? connectors() : connectors;
    connectors_.forEach((connector) => connector.setStorage(this.args.storage));
    this.setState((x2) => ({
      ...x2,
      connectors: connectors_
    }));
  }
  getPublicClient({ chainId } = {}) {
    let publicClient_ = this.publicClients.get(-1);
    if (publicClient_ && publicClient_?.chain.id === chainId)
      return publicClient_;
    publicClient_ = this.publicClients.get(chainId ?? -1);
    if (publicClient_)
      return publicClient_;
    const { publicClient } = this.args;
    publicClient_ = typeof publicClient === "function" ? publicClient({ chainId }) : publicClient;
    this.publicClients.set(chainId ?? -1, publicClient_);
    return publicClient_;
  }
  setPublicClient(publicClient) {
    const chainId = this.data?.chain?.id;
    this.args = {
      ...this.args,
      publicClient
    };
    this.publicClients.clear();
    this.setState((x2) => ({
      ...x2,
      publicClient: this.getPublicClient({ chainId })
    }));
  }
  getWebSocketPublicClient({ chainId } = {}) {
    let webSocketPublicClient_ = this.webSocketPublicClients.get(-1);
    if (webSocketPublicClient_ && webSocketPublicClient_?.chain.id === chainId)
      return webSocketPublicClient_;
    webSocketPublicClient_ = this.webSocketPublicClients.get(chainId ?? -1);
    if (webSocketPublicClient_)
      return webSocketPublicClient_;
    const { webSocketPublicClient } = this.args;
    webSocketPublicClient_ = typeof webSocketPublicClient === "function" ? webSocketPublicClient({ chainId }) : webSocketPublicClient;
    if (webSocketPublicClient_)
      this.webSocketPublicClients.set(chainId ?? -1, webSocketPublicClient_);
    return webSocketPublicClient_;
  }
  setWebSocketPublicClient(webSocketPublicClient) {
    const chainId = this.data?.chain?.id;
    this.args = {
      ...this.args,
      webSocketPublicClient
    };
    this.webSocketPublicClients.clear();
    this.setState((x2) => ({
      ...x2,
      webSocketPublicClient: this.getWebSocketPublicClient({
        chainId
      })
    }));
  }
  setLastUsedConnector(lastUsedConnector = null) {
    this.storage?.setItem("wallet", lastUsedConnector);
  }
};
_isAutoConnecting = /* @__PURE__ */ new WeakMap();
_lastUsedConnector = /* @__PURE__ */ new WeakMap();
_addEffects = /* @__PURE__ */ new WeakSet();
addEffects_fn = function() {
  const onChange = (data2) => {
    this.setState((x2) => ({
      ...x2,
      data: { ...x2.data, ...data2 }
    }));
  };
  const onDisconnect = () => {
    this.clearState();
  };
  const onError = (error) => {
    this.setState((x2) => ({ ...x2, error }));
  };
  this.store.subscribe(
    ({ connector }) => connector,
    (connector, prevConnector) => {
      prevConnector?.off?.("change", onChange);
      prevConnector?.off?.("disconnect", onDisconnect);
      prevConnector?.off?.("error", onError);
      if (!connector)
        return;
      connector.on?.("change", onChange);
      connector.on?.("disconnect", onDisconnect);
      connector.on?.("error", onError);
    }
  );
  const { publicClient, webSocketPublicClient } = this.args;
  const subscribePublicClient = typeof publicClient === "function";
  const subscribeWebSocketPublicClient = typeof webSocketPublicClient === "function";
  if (subscribePublicClient || subscribeWebSocketPublicClient)
    this.store.subscribe(
      ({ data: data2 }) => data2?.chain?.id,
      (chainId) => {
        this.setState((x2) => ({
          ...x2,
          publicClient: this.getPublicClient({ chainId }),
          webSocketPublicClient: this.getWebSocketPublicClient({
            chainId
          })
        }));
      }
    );
};
var config$3;
function createConfig$1(args) {
  const config_ = new Config(args);
  config$3 = config_;
  return config_;
}
function getConfig() {
  if (!config$3) {
    throw new Error(
      "No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config"
    );
  }
  return config$3;
}
async function connect({ chainId, connector }) {
  const config2 = getConfig();
  const activeConnector = config2.connector;
  if (activeConnector && connector.id === activeConnector.id)
    throw new ConnectorAlreadyConnectedError();
  try {
    config2.setState((x2) => ({ ...x2, status: "connecting" }));
    const data2 = await connector.connect({ chainId });
    config2.setLastUsedConnector(connector.id);
    config2.setState((x2) => ({
      ...x2,
      connector,
      chains: connector?.chains,
      data: data2,
      status: "connected"
    }));
    config2.storage.setItem("connected", true);
    return { ...data2, connector };
  } catch (err) {
    config2.setState((x2) => {
      return {
        ...x2,
        status: x2.connector ? "connected" : "disconnected"
      };
    });
    throw err;
  }
}
async function disconnect() {
  const config2 = getConfig();
  if (config2.connector)
    await config2.connector.disconnect();
  config2.clearState();
  config2.storage.removeItem("connected");
}
var erc20ABI = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];
var erc20ABI_bytes32 = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32"
      }
    ]
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32"
      }
    ]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];
function getPublicClient({ chainId } = {}) {
  const config2 = getConfig();
  if (chainId)
    return config2.getPublicClient({ chainId }) || config2.publicClient;
  return config2.publicClient;
}
function getWebSocketPublicClient({
  chainId
} = {}) {
  const config2 = getConfig();
  if (chainId)
    return config2.getWebSocketPublicClient({ chainId }) || config2.webSocketPublicClient;
  return config2.webSocketPublicClient;
}
function watchPublicClient(args, callback) {
  const config2 = getConfig();
  const handleChange = async () => callback(getPublicClient(args));
  const unsubscribe = config2.subscribe(
    ({ publicClient }) => publicClient,
    handleChange
  );
  return unsubscribe;
}
function watchWebSocketPublicClient(args, callback) {
  const config2 = getConfig();
  const handleChange = async () => callback(getWebSocketPublicClient(args));
  const unsubscribe = config2.subscribe(
    ({ webSocketPublicClient }) => webSocketPublicClient,
    handleChange
  );
  return unsubscribe;
}
async function multicall$3({
  chainId,
  contracts: contracts2,
  blockNumber,
  blockTag,
  ...args
}) {
  const publicClient = getPublicClient({ chainId });
  if (!publicClient.chains)
    throw new ConfigChainsNotFound();
  if (chainId && publicClient.chain.id !== chainId)
    throw new ChainNotConfiguredError({ chainId });
  return publicClient.multicall({
    allowFailure: args.allowFailure ?? true,
    blockNumber,
    blockTag,
    contracts: contracts2
  });
}
async function readContract$3({
  address: address2,
  account: account2,
  chainId,
  abi: abi2,
  args,
  functionName,
  blockNumber,
  blockTag
}) {
  const publicClient = getPublicClient({ chainId });
  return publicClient.readContract({
    abi: abi2,
    address: address2,
    account: account2,
    functionName,
    args,
    blockNumber,
    blockTag
  });
}
async function readContracts({
  contracts: contracts2,
  blockNumber,
  blockTag,
  ...args
}) {
  const { allowFailure = true } = args;
  try {
    const publicClient = getPublicClient();
    const contractsByChainId = contracts2.reduce((contracts22, contract2, index2) => {
      const chainId = contract2.chainId ?? publicClient.chain.id;
      return {
        ...contracts22,
        [chainId]: [...contracts22[chainId] || [], { contract: contract2, index: index2 }]
      };
    }, {});
    const promises = () => Object.entries(contractsByChainId).map(
      ([chainId, contracts22]) => multicall$3({
        allowFailure,
        chainId: parseInt(chainId),
        contracts: contracts22.map(
          ({ contract: contract2 }) => contract2
        ),
        blockNumber,
        blockTag
      })
    );
    const multicallResults = (await Promise.all(promises())).flat();
    const resultIndexes = Object.values(contractsByChainId).flatMap(
      (contracts22) => contracts22.map(({ index: index2 }) => index2)
    );
    return multicallResults.reduce((results, result, index2) => {
      if (results)
        results[resultIndexes[index2]] = result;
      return results;
    }, []);
  } catch (err) {
    if (err instanceof ContractFunctionExecutionError$1)
      throw err;
    const promises = () => contracts2.map(
      (contract2) => readContract$3({ ...contract2, blockNumber, blockTag })
    );
    if (allowFailure)
      return (await Promise.allSettled(promises())).map((result) => {
        if (result.status === "fulfilled")
          return { result: result.value, status: "success" };
        return { error: result.reason, result: void 0, status: "failure" };
      });
    return await Promise.all(promises());
  }
}
async function fetchBalance({
  address: address2,
  chainId,
  formatUnits: unit2,
  token: token2
}) {
  const config2 = getConfig();
  const publicClient = getPublicClient({ chainId });
  if (token2) {
    const fetchContractBalance = async ({ abi: abi2 }) => {
      const erc20Config = { abi: abi2, address: token2, chainId };
      const [value2, decimals, symbol2] = await readContracts({
        allowFailure: false,
        contracts: [
          {
            ...erc20Config,
            functionName: "balanceOf",
            args: [address2]
          },
          { ...erc20Config, functionName: "decimals" },
          { ...erc20Config, functionName: "symbol" }
        ]
      });
      return {
        decimals,
        formatted: formatUnits$3(value2 ?? "0", getUnit(unit2 ?? decimals)),
        symbol: symbol2,
        value: value2
      };
    };
    try {
      return await fetchContractBalance({ abi: erc20ABI });
    } catch (err) {
      if (err instanceof ContractFunctionExecutionError$1) {
        const { symbol: symbol2, ...rest } = await fetchContractBalance({
          abi: erc20ABI_bytes32
        });
        return {
          symbol: hexToString(trim$3(symbol2, { dir: "right" })),
          ...rest
        };
      }
      throw err;
    }
  }
  const chains2 = [
    ...config2.publicClient.chains || [],
    ...config2.chains ?? []
  ];
  const value = await publicClient.getBalance({ address: address2 });
  const chain2 = chains2.find((x2) => x2.id === publicClient.chain.id);
  return {
    decimals: chain2?.nativeCurrency.decimals ?? 18,
    formatted: formatUnits$3(value ?? "0", getUnit(unit2 ?? 18)),
    symbol: chain2?.nativeCurrency.symbol ?? "ETH",
    value
  };
}
function getAccount() {
  const { data: data2, connector, status } = getConfig();
  switch (status) {
    case "connected":
      return {
        address: data2?.account,
        connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "reconnecting":
      return {
        address: data2?.account,
        connector,
        isConnected: !!data2?.account,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status
      };
    case "connecting":
      return {
        address: data2?.account,
        connector,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "disconnected":
      return {
        address: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status
      };
  }
}
function getNetwork() {
  const config2 = getConfig();
  const chainId = config2.data?.chain?.id;
  const activeChains = config2.chains ?? [];
  const activeChain = [
    ...config2.publicClient?.chains || [],
    ...activeChains
  ].find((x2) => x2.id === chainId) ?? {
    id: chainId,
    name: `Chain ${chainId}`,
    network: `${chainId}`,
    nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
    rpcUrls: {
      default: { http: [""] },
      public: { http: [""] }
    }
  };
  return {
    chain: chainId ? {
      ...activeChain,
      ...config2.data?.chain,
      id: chainId
    } : void 0,
    chains: activeChains
  };
}
async function switchNetwork({
  chainId
}) {
  const { connector } = getConfig();
  if (!connector)
    throw new ConnectorNotFoundError();
  if (!connector.switchChain)
    throw new SwitchChainNotSupportedError({
      connector
    });
  return connector.switchChain(chainId);
}
function watchAccount(callback, { selector = (x2) => x2 } = {}) {
  const config2 = getConfig();
  const handleChange = () => callback(getAccount());
  const unsubscribe = config2.subscribe(
    ({ data: data2, connector, status }) => selector({
      address: data2?.account,
      connector,
      status
    }),
    handleChange,
    {
      equalityFn: shallow$1
    }
  );
  return unsubscribe;
}
function watchNetwork(callback, { selector = (x2) => x2 } = {}) {
  const config2 = getConfig();
  const handleChange = () => callback(getNetwork());
  const unsubscribe = config2.subscribe(
    ({ data: data2, chains: chains2 }) => selector({ chainId: data2?.chain?.id, chains: chains2 }),
    handleChange,
    {
      equalityFn: shallow$1
    }
  );
  return unsubscribe;
}
async function fetchEnsAddress({
  chainId,
  name: name2
}) {
  const { normalize: normalize2 } = await __vitePreload(() => import("./index-49a6dbef.js"), true ? ["assets/index-49a6dbef.js","assets/normalize-66a64b6d.js"] : void 0);
  const publicClient = getPublicClient({ chainId });
  const address2 = await publicClient.getEnsAddress({
    name: normalize2(name2)
  });
  try {
    if (address2 === "0x0000000000000000000000000000000000000000")
      return null;
    return address2 ? getAddress$3(address2) : null;
  } catch (_error) {
    return null;
  }
}
async function fetchEnsAvatar({
  name: name2,
  chainId
}) {
  const { normalize: normalize2 } = await __vitePreload(() => import("./index-49a6dbef.js"), true ? ["assets/index-49a6dbef.js","assets/normalize-66a64b6d.js"] : void 0);
  const publicClient = getPublicClient({ chainId });
  const avatar = await publicClient.getEnsAvatar({ name: normalize2(name2) });
  return avatar;
}
async function fetchEnsName({
  address: address2,
  chainId
}) {
  const publicClient = getPublicClient({ chainId });
  return publicClient.getEnsName({
    address: getAddress$3(address2)
  });
}
async function fetchBlockNumber({
  chainId
} = {}) {
  const publicClient = getPublicClient({ chainId });
  const blockNumber = await publicClient.getBlockNumber();
  return blockNumber;
}
var withSelector = { exports: {} };
var withSelector_production_min$1 = {};
const require$$1$E = /* @__PURE__ */ getAugmentedNamespace(shim);
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$3 = require$$0$1i, n$2 = require$$1$E;
function p$3(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q$4 = "function" === typeof Object.is ? Object.is : p$3, r$2 = n$2.useSyncExternalStore, t$2 = h$3.useRef, u$2 = h$3.useEffect, v$4 = h$3.useMemo, w$2 = h$3.useDebugValue;
var useSyncExternalStoreWithSelector = withSelector_production_min$1.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
  var c2 = t$2(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else
    f2 = c2.current;
  c2 = v$4(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a4))
            return k2 = b3;
        }
        return k2 = a4;
      }
      b3 = k2;
      if (q$4(d3, a4))
        return b3;
      var e3 = l2(a4);
      if (void 0 !== g2 && g2(b3, e3))
        return b3;
      d3 = a4;
      return k2 = e3;
    }
    var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a3(b2());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r$2(a2, c2[0], c2[1]);
  u$2(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w$2(d2);
  return d2;
};
const withSelector_production_min = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: withSelector_production_min$1,
  useSyncExternalStoreWithSelector
}, [withSelector_production_min$1]);
const require$$0$1b = /* @__PURE__ */ getAugmentedNamespace(withSelector_production_min);
{
  withSelector.exports = require$$0$1b;
}
var withSelectorExports = withSelector.exports;
function createConfig({
  queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        cacheTime: 1e3 * 60 * 60 * 24,
        networkMode: "offlineFirst",
        refetchOnWindowFocus: false,
        retry: 0
      },
      mutations: {
        networkMode: "offlineFirst"
      }
    }
  }),
  storage = createStorage({
    storage: typeof window !== "undefined" && window.localStorage ? window.localStorage : noopStorage
  }),
  persister = typeof window !== "undefined" ? createSyncStoragePersister({
    key: "cache",
    storage,
    serialize: (x2) => x2,
    deserialize: (x2) => x2
  }) : void 0,
  ...args
}) {
  const config2 = createConfig$1({
    ...args,
    storage
  });
  if (persister)
    persistQueryClient({
      queryClient,
      persister,
      dehydrateOptions: {
        shouldDehydrateQuery: (query) => query.cacheTime !== 0 && query.queryKey[0].persist !== false
      }
    });
  return Object.assign(config2, { queryClient });
}
var Context$2 = reactExports.createContext(void 0);
var queryClientContext = reactExports.createContext(
  void 0
);
function WagmiConfig({
  children,
  config: config2
}) {
  return reactExports.createElement(Context$2.Provider, {
    children: reactExports.createElement(QueryClientProvider, {
      children,
      client: config2.queryClient,
      context: queryClientContext
    }),
    value: config2
  });
}
function useConfig$1() {
  const config2 = reactExports.useContext(Context$2);
  if (!config2)
    throw new Error(
      [
        "`useConfig` must be used within `WagmiConfig`.\n",
        "Read more: https://wagmi.sh/react/WagmiConfig"
      ].join("\n")
    );
  return config2;
}
var useSyncExternalStore2 = shimExports.useSyncExternalStore;
function isQueryKey(value) {
  return Array.isArray(value);
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function parseQueryArgs(arg1, arg2, arg3) {
  if (!isQueryKey(arg1)) {
    return arg1;
  }
  if (typeof arg2 === "function") {
    return { ...arg3, queryKey: arg1, queryFn: arg2 };
  }
  return { ...arg2, queryKey: arg1 };
}
function queryKeyHashFn(queryKey17) {
  return JSON.stringify(
    queryKey17,
    (_2, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : typeof val === "bigint" ? val.toString() : val
  );
}
function shouldThrowError(_useErrorBoundary, params) {
  if (typeof _useErrorBoundary === "function") {
    return _useErrorBoundary(...params);
  }
  return !!_useErrorBoundary;
}
function trackResult(result, observer) {
  const trackedResult = {};
  Object.keys(result).forEach((key) => {
    Object.defineProperty(trackedResult, key, {
      configurable: false,
      enumerable: true,
      get: () => {
        observer.trackedProps.add(key);
        return result[key];
      }
    });
  });
  return trackedResult;
}
function useBaseQuery(options, Observer) {
  const queryClient = useQueryClient({ context: options.context });
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = queryClient.defaultQueryOptions({
    ...options,
    queryKeyHashFn
  });
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  if (defaultedOptions.onError) {
    defaultedOptions.onError = notifyManager.batchCalls(
      defaultedOptions.onError
    );
  }
  if (defaultedOptions.onSuccess) {
    defaultedOptions.onSuccess = notifyManager.batchCalls(
      defaultedOptions.onSuccess
    );
  }
  if (defaultedOptions.onSettled) {
    defaultedOptions.onSettled = notifyManager.batchCalls(
      defaultedOptions.onSettled
    );
  }
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
  }
  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {
    if (!errorResetBoundary.isReset()) {
      defaultedOptions.retryOnMount = false;
    }
  }
  const [observer] = reactExports.useState(
    () => new Observer(
      queryClient,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  useSyncExternalStore2(
    reactExports.useCallback(
      (onStoreChange) => isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer, isRestoring]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  reactExports.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
  reactExports.useEffect(() => {
    observer.setOptions(defaultedOptions, { listeners: false });
  }, [defaultedOptions, observer]);
  if (defaultedOptions.suspense && result.isLoading && result.isFetching && !isRestoring) {
    throw observer.fetchOptimistic(defaultedOptions).then(({ data: data2 }) => {
      defaultedOptions.onSuccess?.(data2);
      defaultedOptions.onSettled?.(data2, null);
    }).catch((error) => {
      errorResetBoundary.clearReset();
      defaultedOptions.onError?.(error);
      defaultedOptions.onSettled?.(void 0, error);
    });
  }
  if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(defaultedOptions.useErrorBoundary, [
    result.error,
    observer.getCurrentQuery()
  ])) {
    throw result.error;
  }
  const status = result.status === "loading" && result.fetchStatus === "idle" ? "idle" : result.status;
  const isIdle = status === "idle";
  const isLoading = status === "loading" && result.fetchStatus === "fetching";
  return {
    ...result,
    defaultedOptions,
    isIdle,
    isLoading,
    observer,
    status
  };
}
function useMutation(arg1, arg2, arg3) {
  const options = parseMutationArgs(arg1, arg2, arg3);
  return useMutation$1({ context: queryClientContext, ...options });
}
function useQuery(arg1, arg2, arg3) {
  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
  const baseQuery = useBaseQuery({ context: queryClientContext, ...parsedOptions }, QueryObserver);
  const result = {
    data: baseQuery.data,
    error: baseQuery.error,
    fetchStatus: baseQuery.fetchStatus,
    isError: baseQuery.isError,
    isFetched: baseQuery.isFetched,
    isFetchedAfterMount: baseQuery.isFetchedAfterMount,
    isFetching: baseQuery.isFetching,
    isIdle: baseQuery.isIdle,
    isLoading: baseQuery.isLoading,
    isRefetching: baseQuery.isRefetching,
    isSuccess: baseQuery.isSuccess,
    refetch: baseQuery.refetch,
    status: baseQuery.status,
    internal: {
      dataUpdatedAt: baseQuery.dataUpdatedAt,
      errorUpdatedAt: baseQuery.errorUpdatedAt,
      failureCount: baseQuery.failureCount,
      isFetchedAfterMount: baseQuery.isFetchedAfterMount,
      isLoadingError: baseQuery.isLoadingError,
      isPaused: baseQuery.isPaused,
      isPlaceholderData: baseQuery.isPlaceholderData,
      isPreviousData: baseQuery.isPreviousData,
      isRefetchError: baseQuery.isRefetchError,
      isStale: baseQuery.isStale,
      remove: baseQuery.remove
    }
  };
  return !baseQuery.defaultedOptions.notifyOnChangeProps ? trackResult(result, baseQuery.observer) : result;
}
var useQueryClient2 = () => useQueryClient({ context: queryClientContext });
function usePublicClient({
  chainId
} = {}) {
  return withSelectorExports.useSyncExternalStoreWithSelector(
    (cb2) => watchPublicClient({ chainId }, cb2),
    () => getPublicClient({ chainId }),
    () => getPublicClient({ chainId }),
    (x2) => x2,
    (a2, b2) => a2.uid === b2.uid
  );
}
function useWebSocketPublicClient({ chainId } = {}) {
  return withSelectorExports.useSyncExternalStoreWithSelector(
    (cb2) => watchWebSocketPublicClient({ chainId }, cb2),
    () => getWebSocketPublicClient({ chainId }),
    () => getWebSocketPublicClient({ chainId }),
    (x2) => x2,
    (a2, b2) => a2?.uid === b2?.uid
  );
}
function useChainId({ chainId } = {}) {
  const publicClient = usePublicClient({ chainId });
  return publicClient.chain.id;
}
function useForceUpdate$1() {
  const [, forceUpdate] = reactExports.useReducer((x2) => x2 + 1, 0);
  return forceUpdate;
}
function queryKey2({ chainId, scopeKey }) {
  return [{ entity: "blockNumber", chainId, scopeKey }];
}
function queryFn2({
  queryKey: [{ chainId }]
}) {
  return fetchBlockNumber({ chainId });
}
function useBlockNumber({
  cacheTime = 0,
  chainId: chainId_,
  enabled = true,
  scopeKey,
  staleTime,
  suspense,
  watch: watch2 = false,
  onBlock,
  onError,
  onSettled,
  onSuccess
} = {}) {
  const chainId = useChainId({ chainId: chainId_ });
  const publicClient = usePublicClient({ chainId });
  const webSocketPublicClient = useWebSocketPublicClient({ chainId });
  const queryClient = useQueryClient2();
  reactExports.useEffect(() => {
    if (!enabled)
      return;
    if (!watch2 && !onBlock)
      return;
    const publicClient_ = webSocketPublicClient ?? publicClient;
    const unwatch = publicClient_.watchBlockNumber({
      onBlockNumber: (blockNumber) => {
        if (watch2)
          queryClient.setQueryData(queryKey2({ chainId, scopeKey }), blockNumber);
        if (onBlock)
          onBlock(blockNumber);
      },
      emitOnBegin: true
    });
    return unwatch;
  }, [
    chainId,
    scopeKey,
    onBlock,
    publicClient,
    queryClient,
    watch2,
    webSocketPublicClient,
    enabled
  ]);
  return useQuery(queryKey2({ scopeKey, chainId }), queryFn2, {
    cacheTime,
    enabled,
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
function useInvalidateOnBlock({
  chainId,
  enabled,
  queryKey: queryKey17
}) {
  const queryClient = useQueryClient2();
  const onBlock = reactExports.useCallback(
    () => queryClient.invalidateQueries({ queryKey: queryKey17 }, { cancelRefetch: false }),
    [queryClient, queryKey17]
  );
  useBlockNumber({
    chainId,
    enabled,
    onBlock: enabled ? onBlock : void 0,
    scopeKey: enabled ? void 0 : "idle"
  });
}
var isPlainObject2 = (obj) => typeof obj === "object" && !Array.isArray(obj);
function useSyncExternalStoreWithTracked(subscribe, getSnapshot, getServerSnapshot = getSnapshot, isEqual3 = deepEqual) {
  const trackedKeys = reactExports.useRef([]);
  const result = withSelectorExports.useSyncExternalStoreWithSelector(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    (x2) => x2,
    (a2, b2) => {
      if (isPlainObject2(a2) && isPlainObject2(b2) && trackedKeys.current.length) {
        for (const key of trackedKeys.current) {
          const equal2 = isEqual3(
            a2[key],
            b2[key]
          );
          if (!equal2)
            return false;
        }
        return true;
      }
      return isEqual3(a2, b2);
    }
  );
  if (isPlainObject2(result)) {
    const trackedResult = { ...result };
    Object.defineProperties(
      trackedResult,
      Object.entries(trackedResult).reduce(
        (res, [key, value]) => {
          return {
            ...res,
            [key]: {
              configurable: false,
              enumerable: true,
              get: () => {
                if (!trackedKeys.current.includes(key)) {
                  trackedKeys.current.push(key);
                }
                return value;
              }
            }
          };
        },
        {}
      )
    );
    return trackedResult;
  }
  return result;
}
function useAccount({ onConnect, onDisconnect } = {}) {
  const config2 = useConfig$1();
  const watchAccount_ = reactExports.useCallback(
    (callback) => watchAccount(callback),
    [config2]
  );
  const account2 = useSyncExternalStoreWithTracked(watchAccount_, getAccount);
  const previousAccountRef = reactExports.useRef();
  const previousAccount = previousAccountRef.current;
  reactExports.useEffect(() => {
    if (previousAccount?.status !== "connected" && account2.status === "connected") {
      onConnect?.({
        address: account2.address,
        connector: account2.connector,
        isReconnected: previousAccount?.status === "reconnecting" || previousAccount?.status === void 0
      });
    }
    if (previousAccount?.status === "connected" && account2.status === "disconnected") {
      onDisconnect?.();
    }
    previousAccountRef.current = account2;
  }, [onConnect, onDisconnect, previousAccount, account2]);
  return account2;
}
function queryKey4({
  address: address2,
  chainId,
  formatUnits: formatUnits2,
  scopeKey,
  token: token2
}) {
  return [
    {
      entity: "balance",
      address: address2,
      chainId,
      formatUnits: formatUnits2,
      scopeKey,
      token: token2
    }
  ];
}
function queryFn4({
  queryKey: [{ address: address2, chainId, formatUnits: formatUnits2, token: token2 }]
}) {
  if (!address2)
    throw new Error("address is required");
  return fetchBalance({ address: address2, chainId, formatUnits: formatUnits2, token: token2 });
}
function useBalance({
  address: address2,
  cacheTime,
  chainId: chainId_,
  enabled = true,
  formatUnits: formatUnits2,
  scopeKey,
  staleTime,
  suspense,
  token: token2,
  watch: watch2,
  onError,
  onSettled,
  onSuccess
} = {}) {
  const chainId = useChainId({ chainId: chainId_ });
  const queryKey_ = reactExports.useMemo(
    () => queryKey4({ address: address2, chainId, formatUnits: formatUnits2, scopeKey, token: token2 }),
    [address2, chainId, formatUnits2, scopeKey, token2]
  );
  const balanceQuery = useQuery(queryKey_, queryFn4, {
    cacheTime,
    enabled: Boolean(enabled && address2),
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
  useInvalidateOnBlock({
    chainId,
    enabled: Boolean(enabled && watch2 && address2),
    queryKey: queryKey_
  });
  return balanceQuery;
}
var mutationKey = (args) => [{ entity: "connect", ...args }];
var mutationFn = (args) => {
  const { connector, chainId } = args;
  if (!connector)
    throw new Error("connector is required");
  return connect({ connector, chainId });
};
function useConnect$1({
  chainId,
  connector,
  onError,
  onMutate,
  onSettled,
  onSuccess
} = {}) {
  const config2 = useConfig$1();
  const {
    data: data2,
    error,
    isError,
    isIdle,
    isLoading,
    isSuccess,
    mutate,
    mutateAsync,
    reset: reset3,
    status,
    variables
  } = useMutation(mutationKey({ connector, chainId }), mutationFn, {
    onError,
    onMutate,
    onSettled,
    onSuccess
  });
  const connect2 = reactExports.useCallback(
    (args) => {
      return mutate({
        chainId: args?.chainId ?? chainId,
        connector: args?.connector ?? connector
      });
    },
    [chainId, connector, mutate]
  );
  const connectAsync = reactExports.useCallback(
    (args) => {
      return mutateAsync({
        chainId: args?.chainId ?? chainId,
        connector: args?.connector ?? connector
      });
    },
    [chainId, connector, mutateAsync]
  );
  return {
    connect: connect2,
    connectAsync,
    connectors: config2.connectors,
    data: data2,
    error,
    isError,
    isIdle,
    isLoading,
    isSuccess,
    pendingConnector: variables?.connector,
    reset: reset3,
    status,
    variables
  };
}
var mutationKey2 = [{ entity: "disconnect" }];
var mutationFn2 = () => disconnect();
function useDisconnect({
  onError,
  onMutate,
  onSettled,
  onSuccess
} = {}) {
  const {
    error,
    isError,
    isIdle,
    isLoading,
    isSuccess,
    mutate: disconnect2,
    mutateAsync: disconnectAsync,
    reset: reset3,
    status
  } = useMutation(mutationKey2, mutationFn2, {
    ...onError ? {
      onError(error2, _variables, context) {
        onError(error2, context);
      }
    } : {},
    onMutate,
    ...onSettled ? {
      onSettled(_data, error2, _variables, context) {
        onSettled(error2, context);
      }
    } : {},
    ...onSuccess ? {
      onSuccess(_data, _variables, context) {
        onSuccess(context);
      }
    } : {}
  });
  return {
    disconnect: disconnect2,
    disconnectAsync,
    error,
    isError,
    isIdle,
    isLoading,
    isSuccess,
    reset: reset3,
    status
  };
}
function useNetwork() {
  const config2 = useConfig$1();
  const watchNetwork_ = reactExports.useCallback(
    (callback) => watchNetwork(callback),
    [config2]
  );
  return useSyncExternalStoreWithTracked(watchNetwork_, getNetwork);
}
var mutationKey5 = (args) => [{ entity: "switchNetwork", ...args }];
var mutationFn5 = (args) => {
  const { chainId } = args;
  if (!chainId)
    throw new Error("chainId is required");
  return switchNetwork({ chainId });
};
function useSwitchNetwork({
  chainId,
  throwForSwitchChainNotSupported,
  onError,
  onMutate,
  onSettled,
  onSuccess
} = {}) {
  const config2 = useConfig$1();
  const forceUpdate = useForceUpdate$1();
  const {
    data: data2,
    error,
    isError,
    isIdle,
    isLoading,
    isSuccess,
    mutate,
    mutateAsync,
    reset: reset3,
    status,
    variables
  } = useMutation(mutationKey5({ chainId }), mutationFn5, {
    onError,
    onMutate,
    onSettled,
    onSuccess
  });
  const switchNetwork_ = reactExports.useCallback(
    (chainId_) => mutate({ chainId: chainId_ ?? chainId }),
    [chainId, mutate]
  );
  const switchNetworkAsync_ = reactExports.useCallback(
    (chainId_) => mutateAsync({ chainId: chainId_ ?? chainId }),
    [chainId, mutateAsync]
  );
  reactExports.useEffect(() => {
    const unwatch = config2.subscribe(
      ({ chains: chains2, connector }) => ({
        chains: chains2,
        connector
      }),
      forceUpdate
    );
    return unwatch;
  }, [config2, forceUpdate]);
  let switchNetwork2;
  let switchNetworkAsync;
  const supportsSwitchChain = !!config2.connector?.switchChain;
  if (throwForSwitchChainNotSupported || supportsSwitchChain) {
    switchNetwork2 = switchNetwork_;
    switchNetworkAsync = switchNetworkAsync_;
  }
  return {
    chains: config2.chains ?? [],
    data: data2,
    error,
    isError,
    isIdle,
    isLoading,
    isSuccess,
    pendingChainId: variables?.chainId,
    reset: reset3,
    status,
    switchNetwork: switchNetwork2,
    switchNetworkAsync,
    variables
  };
}
function queryKey10({ chainId, name: name2, scopeKey }) {
  return [{ entity: "ensAddress", chainId, name: name2, scopeKey }];
}
function queryFn10({
  queryKey: [{ chainId, name: name2 }]
}) {
  if (!name2)
    throw new Error("name is required");
  return fetchEnsAddress({ chainId, name: name2 });
}
function useEnsAddress({
  cacheTime,
  chainId: chainId_,
  enabled = true,
  name: name2,
  scopeKey,
  staleTime = 1e3 * 60 * 60 * 24,
  suspense,
  onError,
  onSettled,
  onSuccess
} = {}) {
  const chainId = useChainId({ chainId: chainId_ });
  return useQuery(queryKey10({ chainId, name: name2, scopeKey }), queryFn10, {
    cacheTime,
    enabled: Boolean(enabled && chainId && name2),
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
function queryKey11({ name: name2, chainId, scopeKey }) {
  return [{ entity: "ensAvatar", name: name2, chainId, scopeKey }];
}
function queryFn11({
  queryKey: [{ name: name2, chainId }]
}) {
  if (!name2)
    throw new Error("name is required");
  return fetchEnsAvatar({ name: name2, chainId });
}
function useEnsAvatar({
  cacheTime,
  chainId: chainId_,
  enabled = true,
  name: name2,
  scopeKey,
  staleTime = 1e3 * 60 * 60 * 24,
  suspense,
  onError,
  onSettled,
  onSuccess
} = {}) {
  const chainId = useChainId({ chainId: chainId_ });
  return useQuery(queryKey11({ name: name2, chainId, scopeKey }), queryFn11, {
    cacheTime,
    enabled: Boolean(enabled && name2 && chainId),
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
function queryKey12({
  address: address2,
  chainId,
  scopeKey
}) {
  return [{ entity: "ensName", address: address2, chainId, scopeKey }];
}
function queryFn12({
  queryKey: [{ address: address2, chainId }]
}) {
  if (!address2)
    throw new Error("address is required");
  return fetchEnsName({ address: address2, chainId });
}
function useEnsName({
  address: address2,
  cacheTime,
  chainId: chainId_,
  enabled = true,
  scopeKey,
  staleTime = 1e3 * 60 * 60 * 24,
  suspense,
  onError,
  onSettled,
  onSuccess
} = {}) {
  const chainId = useChainId({ chainId: chainId_ });
  return useQuery(queryKey12({ address: address2, chainId, scopeKey }), queryFn12, {
    cacheTime,
    enabled: Boolean(enabled && address2 && chainId),
    staleTime,
    suspense,
    onError,
    onSettled,
    onSuccess
  });
}
function alchemyProvider({
  apiKey
}) {
  return function(chain2) {
    const baseHttpUrl = chain2.rpcUrls.alchemy?.http[0];
    const baseWsUrl = chain2.rpcUrls.alchemy?.webSocket?.[0];
    if (!baseHttpUrl)
      return null;
    return {
      chain: {
        ...chain2,
        rpcUrls: {
          ...chain2.rpcUrls,
          default: { http: [`${baseHttpUrl}/${apiKey}`] }
        }
      },
      rpcUrls: {
        http: [`${baseHttpUrl}/${apiKey}`],
        webSocket: [`${baseWsUrl}/${apiKey}`]
      }
    };
  };
}
function infuraProvider({
  apiKey
}) {
  return function(chain2) {
    const baseHttpUrl = chain2.rpcUrls.infura?.http[0];
    const baseWsUrl = chain2.rpcUrls.infura?.webSocket?.[0];
    if (!baseHttpUrl)
      return null;
    return {
      chain: {
        ...chain2,
        rpcUrls: {
          ...chain2.rpcUrls,
          default: { http: [`${baseHttpUrl}/${apiKey}`] }
        }
      },
      rpcUrls: {
        http: [`${baseHttpUrl}/${apiKey}`],
        webSocket: [`${baseWsUrl}/${apiKey}`]
      }
    };
  };
}
function jsonRpcProvider({
  rpc: rpc2
}) {
  return function(chain2) {
    const rpcConfig = rpc2(chain2);
    if (!rpcConfig || rpcConfig.http === "")
      return null;
    return {
      chain: {
        ...chain2,
        rpcUrls: {
          ...chain2.rpcUrls,
          default: { http: [rpcConfig.http] }
        }
      },
      rpcUrls: {
        http: [rpcConfig.http],
        webSocket: rpcConfig.webSocket ? [rpcConfig.webSocket] : void 0
      }
    };
  };
}
function publicProvider() {
  return function(chain2) {
    if (!chain2.rpcUrls.public.http[0])
      return null;
    return {
      chain: chain2,
      rpcUrls: chain2.rpcUrls.public
    };
  };
}
var _UNSTABLE_shimOnConnectSelectAccount;
var MetaMaskConnector = class extends InjectedConnector {
  constructor({
    chains: chains2,
    options: options_
  } = {}) {
    const options = {
      name: "MetaMask",
      shimDisconnect: true,
      getProvider() {
        function getReady(ethereum2) {
          const isMetaMask2 = !!ethereum2?.isMetaMask;
          if (!isMetaMask2)
            return;
          if (ethereum2.isBraveWallet && !ethereum2._events && !ethereum2._state)
            return;
          if (ethereum2.isApexWallet)
            return;
          if (ethereum2.isAvalanche)
            return;
          if (ethereum2.isBitKeep)
            return;
          if (ethereum2.isBlockWallet)
            return;
          if (ethereum2.isCoin98)
            return;
          if (ethereum2.isFordefi)
            return;
          if (ethereum2.isMathWallet)
            return;
          if (ethereum2.isOkxWallet || ethereum2.isOKExWallet)
            return;
          if (ethereum2.isOneInchIOSWallet || ethereum2.isOneInchAndroidWallet)
            return;
          if (ethereum2.isOpera)
            return;
          if (ethereum2.isPortal)
            return;
          if (ethereum2.isRabby)
            return;
          if (ethereum2.isDefiant)
            return;
          if (ethereum2.isTokenPocket)
            return;
          if (ethereum2.isTokenary)
            return;
          if (ethereum2.isZeal)
            return;
          if (ethereum2.isZerion)
            return;
          return ethereum2;
        }
        if (typeof window === "undefined")
          return;
        const ethereum = window.ethereum;
        if (ethereum?.providers)
          return ethereum.providers.find(getReady);
        return getReady(ethereum);
      },
      ...options_
    };
    super({ chains: chains2, options });
    this.id = "metaMask";
    this.shimDisconnectKey = `${this.id}.shimDisconnect`;
    __privateAdd$1(this, _UNSTABLE_shimOnConnectSelectAccount, void 0);
    __privateSet$1(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);
  }
  async connect({ chainId } = {}) {
    try {
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ConnectorNotFoundError();
      if (provider2.on) {
        provider2.on("accountsChanged", this.onAccountsChanged);
        provider2.on("chainChanged", this.onChainChanged);
        provider2.on("disconnect", this.onDisconnect);
      }
      this.emit("message", { type: "connecting" });
      let account2 = null;
      if (__privateGet$1(this, _UNSTABLE_shimOnConnectSelectAccount) && this.options?.shimDisconnect && !this.storage?.getItem(this.shimDisconnectKey)) {
        account2 = await this.getAccount().catch(() => null);
        const isConnected = !!account2;
        if (isConnected)
          try {
            await provider2.request({
              method: "wallet_requestPermissions",
              params: [{ eth_accounts: {} }]
            });
            account2 = await this.getAccount();
          } catch (error) {
            if (this.isUserRejectedRequestError(error))
              throw new UserRejectedRequestError$1(error);
            if (error.code === new ResourceUnavailableRpcError$1(error).code)
              throw error;
          }
      }
      if (!account2) {
        const accounts2 = await provider2.request({
          method: "eth_requestAccounts"
        });
        account2 = getAddress$3(accounts2[0]);
      }
      let id2 = await this.getChainId();
      let unsupported = this.isChainUnsupported(id2);
      if (chainId && id2 !== chainId) {
        const chain2 = await this.switchChain(chainId);
        id2 = chain2.id;
        unsupported = this.isChainUnsupported(id2);
      }
      if (this.options?.shimDisconnect)
        this.storage?.setItem(this.shimDisconnectKey, true);
      return { account: account2, chain: { id: id2, unsupported }, provider: provider2 };
    } catch (error) {
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError$1(error);
      if (error.code === -32002)
        throw new ResourceUnavailableRpcError$1(error);
      throw error;
    }
  }
};
_UNSTABLE_shimOnConnectSelectAccount = /* @__PURE__ */ new WeakMap();
var chacha20poly1305 = {};
var chacha$1 = {};
var binary$1 = {};
var int$3 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function imulShim(a2, b2) {
    var ah2 = a2 >>> 16 & 65535, al2 = a2 & 65535;
    var bh2 = b2 >>> 16 & 65535, bl2 = b2 & 65535;
    return al2 * bl2 + (ah2 * bl2 + al2 * bh2 << 16 >>> 0) | 0;
  }
  exports.mul = Math.imul || imulShim;
  function add2(a2, b2) {
    return a2 + b2 | 0;
  }
  exports.add = add2;
  function sub(a2, b2) {
    return a2 - b2 | 0;
  }
  exports.sub = sub;
  function rotl2(x2, n2) {
    return x2 << n2 | x2 >>> 32 - n2;
  }
  exports.rotl = rotl2;
  function rotr2(x2, n2) {
    return x2 << 32 - n2 | x2 >>> n2;
  }
  exports.rotr = rotr2;
  function isIntegerShim(n2) {
    return typeof n2 === "number" && isFinite(n2) && Math.floor(n2) === n2;
  }
  exports.isInteger = Number.isInteger || isIntegerShim;
  exports.MAX_SAFE_INTEGER = 9007199254740991;
  exports.isSafeInteger = function(n2) {
    return exports.isInteger(n2) && (n2 >= -exports.MAX_SAFE_INTEGER && n2 <= exports.MAX_SAFE_INTEGER);
  };
})(int$3);
const int$1 = /* @__PURE__ */ getDefaultExportFromCjs(int$3);
const int$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: int$1
}, [int$3]);
const require$$0$1a = /* @__PURE__ */ getAugmentedNamespace(int$2);
Object.defineProperty(binary$1, "__esModule", { value: true });
var int_1 = require$$0$1a;
function readInt16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
}
var readInt16BE_1 = binary$1.readInt16BE = readInt16BE;
function readUint16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
}
var readUint16BE_1 = binary$1.readUint16BE = readUint16BE;
function readInt16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
}
var readInt16LE_1 = binary$1.readInt16LE = readInt16LE;
function readUint16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) >>> 0;
}
var readUint16LE_1 = binary$1.readUint16LE = readUint16LE;
function writeUint16BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 8;
  out[offset + 1] = value >>> 0;
  return out;
}
var writeUint16BE_1 = binary$1.writeUint16BE = writeUint16BE;
var writeInt16BE = binary$1.writeInt16BE = writeUint16BE;
function writeUint16LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  return out;
}
var writeUint16LE_1 = binary$1.writeUint16LE = writeUint16LE;
var writeInt16LE = binary$1.writeInt16LE = writeUint16LE;
function readInt32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
}
var readInt32BE_1 = binary$1.readInt32BE = readInt32BE;
function readUint32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
var readUint32BE_1 = binary$1.readUint32BE = readUint32BE;
function readInt32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
}
var readInt32LE_1 = binary$1.readInt32LE = readInt32LE;
function readUint32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
}
var readUint32LE_1 = binary$1.readUint32LE = readUint32LE;
function writeUint32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 24;
  out[offset + 1] = value >>> 16;
  out[offset + 2] = value >>> 8;
  out[offset + 3] = value >>> 0;
  return out;
}
var writeUint32BE_1 = binary$1.writeUint32BE = writeUint32BE;
var writeInt32BE = binary$1.writeInt32BE = writeUint32BE;
function writeUint32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  out[offset + 2] = value >>> 16;
  out[offset + 3] = value >>> 24;
  return out;
}
var writeUint32LE_1 = binary$1.writeUint32LE = writeUint32LE;
var writeInt32LE = binary$1.writeInt32LE = writeUint32LE;
function readInt64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi2 = readInt32BE(array, offset);
  var lo = readInt32BE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
var readInt64BE_1 = binary$1.readInt64BE = readInt64BE;
function readUint64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi2 = readUint32BE(array, offset);
  var lo = readUint32BE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
var readUint64BE_1 = binary$1.readUint64BE = readUint64BE;
function readInt64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readInt32LE(array, offset);
  var hi2 = readInt32LE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
var readInt64LE_1 = binary$1.readInt64LE = readInt64LE;
function readUint64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readUint32LE(array, offset);
  var hi2 = readUint32LE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
var readUint64LE_1 = binary$1.readUint64LE = readUint64LE;
function writeUint64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32BE(value / 4294967296 >>> 0, out, offset);
  writeUint32BE(value >>> 0, out, offset + 4);
  return out;
}
var writeUint64BE_1 = binary$1.writeUint64BE = writeUint64BE;
var writeInt64BE = binary$1.writeInt64BE = writeUint64BE;
function writeUint64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32LE(value >>> 0, out, offset);
  writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
  return out;
}
var writeUint64LE_1 = binary$1.writeUint64LE = writeUint64LE;
var writeInt64LE = binary$1.writeInt64LE = writeUint64LE;
function readUintBE$1(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintBE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul3 = 1;
  for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
    result += array[i2] * mul3;
    mul3 *= 256;
  }
  return result;
}
var readUintBE_1 = binary$1.readUintBE = readUintBE$1;
function readUintLE$1(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintLE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul3 = 1;
  for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
    result += array[i2] * mul3;
    mul3 *= 256;
  }
  return result;
}
var readUintLE_1 = binary$1.readUintLE = readUintLE$1;
function writeUintBE$1(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintBE value must be an integer");
  }
  var div = 1;
  for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
    out[i2] = value / div & 255;
    div *= 256;
  }
  return out;
}
var writeUintBE_1 = binary$1.writeUintBE = writeUintBE$1;
function writeUintLE$1(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintLE value must be an integer");
  }
  var div = 1;
  for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
    out[i2] = value / div & 255;
    div *= 256;
  }
  return out;
}
var writeUintLE_1 = binary$1.writeUintLE = writeUintLE$1;
function readFloat32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset);
}
var readFloat32BE_1 = binary$1.readFloat32BE = readFloat32BE;
function readFloat32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset, true);
}
var readFloat32LE_1 = binary$1.readFloat32LE = readFloat32LE;
function readFloat64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset);
}
var readFloat64BE_1 = binary$1.readFloat64BE = readFloat64BE;
function readFloat64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset, true);
}
var readFloat64LE_1 = binary$1.readFloat64LE = readFloat64LE;
function writeFloat32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value);
  return out;
}
var writeFloat32BE_1 = binary$1.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value, true);
  return out;
}
var writeFloat32LE_1 = binary$1.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value);
  return out;
}
var writeFloat64BE_1 = binary$1.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value, true);
  return out;
}
var writeFloat64LE_1 = binary$1.writeFloat64LE = writeFloat64LE;
const binary = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: binary$1,
  readFloat32BE: readFloat32BE_1,
  readFloat32LE: readFloat32LE_1,
  readFloat64BE: readFloat64BE_1,
  readFloat64LE: readFloat64LE_1,
  readInt16BE: readInt16BE_1,
  readInt16LE: readInt16LE_1,
  readInt32BE: readInt32BE_1,
  readInt32LE: readInt32LE_1,
  readInt64BE: readInt64BE_1,
  readInt64LE: readInt64LE_1,
  readUint16BE: readUint16BE_1,
  readUint16LE: readUint16LE_1,
  readUint32BE: readUint32BE_1,
  readUint32LE: readUint32LE_1,
  readUint64BE: readUint64BE_1,
  readUint64LE: readUint64LE_1,
  readUintBE: readUintBE_1,
  readUintLE: readUintLE_1,
  writeFloat32BE: writeFloat32BE_1,
  writeFloat32LE: writeFloat32LE_1,
  writeFloat64BE: writeFloat64BE_1,
  writeFloat64LE: writeFloat64LE_1,
  writeInt16BE,
  writeInt16LE,
  writeInt32BE,
  writeInt32LE,
  writeInt64BE,
  writeInt64LE,
  writeUint16BE: writeUint16BE_1,
  writeUint16LE: writeUint16LE_1,
  writeUint32BE: writeUint32BE_1,
  writeUint32LE: writeUint32LE_1,
  writeUint64BE: writeUint64BE_1,
  writeUint64LE: writeUint64LE_1,
  writeUintBE: writeUintBE_1,
  writeUintLE: writeUintLE_1
}, [binary$1]);
const require$$0$19 = /* @__PURE__ */ getAugmentedNamespace(binary);
var wipe$2 = {};
Object.defineProperty(wipe$2, "__esModule", { value: true });
function wipe(array) {
  for (var i2 = 0; i2 < array.length; i2++) {
    array[i2] = 0;
  }
  return array;
}
var wipe_2 = wipe$2.wipe = wipe;
const wipe$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: wipe$2,
  wipe: wipe_2
}, [wipe$2]);
const require$$2$o = /* @__PURE__ */ getAugmentedNamespace(wipe$1);
Object.defineProperty(chacha$1, "__esModule", { value: true });
var binary_1 = require$$0$19;
var wipe_1$3 = require$$2$o;
var ROUNDS = 20;
function core(out, input, key) {
  var j0 = 1634760805;
  var j1 = 857760878;
  var j2 = 2036477234;
  var j3 = 1797285236;
  var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
  var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
  var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
  var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
  var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
  var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
  var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
  var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
  var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
  var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
  var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
  var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
  var x0 = j0;
  var x1 = j1;
  var x2 = j2;
  var x3 = j3;
  var x4 = j4;
  var x5 = j5;
  var x6 = j6;
  var x7 = j7;
  var x8 = j8;
  var x9 = j9;
  var x10 = j10;
  var x11 = j11;
  var x12 = j12;
  var x13 = j13;
  var x14 = j14;
  var x15 = j15;
  for (var i2 = 0; i2 < ROUNDS; i2 += 2) {
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 7 | x5 << 7;
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 7 | x5 << 7;
  }
  binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
  binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
  binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
  binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
  binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
  binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
  binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
  binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
  binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
  binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
  binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
  binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
  binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
  binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
  binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
  binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
function streamXOR(key, nonce, src2, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  if (key.length !== 32) {
    throw new Error("ChaCha: key size must be 32 bytes");
  }
  if (dst.length < src2.length) {
    throw new Error("ChaCha: destination is shorter than source");
  }
  var nc2;
  var counterLength;
  if (nonceInplaceCounterLength === 0) {
    if (nonce.length !== 8 && nonce.length !== 12) {
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    }
    nc2 = new Uint8Array(16);
    counterLength = nc2.length - nonce.length;
    nc2.set(nonce, counterLength);
  } else {
    if (nonce.length !== 16) {
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    }
    nc2 = nonce;
    counterLength = nonceInplaceCounterLength;
  }
  var block2 = new Uint8Array(64);
  for (var i2 = 0; i2 < src2.length; i2 += 64) {
    core(block2, nc2, key);
    for (var j2 = i2; j2 < i2 + 64 && j2 < src2.length; j2++) {
      dst[j2] = src2[j2] ^ block2[j2 - i2];
    }
    incrementCounter(nc2, 0, counterLength);
  }
  wipe_1$3.wipe(block2);
  if (nonceInplaceCounterLength === 0) {
    wipe_1$3.wipe(nc2);
  }
  return dst;
}
var streamXOR_1 = chacha$1.streamXOR = streamXOR;
function stream(key, nonce, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  wipe_1$3.wipe(dst);
  return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
var stream_1 = chacha$1.stream = stream;
function incrementCounter(counter2, pos, len2) {
  var carry = 1;
  while (len2--) {
    carry = carry + (counter2[pos] & 255) | 0;
    counter2[pos] = carry & 255;
    carry >>>= 8;
    pos++;
  }
  if (carry > 0) {
    throw new Error("ChaCha: counter overflow");
  }
}
const chacha = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: chacha$1,
  stream: stream_1,
  streamXOR: streamXOR_1
}, [chacha$1]);
const require$$0$18 = /* @__PURE__ */ getAugmentedNamespace(chacha);
var poly1305$2 = {};
var constantTime$1 = {};
Object.defineProperty(constantTime$1, "__esModule", { value: true });
function select(subject, resultIfOne, resultIfZero) {
  return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
}
var select_1 = constantTime$1.select = select;
function lessOrEqual(a2, b2) {
  return (a2 | 0) - (b2 | 0) - 1 >>> 31 & 1;
}
var lessOrEqual_1 = constantTime$1.lessOrEqual = lessOrEqual;
function compare$1(a2, b2) {
  if (a2.length !== b2.length) {
    return 0;
  }
  var result = 0;
  for (var i2 = 0; i2 < a2.length; i2++) {
    result |= a2[i2] ^ b2[i2];
  }
  return 1 & result - 1 >>> 8;
}
var compare_1 = constantTime$1.compare = compare$1;
function equal$1(a2, b2) {
  if (a2.length === 0 || b2.length === 0) {
    return false;
  }
  return compare$1(a2, b2) !== 0;
}
var equal_1 = constantTime$1.equal = equal$1;
const constantTime = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  compare: compare_1,
  default: constantTime$1,
  equal: equal_1,
  lessOrEqual: lessOrEqual_1,
  select: select_1
}, [constantTime$1]);
const require$$1$D = /* @__PURE__ */ getAugmentedNamespace(constantTime);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var constant_time_12 = require$$1$D;
  var wipe_12 = require$$2$o;
  exports.DIGEST_LENGTH = 16;
  var Poly1305 = (
    /** @class */
    function() {
      function Poly13052(key) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this._r[5] = t4 >>> 1 & 8190;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this._r[9] = t7 >>> 5 & 127;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
      }
      Poly13052.prototype._blocks = function(m2, mpos, bytes2) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes2 >= 16) {
          var t0 = m2[mpos + 0] | m2[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m2[mpos + 2] | m2[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m2[mpos + 4] | m2[mpos + 5] << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m2[mpos + 6] | m2[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m2[mpos + 8] | m2[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          var t5 = m2[mpos + 10] | m2[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m2[mpos + 12] | m2[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m2[mpos + 14] | m2[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          var c2 = 0;
          var d0 = c2;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c2 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c2 += d0 >>> 13;
          d0 &= 8191;
          var d1 = c2;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c2 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c2 += d1 >>> 13;
          d1 &= 8191;
          var d2 = c2;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c2 = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c2 += d2 >>> 13;
          d2 &= 8191;
          var d3 = c2;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c2 = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c2 += d3 >>> 13;
          d3 &= 8191;
          var d4 = c2;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c2 = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c2 += d4 >>> 13;
          d4 &= 8191;
          var d5 = c2;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c2 = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c2 += d5 >>> 13;
          d5 &= 8191;
          var d6 = c2;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c2 = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c2 += d6 >>> 13;
          d6 &= 8191;
          var d7 = c2;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c2 = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c2 += d7 >>> 13;
          d7 &= 8191;
          var d8 = c2;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c2 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c2 += d8 >>> 13;
          d8 &= 8191;
          var d9 = c2;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c2 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c2 += d9 >>> 13;
          d9 &= 8191;
          c2 = (c2 << 2) + c2 | 0;
          c2 = c2 + d0 | 0;
          d0 = c2 & 8191;
          c2 = c2 >>> 13;
          d1 += c2;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes2 -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };
      Poly13052.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }
        var g2 = new Uint16Array(10);
        var c2;
        var mask;
        var f2;
        var i2;
        if (this._leftover) {
          i2 = this._leftover;
          this._buffer[i2++] = 1;
          for (; i2 < 16; i2++) {
            this._buffer[i2] = 0;
          }
          this._fin = 1;
          this._blocks(this._buffer, 0, 16);
        }
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this._h[i2] += c2;
          c2 = this._h[i2] >>> 13;
          this._h[i2] &= 8191;
        }
        this._h[0] += c2 * 5;
        c2 = this._h[0] >>> 13;
        this._h[0] &= 8191;
        this._h[1] += c2;
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        this._h[2] += c2;
        g2[0] = this._h[0] + 5;
        c2 = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g2[i2] = this._h[i2] + c2;
          c2 = g2[i2] >>> 13;
          g2[i2] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c2 ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++) {
          g2[i2] &= mask;
        }
        mask = ~mask;
        for (i2 = 0; i2 < 10; i2++) {
          this._h[i2] = this._h[i2] & mask | g2[i2];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
        f2 = this._h[0] + this._pad[0];
        this._h[0] = f2 & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f2 = (this._h[i2] + this._pad[i2] | 0) + (f2 >>> 16) | 0;
          this._h[i2] = f2 & 65535;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };
      Poly13052.prototype.update = function(m2) {
        var mpos = 0;
        var bytes2 = m2.length;
        var want;
        if (this._leftover) {
          want = 16 - this._leftover;
          if (want > bytes2) {
            want = bytes2;
          }
          for (var i2 = 0; i2 < want; i2++) {
            this._buffer[this._leftover + i2] = m2[mpos + i2];
          }
          bytes2 -= want;
          mpos += want;
          this._leftover += want;
          if (this._leftover < 16) {
            return this;
          }
          this._blocks(this._buffer, 0, 16);
          this._leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this._blocks(m2, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (var i2 = 0; i2 < bytes2; i2++) {
            this._buffer[this._leftover + i2] = m2[mpos + i2];
          }
          this._leftover += bytes2;
        }
        return this;
      };
      Poly13052.prototype.digest = function() {
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };
      Poly13052.prototype.clean = function() {
        wipe_12.wipe(this._buffer);
        wipe_12.wipe(this._r);
        wipe_12.wipe(this._h);
        wipe_12.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true;
        return this;
      };
      return Poly13052;
    }()
  );
  exports.Poly1305 = Poly1305;
  function oneTimeAuth(key, data2) {
    var h2 = new Poly1305(key);
    h2.update(data2);
    var digest = h2.digest();
    h2.clean();
    return digest;
  }
  exports.oneTimeAuth = oneTimeAuth;
  function equal2(a2, b2) {
    if (a2.length !== exports.DIGEST_LENGTH || b2.length !== exports.DIGEST_LENGTH) {
      return false;
    }
    return constant_time_12.equal(a2, b2);
  }
  exports.equal = equal2;
})(poly1305$2);
const poly1305 = /* @__PURE__ */ getDefaultExportFromCjs(poly1305$2);
const poly1305$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: poly1305
}, [poly1305$2]);
const require$$1$C = /* @__PURE__ */ getAugmentedNamespace(poly1305$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var chacha_1 = require$$0$18;
  var poly1305_1 = require$$1$C;
  var wipe_12 = require$$2$o;
  var binary_12 = require$$0$19;
  var constant_time_12 = require$$1$D;
  exports.KEY_LENGTH = 32;
  exports.NONCE_LENGTH = 12;
  exports.TAG_LENGTH = 16;
  var ZEROS = new Uint8Array(16);
  var ChaCha20Poly1305 = (
    /** @class */
    function() {
      function ChaCha20Poly13052(key) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key.length !== exports.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key);
      }
      ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        var counter2 = new Uint8Array(16);
        counter2.set(nonce, counter2.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter2, authKey, 4);
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter2, plaintext, result, 4);
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        wipe_12.wipe(counter2);
        return result;
      };
      ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var counter2 = new Uint8Array(16);
        counter2.set(nonce, counter2.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter2, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        if (!constant_time_12.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        }
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter2, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        wipe_12.wipe(counter2);
        return result;
      };
      ChaCha20Poly13052.prototype.clean = function() {
        wipe_12.wipe(this._key);
        return this;
      };
      ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h2 = new poly1305_1.Poly1305(authKey);
        if (associatedData) {
          h2.update(associatedData);
          if (associatedData.length % 16 > 0) {
            h2.update(ZEROS.subarray(associatedData.length % 16));
          }
        }
        h2.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
          h2.update(ZEROS.subarray(ciphertext.length % 16));
        }
        var length2 = new Uint8Array(8);
        if (associatedData) {
          binary_12.writeUint64LE(associatedData.length, length2);
        }
        h2.update(length2);
        binary_12.writeUint64LE(ciphertext.length, length2);
        h2.update(length2);
        var tag = h2.digest();
        for (var i2 = 0; i2 < tag.length; i2++) {
          tagOut[i2] = tag[i2];
        }
        h2.clean();
        wipe_12.wipe(tag);
        wipe_12.wipe(length2);
      };
      return ChaCha20Poly13052;
    }()
  );
  exports.ChaCha20Poly1305 = ChaCha20Poly1305;
})(chacha20poly1305);
var hkdf = {};
var hmac$2 = {};
var hash$4 = {};
Object.defineProperty(hash$4, "__esModule", { value: true });
function isSerializableHash(h2) {
  return typeof h2.saveState !== "undefined" && typeof h2.restoreState !== "undefined" && typeof h2.cleanSavedState !== "undefined";
}
var isSerializableHash_1 = hash$4.isSerializableHash = isSerializableHash;
const hash$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: hash$4,
  isSerializableHash: isSerializableHash_1
}, [hash$4]);
const require$$0$17 = /* @__PURE__ */ getAugmentedNamespace(hash$3);
Object.defineProperty(hmac$2, "__esModule", { value: true });
var hash_1$1 = require$$0$17;
var constant_time_1 = require$$1$D;
var wipe_1$2 = require$$2$o;
var HMAC = (
  /** @class */
  function() {
    function HMAC3(hash2, key) {
      this._finished = false;
      this._inner = new hash2();
      this._outer = new hash2();
      this.blockSize = this._outer.blockSize;
      this.digestLength = this._outer.digestLength;
      var pad2 = new Uint8Array(this.blockSize);
      if (key.length > this.blockSize) {
        this._inner.update(key).finish(pad2).clean();
      } else {
        pad2.set(key);
      }
      for (var i2 = 0; i2 < pad2.length; i2++) {
        pad2[i2] ^= 54;
      }
      this._inner.update(pad2);
      for (var i2 = 0; i2 < pad2.length; i2++) {
        pad2[i2] ^= 54 ^ 92;
      }
      this._outer.update(pad2);
      if (hash_1$1.isSerializableHash(this._inner) && hash_1$1.isSerializableHash(this._outer)) {
        this._innerKeyedState = this._inner.saveState();
        this._outerKeyedState = this._outer.saveState();
      }
      wipe_1$2.wipe(pad2);
    }
    HMAC3.prototype.reset = function() {
      if (!hash_1$1.isSerializableHash(this._inner) || !hash_1$1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      }
      this._inner.restoreState(this._innerKeyedState);
      this._outer.restoreState(this._outerKeyedState);
      this._finished = false;
      return this;
    };
    HMAC3.prototype.clean = function() {
      if (hash_1$1.isSerializableHash(this._inner)) {
        this._inner.cleanSavedState(this._innerKeyedState);
      }
      if (hash_1$1.isSerializableHash(this._outer)) {
        this._outer.cleanSavedState(this._outerKeyedState);
      }
      this._inner.clean();
      this._outer.clean();
    };
    HMAC3.prototype.update = function(data2) {
      this._inner.update(data2);
      return this;
    };
    HMAC3.prototype.finish = function(out) {
      if (this._finished) {
        this._outer.finish(out);
        return this;
      }
      this._inner.finish(out);
      this._outer.update(out.subarray(0, this.digestLength)).finish(out);
      this._finished = true;
      return this;
    };
    HMAC3.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      this.finish(out);
      return out;
    };
    HMAC3.prototype.saveState = function() {
      if (!hash_1$1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      }
      return this._inner.saveState();
    };
    HMAC3.prototype.restoreState = function(savedState) {
      if (!hash_1$1.isSerializableHash(this._inner) || !hash_1$1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      }
      this._inner.restoreState(savedState);
      this._outer.restoreState(this._outerKeyedState);
      this._finished = false;
      return this;
    };
    HMAC3.prototype.cleanSavedState = function(savedState) {
      if (!hash_1$1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      }
      this._inner.cleanSavedState(savedState);
    };
    return HMAC3;
  }()
);
var HMAC_1 = hmac$2.HMAC = HMAC;
function hmac(hash2, key, data2) {
  var h2 = new HMAC(hash2, key);
  h2.update(data2);
  var digest = h2.digest();
  h2.clean();
  return digest;
}
var hmac_2 = hmac$2.hmac = hmac;
var equal = hmac$2.equal = constant_time_1.equal;
const hmac$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  HMAC: HMAC_1,
  default: hmac$2,
  equal,
  hmac: hmac_2
}, [hmac$2]);
const require$$0$16 = /* @__PURE__ */ getAugmentedNamespace(hmac$1);
Object.defineProperty(hkdf, "__esModule", { value: true });
var hmac_1 = require$$0$16;
var wipe_1$1 = require$$2$o;
var HKDF = (
  /** @class */
  function() {
    function HKDF2(hash2, key, salt, info) {
      if (salt === void 0) {
        salt = new Uint8Array(0);
      }
      this._counter = new Uint8Array(1);
      this._hash = hash2;
      this._info = info;
      var okm = hmac_1.hmac(this._hash, salt, key);
      this._hmac = new hmac_1.HMAC(hash2, okm);
      this._buffer = new Uint8Array(this._hmac.digestLength);
      this._bufpos = this._buffer.length;
    }
    HKDF2.prototype._fillBuffer = function() {
      this._counter[0]++;
      var ctr = this._counter[0];
      if (ctr === 0) {
        throw new Error("hkdf: cannot expand more");
      }
      this._hmac.reset();
      if (ctr > 1) {
        this._hmac.update(this._buffer);
      }
      if (this._info) {
        this._hmac.update(this._info);
      }
      this._hmac.update(this._counter);
      this._hmac.finish(this._buffer);
      this._bufpos = 0;
    };
    HKDF2.prototype.expand = function(length2) {
      var out = new Uint8Array(length2);
      for (var i2 = 0; i2 < out.length; i2++) {
        if (this._bufpos === this._buffer.length) {
          this._fillBuffer();
        }
        out[i2] = this._buffer[this._bufpos++];
      }
      return out;
    };
    HKDF2.prototype.clean = function() {
      this._hmac.clean();
      wipe_1$1.wipe(this._buffer);
      wipe_1$1.wipe(this._counter);
      this._bufpos = 0;
    };
    return HKDF2;
  }()
);
var HKDF_1 = hkdf.HKDF = HKDF;
var random$2 = {};
var system$1 = {};
var browser$3 = {};
Object.defineProperty(browser$3, "__esModule", { value: true });
var BrowserRandomSource_1 = browser$3.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
    if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
      this._crypto = browserCrypto;
      this.isAvailable = true;
      this.isInstantiated = true;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Browser random byte generator is not available.");
    }
    const out = new Uint8Array(length2);
    for (let i2 = 0; i2 < out.length; i2 += QUOTA) {
      this._crypto.getRandomValues(out.subarray(i2, i2 + Math.min(out.length - i2, QUOTA)));
    }
    return out;
  }
}
BrowserRandomSource_1 = browser$3.BrowserRandomSource = BrowserRandomSource;
const browser$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get BrowserRandomSource() {
    return BrowserRandomSource_1;
  },
  default: browser$3
}, [browser$3]);
const require$$0$15 = /* @__PURE__ */ getAugmentedNamespace(browser$2);
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var node$3 = {};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$3$l = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
Object.defineProperty(node$3, "__esModule", { value: true });
var NodeRandomSource_1 = node$3.NodeRandomSource = void 0;
const wipe_1 = require$$2$o;
class NodeRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    if (typeof commonjsRequire !== "undefined") {
      const nodeCrypto = require$$3$l;
      if (nodeCrypto && nodeCrypto.randomBytes) {
        this._crypto = nodeCrypto;
        this.isAvailable = true;
        this.isInstantiated = true;
      }
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Node.js random byte generator is not available.");
    }
    let buffer2 = this._crypto.randomBytes(length2);
    if (buffer2.length !== length2) {
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    }
    const out = new Uint8Array(length2);
    for (let i2 = 0; i2 < out.length; i2++) {
      out[i2] = buffer2[i2];
    }
    (0, wipe_1.wipe)(buffer2);
    return out;
  }
}
NodeRandomSource_1 = node$3.NodeRandomSource = NodeRandomSource;
const node$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get NodeRandomSource() {
    return NodeRandomSource_1;
  },
  default: node$3
}, [node$3]);
const require$$1$B = /* @__PURE__ */ getAugmentedNamespace(node$2);
Object.defineProperty(system$1, "__esModule", { value: true });
var SystemRandomSource_1 = system$1.SystemRandomSource = void 0;
const browser_1 = require$$0$15;
const node_1 = require$$1$B;
class SystemRandomSource {
  constructor() {
    this.isAvailable = false;
    this.name = "";
    this._source = new browser_1.BrowserRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Browser";
      return;
    }
    this._source = new node_1.NodeRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Node";
      return;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable) {
      throw new Error("System random byte generator is not available.");
    }
    return this._source.randomBytes(length2);
  }
}
SystemRandomSource_1 = system$1.SystemRandomSource = SystemRandomSource;
const system = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get SystemRandomSource() {
    return SystemRandomSource_1;
  },
  default: system$1
}, [system$1]);
const require$$0$14 = /* @__PURE__ */ getAugmentedNamespace(system);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
  const system_1 = require$$0$14;
  const binary_12 = require$$0$19;
  const wipe_12 = require$$2$o;
  exports.defaultRandomSource = new system_1.SystemRandomSource();
  function randomBytes2(length2, prng = exports.defaultRandomSource) {
    return prng.randomBytes(length2);
  }
  exports.randomBytes = randomBytes2;
  function randomUint32(prng = exports.defaultRandomSource) {
    const buf2 = randomBytes2(4, prng);
    const result = (0, binary_12.readUint32LE)(buf2);
    (0, wipe_12.wipe)(buf2);
    return result;
  }
  exports.randomUint32 = randomUint32;
  const ALPHANUMERIC2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function randomString(length2, charset = ALPHANUMERIC2, prng = exports.defaultRandomSource) {
    if (charset.length < 2) {
      throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
      throw new Error("randomString charset is too long");
    }
    let out = "";
    const charsLen = charset.length;
    const maxByte = 256 - 256 % charsLen;
    while (length2 > 0) {
      const buf2 = randomBytes2(Math.ceil(length2 * 256 / maxByte), prng);
      for (let i2 = 0; i2 < buf2.length && length2 > 0; i2++) {
        const randomByte = buf2[i2];
        if (randomByte < maxByte) {
          out += charset.charAt(randomByte % charsLen);
          length2--;
        }
      }
      (0, wipe_12.wipe)(buf2);
    }
    return out;
  }
  exports.randomString = randomString;
  function randomStringForEntropy(bits, charset = ALPHANUMERIC2, prng = exports.defaultRandomSource) {
    const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length2, charset, prng);
  }
  exports.randomStringForEntropy = randomStringForEntropy;
})(random$2);
const random = /* @__PURE__ */ getDefaultExportFromCjs(random$2);
const random$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: random
}, [random$2]);
var sha256$6 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var binary_12 = require$$0$19;
  var wipe_12 = require$$2$o;
  exports.DIGEST_LENGTH = 32;
  exports.BLOCK_SIZE = 64;
  var SHA2563 = (
    /** @class */
    function() {
      function SHA2564() {
        this.digestLength = exports.DIGEST_LENGTH;
        this.blockSize = exports.BLOCK_SIZE;
        this._state = new Int32Array(8);
        this._temp = new Int32Array(64);
        this._buffer = new Uint8Array(128);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      SHA2564.prototype._initState = function() {
        this._state[0] = 1779033703;
        this._state[1] = 3144134277;
        this._state[2] = 1013904242;
        this._state[3] = 2773480762;
        this._state[4] = 1359893119;
        this._state[5] = 2600822924;
        this._state[6] = 528734635;
        this._state[7] = 1541459225;
      };
      SHA2564.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA2564.prototype.clean = function() {
        wipe_12.wipe(this._buffer);
        wipe_12.wipe(this._temp);
        this.reset();
      };
      SHA2564.prototype.update = function(data2, dataLength) {
        if (dataLength === void 0) {
          dataLength = data2.length;
        }
        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data2[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data2, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data2[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA2564.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left] = 128;
          for (var i2 = left + 1; i2 < padLength - 8; i2++) {
            this._buffer[i2] = 0;
          }
          binary_12.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_12.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i2 = 0; i2 < this.digestLength / 4; i2++) {
          binary_12.writeUint32BE(this._state[i2], out, i2 * 4);
        }
        return this;
      };
      SHA2564.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA2564.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA2564.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA2564.prototype.cleanSavedState = function(savedState) {
        wipe_12.wipe(savedState.state);
        if (savedState.buffer) {
          wipe_12.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA2564;
    }()
  );
  exports.SHA256 = SHA2563;
  var K2 = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function hashBlocks(w2, v2, p2, pos, len2) {
    while (len2 >= 64) {
      var a2 = v2[0];
      var b2 = v2[1];
      var c2 = v2[2];
      var d2 = v2[3];
      var e2 = v2[4];
      var f2 = v2[5];
      var g2 = v2[6];
      var h2 = v2[7];
      for (var i2 = 0; i2 < 16; i2++) {
        var j2 = pos + i2 * 4;
        w2[i2] = binary_12.readUint32BE(p2, j2);
      }
      for (var i2 = 16; i2 < 64; i2++) {
        var u2 = w2[i2 - 2];
        var t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
        u2 = w2[i2 - 15];
        var t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
        w2[i2] = (t1 + w2[i2 - 7] | 0) + (t2 + w2[i2 - 16] | 0);
      }
      for (var i2 = 0; i2 < 64; i2++) {
        var t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f2 ^ ~e2 & g2) | 0) + (h2 + (K2[i2] + w2[i2] | 0) | 0) | 0;
        var t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) | 0;
        h2 = g2;
        g2 = f2;
        f2 = e2;
        e2 = d2 + t1 | 0;
        d2 = c2;
        c2 = b2;
        b2 = a2;
        a2 = t1 + t2 | 0;
      }
      v2[0] += a2;
      v2[1] += b2;
      v2[2] += c2;
      v2[3] += d2;
      v2[4] += e2;
      v2[5] += f2;
      v2[6] += g2;
      v2[7] += h2;
      pos += 64;
      len2 -= 64;
    }
    return pos;
  }
  function hash2(data2) {
    var h2 = new SHA2563();
    h2.update(data2);
    var digest = h2.digest();
    h2.clean();
    return digest;
  }
  exports.hash = hash2;
})(sha256$6);
var x25519 = {};
const require$$0$13 = /* @__PURE__ */ getAugmentedNamespace(random$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
  const random_1 = require$$0$13;
  const wipe_12 = require$$2$o;
  exports.PUBLIC_KEY_LENGTH = 32;
  exports.SECRET_KEY_LENGTH = 32;
  exports.SHARED_KEY_LENGTH = 32;
  function gf2(init) {
    const r2 = new Float64Array(16);
    if (init) {
      for (let i2 = 0; i2 < init.length; i2++) {
        r2[i2] = init[i2];
      }
    }
    return r2;
  }
  const _9 = new Uint8Array(32);
  _9[0] = 9;
  const _121665 = gf2([56129, 1]);
  function car25519(o) {
    let c2 = 1;
    for (let i2 = 0; i2 < 16; i2++) {
      let v2 = o[i2] + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      o[i2] = v2 - c2 * 65536;
    }
    o[0] += c2 - 1 + 37 * (c2 - 1);
  }
  function sel25519(p2, q2, b2) {
    const c2 = ~(b2 - 1);
    for (let i2 = 0; i2 < 16; i2++) {
      const t2 = c2 & (p2[i2] ^ q2[i2]);
      p2[i2] ^= t2;
      q2[i2] ^= t2;
    }
  }
  function pack25519(o, n2) {
    const m2 = gf2();
    const t2 = gf2();
    for (let i2 = 0; i2 < 16; i2++) {
      t2[i2] = n2[i2];
    }
    car25519(t2);
    car25519(t2);
    car25519(t2);
    for (let j2 = 0; j2 < 2; j2++) {
      m2[0] = t2[0] - 65517;
      for (let i2 = 1; i2 < 15; i2++) {
        m2[i2] = t2[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
        m2[i2 - 1] &= 65535;
      }
      m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
      const b2 = m2[15] >> 16 & 1;
      m2[14] &= 65535;
      sel25519(t2, m2, 1 - b2);
    }
    for (let i2 = 0; i2 < 16; i2++) {
      o[2 * i2] = t2[i2] & 255;
      o[2 * i2 + 1] = t2[i2] >> 8;
    }
  }
  function unpack25519(o, n2) {
    for (let i2 = 0; i2 < 16; i2++) {
      o[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
    }
    o[15] &= 32767;
  }
  function add2(o, a2, b2) {
    for (let i2 = 0; i2 < 16; i2++) {
      o[i2] = a2[i2] + b2[i2];
    }
  }
  function sub(o, a2, b2) {
    for (let i2 = 0; i2 < 16; i2++) {
      o[i2] = a2[i2] - b2[i2];
    }
  }
  function mul3(o, a2, b2) {
    let v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
    v2 = a2[0];
    t0 += v2 * b0;
    t1 += v2 * b1;
    t2 += v2 * b22;
    t3 += v2 * b3;
    t4 += v2 * b4;
    t5 += v2 * b5;
    t6 += v2 * b6;
    t7 += v2 * b7;
    t8 += v2 * b8;
    t9 += v2 * b9;
    t10 += v2 * b10;
    t11 += v2 * b11;
    t12 += v2 * b12;
    t13 += v2 * b13;
    t14 += v2 * b14;
    t15 += v2 * b15;
    v2 = a2[1];
    t1 += v2 * b0;
    t2 += v2 * b1;
    t3 += v2 * b22;
    t4 += v2 * b3;
    t5 += v2 * b4;
    t6 += v2 * b5;
    t7 += v2 * b6;
    t8 += v2 * b7;
    t9 += v2 * b8;
    t10 += v2 * b9;
    t11 += v2 * b10;
    t12 += v2 * b11;
    t13 += v2 * b12;
    t14 += v2 * b13;
    t15 += v2 * b14;
    t16 += v2 * b15;
    v2 = a2[2];
    t2 += v2 * b0;
    t3 += v2 * b1;
    t4 += v2 * b22;
    t5 += v2 * b3;
    t6 += v2 * b4;
    t7 += v2 * b5;
    t8 += v2 * b6;
    t9 += v2 * b7;
    t10 += v2 * b8;
    t11 += v2 * b9;
    t12 += v2 * b10;
    t13 += v2 * b11;
    t14 += v2 * b12;
    t15 += v2 * b13;
    t16 += v2 * b14;
    t17 += v2 * b15;
    v2 = a2[3];
    t3 += v2 * b0;
    t4 += v2 * b1;
    t5 += v2 * b22;
    t6 += v2 * b3;
    t7 += v2 * b4;
    t8 += v2 * b5;
    t9 += v2 * b6;
    t10 += v2 * b7;
    t11 += v2 * b8;
    t12 += v2 * b9;
    t13 += v2 * b10;
    t14 += v2 * b11;
    t15 += v2 * b12;
    t16 += v2 * b13;
    t17 += v2 * b14;
    t18 += v2 * b15;
    v2 = a2[4];
    t4 += v2 * b0;
    t5 += v2 * b1;
    t6 += v2 * b22;
    t7 += v2 * b3;
    t8 += v2 * b4;
    t9 += v2 * b5;
    t10 += v2 * b6;
    t11 += v2 * b7;
    t12 += v2 * b8;
    t13 += v2 * b9;
    t14 += v2 * b10;
    t15 += v2 * b11;
    t16 += v2 * b12;
    t17 += v2 * b13;
    t18 += v2 * b14;
    t19 += v2 * b15;
    v2 = a2[5];
    t5 += v2 * b0;
    t6 += v2 * b1;
    t7 += v2 * b22;
    t8 += v2 * b3;
    t9 += v2 * b4;
    t10 += v2 * b5;
    t11 += v2 * b6;
    t12 += v2 * b7;
    t13 += v2 * b8;
    t14 += v2 * b9;
    t15 += v2 * b10;
    t16 += v2 * b11;
    t17 += v2 * b12;
    t18 += v2 * b13;
    t19 += v2 * b14;
    t20 += v2 * b15;
    v2 = a2[6];
    t6 += v2 * b0;
    t7 += v2 * b1;
    t8 += v2 * b22;
    t9 += v2 * b3;
    t10 += v2 * b4;
    t11 += v2 * b5;
    t12 += v2 * b6;
    t13 += v2 * b7;
    t14 += v2 * b8;
    t15 += v2 * b9;
    t16 += v2 * b10;
    t17 += v2 * b11;
    t18 += v2 * b12;
    t19 += v2 * b13;
    t20 += v2 * b14;
    t21 += v2 * b15;
    v2 = a2[7];
    t7 += v2 * b0;
    t8 += v2 * b1;
    t9 += v2 * b22;
    t10 += v2 * b3;
    t11 += v2 * b4;
    t12 += v2 * b5;
    t13 += v2 * b6;
    t14 += v2 * b7;
    t15 += v2 * b8;
    t16 += v2 * b9;
    t17 += v2 * b10;
    t18 += v2 * b11;
    t19 += v2 * b12;
    t20 += v2 * b13;
    t21 += v2 * b14;
    t22 += v2 * b15;
    v2 = a2[8];
    t8 += v2 * b0;
    t9 += v2 * b1;
    t10 += v2 * b22;
    t11 += v2 * b3;
    t12 += v2 * b4;
    t13 += v2 * b5;
    t14 += v2 * b6;
    t15 += v2 * b7;
    t16 += v2 * b8;
    t17 += v2 * b9;
    t18 += v2 * b10;
    t19 += v2 * b11;
    t20 += v2 * b12;
    t21 += v2 * b13;
    t22 += v2 * b14;
    t23 += v2 * b15;
    v2 = a2[9];
    t9 += v2 * b0;
    t10 += v2 * b1;
    t11 += v2 * b22;
    t12 += v2 * b3;
    t13 += v2 * b4;
    t14 += v2 * b5;
    t15 += v2 * b6;
    t16 += v2 * b7;
    t17 += v2 * b8;
    t18 += v2 * b9;
    t19 += v2 * b10;
    t20 += v2 * b11;
    t21 += v2 * b12;
    t22 += v2 * b13;
    t23 += v2 * b14;
    t24 += v2 * b15;
    v2 = a2[10];
    t10 += v2 * b0;
    t11 += v2 * b1;
    t12 += v2 * b22;
    t13 += v2 * b3;
    t14 += v2 * b4;
    t15 += v2 * b5;
    t16 += v2 * b6;
    t17 += v2 * b7;
    t18 += v2 * b8;
    t19 += v2 * b9;
    t20 += v2 * b10;
    t21 += v2 * b11;
    t22 += v2 * b12;
    t23 += v2 * b13;
    t24 += v2 * b14;
    t25 += v2 * b15;
    v2 = a2[11];
    t11 += v2 * b0;
    t12 += v2 * b1;
    t13 += v2 * b22;
    t14 += v2 * b3;
    t15 += v2 * b4;
    t16 += v2 * b5;
    t17 += v2 * b6;
    t18 += v2 * b7;
    t19 += v2 * b8;
    t20 += v2 * b9;
    t21 += v2 * b10;
    t22 += v2 * b11;
    t23 += v2 * b12;
    t24 += v2 * b13;
    t25 += v2 * b14;
    t26 += v2 * b15;
    v2 = a2[12];
    t12 += v2 * b0;
    t13 += v2 * b1;
    t14 += v2 * b22;
    t15 += v2 * b3;
    t16 += v2 * b4;
    t17 += v2 * b5;
    t18 += v2 * b6;
    t19 += v2 * b7;
    t20 += v2 * b8;
    t21 += v2 * b9;
    t22 += v2 * b10;
    t23 += v2 * b11;
    t24 += v2 * b12;
    t25 += v2 * b13;
    t26 += v2 * b14;
    t27 += v2 * b15;
    v2 = a2[13];
    t13 += v2 * b0;
    t14 += v2 * b1;
    t15 += v2 * b22;
    t16 += v2 * b3;
    t17 += v2 * b4;
    t18 += v2 * b5;
    t19 += v2 * b6;
    t20 += v2 * b7;
    t21 += v2 * b8;
    t22 += v2 * b9;
    t23 += v2 * b10;
    t24 += v2 * b11;
    t25 += v2 * b12;
    t26 += v2 * b13;
    t27 += v2 * b14;
    t28 += v2 * b15;
    v2 = a2[14];
    t14 += v2 * b0;
    t15 += v2 * b1;
    t16 += v2 * b22;
    t17 += v2 * b3;
    t18 += v2 * b4;
    t19 += v2 * b5;
    t20 += v2 * b6;
    t21 += v2 * b7;
    t22 += v2 * b8;
    t23 += v2 * b9;
    t24 += v2 * b10;
    t25 += v2 * b11;
    t26 += v2 * b12;
    t27 += v2 * b13;
    t28 += v2 * b14;
    t29 += v2 * b15;
    v2 = a2[15];
    t15 += v2 * b0;
    t16 += v2 * b1;
    t17 += v2 * b22;
    t18 += v2 * b3;
    t19 += v2 * b4;
    t20 += v2 * b5;
    t21 += v2 * b6;
    t22 += v2 * b7;
    t23 += v2 * b8;
    t24 += v2 * b9;
    t25 += v2 * b10;
    t26 += v2 * b11;
    t27 += v2 * b12;
    t28 += v2 * b13;
    t29 += v2 * b14;
    t30 += v2 * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c2 = 1;
    v2 = t0 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t0 = v2 - c2 * 65536;
    v2 = t1 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t1 = v2 - c2 * 65536;
    v2 = t2 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t2 = v2 - c2 * 65536;
    v2 = t3 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t3 = v2 - c2 * 65536;
    v2 = t4 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t4 = v2 - c2 * 65536;
    v2 = t5 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t5 = v2 - c2 * 65536;
    v2 = t6 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t6 = v2 - c2 * 65536;
    v2 = t7 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t7 = v2 - c2 * 65536;
    v2 = t8 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t8 = v2 - c2 * 65536;
    v2 = t9 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t9 = v2 - c2 * 65536;
    v2 = t10 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t10 = v2 - c2 * 65536;
    v2 = t11 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t11 = v2 - c2 * 65536;
    v2 = t12 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t12 = v2 - c2 * 65536;
    v2 = t13 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t13 = v2 - c2 * 65536;
    v2 = t14 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t14 = v2 - c2 * 65536;
    v2 = t15 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t15 = v2 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    c2 = 1;
    v2 = t0 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t0 = v2 - c2 * 65536;
    v2 = t1 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t1 = v2 - c2 * 65536;
    v2 = t2 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t2 = v2 - c2 * 65536;
    v2 = t3 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t3 = v2 - c2 * 65536;
    v2 = t4 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t4 = v2 - c2 * 65536;
    v2 = t5 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t5 = v2 - c2 * 65536;
    v2 = t6 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t6 = v2 - c2 * 65536;
    v2 = t7 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t7 = v2 - c2 * 65536;
    v2 = t8 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t8 = v2 - c2 * 65536;
    v2 = t9 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t9 = v2 - c2 * 65536;
    v2 = t10 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t10 = v2 - c2 * 65536;
    v2 = t11 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t11 = v2 - c2 * 65536;
    v2 = t12 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t12 = v2 - c2 * 65536;
    v2 = t13 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t13 = v2 - c2 * 65536;
    v2 = t14 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t14 = v2 - c2 * 65536;
    v2 = t15 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t15 = v2 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
  }
  function square(o, a2) {
    mul3(o, a2, a2);
  }
  function inv25519(o, inp) {
    const c2 = gf2();
    for (let i2 = 0; i2 < 16; i2++) {
      c2[i2] = inp[i2];
    }
    for (let i2 = 253; i2 >= 0; i2--) {
      square(c2, c2);
      if (i2 !== 2 && i2 !== 4) {
        mul3(c2, c2, inp);
      }
    }
    for (let i2 = 0; i2 < 16; i2++) {
      o[i2] = c2[i2];
    }
  }
  function scalarMult(n2, p2) {
    const z2 = new Uint8Array(32);
    const x2 = new Float64Array(80);
    const a2 = gf2(), b2 = gf2(), c2 = gf2(), d2 = gf2(), e2 = gf2(), f2 = gf2();
    for (let i2 = 0; i2 < 31; i2++) {
      z2[i2] = n2[i2];
    }
    z2[31] = n2[31] & 127 | 64;
    z2[0] &= 248;
    unpack25519(x2, p2);
    for (let i2 = 0; i2 < 16; i2++) {
      b2[i2] = x2[i2];
    }
    a2[0] = d2[0] = 1;
    for (let i2 = 254; i2 >= 0; --i2) {
      const r2 = z2[i2 >>> 3] >>> (i2 & 7) & 1;
      sel25519(a2, b2, r2);
      sel25519(c2, d2, r2);
      add2(e2, a2, c2);
      sub(a2, a2, c2);
      add2(c2, b2, d2);
      sub(b2, b2, d2);
      square(d2, e2);
      square(f2, a2);
      mul3(a2, c2, a2);
      mul3(c2, b2, e2);
      add2(e2, a2, c2);
      sub(a2, a2, c2);
      square(b2, a2);
      sub(c2, d2, f2);
      mul3(a2, c2, _121665);
      add2(a2, a2, d2);
      mul3(c2, c2, a2);
      mul3(a2, d2, f2);
      mul3(d2, b2, x2);
      square(b2, e2);
      sel25519(a2, b2, r2);
      sel25519(c2, d2, r2);
    }
    for (let i2 = 0; i2 < 16; i2++) {
      x2[i2 + 16] = a2[i2];
      x2[i2 + 32] = c2[i2];
      x2[i2 + 48] = b2[i2];
      x2[i2 + 64] = d2[i2];
    }
    const x32 = x2.subarray(32);
    const x16 = x2.subarray(16);
    inv25519(x32, x32);
    mul3(x16, x16, x32);
    const q2 = new Uint8Array(32);
    pack25519(q2, x16);
    return q2;
  }
  exports.scalarMult = scalarMult;
  function scalarMultBase(n2) {
    return scalarMult(n2, _9);
  }
  exports.scalarMultBase = scalarMultBase;
  function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports.SECRET_KEY_LENGTH) {
      throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    }
    const secretKey = new Uint8Array(seed);
    const publicKey = scalarMultBase(secretKey);
    return {
      publicKey,
      secretKey
    };
  }
  exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
  function generateKeyPair(prng) {
    const seed = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed);
    (0, wipe_12.wipe)(seed);
    return result;
  }
  exports.generateKeyPair = generateKeyPair;
  function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect public key length");
    }
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
      let zeros = 0;
      for (let i2 = 0; i2 < result.length; i2++) {
        zeros |= result[i2];
      }
      if (zeros === 0) {
        throw new Error("X25519: invalid shared key");
      }
    }
    return result;
  }
  exports.sharedKey = sharedKey;
})(x25519);
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}
function allocUnsafe(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}
function concat$4(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output2.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output2);
}
const concat$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  concat: concat$4
}, Symbol.toStringTag, { value: "Module" }));
function base$3(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode3(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size2 - length2;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length2;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j3 = zeroes;
    while (it4 !== size2) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode3,
    decodeUnsafe,
    decode: decode2
  };
}
var src$3 = base$3;
var _brrp__multiformats_scope_baseX = src$3;
const empty = new Uint8Array(0);
const fromHex$1 = (hex2) => {
  const hexes2 = hex2.match(/../g);
  return hexes2 ? new Uint8Array(hexes2.map((b2) => parseInt(b2, 16))) : empty;
};
const equals$1 = (aa2, bb2) => {
  if (aa2 === bb2)
    return true;
  if (aa2.byteLength !== bb2.byteLength) {
    return false;
  }
  for (let ii2 = 0; ii2 < aa2.byteLength; ii2++) {
    if (aa2[ii2] !== bb2[ii2]) {
      return false;
    }
  }
  return true;
};
const coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString$3 = (str) => new TextEncoder().encode(str);
const toString$2 = (b2) => new TextDecoder().decode(b2);
class Encoder {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix, baseEncode);
    this.decoder = new Decoder(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$1 = ({ name: name2, prefix, encode: encode3, decode: decode2 }) => new Codec(name2, prefix, encode3, decode2);
const baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode3, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name2);
  return from$1({
    prefix,
    name: name2,
    encode: encode3,
    decode: (text) => coerce(decode2(text))
  });
};
const decode$f = (string2, alphabet2, bitsPerChar, name2) => {
  const codes = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$e = (data2, alphabet2, bitsPerChar) => {
  const pad2 = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data2.length; ++i2) {
    buffer2 = buffer2 << 8 | data2[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad2) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$1({
    prefix,
    name: name2,
    encode(input) {
      return encode$e(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$f(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const identity = from$1({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString$2(buf2),
  decode: (str) => fromString$3(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base64$3 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$3,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
const alphabetBytesToChars = alphabet.reduce((p2, c2, i2) => {
  p2[i2] = c2;
  return p2;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p2, c2, i2) => {
  p2[c2.codePointAt(0)] = i2;
  return p2;
}, []);
function encode$d(data2) {
  return data2.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode$e(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from$1({
  prefix: "🚀",
  name: "base256emoji",
  encode: encode$d,
  decode: decode$e
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
var encode_1$1 = encode$c;
var MSB$2 = 128, REST$2 = 127, MSBALL$1 = ~REST$2, INT$1 = Math.pow(2, 31);
function encode$c(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$1) {
    out[offset++] = num & 255 | MSB$2;
    num /= 128;
  }
  while (num & MSBALL$1) {
    out[offset++] = num & 255 | MSB$2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$c.bytes = offset - oldOffset + 1;
  return out;
}
var decode$d = read$2;
var MSB$1$1 = 128, REST$1$1 = 127;
function read$2(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b2, l2 = buf2.length;
  do {
    if (counter2 >= l2) {
      read$2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter2++];
    res += shift < 28 ? (b2 & REST$1$1) << shift : (b2 & REST$1$1) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1$1);
  read$2.bytes = counter2 - offset;
  return res;
}
var N1$1 = Math.pow(2, 7);
var N2$1 = Math.pow(2, 14);
var N3$1 = Math.pow(2, 21);
var N4$1 = Math.pow(2, 28);
var N5$1 = Math.pow(2, 35);
var N6$1 = Math.pow(2, 42);
var N7$1 = Math.pow(2, 49);
var N8$1 = Math.pow(2, 56);
var N9$1 = Math.pow(2, 63);
var length$3 = function(value) {
  return value < N1$1 ? 1 : value < N2$1 ? 2 : value < N3$1 ? 3 : value < N4$1 ? 4 : value < N5$1 ? 5 : value < N6$1 ? 6 : value < N7$1 ? 7 : value < N8$1 ? 8 : value < N9$1 ? 9 : 10;
};
var varint$2 = {
  encode: encode_1$1,
  decode: decode$d,
  encodingLength: length$3
};
var _brrp_varint = varint$2;
const decode$c = (data2, offset = 0) => {
  const code2 = _brrp_varint.decode(data2, offset);
  return [
    code2,
    _brrp_varint.decode.bytes
  ];
};
const encodeTo = (int2, target, offset = 0) => {
  _brrp_varint.encode(int2, target, offset);
  return target;
};
const encodingLength = (int2) => {
  return _brrp_varint.encodingLength(int2);
};
const create$7 = (code2, digest) => {
  const size2 = digest.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size2);
  const bytes2 = new Uint8Array(digestOffset + size2);
  encodeTo(code2, bytes2, 0);
  encodeTo(size2, bytes2, sizeOffset);
  bytes2.set(digest, digestOffset);
  return new Digest(code2, size2, digest, bytes2);
};
const decode$b = (multihash) => {
  const bytes2 = coerce(multihash);
  const [code2, sizeOffset] = decode$c(bytes2);
  const [size2, digestOffset] = decode$c(bytes2.subarray(sizeOffset));
  const digest = bytes2.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size2) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size2, digest, bytes2);
};
const equals = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals$1(a2.bytes, b2.bytes);
  }
};
class Digest {
  constructor(code2, size2, digest, bytes2) {
    this.code = code2;
    this.size = size2;
    this.digest = digest;
    this.bytes = bytes2;
  }
}
const from = ({ name: name2, code: code2, encode: encode3 }) => new Hasher(name2, code2, encode3);
class Hasher {
  constructor(name2, code2, encode3) {
    this.name = name2;
    this.code = code2;
    this.encode = encode3;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create$7(this.code, result) : result.then((digest) => create$7(this.code, digest));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
const sha = (name2) => async (data2) => new Uint8Array(await crypto.subtle.digest(name2, data2));
const sha256$5 = from({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
const name$4 = "raw";
const code$4 = 85;
const encode$b = (node2) => coerce(node2);
const decode$a = (data2) => coerce(data2);
const raw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code: code$4,
  decode: decode$a,
  encode: encode$b,
  name: name$4
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
class CID {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly$1,
      version: readonly$1,
      multihash: readonly$1,
      bytes: readonly$1,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest } = this.multihash;
        const multihash = create$7(code2, digest);
        return CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0(bytes2, _baseCache, base3 || base58btc.encoder);
      default:
        return toStringV1(bytes2, _baseCache, base3 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
      return new CID(version2, code2, multihash, bytes2 || encodeCID(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest = decode$b(multihash);
      return CID.create(version2, code2, digest);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new CID(version2, code2, digest, digest.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID(version2, code2, digest.bytes);
        return new CID(version2, code2, digest, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest) {
    return CID.create(0, DAG_PB_CODE, digest);
  }
  static createV1(code2, digest) {
    return CID.create(1, code2, digest);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length2] = decode$c(initialBytes.subarray(offset));
      offset += length2;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size2 = offset + digestSize;
    const multihashSize = size2 - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size: size2
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes(source, base3);
    const cid = CID.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base3 || base32;
      return [
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0 = (bytes2, cache2, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1 = (bytes2, cache2, base3) => {
  const { prefix } = base3;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
const encodeCID = (version2, code2, multihash) => {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version2, bytes2, 0);
  encodeTo(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol = Symbol.for("@ipld/js-cid/CID");
const readonly$1 = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$8 = "0.0.0-dev";
const deprecate = (range, message) => {
  if (range.test(version$8)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$4,
  ...base256emoji$1
};
function createCodec(name2, prefix, encode3, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode3
    },
    decoder: { decode: decode2 }
  };
}
const string = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string2 += String.fromCharCode(buf2[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
const BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function fromString$1(string2, encoding2 = "utf8") {
  const base3 = BASES[encoding2];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding2}"`);
  }
  if ((encoding2 === "utf8" || encoding2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
const fromString$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fromString: fromString$1
}, Symbol.toStringTag, { value: "Module" }));
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name2, version2, os) {
      this.name = name2;
      this.version = version2;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version2) {
      this.version = version2;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name2, version2, os, bot) {
      this.name = name2;
      this.version = version2;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser2 = _a2[0], regex2 = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex2.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS$1(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version2, os);
}
function detectOS$1(ua2) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a2 = operatingSystemRules[ii2], os = _a2[0], regex2 = _a2[1];
    var match = regex2.exec(ua2);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output2 = [];
  for (var ii2 = 0; ii2 < count; ii2++) {
    output2.push("0");
  }
  return output2;
}
var cjs$5 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s = arguments[i2];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __rest$1(s, e2) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
        t2[p2[i2]] = s[p2[i2]];
    }
  return t2;
}
function __decorate$1(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter$1(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o[k22] = m2[k2];
}
function __exportStar(m2, exports) {
  for (var p2 in m2)
    if (p2 !== "default" && !exports.hasOwnProperty(p2))
      exports[p2] = m2[p2];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i2 = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i2 = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++)
    s += arguments[i2].length;
  for (var r2 = Array(s), k2 = 0, i2 = 0; i2 < il2; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f2) {
    i2[n2] = o[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw2) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw2 });
  } else {
    cooked.raw = raw2;
  }
  return cooked;
}
function __importStar(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k2 in mod2)
      if (Object.hasOwnProperty.call(mod2, k2))
        result[k2] = mod2[k2];
  }
  result.default = mod2;
  return result;
}
function __importDefault$3(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign$1;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter: __awaiter$1,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate: __decorate$1,
  __exportStar,
  __extends,
  __generator,
  __importDefault: __importDefault$3,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest: __rest$1,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$12 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var utils$n = {};
var delay = {};
var hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay)
    return delay;
  hasRequiredDelay = 1;
  Object.defineProperty(delay, "__esModule", { value: true });
  delay.delay = void 0;
  function delay$1(timeout) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(true);
      }, timeout);
    });
  }
  delay.delay = delay$1;
  return delay;
}
var convert = {};
var constants$2 = {};
var misc = {};
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc)
    return misc;
  hasRequiredMisc = 1;
  Object.defineProperty(misc, "__esModule", { value: true });
  misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0;
  misc.ONE_HUNDRED = 100;
  misc.ONE_THOUSAND = 1e3;
  return misc;
}
var time = {};
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime)
    return time;
  hasRequiredTime = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  })(time);
  return time;
}
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants)
    return constants$2;
  hasRequiredConstants = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0$12;
    tslib_1.__exportStar(requireMisc(), exports);
    tslib_1.__exportStar(requireTime(), exports);
  })(constants$2);
  return constants$2;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert)
    return convert;
  hasRequiredConvert = 1;
  Object.defineProperty(convert, "__esModule", { value: true });
  convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const constants_12 = requireConstants();
  function toMiliseconds(seconds) {
    return seconds * constants_12.ONE_THOUSAND;
  }
  convert.toMiliseconds = toMiliseconds;
  function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_12.ONE_THOUSAND);
  }
  convert.fromMiliseconds = fromMiliseconds;
  return convert;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1)
    return utils$n;
  hasRequiredUtils$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0$12;
    tslib_1.__exportStar(requireDelay(), exports);
    tslib_1.__exportStar(requireConvert(), exports);
  })(utils$n);
  return utils$n;
}
var watch$1 = {};
var hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1)
    return watch$1;
  hasRequiredWatch$1 = 1;
  Object.defineProperty(watch$1, "__esModule", { value: true });
  watch$1.Watch = void 0;
  class Watch {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(label) {
      if (this.timestamps.has(label)) {
        throw new Error(`Watch already started for label: ${label}`);
      }
      this.timestamps.set(label, { started: Date.now() });
    }
    stop(label) {
      const timestamp = this.get(label);
      if (typeof timestamp.elapsed !== "undefined") {
        throw new Error(`Watch already stopped for label: ${label}`);
      }
      const elapsed = Date.now() - timestamp.started;
      this.timestamps.set(label, { started: timestamp.started, elapsed });
    }
    get(label) {
      const timestamp = this.timestamps.get(label);
      if (typeof timestamp === "undefined") {
        throw new Error(`No timestamp found for label: ${label}`);
      }
      return timestamp;
    }
    elapsed(label) {
      const timestamp = this.get(label);
      const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
      return elapsed;
    }
  }
  watch$1.Watch = Watch;
  watch$1.default = Watch;
  return watch$1;
}
var types$4 = {};
var watch = {};
var hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch)
    return watch;
  hasRequiredWatch = 1;
  Object.defineProperty(watch, "__esModule", { value: true });
  watch.IWatch = void 0;
  class IWatch {
  }
  watch.IWatch = IWatch;
  return watch;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes)
    return types$4;
  hasRequiredTypes = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0$12;
    tslib_1.__exportStar(requireWatch(), exports);
  })(types$4);
  return types$4;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require$$0$12;
  tslib_1.__exportStar(requireUtils$1(), exports);
  tslib_1.__exportStar(requireWatch$1(), exports);
  tslib_1.__exportStar(requireTypes(), exports);
  tslib_1.__exportStar(requireConstants(), exports);
})(cjs$5);
const index$m = /* @__PURE__ */ getDefaultExportFromCjs(cjs$5);
const cjs$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$m
}, [cjs$5]);
var cjs$3 = {};
Object.defineProperty(cjs$3, "__esModule", { value: true });
var getLocalStorage_1 = cjs$3.getLocalStorage = getLocalStorageOrThrow_1 = cjs$3.getLocalStorageOrThrow = getCrypto_1 = cjs$3.getCrypto = getCryptoOrThrow_1 = cjs$3.getCryptoOrThrow = getLocation_1 = cjs$3.getLocation = getLocationOrThrow_1 = cjs$3.getLocationOrThrow = getNavigator_1 = cjs$3.getNavigator = getNavigatorOrThrow_1 = cjs$3.getNavigatorOrThrow = getDocument_1 = cjs$3.getDocument = getDocumentOrThrow_1 = cjs$3.getDocumentOrThrow = getFromWindowOrThrow_1 = cjs$3.getFromWindowOrThrow = getFromWindow_1 = cjs$3.getFromWindow = void 0;
function getFromWindow(name2) {
  let res = void 0;
  if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
    res = window[name2];
  }
  return res;
}
var getFromWindow_1 = cjs$3.getFromWindow = getFromWindow;
function getFromWindowOrThrow(name2) {
  const res = getFromWindow(name2);
  if (!res) {
    throw new Error(`${name2} is not defined in Window`);
  }
  return res;
}
var getFromWindowOrThrow_1 = cjs$3.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
var getDocumentOrThrow_1 = cjs$3.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
var getDocument_1 = cjs$3.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
var getNavigatorOrThrow_1 = cjs$3.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
var getNavigator_1 = cjs$3.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
var getLocationOrThrow_1 = cjs$3.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
var getLocation_1 = cjs$3.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
var getCryptoOrThrow_1 = cjs$3.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
var getCrypto_1 = cjs$3.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
var getLocalStorageOrThrow_1 = cjs$3.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
getLocalStorage_1 = cjs$3.getLocalStorage = getLocalStorage;
const cjs$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: cjs$3,
  get getCrypto() {
    return getCrypto_1;
  },
  get getCryptoOrThrow() {
    return getCryptoOrThrow_1;
  },
  get getDocument() {
    return getDocument_1;
  },
  get getDocumentOrThrow() {
    return getDocumentOrThrow_1;
  },
  get getFromWindow() {
    return getFromWindow_1;
  },
  get getFromWindowOrThrow() {
    return getFromWindowOrThrow_1;
  },
  get getLocalStorage() {
    return getLocalStorage_1;
  },
  get getLocalStorageOrThrow() {
    return getLocalStorageOrThrow_1;
  },
  get getLocation() {
    return getLocation_1;
  },
  get getLocationOrThrow() {
    return getLocationOrThrow_1;
  },
  get getNavigator() {
    return getNavigator_1;
  },
  get getNavigatorOrThrow() {
    return getNavigatorOrThrow_1;
  }
}, [cjs$3]);
var cjs$1 = {};
const require$$0$11 = /* @__PURE__ */ getAugmentedNamespace(cjs$2);
Object.defineProperty(cjs$1, "__esModule", { value: true });
var getWindowMetadata_1 = cjs$1.getWindowMetadata = void 0;
const window_getters_1 = require$$0$11;
function getWindowMetadata() {
  let doc;
  let loc;
  try {
    doc = window_getters_1.getDocumentOrThrow();
    loc = window_getters_1.getLocationOrThrow();
  } catch (e2) {
    return null;
  }
  function getIcons() {
    const links2 = doc.getElementsByTagName("link");
    const icons2 = [];
    for (let i2 = 0; i2 < links2.length; i2++) {
      const link = links2[i2];
      const rel = link.getAttribute("rel");
      if (rel) {
        if (rel.toLowerCase().indexOf("icon") > -1) {
          const href = link.getAttribute("href");
          if (href) {
            if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
              let absoluteHref = loc.protocol + "//" + loc.host;
              if (href.indexOf("/") === 0) {
                absoluteHref += href;
              } else {
                const path = loc.pathname.split("/");
                path.pop();
                const finalPath = path.join("/");
                absoluteHref += finalPath + "/" + href;
              }
              icons2.push(absoluteHref);
            } else if (href.indexOf("//") === 0) {
              const absoluteUrl = loc.protocol + href;
              icons2.push(absoluteUrl);
            } else {
              icons2.push(href);
            }
          }
        }
      }
    }
    return icons2;
  }
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc.getElementsByTagName("meta");
    for (let i2 = 0; i2 < metaTags.length; i2++) {
      const tag = metaTags[i2];
      const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
        if (attr) {
          return args.includes(attr);
        }
        return false;
      });
      if (attributes.length && attributes) {
        const content = tag.getAttribute("content");
        if (content) {
          return content;
        }
      }
    }
    return "";
  }
  function getName() {
    let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    if (!name3) {
      name3 = doc.title;
    }
    return name3;
  }
  function getDescription() {
    const description3 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
    return description3;
  }
  const name2 = getName();
  const description2 = getDescription();
  const url = loc.origin;
  const icons = getIcons();
  const meta = {
    description: description2,
    url,
    icons,
    name: name2
  };
  return meta;
}
getWindowMetadata_1 = cjs$1.getWindowMetadata = getWindowMetadata;
var queryString = {};
var strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
const index$l = /* @__PURE__ */ getDefaultExportFromCjs(strictUriEncode);
const strictUriEncode$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$l
}, [strictUriEncode]);
const require$$0$10 = /* @__PURE__ */ getAugmentedNamespace(strictUriEncode$1);
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components, split2) {
  try {
    return [decodeURIComponent(components.join(""))];
  } catch (err) {
  }
  if (components.length === 1) {
    return components;
  }
  split2 = split2 || 1;
  var left = components.slice(0, split2);
  var right = components.slice(split2);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode$9(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher) || [];
    for (var i2 = 1; i2 < tokens.length; i2++) {
      input = decodeComponents(tokens, i2).join("");
      tokens = input.match(singleMatcher) || [];
    }
    return input;
  }
}
function customDecodeURIComponent(input) {
  var replaceMap = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  };
  var match = multiMatcher.exec(input);
  while (match) {
    try {
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode$9(match[0]);
      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }
    match = multiMatcher.exec(input);
  }
  replaceMap["%C2"] = "�";
  var entries = Object.keys(replaceMap);
  for (var i2 = 0; i2 < entries.length; i2++) {
    var key = entries[i2];
    input = input.replace(new RegExp(key, "g"), replaceMap[key]);
  }
  return input;
}
var decodeUriComponent = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent(encodedURI);
  }
};
const index$k = /* @__PURE__ */ getDefaultExportFromCjs(decodeUriComponent);
const decodeUriComponent$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$k
}, [decodeUriComponent]);
const require$$1$A = /* @__PURE__ */ getAugmentedNamespace(decodeUriComponent$1);
var splitOnFirst = (string2, separator) => {
  if (!(typeof string2 === "string" && typeof separator === "string")) {
    throw new TypeError("Expected the arguments to be of type `string`");
  }
  if (separator === "") {
    return [string2];
  }
  const separatorIndex = string2.indexOf(separator);
  if (separatorIndex === -1) {
    return [string2];
  }
  return [
    string2.slice(0, separatorIndex),
    string2.slice(separatorIndex + separator.length)
  ];
};
const index$j = /* @__PURE__ */ getDefaultExportFromCjs(splitOnFirst);
const splitOnFirst$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$j
}, [splitOnFirst]);
const require$$2$n = /* @__PURE__ */ getAugmentedNamespace(splitOnFirst$1);
var filterObj = function(obj, predicate) {
  var ret = {};
  var keys2 = Object.keys(obj);
  var isArr = Array.isArray(predicate);
  for (var i2 = 0; i2 < keys2.length; i2++) {
    var key = keys2[i2];
    var val = obj[key];
    if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
      ret[key] = val;
    }
  }
  return ret;
};
const index$i = /* @__PURE__ */ getDefaultExportFromCjs(filterObj);
const filterObj$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$i
}, [filterObj]);
const require$$3$k = /* @__PURE__ */ getAugmentedNamespace(filterObj$1);
(function(exports) {
  const strictUriEncode2 = require$$0$10;
  const decodeComponent = require$$1$A;
  const splitOnFirst2 = require$$2$n;
  const filterObject = require$$3$k;
  const isNullOrUndefined = (value) => value === null || value === void 0;
  const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case "index":
        return (key) => (result, value) => {
          const index2 = result.length;
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode3(key, options), "[", index2, "]"].join("")];
          }
          return [
            ...result,
            [encode3(key, options), "[", encode3(index2, options), "]=", encode3(value, options)].join("")
          ];
        };
      case "bracket":
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode3(key, options), "[]"].join("")];
          }
          return [...result, [encode3(key, options), "[]=", encode3(value, options)].join("")];
        };
      case "colon-list-separator":
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode3(key, options), ":list="].join("")];
          }
          return [...result, [encode3(key, options), ":list=", encode3(value, options)].join("")];
        };
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          value = value === null ? "" : value;
          if (result.length === 0) {
            return [[encode3(key, options), keyValueSep, encode3(value, options)].join("")];
          }
          return [[result, encode3(value, options)].join(options.arrayFormatSeparator)];
        };
      }
      default:
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, encode3(key, options)];
          }
          return [...result, [encode3(key, options), "=", encode3(value, options)].join("")];
        };
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case "index":
        return (key, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key);
          key = key.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = {};
          }
          accumulator[key][result[1]] = value;
        };
      case "bracket":
        return (key, value, accumulator) => {
          result = /(\[\])$/.exec(key);
          key = key.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "colon-list-separator":
        return (key, value, accumulator) => {
          result = /(:list)$/.exec(key);
          key = key.replace(/:list$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "comma":
      case "separator":
        return (key, value, accumulator) => {
          const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
          accumulator[key] = newValue;
        };
      case "bracket-separator":
        return (key, value, accumulator) => {
          const isArray2 = /(\[\])$/.test(key);
          key = key.replace(/\[\]$/, "");
          if (!isArray2) {
            accumulator[key] = value ? decode2(value, options) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
          if (accumulator[key] === void 0) {
            accumulator[key] = arrayValue;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], arrayValue);
        };
      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === void 0) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode3(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode2(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a2, b2) => Number(a2) - Number(b2)).map((key) => input[key]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash2(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash2 = url.slice(hashStart);
    }
    return hash2;
  }
  function extract2(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function parse2(query, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter2 = parserForArrayFormat(options);
    const ret = /* @__PURE__ */ Object.create(null);
    if (typeof query !== "string") {
      return ret;
    }
    query = query.trim().replace(/^[?#&]/, "");
    if (!query) {
      return ret;
    }
    for (const param of query.split("&")) {
      if (param === "") {
        continue;
      }
      let [key, value] = splitOnFirst2(options.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
      formatter2(decode2(key, options), value, ret);
    }
    for (const key of Object.keys(ret)) {
      const value = ret[key];
      if (typeof value === "object" && value !== null) {
        for (const k2 of Object.keys(value)) {
          value[k2] = parseValue(value[k2], options);
        }
      } else {
        ret[key] = parseValue(value, options);
      }
    }
    if (options.sort === false) {
      return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
      const value = ret[key];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  exports.extract = extract2;
  exports.parse = parse2;
  exports.stringify = (object, options) => {
    if (!object) {
      return "";
    }
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
    const formatter2 = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key of Object.keys(object)) {
      if (!shouldFilter(key)) {
        objectCopy[key] = object[key];
      }
    }
    const keys2 = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys2.sort(options.sort);
    }
    return keys2.map((key) => {
      const value = object[key];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode3(key, options);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === "bracket-separator") {
          return encode3(key, options) + "[]";
        }
        return value.reduce(formatter2(key), []).join("&");
      }
      return encode3(key, options) + "=" + encode3(value, options);
    }).filter((x2) => x2.length > 0).join("&");
  };
  exports.parseUrl = (url, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url_, hash2] = splitOnFirst2(url, "#");
    return Object.assign(
      {
        url: url_.split("?")[0] || "",
        query: parse2(extract2(url), options)
      },
      options && options.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options) } : {}
    );
  };
  exports.stringifyUrl = (object, options) => {
    options = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options);
    const url = removeHash(object.url).split("?")[0] || "";
    const queryFromUrl = exports.extract(object.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
    const query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString2 = exports.stringify(query, options);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash2 = getHash2(object.url);
    if (object.fragmentIdentifier) {
      hash2 = `#${options[encodeFragmentIdentifier] ? encode3(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString2}${hash2}`;
  };
  exports.pick = (input, filter2, options) => {
    options = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options);
    const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter2),
      fragmentIdentifier
    }, options);
  };
  exports.exclude = (input, filter2, options) => {
    const exclusionFilter = Array.isArray(filter2) ? (key) => !filter2.includes(key) : (key, value) => !filter2(key, value);
    return exports.pick(input, exclusionFilter, options);
  };
})(queryString);
function S$2(e2 = [], n2 = []) {
  return [.../* @__PURE__ */ new Set([...e2, ...n2])];
}
var Pt = Object.defineProperty, Rt = Object.defineProperties, Tt = Object.getOwnPropertyDescriptors, Ye$1 = Object.getOwnPropertySymbols, At = Object.prototype.hasOwnProperty, Ut = Object.prototype.propertyIsEnumerable, Je = (e2, n2, t2) => n2 in e2 ? Pt(e2, n2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[n2] = t2, _t = (e2, n2) => {
  for (var t2 in n2 || (n2 = {}))
    At.call(n2, t2) && Je(e2, t2, n2[t2]);
  if (Ye$1)
    for (var t2 of Ye$1(n2))
      Ut.call(n2, t2) && Je(e2, t2, n2[t2]);
  return e2;
}, Ct = (e2, n2) => Rt(e2, Tt(n2));
function oe$1(e2) {
  return e2.includes(":");
}
function en(e2) {
  return oe$1(e2) ? e2.split(":")[0] : e2;
}
function se$1(e2) {
  var n2, t2, r2;
  const o = {};
  if (!B$2(e2))
    return o;
  for (const [s, i2] of Object.entries(e2)) {
    const d2 = oe$1(s) ? [s] : i2.chains, l2 = i2.methods || [], c2 = i2.events || [], u2 = en(s);
    o[u2] = Ct(_t({}, o[u2]), { chains: S$2(d2, (n2 = o[u2]) == null ? void 0 : n2.chains), methods: S$2(l2, (t2 = o[u2]) == null ? void 0 : t2.methods), events: S$2(c2, (r2 = o[u2]) == null ? void 0 : r2.events) });
  }
  return o;
}
function B$2(e2) {
  return Object.getPrototypeOf(e2) === Object.prototype && Object.keys(e2).length;
}
var NAMESPACE = "eip155";
var STORE_KEY = "store";
var REQUESTED_CHAINS_KEY = "requestedChains";
var ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain";
var _provider$3, _initProviderPromise, _createProvider, createProvider_fn, _initProvider, initProvider_fn, _isChainsStale, isChainsStale_fn, _setupListeners, setupListeners_fn, _removeListeners, removeListeners_fn, _setRequestedChainsIds, setRequestedChainsIds_fn, _getRequestedChainsIds, getRequestedChainsIds_fn, _getNamespaceChainsIds, getNamespaceChainsIds_fn, _getNamespaceMethods, getNamespaceMethods_fn;
var WalletConnectConnector = class extends Connector {
  constructor(config2) {
    super({
      ...config2,
      options: { isNewChainsStale: true, ...config2.options }
    });
    __privateAdd$1(this, _createProvider);
    __privateAdd$1(this, _initProvider);
    __privateAdd$1(this, _isChainsStale);
    __privateAdd$1(this, _setupListeners);
    __privateAdd$1(this, _removeListeners);
    __privateAdd$1(this, _setRequestedChainsIds);
    __privateAdd$1(this, _getRequestedChainsIds);
    __privateAdd$1(this, _getNamespaceChainsIds);
    __privateAdd$1(this, _getNamespaceMethods);
    this.id = "walletConnect";
    this.name = "WalletConnect";
    this.ready = true;
    __privateAdd$1(this, _provider$3, void 0);
    __privateAdd$1(this, _initProviderPromise, void 0);
    this.onAccountsChanged = (accounts2) => {
      if (accounts2.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", { account: getAddress$3(accounts2[0]) });
    };
    this.onChainChanged = (chainId) => {
      const id2 = Number(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", { chain: { id: id2, unsupported } });
    };
    this.onDisconnect = () => {
      __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);
      this.emit("disconnect");
    };
    this.onDisplayUri = (uri) => {
      this.emit("message", { type: "display_uri", data: uri });
    };
    this.onConnect = () => {
      this.emit("connect", {});
    };
    __privateMethod$1(this, _createProvider, createProvider_fn).call(this);
  }
  async connect({ chainId, pairingTopic } = {}) {
    try {
      let targetChainId = chainId;
      if (!targetChainId) {
        const store = this.storage?.getItem(STORE_KEY);
        const lastUsedChainId = store?.state?.data?.chain?.id;
        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId))
          targetChainId = lastUsedChainId;
        else
          targetChainId = this.chains[0]?.id;
      }
      if (!targetChainId)
        throw new Error("No chains found on connector.");
      const provider2 = await this.getProvider();
      __privateMethod$1(this, _setupListeners, setupListeners_fn).call(this);
      const isChainsStale = __privateMethod$1(this, _isChainsStale, isChainsStale_fn).call(this);
      if (provider2.session && isChainsStale)
        await provider2.disconnect();
      if (!provider2.session || isChainsStale) {
        const optionalChains = this.chains.filter((chain2) => chain2.id !== targetChainId).map((optionalChain) => optionalChain.id);
        this.emit("message", { type: "connecting" });
        await provider2.connect({
          pairingTopic,
          optionalChains: [targetChainId, ...optionalChains]
        });
        __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, this.chains.map(({ id: id22 }) => id22));
      }
      const accounts2 = await provider2.enable();
      const account2 = getAddress$3(accounts2[0]);
      const id2 = await this.getChainId();
      const unsupported = this.isChainUnsupported(id2);
      return {
        account: account2,
        chain: { id: id2, unsupported }
      };
    } catch (error) {
      if (/user rejected/i.test(error?.message)) {
        throw new UserRejectedRequestError$1(error);
      }
      throw error;
    }
  }
  async disconnect() {
    const provider2 = await this.getProvider();
    try {
      await provider2.disconnect();
    } catch (error) {
      if (!/No matching key/i.test(error.message))
        throw error;
    } finally {
      __privateMethod$1(this, _removeListeners, removeListeners_fn).call(this);
      __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);
    }
  }
  async getAccount() {
    const { accounts: accounts2 } = await this.getProvider();
    return getAddress$3(accounts2[0]);
  }
  async getChainId() {
    const { chainId } = await this.getProvider();
    return chainId;
  }
  async getProvider({ chainId } = {}) {
    if (!__privateGet$1(this, _provider$3))
      await __privateMethod$1(this, _createProvider, createProvider_fn).call(this);
    if (chainId)
      await this.switchChain(chainId);
    return __privateGet$1(this, _provider$3);
  }
  async getWalletClient({
    chainId
  } = {}) {
    const [provider2, account2] = await Promise.all([
      this.getProvider({ chainId }),
      this.getAccount()
    ]);
    const chain2 = this.chains.find((x2) => x2.id === chainId);
    if (!provider2)
      throw new Error("provider is required.");
    return createWalletClient$1({
      account: account2,
      chain: chain2,
      transport: custom$3(provider2)
    });
  }
  async isAuthorized() {
    try {
      const [account2, provider2] = await Promise.all([
        this.getAccount(),
        this.getProvider()
      ]);
      const isChainsStale = __privateMethod$1(this, _isChainsStale, isChainsStale_fn).call(this);
      if (!account2)
        return false;
      if (isChainsStale && provider2.session) {
        try {
          await provider2.disconnect();
        } catch {
        }
        return false;
      }
      return true;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    const chain2 = this.chains.find((chain22) => chain22.id === chainId);
    if (!chain2)
      throw new SwitchChainError$1(new Error("chain not found on connector."));
    try {
      const provider2 = await this.getProvider();
      const namespaceChains = __privateMethod$1(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);
      const namespaceMethods = __privateMethod$1(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);
      const isChainApproved = namespaceChains.includes(chainId);
      if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
        await provider2.request({
          method: ADD_ETH_CHAIN_METHOD,
          params: [
            {
              chainId: numberToHex(chain2.id),
              blockExplorerUrls: [chain2.blockExplorers?.default?.url],
              chainName: chain2.name,
              nativeCurrency: chain2.nativeCurrency,
              rpcUrls: [...chain2.rpcUrls.default.http]
            }
          ]
        });
        const requestedChains = __privateMethod$1(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);
        requestedChains.push(chainId);
        __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, requestedChains);
      }
      await provider2.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: numberToHex(chainId) }]
      });
      return chain2;
    } catch (error) {
      const message = typeof error === "string" ? error : error?.message;
      if (/user rejected request/i.test(message)) {
        throw new UserRejectedRequestError$1(error);
      }
      throw new SwitchChainError$1(error);
    }
  }
};
_provider$3 = /* @__PURE__ */ new WeakMap();
_initProviderPromise = /* @__PURE__ */ new WeakMap();
_createProvider = /* @__PURE__ */ new WeakSet();
createProvider_fn = async function() {
  if (!__privateGet$1(this, _initProviderPromise) && typeof window !== "undefined") {
    __privateSet$1(this, _initProviderPromise, __privateMethod$1(this, _initProvider, initProvider_fn).call(this));
  }
  return __privateGet$1(this, _initProviderPromise);
};
_initProvider = /* @__PURE__ */ new WeakSet();
initProvider_fn = async function() {
  const { EthereumProvider } = await __vitePreload(() => import("./index.es-14ffc65d.js"), true ? ["assets/index.es-14ffc65d.js","assets/index-cd0a5607.js","assets/http-b176eb0b.js"] : void 0);
  const optionalChains = this.chains.map(({ id: id2 }) => id2);
  if (optionalChains.length) {
    const {
      projectId,
      showQrModal = true,
      qrModalOptions,
      metadata,
      relayUrl
    } = this.options;
    __privateSet$1(this, _provider$3, await EthereumProvider.init({
      showQrModal,
      qrModalOptions,
      projectId,
      optionalChains,
      rpcMap: Object.fromEntries(
        this.chains.map((chain2) => [
          chain2.id,
          chain2.rpcUrls.default.http[0]
        ])
      ),
      metadata,
      relayUrl
    }));
  }
};
_isChainsStale = /* @__PURE__ */ new WeakSet();
isChainsStale_fn = function() {
  const namespaceMethods = __privateMethod$1(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);
  if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD))
    return false;
  if (!this.options.isNewChainsStale)
    return false;
  const requestedChains = __privateMethod$1(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);
  const connectorChains = this.chains.map(({ id: id2 }) => id2);
  const namespaceChains = __privateMethod$1(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);
  if (namespaceChains.length && !namespaceChains.some((id2) => connectorChains.includes(id2)))
    return false;
  return !connectorChains.every((id2) => requestedChains.includes(id2));
};
_setupListeners = /* @__PURE__ */ new WeakSet();
setupListeners_fn = function() {
  if (!__privateGet$1(this, _provider$3))
    return;
  __privateMethod$1(this, _removeListeners, removeListeners_fn).call(this);
  __privateGet$1(this, _provider$3).on("accountsChanged", this.onAccountsChanged);
  __privateGet$1(this, _provider$3).on("chainChanged", this.onChainChanged);
  __privateGet$1(this, _provider$3).on("disconnect", this.onDisconnect);
  __privateGet$1(this, _provider$3).on("session_delete", this.onDisconnect);
  __privateGet$1(this, _provider$3).on("display_uri", this.onDisplayUri);
  __privateGet$1(this, _provider$3).on("connect", this.onConnect);
};
_removeListeners = /* @__PURE__ */ new WeakSet();
removeListeners_fn = function() {
  if (!__privateGet$1(this, _provider$3))
    return;
  __privateGet$1(this, _provider$3).removeListener("accountsChanged", this.onAccountsChanged);
  __privateGet$1(this, _provider$3).removeListener("chainChanged", this.onChainChanged);
  __privateGet$1(this, _provider$3).removeListener("disconnect", this.onDisconnect);
  __privateGet$1(this, _provider$3).removeListener("session_delete", this.onDisconnect);
  __privateGet$1(this, _provider$3).removeListener("display_uri", this.onDisplayUri);
  __privateGet$1(this, _provider$3).removeListener("connect", this.onConnect);
};
_setRequestedChainsIds = /* @__PURE__ */ new WeakSet();
setRequestedChainsIds_fn = function(chains2) {
  this.storage?.setItem(REQUESTED_CHAINS_KEY, chains2);
};
_getRequestedChainsIds = /* @__PURE__ */ new WeakSet();
getRequestedChainsIds_fn = function() {
  return this.storage?.getItem(REQUESTED_CHAINS_KEY) ?? [];
};
_getNamespaceChainsIds = /* @__PURE__ */ new WeakSet();
getNamespaceChainsIds_fn = function() {
  if (!__privateGet$1(this, _provider$3))
    return [];
  const namespaces = __privateGet$1(this, _provider$3).session?.namespaces;
  if (!namespaces)
    return [];
  const normalizedNamespaces = se$1(namespaces);
  const chainIds = normalizedNamespaces[NAMESPACE]?.chains?.map(
    (chain2) => parseInt(chain2.split(":")[1] || "")
  );
  return chainIds ?? [];
};
_getNamespaceMethods = /* @__PURE__ */ new WeakSet();
getNamespaceMethods_fn = function() {
  if (!__privateGet$1(this, _provider$3))
    return [];
  const namespaces = __privateGet$1(this, _provider$3).session?.namespaces;
  if (!namespaces)
    return [];
  const normalizedNamespaces = se$1(namespaces);
  const methods2 = normalizedNamespaces[NAMESPACE]?.methods;
  return methods2 ?? [];
};
var switchChainAllowedRegex = /(imtoken|metamask|rainbow|trust wallet|uniswap wallet|ledger)/i;
var _provider$2, _switchChain, switchChain_fn;
var WalletConnectLegacyConnector = class extends Connector {
  constructor() {
    super(...arguments);
    __privateAdd$1(this, _switchChain);
    this.id = "walletConnectLegacy";
    this.name = "WalletConnectLegacy";
    this.ready = true;
    __privateAdd$1(this, _provider$2, void 0);
    this.onAccountsChanged = (accounts2) => {
      if (accounts2.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", { account: getAddress$3(accounts2[0]) });
    };
    this.onChainChanged = (chainId) => {
      const id2 = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", { chain: { id: id2, unsupported } });
    };
    this.onDisconnect = () => {
      this.emit("disconnect");
    };
  }
  async connect({ chainId } = {}) {
    try {
      let targetChainId = chainId;
      if (!targetChainId) {
        const store = this.storage?.getItem("store");
        const lastUsedChainId = store?.state?.data?.chain?.id;
        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId))
          targetChainId = lastUsedChainId;
      }
      const provider2 = await this.getProvider({
        chainId: targetChainId,
        create: true
      });
      provider2.on("accountsChanged", this.onAccountsChanged);
      provider2.on("chainChanged", this.onChainChanged);
      provider2.on("disconnect", this.onDisconnect);
      setTimeout(() => this.emit("message", { type: "connecting" }), 0);
      const accounts2 = await provider2.enable();
      const account2 = getAddress$3(accounts2[0]);
      const id2 = await this.getChainId();
      const unsupported = this.isChainUnsupported(id2);
      const walletName = provider2.connector?.peerMeta?.name ?? "";
      if (switchChainAllowedRegex.test(walletName))
        this.switchChain = __privateMethod$1(this, _switchChain, switchChain_fn);
      return {
        account: account2,
        chain: { id: id2, unsupported }
      };
    } catch (error) {
      if (/user closed modal/i.test(error.message))
        throw new UserRejectedRequestError$1(error);
      throw error;
    }
  }
  async disconnect() {
    const provider2 = await this.getProvider();
    await provider2.disconnect();
    provider2.removeListener("accountsChanged", this.onAccountsChanged);
    provider2.removeListener("chainChanged", this.onChainChanged);
    provider2.removeListener("disconnect", this.onDisconnect);
    typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
  }
  async getAccount() {
    const provider2 = await this.getProvider();
    const accounts2 = provider2.accounts;
    return getAddress$3(accounts2[0]);
  }
  async getChainId() {
    const provider2 = await this.getProvider();
    const chainId = normalizeChainId(provider2.chainId);
    return chainId;
  }
  async getProvider({
    chainId,
    create: create5
  } = {}) {
    if (!__privateGet$1(this, _provider$2) || chainId || create5) {
      const rpc2 = !this.options?.infuraId ? this.chains.reduce(
        (rpc22, chain2) => ({
          ...rpc22,
          [chain2.id]: chain2.rpcUrls.default.http[0]
        }),
        {}
      ) : {};
      const WalletConnectProvider = (await __vitePreload(() => import("./index-e5833e58.js"), true ? ["assets/index-e5833e58.js","assets/http-b176eb0b.js","assets/index-cd0a5607.js","assets/hooks.module-42a01bdb.js"] : void 0)).default;
      __privateSet$1(this, _provider$2, new WalletConnectProvider({
        ...this.options,
        chainId,
        rpc: { ...rpc2, ...this.options?.rpc }
      }));
      __privateGet$1(this, _provider$2).http = await __privateGet$1(this, _provider$2).setHttpProvider(chainId);
    }
    return __privateGet$1(this, _provider$2);
  }
  async getWalletClient({
    chainId
  } = {}) {
    const [provider2, account2] = await Promise.all([
      this.getProvider({ chainId }),
      this.getAccount()
    ]);
    const chain2 = this.chains.find((x2) => x2.id === chainId);
    if (!provider2)
      throw new Error("provider is required.");
    return createWalletClient$1({
      account: account2,
      chain: chain2,
      transport: custom$3(provider2)
    });
  }
  async isAuthorized() {
    try {
      const account2 = await this.getAccount();
      return !!account2;
    } catch {
      return false;
    }
  }
};
_provider$2 = /* @__PURE__ */ new WeakMap();
_switchChain = /* @__PURE__ */ new WeakSet();
switchChain_fn = async function(chainId) {
  const provider2 = await this.getProvider();
  const id2 = numberToHex(chainId);
  try {
    await Promise.race([
      provider2.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: id2 }]
      }),
      new Promise(
        (res) => this.on("change", ({ chain: chain2 }) => {
          if (chain2?.id === chainId)
            res(chainId);
        })
      )
    ]);
    return this.chains.find((x2) => x2.id === chainId) ?? {
      id: chainId,
      name: `Chain ${id2}`,
      network: `${id2}`,
      nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
      rpcUrls: { default: { http: [""] }, public: { http: [""] } }
    };
  } catch (error) {
    const message = typeof error === "string" ? error : error?.message;
    if (/user rejected request/i.test(message))
      throw new UserRejectedRequestError$1(error);
    throw new SwitchChainError$1(error);
  }
};
var _client, _provider$1;
var CoinbaseWalletConnector = class extends Connector {
  constructor({ chains: chains2, options }) {
    super({
      chains: chains2,
      options: {
        reloadOnDisconnect: false,
        ...options
      }
    });
    this.id = "coinbaseWallet";
    this.name = "Coinbase Wallet";
    this.ready = true;
    __privateAdd$1(this, _client, void 0);
    __privateAdd$1(this, _provider$1, void 0);
    this.onAccountsChanged = (accounts2) => {
      if (accounts2.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", { account: getAddress$3(accounts2[0]) });
    };
    this.onChainChanged = (chainId) => {
      const id2 = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", { chain: { id: id2, unsupported } });
    };
    this.onDisconnect = () => {
      this.emit("disconnect");
    };
  }
  async connect({ chainId } = {}) {
    try {
      const provider2 = await this.getProvider();
      provider2.on("accountsChanged", this.onAccountsChanged);
      provider2.on("chainChanged", this.onChainChanged);
      provider2.on("disconnect", this.onDisconnect);
      this.emit("message", { type: "connecting" });
      const accounts2 = await provider2.enable();
      const account2 = getAddress$3(accounts2[0]);
      let id2 = await this.getChainId();
      let unsupported = this.isChainUnsupported(id2);
      if (chainId && id2 !== chainId) {
        const chain2 = await this.switchChain(chainId);
        id2 = chain2.id;
        unsupported = this.isChainUnsupported(id2);
      }
      return {
        account: account2,
        chain: { id: id2, unsupported }
      };
    } catch (error) {
      if (/(user closed modal|accounts received is empty)/i.test(
        error.message
      ))
        throw new UserRejectedRequestError$1(error);
      throw error;
    }
  }
  async disconnect() {
    if (!__privateGet$1(this, _provider$1))
      return;
    const provider2 = await this.getProvider();
    provider2.removeListener("accountsChanged", this.onAccountsChanged);
    provider2.removeListener("chainChanged", this.onChainChanged);
    provider2.removeListener("disconnect", this.onDisconnect);
    provider2.disconnect();
    provider2.close();
  }
  async getAccount() {
    const provider2 = await this.getProvider();
    const accounts2 = await provider2.request({
      method: "eth_accounts"
    });
    return getAddress$3(accounts2[0]);
  }
  async getChainId() {
    const provider2 = await this.getProvider();
    const chainId = normalizeChainId(provider2.chainId);
    return chainId;
  }
  async getProvider() {
    if (!__privateGet$1(this, _provider$1)) {
      let CoinbaseWalletSDK = (await __vitePreload(() => import("./index-54bd28c8.js").then((n2) => n2.i), true ? ["assets/index-54bd28c8.js","assets/index-cd0a5607.js","assets/hooks.module-42a01bdb.js"] : void 0)).default;
      if (typeof CoinbaseWalletSDK !== "function" && typeof CoinbaseWalletSDK.default === "function")
        CoinbaseWalletSDK = CoinbaseWalletSDK.default;
      __privateSet$1(this, _client, new CoinbaseWalletSDK(this.options));
      const walletExtensionChainId = __privateGet$1(this, _client).walletExtension?.getChainId();
      const chain2 = this.chains.find(
        (chain22) => this.options.chainId ? chain22.id === this.options.chainId : chain22.id === walletExtensionChainId
      ) || this.chains[0];
      const chainId = this.options.chainId || chain2?.id;
      const jsonRpcUrl = this.options.jsonRpcUrl || chain2?.rpcUrls.default.http[0];
      __privateSet$1(this, _provider$1, __privateGet$1(this, _client).makeWeb3Provider(jsonRpcUrl, chainId));
    }
    return __privateGet$1(this, _provider$1);
  }
  async getWalletClient({
    chainId
  } = {}) {
    const [provider2, account2] = await Promise.all([
      this.getProvider(),
      this.getAccount()
    ]);
    const chain2 = this.chains.find((x2) => x2.id === chainId);
    if (!provider2)
      throw new Error("provider is required.");
    return createWalletClient$1({
      account: account2,
      chain: chain2,
      transport: custom$3(provider2)
    });
  }
  async isAuthorized() {
    try {
      const account2 = await this.getAccount();
      return !!account2;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    const provider2 = await this.getProvider();
    const id2 = numberToHex(chainId);
    try {
      await provider2.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: id2 }]
      });
      return this.chains.find((x2) => x2.id === chainId) ?? {
        id: chainId,
        name: `Chain ${id2}`,
        network: `${id2}`,
        nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
        rpcUrls: { default: { http: [""] }, public: { http: [""] } }
      };
    } catch (error) {
      const chain2 = this.chains.find((x2) => x2.id === chainId);
      if (!chain2)
        throw new ChainNotConfiguredForConnectorError({
          chainId,
          connectorId: this.id
        });
      if (error.code === 4902) {
        try {
          await provider2.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: id2,
                chainName: chain2.name,
                nativeCurrency: chain2.nativeCurrency,
                rpcUrls: [chain2.rpcUrls.public?.http[0] ?? ""],
                blockExplorerUrls: this.getBlockExplorerUrls(chain2)
              }
            ]
          });
          return chain2;
        } catch (error2) {
          throw new UserRejectedRequestError$1(error2);
        }
      }
      throw new SwitchChainError$1(error);
    }
  }
  async watchAsset({
    address: address2,
    decimals = 18,
    image,
    symbol: symbol2
  }) {
    const provider2 = await this.getProvider();
    return provider2.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address: address2,
          decimals,
          image,
          symbol: symbol2
        }
      }
    });
  }
};
_client = /* @__PURE__ */ new WeakMap();
_provider$1 = /* @__PURE__ */ new WeakMap();
var dist$4 = {};
var provider$1 = {};
var events$1 = { exports: {} };
var R$1 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R$1 && typeof R$1.apply === "function" ? R$1.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R$1 && typeof R$1.ownKeys === "function") {
  ReflectOwnKeys = R$1.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning2) {
  if (console && console.warn)
    console.warn(warning2);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events$1.exports = EventEmitter$1;
var once_1 = events$1.exports.once = once;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter$1.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
  }
  this._maxListeners = n2;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$1.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter$1.prototype.emit = function emit(type) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++)
    args.push(arguments[i2]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len2 = handler.length;
    var listeners2 = arrayClone(handler, len2);
    for (var i2 = 0; i2 < len2; ++i2)
      ReflectApply(listeners2[i2], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter$1.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter$1.prototype.once = function once2(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$1.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$1.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i2, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length - 1; i2 >= 0; i2--) {
      if (list[i2] === listener || list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i2;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    var key;
    for (i2 = 0; i2 < keys2.length; ++i2) {
      key = keys2[i2];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
      this.removeListener(type, listeners2[i2]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter$1.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter$1.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter$1.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter$1.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n2) {
  var copy2 = new Array(n2);
  for (var i2 = 0; i2 < n2; ++i2)
    copy2[i2] = arr[i2];
  return copy2;
}
function spliceOne(list, index2) {
  for (; index2 + 1 < list.length; index2++)
    list[index2] = list[index2 + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
function once(emitter, name2) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name2, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
    if (name2 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name2, listener);
    } else {
      emitter.on(name2, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name2, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name2, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var eventsExports = events$1.exports;
const EventEmitter$2 = /* @__PURE__ */ getDefaultExportFromCjs(eventsExports);
const events = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: EventEmitter$2,
  once: once_1
}, [eventsExports]);
const require$$0$$ = /* @__PURE__ */ getAugmentedNamespace(events);
var utils$m = {};
Object.defineProperty(utils$m, "__esModule", { value: true });
var getLowerCase_1 = utils$m.getLowerCase = void 0;
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
getLowerCase_1 = utils$m.getLowerCase = getLowerCase;
const utils$l = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$m,
  get getLowerCase() {
    return getLowerCase_1;
  }
}, [utils$m]);
const require$$1$z = /* @__PURE__ */ getAugmentedNamespace(utils$l);
Object.defineProperty(provider$1, "__esModule", { value: true });
var SafeAppProvider_1 = provider$1.SafeAppProvider = void 0;
const events_1 = require$$0$$;
const utils_1$3 = require$$1$z;
class SafeAppProvider extends events_1.EventEmitter {
  constructor(safe2, sdk2) {
    super();
    this.submittedTxs = /* @__PURE__ */ new Map();
    this.safe = safe2;
    this.sdk = sdk2;
  }
  async connect() {
    this.emit("connect", { chainId: this.chainId });
    return;
  }
  async disconnect() {
    return;
  }
  get chainId() {
    return this.safe.chainId;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async request(request2) {
    const { method, params = [] } = request2;
    switch (method) {
      case "eth_accounts":
        return [this.safe.safeAddress];
      case "net_version":
      case "eth_chainId":
        return `0x${this.chainId.toString(16)}`;
      case "personal_sign": {
        const [message, address2] = params;
        if (this.safe.safeAddress.toLowerCase() !== address2.toLowerCase()) {
          throw new Error("The address or message hash is invalid");
        }
        const response = await this.sdk.txs.signMessage(message);
        const signature2 = "signature" in response ? response.signature : void 0;
        return signature2 || "0x";
      }
      case "eth_sign": {
        const [address2, messageHash] = params;
        if (this.safe.safeAddress.toLowerCase() !== address2.toLowerCase() || !messageHash.startsWith("0x")) {
          throw new Error("The address or message hash is invalid");
        }
        const response = await this.sdk.txs.signMessage(messageHash);
        const signature2 = "signature" in response ? response.signature : void 0;
        return signature2 || "0x";
      }
      case "eth_signTypedData":
      case "eth_signTypedData_v4": {
        const [address2, typedData2] = params;
        const parsedTypedData = typeof typedData2 === "string" ? JSON.parse(typedData2) : typedData2;
        if (this.safe.safeAddress.toLowerCase() !== address2.toLowerCase()) {
          throw new Error("The address is invalid");
        }
        const response = await this.sdk.txs.signTypedMessage(parsedTypedData);
        const signature2 = "signature" in response ? response.signature : void 0;
        return signature2 || "0x";
      }
      case "eth_sendTransaction":
        const tx = {
          ...params[0],
          value: params[0].value || "0",
          data: params[0].data || "0x"
        };
        if (typeof tx.gas === "string" && tx.gas.startsWith("0x")) {
          tx.gas = parseInt(tx.gas, 16);
        }
        const resp = await this.sdk.txs.send({
          txs: [tx],
          params: { safeTxGas: tx.gas }
        });
        this.submittedTxs.set(resp.safeTxHash, {
          from: this.safe.safeAddress,
          hash: resp.safeTxHash,
          gas: 0,
          gasPrice: "0x00",
          nonce: 0,
          input: tx.data,
          value: tx.value,
          to: tx.to,
          blockHash: null,
          blockNumber: null,
          transactionIndex: null
        });
        return resp.safeTxHash;
      case "eth_blockNumber":
        const block2 = await this.sdk.eth.getBlockByNumber(["latest"]);
        return block2.number;
      case "eth_getBalance":
        return this.sdk.eth.getBalance([(0, utils_1$3.getLowerCase)(params[0]), params[1]]);
      case "eth_getCode":
        return this.sdk.eth.getCode([(0, utils_1$3.getLowerCase)(params[0]), params[1]]);
      case "eth_getTransactionCount":
        return this.sdk.eth.getTransactionCount([(0, utils_1$3.getLowerCase)(params[0]), params[1]]);
      case "eth_getStorageAt":
        return this.sdk.eth.getStorageAt([(0, utils_1$3.getLowerCase)(params[0]), params[1], params[2]]);
      case "eth_getBlockByNumber":
        return this.sdk.eth.getBlockByNumber([params[0], params[1]]);
      case "eth_getBlockByHash":
        return this.sdk.eth.getBlockByHash([params[0], params[1]]);
      case "eth_getTransactionByHash":
        let txHash = params[0];
        try {
          const resp2 = await this.sdk.txs.getBySafeTxHash(txHash);
          txHash = resp2.txHash || txHash;
        } catch (e2) {
        }
        if (this.submittedTxs.has(txHash)) {
          return this.submittedTxs.get(txHash);
        }
        return this.sdk.eth.getTransactionByHash([txHash]).then((tx2) => {
          if (tx2) {
            tx2.hash = params[0];
          }
          return tx2;
        });
      case "eth_getTransactionReceipt": {
        let txHash2 = params[0];
        try {
          const resp2 = await this.sdk.txs.getBySafeTxHash(txHash2);
          txHash2 = resp2.txHash || txHash2;
        } catch (e2) {
        }
        return this.sdk.eth.getTransactionReceipt([txHash2]).then((tx2) => {
          if (tx2) {
            tx2.transactionHash = params[0];
          }
          return tx2;
        });
      }
      case "eth_estimateGas": {
        return this.sdk.eth.getEstimateGas(params[0]);
      }
      case "eth_call": {
        return this.sdk.eth.call([params[0], params[1]]);
      }
      case "eth_getLogs":
        return this.sdk.eth.getPastLogs([params[0]]);
      case "eth_gasPrice":
        return this.sdk.eth.getGasPrice();
      case "wallet_getPermissions":
        return this.sdk.wallet.getPermissions();
      case "wallet_requestPermissions":
        return this.sdk.wallet.requestPermissions(params[0]);
      case "safe_setSettings":
        return this.sdk.eth.setSafeSettings([params[0]]);
      default:
        throw Error(`"${request2.method}" not implemented`);
    }
  }
  // this method is needed for ethers v4
  // https://github.com/ethers-io/ethers.js/blob/427e16826eb15d52d25c4f01027f8db22b74b76c/src.ts/providers/web3-provider.ts#L41-L55
  send(request2, callback) {
    if (!request2)
      callback("Undefined request");
    this.request(request2).then((result) => callback(null, { jsonrpc: "2.0", id: request2.id, result })).catch((error) => callback(error, null));
  }
}
SafeAppProvider_1 = provider$1.SafeAppProvider = SafeAppProvider;
const provider = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get SafeAppProvider() {
    return SafeAppProvider_1;
  },
  default: provider$1
}, [provider$1]);
const require$$0$_ = /* @__PURE__ */ getAugmentedNamespace(provider);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SafeAppProvider = void 0;
  var provider_1 = require$$0$_;
  Object.defineProperty(exports, "SafeAppProvider", { enumerable: true, get: function() {
    return provider_1.SafeAppProvider;
  } });
})(dist$4);
var src$2 = {};
var sdk$3 = {};
var communication$1 = {};
var messageFormatter$1 = {};
var utils$k = {};
const name$3 = "@safe-global/safe-apps-sdk";
const version$7 = "8.1.0";
const description = "SDK developed to integrate third-party apps with Safe app.";
const main = "dist/src/index.js";
const typings = "dist/src/index.d.ts";
const _files = [
  "dist/**/*",
  "src/**/*",
  "CHANGELOG.md",
  "README.md"
];
const sideEffects = false;
const keywords = [
  "Safe",
  "sdk",
  "apps"
];
const scripts = {
  test: "jest",
  "format-dist": `sed -i '' 's/"files":/"_files":/' dist/package.json`,
  build: "yarn rimraf dist && tsc && yarn format-dist"
};
const author = "Safe (https://safe.global)";
const license = "MIT";
const dependencies = {
  "@safe-global/safe-gateway-typescript-sdk": "^3.5.3",
  viem: "^1.0.0"
};
const repository = {
  type: "git",
  url: "git+https://github.com/safe-global/safe-apps-sdk.git"
};
const bugs = {
  url: "https://github.com/safe-global/safe-apps-sdk/issues"
};
const homepage = "https://github.com/safe-global/safe-apps-sdk#readme";
const publishConfig = {
  access: "public"
};
const require$$0$Z = {
  name: name$3,
  version: version$7,
  description,
  main,
  typings,
  _files,
  sideEffects,
  keywords,
  scripts,
  author,
  license,
  dependencies,
  repository,
  bugs,
  homepage,
  publishConfig
};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(utils$k, "__esModule", { value: true });
var getSDKVersion_1 = utils$k.getSDKVersion = void 0;
const package_json_1 = __importDefault$2(require$$0$Z);
const getSDKVersion = () => {
  return package_json_1.default.version.split("-")[0];
};
getSDKVersion_1 = utils$k.getSDKVersion = getSDKVersion;
const utils$j = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$k,
  get getSDKVersion() {
    return getSDKVersion_1;
  }
}, [utils$k]);
const require$$4$d = /* @__PURE__ */ getAugmentedNamespace(utils$j);
var utils$i = {};
Object.defineProperty(utils$i, "__esModule", { value: true });
var generateRequestId_1 = utils$i.generateRequestId = void 0;
const dec2hex = (dec) => dec.toString(16).padStart(2, "0");
const generateId = (len2) => {
  const arr = new Uint8Array((len2 || 40) / 2);
  window.crypto.getRandomValues(arr);
  return Array.from(arr, dec2hex).join("");
};
const generateRequestId = () => {
  if (typeof window !== "undefined") {
    return generateId(10);
  }
  return (/* @__PURE__ */ new Date()).getTime().toString(36);
};
generateRequestId_1 = utils$i.generateRequestId = generateRequestId;
const utils$h = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$i,
  get generateRequestId() {
    return generateRequestId_1;
  }
}, [utils$i]);
const require$$1$y = /* @__PURE__ */ getAugmentedNamespace(utils$h);
Object.defineProperty(messageFormatter$1, "__esModule", { value: true });
var MessageFormatter_1 = messageFormatter$1.MessageFormatter = void 0;
const utils_1$2 = require$$4$d;
const utils_2 = require$$1$y;
class MessageFormatter {
}
MessageFormatter_1 = messageFormatter$1.MessageFormatter = MessageFormatter;
MessageFormatter.makeRequest = (method, params) => {
  const id2 = (0, utils_2.generateRequestId)();
  return {
    id: id2,
    method,
    params,
    env: {
      sdkVersion: (0, utils_1$2.getSDKVersion)()
    }
  };
};
MessageFormatter.makeResponse = (id2, data2, version2) => ({
  id: id2,
  success: true,
  version: version2,
  data: data2
});
MessageFormatter.makeErrorResponse = (id2, error, version2) => ({
  id: id2,
  success: false,
  error,
  version: version2
});
const messageFormatter = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get MessageFormatter() {
    return MessageFormatter_1;
  },
  default: messageFormatter$1
}, [messageFormatter$1]);
const require$$3$j = /* @__PURE__ */ getAugmentedNamespace(messageFormatter);
var methods$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RestrictedMethods = exports.Methods = void 0;
  (function(Methods) {
    Methods["sendTransactions"] = "sendTransactions";
    Methods["rpcCall"] = "rpcCall";
    Methods["getChainInfo"] = "getChainInfo";
    Methods["getSafeInfo"] = "getSafeInfo";
    Methods["getTxBySafeTxHash"] = "getTxBySafeTxHash";
    Methods["getSafeBalances"] = "getSafeBalances";
    Methods["signMessage"] = "signMessage";
    Methods["signTypedMessage"] = "signTypedMessage";
    Methods["getEnvironmentInfo"] = "getEnvironmentInfo";
    Methods["getOffChainSignature"] = "getOffChainSignature";
    Methods["requestAddressBook"] = "requestAddressBook";
    Methods["wallet_getPermissions"] = "wallet_getPermissions";
    Methods["wallet_requestPermissions"] = "wallet_requestPermissions";
  })(exports.Methods || (exports.Methods = {}));
  (function(RestrictedMethods) {
    RestrictedMethods["requestAddressBook"] = "requestAddressBook";
  })(exports.RestrictedMethods || (exports.RestrictedMethods = {}));
})(methods$2);
const methods = /* @__PURE__ */ getDefaultExportFromCjs(methods$2);
const methods$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: methods
}, [methods$2]);
const require$$2$m = /* @__PURE__ */ getAugmentedNamespace(methods$1);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const messageFormatter_1 = require$$3$j;
  class PostMessageCommunicator {
    constructor(allowedOrigins = null, debugMode = false) {
      this.allowedOrigins = null;
      this.callbacks = /* @__PURE__ */ new Map();
      this.debugMode = false;
      this.isServer = typeof window === "undefined";
      this.isValidMessage = ({ origin, data: data2, source }) => {
        const emptyOrMalformed = !data2;
        const sentFromParentEl = !this.isServer && source === window.parent;
        const majorVersionNumber = typeof data2.version !== "undefined" && parseInt(data2.version.split(".")[0]);
        const allowedSDKVersion = majorVersionNumber >= 1;
        let validOrigin = true;
        if (Array.isArray(this.allowedOrigins)) {
          validOrigin = this.allowedOrigins.find((regExp) => regExp.test(origin)) !== void 0;
        }
        return !emptyOrMalformed && sentFromParentEl && allowedSDKVersion && validOrigin;
      };
      this.logIncomingMessage = (msg) => {
        console.info(`Safe Apps SDK v1: A message was received from origin ${msg.origin}. `, msg.data);
      };
      this.onParentMessage = (msg) => {
        if (this.isValidMessage(msg)) {
          this.debugMode && this.logIncomingMessage(msg);
          this.handleIncomingMessage(msg.data);
        }
      };
      this.handleIncomingMessage = (payload) => {
        const { id: id2 } = payload;
        const cb2 = this.callbacks.get(id2);
        if (cb2) {
          cb2(payload);
          this.callbacks.delete(id2);
        }
      };
      this.send = (method, params) => {
        const request2 = messageFormatter_1.MessageFormatter.makeRequest(method, params);
        if (this.isServer) {
          throw new Error("Window doesn't exist");
        }
        window.parent.postMessage(request2, "*");
        return new Promise((resolve, reject) => {
          this.callbacks.set(request2.id, (response) => {
            if (!response.success) {
              reject(new Error(response.error));
              return;
            }
            resolve(response);
          });
        });
      };
      this.allowedOrigins = allowedOrigins;
      this.debugMode = debugMode;
      if (!this.isServer) {
        window.addEventListener("message", this.onParentMessage);
      }
    }
  }
  exports.default = PostMessageCommunicator;
  __exportStar2(require$$2$m, exports);
})(communication$1);
const index$h = /* @__PURE__ */ getDefaultExportFromCjs(communication$1);
const communication = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$h
}, [communication$1]);
const require$$0$Y = /* @__PURE__ */ getAugmentedNamespace(communication);
var txs$1 = {};
var types$3 = {};
var sdk$2 = {};
Object.defineProperty(sdk$2, "__esModule", { value: true });
var isObjectEIP712TypedData_1 = sdk$2.isObjectEIP712TypedData = void 0;
const isObjectEIP712TypedData = (obj) => {
  return typeof obj === "object" && obj != null && "domain" in obj && "types" in obj && "message" in obj;
};
isObjectEIP712TypedData_1 = sdk$2.isObjectEIP712TypedData = isObjectEIP712TypedData;
const sdk$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sdk$2,
  get isObjectEIP712TypedData() {
    return isObjectEIP712TypedData_1;
  }
}, [sdk$2]);
const require$$0$X = /* @__PURE__ */ getAugmentedNamespace(sdk$1);
var rpc$9 = {};
Object.defineProperty(rpc$9, "__esModule", { value: true });
const rpc$8 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: rpc$9
}, [rpc$9]);
const require$$1$x = /* @__PURE__ */ getAugmentedNamespace(rpc$8);
var gateway$2 = {};
var dist$3 = {};
var endpoint$1 = {};
var utils$g = {};
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(utils$g, "__esModule", { value: true });
var deleteData_1 = utils$g.deleteData = fetchData_1 = utils$g.fetchData = stringifyQuery_1 = utils$g.stringifyQuery = insertParams_1 = utils$g.insertParams = void 0;
const isErrorResponse = (data2) => {
  const isObject2 = typeof data2 === "object" && data2 !== null;
  return isObject2 && "code" in data2 && "message" in data2;
};
function replaceParam(str, key, value) {
  return str.replace(new RegExp(`\\{${key}\\}`, "g"), value);
}
function insertParams(template, params) {
  return params ? Object.keys(params).reduce((result, key) => {
    return replaceParam(result, key, String(params[key]));
  }, template) : template;
}
var insertParams_1 = utils$g.insertParams = insertParams;
function stringifyQuery(query) {
  if (!query) {
    return "";
  }
  const searchParams = new URLSearchParams();
  Object.keys(query).forEach((key) => {
    if (query[key] != null) {
      searchParams.append(key, String(query[key]));
    }
  });
  const searchString = searchParams.toString();
  return searchString ? `?${searchString}` : "";
}
var stringifyQuery_1 = utils$g.stringifyQuery = stringifyQuery;
function parseResponse(resp) {
  return __awaiter(this, void 0, void 0, function* () {
    let json;
    try {
      json = yield resp.json();
    } catch (_a2) {
      if (resp.headers && resp.headers.get("content-length") !== "0") {
        throw new Error(`Invalid response content: ${resp.statusText}`);
      }
    }
    if (!resp.ok) {
      const errTxt = isErrorResponse(json) ? `${json.code}: ${json.message}` : resp.statusText;
      throw new Error(errTxt);
    }
    return json;
  });
}
function fetchData(url, body) {
  return __awaiter(this, void 0, void 0, function* () {
    let options;
    if (body != null) {
      options = {
        method: "POST",
        body: typeof body === "string" ? body : JSON.stringify(body),
        headers: { "Content-Type": "application/json" }
      };
    }
    const resp = yield fetch(url, options);
    return parseResponse(resp);
  });
}
var fetchData_1 = utils$g.fetchData = fetchData;
function deleteData(url) {
  return __awaiter(this, void 0, void 0, function* () {
    const options = {
      method: "DELETE"
    };
    const resp = yield fetch(url, options);
    return parseResponse(resp);
  });
}
deleteData_1 = utils$g.deleteData = deleteData;
const utils$f = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$g,
  get deleteData() {
    return deleteData_1;
  },
  get fetchData() {
    return fetchData_1;
  },
  get insertParams() {
    return insertParams_1;
  },
  get stringifyQuery() {
    return stringifyQuery_1;
  }
}, [utils$g]);
const require$$0$W = /* @__PURE__ */ getAugmentedNamespace(utils$f);
Object.defineProperty(endpoint$1, "__esModule", { value: true });
var deleteEndpoint_1 = endpoint$1.deleteEndpoint = getEndpoint_1 = endpoint$1.getEndpoint = postEndpoint_1 = endpoint$1.postEndpoint = void 0;
const utils_1$1 = require$$0$W;
function makeUrl(baseUrl, path, pathParams, query) {
  const pathname = (0, utils_1$1.insertParams)(path, pathParams);
  const search = (0, utils_1$1.stringifyQuery)(query);
  return `${baseUrl}${pathname}${search}`;
}
function postEndpoint(baseUrl, path, params) {
  const url = makeUrl(baseUrl, path, params === null || params === void 0 ? void 0 : params.path, params === null || params === void 0 ? void 0 : params.query);
  return (0, utils_1$1.fetchData)(url, params === null || params === void 0 ? void 0 : params.body);
}
var postEndpoint_1 = endpoint$1.postEndpoint = postEndpoint;
function getEndpoint(baseUrl, path, params, rawUrl) {
  if (rawUrl) {
    return (0, utils_1$1.fetchData)(rawUrl);
  }
  const url = makeUrl(baseUrl, path, params === null || params === void 0 ? void 0 : params.path, params === null || params === void 0 ? void 0 : params.query);
  return (0, utils_1$1.fetchData)(url);
}
var getEndpoint_1 = endpoint$1.getEndpoint = getEndpoint;
function deleteEndpoint(baseUrl, path, params) {
  const url = makeUrl(baseUrl, path, params === null || params === void 0 ? void 0 : params.path);
  return (0, utils_1$1.deleteData)(url);
}
deleteEndpoint_1 = endpoint$1.deleteEndpoint = deleteEndpoint;
const endpoint = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: endpoint$1,
  get deleteEndpoint() {
    return deleteEndpoint_1;
  },
  get getEndpoint() {
    return getEndpoint_1;
  },
  get postEndpoint() {
    return postEndpoint_1;
  }
}, [endpoint$1]);
const require$$0$V = /* @__PURE__ */ getAugmentedNamespace(endpoint);
var config$2 = {};
Object.defineProperty(config$2, "__esModule", { value: true });
var DEFAULT_BASE_URL = config$2.DEFAULT_BASE_URL = void 0;
DEFAULT_BASE_URL = config$2.DEFAULT_BASE_URL = "https://safe-client.safe.global";
const config$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get DEFAULT_BASE_URL() {
    return DEFAULT_BASE_URL;
  },
  default: config$2
}, [config$2]);
const require$$1$w = /* @__PURE__ */ getAugmentedNamespace(config$1);
var safeInfo$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ImplementationVersionState = void 0;
  (function(ImplementationVersionState) {
    ImplementationVersionState["UP_TO_DATE"] = "UP_TO_DATE";
    ImplementationVersionState["OUTDATED"] = "OUTDATED";
    ImplementationVersionState["UNKNOWN"] = "UNKNOWN";
  })(exports.ImplementationVersionState || (exports.ImplementationVersionState = {}));
})(safeInfo$2);
const safeInfo = /* @__PURE__ */ getDefaultExportFromCjs(safeInfo$2);
const safeInfo$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: safeInfo
}, [safeInfo$2]);
const require$$2$l = /* @__PURE__ */ getAugmentedNamespace(safeInfo$1);
var safeApps$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SafeAppSocialPlatforms = exports.SafeAppFeatures = exports.SafeAppAccessPolicyTypes = void 0;
  (function(SafeAppAccessPolicyTypes) {
    SafeAppAccessPolicyTypes["NoRestrictions"] = "NO_RESTRICTIONS";
    SafeAppAccessPolicyTypes["DomainAllowlist"] = "DOMAIN_ALLOWLIST";
  })(exports.SafeAppAccessPolicyTypes || (exports.SafeAppAccessPolicyTypes = {}));
  (function(SafeAppFeatures) {
    SafeAppFeatures["BATCHED_TRANSACTIONS"] = "BATCHED_TRANSACTIONS";
  })(exports.SafeAppFeatures || (exports.SafeAppFeatures = {}));
  (function(SafeAppSocialPlatforms) {
    SafeAppSocialPlatforms["TWITTER"] = "TWITTER";
    SafeAppSocialPlatforms["GITHUB"] = "GITHUB";
    SafeAppSocialPlatforms["DISCORD"] = "DISCORD";
  })(exports.SafeAppSocialPlatforms || (exports.SafeAppSocialPlatforms = {}));
})(safeApps$2);
const safeApps = /* @__PURE__ */ getDefaultExportFromCjs(safeApps$2);
const safeApps$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: safeApps
}, [safeApps$2]);
const require$$3$i = /* @__PURE__ */ getAugmentedNamespace(safeApps$1);
var transactions$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LabelValue = exports.DetailedExecutionInfoType = exports.TransactionListItemType = exports.ConflictType = exports.TransactionInfoType = exports.SettingsInfoType = exports.TransactionTokenType = exports.TransferDirection = exports.TransactionStatus = exports.Operation = void 0;
  (function(Operation) {
    Operation[Operation["CALL"] = 0] = "CALL";
    Operation[Operation["DELEGATE"] = 1] = "DELEGATE";
  })(exports.Operation || (exports.Operation = {}));
  (function(TransactionStatus) {
    TransactionStatus["AWAITING_CONFIRMATIONS"] = "AWAITING_CONFIRMATIONS";
    TransactionStatus["AWAITING_EXECUTION"] = "AWAITING_EXECUTION";
    TransactionStatus["CANCELLED"] = "CANCELLED";
    TransactionStatus["FAILED"] = "FAILED";
    TransactionStatus["SUCCESS"] = "SUCCESS";
  })(exports.TransactionStatus || (exports.TransactionStatus = {}));
  (function(TransferDirection) {
    TransferDirection["INCOMING"] = "INCOMING";
    TransferDirection["OUTGOING"] = "OUTGOING";
    TransferDirection["UNKNOWN"] = "UNKNOWN";
  })(exports.TransferDirection || (exports.TransferDirection = {}));
  (function(TransactionTokenType) {
    TransactionTokenType["ERC20"] = "ERC20";
    TransactionTokenType["ERC721"] = "ERC721";
    TransactionTokenType["NATIVE_COIN"] = "NATIVE_COIN";
  })(exports.TransactionTokenType || (exports.TransactionTokenType = {}));
  (function(SettingsInfoType) {
    SettingsInfoType["SET_FALLBACK_HANDLER"] = "SET_FALLBACK_HANDLER";
    SettingsInfoType["ADD_OWNER"] = "ADD_OWNER";
    SettingsInfoType["REMOVE_OWNER"] = "REMOVE_OWNER";
    SettingsInfoType["SWAP_OWNER"] = "SWAP_OWNER";
    SettingsInfoType["CHANGE_THRESHOLD"] = "CHANGE_THRESHOLD";
    SettingsInfoType["CHANGE_IMPLEMENTATION"] = "CHANGE_IMPLEMENTATION";
    SettingsInfoType["ENABLE_MODULE"] = "ENABLE_MODULE";
    SettingsInfoType["DISABLE_MODULE"] = "DISABLE_MODULE";
    SettingsInfoType["SET_GUARD"] = "SET_GUARD";
    SettingsInfoType["DELETE_GUARD"] = "DELETE_GUARD";
  })(exports.SettingsInfoType || (exports.SettingsInfoType = {}));
  (function(TransactionInfoType) {
    TransactionInfoType["TRANSFER"] = "Transfer";
    TransactionInfoType["SETTINGS_CHANGE"] = "SettingsChange";
    TransactionInfoType["CUSTOM"] = "Custom";
    TransactionInfoType["CREATION"] = "Creation";
  })(exports.TransactionInfoType || (exports.TransactionInfoType = {}));
  (function(ConflictType) {
    ConflictType["NONE"] = "None";
    ConflictType["HAS_NEXT"] = "HasNext";
    ConflictType["END"] = "End";
  })(exports.ConflictType || (exports.ConflictType = {}));
  (function(TransactionListItemType) {
    TransactionListItemType["TRANSACTION"] = "TRANSACTION";
    TransactionListItemType["LABEL"] = "LABEL";
    TransactionListItemType["CONFLICT_HEADER"] = "CONFLICT_HEADER";
    TransactionListItemType["DATE_LABEL"] = "DATE_LABEL";
  })(exports.TransactionListItemType || (exports.TransactionListItemType = {}));
  (function(DetailedExecutionInfoType) {
    DetailedExecutionInfoType["MULTISIG"] = "MULTISIG";
    DetailedExecutionInfoType["MODULE"] = "MODULE";
  })(exports.DetailedExecutionInfoType || (exports.DetailedExecutionInfoType = {}));
  (function(LabelValue) {
    LabelValue["Queued"] = "Queued";
    LabelValue["Next"] = "Next";
  })(exports.LabelValue || (exports.LabelValue = {}));
})(transactions$2);
const transactions = /* @__PURE__ */ getDefaultExportFromCjs(transactions$2);
const transactions$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: transactions
}, [transactions$2]);
const require$$4$c = /* @__PURE__ */ getAugmentedNamespace(transactions$1);
var chains$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FEATURES = exports.GAS_PRICE_TYPE = exports.RPC_AUTHENTICATION = void 0;
  (function(RPC_AUTHENTICATION) {
    RPC_AUTHENTICATION["API_KEY_PATH"] = "API_KEY_PATH";
    RPC_AUTHENTICATION["NO_AUTHENTICATION"] = "NO_AUTHENTICATION";
    RPC_AUTHENTICATION["UNKNOWN"] = "UNKNOWN";
  })(exports.RPC_AUTHENTICATION || (exports.RPC_AUTHENTICATION = {}));
  (function(GAS_PRICE_TYPE) {
    GAS_PRICE_TYPE["ORACLE"] = "ORACLE";
    GAS_PRICE_TYPE["FIXED"] = "FIXED";
    GAS_PRICE_TYPE["FIXED_1559"] = "FIXED1559";
    GAS_PRICE_TYPE["UNKNOWN"] = "UNKNOWN";
  })(exports.GAS_PRICE_TYPE || (exports.GAS_PRICE_TYPE = {}));
  (function(FEATURES) {
    FEATURES["ERC721"] = "ERC721";
    FEATURES["SAFE_APPS"] = "SAFE_APPS";
    FEATURES["CONTRACT_INTERACTION"] = "CONTRACT_INTERACTION";
    FEATURES["DOMAIN_LOOKUP"] = "DOMAIN_LOOKUP";
    FEATURES["SPENDING_LIMIT"] = "SPENDING_LIMIT";
    FEATURES["EIP1559"] = "EIP1559";
    FEATURES["SAFE_TX_GAS_OPTIONAL"] = "SAFE_TX_GAS_OPTIONAL";
    FEATURES["TX_SIMULATION"] = "TX_SIMULATION";
    FEATURES["EIP1271"] = "EIP1271";
  })(exports.FEATURES || (exports.FEATURES = {}));
})(chains$2);
const chains = /* @__PURE__ */ getDefaultExportFromCjs(chains$2);
const chains$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: chains
}, [chains$2]);
const require$$5$9 = /* @__PURE__ */ getAugmentedNamespace(chains$1);
var common$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenType = void 0;
  (function(TokenType) {
    TokenType["ERC20"] = "ERC20";
    TokenType["ERC721"] = "ERC721";
    TokenType["NATIVE_TOKEN"] = "NATIVE_TOKEN";
  })(exports.TokenType || (exports.TokenType = {}));
})(common$2);
const common = /* @__PURE__ */ getDefaultExportFromCjs(common$2);
const common$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: common
}, [common$2]);
const require$$6$8 = /* @__PURE__ */ getAugmentedNamespace(common$1);
var masterCopies$1 = {};
Object.defineProperty(masterCopies$1, "__esModule", { value: true });
const masterCopies = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: masterCopies$1
}, [masterCopies$1]);
const require$$7$6 = /* @__PURE__ */ getAugmentedNamespace(masterCopies);
var decodedData$1 = {};
Object.defineProperty(decodedData$1, "__esModule", { value: true });
const decodedData = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: decodedData$1
}, [decodedData$1]);
const require$$8$4 = /* @__PURE__ */ getAugmentedNamespace(decodedData);
var safeMessages$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SafeMessageStatus = exports.SafeMessageListItemType = void 0;
  (function(SafeMessageListItemType) {
    SafeMessageListItemType["DATE_LABEL"] = "DATE_LABEL";
    SafeMessageListItemType["MESSAGE"] = "MESSAGE";
  })(exports.SafeMessageListItemType || (exports.SafeMessageListItemType = {}));
  (function(SafeMessageStatus) {
    SafeMessageStatus["NEEDS_CONFIRMATION"] = "NEEDS_CONFIRMATION";
    SafeMessageStatus["CONFIRMED"] = "CONFIRMED";
  })(exports.SafeMessageStatus || (exports.SafeMessageStatus = {}));
})(safeMessages$2);
const safeMessages = /* @__PURE__ */ getDefaultExportFromCjs(safeMessages$2);
const safeMessages$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: safeMessages
}, [safeMessages$2]);
const require$$9$5 = /* @__PURE__ */ getAugmentedNamespace(safeMessages$1);
var notifications$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeviceType = void 0;
  (function(DeviceType) {
    DeviceType["ANDROID"] = "ANDROID";
    DeviceType["IOS"] = "IOS";
    DeviceType["WEB"] = "WEB";
  })(exports.DeviceType || (exports.DeviceType = {}));
})(notifications$2);
const notifications = /* @__PURE__ */ getDefaultExportFromCjs(notifications$2);
const notifications$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: notifications
}, [notifications$2]);
const require$$10$5 = /* @__PURE__ */ getAugmentedNamespace(notifications$1);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unregisterDevice = exports.unregisterSafe = exports.registerDevice = exports.getDelegates = exports.confirmSafeMessage = exports.proposeSafeMessage = exports.getSafeMessage = exports.getSafeMessages = exports.getDecodedData = exports.getMasterCopies = exports.getSafeApps = exports.getChainConfig = exports.getChainsConfig = exports.proposeTransaction = exports.getNonces = exports.postSafeGasEstimation = exports.getTransactionDetails = exports.getTransactionQueue = exports.getTransactionHistory = exports.getCollectiblesPage = exports.getCollectibles = exports.getOwnedSafes = exports.getFiatCurrencies = exports.getBalances = exports.getMultisigTransactions = exports.getModuleTransactions = exports.getIncomingTransfers = exports.getSafeInfo = exports.setBaseUrl = void 0;
  const endpoint_1 = require$$0$V;
  const config_1 = require$$1$w;
  __exportStar2(require$$2$l, exports);
  __exportStar2(require$$3$i, exports);
  __exportStar2(require$$4$c, exports);
  __exportStar2(require$$5$9, exports);
  __exportStar2(require$$6$8, exports);
  __exportStar2(require$$7$6, exports);
  __exportStar2(require$$8$4, exports);
  __exportStar2(require$$9$5, exports);
  __exportStar2(require$$10$5, exports);
  let baseUrl = config_1.DEFAULT_BASE_URL;
  const setBaseUrl = (url) => {
    baseUrl = url;
  };
  exports.setBaseUrl = setBaseUrl;
  function getSafeInfo(chainId, address2) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/safes/{address}", { path: { chainId, address: address2 } });
  }
  exports.getSafeInfo = getSafeInfo;
  function getIncomingTransfers(chainId, address2, query, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/safes/{address}/incoming-transfers/", {
      path: { chainId, address: address2 },
      query
    }, pageUrl);
  }
  exports.getIncomingTransfers = getIncomingTransfers;
  function getModuleTransactions(chainId, address2, query, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/safes/{address}/module-transactions/", {
      path: { chainId, address: address2 },
      query
    }, pageUrl);
  }
  exports.getModuleTransactions = getModuleTransactions;
  function getMultisigTransactions(chainId, address2, query, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/safes/{address}/multisig-transactions/", {
      path: { chainId, address: address2 },
      query
    }, pageUrl);
  }
  exports.getMultisigTransactions = getMultisigTransactions;
  function getBalances(chainId, address2, currency = "usd", query = {}) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/safes/{address}/balances/{currency}", {
      path: { chainId, address: address2, currency },
      query
    });
  }
  exports.getBalances = getBalances;
  function getFiatCurrencies() {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/balances/supported-fiat-codes");
  }
  exports.getFiatCurrencies = getFiatCurrencies;
  function getOwnedSafes(chainId, address2) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/owners/{address}/safes", { path: { chainId, address: address2 } });
  }
  exports.getOwnedSafes = getOwnedSafes;
  function getCollectibles(chainId, address2, query = {}) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/safes/{address}/collectibles", {
      path: { chainId, address: address2 },
      query
    });
  }
  exports.getCollectibles = getCollectibles;
  function getCollectiblesPage(chainId, address2, query = {}, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v2/chains/{chainId}/safes/{address}/collectibles", { path: { chainId, address: address2 }, query }, pageUrl);
  }
  exports.getCollectiblesPage = getCollectiblesPage;
  function getTransactionHistory(chainId, address2, query = {}, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/safes/{safe_address}/transactions/history", { path: { chainId, safe_address: address2 }, query }, pageUrl);
  }
  exports.getTransactionHistory = getTransactionHistory;
  function getTransactionQueue(chainId, address2, query = {}, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/safes/{safe_address}/transactions/queued", { path: { chainId, safe_address: address2 }, query }, pageUrl);
  }
  exports.getTransactionQueue = getTransactionQueue;
  function getTransactionDetails(chainId, transactionId) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/transactions/{transactionId}", {
      path: { chainId, transactionId }
    });
  }
  exports.getTransactionDetails = getTransactionDetails;
  function postSafeGasEstimation(chainId, address2, body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, "/v2/chains/{chainId}/safes/{safe_address}/multisig-transactions/estimations", {
      path: { chainId, safe_address: address2 },
      body
    });
  }
  exports.postSafeGasEstimation = postSafeGasEstimation;
  function getNonces(chainId, address2) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/safes/{safe_address}/nonces", {
      path: { chainId, safe_address: address2 }
    });
  }
  exports.getNonces = getNonces;
  function proposeTransaction(chainId, address2, body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, "/v1/chains/{chainId}/transactions/{safe_address}/propose", {
      path: { chainId, safe_address: address2 },
      body
    });
  }
  exports.proposeTransaction = proposeTransaction;
  function getChainsConfig(query) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains", {
      query
    });
  }
  exports.getChainsConfig = getChainsConfig;
  function getChainConfig(chainId) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}", {
      path: { chainId }
    });
  }
  exports.getChainConfig = getChainConfig;
  function getSafeApps(chainId, query = {}) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/safe-apps", {
      path: { chainId },
      query
    });
  }
  exports.getSafeApps = getSafeApps;
  function getMasterCopies(chainId) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/about/master-copies", {
      path: { chainId }
    });
  }
  exports.getMasterCopies = getMasterCopies;
  function getDecodedData(chainId, encodedData, to) {
    return (0, endpoint_1.postEndpoint)(baseUrl, "/v1/chains/{chainId}/data-decoder", {
      path: { chainId },
      body: { data: encodedData, to }
    });
  }
  exports.getDecodedData = getDecodedData;
  function getSafeMessages(chainId, address2, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/safes/{safe_address}/messages", { path: { chainId, safe_address: address2 }, query: {} }, pageUrl);
  }
  exports.getSafeMessages = getSafeMessages;
  function getSafeMessage(chainId, messageHash) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/messages/{message_hash}", {
      path: { chainId, message_hash: messageHash }
    });
  }
  exports.getSafeMessage = getSafeMessage;
  function proposeSafeMessage(chainId, address2, body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, "/v1/chains/{chainId}/safes/{safe_address}/messages", {
      path: { chainId, safe_address: address2 },
      body
    });
  }
  exports.proposeSafeMessage = proposeSafeMessage;
  function confirmSafeMessage(chainId, messageHash, body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, "/v1/chains/{chainId}/messages/{message_hash}/signatures", {
      path: { chainId, message_hash: messageHash },
      body
    });
  }
  exports.confirmSafeMessage = confirmSafeMessage;
  function getDelegates(chainId, query = {}) {
    return (0, endpoint_1.getEndpoint)(baseUrl, "/v1/chains/{chainId}/delegates", {
      path: { chainId },
      query
    });
  }
  exports.getDelegates = getDelegates;
  function registerDevice(body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, "/v1/register/notifications", {
      body
    });
  }
  exports.registerDevice = registerDevice;
  function unregisterSafe(chainId, address2, uuid) {
    return (0, endpoint_1.deleteEndpoint)(baseUrl, "/v1/chains/{chainId}/notifications/devices/{uuid}/safes/{safe_address}", {
      path: { chainId, safe_address: address2, uuid }
    });
  }
  exports.unregisterSafe = unregisterSafe;
  function unregisterDevice(chainId, uuid) {
    return (0, endpoint_1.deleteEndpoint)(baseUrl, "/v1/chains/{chainId}/notifications/devices/{uuid}", {
      path: { chainId, uuid }
    });
  }
  exports.unregisterDevice = unregisterDevice;
})(dist$3);
const index$g = /* @__PURE__ */ getDefaultExportFromCjs(dist$3);
const dist$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$g
}, [dist$3]);
const require$$0$U = /* @__PURE__ */ getAugmentedNamespace(dist$2);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransferDirection = exports.TransactionStatus = exports.TokenType = exports.Operation = void 0;
  var safe_gateway_typescript_sdk_1 = require$$0$U;
  Object.defineProperty(exports, "Operation", { enumerable: true, get: function() {
    return safe_gateway_typescript_sdk_1.Operation;
  } });
  Object.defineProperty(exports, "TokenType", { enumerable: true, get: function() {
    return safe_gateway_typescript_sdk_1.TokenType;
  } });
  Object.defineProperty(exports, "TransactionStatus", { enumerable: true, get: function() {
    return safe_gateway_typescript_sdk_1.TransactionStatus;
  } });
  Object.defineProperty(exports, "TransferDirection", { enumerable: true, get: function() {
    return safe_gateway_typescript_sdk_1.TransferDirection;
  } });
})(gateway$2);
const gateway = /* @__PURE__ */ getDefaultExportFromCjs(gateway$2);
const gateway$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: gateway
}, [gateway$2]);
const require$$2$k = /* @__PURE__ */ getAugmentedNamespace(gateway$1);
var messaging$1 = {};
Object.defineProperty(messaging$1, "__esModule", { value: true });
const messaging = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: messaging$1
}, [messaging$1]);
const require$$3$h = /* @__PURE__ */ getAugmentedNamespace(messaging);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require$$0$X, exports);
  __exportStar2(require$$1$x, exports);
  __exportStar2(require$$2$k, exports);
  __exportStar2(require$$3$h, exports);
})(types$3);
const index$f = /* @__PURE__ */ getDefaultExportFromCjs(types$3);
const types$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$f
}, [types$3]);
const require$$1$v = /* @__PURE__ */ getAugmentedNamespace(types$2);
Object.defineProperty(txs$1, "__esModule", { value: true });
var TXs_1 = txs$1.TXs = void 0;
const methods_1$3 = require$$2$m;
const types_1$1 = require$$1$v;
class TXs {
  constructor(communicator) {
    this.communicator = communicator;
  }
  async getBySafeTxHash(safeTxHash) {
    if (!safeTxHash) {
      throw new Error("Invalid safeTxHash");
    }
    const response = await this.communicator.send(methods_1$3.Methods.getTxBySafeTxHash, { safeTxHash });
    return response.data;
  }
  async signMessage(message) {
    const messagePayload = {
      message
    };
    const response = await this.communicator.send(methods_1$3.Methods.signMessage, messagePayload);
    return response.data;
  }
  async signTypedMessage(typedData2) {
    if (!(0, types_1$1.isObjectEIP712TypedData)(typedData2)) {
      throw new Error("Invalid typed data");
    }
    const response = await this.communicator.send(methods_1$3.Methods.signTypedMessage, { typedData: typedData2 });
    return response.data;
  }
  async send({ txs: txs2, params }) {
    if (!txs2 || !txs2.length) {
      throw new Error("No transactions were passed");
    }
    const messagePayload = {
      txs: txs2,
      params
    };
    const response = await this.communicator.send(methods_1$3.Methods.sendTransactions, messagePayload);
    return response.data;
  }
}
TXs_1 = txs$1.TXs = TXs;
const txs = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get TXs() {
    return TXs_1;
  },
  default: txs$1
}, [txs$1]);
const require$$1$u = /* @__PURE__ */ getAugmentedNamespace(txs);
var eth$1 = {};
var constants$1 = {};
Object.defineProperty(constants$1, "__esModule", { value: true });
var RPC_CALLS = constants$1.RPC_CALLS = void 0;
RPC_CALLS = constants$1.RPC_CALLS = {
  eth_call: "eth_call",
  eth_gasPrice: "eth_gasPrice",
  eth_getLogs: "eth_getLogs",
  eth_getBalance: "eth_getBalance",
  eth_getCode: "eth_getCode",
  eth_getBlockByHash: "eth_getBlockByHash",
  eth_getBlockByNumber: "eth_getBlockByNumber",
  eth_getStorageAt: "eth_getStorageAt",
  eth_getTransactionByHash: "eth_getTransactionByHash",
  eth_getTransactionReceipt: "eth_getTransactionReceipt",
  eth_getTransactionCount: "eth_getTransactionCount",
  eth_estimateGas: "eth_estimateGas",
  safe_setSettings: "safe_setSettings"
};
const constants = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get RPC_CALLS() {
    return RPC_CALLS;
  },
  default: constants$1
}, [constants$1]);
const require$$3$g = /* @__PURE__ */ getAugmentedNamespace(constants);
Object.defineProperty(eth$1, "__esModule", { value: true });
var Eth_1 = eth$1.Eth = void 0;
const constants_1$1 = require$$3$g;
const methods_1$2 = require$$2$m;
const inputFormatters = {
  defaultBlockParam: (arg = "latest") => arg,
  returnFullTxObjectParam: (arg = false) => arg,
  blockNumberToHex: (arg) => Number.isInteger(arg) ? `0x${arg.toString(16)}` : arg
};
class Eth {
  constructor(communicator) {
    this.communicator = communicator;
    this.call = this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_call,
      formatters: [null, inputFormatters.defaultBlockParam]
    });
    this.getBalance = this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_getBalance,
      formatters: [null, inputFormatters.defaultBlockParam]
    });
    this.getCode = this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_getCode,
      formatters: [null, inputFormatters.defaultBlockParam]
    });
    this.getStorageAt = this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_getStorageAt,
      formatters: [null, inputFormatters.blockNumberToHex, inputFormatters.defaultBlockParam]
    });
    this.getPastLogs = this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_getLogs
    });
    this.getBlockByHash = this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_getBlockByHash,
      formatters: [null, inputFormatters.returnFullTxObjectParam]
    });
    this.getBlockByNumber = this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_getBlockByNumber,
      formatters: [inputFormatters.blockNumberToHex, inputFormatters.returnFullTxObjectParam]
    });
    this.getTransactionByHash = this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_getTransactionByHash
    });
    this.getTransactionReceipt = this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_getTransactionReceipt
    });
    this.getTransactionCount = this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_getTransactionCount,
      formatters: [null, inputFormatters.defaultBlockParam]
    });
    this.getGasPrice = this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_gasPrice
    });
    this.getEstimateGas = (transaction2) => this.buildRequest({
      call: constants_1$1.RPC_CALLS.eth_estimateGas
    })([transaction2]);
    this.setSafeSettings = this.buildRequest({
      call: constants_1$1.RPC_CALLS.safe_setSettings
    });
  }
  buildRequest(args) {
    const { call: call2, formatters } = args;
    return async (params) => {
      if (formatters && Array.isArray(params)) {
        formatters.forEach((formatter2, i2) => {
          if (formatter2) {
            params[i2] = formatter2(params[i2]);
          }
        });
      }
      const payload = {
        call: call2,
        params: params || []
      };
      const response = await this.communicator.send(methods_1$2.Methods.rpcCall, payload);
      return response.data;
    };
  }
}
Eth_1 = eth$1.Eth = Eth;
const eth = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get Eth() {
    return Eth_1;
  },
  default: eth$1
}, [eth$1]);
const require$$2$j = /* @__PURE__ */ getAugmentedNamespace(eth);
var safe$2 = {};
var _cjs = {};
var cjs = {};
var errors$3 = {};
var version$6 = {};
Object.defineProperty(version$6, "__esModule", { value: true });
var version_1$1 = version$6.version = void 0;
version_1$1 = version$6.version = "0.9.8";
const version$5 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: version$6,
  get version() {
    return version_1$1;
  }
}, [version$6]);
const require$$0$T = /* @__PURE__ */ getAugmentedNamespace(version$5);
Object.defineProperty(errors$3, "__esModule", { value: true });
var BaseError_1$1 = errors$3.BaseError = void 0;
const version_js_1$1 = require$$0$T;
let BaseError$1 = class BaseError3 extends Error {
  constructor(shortMessage, args = {}) {
    const details = args.cause instanceof BaseError3 ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
    const docsPath2 = args.cause instanceof BaseError3 ? args.cause.docsPath || args.docsPath : args.docsPath;
    const message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath2 ? [`Docs: https://abitype.dev${docsPath2}`] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: abitype@${version_js_1$1.version}`
    ].join("\n");
    super(message);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiTypeError"
    });
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
};
BaseError_1$1 = errors$3.BaseError = BaseError$1;
const errors$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get BaseError() {
    return BaseError_1$1;
  },
  default: errors$3
}, [errors$3]);
const require$$0$S = /* @__PURE__ */ getAugmentedNamespace(errors$2);
var narrow$2 = {};
Object.defineProperty(narrow$2, "__esModule", { value: true });
var narrow_2 = narrow$2.narrow = void 0;
function narrow(value) {
  return value;
}
narrow_2 = narrow$2.narrow = narrow;
const narrow$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: narrow$2,
  get narrow() {
    return narrow_2;
  }
}, [narrow$2]);
const require$$1$t = /* @__PURE__ */ getAugmentedNamespace(narrow$1);
var formatAbi$2 = {};
var formatAbiItem$3 = {};
var formatAbiParameters$2 = {};
var formatAbiParameter$2 = {};
var regex$5 = {};
Object.defineProperty(regex$5, "__esModule", { value: true });
var isTupleRegex = regex$5.isTupleRegex = integerRegex$1 = regex$5.integerRegex = bytesRegex$1 = regex$5.bytesRegex = execTyped_1 = regex$5.execTyped = void 0;
function execTyped(regex2, string2) {
  const match = regex2.exec(string2);
  return match?.groups;
}
var execTyped_1 = regex$5.execTyped = execTyped;
var bytesRegex$1 = regex$5.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex$1 = regex$5.integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
isTupleRegex = regex$5.isTupleRegex = /^\(.+?\).*?$/;
const regex$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get bytesRegex() {
    return bytesRegex$1;
  },
  default: regex$5,
  get execTyped() {
    return execTyped_1;
  },
  get integerRegex() {
    return integerRegex$1;
  },
  get isTupleRegex() {
    return isTupleRegex;
  }
}, [regex$5]);
const require$$0$R = /* @__PURE__ */ getAugmentedNamespace(regex$4);
Object.defineProperty(formatAbiParameter$2, "__esModule", { value: true });
var formatAbiParameter_2 = formatAbiParameter$2.formatAbiParameter = void 0;
const regex_js_1$4 = require$$0$R;
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter2) {
  let type = abiParameter2.type;
  if (tupleRegex.test(abiParameter2.type) && "components" in abiParameter2) {
    type = "(";
    const length2 = abiParameter2.components.length;
    for (let i2 = 0; i2 < length2; i2++) {
      const component = abiParameter2.components[i2];
      type += formatAbiParameter(component);
      if (i2 < length2 - 1)
        type += ", ";
    }
    const result = (0, regex_js_1$4.execTyped)(tupleRegex, abiParameter2.type);
    type += `)${result?.array ?? ""}`;
    return formatAbiParameter({
      ...abiParameter2,
      type
    });
  }
  if ("indexed" in abiParameter2 && abiParameter2.indexed)
    type = `${type} indexed`;
  if (abiParameter2.name)
    return `${type} ${abiParameter2.name}`;
  return type;
}
formatAbiParameter_2 = formatAbiParameter$2.formatAbiParameter = formatAbiParameter;
const formatAbiParameter$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formatAbiParameter$2,
  get formatAbiParameter() {
    return formatAbiParameter_2;
  }
}, [formatAbiParameter$2]);
const require$$4$b = /* @__PURE__ */ getAugmentedNamespace(formatAbiParameter$1);
Object.defineProperty(formatAbiParameters$2, "__esModule", { value: true });
var formatAbiParameters_2 = formatAbiParameters$2.formatAbiParameters = void 0;
const formatAbiParameter_js_1 = require$$4$b;
function formatAbiParameters(abiParameters) {
  let params = "";
  const length2 = abiParameters.length;
  for (let i2 = 0; i2 < length2; i2++) {
    const abiParameter2 = abiParameters[i2];
    params += (0, formatAbiParameter_js_1.formatAbiParameter)(abiParameter2);
    if (i2 !== length2 - 1)
      params += ", ";
  }
  return params;
}
formatAbiParameters_2 = formatAbiParameters$2.formatAbiParameters = formatAbiParameters;
const formatAbiParameters$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formatAbiParameters$2,
  get formatAbiParameters() {
    return formatAbiParameters_2;
  }
}, [formatAbiParameters$2]);
const require$$5$8 = /* @__PURE__ */ getAugmentedNamespace(formatAbiParameters$1);
Object.defineProperty(formatAbiItem$3, "__esModule", { value: true });
var formatAbiItem_2 = formatAbiItem$3.formatAbiItem = void 0;
const formatAbiParameters_js_1 = require$$5$8;
function formatAbiItem$1(abiItem2) {
  if (abiItem2.type === "function")
    return `function ${abiItem2.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem2.inputs)})${abiItem2.stateMutability && abiItem2.stateMutability !== "nonpayable" ? ` ${abiItem2.stateMutability}` : ""}${abiItem2.outputs.length ? ` returns (${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem2.outputs)})` : ""}`;
  else if (abiItem2.type === "event")
    return `event ${abiItem2.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem2.inputs)})`;
  else if (abiItem2.type === "error")
    return `error ${abiItem2.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem2.inputs)})`;
  else if (abiItem2.type === "constructor")
    return `constructor(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem2.inputs)})${abiItem2.stateMutability === "payable" ? " payable" : ""}`;
  else if (abiItem2.type === "fallback")
    return "fallback()";
  return "receive() external payable";
}
formatAbiItem_2 = formatAbiItem$3.formatAbiItem = formatAbiItem$1;
const formatAbiItem$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formatAbiItem$3,
  get formatAbiItem() {
    return formatAbiItem_2;
  }
}, [formatAbiItem$3]);
const require$$3$f = /* @__PURE__ */ getAugmentedNamespace(formatAbiItem$2);
Object.defineProperty(formatAbi$2, "__esModule", { value: true });
var formatAbi_2 = formatAbi$2.formatAbi = void 0;
const formatAbiItem_js_1$7 = require$$3$f;
function formatAbi(abi2) {
  const signatures2 = [];
  const length2 = abi2.length;
  for (let i2 = 0; i2 < length2; i2++) {
    const abiItem2 = abi2[i2];
    const signature2 = (0, formatAbiItem_js_1$7.formatAbiItem)(abiItem2);
    signatures2.push(signature2);
  }
  return signatures2;
}
formatAbi_2 = formatAbi$2.formatAbi = formatAbi;
const formatAbi$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formatAbi$2,
  get formatAbi() {
    return formatAbi_2;
  }
}, [formatAbi$2]);
const require$$2$i = /* @__PURE__ */ getAugmentedNamespace(formatAbi$1);
var parseAbi$2 = {};
var signatures$3 = {};
Object.defineProperty(signatures$3, "__esModule", { value: true });
var functionModifiers = signatures$3.functionModifiers = eventModifiers = signatures$3.eventModifiers = modifiers = signatures$3.modifiers = isReceiveSignature_1 = signatures$3.isReceiveSignature = isFallbackSignature_1 = signatures$3.isFallbackSignature = execConstructorSignature_1 = signatures$3.execConstructorSignature = isConstructorSignature_1 = signatures$3.isConstructorSignature = execStructSignature_1 = signatures$3.execStructSignature = isStructSignature_1 = signatures$3.isStructSignature = execFunctionSignature_1 = signatures$3.execFunctionSignature = isFunctionSignature_1 = signatures$3.isFunctionSignature = execEventSignature_1 = signatures$3.execEventSignature = isEventSignature_1 = signatures$3.isEventSignature = execErrorSignature_1 = signatures$3.execErrorSignature = isErrorSignature_1 = signatures$3.isErrorSignature = void 0;
const regex_js_1$3 = require$$0$R;
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(signature2) {
  return errorSignatureRegex.test(signature2);
}
var isErrorSignature_1 = signatures$3.isErrorSignature = isErrorSignature;
function execErrorSignature(signature2) {
  return (0, regex_js_1$3.execTyped)(errorSignatureRegex, signature2);
}
var execErrorSignature_1 = signatures$3.execErrorSignature = execErrorSignature;
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(signature2) {
  return eventSignatureRegex.test(signature2);
}
var isEventSignature_1 = signatures$3.isEventSignature = isEventSignature;
function execEventSignature(signature2) {
  return (0, regex_js_1$3.execTyped)(eventSignatureRegex, signature2);
}
var execEventSignature_1 = signatures$3.execEventSignature = execEventSignature;
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(signature2) {
  return functionSignatureRegex.test(signature2);
}
var isFunctionSignature_1 = signatures$3.isFunctionSignature = isFunctionSignature;
function execFunctionSignature(signature2) {
  return (0, regex_js_1$3.execTyped)(functionSignatureRegex, signature2);
}
var execFunctionSignature_1 = signatures$3.execFunctionSignature = execFunctionSignature;
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(signature2) {
  return structSignatureRegex.test(signature2);
}
var isStructSignature_1 = signatures$3.isStructSignature = isStructSignature;
function execStructSignature(signature2) {
  return (0, regex_js_1$3.execTyped)(structSignatureRegex, signature2);
}
var execStructSignature_1 = signatures$3.execStructSignature = execStructSignature;
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(signature2) {
  return constructorSignatureRegex.test(signature2);
}
var isConstructorSignature_1 = signatures$3.isConstructorSignature = isConstructorSignature;
function execConstructorSignature(signature2) {
  return (0, regex_js_1$3.execTyped)(constructorSignatureRegex, signature2);
}
var execConstructorSignature_1 = signatures$3.execConstructorSignature = execConstructorSignature;
const fallbackSignatureRegex = /^fallback\(\)$/;
function isFallbackSignature(signature2) {
  return fallbackSignatureRegex.test(signature2);
}
var isFallbackSignature_1 = signatures$3.isFallbackSignature = isFallbackSignature;
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(signature2) {
  return receiveSignatureRegex.test(signature2);
}
var isReceiveSignature_1 = signatures$3.isReceiveSignature = isReceiveSignature;
var modifiers = signatures$3.modifiers = /* @__PURE__ */ new Set([
  "memory",
  "indexed",
  "storage",
  "calldata"
]);
var eventModifiers = signatures$3.eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
functionModifiers = signatures$3.functionModifiers = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
const signatures$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: signatures$3,
  get eventModifiers() {
    return eventModifiers;
  },
  get execConstructorSignature() {
    return execConstructorSignature_1;
  },
  get execErrorSignature() {
    return execErrorSignature_1;
  },
  get execEventSignature() {
    return execEventSignature_1;
  },
  get execFunctionSignature() {
    return execFunctionSignature_1;
  },
  get execStructSignature() {
    return execStructSignature_1;
  },
  get functionModifiers() {
    return functionModifiers;
  },
  get isConstructorSignature() {
    return isConstructorSignature_1;
  },
  get isErrorSignature() {
    return isErrorSignature_1;
  },
  get isEventSignature() {
    return isEventSignature_1;
  },
  get isFallbackSignature() {
    return isFallbackSignature_1;
  },
  get isFunctionSignature() {
    return isFunctionSignature_1;
  },
  get isReceiveSignature() {
    return isReceiveSignature_1;
  },
  get isStructSignature() {
    return isStructSignature_1;
  },
  get modifiers() {
    return modifiers;
  }
}, [signatures$3]);
const require$$1$s = /* @__PURE__ */ getAugmentedNamespace(signatures$2);
var structs$1 = {};
var abiItem$1 = {};
Object.defineProperty(abiItem$1, "__esModule", { value: true });
var UnknownSolidityTypeError_1 = abiItem$1.UnknownSolidityTypeError = UnknownTypeError_1 = abiItem$1.UnknownTypeError = InvalidAbiItemError_1 = abiItem$1.InvalidAbiItemError = void 0;
const errors_js_1$7 = require$$0$S;
class InvalidAbiItemError extends errors_js_1$7.BaseError {
  constructor({ signature: signature2 }) {
    super("Failed to parse ABI item.", {
      details: `parseAbiItem(${JSON.stringify(signature2, null, 2)})`,
      docsPath: "/api/human.html#parseabiitem-1"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiItemError"
    });
  }
}
var InvalidAbiItemError_1 = abiItem$1.InvalidAbiItemError = InvalidAbiItemError;
class UnknownTypeError extends errors_js_1$7.BaseError {
  constructor({ type }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownTypeError"
    });
  }
}
var UnknownTypeError_1 = abiItem$1.UnknownTypeError = UnknownTypeError;
class UnknownSolidityTypeError extends errors_js_1$7.BaseError {
  constructor({ type }) {
    super("Unknown type.", {
      metaMessages: [`Type "${type}" is not a valid ABI type.`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownSolidityTypeError"
    });
  }
}
UnknownSolidityTypeError_1 = abiItem$1.UnknownSolidityTypeError = UnknownSolidityTypeError;
const abiItem = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get InvalidAbiItemError() {
    return InvalidAbiItemError_1;
  },
  get UnknownSolidityTypeError() {
    return UnknownSolidityTypeError_1;
  },
  get UnknownTypeError() {
    return UnknownTypeError_1;
  },
  default: abiItem$1
}, [abiItem$1]);
const require$$10$4 = /* @__PURE__ */ getAugmentedNamespace(abiItem);
var abiParameter$1 = {};
Object.defineProperty(abiParameter$1, "__esModule", { value: true });
var InvalidAbiTypeParameterError_1 = abiParameter$1.InvalidAbiTypeParameterError = InvalidFunctionModifierError_1 = abiParameter$1.InvalidFunctionModifierError = InvalidModifierError_1 = abiParameter$1.InvalidModifierError = SolidityProtectedKeywordError_1 = abiParameter$1.SolidityProtectedKeywordError = InvalidParameterError_1 = abiParameter$1.InvalidParameterError = InvalidAbiParametersError_1 = abiParameter$1.InvalidAbiParametersError = InvalidAbiParameterError_1 = abiParameter$1.InvalidAbiParameterError = void 0;
const errors_js_1$6 = require$$0$S;
class InvalidAbiParameterError extends errors_js_1$6.BaseError {
  constructor({ param }) {
    super("Failed to parse ABI parameter.", {
      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
      docsPath: "/api/human.html#parseabiparameter-1"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiParameterError"
    });
  }
}
var InvalidAbiParameterError_1 = abiParameter$1.InvalidAbiParameterError = InvalidAbiParameterError;
class InvalidAbiParametersError extends errors_js_1$6.BaseError {
  constructor({ params }) {
    super("Failed to parse ABI parameters.", {
      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
      docsPath: "/api/human.html#parseabiparameters-1"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiParametersError"
    });
  }
}
var InvalidAbiParametersError_1 = abiParameter$1.InvalidAbiParametersError = InvalidAbiParametersError;
class InvalidParameterError extends errors_js_1$6.BaseError {
  constructor({ param }) {
    super("Invalid ABI parameter.", {
      details: param
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParameterError"
    });
  }
}
var InvalidParameterError_1 = abiParameter$1.InvalidParameterError = InvalidParameterError;
class SolidityProtectedKeywordError extends errors_js_1$6.BaseError {
  constructor({ param, name: name2 }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `"${name2}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SolidityProtectedKeywordError"
    });
  }
}
var SolidityProtectedKeywordError_1 = abiParameter$1.SolidityProtectedKeywordError = SolidityProtectedKeywordError;
class InvalidModifierError extends errors_js_1$6.BaseError {
  constructor({ param, type, modifier }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidModifierError"
    });
  }
}
var InvalidModifierError_1 = abiParameter$1.InvalidModifierError = InvalidModifierError;
class InvalidFunctionModifierError extends errors_js_1$6.BaseError {
  constructor({ param, type, modifier }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidFunctionModifierError"
    });
  }
}
var InvalidFunctionModifierError_1 = abiParameter$1.InvalidFunctionModifierError = InvalidFunctionModifierError;
class InvalidAbiTypeParameterError extends errors_js_1$6.BaseError {
  constructor({ abiParameter: abiParameter2 }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(abiParameter2, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
InvalidAbiTypeParameterError_1 = abiParameter$1.InvalidAbiTypeParameterError = InvalidAbiTypeParameterError;
const abiParameter = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get InvalidAbiParameterError() {
    return InvalidAbiParameterError_1;
  },
  get InvalidAbiParametersError() {
    return InvalidAbiParametersError_1;
  },
  get InvalidAbiTypeParameterError() {
    return InvalidAbiTypeParameterError_1;
  },
  get InvalidFunctionModifierError() {
    return InvalidFunctionModifierError_1;
  },
  get InvalidModifierError() {
    return InvalidModifierError_1;
  },
  get InvalidParameterError() {
    return InvalidParameterError_1;
  },
  get SolidityProtectedKeywordError() {
    return SolidityProtectedKeywordError_1;
  },
  default: abiParameter$1
}, [abiParameter$1]);
const require$$11$4 = /* @__PURE__ */ getAugmentedNamespace(abiParameter);
var signature$1 = {};
Object.defineProperty(signature$1, "__esModule", { value: true });
var InvalidStructSignatureError_1 = signature$1.InvalidStructSignatureError = UnknownSignatureError_1 = signature$1.UnknownSignatureError = InvalidSignatureError_1 = signature$1.InvalidSignatureError = void 0;
const errors_js_1$5 = require$$0$S;
class InvalidSignatureError extends errors_js_1$5.BaseError {
  constructor({ signature: signature2, type }) {
    super(`Invalid ${type} signature.`, {
      details: signature2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidSignatureError"
    });
  }
}
var InvalidSignatureError_1 = signature$1.InvalidSignatureError = InvalidSignatureError;
class UnknownSignatureError extends errors_js_1$5.BaseError {
  constructor({ signature: signature2 }) {
    super("Unknown signature.", {
      details: signature2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownSignatureError"
    });
  }
}
var UnknownSignatureError_1 = signature$1.UnknownSignatureError = UnknownSignatureError;
class InvalidStructSignatureError extends errors_js_1$5.BaseError {
  constructor({ signature: signature2 }) {
    super("Invalid struct signature.", {
      details: signature2,
      metaMessages: ["No properties exist."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidStructSignatureError"
    });
  }
}
InvalidStructSignatureError_1 = signature$1.InvalidStructSignatureError = InvalidStructSignatureError;
const signature = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get InvalidSignatureError() {
    return InvalidSignatureError_1;
  },
  get InvalidStructSignatureError() {
    return InvalidStructSignatureError_1;
  },
  get UnknownSignatureError() {
    return UnknownSignatureError_1;
  },
  default: signature$1
}, [signature$1]);
const require$$12$3 = /* @__PURE__ */ getAugmentedNamespace(signature);
var struct$1 = {};
Object.defineProperty(struct$1, "__esModule", { value: true });
var CircularReferenceError_1 = struct$1.CircularReferenceError = void 0;
const errors_js_1$4 = require$$0$S;
class CircularReferenceError extends errors_js_1$4.BaseError {
  constructor({ type }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${type}" is a circular reference.`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "CircularReferenceError"
    });
  }
}
CircularReferenceError_1 = struct$1.CircularReferenceError = CircularReferenceError;
const struct = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get CircularReferenceError() {
    return CircularReferenceError_1;
  },
  default: struct$1
}, [struct$1]);
const require$$14$4 = /* @__PURE__ */ getAugmentedNamespace(struct);
var utils$e = {};
var splitParameters$2 = {};
Object.defineProperty(splitParameters$2, "__esModule", { value: true });
var InvalidParenthesisError_1 = splitParameters$2.InvalidParenthesisError = void 0;
const errors_js_1$3 = require$$0$S;
class InvalidParenthesisError extends errors_js_1$3.BaseError {
  constructor({ current, depth }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${depth}"`
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParenthesisError"
    });
  }
}
InvalidParenthesisError_1 = splitParameters$2.InvalidParenthesisError = InvalidParenthesisError;
const splitParameters$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get InvalidParenthesisError() {
    return InvalidParenthesisError_1;
  },
  default: splitParameters$2
}, [splitParameters$2]);
const require$$13$4 = /* @__PURE__ */ getAugmentedNamespace(splitParameters$1);
var cache$1 = {};
Object.defineProperty(cache$1, "__esModule", { value: true });
var parameterCache = cache$1.parameterCache = getParameterCacheKey_1 = cache$1.getParameterCacheKey = void 0;
function getParameterCacheKey(param, type) {
  if (type)
    return `${type}:${param}`;
  return param;
}
var getParameterCacheKey_1 = cache$1.getParameterCacheKey = getParameterCacheKey;
parameterCache = cache$1.parameterCache = /* @__PURE__ */ new Map([
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: true }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: true }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ]
]);
const cache = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: cache$1,
  get getParameterCacheKey() {
    return getParameterCacheKey_1;
  },
  get parameterCache() {
    return parameterCache;
  }
}, [cache$1]);
const require$$5$7 = /* @__PURE__ */ getAugmentedNamespace(cache);
Object.defineProperty(utils$e, "__esModule", { value: true });
var isValidDataLocation_1 = utils$e.isValidDataLocation = isSolidityKeyword_1 = utils$e.isSolidityKeyword = isSolidityType_1 = utils$e.isSolidityType = splitParameters_1 = utils$e.splitParameters = parseAbiParameter_1 = utils$e.parseAbiParameter = parseSignature_1 = utils$e.parseSignature = void 0;
const regex_js_1$2 = require$$0$R;
const abiItem_js_1$1 = require$$10$4;
const abiParameter_js_1$1 = require$$11$4;
const signature_js_1$1 = require$$12$3;
const splitParameters_js_1 = require$$13$4;
const cache_js_1 = require$$5$7;
const signatures_js_1$2 = require$$1$s;
function parseSignature(signature2, structs2 = {}) {
  if ((0, signatures_js_1$2.isFunctionSignature)(signature2)) {
    const match = (0, signatures_js_1$2.execFunctionSignature)(signature2);
    if (!match)
      throw new signature_js_1$1.InvalidSignatureError({ signature: signature2, type: "function" });
    const inputParams = splitParameters(match.parameters);
    const inputs = [];
    const inputLength = inputParams.length;
    for (let i2 = 0; i2 < inputLength; i2++) {
      inputs.push(parseAbiParameter$1(inputParams[i2], {
        modifiers: signatures_js_1$2.functionModifiers,
        structs: structs2,
        type: "function"
      }));
    }
    const outputs = [];
    if (match.returns) {
      const outputParams = splitParameters(match.returns);
      const outputLength = outputParams.length;
      for (let i2 = 0; i2 < outputLength; i2++) {
        outputs.push(parseAbiParameter$1(outputParams[i2], {
          modifiers: signatures_js_1$2.functionModifiers,
          structs: structs2,
          type: "function"
        }));
      }
    }
    return {
      name: match.name,
      type: "function",
      stateMutability: match.stateMutability ?? "nonpayable",
      inputs,
      outputs
    };
  }
  if ((0, signatures_js_1$2.isEventSignature)(signature2)) {
    const match = (0, signatures_js_1$2.execEventSignature)(signature2);
    if (!match)
      throw new signature_js_1$1.InvalidSignatureError({ signature: signature2, type: "event" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length2 = params.length;
    for (let i2 = 0; i2 < length2; i2++) {
      abiParameters.push(parseAbiParameter$1(params[i2], {
        modifiers: signatures_js_1$2.eventModifiers,
        structs: structs2,
        type: "event"
      }));
    }
    return { name: match.name, type: "event", inputs: abiParameters };
  }
  if ((0, signatures_js_1$2.isErrorSignature)(signature2)) {
    const match = (0, signatures_js_1$2.execErrorSignature)(signature2);
    if (!match)
      throw new signature_js_1$1.InvalidSignatureError({ signature: signature2, type: "error" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length2 = params.length;
    for (let i2 = 0; i2 < length2; i2++) {
      abiParameters.push(parseAbiParameter$1(params[i2], { structs: structs2, type: "error" }));
    }
    return { name: match.name, type: "error", inputs: abiParameters };
  }
  if ((0, signatures_js_1$2.isConstructorSignature)(signature2)) {
    const match = (0, signatures_js_1$2.execConstructorSignature)(signature2);
    if (!match)
      throw new signature_js_1$1.InvalidSignatureError({ signature: signature2, type: "constructor" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length2 = params.length;
    for (let i2 = 0; i2 < length2; i2++) {
      abiParameters.push(parseAbiParameter$1(params[i2], { structs: structs2, type: "constructor" }));
    }
    return {
      type: "constructor",
      stateMutability: match.stateMutability ?? "nonpayable",
      inputs: abiParameters
    };
  }
  if ((0, signatures_js_1$2.isFallbackSignature)(signature2))
    return { type: "fallback" };
  if ((0, signatures_js_1$2.isReceiveSignature)(signature2))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new signature_js_1$1.UnknownSignatureError({ signature: signature2 });
}
var parseSignature_1 = utils$e.parseSignature = parseSignature;
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter$1(param, options) {
  const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type);
  if (cache_js_1.parameterCache.has(parameterCacheKey))
    return cache_js_1.parameterCache.get(parameterCacheKey);
  const isTuple = regex_js_1$2.isTupleRegex.test(param);
  const match = (0, regex_js_1$2.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
  if (!match)
    throw new abiParameter_js_1$1.InvalidParameterError({ param });
  if (match.name && isSolidityKeyword(match.name))
    throw new abiParameter_js_1$1.SolidityProtectedKeywordError({ param, name: match.name });
  const name2 = match.name ? { name: match.name } : {};
  const indexed = match.modifier === "indexed" ? { indexed: true } : {};
  const structs2 = options?.structs ?? {};
  let type;
  let components = {};
  if (isTuple) {
    type = "tuple";
    const params = splitParameters(match.type);
    const components_ = [];
    const length2 = params.length;
    for (let i2 = 0; i2 < length2; i2++) {
      components_.push(parseAbiParameter$1(params[i2], { structs: structs2 }));
    }
    components = { components: components_ };
  } else if (match.type in structs2) {
    type = "tuple";
    components = { components: structs2[match.type] };
  } else if (dynamicIntegerRegex.test(match.type)) {
    type = `${match.type}256`;
  } else {
    type = match.type;
    if (!(options?.type === "struct") && !isSolidityType(type))
      throw new abiItem_js_1$1.UnknownSolidityTypeError({ type });
  }
  if (match.modifier) {
    if (!options?.modifiers?.has?.(match.modifier))
      throw new abiParameter_js_1$1.InvalidModifierError({
        param,
        type: options?.type,
        modifier: match.modifier
      });
    if (signatures_js_1$2.functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
      throw new abiParameter_js_1$1.InvalidFunctionModifierError({
        param,
        type: options?.type,
        modifier: match.modifier
      });
  }
  const abiParameter2 = {
    type: `${type}${match.array ?? ""}`,
    ...name2,
    ...indexed,
    ...components
  };
  cache_js_1.parameterCache.set(parameterCacheKey, abiParameter2);
  return abiParameter2;
}
var parseAbiParameter_1 = utils$e.parseAbiParameter = parseAbiParameter$1;
function splitParameters(params, result = [], current = "", depth = 0) {
  if (params === "") {
    if (current === "")
      return result;
    if (depth !== 0)
      throw new splitParameters_js_1.InvalidParenthesisError({ current, depth });
    result.push(current.trim());
    return result;
  }
  const length2 = params.length;
  for (let i2 = 0; i2 < length2; i2++) {
    const char = params[i2];
    const tail = params.slice(i2 + 1);
    switch (char) {
      case ",":
        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
      case "(":
        return splitParameters(tail, result, `${current}${char}`, depth + 1);
      case ")":
        return splitParameters(tail, result, `${current}${char}`, depth - 1);
      default:
        return splitParameters(tail, result, `${current}${char}`, depth);
    }
  }
  return [];
}
var splitParameters_1 = utils$e.splitParameters = splitParameters;
function isSolidityType(type) {
  return type === "address" || type === "bool" || type === "function" || type === "string" || regex_js_1$2.bytesRegex.test(type) || regex_js_1$2.integerRegex.test(type);
}
var isSolidityType_1 = utils$e.isSolidityType = isSolidityType;
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(name2) {
  return name2 === "address" || name2 === "bool" || name2 === "function" || name2 === "string" || name2 === "tuple" || regex_js_1$2.bytesRegex.test(name2) || regex_js_1$2.integerRegex.test(name2) || protectedKeywordsRegex.test(name2);
}
var isSolidityKeyword_1 = utils$e.isSolidityKeyword = isSolidityKeyword;
function isValidDataLocation(type, isArray2) {
  return isArray2 || type === "bytes" || type === "string" || type === "tuple";
}
isValidDataLocation_1 = utils$e.isValidDataLocation = isValidDataLocation;
const utils$d = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$e,
  get isSolidityKeyword() {
    return isSolidityKeyword_1;
  },
  get isSolidityType() {
    return isSolidityType_1;
  },
  get isValidDataLocation() {
    return isValidDataLocation_1;
  },
  get parseAbiParameter() {
    return parseAbiParameter_1;
  },
  get parseSignature() {
    return parseSignature_1;
  },
  get splitParameters() {
    return splitParameters_1;
  }
}, [utils$e]);
const require$$3$e = /* @__PURE__ */ getAugmentedNamespace(utils$d);
Object.defineProperty(structs$1, "__esModule", { value: true });
var parseStructs_1 = structs$1.parseStructs = void 0;
const regex_js_1$1 = require$$0$R;
const abiItem_js_1 = require$$10$4;
const abiParameter_js_1 = require$$11$4;
const signature_js_1 = require$$12$3;
const struct_js_1 = require$$14$4;
const signatures_js_1$1 = require$$1$s;
const utils_js_1$a = require$$3$e;
function parseStructs(signatures2) {
  const shallowStructs = {};
  const signaturesLength = signatures2.length;
  for (let i2 = 0; i2 < signaturesLength; i2++) {
    const signature2 = signatures2[i2];
    if (!(0, signatures_js_1$1.isStructSignature)(signature2))
      continue;
    const match = (0, signatures_js_1$1.execStructSignature)(signature2);
    if (!match)
      throw new signature_js_1.InvalidSignatureError({ signature: signature2, type: "struct" });
    const properties = match.properties.split(";");
    const components = [];
    const propertiesLength = properties.length;
    for (let k2 = 0; k2 < propertiesLength; k2++) {
      const property = properties[k2];
      const trimmed = property.trim();
      if (!trimmed)
        continue;
      const abiParameter2 = (0, utils_js_1$a.parseAbiParameter)(trimmed, {
        type: "struct"
      });
      components.push(abiParameter2);
    }
    if (!components.length)
      throw new signature_js_1.InvalidStructSignatureError({ signature: signature2 });
    shallowStructs[match.name] = components;
  }
  const resolvedStructs = {};
  const entries = Object.entries(shallowStructs);
  const entriesLength = entries.length;
  for (let i2 = 0; i2 < entriesLength; i2++) {
    const [name2, parameters] = entries[i2];
    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);
  }
  return resolvedStructs;
}
parseStructs_1 = structs$1.parseStructs = parseStructs;
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(abiParameters, structs2, ancestors = /* @__PURE__ */ new Set()) {
  const components = [];
  const length2 = abiParameters.length;
  for (let i2 = 0; i2 < length2; i2++) {
    const abiParameter2 = abiParameters[i2];
    const isTuple = regex_js_1$1.isTupleRegex.test(abiParameter2.type);
    if (isTuple)
      components.push(abiParameter2);
    else {
      const match = (0, regex_js_1$1.execTyped)(typeWithoutTupleRegex, abiParameter2.type);
      if (!match?.type)
        throw new abiParameter_js_1.InvalidAbiTypeParameterError({ abiParameter: abiParameter2 });
      const { array, type } = match;
      if (type in structs2) {
        if (ancestors.has(type))
          throw new struct_js_1.CircularReferenceError({ type });
        components.push({
          ...abiParameter2,
          type: `tuple${array ?? ""}`,
          components: resolveStructs(structs2[type] ?? [], structs2, /* @__PURE__ */ new Set([...ancestors, type]))
        });
      } else {
        if ((0, utils_js_1$a.isSolidityType)(type))
          components.push(abiParameter2);
        else
          throw new abiItem_js_1.UnknownTypeError({ type });
      }
    }
  }
  return components;
}
const structs = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: structs$1,
  get parseStructs() {
    return parseStructs_1;
  }
}, [structs$1]);
const require$$2$h = /* @__PURE__ */ getAugmentedNamespace(structs);
Object.defineProperty(parseAbi$2, "__esModule", { value: true });
var parseAbi_2 = parseAbi$2.parseAbi = void 0;
const signatures_js_1 = require$$1$s;
const structs_js_1 = require$$2$h;
const utils_js_1$9 = require$$3$e;
function parseAbi(signatures2) {
  const structs2 = (0, structs_js_1.parseStructs)(signatures2);
  const abi2 = [];
  const length2 = signatures2.length;
  for (let i2 = 0; i2 < length2; i2++) {
    const signature2 = signatures2[i2];
    if ((0, signatures_js_1.isStructSignature)(signature2))
      continue;
    abi2.push((0, utils_js_1$9.parseSignature)(signature2, structs2));
  }
  return abi2;
}
parseAbi_2 = parseAbi$2.parseAbi = parseAbi;
const parseAbi$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: parseAbi$2,
  get parseAbi() {
    return parseAbi_2;
  }
}, [parseAbi$2]);
const require$$6$7 = /* @__PURE__ */ getAugmentedNamespace(parseAbi$1);
var parseAbiItem = {};
var hasRequiredParseAbiItem;
function requireParseAbiItem() {
  if (hasRequiredParseAbiItem)
    return parseAbiItem;
  hasRequiredParseAbiItem = 1;
  Object.defineProperty(parseAbiItem, "__esModule", { value: true });
  parseAbiItem.parseAbiItem = void 0;
  const index_js_1 = requireCjs();
  const signatures_js_12 = require$$1$s;
  const structs_js_12 = require$$2$h;
  const utils_js_12 = require$$3$e;
  function parseAbiItem$1(signature2) {
    let abiItem2;
    if (typeof signature2 === "string")
      abiItem2 = (0, utils_js_12.parseSignature)(signature2);
    else {
      const structs2 = (0, structs_js_12.parseStructs)(signature2);
      const length2 = signature2.length;
      for (let i2 = 0; i2 < length2; i2++) {
        const signature_ = signature2[i2];
        if ((0, signatures_js_12.isStructSignature)(signature_))
          continue;
        abiItem2 = (0, utils_js_12.parseSignature)(signature_, structs2);
        break;
      }
    }
    if (!abiItem2)
      throw new index_js_1.InvalidAbiItemError({ signature: signature2 });
    return abiItem2;
  }
  parseAbiItem.parseAbiItem = parseAbiItem$1;
  return parseAbiItem;
}
var parseAbiParameter = {};
var hasRequiredParseAbiParameter;
function requireParseAbiParameter() {
  if (hasRequiredParseAbiParameter)
    return parseAbiParameter;
  hasRequiredParseAbiParameter = 1;
  Object.defineProperty(parseAbiParameter, "__esModule", { value: true });
  parseAbiParameter.parseAbiParameter = void 0;
  const index_js_1 = requireCjs();
  const signatures_js_12 = require$$1$s;
  const structs_js_12 = require$$2$h;
  const utils_js_12 = require$$3$e;
  function parseAbiParameter$12(param) {
    let abiParameter2;
    if (typeof param === "string")
      abiParameter2 = (0, utils_js_12.parseAbiParameter)(param, {
        modifiers: signatures_js_12.modifiers
      });
    else {
      const structs2 = (0, structs_js_12.parseStructs)(param);
      const length2 = param.length;
      for (let i2 = 0; i2 < length2; i2++) {
        const signature2 = param[i2];
        if ((0, signatures_js_12.isStructSignature)(signature2))
          continue;
        abiParameter2 = (0, utils_js_12.parseAbiParameter)(signature2, { modifiers: signatures_js_12.modifiers, structs: structs2 });
        break;
      }
    }
    if (!abiParameter2)
      throw new index_js_1.InvalidAbiParameterError({ param });
    return abiParameter2;
  }
  parseAbiParameter.parseAbiParameter = parseAbiParameter$12;
  return parseAbiParameter;
}
var parseAbiParameters = {};
var hasRequiredParseAbiParameters;
function requireParseAbiParameters() {
  if (hasRequiredParseAbiParameters)
    return parseAbiParameters;
  hasRequiredParseAbiParameters = 1;
  Object.defineProperty(parseAbiParameters, "__esModule", { value: true });
  parseAbiParameters.parseAbiParameters = void 0;
  const index_js_1 = requireCjs();
  const signatures_js_12 = require$$1$s;
  const structs_js_12 = require$$2$h;
  const utils_js_12 = require$$3$e;
  const utils_js_2 = require$$3$e;
  function parseAbiParameters$1(params) {
    const abiParameters = [];
    if (typeof params === "string") {
      const parameters = (0, utils_js_12.splitParameters)(params);
      const length2 = parameters.length;
      for (let i2 = 0; i2 < length2; i2++) {
        abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[i2], { modifiers: signatures_js_12.modifiers }));
      }
    } else {
      const structs2 = (0, structs_js_12.parseStructs)(params);
      const length2 = params.length;
      for (let i2 = 0; i2 < length2; i2++) {
        const signature2 = params[i2];
        if ((0, signatures_js_12.isStructSignature)(signature2))
          continue;
        const parameters = (0, utils_js_12.splitParameters)(signature2);
        const length3 = parameters.length;
        for (let k2 = 0; k2 < length3; k2++) {
          abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[k2], { modifiers: signatures_js_12.modifiers, structs: structs2 }));
        }
      }
    }
    if (abiParameters.length === 0)
      throw new index_js_1.InvalidAbiParametersError({ params });
    return abiParameters;
  }
  parseAbiParameters.parseAbiParameters = parseAbiParameters$1;
  return parseAbiParameters;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs)
    return cjs;
  hasRequiredCjs = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularReferenceError = exports.InvalidParenthesisError = exports.UnknownSignatureError = exports.InvalidSignatureError = exports.InvalidStructSignatureError = exports.InvalidAbiParameterError = exports.InvalidAbiParametersError = exports.InvalidParameterError = exports.SolidityProtectedKeywordError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.UnknownSolidityTypeError = exports.InvalidAbiItemError = exports.UnknownTypeError = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.formatAbiParameters = exports.formatAbiParameter = exports.formatAbiItem = exports.formatAbi = exports.narrow = exports.BaseError = void 0;
    var errors_js_12 = require$$0$S;
    Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
      return errors_js_12.BaseError;
    } });
    var narrow_js_1 = require$$1$t;
    Object.defineProperty(exports, "narrow", { enumerable: true, get: function() {
      return narrow_js_1.narrow;
    } });
    var formatAbi_js_1 = require$$2$i;
    Object.defineProperty(exports, "formatAbi", { enumerable: true, get: function() {
      return formatAbi_js_1.formatAbi;
    } });
    var formatAbiItem_js_12 = require$$3$f;
    Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function() {
      return formatAbiItem_js_12.formatAbiItem;
    } });
    var formatAbiParameter_js_12 = require$$4$b;
    Object.defineProperty(exports, "formatAbiParameter", { enumerable: true, get: function() {
      return formatAbiParameter_js_12.formatAbiParameter;
    } });
    var formatAbiParameters_js_12 = require$$5$8;
    Object.defineProperty(exports, "formatAbiParameters", { enumerable: true, get: function() {
      return formatAbiParameters_js_12.formatAbiParameters;
    } });
    var parseAbi_js_1 = require$$6$7;
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return parseAbi_js_1.parseAbi;
    } });
    var parseAbiItem_js_1 = requireParseAbiItem();
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return parseAbiItem_js_1.parseAbiItem;
    } });
    var parseAbiParameter_js_1 = requireParseAbiParameter();
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return parseAbiParameter_js_1.parseAbiParameter;
    } });
    var parseAbiParameters_js_1 = requireParseAbiParameters();
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return parseAbiParameters_js_1.parseAbiParameters;
    } });
    var abiItem_js_12 = require$$10$4;
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return abiItem_js_12.UnknownTypeError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abiItem_js_12.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "UnknownSolidityTypeError", { enumerable: true, get: function() {
      return abiItem_js_12.UnknownSolidityTypeError;
    } });
    var abiParameter_js_12 = require$$11$4;
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abiParameter_js_12.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abiParameter_js_12.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return abiParameter_js_12.InvalidModifierError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abiParameter_js_12.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return abiParameter_js_12.InvalidParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abiParameter_js_12.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abiParameter_js_12.InvalidAbiParameterError;
    } });
    var signature_js_12 = require$$12$3;
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return signature_js_12.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return signature_js_12.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return signature_js_12.UnknownSignatureError;
    } });
    var splitParameters_js_12 = require$$13$4;
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return splitParameters_js_12.InvalidParenthesisError;
    } });
    var struct_js_12 = require$$14$4;
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return struct_js_12.CircularReferenceError;
    } });
  })(cjs);
  return cjs;
}
var getContract$2 = {};
var getAction$2 = {};
Object.defineProperty(getAction$2, "__esModule", { value: true });
var getAction_2 = getAction$2.getAction = void 0;
function getAction(client2, action, name2) {
  return (params) => client2[action.name || name2]?.(params) ?? action(client2, params);
}
getAction_2 = getAction$2.getAction = getAction;
const getAction$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getAction$2,
  get getAction() {
    return getAction_2;
  }
}, [getAction$2]);
const require$$4$a = /* @__PURE__ */ getAugmentedNamespace(getAction$1);
var createContractEventFilter$2 = {};
var encodeEventTopics$2 = {};
var abi = {};
var formatAbiItem = {};
var hasRequiredFormatAbiItem;
function requireFormatAbiItem() {
  if (hasRequiredFormatAbiItem)
    return formatAbiItem;
  hasRequiredFormatAbiItem = 1;
  Object.defineProperty(formatAbiItem, "__esModule", { value: true });
  formatAbiItem.formatAbiParams = formatAbiItem.formatAbiItem = void 0;
  const abi_js_12 = requireAbi();
  function formatAbiItem$12(abiItem2, { includeName = false } = {}) {
    if (abiItem2.type !== "function" && abiItem2.type !== "event" && abiItem2.type !== "error")
      throw new abi_js_12.InvalidDefinitionTypeError(abiItem2.type);
    return `${abiItem2.name}(${formatAbiParams2(abiItem2.inputs, { includeName })})`;
  }
  formatAbiItem.formatAbiItem = formatAbiItem$12;
  function formatAbiParams2(params, { includeName = false } = {}) {
    if (!params)
      return "";
    return params.map((param) => formatAbiParam2(param, { includeName })).join(includeName ? ", " : ",");
  }
  formatAbiItem.formatAbiParams = formatAbiParams2;
  function formatAbiParam2(param, { includeName }) {
    if (param.type.startsWith("tuple")) {
      return `(${formatAbiParams2(param.components, { includeName })})${param.type.slice("tuple".length)}`;
    }
    return param.type + (includeName && param.name ? ` ${param.name}` : "");
  }
  return formatAbiItem;
}
var size$3 = {};
var isHex$2 = {};
Object.defineProperty(isHex$2, "__esModule", { value: true });
var isHex_2 = isHex$2.isHex = void 0;
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
isHex_2 = isHex$2.isHex = isHex;
const isHex$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: isHex$2,
  get isHex() {
    return isHex_2;
  }
}, [isHex$2]);
const require$$102 = /* @__PURE__ */ getAugmentedNamespace(isHex$1);
Object.defineProperty(size$3, "__esModule", { value: true });
var size_2 = size$3.size = void 0;
const isHex_js_1$b = require$$102;
function size$1(value) {
  if ((0, isHex_js_1$b.isHex)(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
size_2 = size$3.size = size$1;
const size$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: size$3,
  get size() {
    return size_2;
  }
}, [size$3]);
const require$$113 = /* @__PURE__ */ getAugmentedNamespace(size$2);
var base$2 = {};
var utils$c = {};
var version$4 = {};
Object.defineProperty(version$4, "__esModule", { value: true });
var version_1 = version$4.version = void 0;
version_1 = version$4.version = "1.21.3";
const version$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: version$4,
  get version() {
    return version_1;
  }
}, [version$4]);
const require$$0$Q = /* @__PURE__ */ getAugmentedNamespace(version$3);
Object.defineProperty(utils$c, "__esModule", { value: true });
var getVersion_1 = utils$c.getVersion = getUrl_1 = utils$c.getUrl = getContractAddress_1 = utils$c.getContractAddress = void 0;
const version_js_1 = require$$0$Q;
const getContractAddress$1 = (address2) => address2;
var getContractAddress_1 = utils$c.getContractAddress = getContractAddress$1;
const getUrl = (url) => url;
var getUrl_1 = utils$c.getUrl = getUrl;
const getVersion = () => `viem@${version_js_1.version}`;
getVersion_1 = utils$c.getVersion = getVersion;
const utils$b = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$c,
  get getContractAddress() {
    return getContractAddress_1;
  },
  get getUrl() {
    return getUrl_1;
  },
  get getVersion() {
    return getVersion_1;
  }
}, [utils$c]);
const require$$2$g = /* @__PURE__ */ getAugmentedNamespace(utils$b);
Object.defineProperty(base$2, "__esModule", { value: true });
var BaseError_1 = base$2.BaseError = void 0;
const utils_js_1$8 = require$$2$g;
class BaseError extends Error {
  constructor(shortMessage, args = {}) {
    super();
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ViemError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (0, utils_js_1$8.getVersion)()
    });
    const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
    const docsPath2 = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath2 ? [
        `Docs: https://viem.sh${docsPath2}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
      ] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn) {
    return walk(this, fn);
  }
}
BaseError_1 = base$2.BaseError = BaseError;
function walk(err, fn) {
  if (fn?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err)
    return walk(err.cause, fn);
  return fn ? null : err;
}
const base$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get BaseError() {
    return BaseError_1;
  },
  default: base$2
}, [base$2]);
const require$$21$2 = /* @__PURE__ */ getAugmentedNamespace(base$1);
var hasRequiredAbi;
function requireAbi() {
  if (hasRequiredAbi)
    return abi;
  hasRequiredAbi = 1;
  Object.defineProperty(abi, "__esModule", { value: true });
  abi.UnsupportedPackedAbiType = abi.InvalidDefinitionTypeError = abi.InvalidArrayError = abi.InvalidAbiDecodingTypeError = abi.InvalidAbiEncodingTypeError = abi.DecodeLogTopicsMismatch = abi.DecodeLogDataMismatch = abi.BytesSizeMismatchError = abi.AbiItemAmbiguityError = abi.AbiFunctionSignatureNotFoundError = abi.AbiFunctionOutputsNotFoundError = abi.AbiFunctionNotFoundError = abi.AbiEventNotFoundError = abi.AbiEventSignatureNotFoundError = abi.AbiEventSignatureEmptyTopicsError = abi.AbiErrorSignatureNotFoundError = abi.AbiErrorNotFoundError = abi.AbiErrorInputsNotFoundError = abi.AbiEncodingLengthMismatchError = abi.AbiEncodingBytesSizeMismatchError = abi.AbiEncodingArrayLengthMismatchError = abi.AbiDecodingZeroDataError = abi.AbiDecodingDataSizeTooSmallError = abi.AbiDecodingDataSizeInvalidError = abi.AbiConstructorParamsNotFoundError = abi.AbiConstructorNotFoundError = void 0;
  const formatAbiItem_js_12 = requireFormatAbiItem();
  const size_js_12 = require$$113;
  const base_js_12 = require$$21$2;
  class AbiConstructorNotFoundError2 extends base_js_12.BaseError {
    constructor({ docsPath: docsPath2 }) {
      super([
        "A constructor was not found on the ABI.",
        "Make sure you are using the correct ABI and that the constructor exists on it."
      ].join("\n"), {
        docsPath: docsPath2
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiConstructorNotFoundError"
      });
    }
  }
  abi.AbiConstructorNotFoundError = AbiConstructorNotFoundError2;
  class AbiConstructorParamsNotFoundError2 extends base_js_12.BaseError {
    constructor({ docsPath: docsPath2 }) {
      super([
        "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
        "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
      ].join("\n"), {
        docsPath: docsPath2
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiConstructorParamsNotFoundError"
      });
    }
  }
  abi.AbiConstructorParamsNotFoundError = AbiConstructorParamsNotFoundError2;
  class AbiDecodingDataSizeInvalidError extends base_js_12.BaseError {
    constructor({ data: data2, size: size2 }) {
      super([
        `Data size of ${size2} bytes is invalid.`,
        "Size must be in increments of 32 bytes (size % 32 === 0)."
      ].join("\n"), { metaMessages: [`Data: ${data2} (${size2} bytes)`] });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiDecodingDataSizeInvalidError"
      });
    }
  }
  abi.AbiDecodingDataSizeInvalidError = AbiDecodingDataSizeInvalidError;
  class AbiDecodingDataSizeTooSmallError2 extends base_js_12.BaseError {
    constructor({ data: data2, params, size: size2 }) {
      super([`Data size of ${size2} bytes is too small for given parameters.`].join("\n"), {
        metaMessages: [
          `Params: (${(0, formatAbiItem_js_12.formatAbiParams)(params, { includeName: true })})`,
          `Data:   ${data2} (${size2} bytes)`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiDecodingDataSizeTooSmallError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.data = data2;
      this.params = params;
      this.size = size2;
    }
  }
  abi.AbiDecodingDataSizeTooSmallError = AbiDecodingDataSizeTooSmallError2;
  class AbiDecodingZeroDataError2 extends base_js_12.BaseError {
    constructor() {
      super('Cannot decode zero data ("0x") with ABI parameters.');
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiDecodingZeroDataError"
      });
    }
  }
  abi.AbiDecodingZeroDataError = AbiDecodingZeroDataError2;
  class AbiEncodingArrayLengthMismatchError2 extends base_js_12.BaseError {
    constructor({ expectedLength, givenLength, type }) {
      super([
        `ABI encoding array length mismatch for type ${type}.`,
        `Expected length: ${expectedLength}`,
        `Given length: ${givenLength}`
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEncodingArrayLengthMismatchError"
      });
    }
  }
  abi.AbiEncodingArrayLengthMismatchError = AbiEncodingArrayLengthMismatchError2;
  class AbiEncodingBytesSizeMismatchError2 extends base_js_12.BaseError {
    constructor({ expectedSize, value }) {
      super(`Size of bytes "${value}" (bytes${(0, size_js_12.size)(value)}) does not match expected size (bytes${expectedSize}).`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEncodingBytesSizeMismatchError"
      });
    }
  }
  abi.AbiEncodingBytesSizeMismatchError = AbiEncodingBytesSizeMismatchError2;
  class AbiEncodingLengthMismatchError2 extends base_js_12.BaseError {
    constructor({ expectedLength, givenLength }) {
      super([
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${expectedLength}`,
        `Given length (values): ${givenLength}`
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEncodingLengthMismatchError"
      });
    }
  }
  abi.AbiEncodingLengthMismatchError = AbiEncodingLengthMismatchError2;
  class AbiErrorInputsNotFoundError extends base_js_12.BaseError {
    constructor(errorName, { docsPath: docsPath2 }) {
      super([
        `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
        "Cannot encode error result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the inputs exist on it."
      ].join("\n"), {
        docsPath: docsPath2
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiErrorInputsNotFoundError"
      });
    }
  }
  abi.AbiErrorInputsNotFoundError = AbiErrorInputsNotFoundError;
  class AbiErrorNotFoundError extends base_js_12.BaseError {
    constructor(errorName, { docsPath: docsPath2 } = {}) {
      super([
        `Error ${errorName ? `"${errorName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it."
      ].join("\n"), {
        docsPath: docsPath2
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiErrorNotFoundError"
      });
    }
  }
  abi.AbiErrorNotFoundError = AbiErrorNotFoundError;
  class AbiErrorSignatureNotFoundError2 extends base_js_12.BaseError {
    constructor(signature2, { docsPath: docsPath2 }) {
      super([
        `Encoded error signature "${signature2}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
      ].join("\n"), {
        docsPath: docsPath2
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiErrorSignatureNotFoundError"
      });
      Object.defineProperty(this, "signature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.signature = signature2;
    }
  }
  abi.AbiErrorSignatureNotFoundError = AbiErrorSignatureNotFoundError2;
  class AbiEventSignatureEmptyTopicsError2 extends base_js_12.BaseError {
    constructor({ docsPath: docsPath2 }) {
      super("Cannot extract event signature from empty topics.", {
        docsPath: docsPath2
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEventSignatureEmptyTopicsError"
      });
    }
  }
  abi.AbiEventSignatureEmptyTopicsError = AbiEventSignatureEmptyTopicsError2;
  class AbiEventSignatureNotFoundError2 extends base_js_12.BaseError {
    constructor(signature2, { docsPath: docsPath2 }) {
      super([
        `Encoded event signature "${signature2}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature2}.`
      ].join("\n"), {
        docsPath: docsPath2
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEventSignatureNotFoundError"
      });
    }
  }
  abi.AbiEventSignatureNotFoundError = AbiEventSignatureNotFoundError2;
  class AbiEventNotFoundError2 extends base_js_12.BaseError {
    constructor(eventName, { docsPath: docsPath2 } = {}) {
      super([
        `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it."
      ].join("\n"), {
        docsPath: docsPath2
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiEventNotFoundError"
      });
    }
  }
  abi.AbiEventNotFoundError = AbiEventNotFoundError2;
  class AbiFunctionNotFoundError2 extends base_js_12.BaseError {
    constructor(functionName, { docsPath: docsPath2 } = {}) {
      super([
        `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join("\n"), {
        docsPath: docsPath2
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiFunctionNotFoundError"
      });
    }
  }
  abi.AbiFunctionNotFoundError = AbiFunctionNotFoundError2;
  class AbiFunctionOutputsNotFoundError2 extends base_js_12.BaseError {
    constructor(functionName, { docsPath: docsPath2 }) {
      super([
        `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
        "Cannot decode function result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join("\n"), {
        docsPath: docsPath2
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiFunctionOutputsNotFoundError"
      });
    }
  }
  abi.AbiFunctionOutputsNotFoundError = AbiFunctionOutputsNotFoundError2;
  class AbiFunctionSignatureNotFoundError extends base_js_12.BaseError {
    constructor(signature2, { docsPath: docsPath2 }) {
      super([
        `Encoded function signature "${signature2}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature2}.`
      ].join("\n"), {
        docsPath: docsPath2
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiFunctionSignatureNotFoundError"
      });
    }
  }
  abi.AbiFunctionSignatureNotFoundError = AbiFunctionSignatureNotFoundError;
  class AbiItemAmbiguityError2 extends base_js_12.BaseError {
    constructor(x2, y2) {
      super("Found ambiguous types in overloaded ABI items.", {
        metaMessages: [
          `\`${x2.type}\` in \`${(0, formatAbiItem_js_12.formatAbiItem)(x2.abiItem)}\`, and`,
          `\`${y2.type}\` in \`${(0, formatAbiItem_js_12.formatAbiItem)(y2.abiItem)}\``,
          "",
          "These types encode differently and cannot be distinguished at runtime.",
          "Remove one of the ambiguous items in the ABI."
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiItemAmbiguityError"
      });
    }
  }
  abi.AbiItemAmbiguityError = AbiItemAmbiguityError2;
  class BytesSizeMismatchError2 extends base_js_12.BaseError {
    constructor({ expectedSize, givenSize }) {
      super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BytesSizeMismatchError"
      });
    }
  }
  abi.BytesSizeMismatchError = BytesSizeMismatchError2;
  class DecodeLogDataMismatch2 extends base_js_12.BaseError {
    constructor({ abiItem: abiItem2, data: data2, params, size: size2 }) {
      super([
        `Data size of ${size2} bytes is too small for non-indexed event parameters.`
      ].join("\n"), {
        metaMessages: [
          `Params: (${(0, formatAbiItem_js_12.formatAbiParams)(params, { includeName: true })})`,
          `Data:   ${data2} (${size2} bytes)`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "DecodeLogDataMismatch"
      });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.abiItem = abiItem2;
      this.data = data2;
      this.params = params;
      this.size = size2;
    }
  }
  abi.DecodeLogDataMismatch = DecodeLogDataMismatch2;
  class DecodeLogTopicsMismatch2 extends base_js_12.BaseError {
    constructor({ abiItem: abiItem2, param }) {
      super([
        `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${(0, formatAbiItem_js_12.formatAbiItem)(abiItem2, { includeName: true })}".`
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "DecodeLogTopicsMismatch"
      });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.abiItem = abiItem2;
    }
  }
  abi.DecodeLogTopicsMismatch = DecodeLogTopicsMismatch2;
  class InvalidAbiEncodingTypeError2 extends base_js_12.BaseError {
    constructor(type, { docsPath: docsPath2 }) {
      super([
        `Type "${type}" is not a valid encoding type.`,
        "Please provide a valid ABI type."
      ].join("\n"), { docsPath: docsPath2 });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiEncodingType"
      });
    }
  }
  abi.InvalidAbiEncodingTypeError = InvalidAbiEncodingTypeError2;
  class InvalidAbiDecodingTypeError2 extends base_js_12.BaseError {
    constructor(type, { docsPath: docsPath2 }) {
      super([
        `Type "${type}" is not a valid decoding type.`,
        "Please provide a valid ABI type."
      ].join("\n"), { docsPath: docsPath2 });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiDecodingType"
      });
    }
  }
  abi.InvalidAbiDecodingTypeError = InvalidAbiDecodingTypeError2;
  class InvalidArrayError2 extends base_js_12.BaseError {
    constructor(value) {
      super([`Value "${value}" is not a valid array.`].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidArrayError"
      });
    }
  }
  abi.InvalidArrayError = InvalidArrayError2;
  class InvalidDefinitionTypeError2 extends base_js_12.BaseError {
    constructor(type) {
      super([
        `"${type}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"'
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidDefinitionTypeError"
      });
    }
  }
  abi.InvalidDefinitionTypeError = InvalidDefinitionTypeError2;
  class UnsupportedPackedAbiType extends base_js_12.BaseError {
    constructor(type) {
      super(`Type "${type}" is not supported for packed encoding.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnsupportedPackedAbiType"
      });
    }
  }
  abi.UnsupportedPackedAbiType = UnsupportedPackedAbiType;
  return abi;
}
var log$4 = {};
Object.defineProperty(log$4, "__esModule", { value: true });
var FilterTypeNotSupportedError_1 = log$4.FilterTypeNotSupportedError = void 0;
const base_js_1$o = require$$21$2;
class FilterTypeNotSupportedError extends base_js_1$o.BaseError {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FilterTypeNotSupportedError"
    });
  }
}
FilterTypeNotSupportedError_1 = log$4.FilterTypeNotSupportedError = FilterTypeNotSupportedError;
const log$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get FilterTypeNotSupportedError() {
    return FilterTypeNotSupportedError_1;
  },
  default: log$4
}, [log$4]);
const require$$31$1 = /* @__PURE__ */ getAugmentedNamespace(log$3);
var toBytes$1 = {};
var pad$2 = {};
var data$1 = {};
Object.defineProperty(data$1, "__esModule", { value: true });
var SizeExceedsPaddingSizeError_1 = data$1.SizeExceedsPaddingSizeError = SliceOffsetOutOfBoundsError_1 = data$1.SliceOffsetOutOfBoundsError = void 0;
const base_js_1$n = require$$21$2;
class SliceOffsetOutOfBoundsError extends base_js_1$n.BaseError {
  constructor({ offset, position, size: size2 }) {
    super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size2}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SliceOffsetOutOfBoundsError"
    });
  }
}
var SliceOffsetOutOfBoundsError_1 = data$1.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;
class SizeExceedsPaddingSizeError extends base_js_1$n.BaseError {
  constructor({ size: size2, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SizeExceedsPaddingSizeError"
    });
  }
}
SizeExceedsPaddingSizeError_1 = data$1.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;
const data = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get SizeExceedsPaddingSizeError() {
    return SizeExceedsPaddingSizeError_1;
  },
  get SliceOffsetOutOfBoundsError() {
    return SliceOffsetOutOfBoundsError_1;
  },
  default: data$1
}, [data$1]);
const require$$35$1 = /* @__PURE__ */ getAugmentedNamespace(data);
Object.defineProperty(pad$2, "__esModule", { value: true });
var padBytes_1 = pad$2.padBytes = padHex_1 = pad$2.padHex = pad_2 = pad$2.pad = void 0;
const data_js_1$1 = require$$35$1;
function pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
var pad_2 = pad$2.pad = pad;
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex2 = hex_.replace("0x", "");
  if (hex2.length > size2 * 2)
    throw new data_js_1$1.SizeExceedsPaddingSizeError({
      size: Math.ceil(hex2.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex2[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
var padHex_1 = pad$2.padHex = padHex;
function padBytes(bytes2, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes2;
  if (bytes2.length > size2)
    throw new data_js_1$1.SizeExceedsPaddingSizeError({
      size: bytes2.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i2 = 0; i2 < size2; i2++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i2 : size2 - i2 - 1] = bytes2[padEnd ? i2 : bytes2.length - i2 - 1];
  }
  return paddedBytes;
}
padBytes_1 = pad$2.padBytes = padBytes;
const pad$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: pad$2,
  get pad() {
    return pad_2;
  },
  get padBytes() {
    return padBytes_1;
  },
  get padHex() {
    return padHex_1;
  }
}, [pad$2]);
const require$$106 = /* @__PURE__ */ getAugmentedNamespace(pad$1);
var fromHex = {};
var encoding$1 = {};
Object.defineProperty(encoding$1, "__esModule", { value: true });
var SizeOverflowError_1 = encoding$1.SizeOverflowError = OffsetOutOfBoundsError_1 = encoding$1.OffsetOutOfBoundsError = InvalidHexValueError_1 = encoding$1.InvalidHexValueError = InvalidHexBooleanError_1 = encoding$1.InvalidHexBooleanError = InvalidBytesBooleanError_1 = encoding$1.InvalidBytesBooleanError = IntegerOutOfRangeError_1 = encoding$1.IntegerOutOfRangeError = DataLengthTooShortError_1 = encoding$1.DataLengthTooShortError = DataLengthTooLongError_1 = encoding$1.DataLengthTooLongError = void 0;
const base_js_1$m = require$$21$2;
class DataLengthTooLongError extends base_js_1$m.BaseError {
  constructor({ consumed, length: length2 }) {
    super(`Consumed bytes (${consumed}) is shorter than data length (${length2 - 1}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "DataLengthTooLongError"
    });
  }
}
var DataLengthTooLongError_1 = encoding$1.DataLengthTooLongError = DataLengthTooLongError;
class DataLengthTooShortError extends base_js_1$m.BaseError {
  constructor({ length: length2, dataLength }) {
    super(`Data length (${dataLength - 1}) is shorter than consumed bytes length (${length2 - 1}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "DataLengthTooShortError"
    });
  }
}
var DataLengthTooShortError_1 = encoding$1.DataLengthTooShortError = DataLengthTooShortError;
class IntegerOutOfRangeError extends base_js_1$m.BaseError {
  constructor({ max, min, signed, size: size2, value }) {
    super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntegerOutOfRangeError"
    });
  }
}
var IntegerOutOfRangeError_1 = encoding$1.IntegerOutOfRangeError = IntegerOutOfRangeError;
class InvalidBytesBooleanError extends base_js_1$m.BaseError {
  constructor(bytes2) {
    super(`Bytes value "${bytes2}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidBytesBooleanError"
    });
  }
}
var InvalidBytesBooleanError_1 = encoding$1.InvalidBytesBooleanError = InvalidBytesBooleanError;
class InvalidHexBooleanError extends base_js_1$m.BaseError {
  constructor(hex2) {
    super(`Hex value "${hex2}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidHexBooleanError"
    });
  }
}
var InvalidHexBooleanError_1 = encoding$1.InvalidHexBooleanError = InvalidHexBooleanError;
class InvalidHexValueError extends base_js_1$m.BaseError {
  constructor(value) {
    super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidHexValueError"
    });
  }
}
var InvalidHexValueError_1 = encoding$1.InvalidHexValueError = InvalidHexValueError;
class OffsetOutOfBoundsError extends base_js_1$m.BaseError {
  constructor({ nextOffset, offset }) {
    super(`Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "OffsetOutOfBoundsError"
    });
  }
}
var OffsetOutOfBoundsError_1 = encoding$1.OffsetOutOfBoundsError = OffsetOutOfBoundsError;
class SizeOverflowError extends base_js_1$m.BaseError {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SizeOverflowError"
    });
  }
}
SizeOverflowError_1 = encoding$1.SizeOverflowError = SizeOverflowError;
const encoding = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get DataLengthTooLongError() {
    return DataLengthTooLongError_1;
  },
  get DataLengthTooShortError() {
    return DataLengthTooShortError_1;
  },
  get IntegerOutOfRangeError() {
    return IntegerOutOfRangeError_1;
  },
  get InvalidBytesBooleanError() {
    return InvalidBytesBooleanError_1;
  },
  get InvalidHexBooleanError() {
    return InvalidHexBooleanError_1;
  },
  get InvalidHexValueError() {
    return InvalidHexValueError_1;
  },
  get OffsetOutOfBoundsError() {
    return OffsetOutOfBoundsError_1;
  },
  get SizeOverflowError() {
    return SizeOverflowError_1;
  },
  default: encoding$1
}, [encoding$1]);
const require$$27$3 = /* @__PURE__ */ getAugmentedNamespace(encoding);
var trim$2 = {};
Object.defineProperty(trim$2, "__esModule", { value: true });
var trim_2 = trim$2.trim = void 0;
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data2 = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i2 = 0; i2 < data2.length - 1; i2++) {
    if (data2[dir === "left" ? i2 : data2.length - i2 - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data2 = dir === "left" ? data2.slice(sliceLength) : data2.slice(0, data2.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data2.length === 1 && dir === "right")
      data2 = `${data2}0`;
    return `0x${data2.length % 2 === 1 ? `0${data2}` : data2}`;
  }
  return data2;
}
trim_2 = trim$2.trim = trim;
const trim$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: trim$2,
  get trim() {
    return trim_2;
  }
}, [trim$2]);
const require$$116 = /* @__PURE__ */ getAugmentedNamespace(trim$1);
var hasRequiredFromHex;
function requireFromHex() {
  if (hasRequiredFromHex)
    return fromHex;
  hasRequiredFromHex = 1;
  Object.defineProperty(fromHex, "__esModule", { value: true });
  fromHex.hexToString = fromHex.hexToNumber = fromHex.hexToBool = fromHex.hexToBigInt = fromHex.fromHex = fromHex.assertSize = void 0;
  const encoding_js_12 = require$$27$3;
  const size_js_12 = require$$113;
  const trim_js_12 = require$$116;
  const toBytes_js_12 = requireToBytes();
  function assertSize2(hexOrBytes, { size: size2 }) {
    if ((0, size_js_12.size)(hexOrBytes) > size2)
      throw new encoding_js_12.SizeOverflowError({
        givenSize: (0, size_js_12.size)(hexOrBytes),
        maxSize: size2
      });
  }
  fromHex.assertSize = assertSize2;
  function fromHex$12(hex2, toOrOpts) {
    const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
    const to = opts.to;
    if (to === "number")
      return hexToNumber2(hex2, opts);
    if (to === "bigint")
      return hexToBigInt2(hex2, opts);
    if (to === "string")
      return hexToString2(hex2, opts);
    if (to === "boolean")
      return hexToBool2(hex2, opts);
    return (0, toBytes_js_12.hexToBytes)(hex2, opts);
  }
  fromHex.fromHex = fromHex$12;
  function hexToBigInt2(hex2, opts = {}) {
    const { signed } = opts;
    if (opts.size)
      assertSize2(hex2, { size: opts.size });
    const value = BigInt(hex2);
    if (!signed)
      return value;
    const size2 = (hex2.length - 2) / 2;
    const max = (1n << BigInt(size2) * 8n - 1n) - 1n;
    if (value <= max)
      return value;
    return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
  }
  fromHex.hexToBigInt = hexToBigInt2;
  function hexToBool2(hex_, opts = {}) {
    let hex2 = hex_;
    if (opts.size) {
      assertSize2(hex2, { size: opts.size });
      hex2 = (0, trim_js_12.trim)(hex2);
    }
    if ((0, trim_js_12.trim)(hex2) === "0x00")
      return false;
    if ((0, trim_js_12.trim)(hex2) === "0x01")
      return true;
    throw new encoding_js_12.InvalidHexBooleanError(hex2);
  }
  fromHex.hexToBool = hexToBool2;
  function hexToNumber2(hex2, opts = {}) {
    return Number(hexToBigInt2(hex2, opts));
  }
  fromHex.hexToNumber = hexToNumber2;
  function hexToString2(hex2, opts = {}) {
    let bytes2 = (0, toBytes_js_12.hexToBytes)(hex2);
    if (opts.size) {
      assertSize2(bytes2, { size: opts.size });
      bytes2 = (0, trim_js_12.trim)(bytes2, { dir: "right" });
    }
    return new TextDecoder().decode(bytes2);
  }
  fromHex.hexToString = hexToString2;
  return fromHex;
}
var toHex = {};
var hasRequiredToHex;
function requireToHex() {
  if (hasRequiredToHex)
    return toHex;
  hasRequiredToHex = 1;
  Object.defineProperty(toHex, "__esModule", { value: true });
  toHex.stringToHex = toHex.numberToHex = toHex.bytesToHex = toHex.boolToHex = toHex.toHex = void 0;
  const encoding_js_12 = require$$27$3;
  const pad_js_12 = require$$106;
  const fromHex_js_12 = requireFromHex();
  const hexes2 = Array.from({ length: 256 }, (_v, i2) => i2.toString(16).padStart(2, "0"));
  function toHex$12(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToHex2(value, opts);
    if (typeof value === "string") {
      return stringToHex2(value, opts);
    }
    if (typeof value === "boolean")
      return boolToHex2(value, opts);
    return bytesToHex2(value, opts);
  }
  toHex.toHex = toHex$12;
  function boolToHex2(value, opts = {}) {
    const hex2 = `0x${Number(value)}`;
    if (typeof opts.size === "number") {
      (0, fromHex_js_12.assertSize)(hex2, { size: opts.size });
      return (0, pad_js_12.pad)(hex2, { size: opts.size });
    }
    return hex2;
  }
  toHex.boolToHex = boolToHex2;
  function bytesToHex2(value, opts = {}) {
    let string2 = "";
    for (let i2 = 0; i2 < value.length; i2++) {
      string2 += hexes2[value[i2]];
    }
    const hex2 = `0x${string2}`;
    if (typeof opts.size === "number") {
      (0, fromHex_js_12.assertSize)(hex2, { size: opts.size });
      return (0, pad_js_12.pad)(hex2, { dir: "right", size: opts.size });
    }
    return hex2;
  }
  toHex.bytesToHex = bytesToHex2;
  function numberToHex2(value_, opts = {}) {
    const { signed, size: size2 } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size2) {
      if (signed)
        maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
      else
        maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
    } else if (typeof value_ === "number") {
      maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
    if (maxValue && value > maxValue || value < minValue) {
      const suffix = typeof value_ === "bigint" ? "n" : "";
      throw new encoding_js_12.IntegerOutOfRangeError({
        max: maxValue ? `${maxValue}${suffix}` : void 0,
        min: `${minValue}${suffix}`,
        signed,
        size: size2,
        value: `${value_}${suffix}`
      });
    }
    const hex2 = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
    if (size2)
      return (0, pad_js_12.pad)(hex2, { size: size2 });
    return hex2;
  }
  toHex.numberToHex = numberToHex2;
  const encoder2 = new TextEncoder();
  function stringToHex2(value_, opts = {}) {
    const value = encoder2.encode(value_);
    return bytesToHex2(value, opts);
  }
  toHex.stringToHex = stringToHex2;
  return toHex;
}
var hasRequiredToBytes;
function requireToBytes() {
  if (hasRequiredToBytes)
    return toBytes$1;
  hasRequiredToBytes = 1;
  Object.defineProperty(toBytes$1, "__esModule", { value: true });
  toBytes$1.stringToBytes = toBytes$1.numberToBytes = toBytes$1.hexToBytes = toBytes$1.boolToBytes = toBytes$1.toBytes = void 0;
  const base_js_12 = require$$21$2;
  const isHex_js_12 = require$$102;
  const pad_js_12 = require$$106;
  const fromHex_js_12 = requireFromHex();
  const toHex_js_12 = requireToHex();
  const encoder2 = new TextEncoder();
  function toBytes2(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToBytes2(value, opts);
    if (typeof value === "boolean")
      return boolToBytes2(value, opts);
    if ((0, isHex_js_12.isHex)(value))
      return hexToBytes2(value, opts);
    return stringToBytes2(value, opts);
  }
  toBytes$1.toBytes = toBytes2;
  function boolToBytes2(value, opts = {}) {
    const bytes2 = new Uint8Array(1);
    bytes2[0] = Number(value);
    if (typeof opts.size === "number") {
      (0, fromHex_js_12.assertSize)(bytes2, { size: opts.size });
      return (0, pad_js_12.pad)(bytes2, { size: opts.size });
    }
    return bytes2;
  }
  toBytes$1.boolToBytes = boolToBytes2;
  const charCodeMap2 = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
  function charCodeToBase162(char) {
    if (char >= charCodeMap2.zero && char <= charCodeMap2.nine)
      return char - charCodeMap2.zero;
    if (char >= charCodeMap2.A && char <= charCodeMap2.F)
      return char - (charCodeMap2.A - 10);
    if (char >= charCodeMap2.a && char <= charCodeMap2.f)
      return char - (charCodeMap2.a - 10);
    return void 0;
  }
  function hexToBytes2(hex_, opts = {}) {
    let hex2 = hex_;
    if (opts.size) {
      (0, fromHex_js_12.assertSize)(hex2, { size: opts.size });
      hex2 = (0, pad_js_12.pad)(hex2, { dir: "right", size: opts.size });
    }
    let hexString = hex2.slice(2);
    if (hexString.length % 2)
      hexString = `0${hexString}`;
    const length2 = hexString.length / 2;
    const bytes2 = new Uint8Array(length2);
    for (let index2 = 0, j2 = 0; index2 < length2; index2++) {
      const nibbleLeft = charCodeToBase162(hexString.charCodeAt(j2++));
      const nibbleRight = charCodeToBase162(hexString.charCodeAt(j2++));
      if (nibbleLeft === void 0 || nibbleRight === void 0) {
        throw new base_js_12.BaseError(`Invalid byte sequence ("${hexString[j2 - 2]}${hexString[j2 - 1]}" in "${hexString}").`);
      }
      bytes2[index2] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes2;
  }
  toBytes$1.hexToBytes = hexToBytes2;
  function numberToBytes2(value, opts) {
    const hex2 = (0, toHex_js_12.numberToHex)(value, opts);
    return hexToBytes2(hex2);
  }
  toBytes$1.numberToBytes = numberToBytes2;
  function stringToBytes2(value, opts = {}) {
    const bytes2 = encoder2.encode(value);
    if (typeof opts.size === "number") {
      (0, fromHex_js_12.assertSize)(bytes2, { size: opts.size });
      return (0, pad_js_12.pad)(bytes2, { dir: "right", size: opts.size });
    }
    return bytes2;
  }
  toBytes$1.stringToBytes = stringToBytes2;
  return toBytes$1;
}
var getEventSelector$2 = {};
var getEventSignature$2 = {};
var getFunctionSignature$2 = {};
var normalizeSignature$2 = {};
Object.defineProperty(normalizeSignature$2, "__esModule", { value: true });
var normalizeSignature_2 = normalizeSignature$2.normalizeSignature = void 0;
const base_js_1$l = require$$21$2;
function normalizeSignature(signature2) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i2 = 0; i2 < signature2.length; i2++) {
    const char = signature2[i2];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature2[i2 - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new base_js_1$l.BaseError("Unable to normalize signature.");
  return result;
}
normalizeSignature_2 = normalizeSignature$2.normalizeSignature = normalizeSignature;
const normalizeSignature$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: normalizeSignature$2,
  get normalizeSignature() {
    return normalizeSignature_2;
  }
}, [normalizeSignature$2]);
const require$$1$r = /* @__PURE__ */ getAugmentedNamespace(normalizeSignature$1);
Object.defineProperty(getFunctionSignature$2, "__esModule", { value: true });
var getFunctionSignature_2 = getFunctionSignature$2.getFunctionSignature = void 0;
const abitype_1 = requireCjs();
const normalizeSignature_js_1 = require$$1$r;
const getFunctionSignature = (fn_) => {
  const fn = (() => {
    if (typeof fn_ === "string")
      return fn_;
    return (0, abitype_1.formatAbiItem)(fn_);
  })();
  return (0, normalizeSignature_js_1.normalizeSignature)(fn);
};
getFunctionSignature_2 = getFunctionSignature$2.getFunctionSignature = getFunctionSignature;
const getFunctionSignature$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getFunctionSignature$2,
  get getFunctionSignature() {
    return getFunctionSignature_2;
  }
}, [getFunctionSignature$2]);
const require$$96 = /* @__PURE__ */ getAugmentedNamespace(getFunctionSignature$1);
Object.defineProperty(getEventSignature$2, "__esModule", { value: true });
var getEventSignature_2 = getEventSignature$2.getEventSignature = void 0;
const getFunctionSignature_js_1$1 = require$$96;
const getEventSignature = (fn) => {
  return (0, getFunctionSignature_js_1$1.getFunctionSignature)(fn);
};
getEventSignature_2 = getEventSignature$2.getEventSignature = getEventSignature;
const getEventSignature$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getEventSignature$2,
  get getEventSignature() {
    return getEventSignature_2;
  }
}, [getEventSignature$2]);
const require$$94 = /* @__PURE__ */ getAugmentedNamespace(getEventSignature$1);
var keccak256$2 = {};
var sha3$1 = {};
var _assert$1 = {};
Object.defineProperty(_assert$1, "__esModule", { value: true });
var output_1 = _assert$1.output = exists_1 = _assert$1.exists = hash_1 = _assert$1.hash = bytes_1 = _assert$1.bytes = bool_1 = _assert$1.bool = number_1 = _assert$1.number = void 0;
function number$3(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
var number_1 = _assert$1.number = number$3;
function bool(b2) {
  if (typeof b2 !== "boolean")
    throw new Error(`Expected boolean, not ${b2}`);
}
var bool_1 = _assert$1.bool = bool;
function bytes$2(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
var bytes_1 = _assert$1.bytes = bytes$2;
function hash$2(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$3(hash2.outputLen);
  number$3(hash2.blockLen);
}
var hash_1 = _assert$1.hash = hash$2;
function exists$1(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
var exists_1 = _assert$1.exists = exists$1;
function output(out, instance) {
  bytes$2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
output_1 = _assert$1.output = output;
const assert = { number: number$3, bool, bytes: bytes$2, hash: hash$2, exists: exists$1, output };
var _default$3 = _assert$1.default = assert;
const _assert = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get bool() {
    return bool_1;
  },
  get bytes() {
    return bytes_1;
  },
  default: _default$3,
  get exists() {
    return exists_1;
  },
  get hash() {
    return hash_1;
  },
  get number() {
    return number_1;
  },
  get output() {
    return output_1;
  }
}, [_assert$1]);
const require$$0$P = /* @__PURE__ */ getAugmentedNamespace(_assert);
var _u64$1 = {};
Object.defineProperty(_u64$1, "__esModule", { value: true });
var add5L_1 = _u64$1.add5L = add5H_1 = _u64$1.add5H = add4H_1 = _u64$1.add4H = add4L_1 = _u64$1.add4L = add3H_1 = _u64$1.add3H = add3L_1 = _u64$1.add3L = add_1 = _u64$1.add = rotlBL_1 = _u64$1.rotlBL = rotlBH_1 = _u64$1.rotlBH = rotlSL_1 = _u64$1.rotlSL = rotlSH_1 = _u64$1.rotlSH = rotr32L_1 = _u64$1.rotr32L = rotr32H_1 = _u64$1.rotr32H = rotrBL_1 = _u64$1.rotrBL = rotrBH_1 = _u64$1.rotrBH = rotrSL_1 = _u64$1.rotrSL = rotrSH_1 = _u64$1.rotrSH = shrSL_1 = _u64$1.shrSL = shrSH_1 = _u64$1.shrSH = toBig_1 = _u64$1.toBig = split_1 = _u64$1.split = fromBig_1 = _u64$1.fromBig = void 0;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
var fromBig_1 = _u64$1.fromBig = fromBig;
function split(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h: h2, l: l2 } = fromBig(lst[i2], le2);
    [Ah2[i2], Al[i2]] = [h2, l2];
  }
  return [Ah2, Al];
}
var split_1 = _u64$1.split = split;
const toBig = (h2, l2) => BigInt(h2 >>> 0) << _32n | BigInt(l2 >>> 0);
var toBig_1 = _u64$1.toBig = toBig;
const shrSH = (h2, _l, s) => h2 >>> s;
var shrSH_1 = _u64$1.shrSH = shrSH;
const shrSL = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
var shrSL_1 = _u64$1.shrSL = shrSL;
const rotrSH = (h2, l2, s) => h2 >>> s | l2 << 32 - s;
var rotrSH_1 = _u64$1.rotrSH = rotrSH;
const rotrSL = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
var rotrSL_1 = _u64$1.rotrSL = rotrSL;
const rotrBH = (h2, l2, s) => h2 << 64 - s | l2 >>> s - 32;
var rotrBH_1 = _u64$1.rotrBH = rotrBH;
const rotrBL = (h2, l2, s) => h2 >>> s - 32 | l2 << 64 - s;
var rotrBL_1 = _u64$1.rotrBL = rotrBL;
const rotr32H = (_h, l2) => l2;
var rotr32H_1 = _u64$1.rotr32H = rotr32H;
const rotr32L = (h2, _l) => h2;
var rotr32L_1 = _u64$1.rotr32L = rotr32L;
const rotlSH = (h2, l2, s) => h2 << s | l2 >>> 32 - s;
var rotlSH_1 = _u64$1.rotlSH = rotlSH;
const rotlSL = (h2, l2, s) => l2 << s | h2 >>> 32 - s;
var rotlSL_1 = _u64$1.rotlSL = rotlSL;
const rotlBH = (h2, l2, s) => l2 << s - 32 | h2 >>> 64 - s;
var rotlBH_1 = _u64$1.rotlBH = rotlBH;
const rotlBL = (h2, l2, s) => h2 << s - 32 | l2 >>> 64 - s;
var rotlBL_1 = _u64$1.rotlBL = rotlBL;
function add$1(Ah2, Al, Bh2, Bl2) {
  const l2 = (Al >>> 0) + (Bl2 >>> 0);
  return { h: Ah2 + Bh2 + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
var add_1 = _u64$1.add = add$1;
const add3L = (Al, Bl2, Cl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0);
var add3L_1 = _u64$1.add3L = add3L;
const add3H = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
var add3H_1 = _u64$1.add3H = add3H;
const add4L = (Al, Bl2, Cl, Dl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4L_1 = _u64$1.add4L = add4L;
const add4H = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
var add4H_1 = _u64$1.add4H = add4H;
const add5L = (Al, Bl2, Cl, Dl, El) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
add5L_1 = _u64$1.add5L = add5L;
const add5H = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
var add5H_1 = _u64$1.add5H = add5H;
const u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add: add$1,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var _default$2 = _u64$1.default = u64;
const _u64 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get add() {
    return add_1;
  },
  get add3H() {
    return add3H_1;
  },
  get add3L() {
    return add3L_1;
  },
  get add4H() {
    return add4H_1;
  },
  get add4L() {
    return add4L_1;
  },
  get add5H() {
    return add5H_1;
  },
  get add5L() {
    return add5L_1;
  },
  default: _default$2,
  get fromBig() {
    return fromBig_1;
  },
  get rotlBH() {
    return rotlBH_1;
  },
  get rotlBL() {
    return rotlBL_1;
  },
  get rotlSH() {
    return rotlSH_1;
  },
  get rotlSL() {
    return rotlSL_1;
  },
  get rotr32H() {
    return rotr32H_1;
  },
  get rotr32L() {
    return rotr32L_1;
  },
  get rotrBH() {
    return rotrBH_1;
  },
  get rotrBL() {
    return rotrBL_1;
  },
  get rotrSH() {
    return rotrSH_1;
  },
  get rotrSL() {
    return rotrSL_1;
  },
  get shrSH() {
    return shrSH_1;
  },
  get shrSL() {
    return shrSL_1;
  },
  get split() {
    return split_1;
  },
  get toBig() {
    return toBig_1;
  }
}, [_u64$1]);
const require$$1$q = /* @__PURE__ */ getAugmentedNamespace(_u64);
var utils$a = {};
var crypto$2 = {};
Object.defineProperty(crypto$2, "__esModule", { value: true });
var crypto_1 = crypto$2.crypto = void 0;
crypto_1 = crypto$2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
const crypto$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get crypto() {
    return crypto_1;
  },
  default: crypto$2
}, [crypto$2]);
const require$$0$O = /* @__PURE__ */ getAugmentedNamespace(crypto$1);
(function(exports) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
  const crypto_12 = require$$0$O;
  const u8a2 = (a2) => a2 instanceof Uint8Array;
  const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.u8 = u8;
  const u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  exports.u32 = u322;
  const createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.createView = createView2;
  const rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
  exports.rotr = rotr2;
  exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!exports.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
  function bytesToHex2(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    let hex2 = "";
    for (let i2 = 0; i2 < bytes2.length; i2++) {
      hex2 += hexes2[bytes2[i2]];
    }
    return hex2;
  }
  exports.bytesToHex = bytesToHex2;
  function hexToBytes2(hex2) {
    if (typeof hex2 !== "string")
      throw new Error("hex string expected, got " + typeof hex2);
    const len2 = hex2.length;
    if (len2 % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len2);
    const array = new Uint8Array(len2 / 2);
    for (let i2 = 0; i2 < array.length; i2++) {
      const j2 = i2 * 2;
      const hexByte = hex2.slice(j2, j2 + 2);
      const byte2 = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte2) || byte2 < 0)
        throw new Error("Invalid byte sequence");
      array[i2] = byte2;
    }
    return array;
  }
  exports.hexToBytes = hexToBytes2;
  const nextTick = async () => {
  };
  exports.nextTick = nextTick;
  async function asyncLoop(iters, tick, cb2) {
    let ts = Date.now();
    for (let i2 = 0; i2 < iters; i2++) {
      cb2(i2);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await (0, exports.nextTick)();
      ts += diff;
    }
  }
  exports.asyncLoop = asyncLoop;
  function utf8ToBytes2(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  exports.utf8ToBytes = utf8ToBytes2;
  function toBytes2(data2) {
    if (typeof data2 === "string")
      data2 = utf8ToBytes2(data2);
    if (!u8a2(data2))
      throw new Error(`expected Uint8Array, got ${typeof data2}`);
    return data2;
  }
  exports.toBytes = toBytes2;
  function concatBytes2(...arrays) {
    const r2 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
    let pad2 = 0;
    arrays.forEach((a2) => {
      if (!u8a2(a2))
        throw new Error("Uint8Array expected");
      r2.set(a2, pad2);
      pad2 += a2.length;
    });
    return r2;
  }
  exports.concatBytes = concatBytes2;
  class Hash3 {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  exports.Hash = Hash3;
  const toStr = {}.toString;
  function checkOpts(defaults2, opts) {
    if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults2, opts);
    return merged;
  }
  exports.checkOpts = checkOpts;
  function wrapConstructor2(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  exports.wrapConstructor = wrapConstructor2;
  function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
  function randomBytes2(bytesLength = 32) {
    if (crypto_12.crypto && typeof crypto_12.crypto.getRandomValues === "function") {
      return crypto_12.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  exports.randomBytes = randomBytes2;
})(utils$a);
const utils$8 = /* @__PURE__ */ getDefaultExportFromCjs(utils$a);
const utils$9 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$8
}, [utils$a]);
const require$$1$p = /* @__PURE__ */ getAugmentedNamespace(utils$9);
Object.defineProperty(sha3$1, "__esModule", { value: true });
var shake256 = sha3$1.shake256 = shake128 = sha3$1.shake128 = keccak_512 = sha3$1.keccak_512 = keccak_384 = sha3$1.keccak_384 = keccak_256 = sha3$1.keccak_256 = keccak_224 = sha3$1.keccak_224 = sha3_512 = sha3$1.sha3_512 = sha3_384 = sha3$1.sha3_384 = sha3_256 = sha3$1.sha3_256 = sha3_224 = sha3$1.sha3_224 = Keccak_1 = sha3$1.Keccak = keccakP_1 = sha3$1.keccakP = void 0;
const _assert_js_1$1 = require$$0$P;
const _u64_js_1 = require$$1$q;
const utils_js_1$7 = require$$1$p;
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R2 = _1n, x2 = 1, y2 = 0; round < 24; round++) {
  [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
  SHA3_PI.push(2 * (5 * y2 + x2));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t2 = _0n;
  for (let j2 = 0; j2 < 7; j2++) {
    R2 = (R2 << _1n ^ (R2 >> _7n) * _0x71n) % _256n;
    if (R2 & _2n)
      t2 ^= _1n << (_1n << /* @__PURE__ */ BigInt(j2)) - _1n;
  }
  _SHA3_IOTA.push(t2);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
const rotlH = (h2, l2, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h2, l2, s) : (0, _u64_js_1.rotlSH)(h2, l2, s);
const rotlL = (h2, l2, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h2, l2, s) : (0, _u64_js_1.rotlSL)(h2, l2, s);
function keccakP(s, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x2 = 0; x2 < 10; x2++)
      B2[x2] = s[x2] ^ s[x2 + 10] ^ s[x2 + 20] ^ s[x2 + 30] ^ s[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th2 = rotlH(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s[x2 + y2] ^= Th2;
        s[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL[t2];
      const Th2 = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t2];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th2;
      s[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B2.fill(0);
}
var keccakP_1 = sha3$1.keccakP = keccakP;
class Keccak extends utils_js_1$7.Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    (0, _assert_js_1$1.number)(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = (0, utils_js_1$7.u32)(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data2) {
    (0, _assert_js_1$1.exists)(this);
    const { blockLen, state } = this;
    data2 = (0, utils_js_1$7.toBytes)(data2);
    const len2 = data2.length;
    for (let pos = 0; pos < len2; ) {
      const take2 = Math.min(blockLen - this.pos, len2 - pos);
      for (let i2 = 0; i2 < take2; i2++)
        state[this.pos++] ^= data2[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    (0, _assert_js_1$1.exists)(this, false);
    (0, _assert_js_1$1.bytes)(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len2 = out.length; pos < len2; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take2 = Math.min(blockLen - this.posOut, len2 - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take2), pos);
      this.posOut += take2;
      pos += take2;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    (0, _assert_js_1$1.number)(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    (0, _assert_js_1$1.output)(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
var Keccak_1 = sha3$1.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1$7.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = sha3$1.sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = sha3$1.sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = sha3$1.sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = sha3$1.sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = sha3$1.keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = sha3$1.keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = sha3$1.keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = sha3$1.keccak_512 = gen(1, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1$7.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = sha3$1.shake128 = genShake(31, 168, 128 / 8);
shake256 = sha3$1.shake256 = genShake(31, 136, 256 / 8);
const sha3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get Keccak() {
    return Keccak_1;
  },
  default: sha3$1,
  get keccakP() {
    return keccakP_1;
  },
  get keccak_224() {
    return keccak_224;
  },
  get keccak_256() {
    return keccak_256;
  },
  get keccak_384() {
    return keccak_384;
  },
  get keccak_512() {
    return keccak_512;
  },
  get sha3_224() {
    return sha3_224;
  },
  get sha3_256() {
    return sha3_256;
  },
  get sha3_384() {
    return sha3_384;
  },
  get sha3_512() {
    return sha3_512;
  },
  get shake128() {
    return shake128;
  },
  get shake256() {
    return shake256;
  }
}, [sha3$1]);
const require$$0$N = /* @__PURE__ */ getAugmentedNamespace(sha3);
Object.defineProperty(keccak256$2, "__esModule", { value: true });
var keccak256_2 = keccak256$2.keccak256 = void 0;
const sha3_1 = require$$0$N;
const isHex_js_1$a = require$$102;
const toBytes_js_1$d = requireToBytes();
const toHex_js_1$E = requireToHex();
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes2 = (0, sha3_1.keccak_256)((0, isHex_js_1$a.isHex)(value, { strict: false }) ? (0, toBytes_js_1$d.toBytes)(value) : value);
  if (to === "bytes")
    return bytes2;
  return (0, toHex_js_1$E.toHex)(bytes2);
}
keccak256_2 = keccak256$2.keccak256 = keccak256;
const keccak256$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: keccak256$2,
  get keccak256() {
    return keccak256_2;
  }
}, [keccak256$2]);
const require$$103 = /* @__PURE__ */ getAugmentedNamespace(keccak256$1);
Object.defineProperty(getEventSelector$2, "__esModule", { value: true });
var getEventSelector_2 = getEventSelector$2.getEventSelector = void 0;
const toBytes_js_1$c = requireToBytes();
const getEventSignature_js_1 = require$$94;
const keccak256_js_1$7 = require$$103;
const hash$1 = (value) => (0, keccak256_js_1$7.keccak256)((0, toBytes_js_1$c.toBytes)(value));
const getEventSelector = (fn) => hash$1((0, getEventSignature_js_1.getEventSignature)(fn));
getEventSelector_2 = getEventSelector$2.getEventSelector = getEventSelector;
const getEventSelector$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getEventSelector$2,
  get getEventSelector() {
    return getEventSelector_2;
  }
}, [getEventSelector$2]);
const require$$93 = /* @__PURE__ */ getAugmentedNamespace(getEventSelector$1);
var encodeAbiParameters$2 = {};
var address$3 = {};
Object.defineProperty(address$3, "__esModule", { value: true });
var InvalidAddressError_1 = address$3.InvalidAddressError = void 0;
const base_js_1$k = require$$21$2;
class InvalidAddressError extends base_js_1$k.BaseError {
  constructor({ address: address2 }) {
    super(`Address "${address2}" is invalid.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAddressError"
    });
  }
}
InvalidAddressError_1 = address$3.InvalidAddressError = InvalidAddressError;
const address$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get InvalidAddressError() {
    return InvalidAddressError_1;
  },
  default: address$3
}, [address$3]);
const require$$33$1 = /* @__PURE__ */ getAugmentedNamespace(address$2);
var isAddress$2 = {};
Object.defineProperty(isAddress$2, "__esModule", { value: true });
var isAddress_2 = isAddress$2.isAddress = void 0;
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
function isAddress(address2) {
  return addressRegex.test(address2);
}
isAddress_2 = isAddress$2.isAddress = isAddress;
const isAddress$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: isAddress$2,
  get isAddress() {
    return isAddress_2;
  }
}, [isAddress$2]);
const require$$98 = /* @__PURE__ */ getAugmentedNamespace(isAddress$1);
var concat$3 = {};
Object.defineProperty(concat$3, "__esModule", { value: true });
var concatHex_1 = concat$3.concatHex = concatBytes_1 = concat$3.concatBytes = concat_2 = concat$3.concat = void 0;
function concat$1(values) {
  if (typeof values[0] === "string")
    return concatHex(values);
  return concatBytes(values);
}
var concat_2 = concat$3.concat = concat$1;
function concatBytes(values) {
  let length2 = 0;
  for (const arr of values) {
    length2 += arr.length;
  }
  const result = new Uint8Array(length2);
  let offset = 0;
  for (const arr of values) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
var concatBytes_1 = concat$3.concatBytes = concatBytes;
function concatHex(values) {
  return `0x${values.reduce((acc, x2) => acc + x2.replace("0x", ""), "")}`;
}
concatHex_1 = concat$3.concatHex = concatHex;
const concat$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get concat() {
    return concat_2;
  },
  get concatBytes() {
    return concatBytes_1;
  },
  get concatHex() {
    return concatHex_1;
  },
  default: concat$3
}, [concat$3]);
const require$$80 = /* @__PURE__ */ getAugmentedNamespace(concat$2);
var slice$3 = {};
Object.defineProperty(slice$3, "__esModule", { value: true });
var sliceHex_1 = slice$3.sliceHex = sliceBytes_1 = slice$3.sliceBytes = slice_2 = slice$3.slice = void 0;
const data_js_1 = require$$35$1;
const isHex_js_1$9 = require$$102;
const size_js_1$3 = require$$113;
function slice$1(value, start, end2, { strict } = {}) {
  if ((0, isHex_js_1$9.isHex)(value, { strict: false }))
    return sliceHex(value, start, end2, {
      strict
    });
  return sliceBytes(value, start, end2, {
    strict
  });
}
var slice_2 = slice$3.slice = slice$1;
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > (0, size_js_1$3.size)(value) - 1)
    throw new data_js_1.SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: (0, size_js_1$3.size)(value)
    });
}
function assertEndOffset(value, start, end2) {
  if (typeof start === "number" && typeof end2 === "number" && (0, size_js_1$3.size)(value) !== end2 - start) {
    throw new data_js_1.SliceOffsetOutOfBoundsError({
      offset: end2,
      position: "end",
      size: (0, size_js_1$3.size)(value)
    });
  }
}
function sliceBytes(value_, start, end2, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end2);
  if (strict)
    assertEndOffset(value, start, end2);
  return value;
}
var sliceBytes_1 = slice$3.sliceBytes = sliceBytes;
function sliceHex(value_, start, end2, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end2 ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end2);
  return value;
}
sliceHex_1 = slice$3.sliceHex = sliceHex;
const slice$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: slice$3,
  get slice() {
    return slice_2;
  },
  get sliceBytes() {
    return sliceBytes_1;
  },
  get sliceHex() {
    return sliceHex_1;
  }
}, [slice$3]);
const require$$114 = /* @__PURE__ */ getAugmentedNamespace(slice$2);
Object.defineProperty(encodeAbiParameters$2, "__esModule", { value: true });
var getArrayComponents_1 = encodeAbiParameters$2.getArrayComponents = encodeAbiParameters_2 = encodeAbiParameters$2.encodeAbiParameters = void 0;
const abi_js_1$k = requireAbi();
const address_js_1$7 = require$$33$1;
const isAddress_js_1$8 = require$$98;
const concat_js_1$6 = require$$80;
const pad_js_1$2 = require$$106;
const size_js_1$2 = require$$113;
const slice_js_1$5 = require$$114;
const toHex_js_1$D = requireToHex();
function encodeAbiParameters(params, values) {
  if (params.length !== values.length)
    throw new abi_js_1$k.AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values.length
    });
  const preparedParams = prepareParams({
    params,
    values
  });
  const data2 = encodeParams(preparedParams);
  if (data2.length === 0)
    return "0x";
  return data2;
}
var encodeAbiParameters_2 = encodeAbiParameters$2.encodeAbiParameters = encodeAbiParameters;
function prepareParams({ params, values }) {
  const preparedParams = [];
  for (let i2 = 0; i2 < params.length; i2++) {
    preparedParams.push(prepareParam({ param: params[i2], value: values[i2] }));
  }
  return preparedParams;
}
function prepareParam({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length2, type] = arrayComponents;
    return encodeArray$1(value, { length: length2, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed = param.type.startsWith("int");
    return encodeNumber(value, { signed });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes$1(value, { param });
  }
  if (param.type === "string") {
    return encodeString$1(value);
  }
  throw new abi_js_1$k.InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i2 = 0; i2 < preparedParams.length; i2++) {
    const { dynamic, encoded } = preparedParams[i2];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += (0, size_js_1$2.size)(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i2 = 0; i2 < preparedParams.length; i2++) {
    const { dynamic, encoded } = preparedParams[i2];
    if (dynamic) {
      staticParams.push((0, toHex_js_1$D.numberToHex)(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += (0, size_js_1$2.size)(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return (0, concat_js_1$6.concat)([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!(0, isAddress_js_1$8.isAddress)(value))
    throw new address_js_1$7.InvalidAddressError({ address: value });
  return { dynamic: false, encoded: (0, pad_js_1$2.padHex)(value.toLowerCase()) };
}
function encodeArray$1(value, { length: length2, param }) {
  const dynamic = length2 === null;
  if (!Array.isArray(value))
    throw new abi_js_1$k.InvalidArrayError(value);
  if (!dynamic && value.length !== length2)
    throw new abi_js_1$k.AbiEncodingArrayLengthMismatchError({
      expectedLength: length2,
      givenLength: value.length,
      type: `${param.type}[${length2}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i2 = 0; i2 < value.length; i2++) {
    const preparedParam = prepareParam({ param, value: value[i2] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data2 = encodeParams(preparedParams);
    if (dynamic) {
      const length3 = (0, toHex_js_1$D.numberToHex)(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? (0, concat_js_1$6.concat)([length3, data2]) : length3
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data2 };
  }
  return {
    dynamic: false,
    encoded: (0, concat_js_1$6.concat)(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes$1(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = (0, size_js_1$2.size)(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = (0, pad_js_1$2.padHex)(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: (0, concat_js_1$6.concat)([(0, pad_js_1$2.padHex)((0, toHex_js_1$D.numberToHex)(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== parseInt(paramSize))
    throw new abi_js_1$k.AbiEncodingBytesSizeMismatchError({
      expectedSize: parseInt(paramSize),
      value
    });
  return { dynamic: false, encoded: (0, pad_js_1$2.padHex)(value, { dir: "right" }) };
}
function encodeBool(value) {
  return { dynamic: false, encoded: (0, pad_js_1$2.padHex)((0, toHex_js_1$D.boolToHex)(value)) };
}
function encodeNumber(value, { signed }) {
  return {
    dynamic: false,
    encoded: (0, toHex_js_1$D.numberToHex)(value, {
      size: 32,
      signed
    })
  };
}
function encodeString$1(value) {
  const hexValue = (0, toHex_js_1$D.stringToHex)(value);
  const partsLength = Math.ceil((0, size_js_1$2.size)(hexValue) / 32);
  const parts = [];
  for (let i2 = 0; i2 < partsLength; i2++) {
    parts.push((0, pad_js_1$2.padHex)((0, slice_js_1$5.slice)(hexValue, i2 * 32, (i2 + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: (0, concat_js_1$6.concat)([
      (0, pad_js_1$2.padHex)((0, toHex_js_1$D.numberToHex)((0, size_js_1$2.size)(hexValue), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i2 = 0; i2 < param.components.length; i2++) {
    const param_ = param.components[i2];
    const index2 = Array.isArray(value) ? i2 : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index2]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : (0, concat_js_1$6.concat)(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : void 0;
}
getArrayComponents_1 = encodeAbiParameters$2.getArrayComponents = getArrayComponents;
const encodeAbiParameters$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: encodeAbiParameters$2,
  get encodeAbiParameters() {
    return encodeAbiParameters_2;
  },
  get getArrayComponents() {
    return getArrayComponents_1;
  }
}, [encodeAbiParameters$2]);
const require$$47 = /* @__PURE__ */ getAugmentedNamespace(encodeAbiParameters$1);
var getAbiItem$2 = {};
var getFunctionSelector$2 = {};
Object.defineProperty(getFunctionSelector$2, "__esModule", { value: true });
var getFunctionSelector_2 = getFunctionSelector$2.getFunctionSelector = void 0;
const slice_js_1$4 = require$$114;
const toBytes_js_1$b = requireToBytes();
const getFunctionSignature_js_1 = require$$96;
const keccak256_js_1$6 = require$$103;
const hash = (value) => (0, keccak256_js_1$6.keccak256)((0, toBytes_js_1$b.toBytes)(value));
const getFunctionSelector = (fn) => (0, slice_js_1$4.slice)(hash((0, getFunctionSignature_js_1.getFunctionSignature)(fn)), 0, 4);
getFunctionSelector_2 = getFunctionSelector$2.getFunctionSelector = getFunctionSelector;
const getFunctionSelector$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getFunctionSelector$2,
  get getFunctionSelector() {
    return getFunctionSelector_2;
  }
}, [getFunctionSelector$2]);
const require$$95 = /* @__PURE__ */ getAugmentedNamespace(getFunctionSelector$1);
Object.defineProperty(getAbiItem$2, "__esModule", { value: true });
var getAmbiguousTypes_1 = getAbiItem$2.getAmbiguousTypes = isArgOfType_1 = getAbiItem$2.isArgOfType = getAbiItem_2 = getAbiItem$2.getAbiItem = void 0;
const abi_js_1$j = requireAbi();
const isHex_js_1$8 = require$$102;
const getEventSelector_js_1$2 = require$$93;
const getFunctionSelector_js_1$4 = require$$95;
const isAddress_js_1$7 = require$$98;
function getAbiItem({ abi: abi2, args = [], name: name2 }) {
  const isSelector = (0, isHex_js_1$8.isHex)(name2, { strict: false });
  const abiItems = abi2.filter((abiItem2) => {
    if (isSelector) {
      if (abiItem2.type === "function")
        return (0, getFunctionSelector_js_1$4.getFunctionSelector)(abiItem2) === name2;
      if (abiItem2.type === "event")
        return (0, getEventSelector_js_1$2.getEventSelector)(abiItem2) === name2;
      return false;
    }
    return "name" in abiItem2 && abiItem2.name === name2;
  });
  if (abiItems.length === 0)
    return void 0;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem = void 0;
  for (const abiItem2 of abiItems) {
    if (!("inputs" in abiItem2))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem2.inputs || abiItem2.inputs.length === 0)
        return abiItem2;
      continue;
    }
    if (!abiItem2.inputs)
      continue;
    if (abiItem2.inputs.length === 0)
      continue;
    if (abiItem2.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index2) => {
      const abiParameter2 = "inputs" in abiItem2 && abiItem2.inputs[index2];
      if (!abiParameter2)
        return false;
      return isArgOfType(arg, abiParameter2);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem2.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new abi_js_1$j.AbiItemAmbiguityError({
            abiItem: abiItem2,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem2;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
var getAbiItem_2 = getAbiItem$2.getAbiItem = getAbiItem;
function isArgOfType(arg, abiParameter2) {
  const argType = typeof arg;
  const abiParameterType = abiParameter2.type;
  switch (abiParameterType) {
    case "address":
      return (0, isAddress_js_1$7.isAddress)(arg);
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter2)
        return Object.values(abiParameter2.components).every((component, index2) => {
          return isArgOfType(Object.values(arg)[index2], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x2) => isArgOfType(x2, {
          ...abiParameter2,
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
var isArgOfType_1 = getAbiItem$2.isArgOfType = isArgOfType;
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types2 = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types2.includes("address") && types2.includes("bytes20"))
        return true;
      if (types2.includes("address") && types2.includes("string"))
        return (0, isAddress_js_1$7.isAddress)(args[parameterIndex]);
      if (types2.includes("address") && types2.includes("bytes"))
        return (0, isAddress_js_1$7.isAddress)(args[parameterIndex]);
      return false;
    })();
    if (ambiguous)
      return types2;
  }
  return;
}
getAmbiguousTypes_1 = getAbiItem$2.getAmbiguousTypes = getAmbiguousTypes;
const getAbiItem$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getAbiItem$2,
  get getAbiItem() {
    return getAbiItem_2;
  },
  get getAmbiguousTypes() {
    return getAmbiguousTypes_1;
  },
  get isArgOfType() {
    return isArgOfType_1;
  }
}, [getAbiItem$2]);
const require$$56$1 = /* @__PURE__ */ getAugmentedNamespace(getAbiItem$1);
Object.defineProperty(encodeEventTopics$2, "__esModule", { value: true });
var encodeEventTopics_2 = encodeEventTopics$2.encodeEventTopics = void 0;
const abi_js_1$i = requireAbi();
const log_js_1$5 = require$$31$1;
const toBytes_js_1$a = requireToBytes();
const getEventSelector_js_1$1 = require$$93;
const keccak256_js_1$5 = require$$103;
const encodeAbiParameters_js_1$5 = require$$47;
const formatAbiItem_js_1$6 = requireFormatAbiItem();
const getAbiItem_js_1$6 = require$$56$1;
function encodeEventTopics({ abi: abi2, eventName, args }) {
  let abiItem2 = abi2[0];
  if (eventName) {
    abiItem2 = (0, getAbiItem_js_1$6.getAbiItem)({
      abi: abi2,
      args,
      name: eventName
    });
    if (!abiItem2)
      throw new abi_js_1$i.AbiEventNotFoundError(eventName, {
        docsPath: "/docs/contract/encodeEventTopics"
      });
  }
  if (abiItem2.type !== "event")
    throw new abi_js_1$i.AbiEventNotFoundError(void 0, {
      docsPath: "/docs/contract/encodeEventTopics"
    });
  const definition = (0, formatAbiItem_js_1$6.formatAbiItem)(abiItem2);
  const signature2 = (0, getEventSelector_js_1$1.getEventSelector)(definition);
  let topics = [];
  if (args && "inputs" in abiItem2) {
    const indexedInputs = abiItem2.inputs?.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x2) => args[x2.name]) ?? [] : [];
    if (args_.length > 0) {
      topics = indexedInputs?.map((param, i2) => Array.isArray(args_[i2]) ? args_[i2].map((_2, j2) => encodeArg({ param, value: args_[i2][j2] })) : args_[i2] ? encodeArg({ param, value: args_[i2] }) : null) ?? [];
    }
  }
  return [signature2, ...topics];
}
encodeEventTopics_2 = encodeEventTopics$2.encodeEventTopics = encodeEventTopics;
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return (0, keccak256_js_1$5.keccak256)((0, toBytes_js_1$a.toBytes)(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new log_js_1$5.FilterTypeNotSupportedError(param.type);
  return (0, encodeAbiParameters_js_1$5.encodeAbiParameters)([param], [value]);
}
const encodeEventTopics$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: encodeEventTopics$2,
  get encodeEventTopics() {
    return encodeEventTopics_2;
  }
}, [encodeEventTopics$2]);
const require$$50 = /* @__PURE__ */ getAugmentedNamespace(encodeEventTopics$1);
var createFilterRequestScope$2 = {};
Object.defineProperty(createFilterRequestScope$2, "__esModule", { value: true });
var createFilterRequestScope_2 = createFilterRequestScope$2.createFilterRequestScope = void 0;
function createFilterRequestScope(client2, { method }) {
  const requestMap = {};
  if (client2.transport.type === "fallback")
    client2.transport.onResponse?.(({ method: method_, response: id2, status, transport: transport2 }) => {
      if (status === "success" && method === method_)
        requestMap[id2] = transport2.request;
    });
  return (id2) => requestMap[id2] || client2.request;
}
createFilterRequestScope_2 = createFilterRequestScope$2.createFilterRequestScope = createFilterRequestScope;
const createFilterRequestScope$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createFilterRequestScope() {
    return createFilterRequestScope_2;
  },
  default: createFilterRequestScope$2
}, [createFilterRequestScope$2]);
const require$$0$M = /* @__PURE__ */ getAugmentedNamespace(createFilterRequestScope$1);
Object.defineProperty(createContractEventFilter$2, "__esModule", { value: true });
var createContractEventFilter_2 = createContractEventFilter$2.createContractEventFilter = void 0;
const encodeEventTopics_js_1$3 = require$$50;
const toHex_js_1$C = requireToHex();
const createFilterRequestScope_js_1$3 = require$$0$M;
async function createContractEventFilter(client2, { address: address2, abi: abi2, args, eventName, fromBlock, strict, toBlock }) {
  const getRequest = (0, createFilterRequestScope_js_1$3.createFilterRequestScope)(client2, {
    method: "eth_newFilter"
  });
  const topics = eventName ? (0, encodeEventTopics_js_1$3.encodeEventTopics)({
    abi: abi2,
    args,
    eventName
  }) : void 0;
  const id2 = await client2.request({
    method: "eth_newFilter",
    params: [
      {
        address: address2,
        fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1$C.numberToHex)(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1$C.numberToHex)(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi: abi2,
    args,
    eventName,
    id: id2,
    request: getRequest(id2),
    strict,
    type: "event"
  };
}
createContractEventFilter_2 = createContractEventFilter$2.createContractEventFilter = createContractEventFilter;
const createContractEventFilter$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createContractEventFilter() {
    return createContractEventFilter_2;
  },
  default: createContractEventFilter$2
}, [createContractEventFilter$2]);
const require$$7$5 = /* @__PURE__ */ getAugmentedNamespace(createContractEventFilter$1);
var estimateContractGas$2 = {};
var parseAccount$2 = {};
Object.defineProperty(parseAccount$2, "__esModule", { value: true });
var parseAccount_2 = parseAccount$2.parseAccount = void 0;
function parseAccount(account2) {
  if (typeof account2 === "string")
    return { address: account2, type: "json-rpc" };
  return account2;
}
parseAccount_2 = parseAccount$2.parseAccount = parseAccount;
const parseAccount$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: parseAccount$2,
  get parseAccount() {
    return parseAccount_2;
  }
}, [parseAccount$2]);
const require$$0$L = /* @__PURE__ */ getAugmentedNamespace(parseAccount$1);
var encodeFunctionData$2 = {};
Object.defineProperty(encodeFunctionData$2, "__esModule", { value: true });
var encodeFunctionData_2 = encodeFunctionData$2.encodeFunctionData = void 0;
const abi_js_1$h = requireAbi();
const concat_js_1$5 = require$$80;
const getFunctionSelector_js_1$3 = require$$95;
const encodeAbiParameters_js_1$4 = require$$47;
const formatAbiItem_js_1$5 = requireFormatAbiItem();
const getAbiItem_js_1$5 = require$$56$1;
function encodeFunctionData({ abi: abi2, args, functionName }) {
  let abiItem2 = abi2[0];
  if (functionName) {
    abiItem2 = (0, getAbiItem_js_1$5.getAbiItem)({
      abi: abi2,
      args,
      name: functionName
    });
    if (!abiItem2)
      throw new abi_js_1$h.AbiFunctionNotFoundError(functionName, {
        docsPath: "/docs/contract/encodeFunctionData"
      });
  }
  if (abiItem2.type !== "function")
    throw new abi_js_1$h.AbiFunctionNotFoundError(void 0, {
      docsPath: "/docs/contract/encodeFunctionData"
    });
  const definition = (0, formatAbiItem_js_1$5.formatAbiItem)(abiItem2);
  const signature2 = (0, getFunctionSelector_js_1$3.getFunctionSelector)(definition);
  const data2 = "inputs" in abiItem2 && abiItem2.inputs ? (0, encodeAbiParameters_js_1$4.encodeAbiParameters)(abiItem2.inputs, args ?? []) : void 0;
  return (0, concat_js_1$5.concatHex)([signature2, data2 ?? "0x"]);
}
encodeFunctionData_2 = encodeFunctionData$2.encodeFunctionData = encodeFunctionData;
const encodeFunctionData$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: encodeFunctionData$2,
  get encodeFunctionData() {
    return encodeFunctionData_2;
  }
}, [encodeFunctionData$2]);
const require$$51 = /* @__PURE__ */ getAugmentedNamespace(encodeFunctionData$1);
var getContractError$2 = {};
var contract$3 = {};
var solidity$1 = {};
Object.defineProperty(solidity$1, "__esModule", { value: true });
var solidityPanic = solidity$1.solidityPanic = solidityError = solidity$1.solidityError = panicReasons = solidity$1.panicReasons = void 0;
var panicReasons = solidity$1.panicReasons = {
  1: "An `assert` condition failed.",
  17: "Arithmic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
};
var solidityError = solidity$1.solidityError = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
};
solidityPanic = solidity$1.solidityPanic = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
const solidity = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: solidity$1,
  get panicReasons() {
    return panicReasons;
  },
  get solidityError() {
    return solidityError;
  },
  get solidityPanic() {
    return solidityPanic;
  }
}, [solidity$1]);
const require$$0$K = /* @__PURE__ */ getAugmentedNamespace(solidity);
var decodeErrorResult$2 = {};
var decodeAbiParameters$2 = {};
var getAddress$2 = {};
Object.defineProperty(getAddress$2, "__esModule", { value: true });
var getAddress_2 = getAddress$2.getAddress = checksumAddress_1 = getAddress$2.checksumAddress = void 0;
const address_js_1$6 = require$$33$1;
const toBytes_js_1$9 = requireToBytes();
const keccak256_js_1$4 = require$$103;
const isAddress_js_1$6 = require$$98;
function checksumAddress(address_, chainId) {
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash2 = (0, keccak256_js_1$4.keccak256)((0, toBytes_js_1$9.stringToBytes)(hexAddress), "bytes");
  const address2 = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hash2[i2 >> 1] >> 4 >= 8 && address2[i2]) {
      address2[i2] = address2[i2].toUpperCase();
    }
    if ((hash2[i2 >> 1] & 15) >= 8 && address2[i2 + 1]) {
      address2[i2 + 1] = address2[i2 + 1].toUpperCase();
    }
  }
  return `0x${address2.join("")}`;
}
var checksumAddress_1 = getAddress$2.checksumAddress = checksumAddress;
function getAddress(address2, chainId) {
  if (!(0, isAddress_js_1$6.isAddress)(address2))
    throw new address_js_1$6.InvalidAddressError({ address: address2 });
  return checksumAddress(address2, chainId);
}
getAddress_2 = getAddress$2.getAddress = getAddress;
const getAddress$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get checksumAddress() {
    return checksumAddress_1;
  },
  default: getAddress$2,
  get getAddress() {
    return getAddress_2;
  }
}, [getAddress$2]);
const require$$91 = /* @__PURE__ */ getAugmentedNamespace(getAddress$1);
Object.defineProperty(decodeAbiParameters$2, "__esModule", { value: true });
var decodeAbiParameters_2 = decodeAbiParameters$2.decodeAbiParameters = void 0;
const abi_js_1$g = requireAbi();
const getAddress_js_1$5 = require$$91;
const size_js_1$1 = require$$113;
const slice_js_1$3 = require$$114;
const trim_js_1$3 = require$$116;
const fromHex_js_1$d = requireFromHex();
const encodeAbiParameters_js_1$3 = require$$47;
function decodeAbiParameters(params, data2) {
  if (data2 === "0x" && params.length > 0)
    throw new abi_js_1$g.AbiDecodingZeroDataError();
  if ((0, size_js_1$1.size)(data2) && (0, size_js_1$1.size)(data2) < 32)
    throw new abi_js_1$g.AbiDecodingDataSizeTooSmallError({
      data: data2,
      params,
      size: (0, size_js_1$1.size)(data2)
    });
  return decodeParams({
    data: data2,
    params
  });
}
decodeAbiParameters_2 = decodeAbiParameters$2.decodeAbiParameters = decodeAbiParameters;
function decodeParams({ data: data2, params }) {
  const decodedValues = [];
  let position = 0;
  for (let i2 = 0; i2 < params.length; i2++) {
    if (position >= (0, size_js_1$1.size)(data2))
      throw new abi_js_1$g.AbiDecodingDataSizeTooSmallError({
        data: data2,
        params,
        size: (0, size_js_1$1.size)(data2)
      });
    const param = params[i2];
    const { consumed, value } = decodeParam({ data: data2, param, position });
    decodedValues.push(value);
    position += consumed;
  }
  return decodedValues;
}
function decodeParam({ data: data2, param, position }) {
  const arrayComponents = (0, encodeAbiParameters_js_1$3.getArrayComponents)(param.type);
  if (arrayComponents) {
    const [length2, type] = arrayComponents;
    return decodeArray(data2, {
      length: length2,
      param: { ...param, type },
      position
    });
  }
  if (param.type === "tuple") {
    return decodeTuple(data2, { param, position });
  }
  if (param.type === "string") {
    return decodeString(data2, { position });
  }
  if (param.type.startsWith("bytes")) {
    return decodeBytes$1(data2, { param, position });
  }
  const value = (0, slice_js_1$3.slice)(data2, position, position + 32, { strict: true });
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return decodeNumber(value, { param });
  }
  if (param.type === "address") {
    return decodeAddress(value);
  }
  if (param.type === "bool") {
    return decodeBool(value);
  }
  throw new abi_js_1$g.InvalidAbiDecodingTypeError(param.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
function decodeAddress(value) {
  return { consumed: 32, value: (0, getAddress_js_1$5.checksumAddress)((0, slice_js_1$3.slice)(value, -20)) };
}
function decodeArray(data2, { param, length: length2, position }) {
  if (!length2) {
    const offset = (0, fromHex_js_1$d.hexToNumber)((0, slice_js_1$3.slice)(data2, position, position + 32, { strict: true }));
    const length3 = (0, fromHex_js_1$d.hexToNumber)((0, slice_js_1$3.slice)(data2, offset, offset + 32, { strict: true }));
    let consumed2 = 0;
    const value2 = [];
    for (let i2 = 0; i2 < length3; ++i2) {
      const decodedChild = decodeParam({
        data: (0, slice_js_1$3.slice)(data2, offset + 32),
        param,
        position: consumed2
      });
      consumed2 += decodedChild.consumed;
      value2.push(decodedChild.value);
    }
    return { value: value2, consumed: 32 };
  }
  if (hasDynamicChild(param)) {
    const arrayComponents = (0, encodeAbiParameters_js_1$3.getArrayComponents)(param.type);
    const dynamicChild = !arrayComponents?.[0];
    let consumed2 = 0;
    const value2 = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      const offset = (0, fromHex_js_1$d.hexToNumber)((0, slice_js_1$3.slice)(data2, position, position + 32, { strict: true }));
      const decodedChild = decodeParam({
        data: (0, slice_js_1$3.slice)(data2, offset),
        param,
        position: dynamicChild ? consumed2 : i2 * 32
      });
      consumed2 += decodedChild.consumed;
      value2.push(decodedChild.value);
    }
    return { value: value2, consumed: 32 };
  }
  let consumed = 0;
  const value = [];
  for (let i2 = 0; i2 < length2; ++i2) {
    const decodedChild = decodeParam({
      data: data2,
      param,
      position: position + consumed
    });
    consumed += decodedChild.consumed;
    value.push(decodedChild.value);
  }
  return { value, consumed };
}
function decodeBool(value) {
  return { consumed: 32, value: (0, fromHex_js_1$d.hexToBool)(value) };
}
function decodeBytes$1(data2, { param, position }) {
  const [_2, size2] = param.type.split("bytes");
  if (!size2) {
    const offset = (0, fromHex_js_1$d.hexToNumber)((0, slice_js_1$3.slice)(data2, position, position + 32, { strict: true }));
    const length2 = (0, fromHex_js_1$d.hexToNumber)((0, slice_js_1$3.slice)(data2, offset, offset + 32, { strict: true }));
    if (length2 === 0)
      return { consumed: 32, value: "0x" };
    const value2 = (0, slice_js_1$3.slice)(data2, offset + 32, offset + 32 + length2, {
      strict: true
    });
    return { consumed: 32, value: value2 };
  }
  const value = (0, slice_js_1$3.slice)(data2, position, position + parseInt(size2), {
    strict: true
  });
  return { consumed: 32, value };
}
function decodeNumber(value, { param }) {
  const signed = param.type.startsWith("int");
  const size2 = parseInt(param.type.split("int")[1] || "256");
  return {
    consumed: 32,
    value: size2 > 48 ? (0, fromHex_js_1$d.hexToBigInt)(value, { signed }) : (0, fromHex_js_1$d.hexToNumber)(value, { signed })
  };
}
function decodeString(data2, { position }) {
  const offset = (0, fromHex_js_1$d.hexToNumber)((0, slice_js_1$3.slice)(data2, position, position + 32, { strict: true }));
  const length2 = (0, fromHex_js_1$d.hexToNumber)((0, slice_js_1$3.slice)(data2, offset, offset + 32, { strict: true }));
  if (length2 === 0)
    return { consumed: 32, value: "" };
  const value = (0, fromHex_js_1$d.hexToString)((0, trim_js_1$3.trim)((0, slice_js_1$3.slice)(data2, offset + 32, offset + 32 + length2, { strict: true })));
  return { consumed: 32, value };
}
function decodeTuple(data2, { param, position }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name: name2 }) => !name2);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset = (0, fromHex_js_1$d.hexToNumber)((0, slice_js_1$3.slice)(data2, position, position + 32, { strict: true }));
    for (let i2 = 0; i2 < param.components.length; ++i2) {
      const component = param.components[i2];
      const decodedChild = decodeParam({
        data: (0, slice_js_1$3.slice)(data2, offset),
        param: component,
        position: consumed
      });
      consumed += decodedChild.consumed;
      value[hasUnnamedChild ? i2 : component?.name] = decodedChild.value;
    }
    return { consumed: 32, value };
  }
  for (let i2 = 0; i2 < param.components.length; ++i2) {
    const component = param.components[i2];
    const decodedChild = decodeParam({
      data: data2,
      param: component,
      position: position + consumed
    });
    consumed += decodedChild.consumed;
    value[hasUnnamedChild ? i2 : component?.name] = decodedChild.value;
  }
  return { consumed, value };
}
function hasDynamicChild(param) {
  const { type } = param;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return param.components?.some(hasDynamicChild);
  const arrayComponents = (0, encodeAbiParameters_js_1$3.getArrayComponents)(param.type);
  if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
    return true;
  return false;
}
const decodeAbiParameters$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get decodeAbiParameters() {
    return decodeAbiParameters_2;
  },
  default: decodeAbiParameters$2
}, [decodeAbiParameters$2]);
const require$$41$1 = /* @__PURE__ */ getAugmentedNamespace(decodeAbiParameters$1);
Object.defineProperty(decodeErrorResult$2, "__esModule", { value: true });
var decodeErrorResult_2 = decodeErrorResult$2.decodeErrorResult = void 0;
const solidity_js_1$2 = require$$0$K;
const abi_js_1$f = requireAbi();
const slice_js_1$2 = require$$114;
const getFunctionSelector_js_1$2 = require$$95;
const decodeAbiParameters_js_1$4 = require$$41$1;
const formatAbiItem_js_1$4 = requireFormatAbiItem();
function decodeErrorResult({ abi: abi2, data: data2 }) {
  const signature2 = (0, slice_js_1$2.slice)(data2, 0, 4);
  if (signature2 === "0x")
    throw new abi_js_1$f.AbiDecodingZeroDataError();
  const abi_ = [...abi2 || [], solidity_js_1$2.solidityError, solidity_js_1$2.solidityPanic];
  const abiItem2 = abi_.find((x2) => x2.type === "error" && signature2 === (0, getFunctionSelector_js_1$2.getFunctionSelector)((0, formatAbiItem_js_1$4.formatAbiItem)(x2)));
  if (!abiItem2)
    throw new abi_js_1$f.AbiErrorSignatureNotFoundError(signature2, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: abiItem2,
    args: "inputs" in abiItem2 && abiItem2.inputs && abiItem2.inputs.length > 0 ? (0, decodeAbiParameters_js_1$4.decodeAbiParameters)(abiItem2.inputs, (0, slice_js_1$2.slice)(data2, 4)) : void 0,
    errorName: abiItem2.name
  };
}
decodeErrorResult_2 = decodeErrorResult$2.decodeErrorResult = decodeErrorResult;
const decodeErrorResult$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get decodeErrorResult() {
    return decodeErrorResult_2;
  },
  default: decodeErrorResult$2
}, [decodeErrorResult$2]);
const require$$43$1 = /* @__PURE__ */ getAugmentedNamespace(decodeErrorResult$1);
var formatAbiItemWithArgs$2 = {};
var stringify$2 = {};
Object.defineProperty(stringify$2, "__esModule", { value: true });
var stringify_2 = stringify$2.stringify = void 0;
const stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return typeof replacer === "function" ? replacer(key, value2) : value2;
}, space);
stringify_2 = stringify$2.stringify = stringify;
const stringify$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: stringify$2,
  get stringify() {
    return stringify_2;
  }
}, [stringify$2]);
const require$$115 = /* @__PURE__ */ getAugmentedNamespace(stringify$1);
Object.defineProperty(formatAbiItemWithArgs$2, "__esModule", { value: true });
var formatAbiItemWithArgs_2 = formatAbiItemWithArgs$2.formatAbiItemWithArgs = void 0;
const stringify_js_1$8 = require$$115;
function formatAbiItemWithArgs({ abiItem: abiItem2, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem2))
    return;
  if (!("inputs" in abiItem2))
    return;
  if (!abiItem2.inputs)
    return;
  return `${includeFunctionName ? abiItem2.name : ""}(${abiItem2.inputs.map((input, i2) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i2] === "object" ? (0, stringify_js_1$8.stringify)(args[i2]) : args[i2]}`).join(", ")})`;
}
formatAbiItemWithArgs_2 = formatAbiItemWithArgs$2.formatAbiItemWithArgs = formatAbiItemWithArgs;
const formatAbiItemWithArgs$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formatAbiItemWithArgs$2,
  get formatAbiItemWithArgs() {
    return formatAbiItemWithArgs_2;
  }
}, [formatAbiItemWithArgs$2]);
const require$$24$3 = /* @__PURE__ */ getAugmentedNamespace(formatAbiItemWithArgs$1);
var formatEther$2 = {};
var unit$1 = {};
Object.defineProperty(unit$1, "__esModule", { value: true });
var weiUnits = unit$1.weiUnits = gweiUnits = unit$1.gweiUnits = etherUnits = unit$1.etherUnits = void 0;
var etherUnits = unit$1.etherUnits = {
  gwei: 9,
  wei: 18
};
var gweiUnits = unit$1.gweiUnits = {
  ether: -9,
  wei: 9
};
weiUnits = unit$1.weiUnits = {
  ether: -18,
  gwei: -9
};
const unit = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: unit$1,
  get etherUnits() {
    return etherUnits;
  },
  get gweiUnits() {
    return gweiUnits;
  },
  get weiUnits() {
    return weiUnits;
  }
}, [unit$1]);
const require$$16$2 = /* @__PURE__ */ getAugmentedNamespace(unit);
var formatUnits$2 = {};
Object.defineProperty(formatUnits$2, "__esModule", { value: true });
var formatUnits_2 = formatUnits$2.formatUnits = void 0;
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
formatUnits_2 = formatUnits$2.formatUnits = formatUnits;
const formatUnits$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formatUnits$2,
  get formatUnits() {
    return formatUnits_2;
  }
}, [formatUnits$2]);
const require$$88 = /* @__PURE__ */ getAugmentedNamespace(formatUnits$1);
Object.defineProperty(formatEther$2, "__esModule", { value: true });
var formatEther_2 = formatEther$2.formatEther = void 0;
const unit_js_1$3 = require$$16$2;
const formatUnits_js_1$1 = require$$88;
function formatEther(wei, unit2 = "wei") {
  return (0, formatUnits_js_1$1.formatUnits)(wei, unit_js_1$3.etherUnits[unit2]);
}
formatEther_2 = formatEther$2.formatEther = formatEther;
const formatEther$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formatEther$2,
  get formatEther() {
    return formatEther_2;
  }
}, [formatEther$2]);
const require$$86 = /* @__PURE__ */ getAugmentedNamespace(formatEther$1);
var formatGwei$2 = {};
Object.defineProperty(formatGwei$2, "__esModule", { value: true });
var formatGwei_2 = formatGwei$2.formatGwei = void 0;
const unit_js_1$2 = require$$16$2;
const formatUnits_js_1 = require$$88;
function formatGwei(wei, unit2 = "wei") {
  return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1$2.gweiUnits[unit2]);
}
formatGwei_2 = formatGwei$2.formatGwei = formatGwei;
const formatGwei$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formatGwei$2,
  get formatGwei() {
    return formatGwei_2;
  }
}, [formatGwei$2]);
const require$$87 = /* @__PURE__ */ getAugmentedNamespace(formatGwei$1);
var transaction$4 = {};
Object.defineProperty(transaction$4, "__esModule", { value: true });
var WaitForTransactionReceiptTimeoutError_1 = transaction$4.WaitForTransactionReceiptTimeoutError = TransactionReceiptNotFoundError_1 = transaction$4.TransactionReceiptNotFoundError = TransactionNotFoundError_1 = transaction$4.TransactionNotFoundError = TransactionExecutionError_1 = transaction$4.TransactionExecutionError = InvalidStorageKeySizeError_1 = transaction$4.InvalidStorageKeySizeError = InvalidSerializedTransactionError_1 = transaction$4.InvalidSerializedTransactionError = InvalidSerializedTransactionTypeError_1 = transaction$4.InvalidSerializedTransactionTypeError = InvalidSerializableTransactionError_1 = transaction$4.InvalidSerializableTransactionError = InvalidLegacyVError_1 = transaction$4.InvalidLegacyVError = FeeConflictError_1 = transaction$4.FeeConflictError = prettyPrint_1 = transaction$4.prettyPrint = void 0;
const formatEther_js_1$2 = require$$86;
const formatGwei_js_1$4 = require$$87;
const base_js_1$j = require$$21$2;
function prettyPrint(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === void 0 || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
var prettyPrint_1 = transaction$4.prettyPrint = prettyPrint;
class FeeConflictError extends base_js_1$j.BaseError {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeConflictError"
    });
  }
}
var FeeConflictError_1 = transaction$4.FeeConflictError = FeeConflictError;
class InvalidLegacyVError extends base_js_1$j.BaseError {
  constructor({ v: v2 }) {
    super(`Invalid \`v\` value "${v2}". Expected 27 or 28.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidLegacyVError"
    });
  }
}
var InvalidLegacyVError_1 = transaction$4.InvalidLegacyVError = InvalidLegacyVError;
class InvalidSerializableTransactionError extends base_js_1$j.BaseError {
  constructor({ transaction: transaction2 }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(transaction2),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidSerializableTransactionError"
    });
  }
}
var InvalidSerializableTransactionError_1 = transaction$4.InvalidSerializableTransactionError = InvalidSerializableTransactionError;
class InvalidSerializedTransactionTypeError extends base_js_1$j.BaseError {
  constructor({ serializedType }) {
    super(`Serialized transaction type "${serializedType}" is invalid.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidSerializedTransactionType"
    });
    Object.defineProperty(this, "serializedType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.serializedType = serializedType;
  }
}
var InvalidSerializedTransactionTypeError_1 = transaction$4.InvalidSerializedTransactionTypeError = InvalidSerializedTransactionTypeError;
class InvalidSerializedTransactionError extends base_js_1$j.BaseError {
  constructor({ attributes, serializedTransaction, type }) {
    const missing = Object.entries(attributes).map(([key, value]) => typeof value === "undefined" ? key : void 0).filter(Boolean);
    super(`Invalid serialized transaction of type "${type}" was provided.`, {
      metaMessages: [
        `Serialized Transaction: "${serializedTransaction}"`,
        missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
      ].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidSerializedTransactionError"
    });
    Object.defineProperty(this, "serializedTransaction", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.serializedTransaction = serializedTransaction;
    this.type = type;
  }
}
var InvalidSerializedTransactionError_1 = transaction$4.InvalidSerializedTransactionError = InvalidSerializedTransactionError;
class InvalidStorageKeySizeError extends base_js_1$j.BaseError {
  constructor({ storageKey }) {
    super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidStorageKeySizeError"
    });
  }
}
var InvalidStorageKeySizeError_1 = transaction$4.InvalidStorageKeySizeError = InvalidStorageKeySizeError;
class TransactionExecutionError extends base_js_1$j.BaseError {
  constructor(cause, { account: account2, docsPath: docsPath2, chain: chain2, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      chain: chain2 && `${chain2?.name} (id: ${chain2?.id})`,
      from: account2?.address,
      to,
      value: typeof value !== "undefined" && `${(0, formatEther_js_1$2.formatEther)(value)} ${chain2?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1$4.formatGwei)(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1$4.formatGwei)(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1$4.formatGwei)(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Request Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionExecutionError"
    });
    this.cause = cause;
  }
}
var TransactionExecutionError_1 = transaction$4.TransactionExecutionError = TransactionExecutionError;
class TransactionNotFoundError extends base_js_1$j.BaseError {
  constructor({ blockHash, blockNumber, blockTag, hash: hash2, index: index2 }) {
    let identifier = "Transaction";
    if (blockTag && index2 !== void 0)
      identifier = `Transaction at block time "${blockTag}" at index "${index2}"`;
    if (blockHash && index2 !== void 0)
      identifier = `Transaction at block hash "${blockHash}" at index "${index2}"`;
    if (blockNumber && index2 !== void 0)
      identifier = `Transaction at block number "${blockNumber}" at index "${index2}"`;
    if (hash2)
      identifier = `Transaction with hash "${hash2}"`;
    super(`${identifier} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionNotFoundError"
    });
  }
}
var TransactionNotFoundError_1 = transaction$4.TransactionNotFoundError = TransactionNotFoundError;
class TransactionReceiptNotFoundError extends base_js_1$j.BaseError {
  constructor({ hash: hash2 }) {
    super(`Transaction receipt with hash "${hash2}" could not be found. The Transaction may not be processed on a block yet.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionReceiptNotFoundError"
    });
  }
}
var TransactionReceiptNotFoundError_1 = transaction$4.TransactionReceiptNotFoundError = TransactionReceiptNotFoundError;
class WaitForTransactionReceiptTimeoutError extends base_js_1$j.BaseError {
  constructor({ hash: hash2 }) {
    super(`Timed out while waiting for transaction with hash "${hash2}" to be confirmed.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WaitForTransactionReceiptTimeoutError"
    });
  }
}
WaitForTransactionReceiptTimeoutError_1 = transaction$4.WaitForTransactionReceiptTimeoutError = WaitForTransactionReceiptTimeoutError;
const transaction$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get FeeConflictError() {
    return FeeConflictError_1;
  },
  get InvalidLegacyVError() {
    return InvalidLegacyVError_1;
  },
  get InvalidSerializableTransactionError() {
    return InvalidSerializableTransactionError_1;
  },
  get InvalidSerializedTransactionError() {
    return InvalidSerializedTransactionError_1;
  },
  get InvalidSerializedTransactionTypeError() {
    return InvalidSerializedTransactionTypeError_1;
  },
  get InvalidStorageKeySizeError() {
    return InvalidStorageKeySizeError_1;
  },
  get TransactionExecutionError() {
    return TransactionExecutionError_1;
  },
  get TransactionNotFoundError() {
    return TransactionNotFoundError_1;
  },
  get TransactionReceiptNotFoundError() {
    return TransactionReceiptNotFoundError_1;
  },
  get WaitForTransactionReceiptTimeoutError() {
    return WaitForTransactionReceiptTimeoutError_1;
  },
  default: transaction$4,
  get prettyPrint() {
    return prettyPrint_1;
  }
}, [transaction$4]);
const require$$34$1 = /* @__PURE__ */ getAugmentedNamespace(transaction$3);
Object.defineProperty(contract$3, "__esModule", { value: true });
var RawContractError_1 = contract$3.RawContractError = ContractFunctionZeroDataError_1 = contract$3.ContractFunctionZeroDataError = ContractFunctionRevertedError_1 = contract$3.ContractFunctionRevertedError = ContractFunctionExecutionError_1 = contract$3.ContractFunctionExecutionError = CallExecutionError_1 = contract$3.CallExecutionError = void 0;
const parseAccount_js_1$6 = require$$0$L;
const solidity_js_1$1 = require$$0$K;
const decodeErrorResult_js_1 = require$$43$1;
const formatAbiItem_js_1$3 = requireFormatAbiItem();
const formatAbiItemWithArgs_js_1 = require$$24$3;
const getAbiItem_js_1$4 = require$$56$1;
const formatEther_js_1$1 = require$$86;
const formatGwei_js_1$3 = require$$87;
const abi_js_1$e = requireAbi();
const base_js_1$i = require$$21$2;
const transaction_js_1$c = require$$34$1;
const utils_js_1$6 = require$$2$g;
class CallExecutionError extends base_js_1$i.BaseError {
  constructor(cause, { account: account_, docsPath: docsPath2, chain: chain2, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const account2 = account_ ? (0, parseAccount_js_1$6.parseAccount)(account_) : void 0;
    const prettyArgs = (0, transaction_js_1$c.prettyPrint)({
      from: account2?.address,
      to,
      value: typeof value !== "undefined" && `${(0, formatEther_js_1$1.formatEther)(value)} ${chain2?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1$3.formatGwei)(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1$3.formatGwei)(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1$3.formatGwei)(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Raw Call Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "CallExecutionError"
    });
    this.cause = cause;
  }
}
var CallExecutionError_1 = contract$3.CallExecutionError = CallExecutionError;
class ContractFunctionExecutionError extends base_js_1$i.BaseError {
  constructor(cause, { abi: abi2, args, contractAddress, docsPath: docsPath2, functionName, sender }) {
    const abiItem2 = (0, getAbiItem_js_1$4.getAbiItem)({ abi: abi2, args, name: functionName });
    const formattedArgs = abiItem2 ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
      abiItem: abiItem2,
      args,
      includeFunctionName: false,
      includeName: false
    }) : void 0;
    const functionWithParams = abiItem2 ? (0, formatAbiItem_js_1$3.formatAbiItem)(abiItem2, { includeName: true }) : void 0;
    const prettyArgs = (0, transaction_js_1$c.prettyPrint)({
      address: contractAddress && (0, utils_js_1$6.getContractAddress)(contractAddress),
      function: functionWithParams,
      args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
      sender
    });
    super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Contract Call:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "abi", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "args", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "contractAddress", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "formattedArgs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "functionName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "sender", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionExecutionError"
    });
    this.abi = abi2;
    this.args = args;
    this.cause = cause;
    this.contractAddress = contractAddress;
    this.functionName = functionName;
    this.sender = sender;
  }
}
var ContractFunctionExecutionError_1 = contract$3.ContractFunctionExecutionError = ContractFunctionExecutionError;
class ContractFunctionRevertedError extends base_js_1$i.BaseError {
  constructor({ abi: abi2, data: data2, functionName, message }) {
    let cause;
    let decodedData2 = void 0;
    let metaMessages;
    let reason;
    if (data2 && data2 !== "0x") {
      try {
        decodedData2 = (0, decodeErrorResult_js_1.decodeErrorResult)({ abi: abi2, data: data2 });
        const { abiItem: abiItem2, errorName, args: errorArgs } = decodedData2;
        if (errorName === "Error") {
          reason = errorArgs[0];
        } else if (errorName === "Panic") {
          const [firstArg] = errorArgs;
          reason = solidity_js_1$1.panicReasons[firstArg];
        } else {
          const errorWithParams = abiItem2 ? (0, formatAbiItem_js_1$3.formatAbiItem)(abiItem2, { includeName: true }) : void 0;
          const formattedArgs = abiItem2 && errorArgs ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
            abiItem: abiItem2,
            args: errorArgs,
            includeFunctionName: false,
            includeName: false
          }) : void 0;
          metaMessages = [
            errorWithParams ? `Error: ${errorWithParams}` : "",
            formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
          ];
        }
      } catch (err) {
        cause = err;
      }
    } else if (message)
      reason = message;
    let signature2;
    if (cause instanceof abi_js_1$e.AbiErrorSignatureNotFoundError) {
      signature2 = cause.signature;
      metaMessages = [
        `Unable to decode signature "${signature2}" as it was not found on the provided ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
      ];
    }
    super(reason && reason !== "execution reverted" || signature2 ? [
      `The contract function "${functionName}" reverted with the following ${signature2 ? "signature" : "reason"}:`,
      reason || signature2
    ].join("\n") : `The contract function "${functionName}" reverted.`, {
      cause,
      metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionRevertedError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "reason", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = decodedData2;
    this.reason = reason;
    this.signature = signature2;
  }
}
var ContractFunctionRevertedError_1 = contract$3.ContractFunctionRevertedError = ContractFunctionRevertedError;
class ContractFunctionZeroDataError extends base_js_1$i.BaseError {
  constructor({ functionName }) {
    super(`The contract function "${functionName}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${functionName}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionZeroDataError"
    });
  }
}
var ContractFunctionZeroDataError_1 = contract$3.ContractFunctionZeroDataError = ContractFunctionZeroDataError;
class RawContractError extends base_js_1$i.BaseError {
  constructor({ data: data2, message }) {
    super(message || "");
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RawContractError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data2;
  }
}
RawContractError_1 = contract$3.RawContractError = RawContractError;
const contract$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get CallExecutionError() {
    return CallExecutionError_1;
  },
  get ContractFunctionExecutionError() {
    return ContractFunctionExecutionError_1;
  },
  get ContractFunctionRevertedError() {
    return ContractFunctionRevertedError_1;
  },
  get ContractFunctionZeroDataError() {
    return ContractFunctionZeroDataError_1;
  },
  get RawContractError() {
    return RawContractError_1;
  },
  default: contract$3
}, [contract$3]);
const require$$23$2 = /* @__PURE__ */ getAugmentedNamespace(contract$2);
var rpc$7 = {};
var request$1 = {};
Object.defineProperty(request$1, "__esModule", { value: true });
var TimeoutError_1 = request$1.TimeoutError = RpcRequestError_1 = request$1.RpcRequestError = WebSocketRequestError_1 = request$1.WebSocketRequestError = HttpRequestError_1 = request$1.HttpRequestError = void 0;
const stringify_js_1$7 = require$$115;
const base_js_1$h = require$$21$2;
const utils_js_1$5 = require$$2$g;
class HttpRequestError extends base_js_1$h.BaseError {
  constructor({ body, details, headers, status, url }) {
    super("HTTP request failed.", {
      details,
      metaMessages: [
        status && `Status: ${status}`,
        `URL: ${(0, utils_js_1$5.getUrl)(url)}`,
        body && `Request body: ${(0, stringify_js_1$7.stringify)(body)}`
      ].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "HttpRequestError"
    });
    Object.defineProperty(this, "body", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "url", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.body = body;
    this.headers = headers;
    this.status = status;
    this.url = url;
  }
}
var HttpRequestError_1 = request$1.HttpRequestError = HttpRequestError;
class WebSocketRequestError extends base_js_1$h.BaseError {
  constructor({ body, details, url }) {
    super("WebSocket request failed.", {
      details,
      metaMessages: [`URL: ${(0, utils_js_1$5.getUrl)(url)}`, `Request body: ${(0, stringify_js_1$7.stringify)(body)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebSocketRequestError"
    });
  }
}
var WebSocketRequestError_1 = request$1.WebSocketRequestError = WebSocketRequestError;
class RpcRequestError extends base_js_1$h.BaseError {
  constructor({ body, error, url }) {
    super("RPC Request failed.", {
      cause: error,
      details: error.message,
      metaMessages: [`URL: ${(0, utils_js_1$5.getUrl)(url)}`, `Request body: ${(0, stringify_js_1$7.stringify)(body)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcRequestError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = error.code;
  }
}
var RpcRequestError_1 = request$1.RpcRequestError = RpcRequestError;
class TimeoutError extends base_js_1$h.BaseError {
  constructor({ body, url }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${(0, utils_js_1$5.getUrl)(url)}`, `Request body: ${(0, stringify_js_1$7.stringify)(body)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TimeoutError"
    });
  }
}
TimeoutError_1 = request$1.TimeoutError = TimeoutError;
const request = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get HttpRequestError() {
    return HttpRequestError_1;
  },
  get RpcRequestError() {
    return RpcRequestError_1;
  },
  get TimeoutError() {
    return TimeoutError_1;
  },
  get WebSocketRequestError() {
    return WebSocketRequestError_1;
  },
  default: request$1
}, [request$1]);
const require$$32$2 = /* @__PURE__ */ getAugmentedNamespace(request);
Object.defineProperty(rpc$7, "__esModule", { value: true });
var UnknownRpcError_1 = rpc$7.UnknownRpcError = SwitchChainError_1 = rpc$7.SwitchChainError = ChainDisconnectedError_1 = rpc$7.ChainDisconnectedError = ProviderDisconnectedError_1 = rpc$7.ProviderDisconnectedError = UnsupportedProviderMethodError_1 = rpc$7.UnsupportedProviderMethodError = UnauthorizedProviderError_1 = rpc$7.UnauthorizedProviderError = UserRejectedRequestError_1 = rpc$7.UserRejectedRequestError = JsonRpcVersionUnsupportedError_1 = rpc$7.JsonRpcVersionUnsupportedError = LimitExceededRpcError_1 = rpc$7.LimitExceededRpcError = MethodNotSupportedRpcError_1 = rpc$7.MethodNotSupportedRpcError = TransactionRejectedRpcError_1 = rpc$7.TransactionRejectedRpcError = ResourceUnavailableRpcError_1 = rpc$7.ResourceUnavailableRpcError = ResourceNotFoundRpcError_1 = rpc$7.ResourceNotFoundRpcError = InvalidInputRpcError_1 = rpc$7.InvalidInputRpcError = InternalRpcError_1 = rpc$7.InternalRpcError = InvalidParamsRpcError_1 = rpc$7.InvalidParamsRpcError = MethodNotFoundRpcError_1 = rpc$7.MethodNotFoundRpcError = InvalidRequestRpcError_1 = rpc$7.InvalidRequestRpcError = ParseRpcError_1 = rpc$7.ParseRpcError = ProviderRpcError_1 = rpc$7.ProviderRpcError = RpcError_1 = rpc$7.RpcError = void 0;
const base_js_1$g = require$$21$2;
const request_js_1$3 = require$$32$2;
const unknownErrorCode = -1;
class RpcError extends base_js_1$g.BaseError {
  constructor(cause, { code: code2, docsPath: docsPath2, metaMessages, shortMessage }) {
    super(shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: metaMessages || cause?.metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = cause.name;
    this.code = cause instanceof request_js_1$3.RpcRequestError ? cause.code : code2 ?? unknownErrorCode;
  }
}
var RpcError_1 = rpc$7.RpcError = RpcError;
class ProviderRpcError extends RpcError {
  constructor(cause, options) {
    super(cause, options);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderRpcError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = options.data;
  }
}
var ProviderRpcError_1 = rpc$7.ProviderRpcError = ProviderRpcError;
class ParseRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ParseRpcError.code,
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ParseRpcError"
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});
var ParseRpcError_1 = rpc$7.ParseRpcError = ParseRpcError;
class InvalidRequestRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidRequestRpcError.code,
      shortMessage: "JSON is not a valid request object."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidRequestRpcError"
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
var InvalidRequestRpcError_1 = rpc$7.InvalidRequestRpcError = InvalidRequestRpcError;
class MethodNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: MethodNotFoundRpcError.code,
      shortMessage: "The method does not exist / is not available."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MethodNotFoundRpcError"
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
var MethodNotFoundRpcError_1 = rpc$7.MethodNotFoundRpcError = MethodNotFoundRpcError;
class InvalidParamsRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidParamsRpcError.code,
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParamsRpcError"
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
var InvalidParamsRpcError_1 = rpc$7.InvalidParamsRpcError = InvalidParamsRpcError;
class InternalRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InternalRpcError.code,
      shortMessage: "An internal error was received."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InternalRpcError"
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
var InternalRpcError_1 = rpc$7.InternalRpcError = InternalRpcError;
class InvalidInputRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidInputRpcError.code,
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidInputRpcError"
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
var InvalidInputRpcError_1 = rpc$7.InvalidInputRpcError = InvalidInputRpcError;
class ResourceNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceNotFoundRpcError.code,
      shortMessage: "Requested resource not found."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
var ResourceNotFoundRpcError_1 = rpc$7.ResourceNotFoundRpcError = ResourceNotFoundRpcError;
class ResourceUnavailableRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceUnavailableRpcError.code,
      shortMessage: "Requested resource not available."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceUnavailableRpcError"
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
var ResourceUnavailableRpcError_1 = rpc$7.ResourceUnavailableRpcError = ResourceUnavailableRpcError;
class TransactionRejectedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: TransactionRejectedRpcError.code,
      shortMessage: "Transaction creation failed."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionRejectedRpcError"
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
var TransactionRejectedRpcError_1 = rpc$7.TransactionRejectedRpcError = TransactionRejectedRpcError;
class MethodNotSupportedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: MethodNotSupportedRpcError.code,
      shortMessage: "Method is not implemented."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MethodNotSupportedRpcError"
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
var MethodNotSupportedRpcError_1 = rpc$7.MethodNotSupportedRpcError = MethodNotSupportedRpcError;
class LimitExceededRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: LimitExceededRpcError.code,
      shortMessage: "Request exceeds defined limit."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "LimitExceededRpcError"
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
var LimitExceededRpcError_1 = rpc$7.LimitExceededRpcError = LimitExceededRpcError;
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: JsonRpcVersionUnsupportedError.code,
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "JsonRpcVersionUnsupportedError"
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
var JsonRpcVersionUnsupportedError_1 = rpc$7.JsonRpcVersionUnsupportedError = JsonRpcVersionUnsupportedError;
class UserRejectedRequestError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UserRejectedRequestError.code,
      shortMessage: "User rejected the request."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UserRejectedRequestError"
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
var UserRejectedRequestError_1 = rpc$7.UserRejectedRequestError = UserRejectedRequestError;
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnauthorizedProviderError.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnauthorizedProviderError"
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
var UnauthorizedProviderError_1 = rpc$7.UnauthorizedProviderError = UnauthorizedProviderError;
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnsupportedProviderMethodError.code,
      shortMessage: "The Provider does not support the requested method."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnsupportedProviderMethodError"
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
var UnsupportedProviderMethodError_1 = rpc$7.UnsupportedProviderMethodError = UnsupportedProviderMethodError;
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ProviderDisconnectedError.code,
      shortMessage: "The Provider is disconnected from all chains."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderDisconnectedError"
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
var ProviderDisconnectedError_1 = rpc$7.ProviderDisconnectedError = ProviderDisconnectedError;
class ChainDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ChainDisconnectedError.code,
      shortMessage: "The Provider is not connected to the requested chain."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainDisconnectedError"
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
var ChainDisconnectedError_1 = rpc$7.ChainDisconnectedError = ChainDisconnectedError;
class SwitchChainError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: SwitchChainError.code,
      shortMessage: "An error occurred when attempting to switch chain."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SwitchChainError"
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
var SwitchChainError_1 = rpc$7.SwitchChainError = SwitchChainError;
class UnknownRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      shortMessage: "An unknown RPC error occurred."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownRpcError"
    });
  }
}
UnknownRpcError_1 = rpc$7.UnknownRpcError = UnknownRpcError;
const rpc$6 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get ChainDisconnectedError() {
    return ChainDisconnectedError_1;
  },
  get InternalRpcError() {
    return InternalRpcError_1;
  },
  get InvalidInputRpcError() {
    return InvalidInputRpcError_1;
  },
  get InvalidParamsRpcError() {
    return InvalidParamsRpcError_1;
  },
  get InvalidRequestRpcError() {
    return InvalidRequestRpcError_1;
  },
  get JsonRpcVersionUnsupportedError() {
    return JsonRpcVersionUnsupportedError_1;
  },
  get LimitExceededRpcError() {
    return LimitExceededRpcError_1;
  },
  get MethodNotFoundRpcError() {
    return MethodNotFoundRpcError_1;
  },
  get MethodNotSupportedRpcError() {
    return MethodNotSupportedRpcError_1;
  },
  get ParseRpcError() {
    return ParseRpcError_1;
  },
  get ProviderDisconnectedError() {
    return ProviderDisconnectedError_1;
  },
  get ProviderRpcError() {
    return ProviderRpcError_1;
  },
  get ResourceNotFoundRpcError() {
    return ResourceNotFoundRpcError_1;
  },
  get ResourceUnavailableRpcError() {
    return ResourceUnavailableRpcError_1;
  },
  get RpcError() {
    return RpcError_1;
  },
  get SwitchChainError() {
    return SwitchChainError_1;
  },
  get TransactionRejectedRpcError() {
    return TransactionRejectedRpcError_1;
  },
  get UnauthorizedProviderError() {
    return UnauthorizedProviderError_1;
  },
  get UnknownRpcError() {
    return UnknownRpcError_1;
  },
  get UnsupportedProviderMethodError() {
    return UnsupportedProviderMethodError_1;
  },
  get UserRejectedRequestError() {
    return UserRejectedRequestError_1;
  },
  default: rpc$7
}, [rpc$7]);
const require$$25$2 = /* @__PURE__ */ getAugmentedNamespace(rpc$6);
Object.defineProperty(getContractError$2, "__esModule", { value: true });
var getContractError_2 = getContractError$2.getContractError = void 0;
const abi_js_1$d = requireAbi();
const base_js_1$f = require$$21$2;
const contract_js_1$3 = require$$23$2;
const rpc_js_1$4 = require$$25$2;
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi: abi2, address: address2, args, docsPath: docsPath2, functionName, sender }) {
  const { code: code2, data: data2, message, shortMessage } = err instanceof contract_js_1$3.RawContractError ? err : err instanceof base_js_1$f.BaseError ? err.walk((err2) => "data" in err2) || err.walk() : {};
  const cause = (() => {
    if (err instanceof abi_js_1$d.AbiDecodingZeroDataError)
      return new contract_js_1$3.ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, rpc_js_1$4.InternalRpcError.code].includes(code2) && (data2 || message || shortMessage)) {
      return new contract_js_1$3.ContractFunctionRevertedError({
        abi: abi2,
        data: typeof data2 === "object" ? data2.data : data2,
        functionName,
        message: shortMessage ?? message
      });
    }
    return err;
  })();
  return new contract_js_1$3.ContractFunctionExecutionError(cause, {
    abi: abi2,
    args,
    contractAddress: address2,
    docsPath: docsPath2,
    functionName,
    sender
  });
}
getContractError_2 = getContractError$2.getContractError = getContractError;
const getContractError$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getContractError$2,
  get getContractError() {
    return getContractError_2;
  }
}, [getContractError$2]);
const require$$92 = /* @__PURE__ */ getAugmentedNamespace(getContractError$1);
var estimateGas$2 = {};
var account$1 = {};
Object.defineProperty(account$1, "__esModule", { value: true });
var AccountNotFoundError_1 = account$1.AccountNotFoundError = void 0;
const base_js_1$e = require$$21$2;
class AccountNotFoundError extends base_js_1$e.BaseError {
  constructor({ docsPath: docsPath2 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
    ].join("\n"), {
      docsPath: docsPath2,
      docsSlug: "account"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccountNotFoundError"
    });
  }
}
AccountNotFoundError_1 = account$1.AccountNotFoundError = AccountNotFoundError;
const account = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get AccountNotFoundError() {
    return AccountNotFoundError_1;
  },
  default: account$1
}, [account$1]);
const require$$1$o = /* @__PURE__ */ getAugmentedNamespace(account);
var getEstimateGasError$2 = {};
var estimateGas$1 = {};
Object.defineProperty(estimateGas$1, "__esModule", { value: true });
var EstimateGasExecutionError_1 = estimateGas$1.EstimateGasExecutionError = void 0;
const formatEther_js_1 = require$$86;
const formatGwei_js_1$2 = require$$87;
const base_js_1$d = require$$21$2;
const transaction_js_1$b = require$$34$1;
class EstimateGasExecutionError extends base_js_1$d.BaseError {
  constructor(cause, { account: account2, docsPath: docsPath2, chain: chain2, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = (0, transaction_js_1$b.prettyPrint)({
      from: account2?.address,
      to,
      value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain2?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1$2.formatGwei)(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1$2.formatGwei)(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1$2.formatGwei)(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EstimateGasExecutionError"
    });
    this.cause = cause;
  }
}
EstimateGasExecutionError_1 = estimateGas$1.EstimateGasExecutionError = EstimateGasExecutionError;
const estimateGas = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get EstimateGasExecutionError() {
    return EstimateGasExecutionError_1;
  },
  default: estimateGas$1
}, [estimateGas$1]);
const require$$29$2 = /* @__PURE__ */ getAugmentedNamespace(estimateGas);
var node$1 = {};
Object.defineProperty(node$1, "__esModule", { value: true });
var UnknownNodeError_1 = node$1.UnknownNodeError = TipAboveFeeCapError_1 = node$1.TipAboveFeeCapError = TransactionTypeNotSupportedError_1 = node$1.TransactionTypeNotSupportedError = IntrinsicGasTooLowError_1 = node$1.IntrinsicGasTooLowError = IntrinsicGasTooHighError_1 = node$1.IntrinsicGasTooHighError = InsufficientFundsError_1 = node$1.InsufficientFundsError = NonceMaxValueError_1 = node$1.NonceMaxValueError = NonceTooLowError_1 = node$1.NonceTooLowError = NonceTooHighError_1 = node$1.NonceTooHighError = FeeCapTooLowError_1 = node$1.FeeCapTooLowError = FeeCapTooHighError_1 = node$1.FeeCapTooHighError = ExecutionRevertedError_1 = node$1.ExecutionRevertedError = void 0;
const formatGwei_js_1$1 = require$$87;
const base_js_1$c = require$$21$2;
class ExecutionRevertedError extends base_js_1$c.BaseError {
  constructor({ cause, message } = {}) {
    const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
    super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
var ExecutionRevertedError_1 = node$1.ExecutionRevertedError = ExecutionRevertedError;
class FeeCapTooHighError extends base_js_1$c.BaseError {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1$1.formatGwei)(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeCapTooHigh"
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
var FeeCapTooHighError_1 = node$1.FeeCapTooHighError = FeeCapTooHighError;
class FeeCapTooLowError extends base_js_1$c.BaseError {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1$1.formatGwei)(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeCapTooLow"
    });
  }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
var FeeCapTooLowError_1 = node$1.FeeCapTooLowError = FeeCapTooLowError;
class NonceTooHighError extends base_js_1$c.BaseError {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceTooHighError"
    });
  }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too high/
});
var NonceTooHighError_1 = node$1.NonceTooHighError = NonceTooHighError;
class NonceTooLowError extends base_js_1$c.BaseError {
  constructor({ cause, nonce } = {}) {
    super([
      `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join("\n"), { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceTooLowError"
    });
  }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too low|transaction already imported|already known/
});
var NonceTooLowError_1 = node$1.NonceTooLowError = NonceTooLowError;
class NonceMaxValueError extends base_js_1$c.BaseError {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceMaxValueError"
    });
  }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce has max value/
});
var NonceMaxValueError_1 = node$1.NonceMaxValueError = NonceMaxValueError;
class InsufficientFundsError extends base_js_1$c.BaseError {
  constructor({ cause } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join("\n"), {
      cause,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /insufficient funds/
});
var InsufficientFundsError_1 = node$1.InsufficientFundsError = InsufficientFundsError;
class IntrinsicGasTooHighError extends base_js_1$c.BaseError {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too high|gas limit reached/
});
var IntrinsicGasTooHighError_1 = node$1.IntrinsicGasTooHighError = IntrinsicGasTooHighError;
class IntrinsicGasTooLowError extends base_js_1$c.BaseError {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too low/
});
var IntrinsicGasTooLowError_1 = node$1.IntrinsicGasTooLowError = IntrinsicGasTooLowError;
class TransactionTypeNotSupportedError extends base_js_1$c.BaseError {
  constructor({ cause }) {
    super("The transaction type is not supported for this chain.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /transaction type not valid/
});
var TransactionTypeNotSupportedError_1 = node$1.TransactionTypeNotSupportedError = TransactionTypeNotSupportedError;
class TipAboveFeeCapError extends base_js_1$c.BaseError {
  constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${(0, formatGwei_js_1$1.formatGwei)(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1$1.formatGwei)(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"), {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
var TipAboveFeeCapError_1 = node$1.TipAboveFeeCapError = TipAboveFeeCapError;
class UnknownNodeError extends base_js_1$c.BaseError {
  constructor({ cause }) {
    super(`An error occurred while executing: ${cause?.shortMessage}`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownNodeError"
    });
  }
}
UnknownNodeError_1 = node$1.UnknownNodeError = UnknownNodeError;
const node = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get ExecutionRevertedError() {
    return ExecutionRevertedError_1;
  },
  get FeeCapTooHighError() {
    return FeeCapTooHighError_1;
  },
  get FeeCapTooLowError() {
    return FeeCapTooLowError_1;
  },
  get InsufficientFundsError() {
    return InsufficientFundsError_1;
  },
  get IntrinsicGasTooHighError() {
    return IntrinsicGasTooHighError_1;
  },
  get IntrinsicGasTooLowError() {
    return IntrinsicGasTooLowError_1;
  },
  get NonceMaxValueError() {
    return NonceMaxValueError_1;
  },
  get NonceTooHighError() {
    return NonceTooHighError_1;
  },
  get NonceTooLowError() {
    return NonceTooLowError_1;
  },
  get TipAboveFeeCapError() {
    return TipAboveFeeCapError_1;
  },
  get TransactionTypeNotSupportedError() {
    return TransactionTypeNotSupportedError_1;
  },
  get UnknownNodeError() {
    return UnknownNodeError_1;
  },
  default: node$1
}, [node$1]);
const require$$30$1 = /* @__PURE__ */ getAugmentedNamespace(node);
var getNodeError$2 = {};
Object.defineProperty(getNodeError$2, "__esModule", { value: true });
var getNodeError_2 = getNodeError$2.getNodeError = containsNodeError_1 = getNodeError$2.containsNodeError = void 0;
const base_js_1$b = require$$21$2;
const node_js_1$5 = require$$30$1;
const request_js_1$2 = require$$32$2;
const rpc_js_1$3 = require$$25$2;
function containsNodeError(err) {
  return err instanceof rpc_js_1$3.TransactionRejectedRpcError || err instanceof rpc_js_1$3.InvalidInputRpcError || err instanceof request_js_1$2.RpcRequestError && err.code === node_js_1$5.ExecutionRevertedError.code;
}
var containsNodeError_1 = getNodeError$2.containsNodeError = containsNodeError;
function getNodeError(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err.walk((e2) => e2.code === node_js_1$5.ExecutionRevertedError.code);
  if (executionRevertedError instanceof base_js_1$b.BaseError) {
    return new node_js_1$5.ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details
    });
  }
  if (node_js_1$5.ExecutionRevertedError.nodeMessage.test(message))
    return new node_js_1$5.ExecutionRevertedError({
      cause: err,
      message: err.details
    });
  if (node_js_1$5.FeeCapTooHighError.nodeMessage.test(message))
    return new node_js_1$5.FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (node_js_1$5.FeeCapTooLowError.nodeMessage.test(message))
    return new node_js_1$5.FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (node_js_1$5.NonceTooHighError.nodeMessage.test(message))
    return new node_js_1$5.NonceTooHighError({ cause: err, nonce: args?.nonce });
  if (node_js_1$5.NonceTooLowError.nodeMessage.test(message))
    return new node_js_1$5.NonceTooLowError({ cause: err, nonce: args?.nonce });
  if (node_js_1$5.NonceMaxValueError.nodeMessage.test(message))
    return new node_js_1$5.NonceMaxValueError({ cause: err, nonce: args?.nonce });
  if (node_js_1$5.InsufficientFundsError.nodeMessage.test(message))
    return new node_js_1$5.InsufficientFundsError({ cause: err });
  if (node_js_1$5.IntrinsicGasTooHighError.nodeMessage.test(message))
    return new node_js_1$5.IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
  if (node_js_1$5.IntrinsicGasTooLowError.nodeMessage.test(message))
    return new node_js_1$5.IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
  if (node_js_1$5.TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new node_js_1$5.TransactionTypeNotSupportedError({ cause: err });
  if (node_js_1$5.TipAboveFeeCapError.nodeMessage.test(message))
    return new node_js_1$5.TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
      maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
  return new node_js_1$5.UnknownNodeError({
    cause: err
  });
}
getNodeError_2 = getNodeError$2.getNodeError = getNodeError;
const getNodeError$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get containsNodeError() {
    return containsNodeError_1;
  },
  default: getNodeError$2,
  get getNodeError() {
    return getNodeError_2;
  }
}, [getNodeError$2]);
const require$$52$1 = /* @__PURE__ */ getAugmentedNamespace(getNodeError$1);
Object.defineProperty(getEstimateGasError$2, "__esModule", { value: true });
var getEstimateGasError_2 = getEstimateGasError$2.getEstimateGasError = void 0;
const estimateGas_js_1$1 = require$$29$2;
const node_js_1$4 = require$$30$1;
const getNodeError_js_1$2 = require$$52$1;
function getEstimateGasError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = (0, getNodeError_js_1$2.getNodeError)(err, args);
    if (cause2 instanceof node_js_1$4.UnknownNodeError)
      return err;
    return cause2;
  })();
  return new estimateGas_js_1$1.EstimateGasExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
getEstimateGasError_2 = getEstimateGasError$2.getEstimateGasError = getEstimateGasError;
const getEstimateGasError$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getEstimateGasError$2,
  get getEstimateGasError() {
    return getEstimateGasError_2;
  }
}, [getEstimateGasError$2]);
const require$$55$1 = /* @__PURE__ */ getAugmentedNamespace(getEstimateGasError$1);
var extract$2 = {};
Object.defineProperty(extract$2, "__esModule", { value: true });
var extract_2 = extract$2.extract = void 0;
function extract(value_, { format }) {
  if (!format)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys2 = Object.keys(formatted2);
    for (const key of keys2) {
      if (key in value_)
        value[key] = value_[key];
      if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
        extract_(formatted2[key]);
    }
  }
  const formatted = format(value_ || {});
  extract_(formatted);
  return value;
}
extract_2 = extract$2.extract = extract;
const extract$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: extract$2,
  get extract() {
    return extract_2;
  }
}, [extract$2]);
const require$$0$J = /* @__PURE__ */ getAugmentedNamespace(extract$1);
var transactionRequest$2 = {};
var formatter$1 = {};
Object.defineProperty(formatter$1, "__esModule", { value: true });
var defineFormatter_1 = formatter$1.defineFormatter = void 0;
function defineFormatter(type, format) {
  return ({ exclude, format: overrides }) => {
    return {
      exclude,
      format: (args) => {
        const formatted = format(args);
        if (exclude) {
          for (const key of exclude) {
            delete formatted[key];
          }
        }
        return {
          ...formatted,
          ...overrides(args)
        };
      },
      type
    };
  };
}
defineFormatter_1 = formatter$1.defineFormatter = defineFormatter;
const formatter = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formatter$1,
  get defineFormatter() {
    return defineFormatter_1;
  }
}, [formatter$1]);
const require$$57 = /* @__PURE__ */ getAugmentedNamespace(formatter);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineTransactionRequest = exports.formatTransactionRequest = exports.rpcTransactionType = void 0;
  const toHex_js_12 = requireToHex();
  const formatter_js_12 = require$$57;
  exports.rpcTransactionType = {
    legacy: "0x0",
    eip2930: "0x1",
    eip1559: "0x2"
  };
  function formatTransactionRequest2(transactionRequest2) {
    return {
      ...transactionRequest2,
      gas: typeof transactionRequest2.gas !== "undefined" ? (0, toHex_js_12.numberToHex)(transactionRequest2.gas) : void 0,
      gasPrice: typeof transactionRequest2.gasPrice !== "undefined" ? (0, toHex_js_12.numberToHex)(transactionRequest2.gasPrice) : void 0,
      maxFeePerGas: typeof transactionRequest2.maxFeePerGas !== "undefined" ? (0, toHex_js_12.numberToHex)(transactionRequest2.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: typeof transactionRequest2.maxPriorityFeePerGas !== "undefined" ? (0, toHex_js_12.numberToHex)(transactionRequest2.maxPriorityFeePerGas) : void 0,
      nonce: typeof transactionRequest2.nonce !== "undefined" ? (0, toHex_js_12.numberToHex)(transactionRequest2.nonce) : void 0,
      type: typeof transactionRequest2.type !== "undefined" ? exports.rpcTransactionType[transactionRequest2.type] : void 0,
      value: typeof transactionRequest2.value !== "undefined" ? (0, toHex_js_12.numberToHex)(transactionRequest2.value) : void 0
    };
  }
  exports.formatTransactionRequest = formatTransactionRequest2;
  exports.defineTransactionRequest = (0, formatter_js_12.defineFormatter)("transactionRequest", formatTransactionRequest2);
})(transactionRequest$2);
const transactionRequest = /* @__PURE__ */ getDefaultExportFromCjs(transactionRequest$2);
const transactionRequest$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: transactionRequest
}, [transactionRequest$2]);
const require$$55 = /* @__PURE__ */ getAugmentedNamespace(transactionRequest$1);
var assertRequest$2 = {};
Object.defineProperty(assertRequest$2, "__esModule", { value: true });
var assertRequest_2 = assertRequest$2.assertRequest = void 0;
const parseAccount_js_1$5 = require$$0$L;
const address_js_1$5 = require$$33$1;
const node_js_1$3 = require$$30$1;
const transaction_js_1$a = require$$34$1;
const isAddress_js_1$5 = require$$98;
function assertRequest(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  const account2 = account_ ? (0, parseAccount_js_1$5.parseAccount)(account_) : void 0;
  if (account2 && !(0, isAddress_js_1$5.isAddress)(account2.address))
    throw new address_js_1$5.InvalidAddressError({ address: account2.address });
  if (to && !(0, isAddress_js_1$5.isAddress)(to))
    throw new address_js_1$5.InvalidAddressError({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new transaction_js_1$a.FeeConflictError();
  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
    throw new node_js_1$3.FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new node_js_1$3.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
assertRequest_2 = assertRequest$2.assertRequest = assertRequest;
const assertRequest$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get assertRequest() {
    return assertRequest_2;
  },
  default: assertRequest$2
}, [assertRequest$2]);
const require$$74 = /* @__PURE__ */ getAugmentedNamespace(assertRequest$1);
var prepareTransactionRequest = {};
var estimateFeesPerGas$2 = {};
var fee$1 = {};
Object.defineProperty(fee$1, "__esModule", { value: true });
var MaxFeePerGasTooLowError_1 = fee$1.MaxFeePerGasTooLowError = Eip1559FeesNotSupportedError_1 = fee$1.Eip1559FeesNotSupportedError = BaseFeeScalarError_1 = fee$1.BaseFeeScalarError = void 0;
const formatGwei_js_1 = require$$87;
const base_js_1$a = require$$21$2;
class BaseFeeScalarError extends base_js_1$a.BaseError {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseFeeScalarError"
    });
  }
}
var BaseFeeScalarError_1 = fee$1.BaseFeeScalarError = BaseFeeScalarError;
class Eip1559FeesNotSupportedError extends base_js_1$a.BaseError {
  constructor() {
    super("Chain does not support EIP-1559 fees.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Eip1559FeesNotSupportedError"
    });
  }
}
var Eip1559FeesNotSupportedError_1 = fee$1.Eip1559FeesNotSupportedError = Eip1559FeesNotSupportedError;
class MaxFeePerGasTooLowError extends base_js_1$a.BaseError {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MaxFeePerGasTooLowError"
    });
  }
}
MaxFeePerGasTooLowError_1 = fee$1.MaxFeePerGasTooLowError = MaxFeePerGasTooLowError;
const fee = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get BaseFeeScalarError() {
    return BaseFeeScalarError_1;
  },
  get Eip1559FeesNotSupportedError() {
    return Eip1559FeesNotSupportedError_1;
  },
  get MaxFeePerGasTooLowError() {
    return MaxFeePerGasTooLowError_1;
  },
  default: fee$1
}, [fee$1]);
const require$$24$2 = /* @__PURE__ */ getAugmentedNamespace(fee);
var estimateMaxPriorityFeePerGas$2 = {};
var getBlock$2 = {};
var block$3 = {};
Object.defineProperty(block$3, "__esModule", { value: true });
var BlockNotFoundError_1 = block$3.BlockNotFoundError = void 0;
const base_js_1$9 = require$$21$2;
class BlockNotFoundError extends base_js_1$9.BaseError {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BlockNotFoundError"
    });
  }
}
BlockNotFoundError_1 = block$3.BlockNotFoundError = BlockNotFoundError;
const block$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get BlockNotFoundError() {
    return BlockNotFoundError_1;
  },
  default: block$3
}, [block$3]);
const require$$22$2 = /* @__PURE__ */ getAugmentedNamespace(block$2);
var block$1 = {};
var transaction$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineTransaction = exports.formatTransaction = exports.transactionType = void 0;
  const fromHex_js_12 = requireFromHex();
  const formatter_js_12 = require$$57;
  exports.transactionType = {
    "0x0": "legacy",
    "0x1": "eip2930",
    "0x2": "eip1559"
  };
  function formatTransaction2(transaction2) {
    const transaction_ = {
      ...transaction2,
      blockHash: transaction2.blockHash ? transaction2.blockHash : null,
      blockNumber: transaction2.blockNumber ? BigInt(transaction2.blockNumber) : null,
      chainId: transaction2.chainId ? (0, fromHex_js_12.hexToNumber)(transaction2.chainId) : void 0,
      gas: transaction2.gas ? BigInt(transaction2.gas) : void 0,
      gasPrice: transaction2.gasPrice ? BigInt(transaction2.gasPrice) : void 0,
      maxFeePerGas: transaction2.maxFeePerGas ? BigInt(transaction2.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: transaction2.maxPriorityFeePerGas ? BigInt(transaction2.maxPriorityFeePerGas) : void 0,
      nonce: transaction2.nonce ? (0, fromHex_js_12.hexToNumber)(transaction2.nonce) : void 0,
      to: transaction2.to ? transaction2.to : null,
      transactionIndex: transaction2.transactionIndex ? Number(transaction2.transactionIndex) : null,
      type: transaction2.type ? exports.transactionType[transaction2.type] : void 0,
      typeHex: transaction2.type ? transaction2.type : void 0,
      value: transaction2.value ? BigInt(transaction2.value) : void 0,
      v: transaction2.v ? BigInt(transaction2.v) : void 0
    };
    transaction_.yParity = (() => {
      if (transaction2.yParity)
        return Number(transaction2.yParity);
      if (typeof transaction_.v === "bigint") {
        if (transaction_.v === 0n || transaction_.v === 27n)
          return 0;
        if (transaction_.v === 1n || transaction_.v === 28n)
          return 1;
        if (transaction_.v >= 35n)
          return transaction_.v % 2n === 0n ? 1 : 0;
      }
      return void 0;
    })();
    if (transaction_.type === "legacy") {
      delete transaction_.accessList;
      delete transaction_.maxFeePerGas;
      delete transaction_.maxPriorityFeePerGas;
      delete transaction_.yParity;
    }
    if (transaction_.type === "eip2930") {
      delete transaction_.maxFeePerGas;
      delete transaction_.maxPriorityFeePerGas;
    }
    return transaction_;
  }
  exports.formatTransaction = formatTransaction2;
  exports.defineTransaction = (0, formatter_js_12.defineFormatter)("transaction", formatTransaction2);
})(transaction$2);
const transaction = /* @__PURE__ */ getDefaultExportFromCjs(transaction$2);
const transaction$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: transaction
}, [transaction$2]);
const require$$53$1 = /* @__PURE__ */ getAugmentedNamespace(transaction$1);
Object.defineProperty(block$1, "__esModule", { value: true });
var defineBlock = block$1.defineBlock = formatBlock_1 = block$1.formatBlock = void 0;
const formatter_js_1$1 = require$$57;
const transaction_js_1$9 = require$$53$1;
function formatBlock(block2) {
  const transactions2 = block2.transactions?.map((transaction2) => {
    if (typeof transaction2 === "string")
      return transaction2;
    return (0, transaction_js_1$9.formatTransaction)(transaction2);
  });
  return {
    ...block2,
    baseFeePerGas: block2.baseFeePerGas ? BigInt(block2.baseFeePerGas) : null,
    difficulty: block2.difficulty ? BigInt(block2.difficulty) : void 0,
    gasLimit: block2.gasLimit ? BigInt(block2.gasLimit) : void 0,
    gasUsed: block2.gasUsed ? BigInt(block2.gasUsed) : void 0,
    hash: block2.hash ? block2.hash : null,
    logsBloom: block2.logsBloom ? block2.logsBloom : null,
    nonce: block2.nonce ? block2.nonce : null,
    number: block2.number ? BigInt(block2.number) : null,
    size: block2.size ? BigInt(block2.size) : void 0,
    timestamp: block2.timestamp ? BigInt(block2.timestamp) : void 0,
    transactions: transactions2,
    totalDifficulty: block2.totalDifficulty ? BigInt(block2.totalDifficulty) : null
  };
}
var formatBlock_1 = block$1.formatBlock = formatBlock;
defineBlock = block$1.defineBlock = (0, formatter_js_1$1.defineFormatter)("block", formatBlock);
const block = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: block$1,
  get defineBlock() {
    return defineBlock;
  },
  get formatBlock() {
    return formatBlock_1;
  }
}, [block$1]);
const require$$39$1 = /* @__PURE__ */ getAugmentedNamespace(block);
Object.defineProperty(getBlock$2, "__esModule", { value: true });
var getBlock_2 = getBlock$2.getBlock = void 0;
const block_js_1$2 = require$$22$2;
const toHex_js_1$B = requireToHex();
const block_js_2 = require$$39$1;
async function getBlock(client2, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1$B.numberToHex)(blockNumber) : void 0;
  let block2 = null;
  if (blockHash) {
    block2 = await client2.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    });
  } else {
    block2 = await client2.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    });
  }
  if (!block2)
    throw new block_js_1$2.BlockNotFoundError({ blockHash, blockNumber });
  const format = client2.chain?.formatters?.block?.format || block_js_2.formatBlock;
  return format(block2);
}
getBlock_2 = getBlock$2.getBlock = getBlock;
const getBlock$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getBlock$2,
  get getBlock() {
    return getBlock_2;
  }
}, [getBlock$2]);
const require$$15$3 = /* @__PURE__ */ getAugmentedNamespace(getBlock$1);
var getGasPrice$2 = {};
Object.defineProperty(getGasPrice$2, "__esModule", { value: true });
var getGasPrice_2 = getGasPrice$2.getGasPrice = void 0;
async function getGasPrice(client2) {
  const gasPrice = await client2.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}
getGasPrice_2 = getGasPrice$2.getGasPrice = getGasPrice;
const getGasPrice$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getGasPrice$2,
  get getGasPrice() {
    return getGasPrice_2;
  }
}, [getGasPrice$2]);
const require$$24$1 = /* @__PURE__ */ getAugmentedNamespace(getGasPrice$1);
Object.defineProperty(estimateMaxPriorityFeePerGas$2, "__esModule", { value: true });
var internal_estimateMaxPriorityFeePerGas_1 = estimateMaxPriorityFeePerGas$2.internal_estimateMaxPriorityFeePerGas = estimateMaxPriorityFeePerGas_2 = estimateMaxPriorityFeePerGas$2.estimateMaxPriorityFeePerGas = void 0;
const fee_js_1$1 = require$$24$2;
const fromHex_js_1$c = requireFromHex();
const getAction_js_1$k = require$$4$a;
const getBlock_js_1$3 = require$$15$3;
const getGasPrice_js_1$1 = require$$24$1;
async function estimateMaxPriorityFeePerGas(client2, args) {
  return internal_estimateMaxPriorityFeePerGas(client2, args);
}
var estimateMaxPriorityFeePerGas_2 = estimateMaxPriorityFeePerGas$2.estimateMaxPriorityFeePerGas = estimateMaxPriorityFeePerGas;
async function internal_estimateMaxPriorityFeePerGas(client2, args) {
  const { block: block_, chain: chain2 = client2.chain, request: request2 } = args || {};
  if (typeof chain2?.fees?.defaultPriorityFee === "function") {
    const block2 = block_ || await (0, getAction_js_1$k.getAction)(client2, getBlock_js_1$3.getBlock, "getBlock")({});
    return chain2.fees.defaultPriorityFee({
      block: block2,
      client: client2,
      request: request2
    });
  }
  if (typeof chain2?.fees?.defaultPriorityFee !== "undefined")
    return chain2?.fees?.defaultPriorityFee;
  try {
    const maxPriorityFeePerGasHex = await client2.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return (0, fromHex_js_1$c.hexToBigInt)(maxPriorityFeePerGasHex);
  } catch {
    const [block2, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : (0, getAction_js_1$k.getAction)(client2, getBlock_js_1$3.getBlock, "getBlock")({}),
      (0, getAction_js_1$k.getAction)(client2, getGasPrice_js_1$1.getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block2.baseFeePerGas !== "bigint")
      throw new fee_js_1$1.Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = gasPrice - block2.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}
internal_estimateMaxPriorityFeePerGas_1 = estimateMaxPriorityFeePerGas$2.internal_estimateMaxPriorityFeePerGas = internal_estimateMaxPriorityFeePerGas;
const estimateMaxPriorityFeePerGas$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: estimateMaxPriorityFeePerGas$2,
  get estimateMaxPriorityFeePerGas() {
    return estimateMaxPriorityFeePerGas_2;
  },
  get internal_estimateMaxPriorityFeePerGas() {
    return internal_estimateMaxPriorityFeePerGas_1;
  }
}, [estimateMaxPriorityFeePerGas$2]);
const require$$13$3 = /* @__PURE__ */ getAugmentedNamespace(estimateMaxPriorityFeePerGas$1);
Object.defineProperty(estimateFeesPerGas$2, "__esModule", { value: true });
var internal_estimateFeesPerGas_1 = estimateFeesPerGas$2.internal_estimateFeesPerGas = estimateFeesPerGas_2 = estimateFeesPerGas$2.estimateFeesPerGas = void 0;
const fee_js_1 = require$$24$2;
const getAction_js_1$j = require$$4$a;
const estimateMaxPriorityFeePerGas_js_1 = require$$13$3;
const getBlock_js_1$2 = require$$15$3;
const getGasPrice_js_1 = require$$24$1;
async function estimateFeesPerGas(client2, args) {
  return internal_estimateFeesPerGas(client2, args);
}
var estimateFeesPerGas_2 = estimateFeesPerGas$2.estimateFeesPerGas = estimateFeesPerGas;
async function internal_estimateFeesPerGas(client2, args) {
  const { block: block_, chain: chain2 = client2.chain, request: request2, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain2?.fees?.baseFeeMultiplier === "function")
      return chain2.fees.baseFeeMultiplier({
        block: block_,
        client: client2,
        request: request2
      });
    return chain2?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new fee_js_1.BaseFeeScalarError();
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base3) => base3 * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block2 = block_ ? block_ : await (0, getAction_js_1$j.getAction)(client2, getBlock_js_1$2.getBlock, "getBlock")({});
  if (typeof chain2?.fees?.estimateFeesPerGas === "function")
    return chain2.fees.estimateFeesPerGas({
      block: block_,
      client: client2,
      multiply,
      request: request2,
      type
    });
  if (type === "eip1559") {
    if (typeof block2.baseFeePerGas !== "bigint")
      throw new fee_js_1.Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = request2?.maxPriorityFeePerGas ? request2.maxPriorityFeePerGas : await (0, estimateMaxPriorityFeePerGas_js_1.internal_estimateMaxPriorityFeePerGas)(client2, {
      block: block2,
      chain: chain2,
      request: request2
    });
    const baseFeePerGas = multiply(block2.baseFeePerGas);
    const maxFeePerGas = request2?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request2?.gasPrice ?? multiply(await (0, getAction_js_1$j.getAction)(client2, getGasPrice_js_1.getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}
internal_estimateFeesPerGas_1 = estimateFeesPerGas$2.internal_estimateFeesPerGas = internal_estimateFeesPerGas;
const estimateFeesPerGas$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: estimateFeesPerGas$2,
  get estimateFeesPerGas() {
    return estimateFeesPerGas_2;
  },
  get internal_estimateFeesPerGas() {
    return internal_estimateFeesPerGas_1;
  }
}, [estimateFeesPerGas$2]);
const require$$11$3 = /* @__PURE__ */ getAugmentedNamespace(estimateFeesPerGas$1);
var getTransactionCount$2 = {};
Object.defineProperty(getTransactionCount$2, "__esModule", { value: true });
var getTransactionCount_2 = getTransactionCount$2.getTransactionCount = void 0;
const fromHex_js_1$b = requireFromHex();
const toHex_js_1$A = requireToHex();
async function getTransactionCount(client2, { address: address2, blockTag = "latest", blockNumber }) {
  const count = await client2.request({
    method: "eth_getTransactionCount",
    params: [address2, blockNumber ? (0, toHex_js_1$A.numberToHex)(blockNumber) : blockTag]
  });
  return (0, fromHex_js_1$b.hexToNumber)(count);
}
getTransactionCount_2 = getTransactionCount$2.getTransactionCount = getTransactionCount;
const getTransactionCount$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getTransactionCount$2,
  get getTransactionCount() {
    return getTransactionCount_2;
  }
}, [getTransactionCount$2]);
const require$$30 = /* @__PURE__ */ getAugmentedNamespace(getTransactionCount$1);
var getTransactionType$2 = {};
Object.defineProperty(getTransactionType$2, "__esModule", { value: true });
var getTransactionType_2 = getTransactionType$2.getTransactionType = void 0;
const transaction_js_1$8 = require$$34$1;
function getTransactionType(transaction2) {
  if (transaction2.type)
    return transaction2.type;
  if (typeof transaction2.maxFeePerGas !== "undefined" || typeof transaction2.maxPriorityFeePerGas !== "undefined")
    return "eip1559";
  if (typeof transaction2.gasPrice !== "undefined") {
    if (typeof transaction2.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new transaction_js_1$8.InvalidSerializableTransactionError({ transaction: transaction2 });
}
getTransactionType_2 = getTransactionType$2.getTransactionType = getTransactionType;
const getTransactionType$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getTransactionType$2,
  get getTransactionType() {
    return getTransactionType_2;
  }
}, [getTransactionType$2]);
const require$$59 = /* @__PURE__ */ getAugmentedNamespace(getTransactionType$1);
var hasRequiredPrepareTransactionRequest;
function requirePrepareTransactionRequest() {
  if (hasRequiredPrepareTransactionRequest)
    return prepareTransactionRequest;
  hasRequiredPrepareTransactionRequest = 1;
  Object.defineProperty(prepareTransactionRequest, "__esModule", { value: true });
  prepareTransactionRequest.prepareTransactionRequest = void 0;
  const parseAccount_js_12 = require$$0$L;
  const estimateFeesPerGas_js_1 = require$$11$3;
  const estimateGas_js_12 = requireEstimateGas();
  const getBlock_js_12 = require$$15$3;
  const getTransactionCount_js_1 = require$$30;
  const account_js_12 = require$$1$o;
  const fee_js_12 = require$$24$2;
  const getAction_js_12 = require$$4$a;
  const assertRequest_js_12 = require$$74;
  const getTransactionType_js_1 = require$$59;
  async function prepareTransactionRequest$12(client2, args) {
    const { account: account_ = client2.account, chain: chain2, gas, nonce, type } = args;
    if (!account_)
      throw new account_js_12.AccountNotFoundError();
    const account2 = (0, parseAccount_js_12.parseAccount)(account_);
    const block2 = await (0, getAction_js_12.getAction)(client2, getBlock_js_12.getBlock, "getBlock")({ blockTag: "latest" });
    const request2 = { ...args, from: account2.address };
    if (typeof nonce === "undefined")
      request2.nonce = await (0, getAction_js_12.getAction)(client2, getTransactionCount_js_1.getTransactionCount, "getTransactionCount")({
        address: account2.address,
        blockTag: "pending"
      });
    if (typeof type === "undefined") {
      try {
        request2.type = (0, getTransactionType_js_1.getTransactionType)(request2);
      } catch {
        request2.type = typeof block2.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
      }
    }
    if (request2.type === "eip1559") {
      const { maxFeePerGas, maxPriorityFeePerGas } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client2, {
        block: block2,
        chain: chain2,
        request: request2
      });
      if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
        throw new fee_js_12.MaxFeePerGasTooLowError({
          maxPriorityFeePerGas
        });
      request2.maxPriorityFeePerGas = maxPriorityFeePerGas;
      request2.maxFeePerGas = maxFeePerGas;
    } else {
      if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
        throw new fee_js_12.Eip1559FeesNotSupportedError();
      const { gasPrice: gasPrice_ } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client2, {
        block: block2,
        chain: chain2,
        request: request2,
        type: "legacy"
      });
      request2.gasPrice = gasPrice_;
    }
    if (typeof gas === "undefined")
      request2.gas = await (0, getAction_js_12.getAction)(client2, estimateGas_js_12.estimateGas, "estimateGas")({
        ...request2,
        account: { address: account2.address, type: "json-rpc" }
      });
    (0, assertRequest_js_12.assertRequest)(request2);
    return request2;
  }
  prepareTransactionRequest.prepareTransactionRequest = prepareTransactionRequest$12;
  return prepareTransactionRequest;
}
var hasRequiredEstimateGas;
function requireEstimateGas() {
  if (hasRequiredEstimateGas)
    return estimateGas$2;
  hasRequiredEstimateGas = 1;
  Object.defineProperty(estimateGas$2, "__esModule", { value: true });
  estimateGas$2.estimateGas = void 0;
  const parseAccount_js_12 = require$$0$L;
  const account_js_12 = require$$1$o;
  const toHex_js_12 = requireToHex();
  const getEstimateGasError_js_1 = require$$55$1;
  const extract_js_12 = require$$0$J;
  const transactionRequest_js_12 = require$$55;
  const assertRequest_js_12 = require$$74;
  const prepareTransactionRequest_js_12 = requirePrepareTransactionRequest();
  async function estimateGas2(client2, args) {
    const account_ = args.account ?? client2.account;
    if (!account_)
      throw new account_js_12.AccountNotFoundError({
        docsPath: "/docs/actions/public/estimateGas"
      });
    const account2 = (0, parseAccount_js_12.parseAccount)(account_);
    try {
      const { accessList, blockNumber, blockTag, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account2.type === "local" ? await (0, prepareTransactionRequest_js_12.prepareTransactionRequest)(client2, args) : args;
      const blockNumberHex = blockNumber ? (0, toHex_js_12.numberToHex)(blockNumber) : void 0;
      const block2 = blockNumberHex || blockTag;
      (0, assertRequest_js_12.assertRequest)(args);
      const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || transactionRequest_js_12.formatTransactionRequest;
      const request2 = format({
        ...(0, extract_js_12.extract)(rest, { format: chainFormat }),
        from: account2.address,
        accessList,
        data: data2,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      const balance = await client2.request({
        method: "eth_estimateGas",
        params: block2 ? [request2, block2] : [request2]
      });
      return BigInt(balance);
    } catch (err) {
      throw (0, getEstimateGasError_js_1.getEstimateGasError)(err, {
        ...args,
        account: account2,
        chain: client2.chain
      });
    }
  }
  estimateGas$2.estimateGas = estimateGas2;
  return estimateGas$2;
}
Object.defineProperty(estimateContractGas$2, "__esModule", { value: true });
var estimateContractGas_2 = estimateContractGas$2.estimateContractGas = void 0;
const parseAccount_js_1$4 = require$$0$L;
const encodeFunctionData_js_1$6 = require$$51;
const getContractError_js_1$3 = require$$92;
const getAction_js_1$i = require$$4$a;
const estimateGas_js_1 = requireEstimateGas();
async function estimateContractGas(client2, { abi: abi2, address: address2, args, functionName, ...request2 }) {
  const data2 = (0, encodeFunctionData_js_1$6.encodeFunctionData)({
    abi: abi2,
    args,
    functionName
  });
  try {
    const gas = await (0, getAction_js_1$i.getAction)(client2, estimateGas_js_1.estimateGas, "estimateGas")({
      data: data2,
      to: address2,
      ...request2
    });
    return gas;
  } catch (err) {
    const account2 = request2.account ? (0, parseAccount_js_1$4.parseAccount)(request2.account) : void 0;
    throw (0, getContractError_js_1$3.getContractError)(err, {
      abi: abi2,
      address: address2,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account2?.address
    });
  }
}
estimateContractGas_2 = estimateContractGas$2.estimateContractGas = estimateContractGas;
const estimateContractGas$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: estimateContractGas$2,
  get estimateContractGas() {
    return estimateContractGas_2;
  }
}, [estimateContractGas$2]);
const require$$10$3 = /* @__PURE__ */ getAugmentedNamespace(estimateContractGas$1);
var getContractEvents$2 = {};
var getLogs$2 = {};
var decodeEventLog$2 = {};
Object.defineProperty(decodeEventLog$2, "__esModule", { value: true });
var decodeEventLog_2 = decodeEventLog$2.decodeEventLog = void 0;
const abi_js_1$c = requireAbi();
const getEventSelector_js_1 = require$$93;
const decodeAbiParameters_js_1$3 = require$$41$1;
const formatAbiItem_js_1$2 = requireFormatAbiItem();
const docsPath$5 = "/docs/contract/decodeEventLog";
function decodeEventLog({ abi: abi2, data: data2, strict: strict_, topics }) {
  const strict = strict_ ?? true;
  const [signature2, ...argTopics] = topics;
  if (!signature2)
    throw new abi_js_1$c.AbiEventSignatureEmptyTopicsError({
      docsPath: docsPath$5
    });
  const abiItem2 = abi2.find((x2) => x2.type === "event" && signature2 === (0, getEventSelector_js_1.getEventSelector)((0, formatAbiItem_js_1$2.formatAbiItem)(x2)));
  if (!(abiItem2 && "name" in abiItem2) || abiItem2.type !== "event")
    throw new abi_js_1$c.AbiEventSignatureNotFoundError(signature2, {
      docsPath: docsPath$5
    });
  const { name: name2, inputs } = abiItem2;
  const isUnnamed = inputs?.some((x2) => !("name" in x2 && x2.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x2) => "indexed" in x2 && x2.indexed);
  for (let i2 = 0; i2 < indexedInputs.length; i2++) {
    const param = indexedInputs[i2];
    const topic = argTopics[i2];
    if (!topic)
      throw new abi_js_1$c.DecodeLogTopicsMismatch({
        abiItem: abiItem2,
        param
      });
    args[param.name || i2] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x2) => !("indexed" in x2 && x2.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data2 && data2 !== "0x") {
      try {
        const decodedData2 = (0, decodeAbiParameters_js_1$3.decodeAbiParameters)(nonIndexedInputs, data2);
        if (decodedData2) {
          if (isUnnamed)
            args = [...args, ...decodedData2];
          else {
            for (let i2 = 0; i2 < nonIndexedInputs.length; i2++) {
              args[nonIndexedInputs[i2].name] = decodedData2[i2];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof abi_js_1$c.AbiDecodingDataSizeTooSmallError)
            throw new abi_js_1$c.DecodeLogDataMismatch({
              abiItem: abiItem2,
              data: err.data,
              params: err.params,
              size: err.size
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new abi_js_1$c.DecodeLogDataMismatch({
        abiItem: abiItem2,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name2,
    args: Object.values(args).length > 0 ? args : void 0
  };
}
decodeEventLog_2 = decodeEventLog$2.decodeEventLog = decodeEventLog;
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = (0, decodeAbiParameters_js_1$3.decodeAbiParameters)([param], value) || [];
  return decodedArg[0];
}
const decodeEventLog$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get decodeEventLog() {
    return decodeEventLog_2;
  },
  default: decodeEventLog$2
}, [decodeEventLog$2]);
const require$$44 = /* @__PURE__ */ getAugmentedNamespace(decodeEventLog$1);
var log$2 = {};
Object.defineProperty(log$2, "__esModule", { value: true });
var formatLog_1 = log$2.formatLog = void 0;
function formatLog(log3, { args, eventName } = {}) {
  return {
    ...log3,
    blockHash: log3.blockHash ? log3.blockHash : null,
    blockNumber: log3.blockNumber ? BigInt(log3.blockNumber) : null,
    logIndex: log3.logIndex ? Number(log3.logIndex) : null,
    transactionHash: log3.transactionHash ? log3.transactionHash : null,
    transactionIndex: log3.transactionIndex ? Number(log3.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}
formatLog_1 = log$2.formatLog = formatLog;
const log$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: log$2,
  get formatLog() {
    return formatLog_1;
  }
}, [log$2]);
const require$$40$1 = /* @__PURE__ */ getAugmentedNamespace(log$1);
Object.defineProperty(getLogs$2, "__esModule", { value: true });
var getLogs_2 = getLogs$2.getLogs = void 0;
const abi_js_1$b = requireAbi();
const decodeEventLog_js_1$3 = require$$44;
const encodeEventTopics_js_1$2 = require$$50;
const toHex_js_1$z = requireToHex();
const log_js_1$4 = require$$40$1;
async function getLogs(client2, { address: address2, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events2 = events_ ?? (event ? [event] : void 0);
  let topics = [];
  if (events2) {
    topics = [
      events2.flatMap((event2) => (0, encodeEventTopics_js_1$2.encodeEventTopics)({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client2.request({
      method: "eth_getLogs",
      params: [{ address: address2, topics, blockHash }]
    });
  } else {
    logs = await client2.request({
      method: "eth_getLogs",
      params: [
        {
          address: address2,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1$z.numberToHex)(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1$z.numberToHex)(toBlock) : toBlock
        }
      ]
    });
  }
  return logs.map((log3) => {
    try {
      const { eventName, args: args2 } = events2 ? (0, decodeEventLog_js_1$3.decodeEventLog)({
        abi: events2,
        data: log3.data,
        topics: log3.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return (0, log_js_1$4.formatLog)(log3, { args: args2, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof abi_js_1$b.DecodeLogDataMismatch || err instanceof abi_js_1$b.DecodeLogTopicsMismatch) {
        if (strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
      }
      return (0, log_js_1$4.formatLog)(log3, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
getLogs_2 = getLogs$2.getLogs = getLogs;
const getLogs$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getLogs$2,
  get getLogs() {
    return getLogs_2;
  }
}, [getLogs$2]);
const require$$25$1 = /* @__PURE__ */ getAugmentedNamespace(getLogs$1);
Object.defineProperty(getContractEvents$2, "__esModule", { value: true });
var getContractEvents_2 = getContractEvents$2.getContractEvents = void 0;
const getAbiItem_js_1$3 = require$$56$1;
const getAction_js_1$h = require$$4$a;
const getLogs_js_1 = require$$25$1;
async function getContractEvents(client2, { abi: abi2, address: address2, args, blockHash, eventName, fromBlock, toBlock, strict }) {
  const event = eventName ? (0, getAbiItem_js_1$3.getAbiItem)({ abi: abi2, name: eventName }) : void 0;
  const events2 = !event ? abi2.filter((x2) => x2.type === "event") : void 0;
  return (0, getAction_js_1$h.getAction)(client2, getLogs_js_1.getLogs, "getLogs")({
    address: address2,
    args,
    blockHash,
    event,
    events: events2,
    fromBlock,
    toBlock,
    strict
  });
}
getContractEvents_2 = getContractEvents$2.getContractEvents = getContractEvents;
const getContractEvents$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getContractEvents$2,
  get getContractEvents() {
    return getContractEvents_2;
  }
}, [getContractEvents$2]);
const require$$20$1 = /* @__PURE__ */ getAugmentedNamespace(getContractEvents$1);
var readContract$2 = {};
var decodeFunctionResult$2 = {};
Object.defineProperty(decodeFunctionResult$2, "__esModule", { value: true });
var decodeFunctionResult_2 = decodeFunctionResult$2.decodeFunctionResult = void 0;
const abi_js_1$a = requireAbi();
const decodeAbiParameters_js_1$2 = require$$41$1;
const getAbiItem_js_1$2 = require$$56$1;
const docsPath$4 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult({ abi: abi2, args, functionName, data: data2 }) {
  let abiItem2 = abi2[0];
  if (functionName) {
    abiItem2 = (0, getAbiItem_js_1$2.getAbiItem)({
      abi: abi2,
      args,
      name: functionName
    });
    if (!abiItem2)
      throw new abi_js_1$a.AbiFunctionNotFoundError(functionName, { docsPath: docsPath$4 });
  }
  if (abiItem2.type !== "function")
    throw new abi_js_1$a.AbiFunctionNotFoundError(void 0, { docsPath: docsPath$4 });
  if (!abiItem2.outputs)
    throw new abi_js_1$a.AbiFunctionOutputsNotFoundError(abiItem2.name, { docsPath: docsPath$4 });
  const values = (0, decodeAbiParameters_js_1$2.decodeAbiParameters)(abiItem2.outputs, data2);
  if (values && values.length > 1)
    return values;
  if (values && values.length === 1)
    return values[0];
  return void 0;
}
decodeFunctionResult_2 = decodeFunctionResult$2.decodeFunctionResult = decodeFunctionResult;
const decodeFunctionResult$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get decodeFunctionResult() {
    return decodeFunctionResult_2;
  },
  default: decodeFunctionResult$2
}, [decodeFunctionResult$2]);
const require$$46 = /* @__PURE__ */ getAugmentedNamespace(decodeFunctionResult$1);
var call = {};
var abis$1 = {};
Object.defineProperty(abis$1, "__esModule", { value: true });
var universalSignatureValidatorAbi = abis$1.universalSignatureValidatorAbi = smartAccountAbi = abis$1.smartAccountAbi = addressResolverAbi = abis$1.addressResolverAbi = textResolverAbi = abis$1.textResolverAbi = universalResolverReverseAbi = abis$1.universalResolverReverseAbi = universalResolverResolveAbi = abis$1.universalResolverResolveAbi = multicall3Abi = abis$1.multicall3Abi = void 0;
var multicall3Abi = abis$1.multicall3Abi = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const universalResolverErrors = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  }
];
var universalResolverResolveAbi = abis$1.universalResolverResolveAbi = [
  ...universalResolverErrors,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
];
var universalResolverReverseAbi = abis$1.universalResolverReverseAbi = [
  ...universalResolverErrors,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
];
var textResolverAbi = abis$1.textResolverAbi = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
];
var addressResolverAbi = abis$1.addressResolverAbi = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
];
var smartAccountAbi = abis$1.smartAccountAbi = [
  {
    name: "isValidSignature",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "hash", type: "bytes32" },
      { name: "signature", type: "bytes" }
    ],
    outputs: [{ name: "", type: "bytes4" }]
  }
];
universalSignatureValidatorAbi = abis$1.universalSignatureValidatorAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_signer",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_hash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
];
const abis = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get addressResolverAbi() {
    return addressResolverAbi;
  },
  default: abis$1,
  get multicall3Abi() {
    return multicall3Abi;
  },
  get smartAccountAbi() {
    return smartAccountAbi;
  },
  get textResolverAbi() {
    return textResolverAbi;
  },
  get universalResolverResolveAbi() {
    return universalResolverResolveAbi;
  },
  get universalResolverReverseAbi() {
    return universalResolverReverseAbi;
  },
  get universalSignatureValidatorAbi() {
    return universalSignatureValidatorAbi;
  }
}, [abis$1]);
const require$$14$3 = /* @__PURE__ */ getAugmentedNamespace(abis);
var contract$1 = {};
Object.defineProperty(contract$1, "__esModule", { value: true });
var aggregate3Signature = contract$1.aggregate3Signature = void 0;
aggregate3Signature = contract$1.aggregate3Signature = "0x82ad56cb";
const contract = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get aggregate3Signature() {
    return aggregate3Signature;
  },
  default: contract$1
}, [contract$1]);
const require$$2$f = /* @__PURE__ */ getAugmentedNamespace(contract);
var chain$1 = {};
Object.defineProperty(chain$1, "__esModule", { value: true });
var InvalidChainIdError_1 = chain$1.InvalidChainIdError = ClientChainNotConfiguredError_1 = chain$1.ClientChainNotConfiguredError = ChainNotFoundError_1 = chain$1.ChainNotFoundError = ChainMismatchError_1 = chain$1.ChainMismatchError = ChainDoesNotSupportContract_1 = chain$1.ChainDoesNotSupportContract = void 0;
const base_js_1$8 = require$$21$2;
class ChainDoesNotSupportContract extends base_js_1$8.BaseError {
  constructor({ blockNumber, chain: chain2, contract: contract2 }) {
    super(`Chain "${chain2.name}" does not support contract "${contract2.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...blockNumber && contract2.blockCreated && contract2.blockCreated > blockNumber ? [
          `- The contract "${contract2.name}" was not deployed until block ${contract2.blockCreated} (current block ${blockNumber}).`
        ] : [
          `- The chain does not have the contract "${contract2.name}" configured.`
        ]
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainDoesNotSupportContract"
    });
  }
}
var ChainDoesNotSupportContract_1 = chain$1.ChainDoesNotSupportContract = ChainDoesNotSupportContract;
class ChainMismatchError extends base_js_1$8.BaseError {
  constructor({ chain: chain2, currentChainId }) {
    super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain2.id} – ${chain2.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${currentChainId}`,
        `Expected Chain ID: ${chain2.id} – ${chain2.name}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainMismatchError"
    });
  }
}
var ChainMismatchError_1 = chain$1.ChainMismatchError = ChainMismatchError;
class ChainNotFoundError extends base_js_1$8.BaseError {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainNotFoundError"
    });
  }
}
var ChainNotFoundError_1 = chain$1.ChainNotFoundError = ChainNotFoundError;
class ClientChainNotConfiguredError extends base_js_1$8.BaseError {
  constructor() {
    super("No chain was provided to the Client.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ClientChainNotConfiguredError"
    });
  }
}
var ClientChainNotConfiguredError_1 = chain$1.ClientChainNotConfiguredError = ClientChainNotConfiguredError;
class InvalidChainIdError extends base_js_1$8.BaseError {
  constructor({ chainId }) {
    super(`Chain ID "${chainId}" is invalid.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidChainIdError"
    });
  }
}
InvalidChainIdError_1 = chain$1.InvalidChainIdError = InvalidChainIdError;
const chain = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get ChainDoesNotSupportContract() {
    return ChainDoesNotSupportContract_1;
  },
  get ChainMismatchError() {
    return ChainMismatchError_1;
  },
  get ChainNotFoundError() {
    return ChainNotFoundError_1;
  },
  get ClientChainNotConfiguredError() {
    return ClientChainNotConfiguredError_1;
  },
  get InvalidChainIdError() {
    return InvalidChainIdError_1;
  },
  default: chain$1
}, [chain$1]);
const require$$26$1 = /* @__PURE__ */ getAugmentedNamespace(chain);
var getChainContractAddress$2 = {};
Object.defineProperty(getChainContractAddress$2, "__esModule", { value: true });
var getChainContractAddress_2 = getChainContractAddress$2.getChainContractAddress = void 0;
const chain_js_1$2 = require$$26$1;
function getChainContractAddress({ blockNumber, chain: chain2, contract: name2 }) {
  const contract2 = chain2?.contracts?.[name2];
  if (!contract2)
    throw new chain_js_1$2.ChainDoesNotSupportContract({
      chain: chain2,
      contract: { name: name2 }
    });
  if (blockNumber && contract2.blockCreated && contract2.blockCreated > blockNumber)
    throw new chain_js_1$2.ChainDoesNotSupportContract({
      blockNumber,
      chain: chain2,
      contract: {
        name: name2,
        blockCreated: contract2.blockCreated
      }
    });
  return contract2.address;
}
getChainContractAddress_2 = getChainContractAddress$2.getChainContractAddress = getChainContractAddress;
const getChainContractAddress$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getChainContractAddress$2,
  get getChainContractAddress() {
    return getChainContractAddress_2;
  }
}, [getChainContractAddress$2]);
const require$$84 = /* @__PURE__ */ getAugmentedNamespace(getChainContractAddress$1);
var getCallError$2 = {};
Object.defineProperty(getCallError$2, "__esModule", { value: true });
var getCallError_2 = getCallError$2.getCallError = void 0;
const contract_js_1$2 = require$$23$2;
const node_js_1$2 = require$$30$1;
const getNodeError_js_1$1 = require$$52$1;
function getCallError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = (0, getNodeError_js_1$1.getNodeError)(err, args);
    if (cause2 instanceof node_js_1$2.UnknownNodeError)
      return err;
    return cause2;
  })();
  return new contract_js_1$2.CallExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
getCallError_2 = getCallError$2.getCallError = getCallError;
const getCallError$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getCallError$2,
  get getCallError() {
    return getCallError_2;
  }
}, [getCallError$2]);
const require$$53 = /* @__PURE__ */ getAugmentedNamespace(getCallError$1);
var createBatchScheduler$2 = {};
Object.defineProperty(createBatchScheduler$2, "__esModule", { value: true });
var createBatchScheduler_2 = createBatchScheduler$2.createBatchScheduler = void 0;
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn, id: id2, shouldSplitBatch, wait: wait2 = 0, sort }) {
  const exec = async () => {
    const scheduler2 = getScheduler();
    flush2();
    const args = scheduler2.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn(args).then((data2) => {
      if (sort && Array.isArray(data2))
        data2.sort(sort);
      for (let i2 = 0; i2 < scheduler2.length; i2++) {
        const { pendingPromise } = scheduler2[i2];
        pendingPromise.resolve?.([data2[i2], data2]);
      }
    }).catch((err) => {
      for (let i2 = 0; i2 < scheduler2.length; i2++) {
        const { pendingPromise } = scheduler2[i2];
        pendingPromise.reject?.(err);
      }
    });
  };
  const flush2 = () => schedulerCache.delete(id2);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id2) || [];
  const setScheduler = (item) => schedulerCache.set(id2, [...getScheduler(), item]);
  return {
    flush: flush2,
    async schedule(args) {
      const pendingPromise = {};
      const promise = new Promise((resolve, reject) => {
        pendingPromise.resolve = resolve;
        pendingPromise.reject = reject;
      });
      const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, pendingPromise });
        return promise;
      }
      setScheduler({ args, pendingPromise });
      setTimeout(exec, wait2);
      return promise;
    }
  };
}
createBatchScheduler_2 = createBatchScheduler$2.createBatchScheduler = createBatchScheduler;
const createBatchScheduler$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createBatchScheduler() {
    return createBatchScheduler_2;
  },
  default: createBatchScheduler$2
}, [createBatchScheduler$2]);
const require$$2$e = /* @__PURE__ */ getAugmentedNamespace(createBatchScheduler$1);
var ccip$2 = {};
var ccip$1 = {};
Object.defineProperty(ccip$1, "__esModule", { value: true });
var OffchainLookupSenderMismatchError_1 = ccip$1.OffchainLookupSenderMismatchError = OffchainLookupResponseMalformedError_1 = ccip$1.OffchainLookupResponseMalformedError = OffchainLookupError_1 = ccip$1.OffchainLookupError = void 0;
const stringify_js_1$6 = require$$115;
const base_js_1$7 = require$$21$2;
const utils_js_1$4 = require$$2$g;
class OffchainLookupError extends base_js_1$7.BaseError {
  constructor({ callbackSelector, cause, data: data2, extraData, sender, urls }) {
    super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
      cause,
      metaMessages: [
        ...cause.metaMessages || [],
        cause.metaMessages?.length ? "" : [],
        "Offchain Gateway Call:",
        urls && [
          "  Gateway URL(s):",
          ...urls.map((url) => `    ${(0, utils_js_1$4.getUrl)(url)}`)
        ],
        `  Sender: ${sender}`,
        `  Data: ${data2}`,
        `  Callback selector: ${callbackSelector}`,
        `  Extra data: ${extraData}`
      ].flat()
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "OffchainLookupError"
    });
  }
}
var OffchainLookupError_1 = ccip$1.OffchainLookupError = OffchainLookupError;
class OffchainLookupResponseMalformedError extends base_js_1$7.BaseError {
  constructor({ result, url }) {
    super("Offchain gateway response is malformed. Response data must be a hex value.", {
      metaMessages: [
        `Gateway URL: ${(0, utils_js_1$4.getUrl)(url)}`,
        `Response: ${(0, stringify_js_1$6.stringify)(result)}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "OffchainLookupResponseMalformedError"
    });
  }
}
var OffchainLookupResponseMalformedError_1 = ccip$1.OffchainLookupResponseMalformedError = OffchainLookupResponseMalformedError;
class OffchainLookupSenderMismatchError extends base_js_1$7.BaseError {
  constructor({ sender, to }) {
    super("Reverted sender address does not match target contract address (`to`).", {
      metaMessages: [
        `Contract address: ${to}`,
        `OffchainLookup sender address: ${sender}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "OffchainLookupSenderMismatchError"
    });
  }
}
OffchainLookupSenderMismatchError_1 = ccip$1.OffchainLookupSenderMismatchError = OffchainLookupSenderMismatchError;
const ccip = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get OffchainLookupError() {
    return OffchainLookupError_1;
  },
  get OffchainLookupResponseMalformedError() {
    return OffchainLookupResponseMalformedError_1;
  },
  get OffchainLookupSenderMismatchError() {
    return OffchainLookupSenderMismatchError_1;
  },
  default: ccip$1
}, [ccip$1]);
const require$$1$n = /* @__PURE__ */ getAugmentedNamespace(ccip);
var isAddressEqual$2 = {};
Object.defineProperty(isAddressEqual$2, "__esModule", { value: true });
var isAddressEqual_2 = isAddressEqual$2.isAddressEqual = void 0;
const address_js_1$4 = require$$33$1;
const isAddress_js_1$4 = require$$98;
function isAddressEqual(a2, b2) {
  if (!(0, isAddress_js_1$4.isAddress)(a2))
    throw new address_js_1$4.InvalidAddressError({ address: a2 });
  if (!(0, isAddress_js_1$4.isAddress)(b2))
    throw new address_js_1$4.InvalidAddressError({ address: b2 });
  return a2.toLowerCase() === b2.toLowerCase();
}
isAddressEqual_2 = isAddressEqual$2.isAddressEqual = isAddressEqual;
const isAddressEqual$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: isAddressEqual$2,
  get isAddressEqual() {
    return isAddressEqual_2;
  }
}, [isAddressEqual$2]);
const require$$99 = /* @__PURE__ */ getAugmentedNamespace(isAddressEqual$1);
var hasRequiredCcip;
function requireCcip() {
  if (hasRequiredCcip)
    return ccip$2;
  hasRequiredCcip = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ccipFetch = exports.offchainLookup = exports.offchainLookupAbiItem = exports.offchainLookupSignature = void 0;
    const call_js_12 = requireCall();
    const ccip_js_1 = require$$1$n;
    const request_js_12 = require$$32$2;
    const decodeErrorResult_js_12 = require$$43$1;
    const encodeAbiParameters_js_12 = require$$47;
    const isAddressEqual_js_12 = require$$99;
    const concat_js_12 = require$$80;
    const isHex_js_12 = require$$102;
    const stringify_js_12 = require$$115;
    exports.offchainLookupSignature = "0x556f1830";
    exports.offchainLookupAbiItem = {
      name: "OffchainLookup",
      type: "error",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "urls",
          type: "string[]"
        },
        {
          name: "callData",
          type: "bytes"
        },
        {
          name: "callbackFunction",
          type: "bytes4"
        },
        {
          name: "extraData",
          type: "bytes"
        }
      ]
    };
    async function offchainLookup(client2, { blockNumber, blockTag, data: data2, to }) {
      const { args } = (0, decodeErrorResult_js_12.decodeErrorResult)({
        data: data2,
        abi: [exports.offchainLookupAbiItem]
      });
      const [sender, urls, callData, callbackSelector, extraData] = args;
      try {
        if (!(0, isAddressEqual_js_12.isAddressEqual)(to, sender))
          throw new ccip_js_1.OffchainLookupSenderMismatchError({ sender, to });
        const result = await ccipFetch({ data: callData, sender, urls });
        const { data: data_ } = await (0, call_js_12.call)(client2, {
          blockNumber,
          blockTag,
          data: (0, concat_js_12.concat)([
            callbackSelector,
            (0, encodeAbiParameters_js_12.encodeAbiParameters)([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
          ]),
          to
        });
        return data_;
      } catch (err) {
        throw new ccip_js_1.OffchainLookupError({
          callbackSelector,
          cause: err,
          data: data2,
          extraData,
          sender,
          urls
        });
      }
    }
    exports.offchainLookup = offchainLookup;
    async function ccipFetch({ data: data2, sender, urls }) {
      let error = new Error("An unknown error occurred.");
      for (let i2 = 0; i2 < urls.length; i2++) {
        const url = urls[i2];
        const method = url.includes("{data}") ? "GET" : "POST";
        const body = method === "POST" ? { data: data2, sender } : void 0;
        try {
          const response = await fetch(url.replace("{sender}", sender).replace("{data}", data2), {
            body: JSON.stringify(body),
            method
          });
          let result;
          if (response.headers.get("Content-Type")?.startsWith("application/json")) {
            result = (await response.json()).data;
          } else {
            result = await response.text();
          }
          if (!response.ok) {
            error = new request_js_12.HttpRequestError({
              body,
              details: result?.error ? (0, stringify_js_12.stringify)(result.error) : response.statusText,
              headers: response.headers,
              status: response.status,
              url
            });
            continue;
          }
          if (!(0, isHex_js_12.isHex)(result)) {
            error = new ccip_js_1.OffchainLookupResponseMalformedError({
              result,
              url
            });
            continue;
          }
          return result;
        } catch (err) {
          error = new request_js_12.HttpRequestError({
            body,
            details: err.message,
            url
          });
        }
      }
      throw error;
    }
    exports.ccipFetch = ccipFetch;
  })(ccip$2);
  return ccip$2;
}
var hasRequiredCall;
function requireCall() {
  if (hasRequiredCall)
    return call;
  hasRequiredCall = 1;
  Object.defineProperty(call, "__esModule", { value: true });
  call.getRevertErrorData = call.call = void 0;
  const parseAccount_js_12 = require$$0$L;
  const abis_js_12 = require$$14$3;
  const contract_js_12 = require$$2$f;
  const base_js_12 = require$$21$2;
  const chain_js_12 = require$$26$1;
  const contract_js_2 = require$$23$2;
  const decodeFunctionResult_js_12 = require$$46;
  const encodeFunctionData_js_12 = require$$51;
  const getChainContractAddress_js_12 = require$$84;
  const toHex_js_12 = requireToHex();
  const getCallError_js_1 = require$$53;
  const extract_js_12 = require$$0$J;
  const transactionRequest_js_12 = require$$55;
  const createBatchScheduler_js_12 = require$$2$e;
  const assertRequest_js_12 = require$$74;
  async function call$12(client2, args) {
    const { account: account_ = client2.account, batch: batch2 = Boolean(client2.batch?.multicall), blockNumber, blockTag = "latest", accessList, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    const account2 = account_ ? (0, parseAccount_js_12.parseAccount)(account_) : void 0;
    try {
      (0, assertRequest_js_12.assertRequest)(args);
      const blockNumberHex = blockNumber ? (0, toHex_js_12.numberToHex)(blockNumber) : void 0;
      const block2 = blockNumberHex || blockTag;
      const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || transactionRequest_js_12.formatTransactionRequest;
      const request2 = format({
        ...(0, extract_js_12.extract)(rest, { format: chainFormat }),
        from: account2?.address,
        accessList,
        data: data2,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      if (batch2 && shouldPerformMulticall2({ request: request2 })) {
        try {
          return await scheduleMulticall2(client2, {
            ...request2,
            blockNumber,
            blockTag
          });
        } catch (err) {
          if (!(err instanceof chain_js_12.ClientChainNotConfiguredError) && !(err instanceof chain_js_12.ChainDoesNotSupportContract))
            throw err;
        }
      }
      const response = await client2.request({
        method: "eth_call",
        params: block2 ? [request2, block2] : [request2]
      });
      if (response === "0x")
        return { data: void 0 };
      return { data: response };
    } catch (err) {
      const data3 = getRevertErrorData2(err);
      const { offchainLookup, offchainLookupSignature } = await Promise.resolve().then(() => requireCcip());
      if (data3?.slice(0, 10) === offchainLookupSignature && to) {
        return { data: await offchainLookup(client2, { data: data3, to }) };
      }
      throw (0, getCallError_js_1.getCallError)(err, {
        ...args,
        account: account2,
        chain: client2.chain
      });
    }
  }
  call.call = call$12;
  function shouldPerformMulticall2({ request: request2 }) {
    const { data: data2, to, ...request_ } = request2;
    if (!data2)
      return false;
    if (data2.startsWith(contract_js_12.aggregate3Signature))
      return false;
    if (!to)
      return false;
    if (Object.values(request_).filter((x2) => typeof x2 !== "undefined").length > 0)
      return false;
    return true;
  }
  async function scheduleMulticall2(client2, args) {
    const { batchSize = 1024, wait: wait2 = 0 } = typeof client2.batch?.multicall === "object" ? client2.batch.multicall : {};
    const { blockNumber, blockTag = "latest", data: data2, multicallAddress: multicallAddress_, to } = args;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
      if (!client2.chain)
        throw new chain_js_12.ClientChainNotConfiguredError();
      multicallAddress = (0, getChainContractAddress_js_12.getChainContractAddress)({
        blockNumber,
        chain: client2.chain,
        contract: "multicall3"
      });
    }
    const blockNumberHex = blockNumber ? (0, toHex_js_12.numberToHex)(blockNumber) : void 0;
    const block2 = blockNumberHex || blockTag;
    const { schedule } = (0, createBatchScheduler_js_12.createBatchScheduler)({
      id: `${client2.uid}.${block2}`,
      wait: wait2,
      shouldSplitBatch(args2) {
        const size2 = args2.reduce((size3, { data: data3 }) => size3 + (data3.length - 2), 0);
        return size2 > batchSize * 2;
      },
      fn: async (requests) => {
        const calls = requests.map((request2) => ({
          allowFailure: true,
          callData: request2.data,
          target: request2.to
        }));
        const calldata = (0, encodeFunctionData_js_12.encodeFunctionData)({
          abi: abis_js_12.multicall3Abi,
          args: [calls],
          functionName: "aggregate3"
        });
        const data3 = await client2.request({
          method: "eth_call",
          params: [
            {
              data: calldata,
              to: multicallAddress
            },
            block2
          ]
        });
        return (0, decodeFunctionResult_js_12.decodeFunctionResult)({
          abi: abis_js_12.multicall3Abi,
          args: [calls],
          functionName: "aggregate3",
          data: data3 || "0x"
        });
      }
    });
    const [{ returnData, success }] = await schedule({ data: data2, to });
    if (!success)
      throw new contract_js_2.RawContractError({ data: returnData });
    if (returnData === "0x")
      return { data: void 0 };
    return { data: returnData };
  }
  function getRevertErrorData2(err) {
    if (!(err instanceof base_js_12.BaseError))
      return void 0;
    const error = err.walk();
    return typeof error.data === "object" ? error.data.data : error.data;
  }
  call.getRevertErrorData = getRevertErrorData2;
  return call;
}
Object.defineProperty(readContract$2, "__esModule", { value: true });
var readContract_2 = readContract$2.readContract = void 0;
const decodeFunctionResult_js_1$4 = require$$46;
const encodeFunctionData_js_1$5 = require$$51;
const getContractError_js_1$2 = require$$92;
const getAction_js_1$g = require$$4$a;
const call_js_1$1 = requireCall();
async function readContract(client2, { abi: abi2, address: address2, args, functionName, ...callRequest }) {
  const calldata = (0, encodeFunctionData_js_1$5.encodeFunctionData)({
    abi: abi2,
    args,
    functionName
  });
  try {
    const { data: data2 } = await (0, getAction_js_1$g.getAction)(client2, call_js_1$1.call, "call")({
      data: calldata,
      to: address2,
      ...callRequest
    });
    return (0, decodeFunctionResult_js_1$4.decodeFunctionResult)({
      abi: abi2,
      args,
      functionName,
      data: data2 || "0x"
    });
  } catch (err) {
    throw (0, getContractError_js_1$2.getContractError)(err, {
      abi: abi2,
      address: address2,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}
readContract_2 = readContract$2.readContract = readContract;
const readContract$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: readContract$2,
  get readContract() {
    return readContract_2;
  }
}, [readContract$2]);
const require$$33 = /* @__PURE__ */ getAugmentedNamespace(readContract$1);
var simulateContract$2 = {};
Object.defineProperty(simulateContract$2, "__esModule", { value: true });
var simulateContract_2 = simulateContract$2.simulateContract = void 0;
const parseAccount_js_1$3 = require$$0$L;
const decodeFunctionResult_js_1$3 = require$$46;
const encodeFunctionData_js_1$4 = require$$51;
const getContractError_js_1$1 = require$$92;
const getAction_js_1$f = require$$4$a;
const call_js_1 = requireCall();
async function simulateContract(client2, { abi: abi2, address: address2, args, dataSuffix, functionName, ...callRequest }) {
  const account2 = callRequest.account ? (0, parseAccount_js_1$3.parseAccount)(callRequest.account) : void 0;
  const calldata = (0, encodeFunctionData_js_1$4.encodeFunctionData)({
    abi: abi2,
    args,
    functionName
  });
  try {
    const { data: data2 } = await (0, getAction_js_1$f.getAction)(client2, call_js_1.call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address2,
      ...callRequest
    });
    const result = (0, decodeFunctionResult_js_1$3.decodeFunctionResult)({
      abi: abi2,
      args,
      functionName,
      data: data2 || "0x"
    });
    return {
      result,
      request: {
        abi: abi2,
        address: address2,
        args,
        dataSuffix,
        functionName,
        ...callRequest
      }
    };
  } catch (err) {
    throw (0, getContractError_js_1$1.getContractError)(err, {
      abi: abi2,
      address: address2,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account2?.address
    });
  }
}
simulateContract_2 = simulateContract$2.simulateContract = simulateContract;
const simulateContract$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: simulateContract$2,
  get simulateContract() {
    return simulateContract_2;
  }
}, [simulateContract$2]);
const require$$34 = /* @__PURE__ */ getAugmentedNamespace(simulateContract$1);
var watchContractEvent$2 = {};
var observe$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observe = exports.cleanupCache = exports.listenersCache = void 0;
  exports.listenersCache = /* @__PURE__ */ new Map();
  exports.cleanupCache = /* @__PURE__ */ new Map();
  let callbackCount2 = 0;
  function observe2(observerId, callbacks, fn) {
    const callbackId = ++callbackCount2;
    const getListeners = () => exports.listenersCache.get(observerId) || [];
    const unsubscribe = () => {
      const listeners3 = getListeners();
      exports.listenersCache.set(observerId, listeners3.filter((cb2) => cb2.id !== callbackId));
    };
    const unwatch = () => {
      const cleanup2 = exports.cleanupCache.get(observerId);
      if (getListeners().length === 1 && cleanup2)
        cleanup2();
      unsubscribe();
    };
    const listeners2 = getListeners();
    exports.listenersCache.set(observerId, [
      ...listeners2,
      { id: callbackId, fns: callbacks }
    ]);
    if (listeners2 && listeners2.length > 0)
      return unwatch;
    const emit3 = {};
    for (const key in callbacks) {
      emit3[key] = (...args) => {
        const listeners3 = getListeners();
        if (listeners3.length === 0)
          return;
        for (const listener of listeners3)
          listener.fns[key]?.(...args);
      };
    }
    const cleanup = fn(emit3);
    if (typeof cleanup === "function")
      exports.cleanupCache.set(observerId, cleanup);
    return unwatch;
  }
  exports.observe = observe2;
})(observe$2);
const observe = /* @__PURE__ */ getDefaultExportFromCjs(observe$2);
const observe$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: observe
}, [observe$2]);
const require$$1$m = /* @__PURE__ */ getAugmentedNamespace(observe$1);
var poll$2 = {};
var wait$2 = {};
Object.defineProperty(wait$2, "__esModule", { value: true });
var wait_2 = wait$2.wait = void 0;
async function wait(time2) {
  return new Promise((res) => setTimeout(res, time2));
}
wait_2 = wait$2.wait = wait;
const wait$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: wait$2,
  get wait() {
    return wait_2;
  }
}, [wait$2]);
const require$$1$l = /* @__PURE__ */ getAugmentedNamespace(wait$1);
Object.defineProperty(poll$2, "__esModule", { value: true });
var poll_2 = poll$2.poll = void 0;
const wait_js_1$2 = require$$1$l;
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch2 = async () => {
    let data2 = void 0;
    if (emitOnBegin)
      data2 = await fn({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data2) ?? interval;
    await (0, wait_js_1$2.wait)(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await (0, wait_js_1$2.wait)(interval);
      poll2();
    };
    poll2();
  };
  watch2();
  return unwatch;
}
poll_2 = poll$2.poll = poll;
const poll$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: poll$2,
  get poll() {
    return poll_2;
  }
}, [poll$2]);
const require$$2$d = /* @__PURE__ */ getAugmentedNamespace(poll$1);
var getBlockNumber$2 = {};
var withCache$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.withCache = exports.getCache = exports.responseCache = exports.promiseCache = void 0;
  exports.promiseCache = /* @__PURE__ */ new Map();
  exports.responseCache = /* @__PURE__ */ new Map();
  function getCache2(cacheKey2) {
    const buildCache = (cacheKey3, cache2) => ({
      clear: () => cache2.delete(cacheKey3),
      get: () => cache2.get(cacheKey3),
      set: (data2) => cache2.set(cacheKey3, data2)
    });
    const promise = buildCache(cacheKey2, exports.promiseCache);
    const response = buildCache(cacheKey2, exports.responseCache);
    return {
      clear: () => {
        promise.clear();
        response.clear();
      },
      promise,
      response
    };
  }
  exports.getCache = getCache2;
  async function withCache2(fn, { cacheKey: cacheKey2, cacheTime = Infinity }) {
    const cache2 = getCache2(cacheKey2);
    const response = cache2.response.get();
    if (response && cacheTime > 0) {
      const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
      if (age < cacheTime)
        return response.data;
    }
    let promise = cache2.promise.get();
    if (!promise) {
      promise = fn();
      cache2.promise.set(promise);
    }
    try {
      const data2 = await promise;
      cache2.response.set({ created: /* @__PURE__ */ new Date(), data: data2 });
      return data2;
    } finally {
      cache2.promise.clear();
    }
  }
  exports.withCache = withCache2;
})(withCache$2);
const withCache = /* @__PURE__ */ getDefaultExportFromCjs(withCache$2);
const withCache$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: withCache
}, [withCache$2]);
const require$$0$I = /* @__PURE__ */ getAugmentedNamespace(withCache$1);
Object.defineProperty(getBlockNumber$2, "__esModule", { value: true });
var getBlockNumber_2 = getBlockNumber$2.getBlockNumber = getBlockNumberCache_1 = getBlockNumber$2.getBlockNumberCache = void 0;
const withCache_js_1 = require$$0$I;
const cacheKey = (id2) => `blockNumber.${id2}`;
function getBlockNumberCache(id2) {
  return (0, withCache_js_1.getCache)(cacheKey(id2));
}
var getBlockNumberCache_1 = getBlockNumber$2.getBlockNumberCache = getBlockNumberCache;
async function getBlockNumber(client2, { cacheTime = client2.cacheTime, maxAge } = {}) {
  const blockNumberHex = await (0, withCache_js_1.withCache)(() => client2.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client2.uid), cacheTime: maxAge ?? cacheTime });
  return BigInt(blockNumberHex);
}
getBlockNumber_2 = getBlockNumber$2.getBlockNumber = getBlockNumber;
const getBlockNumber$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getBlockNumber$2,
  get getBlockNumber() {
    return getBlockNumber_2;
  },
  get getBlockNumberCache() {
    return getBlockNumberCache_1;
  }
}, [getBlockNumber$2]);
const require$$16$1 = /* @__PURE__ */ getAugmentedNamespace(getBlockNumber$1);
var getFilterChanges$2 = {};
Object.defineProperty(getFilterChanges$2, "__esModule", { value: true });
var getFilterChanges_2 = getFilterChanges$2.getFilterChanges = void 0;
const abi_js_1$9 = requireAbi();
const decodeEventLog_js_1$2 = require$$44;
const log_js_1$3 = require$$40$1;
async function getFilterChanges(_client2, { filter: filter2 }) {
  const strict = "strict" in filter2 && filter2.strict;
  const logs = await filter2.request({
    method: "eth_getFilterChanges",
    params: [filter2.id]
  });
  return logs.map((log3) => {
    if (typeof log3 === "string")
      return log3;
    try {
      const { eventName, args } = "abi" in filter2 && filter2.abi ? (0, decodeEventLog_js_1$2.decodeEventLog)({
        abi: filter2.abi,
        data: log3.data,
        topics: log3.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return (0, log_js_1$3.formatLog)(log3, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof abi_js_1$9.DecodeLogDataMismatch || err instanceof abi_js_1$9.DecodeLogTopicsMismatch) {
        if ("strict" in filter2 && filter2.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
      }
      return (0, log_js_1$3.formatLog)(log3, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
getFilterChanges_2 = getFilterChanges$2.getFilterChanges = getFilterChanges;
const getFilterChanges$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getFilterChanges$2,
  get getFilterChanges() {
    return getFilterChanges_2;
  }
}, [getFilterChanges$2]);
const require$$22$1 = /* @__PURE__ */ getAugmentedNamespace(getFilterChanges$1);
var uninstallFilter$2 = {};
Object.defineProperty(uninstallFilter$2, "__esModule", { value: true });
var uninstallFilter_2 = uninstallFilter$2.uninstallFilter = void 0;
async function uninstallFilter(_client2, { filter: filter2 }) {
  return filter2.request({
    method: "eth_uninstallFilter",
    params: [filter2.id]
  });
}
uninstallFilter_2 = uninstallFilter$2.uninstallFilter = uninstallFilter;
const uninstallFilter$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: uninstallFilter$2,
  get uninstallFilter() {
    return uninstallFilter_2;
  }
}, [uninstallFilter$2]);
const require$$35 = /* @__PURE__ */ getAugmentedNamespace(uninstallFilter$1);
Object.defineProperty(watchContractEvent$2, "__esModule", { value: true });
var watchContractEvent_2 = watchContractEvent$2.watchContractEvent = void 0;
const observe_js_1$4 = require$$1$m;
const poll_js_1$3 = require$$2$d;
const stringify_js_1$5 = require$$115;
const abi_js_1$8 = requireAbi();
const rpc_js_1$2 = require$$25$2;
const decodeEventLog_js_1$1 = require$$44;
const encodeEventTopics_js_1$1 = require$$50;
const log_js_1$2 = require$$40$1;
const getAction_js_1$e = require$$4$a;
const createContractEventFilter_js_1$1 = require$$7$5;
const getBlockNumber_js_1$2 = require$$16$1;
const getContractEvents_js_1$1 = require$$20$1;
const getFilterChanges_js_1$1 = require$$22$1;
const uninstallFilter_js_1$1 = require$$35;
function watchContractEvent(client2, { abi: abi2, address: address2, args, batch: batch2 = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client2.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const pollContractEvent = () => {
    const observerId = (0, stringify_js_1$5.stringify)([
      "watchContractEvent",
      address2,
      args,
      batch2,
      client2.uid,
      eventName,
      pollingInterval
    ]);
    const strict = strict_ ?? false;
    return (0, observe_js_1$4.observe)(observerId, { onLogs, onError }, (emit3) => {
      let previousBlockNumber;
      let filter2;
      let initialized = false;
      const unwatch = (0, poll_js_1$3.poll)(async () => {
        if (!initialized) {
          try {
            filter2 = await (0, getAction_js_1$e.getAction)(client2, createContractEventFilter_js_1$1.createContractEventFilter, "createContractEventFilter")({
              abi: abi2,
              address: address2,
              args,
              eventName,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await (0, getAction_js_1$e.getAction)(client2, getFilterChanges_js_1$1.getFilterChanges, "getFilterChanges")({ filter: filter2 });
          } else {
            const blockNumber = await (0, getAction_js_1$e.getAction)(client2, getBlockNumber_js_1$2.getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await (0, getAction_js_1$e.getAction)(client2, getContractEvents_js_1$1.getContractEvents, "getContractEvents")({
                abi: abi2,
                address: address2,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch2)
            emit3.onLogs(logs);
          else
            for (const log3 of logs)
              emit3.onLogs([log3]);
        } catch (err) {
          if (filter2 && err instanceof rpc_js_1$2.InvalidInputRpcError)
            initialized = false;
          emit3.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await (0, getAction_js_1$e.getAction)(client2, uninstallFilter_js_1$1.uninstallFilter, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const topics = eventName ? (0, encodeEventTopics_js_1$1.encodeEventTopics)({
          abi: abi2,
          eventName,
          args
        }) : [];
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["logs", { address: address2, topics }],
          onData(data2) {
            if (!active)
              return;
            const log3 = data2.result;
            try {
              const { eventName: eventName2, args: args2 } = (0, decodeEventLog_js_1$1.decodeEventLog)({
                abi: abi2,
                data: log3.data,
                topics: log3.topics,
                strict: strict_
              });
              const formatted = (0, log_js_1$2.formatLog)(log3, {
                args: args2,
                eventName: eventName2
              });
              onLogs([formatted]);
            } catch (err) {
              let eventName2;
              let isUnnamed;
              if (err instanceof abi_js_1$8.DecodeLogDataMismatch || err instanceof abi_js_1$8.DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName2 = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
              }
              const formatted = (0, log_js_1$2.formatLog)(log3, {
                args: isUnnamed ? [] : {},
                eventName: eventName2
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}
watchContractEvent_2 = watchContractEvent$2.watchContractEvent = watchContractEvent;
const watchContractEvent$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: watchContractEvent$2,
  get watchContractEvent() {
    return watchContractEvent_2;
  }
}, [watchContractEvent$2]);
const require$$41 = /* @__PURE__ */ getAugmentedNamespace(watchContractEvent$1);
var writeContract$2 = {};
var sendTransaction$2 = {};
var assertCurrentChain$2 = {};
Object.defineProperty(assertCurrentChain$2, "__esModule", { value: true });
var assertCurrentChain_2 = assertCurrentChain$2.assertCurrentChain = void 0;
const chain_js_1$1 = require$$26$1;
function assertCurrentChain({ chain: chain2, currentChainId }) {
  if (!chain2)
    throw new chain_js_1$1.ChainNotFoundError();
  if (currentChainId !== chain2.id)
    throw new chain_js_1$1.ChainMismatchError({ chain: chain2, currentChainId });
}
assertCurrentChain_2 = assertCurrentChain$2.assertCurrentChain = assertCurrentChain;
const assertCurrentChain$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get assertCurrentChain() {
    return assertCurrentChain_2;
  },
  default: assertCurrentChain$2
}, [assertCurrentChain$2]);
const require$$81 = /* @__PURE__ */ getAugmentedNamespace(assertCurrentChain$1);
var getTransactionError$2 = {};
Object.defineProperty(getTransactionError$2, "__esModule", { value: true });
var getTransactionError_2 = getTransactionError$2.getTransactionError = void 0;
const node_js_1$1 = require$$30$1;
const transaction_js_1$7 = require$$34$1;
const getNodeError_js_1 = require$$52$1;
function getTransactionError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = (0, getNodeError_js_1.getNodeError)(err, args);
    if (cause2 instanceof node_js_1$1.UnknownNodeError)
      return err;
    return cause2;
  })();
  return new transaction_js_1$7.TransactionExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
getTransactionError_2 = getTransactionError$2.getTransactionError = getTransactionError;
const getTransactionError$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getTransactionError$2,
  get getTransactionError() {
    return getTransactionError_2;
  }
}, [getTransactionError$2]);
const require$$56 = /* @__PURE__ */ getAugmentedNamespace(getTransactionError$1);
var getChainId$2 = {};
Object.defineProperty(getChainId$2, "__esModule", { value: true });
var getChainId_2 = getChainId$2.getChainId = void 0;
const fromHex_js_1$a = requireFromHex();
async function getChainId(client2) {
  const chainIdHex = await client2.request({
    method: "eth_chainId"
  });
  return (0, fromHex_js_1$a.hexToNumber)(chainIdHex);
}
getChainId_2 = getChainId$2.getChainId = getChainId;
const getChainId$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getChainId$2,
  get getChainId() {
    return getChainId_2;
  }
}, [getChainId$2]);
const require$$0$H = /* @__PURE__ */ getAugmentedNamespace(getChainId$1);
var sendRawTransaction$2 = {};
Object.defineProperty(sendRawTransaction$2, "__esModule", { value: true });
var sendRawTransaction_2 = sendRawTransaction$2.sendRawTransaction = void 0;
async function sendRawTransaction(client2, { serializedTransaction }) {
  return client2.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  });
}
sendRawTransaction_2 = sendRawTransaction$2.sendRawTransaction = sendRawTransaction;
const sendRawTransaction$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sendRawTransaction$2,
  get sendRawTransaction() {
    return sendRawTransaction_2;
  }
}, [sendRawTransaction$2]);
const require$$8$3 = /* @__PURE__ */ getAugmentedNamespace(sendRawTransaction$1);
Object.defineProperty(sendTransaction$2, "__esModule", { value: true });
var sendTransaction_2 = sendTransaction$2.sendTransaction = void 0;
const parseAccount_js_1$2 = require$$0$L;
const account_js_1$2 = require$$1$o;
const assertCurrentChain_js_1 = require$$81;
const getTransactionError_js_1 = require$$56;
const extract_js_1$1 = require$$0$J;
const transactionRequest_js_1$1 = require$$55;
const getAction_js_1$d = require$$4$a;
const assertRequest_js_1 = require$$74;
const getChainId_js_1 = require$$0$H;
const prepareTransactionRequest_js_1 = requirePrepareTransactionRequest();
const sendRawTransaction_js_1 = require$$8$3;
async function sendTransaction(client2, args) {
  const { account: account_ = client2.account, chain: chain2 = client2.chain, accessList, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
  if (!account_)
    throw new account_js_1$2.AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account2 = (0, parseAccount_js_1$2.parseAccount)(account_);
  try {
    (0, assertRequest_js_1.assertRequest)(args);
    let chainId;
    if (chain2 !== null) {
      chainId = await (0, getAction_js_1$d.getAction)(client2, getChainId_js_1.getChainId, "getChainId")({});
      (0, assertCurrentChain_js_1.assertCurrentChain)({
        currentChainId: chainId,
        chain: chain2
      });
    }
    if (account2.type === "local") {
      const request3 = await (0, getAction_js_1$d.getAction)(client2, prepareTransactionRequest_js_1.prepareTransactionRequest, "prepareTransactionRequest")({
        account: account2,
        accessList,
        chain: chain2,
        data: data2,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        ...rest
      });
      if (!chainId)
        chainId = await (0, getAction_js_1$d.getAction)(client2, getChainId_js_1.getChainId, "getChainId")({});
      const serializer = chain2?.serializers?.transaction;
      const serializedTransaction = await account2.signTransaction({
        ...request3,
        chainId
      }, { serializer });
      return await (0, getAction_js_1$d.getAction)(client2, sendRawTransaction_js_1.sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || transactionRequest_js_1$1.formatTransactionRequest;
    const request2 = format({
      ...(0, extract_js_1$1.extract)(rest, { format: chainFormat }),
      accessList,
      data: data2,
      from: account2.address,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    return await client2.request({
      method: "eth_sendTransaction",
      params: [request2]
    });
  } catch (err) {
    throw (0, getTransactionError_js_1.getTransactionError)(err, {
      ...args,
      account: account2,
      chain: args.chain || void 0
    });
  }
}
sendTransaction_2 = sendTransaction$2.sendTransaction = sendTransaction;
const sendTransaction$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sendTransaction$2,
  get sendTransaction() {
    return sendTransaction_2;
  }
}, [sendTransaction$2]);
const require$$9$4 = /* @__PURE__ */ getAugmentedNamespace(sendTransaction$1);
Object.defineProperty(writeContract$2, "__esModule", { value: true });
var writeContract_2 = writeContract$2.writeContract = void 0;
const encodeFunctionData_js_1$3 = require$$51;
const getAction_js_1$c = require$$4$a;
const sendTransaction_js_1$1 = require$$9$4;
async function writeContract(client2, { abi: abi2, address: address2, args, dataSuffix, functionName, ...request2 }) {
  const data2 = (0, encodeFunctionData_js_1$3.encodeFunctionData)({
    abi: abi2,
    args,
    functionName
  });
  const hash2 = await (0, getAction_js_1$c.getAction)(client2, sendTransaction_js_1$1.sendTransaction, "sendTransaction")({
    data: `${data2}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
    to: address2,
    ...request2
  });
  return hash2;
}
writeContract_2 = writeContract$2.writeContract = writeContract;
const writeContract$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: writeContract$2,
  get writeContract() {
    return writeContract_2;
  }
}, [writeContract$2]);
const require$$15$2 = /* @__PURE__ */ getAugmentedNamespace(writeContract$1);
Object.defineProperty(getContract$2, "__esModule", { value: true });
var getEventParameters_1 = getContract$2.getEventParameters = getFunctionParameters_1 = getContract$2.getFunctionParameters = getContract_2 = getContract$2.getContract = void 0;
const getAction_js_1$b = require$$4$a;
const createContractEventFilter_js_1 = require$$7$5;
const estimateContractGas_js_1 = require$$10$3;
const getContractEvents_js_1 = require$$20$1;
const readContract_js_1$6 = require$$33;
const simulateContract_js_1 = require$$34;
const watchContractEvent_js_1 = require$$41;
const writeContract_js_1 = require$$15$2;
function getContract({ abi: abi2, address: address2, publicClient, walletClient }) {
  const hasPublicClient = publicClient !== void 0 && publicClient !== null;
  const hasWalletClient = walletClient !== void 0 && walletClient !== null;
  const contract2 = {};
  let hasReadFunction = false;
  let hasWriteFunction = false;
  let hasEvent = false;
  for (const item of abi2) {
    if (item.type === "function")
      if (item.stateMutability === "view" || item.stateMutability === "pure")
        hasReadFunction = true;
      else
        hasWriteFunction = true;
    else if (item.type === "event")
      hasEvent = true;
    if (hasReadFunction && hasWriteFunction && hasEvent)
      break;
  }
  if (hasPublicClient) {
    if (hasReadFunction)
      contract2.read = new Proxy({}, {
        get(_2, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return (0, getAction_js_1$b.getAction)(publicClient, readContract_js_1$6.readContract, "readContract")({
              abi: abi2,
              address: address2,
              functionName,
              args,
              ...options
            });
          };
        }
      });
    if (hasWriteFunction)
      contract2.simulate = new Proxy({}, {
        get(_2, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return (0, getAction_js_1$b.getAction)(publicClient, simulateContract_js_1.simulateContract, "simulateContract")({
              abi: abi2,
              address: address2,
              functionName,
              args,
              ...options
            });
          };
        }
      });
    if (hasEvent) {
      contract2.createEventFilter = new Proxy({}, {
        get(_2, eventName) {
          return (...parameters) => {
            const abiEvent = abi2.find((x2) => x2.type === "event" && x2.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return (0, getAction_js_1$b.getAction)(publicClient, createContractEventFilter_js_1.createContractEventFilter, "createContractEventFilter")({
              abi: abi2,
              address: address2,
              eventName,
              args,
              ...options
            });
          };
        }
      });
      contract2.getEvents = new Proxy({}, {
        get(_2, eventName) {
          return (...parameters) => {
            const abiEvent = abi2.find((x2) => x2.type === "event" && x2.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return (0, getAction_js_1$b.getAction)(publicClient, getContractEvents_js_1.getContractEvents, "getContractEvents")({
              abi: abi2,
              address: address2,
              eventName,
              args,
              ...options
            });
          };
        }
      });
      contract2.watchEvent = new Proxy({}, {
        get(_2, eventName) {
          return (...parameters) => {
            const abiEvent = abi2.find((x2) => x2.type === "event" && x2.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return (0, getAction_js_1$b.getAction)(publicClient, watchContractEvent_js_1.watchContractEvent, "watchContractEvent")({
              abi: abi2,
              address: address2,
              eventName,
              args,
              ...options
            });
          };
        }
      });
    }
  }
  if (hasWalletClient) {
    if (hasWriteFunction)
      contract2.write = new Proxy({}, {
        get(_2, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return (0, getAction_js_1$b.getAction)(walletClient, writeContract_js_1.writeContract, "writeContract")({
              abi: abi2,
              address: address2,
              functionName,
              args,
              ...options
            });
          };
        }
      });
  }
  if (hasPublicClient || hasWalletClient) {
    if (hasWriteFunction)
      contract2.estimateGas = new Proxy({}, {
        get(_2, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            const client2 = publicClient ?? walletClient;
            return (0, getAction_js_1$b.getAction)(client2, estimateContractGas_js_1.estimateContractGas, "estimateContractGas")({
              abi: abi2,
              address: address2,
              functionName,
              args,
              ...options,
              account: options.account ?? walletClient.account
            });
          };
        }
      });
  }
  contract2.address = address2;
  contract2.abi = abi2;
  return contract2;
}
var getContract_2 = getContract$2.getContract = getContract;
function getFunctionParameters(values) {
  const hasArgs = values.length && Array.isArray(values[0]);
  const args = hasArgs ? values[0] : [];
  const options = (hasArgs ? values[1] : values[0]) ?? {};
  return { args, options };
}
var getFunctionParameters_1 = getContract$2.getFunctionParameters = getFunctionParameters;
function getEventParameters(values, abiEvent) {
  let hasArgs = false;
  if (Array.isArray(values[0]))
    hasArgs = true;
  else if (values.length === 1) {
    hasArgs = abiEvent.inputs.some((x2) => x2.indexed);
  } else if (values.length === 2) {
    hasArgs = true;
  }
  const args = hasArgs ? values[0] : void 0;
  const options = (hasArgs ? values[1] : values[0]) ?? {};
  return { args, options };
}
getEventParameters_1 = getContract$2.getEventParameters = getEventParameters;
const getContract$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getContract$2,
  get getContract() {
    return getContract_2;
  },
  get getEventParameters() {
    return getEventParameters_1;
  },
  get getFunctionParameters() {
    return getFunctionParameters_1;
  }
}, [getContract$2]);
const require$$1$k = /* @__PURE__ */ getAugmentedNamespace(getContract$1);
var createClient$2 = {};
var accounts$2 = {};
var publicKeyToAddress$2 = {};
Object.defineProperty(publicKeyToAddress$2, "__esModule", { value: true });
var publicKeyToAddress_2 = publicKeyToAddress$2.publicKeyToAddress = void 0;
const getAddress_js_1$4 = require$$91;
const keccak256_js_1$3 = require$$103;
function publicKeyToAddress(publicKey) {
  const address2 = (0, keccak256_js_1$3.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
  return (0, getAddress_js_1$4.checksumAddress)(`0x${address2}`);
}
publicKeyToAddress_2 = publicKeyToAddress$2.publicKeyToAddress = publicKeyToAddress;
const publicKeyToAddress$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: publicKeyToAddress$2,
  get publicKeyToAddress() {
    return publicKeyToAddress_2;
  }
}, [publicKeyToAddress$2]);
const require$$27$2 = /* @__PURE__ */ getAugmentedNamespace(publicKeyToAddress$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publicKeyToAddress = exports.parseAccount = void 0;
  var parseAccount_js_12 = require$$0$L;
  Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
    return parseAccount_js_12.parseAccount;
  } });
  var publicKeyToAddress_js_12 = require$$27$2;
  Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
    return publicKeyToAddress_js_12.publicKeyToAddress;
  } });
})(accounts$2);
const accounts = /* @__PURE__ */ getDefaultExportFromCjs(accounts$2);
const accounts$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: accounts
}, [accounts$2]);
const require$$0$G = /* @__PURE__ */ getAugmentedNamespace(accounts$1);
var uid$2 = {};
Object.defineProperty(uid$2, "__esModule", { value: true });
var uid_2 = uid$2.uid = void 0;
const size = 256;
let index$e = size;
let buffer$4;
function uid(length2 = 11) {
  if (!buffer$4 || index$e + length2 > size * 2) {
    buffer$4 = "";
    index$e = 0;
    for (let i2 = 0; i2 < size; i2++) {
      buffer$4 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer$4.substring(index$e, index$e++ + length2);
}
uid_2 = uid$2.uid = uid;
const uid$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: uid$2,
  get uid() {
    return uid_2;
  }
}, [uid$2]);
const require$$1$j = /* @__PURE__ */ getAugmentedNamespace(uid$1);
Object.defineProperty(createClient$2, "__esModule", { value: true });
var createClient_2 = createClient$2.createClient = void 0;
const accounts_js_1 = require$$0$G;
const uid_js_1 = require$$1$j;
function createClient(parameters) {
  const { batch: batch2, cacheTime = parameters.pollingInterval ?? 4e3, key = "base", name: name2 = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
  const chain2 = parameters.chain;
  const account2 = parameters.account ? (0, accounts_js_1.parseAccount)(parameters.account) : void 0;
  const { config: config2, request: request2, value } = parameters.transport({
    chain: chain2,
    pollingInterval
  });
  const transport2 = { ...config2, ...value };
  const client2 = {
    account: account2,
    batch: batch2,
    cacheTime,
    chain: chain2,
    key,
    name: name2,
    pollingInterval,
    request: request2,
    transport: transport2,
    type,
    uid: (0, uid_js_1.uid)()
  };
  function extend(base3) {
    return (extendFn) => {
      const extended = extendFn(base3);
      for (const key2 in client2)
        delete extended[key2];
      const combined = { ...base3, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client2, { extend: extend(client2) });
}
createClient_2 = createClient$2.createClient = createClient;
const createClient$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createClient() {
    return createClient_2;
  },
  default: createClient$2
}, [createClient$2]);
const require$$2$c = /* @__PURE__ */ getAugmentedNamespace(createClient$1);
var custom$2 = {};
var createTransport$2 = {};
var buildRequest$2 = {};
var withRetry$2 = {};
Object.defineProperty(withRetry$2, "__esModule", { value: true });
var withRetry_2 = withRetry$2.withRetry = void 0;
const wait_js_1$1 = require$$1$l;
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry2 = async ({ error }) => {
        const delay2 = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay2)
          await (0, wait_js_1$1.wait)(delay2);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data2 = await fn();
        resolve(data2);
      } catch (err) {
        if (count < retryCount && await shouldRetry({ count, error: err }))
          return retry2({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}
withRetry_2 = withRetry$2.withRetry = withRetry;
const withRetry$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: withRetry$2,
  get withRetry() {
    return withRetry_2;
  }
}, [withRetry$2]);
const require$$4$9 = /* @__PURE__ */ getAugmentedNamespace(withRetry$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildRequest = exports.isDeterministicError = void 0;
  const base_js_12 = require$$21$2;
  const request_js_12 = require$$32$2;
  const rpc_js_12 = require$$25$2;
  const withRetry_js_12 = require$$4$9;
  const isDeterministicError2 = (error) => {
    if ("code" in error)
      return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
    if (error instanceof request_js_12.HttpRequestError && error.status)
      return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
    return false;
  };
  exports.isDeterministicError = isDeterministicError2;
  function buildRequest2(request2, { retryDelay = 150, retryCount = 3 } = {}) {
    return async (args) => (0, withRetry_js_12.withRetry)(async () => {
      try {
        return await request2(args);
      } catch (err_) {
        const err = err_;
        switch (err.code) {
          case rpc_js_12.ParseRpcError.code:
            throw new rpc_js_12.ParseRpcError(err);
          case rpc_js_12.InvalidRequestRpcError.code:
            throw new rpc_js_12.InvalidRequestRpcError(err);
          case rpc_js_12.MethodNotFoundRpcError.code:
            throw new rpc_js_12.MethodNotFoundRpcError(err);
          case rpc_js_12.InvalidParamsRpcError.code:
            throw new rpc_js_12.InvalidParamsRpcError(err);
          case rpc_js_12.InternalRpcError.code:
            throw new rpc_js_12.InternalRpcError(err);
          case rpc_js_12.InvalidInputRpcError.code:
            throw new rpc_js_12.InvalidInputRpcError(err);
          case rpc_js_12.ResourceNotFoundRpcError.code:
            throw new rpc_js_12.ResourceNotFoundRpcError(err);
          case rpc_js_12.ResourceUnavailableRpcError.code:
            throw new rpc_js_12.ResourceUnavailableRpcError(err);
          case rpc_js_12.TransactionRejectedRpcError.code:
            throw new rpc_js_12.TransactionRejectedRpcError(err);
          case rpc_js_12.MethodNotSupportedRpcError.code:
            throw new rpc_js_12.MethodNotSupportedRpcError(err);
          case rpc_js_12.LimitExceededRpcError.code:
            throw new rpc_js_12.LimitExceededRpcError(err);
          case rpc_js_12.JsonRpcVersionUnsupportedError.code:
            throw new rpc_js_12.JsonRpcVersionUnsupportedError(err);
          case rpc_js_12.UserRejectedRequestError.code:
            throw new rpc_js_12.UserRejectedRequestError(err);
          case rpc_js_12.UnauthorizedProviderError.code:
            throw new rpc_js_12.UnauthorizedProviderError(err);
          case rpc_js_12.UnsupportedProviderMethodError.code:
            throw new rpc_js_12.UnsupportedProviderMethodError(err);
          case rpc_js_12.ProviderDisconnectedError.code:
            throw new rpc_js_12.ProviderDisconnectedError(err);
          case rpc_js_12.ChainDisconnectedError.code:
            throw new rpc_js_12.ChainDisconnectedError(err);
          case rpc_js_12.SwitchChainError.code:
            throw new rpc_js_12.SwitchChainError(err);
          case 5e3:
            throw new rpc_js_12.UserRejectedRequestError(err);
          default:
            if (err_ instanceof base_js_12.BaseError)
              throw err_;
            throw new rpc_js_12.UnknownRpcError(err);
        }
      }
    }, {
      delay: ({ count, error }) => {
        if (error && error instanceof request_js_12.HttpRequestError) {
          const retryAfter = error?.headers?.get("Retry-After");
          if (retryAfter?.match(/\d/))
            return parseInt(retryAfter) * 1e3;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => !(0, exports.isDeterministicError)(error)
    });
  }
  exports.buildRequest = buildRequest2;
})(buildRequest$2);
const buildRequest = /* @__PURE__ */ getDefaultExportFromCjs(buildRequest$2);
const buildRequest$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: buildRequest
}, [buildRequest$2]);
const require$$0$F = /* @__PURE__ */ getAugmentedNamespace(buildRequest$1);
Object.defineProperty(createTransport$2, "__esModule", { value: true });
var createTransport_2 = createTransport$2.createTransport = void 0;
const buildRequest_js_1$1 = require$$0$F;
function createTransport({ key, name: name2, request: request2, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  return {
    config: { key, name: name2, request: request2, retryCount, retryDelay, timeout, type },
    request: (0, buildRequest_js_1$1.buildRequest)(request2, { retryCount, retryDelay }),
    value
  };
}
createTransport_2 = createTransport$2.createTransport = createTransport;
const createTransport$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createTransport() {
    return createTransport_2;
  },
  default: createTransport$2
}, [createTransport$2]);
const require$$11$2 = /* @__PURE__ */ getAugmentedNamespace(createTransport$1);
Object.defineProperty(custom$2, "__esModule", { value: true });
var custom_2 = custom$2.custom = void 0;
const createTransport_js_1$3 = require$$11$2;
function custom(provider2, config2 = {}) {
  const { key = "custom", name: name2 = "Custom Provider", retryDelay } = config2;
  return ({ retryCount: defaultRetryCount }) => (0, createTransport_js_1$3.createTransport)({
    key,
    name: name2,
    request: provider2.request.bind(provider2),
    retryCount: config2.retryCount ?? defaultRetryCount,
    retryDelay,
    type: "custom"
  });
}
custom_2 = custom$2.custom = custom;
const custom$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get custom() {
    return custom_2;
  },
  default: custom$2
}, [custom$2]);
const require$$3$d = /* @__PURE__ */ getAugmentedNamespace(custom$1);
var fallback$2 = {};
Object.defineProperty(fallback$2, "__esModule", { value: true });
var rankTransports_1 = fallback$2.rankTransports = fallback_2 = fallback$2.fallback = void 0;
const buildRequest_js_1 = require$$0$F;
const wait_js_1 = require$$1$l;
const createTransport_js_1$2 = require$$11$2;
function fallback(transports_, config2 = {}) {
  const { key = "fallback", name: name2 = "Fallback", rank = false, retryCount, retryDelay } = config2;
  return ({ chain: chain2, pollingInterval = 4e3, timeout }) => {
    let transports = transports_;
    let onResponse = () => {
    };
    const transport2 = (0, createTransport_js_1$2.createTransport)({
      key,
      name: name2,
      async request({ method, params }) {
        const fetch2 = async (i2 = 0) => {
          const transport3 = transports[i2]({ chain: chain2, retryCount: 0, timeout });
          try {
            const response = await transport3.request({
              method,
              params
            });
            onResponse({
              method,
              params,
              response,
              transport: transport3,
              status: "success"
            });
            return response;
          } catch (err) {
            onResponse({
              error: err,
              method,
              params,
              transport: transport3,
              status: "error"
            });
            if ((0, buildRequest_js_1.isDeterministicError)(err))
              throw err;
            if (i2 === transports.length - 1)
              throw err;
            return fetch2(i2 + 1);
          }
        };
        return fetch2();
      },
      retryCount,
      retryDelay,
      type: "fallback"
    }, {
      onResponse: (fn) => onResponse = fn,
      transports: transports.map((fn) => fn({ chain: chain2, retryCount: 0 }))
    });
    if (rank) {
      const rankOptions = typeof rank === "object" ? rank : {};
      rankTransports({
        chain: chain2,
        interval: rankOptions.interval ?? pollingInterval,
        onTransports: (transports_2) => transports = transports_2,
        sampleCount: rankOptions.sampleCount,
        timeout: rankOptions.timeout,
        transports,
        weights: rankOptions.weights
      });
    }
    return transport2;
  };
}
var fallback_2 = fallback$2.fallback = fallback;
function rankTransports({ chain: chain2, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
  const samples = [];
  const rankTransports_ = async () => {
    const sample = await Promise.all(transports.map(async (transport2) => {
      const transport_ = transport2({ chain: chain2, retryCount: 0, timeout });
      const start = Date.now();
      let end2;
      let success;
      try {
        await transport_.request({ method: "net_listening" });
        success = 1;
      } catch {
        success = 0;
      } finally {
        end2 = Date.now();
      }
      const latency = end2 - start;
      return { latency, success };
    }));
    samples.push(sample);
    if (samples.length > sampleCount)
      samples.shift();
    const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
    const scores = transports.map((_2, i2) => {
      const latencies = samples.map((sample2) => sample2[i2].latency);
      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
      const latencyScore = 1 - meanLatency / maxLatency;
      const successes = samples.map((sample2) => sample2[i2].success);
      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
      if (stabilityScore === 0)
        return [0, i2];
      return [
        latencyWeight * latencyScore + stabilityWeight * stabilityScore,
        i2
      ];
    }).sort((a2, b2) => b2[0] - a2[0]);
    onTransports(scores.map(([, i2]) => transports[i2]));
    await (0, wait_js_1.wait)(interval);
    rankTransports_();
  };
  rankTransports_();
}
rankTransports_1 = fallback$2.rankTransports = rankTransports;
const fallback$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: fallback$2,
  get fallback() {
    return fallback_2;
  },
  get rankTransports() {
    return rankTransports_1;
  }
}, [fallback$2]);
const require$$4$8 = /* @__PURE__ */ getAugmentedNamespace(fallback$1);
var http$2 = {};
var transport$1 = {};
Object.defineProperty(transport$1, "__esModule", { value: true });
var UrlRequiredError_1 = transport$1.UrlRequiredError = void 0;
const base_js_1$6 = require$$21$2;
class UrlRequiredError extends base_js_1$6.BaseError {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro"
    });
  }
}
UrlRequiredError_1 = transport$1.UrlRequiredError = UrlRequiredError;
const transport = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get UrlRequiredError() {
    return UrlRequiredError_1;
  },
  default: transport$1
}, [transport$1]);
const require$$36 = /* @__PURE__ */ getAugmentedNamespace(transport);
var rpc$5 = {};
const require$$0$E = /* @__PURE__ */ getAugmentedNamespace(native);
var withTimeout$2 = {};
Object.defineProperty(withTimeout$2, "__esModule", { value: true });
var withTimeout_2 = withTimeout$2.withTimeout = void 0;
function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn({ signal: controller?.signal }));
      } catch (err) {
        if (err.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
withTimeout_2 = withTimeout$2.withTimeout = withTimeout;
const withTimeout$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: withTimeout$2,
  get withTimeout() {
    return withTimeout_2;
  }
}, [withTimeout$2]);
const require$$3$c = /* @__PURE__ */ getAugmentedNamespace(withTimeout$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rpc = exports.getSocket = exports.socketsCache = void 0;
  const isows_1 = require$$0$E;
  const request_js_12 = require$$32$2;
  const createBatchScheduler_js_12 = require$$2$e;
  const withTimeout_js_1 = require$$3$c;
  const stringify_js_12 = require$$115;
  let id2 = 0;
  async function http2(url, { body, fetchOptions = {}, timeout = 1e4 }) {
    const { headers, method, signal: signal_ } = fetchOptions;
    try {
      const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {
        const response2 = await fetch(url, {
          ...fetchOptions,
          body: Array.isArray(body) ? (0, stringify_js_12.stringify)(body.map((body2) => ({
            jsonrpc: "2.0",
            id: body2.id ?? id2++,
            ...body2
          }))) : (0, stringify_js_12.stringify)({ jsonrpc: "2.0", id: body.id ?? id2++, ...body }),
          headers: {
            ...headers,
            "Content-Type": "application/json"
          },
          method: method || "POST",
          signal: signal_ || (timeout > 0 ? signal : void 0)
        });
        return response2;
      }, {
        errorInstance: new request_js_12.TimeoutError({ body, url }),
        timeout,
        signal: true
      });
      let data2;
      if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        data2 = await response.json();
      } else {
        data2 = await response.text();
      }
      if (!response.ok) {
        throw new request_js_12.HttpRequestError({
          body,
          details: (0, stringify_js_12.stringify)(data2.error) || response.statusText,
          headers: response.headers,
          status: response.status,
          url
        });
      }
      return data2;
    } catch (err) {
      if (err instanceof request_js_12.HttpRequestError)
        throw err;
      if (err instanceof request_js_12.TimeoutError)
        throw err;
      throw new request_js_12.HttpRequestError({
        body,
        details: err.message,
        url
      });
    }
  }
  exports.socketsCache = /* @__PURE__ */ new Map();
  async function getSocket2(url) {
    let socket = exports.socketsCache.get(url);
    if (socket)
      return socket;
    const { schedule } = (0, createBatchScheduler_js_12.createBatchScheduler)({
      id: url,
      fn: async () => {
        const webSocket3 = new isows_1.WebSocket(url);
        const requests = /* @__PURE__ */ new Map();
        const subscriptions = /* @__PURE__ */ new Map();
        const onMessage = ({ data: data2 }) => {
          const message = JSON.parse(data2);
          const isSubscription = message.method === "eth_subscription";
          const id3 = isSubscription ? message.params.subscription : message.id;
          const cache2 = isSubscription ? subscriptions : requests;
          const callback = cache2.get(id3);
          if (callback)
            callback({ data: data2 });
          if (!isSubscription)
            cache2.delete(id3);
        };
        const onClose = () => {
          exports.socketsCache.delete(url);
          webSocket3.removeEventListener("close", onClose);
          webSocket3.removeEventListener("message", onMessage);
        };
        webSocket3.addEventListener("close", onClose);
        webSocket3.addEventListener("message", onMessage);
        if (webSocket3.readyState === isows_1.WebSocket.CONNECTING) {
          await new Promise((resolve, reject) => {
            if (!webSocket3)
              return;
            webSocket3.onopen = resolve;
            webSocket3.onerror = reject;
          });
        }
        socket = Object.assign(webSocket3, {
          requests,
          subscriptions
        });
        exports.socketsCache.set(url, socket);
        return [socket];
      }
    });
    const [_2, [socket_]] = await schedule();
    return socket_;
  }
  exports.getSocket = getSocket2;
  function webSocket2(socket, { body, onResponse }) {
    if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
      throw new request_js_12.WebSocketRequestError({
        body,
        url: socket.url,
        details: "Socket is closed."
      });
    const id_ = id2++;
    const callback = ({ data: data2 }) => {
      const message = JSON.parse(data2);
      if (typeof message.id === "number" && id_ !== message.id)
        return;
      onResponse?.(message);
      if (body.method === "eth_subscribe" && typeof message.result === "string") {
        socket.subscriptions.set(message.result, callback);
      }
      if (body.method === "eth_unsubscribe") {
        socket.subscriptions.delete(body.params?.[0]);
      }
    };
    socket.requests.set(id_, callback);
    socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
    return socket;
  }
  async function webSocketAsync2(socket, { body, timeout = 1e4 }) {
    return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse) => exports.rpc.webSocket(socket, {
      body,
      onResponse
    })), {
      errorInstance: new request_js_12.TimeoutError({ body, url: socket.url }),
      timeout
    });
  }
  exports.rpc = {
    http: http2,
    webSocket: webSocket2,
    webSocketAsync: webSocketAsync2
  };
})(rpc$5);
const rpc$3 = /* @__PURE__ */ getDefaultExportFromCjs(rpc$5);
const rpc$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: rpc$3
}, [rpc$5]);
const require$$2$b = /* @__PURE__ */ getAugmentedNamespace(rpc$4);
Object.defineProperty(http$2, "__esModule", { value: true });
var http_2 = http$2.http = void 0;
const request_js_1$1 = require$$32$2;
const transport_js_1$1 = require$$36;
const createBatchScheduler_js_1 = require$$2$e;
const rpc_js_1$1 = require$$2$b;
const createTransport_js_1$1 = require$$11$2;
function http(url, config2 = {}) {
  const { batch: batch2, fetchOptions, key = "http", name: name2 = "HTTP JSON-RPC", retryDelay } = config2;
  return ({ chain: chain2, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch2 === "object" ? batch2 : {};
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = url || chain2?.rpcUrls.default.http[0];
    if (!url_)
      throw new transport_js_1$1.UrlRequiredError();
    return (0, createTransport_js_1$1.createTransport)({
      key,
      name: name2,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
          id: `${url}`,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpc_js_1$1.rpc.http(url_, {
            body: body2,
            fetchOptions,
            timeout
          }),
          sort: (a2, b2) => a2.id - b2.id
        });
        const fn = async (body2) => batch2 ? schedule(body2) : [await rpc_js_1$1.rpc.http(url_, { body: body2, fetchOptions, timeout })];
        const [{ error, result }] = await fn(body);
        if (error)
          throw new request_js_1$1.RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url
    });
  };
}
http_2 = http$2.http = http;
const http$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: http$2,
  get http() {
    return http_2;
  }
}, [http$2]);
const require$$5$6 = /* @__PURE__ */ getAugmentedNamespace(http$1);
var createPublicClient = {};
var _public = {};
var getEnsAddress$2 = {};
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: true });
var isNullUniversalResolverError_1 = errors$1.isNullUniversalResolverError = void 0;
const solidity_js_1 = require$$0$K;
const base_js_1$5 = require$$21$2;
const contract_js_1$1 = require$$23$2;
function isNullUniversalResolverError(err, callType) {
  if (!(err instanceof base_js_1$5.BaseError))
    return false;
  const cause = err.walk((e2) => e2 instanceof contract_js_1$1.ContractFunctionRevertedError);
  if (!(cause instanceof contract_js_1$1.ContractFunctionRevertedError))
    return false;
  if (cause.data?.errorName === "ResolverNotFound")
    return true;
  if (cause.data?.errorName === "ResolverWildcardNotSupported")
    return true;
  if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === solidity_js_1.panicReasons[50])
    return true;
  return false;
}
isNullUniversalResolverError_1 = errors$1.isNullUniversalResolverError = isNullUniversalResolverError;
const errors = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: errors$1,
  get isNullUniversalResolverError() {
    return isNullUniversalResolverError_1;
  }
}, [errors$1]);
const require$$3$b = /* @__PURE__ */ getAugmentedNamespace(errors);
var namehash$2 = {};
var encodedLabelToLabelhash$2 = {};
Object.defineProperty(encodedLabelToLabelhash$2, "__esModule", { value: true });
var encodedLabelToLabelhash_2 = encodedLabelToLabelhash$2.encodedLabelToLabelhash = void 0;
const isHex_js_1$7 = require$$102;
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash2 = `0x${label.slice(1, 65)}`;
  if (!(0, isHex_js_1$7.isHex)(hash2))
    return null;
  return hash2;
}
encodedLabelToLabelhash_2 = encodedLabelToLabelhash$2.encodedLabelToLabelhash = encodedLabelToLabelhash;
const encodedLabelToLabelhash$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: encodedLabelToLabelhash$2,
  get encodedLabelToLabelhash() {
    return encodedLabelToLabelhash_2;
  }
}, [encodedLabelToLabelhash$2]);
const require$$3$a = /* @__PURE__ */ getAugmentedNamespace(encodedLabelToLabelhash$1);
Object.defineProperty(namehash$2, "__esModule", { value: true });
var namehash_2 = namehash$2.namehash = void 0;
const concat_js_1$4 = require$$80;
const toBytes_js_1$8 = requireToBytes();
const toHex_js_1$y = requireToHex();
const keccak256_js_1$2 = require$$103;
const encodedLabelToLabelhash_js_1$1 = require$$3$a;
function namehash(name2) {
  let result = new Uint8Array(32).fill(0);
  if (!name2)
    return (0, toHex_js_1$y.bytesToHex)(result);
  const labels = name2.split(".");
  for (let i2 = labels.length - 1; i2 >= 0; i2 -= 1) {
    const hashFromEncodedLabel = (0, encodedLabelToLabelhash_js_1$1.encodedLabelToLabelhash)(labels[i2]);
    const hashed = hashFromEncodedLabel ? (0, toBytes_js_1$8.toBytes)(hashFromEncodedLabel) : (0, keccak256_js_1$2.keccak256)((0, toBytes_js_1$8.stringToBytes)(labels[i2]), "bytes");
    result = (0, keccak256_js_1$2.keccak256)((0, concat_js_1$4.concat)([result, hashed]), "bytes");
  }
  return (0, toHex_js_1$y.bytesToHex)(result);
}
namehash_2 = namehash$2.namehash = namehash;
const namehash$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: namehash$2,
  get namehash() {
    return namehash_2;
  }
}, [namehash$2]);
const require$$38$1 = /* @__PURE__ */ getAugmentedNamespace(namehash$1);
var packetToBytes$2 = {};
var encodeLabelhash$2 = {};
Object.defineProperty(encodeLabelhash$2, "__esModule", { value: true });
var encodeLabelhash_2 = encodeLabelhash$2.encodeLabelhash = void 0;
function encodeLabelhash(hash2) {
  return `[${hash2.slice(2)}]`;
}
encodeLabelhash_2 = encodeLabelhash$2.encodeLabelhash = encodeLabelhash;
const encodeLabelhash$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: encodeLabelhash$2,
  get encodeLabelhash() {
    return encodeLabelhash_2;
  }
}, [encodeLabelhash$2]);
const require$$1$i = /* @__PURE__ */ getAugmentedNamespace(encodeLabelhash$1);
var labelhash$2 = {};
Object.defineProperty(labelhash$2, "__esModule", { value: true });
var labelhash_2 = labelhash$2.labelhash = void 0;
const toBytes_js_1$7 = requireToBytes();
const toHex_js_1$x = requireToHex();
const keccak256_js_1$1 = require$$103;
const encodedLabelToLabelhash_js_1 = require$$3$a;
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return (0, toHex_js_1$x.bytesToHex)(result);
  return (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(label) || (0, keccak256_js_1$1.keccak256)((0, toBytes_js_1$7.stringToBytes)(label));
}
labelhash_2 = labelhash$2.labelhash = labelhash;
const labelhash$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: labelhash$2,
  get labelhash() {
    return labelhash_2;
  }
}, [labelhash$2]);
const require$$37 = /* @__PURE__ */ getAugmentedNamespace(labelhash$1);
Object.defineProperty(packetToBytes$2, "__esModule", { value: true });
var packetToBytes_2 = packetToBytes$2.packetToBytes = void 0;
const toBytes_js_1$6 = requireToBytes();
const encodeLabelhash_js_1 = require$$1$i;
const labelhash_js_1 = require$$37;
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes2 = new Uint8Array((0, toBytes_js_1$6.stringToBytes)(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (let i2 = 0; i2 < list.length; i2++) {
    let encoded = (0, toBytes_js_1$6.stringToBytes)(list[i2]);
    if (encoded.byteLength > 255)
      encoded = (0, toBytes_js_1$6.stringToBytes)((0, encodeLabelhash_js_1.encodeLabelhash)((0, labelhash_js_1.labelhash)(list[i2])));
    bytes2[offset] = encoded.length;
    bytes2.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes2.byteLength !== offset + 1)
    return bytes2.slice(0, offset + 1);
  return bytes2;
}
packetToBytes_2 = packetToBytes$2.packetToBytes = packetToBytes;
const packetToBytes$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: packetToBytes$2,
  get packetToBytes() {
    return packetToBytes_2;
  }
}, [packetToBytes$2]);
const require$$2$a = /* @__PURE__ */ getAugmentedNamespace(packetToBytes$1);
Object.defineProperty(getEnsAddress$2, "__esModule", { value: true });
var getEnsAddress_2 = getEnsAddress$2.getEnsAddress = void 0;
const abis_js_1$3 = require$$14$3;
const decodeFunctionResult_js_1$2 = require$$46;
const encodeFunctionData_js_1$2 = require$$51;
const getChainContractAddress_js_1$4 = require$$84;
const trim_js_1$2 = require$$116;
const toHex_js_1$w = requireToHex();
const errors_js_1$2 = require$$3$b;
const namehash_js_1$1 = require$$38$1;
const packetToBytes_js_1$3 = require$$2$a;
const getAction_js_1$a = require$$4$a;
const readContract_js_1$5 = require$$33;
async function getEnsAddress(client2, { blockNumber, blockTag, coinType, name: name2, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = (0, getChainContractAddress_js_1$4.getChainContractAddress)({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = (0, encodeFunctionData_js_1$2.encodeFunctionData)({
      abi: abis_js_1$3.addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [(0, namehash_js_1$1.namehash)(name2), BigInt(coinType)] } : { args: [(0, namehash_js_1$1.namehash)(name2)] }
    });
    const res = await (0, getAction_js_1$a.getAction)(client2, readContract_js_1$5.readContract, "readContract")({
      address: universalResolverAddress,
      abi: abis_js_1$3.universalResolverResolveAbi,
      functionName: "resolve",
      args: [(0, toHex_js_1$w.toHex)((0, packetToBytes_js_1$3.packetToBytes)(name2)), functionData],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const address2 = (0, decodeFunctionResult_js_1$2.decodeFunctionResult)({
      abi: abis_js_1$3.addressResolverAbi,
      args: coinType != null ? [(0, namehash_js_1$1.namehash)(name2), BigInt(coinType)] : void 0,
      functionName: "addr",
      data: res[0]
    });
    if (address2 === "0x")
      return null;
    if ((0, trim_js_1$2.trim)(address2) === "0x00")
      return null;
    return address2;
  } catch (err) {
    if ((0, errors_js_1$2.isNullUniversalResolverError)(err, "resolve"))
      return null;
    throw err;
  }
}
getEnsAddress_2 = getEnsAddress$2.getEnsAddress = getEnsAddress;
const getEnsAddress$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getEnsAddress$2,
  get getEnsAddress() {
    return getEnsAddress_2;
  }
}, [getEnsAddress$2]);
const require$$0$D = /* @__PURE__ */ getAugmentedNamespace(getEnsAddress$1);
var getEnsAvatar$2 = {};
var parseAvatarRecord$2 = {};
var utils$7 = {};
var ens$1 = {};
Object.defineProperty(ens$1, "__esModule", { value: true });
var EnsAvatarUnsupportedNamespaceError_1 = ens$1.EnsAvatarUnsupportedNamespaceError = EnsAvatarUriResolutionError_1 = ens$1.EnsAvatarUriResolutionError = EnsAvatarInvalidNftUriError_1 = ens$1.EnsAvatarInvalidNftUriError = EnsAvatarInvalidMetadataError_1 = ens$1.EnsAvatarInvalidMetadataError = void 0;
const base_js_1$4 = require$$21$2;
class EnsAvatarInvalidMetadataError extends base_js_1$4.BaseError {
  constructor({ data: data2 }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data2)}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidMetadataError"
    });
  }
}
var EnsAvatarInvalidMetadataError_1 = ens$1.EnsAvatarInvalidMetadataError = EnsAvatarInvalidMetadataError;
class EnsAvatarInvalidNftUriError extends base_js_1$4.BaseError {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidNftUriError"
    });
  }
}
var EnsAvatarInvalidNftUriError_1 = ens$1.EnsAvatarInvalidNftUriError = EnsAvatarInvalidNftUriError;
class EnsAvatarUriResolutionError extends base_js_1$4.BaseError {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUriResolutionError"
    });
  }
}
var EnsAvatarUriResolutionError_1 = ens$1.EnsAvatarUriResolutionError = EnsAvatarUriResolutionError;
class EnsAvatarUnsupportedNamespaceError extends base_js_1$4.BaseError {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUnsupportedNamespaceError"
    });
  }
}
EnsAvatarUnsupportedNamespaceError_1 = ens$1.EnsAvatarUnsupportedNamespaceError = EnsAvatarUnsupportedNamespaceError;
const ens = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get EnsAvatarInvalidMetadataError() {
    return EnsAvatarInvalidMetadataError_1;
  },
  get EnsAvatarInvalidNftUriError() {
    return EnsAvatarInvalidNftUriError_1;
  },
  get EnsAvatarUnsupportedNamespaceError() {
    return EnsAvatarUnsupportedNamespaceError_1;
  },
  get EnsAvatarUriResolutionError() {
    return EnsAvatarUriResolutionError_1;
  },
  default: ens$1
}, [ens$1]);
const require$$28$2 = /* @__PURE__ */ getAugmentedNamespace(ens);
Object.defineProperty(utils$7, "__esModule", { value: true });
var getNftTokenUri_1 = utils$7.getNftTokenUri = parseNftUri_1 = utils$7.parseNftUri = parseAvatarUri_1 = utils$7.parseAvatarUri = getMetadataAvatarUri_1 = utils$7.getMetadataAvatarUri = getJsonImage_1 = utils$7.getJsonImage = resolveAvatarUri_1 = utils$7.resolveAvatarUri = getGateway_1 = utils$7.getGateway = isImageUri_1 = utils$7.isImageUri = void 0;
const readContract_js_1$4 = require$$33;
const ens_js_1 = require$$28$2;
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType?.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        resolve(true);
      };
      img.onerror = () => {
        resolve(false);
      };
      img.src = uri;
    });
  }
}
var isImageUri_1 = utils$7.isImageUri = isImageUri;
function getGateway(custom2, defaultGateway) {
  if (!custom2)
    return defaultGateway;
  if (custom2.endsWith("/"))
    return custom2.slice(0, -1);
  return custom2;
}
var getGateway_1 = utils$7.getGateway = getGateway;
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls?.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
}
var resolveAvatarUri_1 = utils$7.resolveAvatarUri = resolveAvatarUri;
function getJsonImage(data2) {
  if (typeof data2 !== "object" || !("image" in data2) && !("image_url" in data2) && !("image_data" in data2)) {
    throw new ens_js_1.EnsAvatarInvalidMetadataError({ data: data2 });
  }
  return data2.image || data2.image_url || data2.image_data;
}
var getJsonImage_1 = utils$7.getJsonImage = getJsonImage;
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
  }
}
var getMetadataAvatarUri_1 = utils$7.getMetadataAvatarUri = getMetadataAvatarUri;
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
}
var parseAvatarUri_1 = utils$7.parseAvatarUri = parseAvatarUri;
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new ens_js_1.EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
var parseNftUri_1 = utils$7.parseNftUri = parseNftUri;
async function getNftTokenUri(client2, { nft }) {
  if (nft.namespace === "erc721") {
    return (0, readContract_js_1$4.readContract)(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return (0, readContract_js_1$4.readContract)(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}
getNftTokenUri_1 = utils$7.getNftTokenUri = getNftTokenUri;
const utils$6 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$7,
  get getGateway() {
    return getGateway_1;
  },
  get getJsonImage() {
    return getJsonImage_1;
  },
  get getMetadataAvatarUri() {
    return getMetadataAvatarUri_1;
  },
  get getNftTokenUri() {
    return getNftTokenUri_1;
  },
  get isImageUri() {
    return isImageUri_1;
  },
  get parseAvatarUri() {
    return parseAvatarUri_1;
  },
  get parseNftUri() {
    return parseNftUri_1;
  },
  get resolveAvatarUri() {
    return resolveAvatarUri_1;
  }
}, [utils$7]);
const require$$0$C = /* @__PURE__ */ getAugmentedNamespace(utils$6);
Object.defineProperty(parseAvatarRecord$2, "__esModule", { value: true });
var parseAvatarRecord_2 = parseAvatarRecord$2.parseAvatarRecord = void 0;
const utils_js_1$3 = require$$0$C;
async function parseAvatarRecord(client2, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client2, { gatewayUrls, record });
  return (0, utils_js_1$3.parseAvatarUri)({ uri: record, gatewayUrls });
}
parseAvatarRecord_2 = parseAvatarRecord$2.parseAvatarRecord = parseAvatarRecord;
async function parseNftAvatarUri(client2, { gatewayUrls, record }) {
  const nft = (0, utils_js_1$3.parseNftUri)(record);
  const nftUri = await (0, utils_js_1$3.getNftTokenUri)(client2, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = (0, utils_js_1$3.resolveAvatarUri)({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
    const decoded = JSON.parse(encodedJson);
    return (0, utils_js_1$3.parseAvatarUri)({ uri: (0, utils_js_1$3.getJsonImage)(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return (0, utils_js_1$3.getMetadataAvatarUri)({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}
const parseAvatarRecord$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: parseAvatarRecord$2,
  get parseAvatarRecord() {
    return parseAvatarRecord_2;
  }
}, [parseAvatarRecord$2]);
const require$$0$B = /* @__PURE__ */ getAugmentedNamespace(parseAvatarRecord$1);
var getEnsText$2 = {};
Object.defineProperty(getEnsText$2, "__esModule", { value: true });
var getEnsText_2 = getEnsText$2.getEnsText = void 0;
const abis_js_1$2 = require$$14$3;
const decodeFunctionResult_js_1$1 = require$$46;
const encodeFunctionData_js_1$1 = require$$51;
const getChainContractAddress_js_1$3 = require$$84;
const toHex_js_1$v = requireToHex();
const errors_js_1$1 = require$$3$b;
const namehash_js_1 = require$$38$1;
const packetToBytes_js_1$2 = require$$2$a;
const getAction_js_1$9 = require$$4$a;
const readContract_js_1$3 = require$$33;
async function getEnsText(client2, { blockNumber, blockTag, name: name2, key, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = (0, getChainContractAddress_js_1$3.getChainContractAddress)({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const res = await (0, getAction_js_1$9.getAction)(client2, readContract_js_1$3.readContract, "readContract")({
      address: universalResolverAddress,
      abi: abis_js_1$2.universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        (0, toHex_js_1$v.toHex)((0, packetToBytes_js_1$2.packetToBytes)(name2)),
        (0, encodeFunctionData_js_1$1.encodeFunctionData)({
          abi: abis_js_1$2.textResolverAbi,
          functionName: "text",
          args: [(0, namehash_js_1.namehash)(name2), key]
        })
      ],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const record = (0, decodeFunctionResult_js_1$1.decodeFunctionResult)({
      abi: abis_js_1$2.textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if ((0, errors_js_1$1.isNullUniversalResolverError)(err, "resolve"))
      return null;
    throw err;
  }
}
getEnsText_2 = getEnsText$2.getEnsText = getEnsText;
const getEnsText$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getEnsText$2,
  get getEnsText() {
    return getEnsText_2;
  }
}, [getEnsText$2]);
const require$$4$7 = /* @__PURE__ */ getAugmentedNamespace(getEnsText$1);
Object.defineProperty(getEnsAvatar$2, "__esModule", { value: true });
var getEnsAvatar_2 = getEnsAvatar$2.getEnsAvatar = void 0;
const parseAvatarRecord_js_1 = require$$0$B;
const getAction_js_1$8 = require$$4$a;
const getEnsText_js_1 = require$$4$7;
async function getEnsAvatar(client2, { blockNumber, blockTag, gatewayUrls, name: name2, universalResolverAddress }) {
  const record = await (0, getAction_js_1$8.getAction)(client2, getEnsText_js_1.getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name: name2,
    universalResolverAddress
  });
  if (!record)
    return null;
  try {
    return await (0, parseAvatarRecord_js_1.parseAvatarRecord)(client2, { record, gatewayUrls });
  } catch {
    return null;
  }
}
getEnsAvatar_2 = getEnsAvatar$2.getEnsAvatar = getEnsAvatar;
const getEnsAvatar$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getEnsAvatar$2,
  get getEnsAvatar() {
    return getEnsAvatar_2;
  }
}, [getEnsAvatar$2]);
const require$$1$h = /* @__PURE__ */ getAugmentedNamespace(getEnsAvatar$1);
var getEnsName$2 = {};
Object.defineProperty(getEnsName$2, "__esModule", { value: true });
var getEnsName_2 = getEnsName$2.getEnsName = void 0;
const abis_js_1$1 = require$$14$3;
const getChainContractAddress_js_1$2 = require$$84;
const toHex_js_1$u = requireToHex();
const errors_js_1 = require$$3$b;
const packetToBytes_js_1$1 = require$$2$a;
const getAction_js_1$7 = require$$4$a;
const readContract_js_1$2 = require$$33;
async function getEnsName(client2, { address: address2, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = (0, getChainContractAddress_js_1$2.getChainContractAddress)({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address2.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const [name2, resolvedAddress] = await (0, getAction_js_1$7.getAction)(client2, readContract_js_1$2.readContract, "readContract")({
      address: universalResolverAddress,
      abi: abis_js_1$1.universalResolverReverseAbi,
      functionName: "reverse",
      args: [(0, toHex_js_1$u.toHex)((0, packetToBytes_js_1$1.packetToBytes)(reverseNode))],
      blockNumber,
      blockTag
    });
    if (address2.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name2;
  } catch (err) {
    if ((0, errors_js_1.isNullUniversalResolverError)(err, "reverse"))
      return null;
    throw err;
  }
}
getEnsName_2 = getEnsName$2.getEnsName = getEnsName;
const getEnsName$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getEnsName$2,
  get getEnsName() {
    return getEnsName_2;
  }
}, [getEnsName$2]);
const require$$2$9 = /* @__PURE__ */ getAugmentedNamespace(getEnsName$1);
var getEnsResolver$2 = {};
Object.defineProperty(getEnsResolver$2, "__esModule", { value: true });
var getEnsResolver_2 = getEnsResolver$2.getEnsResolver = void 0;
const getChainContractAddress_js_1$1 = require$$84;
const toHex_js_1$t = requireToHex();
const packetToBytes_js_1 = require$$2$a;
const getAction_js_1$6 = require$$4$a;
const readContract_js_1$1 = require$$33;
async function getEnsResolver(client2, { blockNumber, blockTag, name: name2, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = (0, getChainContractAddress_js_1$1.getChainContractAddress)({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await (0, getAction_js_1$6.getAction)(client2, readContract_js_1$1.readContract, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [(0, toHex_js_1$t.toHex)((0, packetToBytes_js_1.packetToBytes)(name2))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}
getEnsResolver_2 = getEnsResolver$2.getEnsResolver = getEnsResolver;
const getEnsResolver$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getEnsResolver$2,
  get getEnsResolver() {
    return getEnsResolver_2;
  }
}, [getEnsResolver$2]);
const require$$3$9 = /* @__PURE__ */ getAugmentedNamespace(getEnsResolver$1);
var createBlockFilter$2 = {};
Object.defineProperty(createBlockFilter$2, "__esModule", { value: true });
var createBlockFilter_2 = createBlockFilter$2.createBlockFilter = void 0;
const createFilterRequestScope_js_1$2 = require$$0$M;
async function createBlockFilter(client2) {
  const getRequest = (0, createFilterRequestScope_js_1$2.createFilterRequestScope)(client2, {
    method: "eth_newBlockFilter"
  });
  const id2 = await client2.request({
    method: "eth_newBlockFilter"
  });
  return { id: id2, request: getRequest(id2), type: "block" };
}
createBlockFilter_2 = createBlockFilter$2.createBlockFilter = createBlockFilter;
const createBlockFilter$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createBlockFilter() {
    return createBlockFilter_2;
  },
  default: createBlockFilter$2
}, [createBlockFilter$2]);
const require$$6$6 = /* @__PURE__ */ getAugmentedNamespace(createBlockFilter$1);
var createEventFilter$2 = {};
Object.defineProperty(createEventFilter$2, "__esModule", { value: true });
var createEventFilter_2 = createEventFilter$2.createEventFilter = void 0;
const encodeEventTopics_js_1 = require$$50;
const toHex_js_1$s = requireToHex();
const createFilterRequestScope_js_1$1 = require$$0$M;
async function createEventFilter(client2, { address: address2, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events2 = events_ ?? (event ? [event] : void 0);
  const getRequest = (0, createFilterRequestScope_js_1$1.createFilterRequestScope)(client2, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events2) {
    topics = [
      events2.flatMap((event2) => (0, encodeEventTopics_js_1.encodeEventTopics)({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  const id2 = await client2.request({
    method: "eth_newFilter",
    params: [
      {
        address: address2,
        fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1$s.numberToHex)(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1$s.numberToHex)(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events2,
    args,
    eventName: event ? event.name : void 0,
    fromBlock,
    id: id2,
    request: getRequest(id2),
    strict,
    toBlock,
    type: "event"
  };
}
createEventFilter_2 = createEventFilter$2.createEventFilter = createEventFilter;
const createEventFilter$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createEventFilter() {
    return createEventFilter_2;
  },
  default: createEventFilter$2
}, [createEventFilter$2]);
const require$$8$2 = /* @__PURE__ */ getAugmentedNamespace(createEventFilter$1);
var createPendingTransactionFilter$2 = {};
Object.defineProperty(createPendingTransactionFilter$2, "__esModule", { value: true });
var createPendingTransactionFilter_2 = createPendingTransactionFilter$2.createPendingTransactionFilter = void 0;
const createFilterRequestScope_js_1 = require$$0$M;
async function createPendingTransactionFilter(client2) {
  const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client2, {
    method: "eth_newPendingTransactionFilter"
  });
  const id2 = await client2.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: id2, request: getRequest(id2), type: "transaction" };
}
createPendingTransactionFilter_2 = createPendingTransactionFilter$2.createPendingTransactionFilter = createPendingTransactionFilter;
const createPendingTransactionFilter$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createPendingTransactionFilter() {
    return createPendingTransactionFilter_2;
  },
  default: createPendingTransactionFilter$2
}, [createPendingTransactionFilter$2]);
const require$$9$3 = /* @__PURE__ */ getAugmentedNamespace(createPendingTransactionFilter$1);
var getBalance$2 = {};
Object.defineProperty(getBalance$2, "__esModule", { value: true });
var getBalance_2 = getBalance$2.getBalance = void 0;
const toHex_js_1$r = requireToHex();
async function getBalance(client2, { address: address2, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? (0, toHex_js_1$r.numberToHex)(blockNumber) : void 0;
  const balance = await client2.request({
    method: "eth_getBalance",
    params: [address2, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}
getBalance_2 = getBalance$2.getBalance = getBalance;
const getBalance$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getBalance$2,
  get getBalance() {
    return getBalance_2;
  }
}, [getBalance$2]);
const require$$14$2 = /* @__PURE__ */ getAugmentedNamespace(getBalance$1);
var getBlockTransactionCount$2 = {};
Object.defineProperty(getBlockTransactionCount$2, "__esModule", { value: true });
var getBlockTransactionCount_2 = getBlockTransactionCount$2.getBlockTransactionCount = void 0;
const fromHex_js_1$9 = requireFromHex();
const toHex_js_1$q = requireToHex();
async function getBlockTransactionCount(client2, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1$q.numberToHex)(blockNumber) : void 0;
  let count;
  if (blockHash) {
    count = await client2.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  } else {
    count = await client2.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    });
  }
  return (0, fromHex_js_1$9.hexToNumber)(count);
}
getBlockTransactionCount_2 = getBlockTransactionCount$2.getBlockTransactionCount = getBlockTransactionCount;
const getBlockTransactionCount$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getBlockTransactionCount$2,
  get getBlockTransactionCount() {
    return getBlockTransactionCount_2;
  }
}, [getBlockTransactionCount$2]);
const require$$17$2 = /* @__PURE__ */ getAugmentedNamespace(getBlockTransactionCount$1);
var getBytecode$2 = {};
Object.defineProperty(getBytecode$2, "__esModule", { value: true });
var getBytecode_2 = getBytecode$2.getBytecode = void 0;
const toHex_js_1$p = requireToHex();
async function getBytecode(client2, { address: address2, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1$p.numberToHex)(blockNumber) : void 0;
  const hex2 = await client2.request({
    method: "eth_getCode",
    params: [address2, blockNumberHex || blockTag]
  });
  if (hex2 === "0x")
    return void 0;
  return hex2;
}
getBytecode_2 = getBytecode$2.getBytecode = getBytecode;
const getBytecode$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getBytecode$2,
  get getBytecode() {
    return getBytecode_2;
  }
}, [getBytecode$2]);
const require$$18$2 = /* @__PURE__ */ getAugmentedNamespace(getBytecode$1);
var getFeeHistory$2 = {};
var feeHistory$1 = {};
Object.defineProperty(feeHistory$1, "__esModule", { value: true });
var formatFeeHistory_1 = feeHistory$1.formatFeeHistory = void 0;
function formatFeeHistory(feeHistory2) {
  return {
    baseFeePerGas: feeHistory2.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory2.gasUsedRatio,
    oldestBlock: BigInt(feeHistory2.oldestBlock),
    reward: feeHistory2.reward?.map((reward) => reward.map((value) => BigInt(value)))
  };
}
formatFeeHistory_1 = feeHistory$1.formatFeeHistory = formatFeeHistory;
const feeHistory = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: feeHistory$1,
  get formatFeeHistory() {
    return formatFeeHistory_1;
  }
}, [feeHistory$1]);
const require$$1$g = /* @__PURE__ */ getAugmentedNamespace(feeHistory);
Object.defineProperty(getFeeHistory$2, "__esModule", { value: true });
var getFeeHistory_2 = getFeeHistory$2.getFeeHistory = void 0;
const toHex_js_1$o = requireToHex();
const feeHistory_js_1 = require$$1$g;
async function getFeeHistory(client2, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? (0, toHex_js_1$o.numberToHex)(blockNumber) : void 0;
  const feeHistory2 = await client2.request({
    method: "eth_feeHistory",
    params: [
      (0, toHex_js_1$o.numberToHex)(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  });
  return (0, feeHistory_js_1.formatFeeHistory)(feeHistory2);
}
getFeeHistory_2 = getFeeHistory$2.getFeeHistory = getFeeHistory;
const getFeeHistory$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getFeeHistory$2,
  get getFeeHistory() {
    return getFeeHistory_2;
  }
}, [getFeeHistory$2]);
const require$$21$1 = /* @__PURE__ */ getAugmentedNamespace(getFeeHistory$1);
var getFilterLogs$2 = {};
Object.defineProperty(getFilterLogs$2, "__esModule", { value: true });
var getFilterLogs_2 = getFilterLogs$2.getFilterLogs = void 0;
const abi_js_1$7 = requireAbi();
const decodeEventLog_js_1 = require$$44;
const log_js_1$1 = require$$40$1;
async function getFilterLogs(_client2, { filter: filter2 }) {
  const strict = filter2.strict ?? false;
  const logs = await filter2.request({
    method: "eth_getFilterLogs",
    params: [filter2.id]
  });
  return logs.map((log3) => {
    try {
      const { eventName, args } = "abi" in filter2 && filter2.abi ? (0, decodeEventLog_js_1.decodeEventLog)({
        abi: filter2.abi,
        data: log3.data,
        topics: log3.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return (0, log_js_1$1.formatLog)(log3, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof abi_js_1$7.DecodeLogDataMismatch || err instanceof abi_js_1$7.DecodeLogTopicsMismatch) {
        if ("strict" in filter2 && filter2.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
      }
      return (0, log_js_1$1.formatLog)(log3, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
getFilterLogs_2 = getFilterLogs$2.getFilterLogs = getFilterLogs;
const getFilterLogs$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getFilterLogs$2,
  get getFilterLogs() {
    return getFilterLogs_2;
  }
}, [getFilterLogs$2]);
const require$$23$1 = /* @__PURE__ */ getAugmentedNamespace(getFilterLogs$1);
var getProof = {};
var proof = {};
var utils$5 = {};
var defineChain$2 = {};
Object.defineProperty(defineChain$2, "__esModule", { value: true });
var defineChain_2 = defineChain$2.defineChain = void 0;
function defineChain(chain2, config2 = {}) {
  const { fees = chain2.fees, formatters = chain2.formatters, serializers = chain2.serializers } = config2;
  return {
    ...chain2,
    fees,
    formatters,
    serializers
  };
}
defineChain_2 = defineChain$2.defineChain = defineChain;
const defineChain$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: defineChain$2,
  get defineChain() {
    return defineChain_2;
  }
}, [defineChain$2]);
const require$$82 = /* @__PURE__ */ getAugmentedNamespace(defineChain$1);
var extractChain$2 = {};
Object.defineProperty(extractChain$2, "__esModule", { value: true });
var extractChain_2 = extractChain$2.extractChain = void 0;
function extractChain({ chains: chains2, id: id2 }) {
  return chains2.find((chain2) => chain2.id === id2);
}
extractChain_2 = extractChain$2.extractChain = extractChain;
const extractChain$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: extractChain$2,
  get extractChain() {
    return extractChain_2;
  }
}, [extractChain$2]);
const require$$83 = /* @__PURE__ */ getAugmentedNamespace(extractChain$1);
var regex$3 = {};
Object.defineProperty(regex$3, "__esModule", { value: true });
var integerRegex = regex$3.integerRegex = bytesRegex = regex$3.bytesRegex = arrayRegex = regex$3.arrayRegex = void 0;
var arrayRegex = regex$3.arrayRegex = /^(.*)\[([0-9]*)\]$/;
var bytesRegex = regex$3.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
integerRegex = regex$3.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
const regex$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get arrayRegex() {
    return arrayRegex;
  },
  get bytesRegex() {
    return bytesRegex;
  },
  default: regex$3,
  get integerRegex() {
    return integerRegex;
  }
}, [regex$3]);
const require$$6$5 = /* @__PURE__ */ getAugmentedNamespace(regex$2);
var typedData = {};
var hashTypedData = {};
var hasRequiredHashTypedData;
function requireHashTypedData() {
  if (hasRequiredHashTypedData)
    return hashTypedData;
  hasRequiredHashTypedData = 1;
  Object.defineProperty(hashTypedData, "__esModule", { value: true });
  hashTypedData.hashDomain = hashTypedData.hashTypedData = void 0;
  const encodeAbiParameters_js_12 = require$$47;
  const concat_js_12 = require$$80;
  const toHex_js_12 = requireToHex();
  const keccak256_js_12 = require$$103;
  const typedData_js_12 = requireTypedData();
  function hashTypedData$12({ domain: domain_, message, primaryType, types: types_ }) {
    const domain = typeof domain_ === "undefined" ? {} : domain_;
    const types2 = {
      EIP712Domain: (0, typedData_js_12.getTypesForEIP712Domain)({ domain }),
      ...types_
    };
    (0, typedData_js_12.validateTypedData)({
      domain,
      message,
      primaryType,
      types: types2
    });
    const parts = ["0x1901"];
    if (domain)
      parts.push(hashDomain2({
        domain,
        types: types2
      }));
    if (primaryType !== "EIP712Domain") {
      parts.push(hashStruct2({
        data: message,
        primaryType,
        types: types2
      }));
    }
    return (0, keccak256_js_12.keccak256)((0, concat_js_12.concat)(parts));
  }
  hashTypedData.hashTypedData = hashTypedData$12;
  function hashDomain2({ domain, types: types2 }) {
    return hashStruct2({
      data: domain,
      primaryType: "EIP712Domain",
      types: types2
    });
  }
  hashTypedData.hashDomain = hashDomain2;
  function hashStruct2({ data: data2, primaryType, types: types2 }) {
    const encoded = encodeData2({
      data: data2,
      primaryType,
      types: types2
    });
    return (0, keccak256_js_12.keccak256)(encoded);
  }
  function encodeData2({ data: data2, primaryType, types: types2 }) {
    const encodedTypes = [{ type: "bytes32" }];
    const encodedValues = [hashType2({ primaryType, types: types2 })];
    for (const field of types2[primaryType]) {
      const [type, value] = encodeField2({
        types: types2,
        name: field.name,
        type: field.type,
        value: data2[field.name]
      });
      encodedTypes.push(type);
      encodedValues.push(value);
    }
    return (0, encodeAbiParameters_js_12.encodeAbiParameters)(encodedTypes, encodedValues);
  }
  function hashType2({ primaryType, types: types2 }) {
    const encodedHashType = (0, toHex_js_12.toHex)(encodeType2({ primaryType, types: types2 }));
    return (0, keccak256_js_12.keccak256)(encodedHashType);
  }
  function encodeType2({ primaryType, types: types2 }) {
    let result = "";
    const unsortedDeps = findTypeDependencies2({ primaryType, types: types2 });
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
      result += `${type}(${types2[type].map(({ name: name2, type: t2 }) => `${t2} ${name2}`).join(",")})`;
    }
    return result;
  }
  function findTypeDependencies2({ primaryType: primaryType_, types: types2 }, results = /* @__PURE__ */ new Set()) {
    const match = primaryType_.match(/^\w*/u);
    const primaryType = match?.[0];
    if (results.has(primaryType) || types2[primaryType] === void 0) {
      return results;
    }
    results.add(primaryType);
    for (const field of types2[primaryType]) {
      findTypeDependencies2({ primaryType: field.type, types: types2 }, results);
    }
    return results;
  }
  function encodeField2({ types: types2, name: name2, type, value }) {
    if (types2[type] !== void 0) {
      return [
        { type: "bytes32" },
        (0, keccak256_js_12.keccak256)(encodeData2({ data: value, primaryType: type, types: types2 }))
      ];
    }
    if (type === "bytes") {
      const prepend = value.length % 2 ? "0" : "";
      value = `0x${prepend + value.slice(2)}`;
      return [{ type: "bytes32" }, (0, keccak256_js_12.keccak256)(value)];
    }
    if (type === "string")
      return [{ type: "bytes32" }, (0, keccak256_js_12.keccak256)((0, toHex_js_12.toHex)(value))];
    if (type.lastIndexOf("]") === type.length - 1) {
      const parsedType = type.slice(0, type.lastIndexOf("["));
      const typeValuePairs = value.map((item) => encodeField2({
        name: name2,
        type: parsedType,
        types: types2,
        value: item
      }));
      return [
        { type: "bytes32" },
        (0, keccak256_js_12.keccak256)((0, encodeAbiParameters_js_12.encodeAbiParameters)(typeValuePairs.map(([t2]) => t2), typeValuePairs.map(([, v2]) => v2)))
      ];
    }
    return [{ type }, value];
  }
  return hashTypedData;
}
var hasRequiredTypedData;
function requireTypedData() {
  if (hasRequiredTypedData)
    return typedData;
  hasRequiredTypedData = 1;
  Object.defineProperty(typedData, "__esModule", { value: true });
  typedData.domainSeparator = typedData.getTypesForEIP712Domain = typedData.validateTypedData = void 0;
  const abi_js_12 = requireAbi();
  const address_js_12 = require$$33$1;
  const isAddress_js_12 = require$$98;
  const size_js_12 = require$$113;
  const toHex_js_12 = requireToHex();
  const regex_js_12 = require$$6$5;
  const hashTypedData_js_12 = requireHashTypedData();
  function validateTypedData2({ domain, message, primaryType, types: types_ }) {
    const types2 = types_;
    const validateData = (struct2, value_) => {
      for (const param of struct2) {
        const { name: name2, type: type_ } = param;
        const type = type_;
        const value = value_[name2];
        const integerMatch = type.match(regex_js_12.integerRegex);
        if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
          const [_type, base3, size_] = integerMatch;
          (0, toHex_js_12.numberToHex)(value, {
            signed: base3 === "int",
            size: parseInt(size_) / 8
          });
        }
        if (type === "address" && typeof value === "string" && !(0, isAddress_js_12.isAddress)(value))
          throw new address_js_12.InvalidAddressError({ address: value });
        const bytesMatch = type.match(regex_js_12.bytesRegex);
        if (bytesMatch) {
          const [_type, size_] = bytesMatch;
          if (size_ && (0, size_js_12.size)(value) !== parseInt(size_))
            throw new abi_js_12.BytesSizeMismatchError({
              expectedSize: parseInt(size_),
              givenSize: (0, size_js_12.size)(value)
            });
        }
        const struct3 = types2[type];
        if (struct3)
          validateData(struct3, value);
      }
    };
    if (types2.EIP712Domain && domain)
      validateData(types2.EIP712Domain, domain);
    if (primaryType !== "EIP712Domain") {
      const type = types2[primaryType];
      validateData(type, message);
    }
  }
  typedData.validateTypedData = validateTypedData2;
  function getTypesForEIP712Domain2({ domain }) {
    return [
      typeof domain?.name === "string" && { name: "name", type: "string" },
      domain?.version && { name: "version", type: "string" },
      typeof domain?.chainId === "number" && {
        name: "chainId",
        type: "uint256"
      },
      domain?.verifyingContract && {
        name: "verifyingContract",
        type: "address"
      },
      domain?.salt && { name: "salt", type: "bytes32" }
    ].filter(Boolean);
  }
  typedData.getTypesForEIP712Domain = getTypesForEIP712Domain2;
  function domainSeparator({ domain }) {
    return (0, hashTypedData_js_12.hashDomain)({
      domain,
      types: {
        EIP712Domain: getTypesForEIP712Domain2({ domain })
      }
    });
  }
  typedData.domainSeparator = domainSeparator;
  return typedData;
}
var decodeFunctionData$2 = {};
Object.defineProperty(decodeFunctionData$2, "__esModule", { value: true });
var decodeFunctionData_2 = decodeFunctionData$2.decodeFunctionData = void 0;
const abi_js_1$6 = requireAbi();
const slice_js_1$1 = require$$114;
const getFunctionSelector_js_1$1 = require$$95;
const decodeAbiParameters_js_1$1 = require$$41$1;
const formatAbiItem_js_1$1 = requireFormatAbiItem();
function decodeFunctionData({ abi: abi2, data: data2 }) {
  const signature2 = (0, slice_js_1$1.slice)(data2, 0, 4);
  const description2 = abi2.find((x2) => x2.type === "function" && signature2 === (0, getFunctionSelector_js_1$1.getFunctionSelector)((0, formatAbiItem_js_1$1.formatAbiItem)(x2)));
  if (!description2)
    throw new abi_js_1$6.AbiFunctionSignatureNotFoundError(signature2, {
      docsPath: "/docs/contract/decodeFunctionData"
    });
  return {
    functionName: description2.name,
    args: "inputs" in description2 && description2.inputs && description2.inputs.length > 0 ? (0, decodeAbiParameters_js_1$1.decodeAbiParameters)(description2.inputs, (0, slice_js_1$1.slice)(data2, 4)) : void 0
  };
}
decodeFunctionData_2 = decodeFunctionData$2.decodeFunctionData = decodeFunctionData;
const decodeFunctionData$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get decodeFunctionData() {
    return decodeFunctionData_2;
  },
  default: decodeFunctionData$2
}, [decodeFunctionData$2]);
const require$$45 = /* @__PURE__ */ getAugmentedNamespace(decodeFunctionData$1);
var encodeDeployData$2 = {};
Object.defineProperty(encodeDeployData$2, "__esModule", { value: true });
var encodeDeployData_2 = encodeDeployData$2.encodeDeployData = void 0;
const abi_js_1$5 = requireAbi();
const concat_js_1$3 = require$$80;
const encodeAbiParameters_js_1$2 = require$$47;
const docsPath$3 = "/docs/contract/encodeDeployData";
function encodeDeployData({ abi: abi2, args, bytecode }) {
  if (!args || args.length === 0)
    return bytecode;
  const description2 = abi2.find((x2) => "type" in x2 && x2.type === "constructor");
  if (!description2)
    throw new abi_js_1$5.AbiConstructorNotFoundError({ docsPath: docsPath$3 });
  if (!("inputs" in description2))
    throw new abi_js_1$5.AbiConstructorParamsNotFoundError({ docsPath: docsPath$3 });
  if (!description2.inputs || description2.inputs.length === 0)
    throw new abi_js_1$5.AbiConstructorParamsNotFoundError({ docsPath: docsPath$3 });
  const data2 = (0, encodeAbiParameters_js_1$2.encodeAbiParameters)(description2.inputs, args);
  return (0, concat_js_1$3.concatHex)([bytecode, data2]);
}
encodeDeployData_2 = encodeDeployData$2.encodeDeployData = encodeDeployData;
const encodeDeployData$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: encodeDeployData$2,
  get encodeDeployData() {
    return encodeDeployData_2;
  }
}, [encodeDeployData$2]);
const require$$48 = /* @__PURE__ */ getAugmentedNamespace(encodeDeployData$1);
var encodeErrorResult$2 = {};
Object.defineProperty(encodeErrorResult$2, "__esModule", { value: true });
var encodeErrorResult_2 = encodeErrorResult$2.encodeErrorResult = void 0;
const abi_js_1$4 = requireAbi();
const concat_js_1$2 = require$$80;
const getFunctionSelector_js_1 = require$$95;
const encodeAbiParameters_js_1$1 = require$$47;
const formatAbiItem_js_1 = requireFormatAbiItem();
const getAbiItem_js_1$1 = require$$56$1;
const docsPath$2 = "/docs/contract/encodeErrorResult";
function encodeErrorResult({ abi: abi2, errorName, args }) {
  let abiItem2 = abi2[0];
  if (errorName) {
    abiItem2 = (0, getAbiItem_js_1$1.getAbiItem)({
      abi: abi2,
      args,
      name: errorName
    });
    if (!abiItem2)
      throw new abi_js_1$4.AbiErrorNotFoundError(errorName, { docsPath: docsPath$2 });
  }
  if (abiItem2.type !== "error")
    throw new abi_js_1$4.AbiErrorNotFoundError(void 0, { docsPath: docsPath$2 });
  const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem2);
  const signature2 = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
  let data2 = "0x";
  if (args && args.length > 0) {
    if (!abiItem2.inputs)
      throw new abi_js_1$4.AbiErrorInputsNotFoundError(abiItem2.name, { docsPath: docsPath$2 });
    data2 = (0, encodeAbiParameters_js_1$1.encodeAbiParameters)(abiItem2.inputs, args);
  }
  return (0, concat_js_1$2.concatHex)([signature2, data2]);
}
encodeErrorResult_2 = encodeErrorResult$2.encodeErrorResult = encodeErrorResult;
const encodeErrorResult$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: encodeErrorResult$2,
  get encodeErrorResult() {
    return encodeErrorResult_2;
  }
}, [encodeErrorResult$2]);
const require$$49 = /* @__PURE__ */ getAugmentedNamespace(encodeErrorResult$1);
var encodeFunctionResult$2 = {};
Object.defineProperty(encodeFunctionResult$2, "__esModule", { value: true });
var encodeFunctionResult_2 = encodeFunctionResult$2.encodeFunctionResult = void 0;
const abi_js_1$3 = requireAbi();
const encodeAbiParameters_js_1 = require$$47;
const getAbiItem_js_1 = require$$56$1;
const docsPath$1 = "/docs/contract/encodeFunctionResult";
function encodeFunctionResult({ abi: abi2, functionName, result }) {
  let abiItem2 = abi2[0];
  if (functionName) {
    abiItem2 = (0, getAbiItem_js_1.getAbiItem)({
      abi: abi2,
      name: functionName
    });
    if (!abiItem2)
      throw new abi_js_1$3.AbiFunctionNotFoundError(functionName, {
        docsPath: "/docs/contract/encodeFunctionResult"
      });
  }
  if (abiItem2.type !== "function")
    throw new abi_js_1$3.AbiFunctionNotFoundError(void 0, {
      docsPath: "/docs/contract/encodeFunctionResult"
    });
  if (!abiItem2.outputs)
    throw new abi_js_1$3.AbiFunctionOutputsNotFoundError(abiItem2.name, { docsPath: docsPath$1 });
  let values = Array.isArray(result) ? result : [result];
  if (abiItem2.outputs.length === 0 && !values[0])
    values = [];
  return (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem2.outputs, values);
}
encodeFunctionResult_2 = encodeFunctionResult$2.encodeFunctionResult = encodeFunctionResult;
const encodeFunctionResult$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: encodeFunctionResult$2,
  get encodeFunctionResult() {
    return encodeFunctionResult_2;
  }
}, [encodeFunctionResult$2]);
const require$$52 = /* @__PURE__ */ getAugmentedNamespace(encodeFunctionResult$1);
var encodePacked$2 = {};
Object.defineProperty(encodePacked$2, "__esModule", { value: true });
var encodePacked_2 = encodePacked$2.encodePacked = void 0;
const abi_js_1$2 = requireAbi();
const address_js_1$3 = require$$33$1;
const isAddress_js_1$3 = require$$98;
const concat_js_1$1 = require$$80;
const pad_js_1$1 = require$$106;
const toHex_js_1$n = requireToHex();
const regex_js_1 = require$$6$5;
function encodePacked(types2, values) {
  if (types2.length !== values.length)
    throw new abi_js_1$2.AbiEncodingLengthMismatchError({
      expectedLength: types2.length,
      givenLength: values.length
    });
  const data2 = [];
  for (let i2 = 0; i2 < types2.length; i2++) {
    const type = types2[i2];
    const value = values[i2];
    data2.push(encode$a(type, value));
  }
  return (0, concat_js_1$1.concatHex)(data2);
}
encodePacked_2 = encodePacked$2.encodePacked = encodePacked;
function encode$a(type, value, isArray2 = false) {
  if (type === "address") {
    const address2 = value;
    if (!(0, isAddress_js_1$3.isAddress)(address2))
      throw new address_js_1$3.InvalidAddressError({ address: address2 });
    return (0, pad_js_1$1.pad)(address2.toLowerCase(), {
      size: isArray2 ? 32 : null
    });
  }
  if (type === "string")
    return (0, toHex_js_1$n.stringToHex)(value);
  if (type === "bytes")
    return value;
  if (type === "bool")
    return (0, pad_js_1$1.pad)((0, toHex_js_1$n.boolToHex)(value), { size: isArray2 ? 32 : 1 });
  const intMatch = type.match(regex_js_1.integerRegex);
  if (intMatch) {
    const [_type, baseType, bits = "256"] = intMatch;
    const size2 = parseInt(bits) / 8;
    return (0, toHex_js_1$n.numberToHex)(value, {
      size: isArray2 ? 32 : size2,
      signed: baseType === "int"
    });
  }
  const bytesMatch = type.match(regex_js_1.bytesRegex);
  if (bytesMatch) {
    const [_type, size2] = bytesMatch;
    if (parseInt(size2) !== (value.length - 2) / 2)
      throw new abi_js_1$2.BytesSizeMismatchError({
        expectedSize: parseInt(size2),
        givenSize: (value.length - 2) / 2
      });
    return (0, pad_js_1$1.pad)(value, { dir: "right", size: isArray2 ? 32 : null });
  }
  const arrayMatch = type.match(regex_js_1.arrayRegex);
  if (arrayMatch && Array.isArray(value)) {
    const [_type, childType] = arrayMatch;
    const data2 = [];
    for (let i2 = 0; i2 < value.length; i2++) {
      data2.push(encode$a(childType, value[i2], true));
    }
    if (data2.length === 0)
      return "0x";
    return (0, concat_js_1$1.concatHex)(data2);
  }
  throw new abi_js_1$2.UnsupportedPackedAbiType(type);
}
const encodePacked$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: encodePacked$2,
  get encodePacked() {
    return encodePacked_2;
  }
}, [encodePacked$2]);
const require$$85 = /* @__PURE__ */ getAugmentedNamespace(encodePacked$1);
var getContractAddress = {};
var isBytes$4 = {};
Object.defineProperty(isBytes$4, "__esModule", { value: true });
var isBytes_2 = isBytes$4.isBytes = void 0;
function isBytes$2(value) {
  if (!value)
    return false;
  if (typeof value !== "object")
    return false;
  if (!("BYTES_PER_ELEMENT" in value))
    return false;
  return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === "Uint8Array";
}
isBytes_2 = isBytes$4.isBytes = isBytes$2;
const isBytes$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: isBytes$4,
  get isBytes() {
    return isBytes_2;
  }
}, [isBytes$4]);
const require$$100 = /* @__PURE__ */ getAugmentedNamespace(isBytes$3);
var toRlp = {};
var cursor$3 = {};
var cursor$2 = {};
Object.defineProperty(cursor$2, "__esModule", { value: true });
var PositionOutOfBoundsError_1 = cursor$2.PositionOutOfBoundsError = NegativeOffsetError_1 = cursor$2.NegativeOffsetError = void 0;
const base_js_1$3 = require$$21$2;
class NegativeOffsetError extends base_js_1$3.BaseError {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NegativeOffsetError"
    });
  }
}
var NegativeOffsetError_1 = cursor$2.NegativeOffsetError = NegativeOffsetError;
class PositionOutOfBoundsError extends base_js_1$3.BaseError {
  constructor({ length: length2, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length2}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PositionOutOfBoundsError"
    });
  }
}
PositionOutOfBoundsError_1 = cursor$2.PositionOutOfBoundsError = PositionOutOfBoundsError;
const cursor$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get NegativeOffsetError() {
    return NegativeOffsetError_1;
  },
  get PositionOutOfBoundsError() {
    return PositionOutOfBoundsError_1;
  },
  default: cursor$2
}, [cursor$2]);
const require$$0$A = /* @__PURE__ */ getAugmentedNamespace(cursor$1);
Object.defineProperty(cursor$3, "__esModule", { value: true });
var createCursor_1 = cursor$3.createCursor = void 0;
const cursor_js_1$1 = require$$0$A;
const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new cursor_js_1$1.PositionOutOfBoundsError({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new cursor_js_1$1.NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new cursor_js_1$1.NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length2, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length2 - 1);
    return this.bytes.subarray(position, position + length2);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte2) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte2;
    this.position++;
  },
  pushBytes(bytes2) {
    this.assertPosition(this.position + bytes2.length - 1);
    this.bytes.set(bytes2, this.position);
    this.position += bytes2.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length2) {
    const value = this.inspectBytes(length2);
    this.position += length2;
    return value;
  },
  readUint8() {
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  setPosition(position) {
    this.assertPosition(position);
    this.position = position;
  }
};
function createCursor(bytes2) {
  const cursor2 = Object.create(staticCursor);
  cursor2.bytes = bytes2;
  cursor2.dataView = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  return cursor2;
}
createCursor_1 = cursor$3.createCursor = createCursor;
const cursor = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createCursor() {
    return createCursor_1;
  },
  default: cursor$3
}, [cursor$3]);
const require$$2$8 = /* @__PURE__ */ getAugmentedNamespace(cursor);
var hasRequiredToRlp;
function requireToRlp() {
  if (hasRequiredToRlp)
    return toRlp;
  hasRequiredToRlp = 1;
  Object.defineProperty(toRlp, "__esModule", { value: true });
  toRlp.hexToRlp = toRlp.bytesToRlp = toRlp.toRlp = void 0;
  const index_js_1 = require_cjs();
  const cursor_js_12 = require$$2$8;
  const toBytes_js_12 = requireToBytes();
  const toHex_js_12 = requireToHex();
  function toRlp$1(bytes2, to = "hex") {
    const encodable = getEncodable(bytes2);
    const cursor2 = (0, cursor_js_12.createCursor)(new Uint8Array(encodable.length));
    encodable.encode(cursor2);
    if (to === "hex")
      return (0, toHex_js_12.bytesToHex)(cursor2.bytes);
    return cursor2.bytes;
  }
  toRlp.toRlp = toRlp$1;
  function bytesToRlp(bytes2, to = "bytes") {
    return toRlp$1(bytes2, to);
  }
  toRlp.bytesToRlp = bytesToRlp;
  function hexToRlp(hex2, to = "hex") {
    return toRlp$1(hex2, to);
  }
  toRlp.hexToRlp = hexToRlp;
  function getEncodable(bytes2) {
    if (Array.isArray(bytes2))
      return getEncodableList(bytes2.map((x2) => getEncodable(x2)));
    return getEncodableBytes(bytes2);
  }
  function getEncodableList(list) {
    const bodyLength = list.reduce((acc, x2) => acc + x2.length, 0);
    const sizeOfBodyLength = getSizeOfLength(bodyLength);
    const length2 = (() => {
      if (bodyLength <= 55)
        return 1 + bodyLength;
      return 1 + sizeOfBodyLength + bodyLength;
    })();
    return {
      length: length2,
      encode(cursor2) {
        if (bodyLength <= 55) {
          cursor2.pushByte(192 + bodyLength);
        } else {
          cursor2.pushByte(192 + 55 + sizeOfBodyLength);
          if (sizeOfBodyLength === 1)
            cursor2.pushUint8(bodyLength);
          else if (sizeOfBodyLength === 2)
            cursor2.pushUint16(bodyLength);
          else if (sizeOfBodyLength === 3)
            cursor2.pushUint24(bodyLength);
          else
            cursor2.pushUint32(bodyLength);
        }
        for (const { encode: encode3 } of list) {
          encode3(cursor2);
        }
      }
    };
  }
  function getEncodableBytes(bytesOrHex) {
    const bytes2 = typeof bytesOrHex === "string" ? (0, toBytes_js_12.hexToBytes)(bytesOrHex) : bytesOrHex;
    const sizeOfBytesLength = getSizeOfLength(bytes2.length);
    const length2 = (() => {
      if (bytes2.length === 1 && bytes2[0] < 128)
        return 1;
      if (bytes2.length <= 55)
        return 1 + bytes2.length;
      return 1 + sizeOfBytesLength + bytes2.length;
    })();
    return {
      length: length2,
      encode(cursor2) {
        if (bytes2.length === 1 && bytes2[0] < 128) {
          cursor2.pushBytes(bytes2);
        } else if (bytes2.length <= 55) {
          cursor2.pushByte(128 + bytes2.length);
          cursor2.pushBytes(bytes2);
        } else {
          cursor2.pushByte(128 + 55 + sizeOfBytesLength);
          if (sizeOfBytesLength === 1)
            cursor2.pushUint8(bytes2.length);
          else if (sizeOfBytesLength === 2)
            cursor2.pushUint16(bytes2.length);
          else if (sizeOfBytesLength === 3)
            cursor2.pushUint24(bytes2.length);
          else
            cursor2.pushUint32(bytes2.length);
          cursor2.pushBytes(bytes2);
        }
      }
    };
  }
  function getSizeOfLength(length2) {
    if (length2 < 2 ** 8)
      return 1;
    if (length2 < 2 ** 16)
      return 2;
    if (length2 < 2 ** 24)
      return 3;
    if (length2 < 2 ** 32)
      return 4;
    throw new index_js_1.BaseError("Length is too large.");
  }
  return toRlp;
}
var hasRequiredGetContractAddress;
function requireGetContractAddress() {
  if (hasRequiredGetContractAddress)
    return getContractAddress;
  hasRequiredGetContractAddress = 1;
  Object.defineProperty(getContractAddress, "__esModule", { value: true });
  getContractAddress.getCreate2Address = getContractAddress.getCreateAddress = getContractAddress.getContractAddress = void 0;
  const concat_js_12 = require$$80;
  const isBytes_js_1 = require$$100;
  const pad_js_12 = require$$106;
  const slice_js_12 = require$$114;
  const toBytes_js_12 = requireToBytes();
  const toRlp_js_1 = requireToRlp();
  const keccak256_js_12 = require$$103;
  const getAddress_js_12 = require$$91;
  function getContractAddress$12(opts) {
    if (opts.opcode === "CREATE2")
      return getCreate2Address(opts);
    return getCreateAddress(opts);
  }
  getContractAddress.getContractAddress = getContractAddress$12;
  function getCreateAddress(opts) {
    const from2 = (0, toBytes_js_12.toBytes)((0, getAddress_js_12.getAddress)(opts.from));
    let nonce = (0, toBytes_js_12.toBytes)(opts.nonce);
    if (nonce[0] === 0)
      nonce = new Uint8Array([]);
    return (0, getAddress_js_12.getAddress)(`0x${(0, keccak256_js_12.keccak256)((0, toRlp_js_1.toRlp)([from2, nonce], "bytes")).slice(26)}`);
  }
  getContractAddress.getCreateAddress = getCreateAddress;
  function getCreate2Address(opts) {
    const from2 = (0, toBytes_js_12.toBytes)((0, getAddress_js_12.getAddress)(opts.from));
    const salt = (0, pad_js_12.pad)((0, isBytes_js_1.isBytes)(opts.salt) ? opts.salt : (0, toBytes_js_12.toBytes)(opts.salt), {
      size: 32
    });
    const bytecodeHash = (() => {
      if ("bytecodeHash" in opts) {
        if ((0, isBytes_js_1.isBytes)(opts.bytecodeHash))
          return opts.bytecodeHash;
        return (0, toBytes_js_12.toBytes)(opts.bytecodeHash);
      }
      return (0, keccak256_js_12.keccak256)(opts.bytecode, "bytes");
    })();
    return (0, getAddress_js_12.getAddress)((0, slice_js_12.slice)((0, keccak256_js_12.keccak256)((0, concat_js_12.concat)([(0, toBytes_js_12.toBytes)("0xff"), from2, salt, bytecodeHash])), 12));
  }
  getContractAddress.getCreate2Address = getCreate2Address;
  return getContractAddress;
}
var extractFunctionParts$2 = {};
Object.defineProperty(extractFunctionParts$2, "__esModule", { value: true });
var extractFunctionType_1 = extractFunctionParts$2.extractFunctionType = extractFunctionParams_1 = extractFunctionParts$2.extractFunctionParams = extractFunctionName_1 = extractFunctionParts$2.extractFunctionName = extractFunctionParts_2 = extractFunctionParts$2.extractFunctionParts = void 0;
const paramsRegex = /((function|event)\s)?(.*)(\((.*)\))/;
function extractFunctionParts(def) {
  const parts = def.match(paramsRegex);
  const type = parts?.[2] || void 0;
  const name2 = parts?.[3];
  const params = parts?.[5] || void 0;
  return { type, name: name2, params };
}
var extractFunctionParts_2 = extractFunctionParts$2.extractFunctionParts = extractFunctionParts;
function extractFunctionName(def) {
  return extractFunctionParts(def).name;
}
var extractFunctionName_1 = extractFunctionParts$2.extractFunctionName = extractFunctionName;
function extractFunctionParams(def) {
  const params = extractFunctionParts(def).params;
  const splitParams = params?.split(",").map((x2) => x2.trim().split(" "));
  return splitParams?.map((param) => ({
    type: param[0],
    name: param[1] === "indexed" ? param[2] : param[1],
    ...param[1] === "indexed" ? { indexed: true } : {}
  }));
}
var extractFunctionParams_1 = extractFunctionParts$2.extractFunctionParams = extractFunctionParams;
function extractFunctionType(def) {
  return extractFunctionParts(def).type;
}
extractFunctionType_1 = extractFunctionParts$2.extractFunctionType = extractFunctionType;
const extractFunctionParts$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: extractFunctionParts$2,
  get extractFunctionName() {
    return extractFunctionName_1;
  },
  get extractFunctionParams() {
    return extractFunctionParams_1;
  },
  get extractFunctionParts() {
    return extractFunctionParts_2;
  },
  get extractFunctionType() {
    return extractFunctionType_1;
  }
}, [extractFunctionParts$2]);
const require$$32$1 = /* @__PURE__ */ getAugmentedNamespace(extractFunctionParts$1);
var transactionReceipt$1 = {};
Object.defineProperty(transactionReceipt$1, "__esModule", { value: true });
var defineTransactionReceipt = transactionReceipt$1.defineTransactionReceipt = formatTransactionReceipt_1 = transactionReceipt$1.formatTransactionReceipt = void 0;
const fromHex_js_1$8 = requireFromHex();
const formatter_js_1 = require$$57;
const log_js_1 = require$$40$1;
const transaction_js_1$6 = require$$53$1;
const statuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt2) {
  return {
    ...transactionReceipt2,
    blockNumber: transactionReceipt2.blockNumber ? BigInt(transactionReceipt2.blockNumber) : null,
    contractAddress: transactionReceipt2.contractAddress ? transactionReceipt2.contractAddress : null,
    cumulativeGasUsed: transactionReceipt2.cumulativeGasUsed ? BigInt(transactionReceipt2.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt2.effectiveGasPrice ? BigInt(transactionReceipt2.effectiveGasPrice) : null,
    gasUsed: transactionReceipt2.gasUsed ? BigInt(transactionReceipt2.gasUsed) : null,
    logs: transactionReceipt2.logs ? transactionReceipt2.logs.map((log3) => (0, log_js_1.formatLog)(log3)) : null,
    to: transactionReceipt2.to ? transactionReceipt2.to : null,
    transactionIndex: transactionReceipt2.transactionIndex ? (0, fromHex_js_1$8.hexToNumber)(transactionReceipt2.transactionIndex) : null,
    status: transactionReceipt2.status ? statuses[transactionReceipt2.status] : null,
    type: transactionReceipt2.type ? transaction_js_1$6.transactionType[transactionReceipt2.type] || transactionReceipt2.type : null
  };
}
var formatTransactionReceipt_1 = transactionReceipt$1.formatTransactionReceipt = formatTransactionReceipt;
defineTransactionReceipt = transactionReceipt$1.defineTransactionReceipt = (0, formatter_js_1.defineFormatter)("transactionReceipt", formatTransactionReceipt);
const transactionReceipt = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: transactionReceipt$1,
  get defineTransactionReceipt() {
    return defineTransactionReceipt;
  },
  get formatTransactionReceipt() {
    return formatTransactionReceipt_1;
  }
}, [transactionReceipt$1]);
const require$$54 = /* @__PURE__ */ getAugmentedNamespace(transactionReceipt);
var fromBytes$2 = {};
Object.defineProperty(fromBytes$2, "__esModule", { value: true });
var bytesToString_1 = fromBytes$2.bytesToString = bytesToNumber_1 = fromBytes$2.bytesToNumber = bytesToBool_1 = fromBytes$2.bytesToBool = bytesToBigInt_1 = fromBytes$2.bytesToBigInt = fromBytes_2 = fromBytes$2.fromBytes = void 0;
const encoding_js_1$1 = require$$27$3;
const trim_js_1$1 = require$$116;
const fromHex_js_1$7 = requireFromHex();
const toHex_js_1$m = requireToHex();
function fromBytes(bytes2, toOrOpts) {
  const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
  const to = opts.to;
  if (to === "number")
    return bytesToNumber(bytes2, opts);
  if (to === "bigint")
    return bytesToBigInt(bytes2, opts);
  if (to === "boolean")
    return bytesToBool(bytes2, opts);
  if (to === "string")
    return bytesToString(bytes2, opts);
  return (0, toHex_js_1$m.bytesToHex)(bytes2, opts);
}
var fromBytes_2 = fromBytes$2.fromBytes = fromBytes;
function bytesToBigInt(bytes2, opts = {}) {
  if (typeof opts.size !== "undefined")
    (0, fromHex_js_1$7.assertSize)(bytes2, { size: opts.size });
  const hex2 = (0, toHex_js_1$m.bytesToHex)(bytes2, opts);
  return (0, fromHex_js_1$7.hexToBigInt)(hex2);
}
var bytesToBigInt_1 = fromBytes$2.bytesToBigInt = bytesToBigInt;
function bytesToBool(bytes_, opts = {}) {
  let bytes2 = bytes_;
  if (typeof opts.size !== "undefined") {
    (0, fromHex_js_1$7.assertSize)(bytes2, { size: opts.size });
    bytes2 = (0, trim_js_1$1.trim)(bytes2);
  }
  if (bytes2.length > 1 || bytes2[0] > 1)
    throw new encoding_js_1$1.InvalidBytesBooleanError(bytes2);
  return Boolean(bytes2[0]);
}
var bytesToBool_1 = fromBytes$2.bytesToBool = bytesToBool;
function bytesToNumber(bytes2, opts = {}) {
  if (typeof opts.size !== "undefined")
    (0, fromHex_js_1$7.assertSize)(bytes2, { size: opts.size });
  const hex2 = (0, toHex_js_1$m.bytesToHex)(bytes2, opts);
  return (0, fromHex_js_1$7.hexToNumber)(hex2);
}
var bytesToNumber_1 = fromBytes$2.bytesToNumber = bytesToNumber;
function bytesToString(bytes_, opts = {}) {
  let bytes2 = bytes_;
  if (typeof opts.size !== "undefined") {
    (0, fromHex_js_1$7.assertSize)(bytes2, { size: opts.size });
    bytes2 = (0, trim_js_1$1.trim)(bytes2, { dir: "right" });
  }
  return new TextDecoder().decode(bytes2);
}
bytesToString_1 = fromBytes$2.bytesToString = bytesToString;
const fromBytes$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get bytesToBigInt() {
    return bytesToBigInt_1;
  },
  get bytesToBool() {
    return bytesToBool_1;
  },
  get bytesToNumber() {
    return bytesToNumber_1;
  },
  get bytesToString() {
    return bytesToString_1;
  },
  default: fromBytes$2,
  get fromBytes() {
    return fromBytes_2;
  }
}, [fromBytes$2]);
const require$$78 = /* @__PURE__ */ getAugmentedNamespace(fromBytes$1);
var fromRlp$2 = {};
Object.defineProperty(fromRlp$2, "__esModule", { value: true });
var rlpToHex_1 = fromRlp$2.rlpToHex = rlpToBytes_1 = fromRlp$2.rlpToBytes = fromRlp_2 = fromRlp$2.fromRlp = void 0;
const base_js_1$2 = require$$21$2;
const encoding_js_1 = require$$27$3;
const cursor_js_1 = require$$2$8;
const toBytes_js_1$5 = requireToBytes();
const toHex_js_1$l = requireToHex();
function fromRlp(value, to = "hex") {
  const bytes2 = (() => {
    if (typeof value === "string") {
      if (value.length > 3 && value.length % 2 !== 0)
        throw new encoding_js_1.InvalidHexValueError(value);
      return (0, toBytes_js_1$5.hexToBytes)(value);
    }
    return value;
  })();
  const cursor2 = (0, cursor_js_1.createCursor)(bytes2);
  const result = fromRlpCursor(cursor2, to);
  return result;
}
var fromRlp_2 = fromRlp$2.fromRlp = fromRlp;
function rlpToBytes(bytes2, to = "bytes") {
  return fromRlp(bytes2, to);
}
var rlpToBytes_1 = fromRlp$2.rlpToBytes = rlpToBytes;
function rlpToHex(hex2, to = "hex") {
  return fromRlp(hex2, to);
}
rlpToHex_1 = fromRlp$2.rlpToHex = rlpToHex;
function fromRlpCursor(cursor2, to = "hex") {
  if (cursor2.bytes.length === 0)
    return to === "hex" ? (0, toHex_js_1$l.bytesToHex)(cursor2.bytes) : cursor2.bytes;
  const prefix = cursor2.readByte();
  if (prefix < 128)
    cursor2.decrementPosition(1);
  if (prefix < 192) {
    const length3 = readLength(cursor2, prefix, 128);
    const bytes2 = cursor2.readBytes(length3);
    return to === "hex" ? (0, toHex_js_1$l.bytesToHex)(bytes2) : bytes2;
  }
  const length2 = readLength(cursor2, prefix, 192);
  return readList(cursor2, length2, to);
}
function readLength(cursor2, prefix, offset) {
  if (offset === 128 && prefix < 128)
    return 1;
  if (prefix <= offset + 55)
    return prefix - offset;
  if (prefix === offset + 55 + 1)
    return cursor2.readUint8();
  if (prefix === offset + 55 + 2)
    return cursor2.readUint16();
  if (prefix === offset + 55 + 3)
    return cursor2.readUint24();
  if (prefix === offset + 55 + 4)
    return cursor2.readUint32();
  throw new base_js_1$2.BaseError("Invalid RLP prefix");
}
function readList(cursor2, length2, to) {
  const position = cursor2.position;
  const value = [];
  while (cursor2.position - position < length2)
    value.push(fromRlpCursor(cursor2, to));
  return value;
}
const fromRlp$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: fromRlp$2,
  get fromRlp() {
    return fromRlp_2;
  },
  get rlpToBytes() {
    return rlpToBytes_1;
  },
  get rlpToHex() {
    return rlpToHex_1;
  }
}, [fromRlp$2]);
const require$$90 = /* @__PURE__ */ getAugmentedNamespace(fromRlp$1);
var isHash$2 = {};
Object.defineProperty(isHash$2, "__esModule", { value: true });
var isHash_2 = isHash$2.isHash = void 0;
const isHex_js_1$6 = require$$102;
const size_js_1 = require$$113;
function isHash(hash2) {
  return (0, isHex_js_1$6.isHex)(hash2) && (0, size_js_1.size)(hash2) === 32;
}
isHash_2 = isHash$2.isHash = isHash;
const isHash$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: isHash$2,
  get isHash() {
    return isHash_2;
  }
}, [isHash$2]);
const require$$101 = /* @__PURE__ */ getAugmentedNamespace(isHash$1);
var sha256$4 = {};
var sha256$3 = {};
var _sha2$1 = {};
Object.defineProperty(_sha2$1, "__esModule", { value: true });
var SHA2_1 = _sha2$1.SHA2 = void 0;
const _assert_js_1 = require$$0$P;
const utils_js_1$2 = require$$1$p;
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n2 & _u32_max);
  const wl2 = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl2, isLE2);
}
class SHA2 extends utils_js_1$2.Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = (0, utils_js_1$2.createView)(this.buffer);
  }
  update(data2) {
    (0, _assert_js_1.exists)(this);
    const { view, buffer: buffer2, blockLen } = this;
    data2 = (0, utils_js_1$2.toBytes)(data2);
    const len2 = data2.length;
    for (let pos = 0; pos < len2; ) {
      const take2 = Math.min(blockLen - this.pos, len2 - pos);
      if (take2 === blockLen) {
        const dataView2 = (0, utils_js_1$2.createView)(data2);
        for (; blockLen <= len2 - pos; pos += blockLen)
          this.process(dataView2, pos);
        continue;
      }
      buffer2.set(data2.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data2.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    (0, _assert_js_1.exists)(this);
    (0, _assert_js_1.output)(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer2[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = (0, utils_js_1$2.createView)(out);
    const len2 = this.outputLen;
    if (len2 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len2 / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length2, finished, destroyed, pos } = this;
    to.length = length2;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length2 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
}
SHA2_1 = _sha2$1.SHA2 = SHA2;
const _sha2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get SHA2() {
    return SHA2_1;
  },
  default: _sha2$1
}, [_sha2$1]);
const require$$0$z = /* @__PURE__ */ getAugmentedNamespace(_sha2);
Object.defineProperty(sha256$3, "__esModule", { value: true });
var sha224 = sha256$3.sha224 = sha256_1$1 = sha256$3.sha256 = void 0;
const _sha2_js_1$1 = require$$0$z;
const utils_js_1$1 = require$$1$p;
const Chi = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
const Maj = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _sha2_js_1$1.SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = (0, utils_js_1$1.rotr)(W15, 7) ^ (0, utils_js_1$1.rotr)(W15, 18) ^ W15 >>> 3;
      const s1 = (0, utils_js_1$1.rotr)(W2, 17) ^ (0, utils_js_1$1.rotr)(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = (0, utils_js_1$1.rotr)(E2, 6) ^ (0, utils_js_1$1.rotr)(E2, 11) ^ (0, utils_js_1$1.rotr)(E2, 25);
      const T1 = H2 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = (0, utils_js_1$1.rotr)(A2, 2) ^ (0, utils_js_1$1.rotr)(A2, 13) ^ (0, utils_js_1$1.rotr)(A2, 22);
      const T2 = sigma0 + Maj(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
}
var sha256_1$1 = sha256$3.sha256 = (0, utils_js_1$1.wrapConstructor)(() => new SHA256());
sha224 = sha256$3.sha224 = (0, utils_js_1$1.wrapConstructor)(() => new SHA224());
const sha256$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sha256$3,
  get sha224() {
    return sha224;
  },
  get sha256() {
    return sha256_1$1;
  }
}, [sha256$3]);
const require$$0$y = /* @__PURE__ */ getAugmentedNamespace(sha256$2);
Object.defineProperty(sha256$4, "__esModule", { value: true });
var sha256_3 = sha256$4.sha256 = void 0;
const sha256_1 = require$$0$y;
const isHex_js_1$5 = require$$102;
const toBytes_js_1$4 = requireToBytes();
const toHex_js_1$k = requireToHex();
function sha256(value, to_) {
  const to = to_ || "hex";
  const bytes2 = (0, sha256_1.sha256)((0, isHex_js_1$5.isHex)(value, { strict: false }) ? (0, toBytes_js_1$4.toBytes)(value) : value);
  if (to === "bytes")
    return bytes2;
  return (0, toHex_js_1$k.toHex)(bytes2);
}
sha256_3 = sha256$4.sha256 = sha256;
const sha256$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sha256$4,
  get sha256() {
    return sha256_3;
  }
}, [sha256$4]);
const require$$104 = /* @__PURE__ */ getAugmentedNamespace(sha256$1);
var ripemd160$4 = {};
var ripemd160$3 = {};
Object.defineProperty(ripemd160$3, "__esModule", { value: true });
var ripemd160_1$1 = ripemd160$3.ripemd160 = RIPEMD160_1 = ripemd160$3.RIPEMD160 = void 0;
const _sha2_js_1 = require$$0$z;
const utils_js_1 = require$$1$p;
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_2, i2) => i2);
const Pi = /* @__PURE__ */ Id.map((i2) => (9 * i2 + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i2 = 0; i2 < 4; i2++)
  for (let j2 of [idxL, idxR])
    j2.push(j2[i2].map((k2) => Rho[k2]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => new Uint8Array(i2));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i2) => idx.map((j2) => shifts[i2][j2]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i2) => idx.map((j2) => shifts[i2][j2]));
const Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
const Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
const rotl = (word, shift) => word << shift | word >>> 32 - shift;
function f$3(group, x2, y2, z2) {
  if (group === 0)
    return x2 ^ y2 ^ z2;
  else if (group === 1)
    return x2 & y2 | ~x2 & z2;
  else if (group === 2)
    return (x2 | ~y2) ^ z2;
  else if (group === 3)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _sha2_js_1.SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      BUF[i2] = view.getUint32(offset, true);
    let al2 = this.h0 | 0, ar = al2, bl2 = this.h1 | 0, br = bl2, cl2 = this.h2 | 0, cr = cl2, dl2 = this.h3 | 0, dr = dl2, el2 = this.h4 | 0, er = el2;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl2 = idxL[group], rr = idxR[group];
      const sl2 = shiftsL[group], sr = shiftsR[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl2 = rotl(al2 + f$3(group, bl2, cl2, dl2) + BUF[rl2[i2]] + hbl, sl2[i2]) + el2 | 0;
        al2 = el2, el2 = dl2, dl2 = rotl(cl2, 10) | 0, cl2 = bl2, bl2 = tl2;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr = rotl(ar + f$3(rGroup, br, cr, dr) + BUF[rr[i2]] + hbr, sr[i2]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl2 + dr | 0, this.h2 + dl2 + er | 0, this.h3 + el2 + ar | 0, this.h4 + al2 + br | 0, this.h0 + bl2 + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
}
var RIPEMD160_1 = ripemd160$3.RIPEMD160 = RIPEMD160;
ripemd160_1$1 = ripemd160$3.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
const ripemd160$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get RIPEMD160() {
    return RIPEMD160_1;
  },
  default: ripemd160$3,
  get ripemd160() {
    return ripemd160_1$1;
  }
}, [ripemd160$3]);
const require$$0$x = /* @__PURE__ */ getAugmentedNamespace(ripemd160$2);
Object.defineProperty(ripemd160$4, "__esModule", { value: true });
var ripemd160_3 = ripemd160$4.ripemd160 = void 0;
const ripemd160_1 = require$$0$x;
const isHex_js_1$4 = require$$102;
const toBytes_js_1$3 = requireToBytes();
const toHex_js_1$j = requireToHex();
function ripemd160(value, to_) {
  const to = to_ || "hex";
  const bytes2 = (0, ripemd160_1.ripemd160)((0, isHex_js_1$4.isHex)(value, { strict: false }) ? (0, toBytes_js_1$3.toBytes)(value) : value);
  if (to === "bytes")
    return bytes2;
  return (0, toHex_js_1$j.toHex)(bytes2);
}
ripemd160_3 = ripemd160$4.ripemd160 = ripemd160;
const ripemd160$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ripemd160$4,
  get ripemd160() {
    return ripemd160_3;
  }
}, [ripemd160$4]);
const require$$105 = /* @__PURE__ */ getAugmentedNamespace(ripemd160$1);
var recoverAddress$2 = {};
var recoverPublicKey$2 = {};
const require$$0$w = /* @__PURE__ */ getAugmentedNamespace(secp256k1$1);
Object.defineProperty(recoverPublicKey$2, "__esModule", { value: true });
var recoverPublicKey_2 = recoverPublicKey$2.recoverPublicKey = void 0;
const isHex_js_1$3 = require$$102;
const fromHex_js_1$6 = requireFromHex();
const toHex_js_1$i = requireToHex();
async function recoverPublicKey({ hash: hash2, signature: signature2 }) {
  const signatureHex = (0, isHex_js_1$3.isHex)(signature2) ? signature2 : (0, toHex_js_1$i.toHex)(signature2);
  const hashHex = (0, isHex_js_1$3.isHex)(hash2) ? hash2 : (0, toHex_js_1$i.toHex)(hash2);
  let v2 = (0, fromHex_js_1$6.hexToNumber)(`0x${signatureHex.slice(130)}`);
  if (v2 === 0 || v2 === 1)
    v2 += 27;
  const { secp256k1: secp256k12 } = await Promise.resolve().then(() => require$$0$w);
  const publicKey = secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(v2 - 27).recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
recoverPublicKey_2 = recoverPublicKey$2.recoverPublicKey = recoverPublicKey;
const recoverPublicKey$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: recoverPublicKey$2,
  get recoverPublicKey() {
    return recoverPublicKey_2;
  }
}, [recoverPublicKey$2]);
const require$$66 = /* @__PURE__ */ getAugmentedNamespace(recoverPublicKey$1);
Object.defineProperty(recoverAddress$2, "__esModule", { value: true });
var recoverAddress_2 = recoverAddress$2.recoverAddress = void 0;
const publicKeyToAddress_js_1 = require$$27$2;
const recoverPublicKey_js_1 = require$$66;
async function recoverAddress({ hash: hash2, signature: signature2 }) {
  return (0, publicKeyToAddress_js_1.publicKeyToAddress)(await (0, recoverPublicKey_js_1.recoverPublicKey)({ hash: hash2, signature: signature2 }));
}
recoverAddress_2 = recoverAddress$2.recoverAddress = recoverAddress;
const recoverAddress$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: recoverAddress$2,
  get recoverAddress() {
    return recoverAddress_2;
  }
}, [recoverAddress$2]);
const require$$64 = /* @__PURE__ */ getAugmentedNamespace(recoverAddress$1);
var recoverMessageAddress$2 = {};
var hashMessage$2 = {};
var strings$1 = {};
Object.defineProperty(strings$1, "__esModule", { value: true });
var presignMessagePrefix = strings$1.presignMessagePrefix = void 0;
presignMessagePrefix = strings$1.presignMessagePrefix = "Ethereum Signed Message:\n";
const strings = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: strings$1,
  get presignMessagePrefix() {
    return presignMessagePrefix;
  }
}, [strings$1]);
const require$$19$1 = /* @__PURE__ */ getAugmentedNamespace(strings);
Object.defineProperty(hashMessage$2, "__esModule", { value: true });
var hashMessage_2 = hashMessage$2.hashMessage = void 0;
const strings_js_1 = require$$19$1;
const concat_js_1 = require$$80;
const toBytes_js_1$2 = requireToBytes();
const keccak256_js_1 = require$$103;
function hashMessage(message, to_) {
  const messageBytes = (() => {
    if (typeof message === "string")
      return (0, toBytes_js_1$2.stringToBytes)(message);
    if (message.raw instanceof Uint8Array)
      return message.raw;
    return (0, toBytes_js_1$2.toBytes)(message.raw);
  })();
  const prefixBytes = (0, toBytes_js_1$2.stringToBytes)(`${strings_js_1.presignMessagePrefix}${messageBytes.length}`);
  return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([prefixBytes, messageBytes]), to_);
}
hashMessage_2 = hashMessage$2.hashMessage = hashMessage;
const hashMessage$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: hashMessage$2,
  get hashMessage() {
    return hashMessage_2;
  }
}, [hashMessage$2]);
const require$$97 = /* @__PURE__ */ getAugmentedNamespace(hashMessage$1);
Object.defineProperty(recoverMessageAddress$2, "__esModule", { value: true });
var recoverMessageAddress_2 = recoverMessageAddress$2.recoverMessageAddress = void 0;
const hashMessage_js_1 = require$$97;
const recoverAddress_js_1$1 = require$$64;
async function recoverMessageAddress({ message, signature: signature2 }) {
  return (0, recoverAddress_js_1$1.recoverAddress)({ hash: (0, hashMessage_js_1.hashMessage)(message), signature: signature2 });
}
recoverMessageAddress_2 = recoverMessageAddress$2.recoverMessageAddress = recoverMessageAddress;
const recoverMessageAddress$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: recoverMessageAddress$2,
  get recoverMessageAddress() {
    return recoverMessageAddress_2;
  }
}, [recoverMessageAddress$2]);
const require$$65 = /* @__PURE__ */ getAugmentedNamespace(recoverMessageAddress$1);
var recoverTypedDataAddress$2 = {};
Object.defineProperty(recoverTypedDataAddress$2, "__esModule", { value: true });
var recoverTypedDataAddress_2 = recoverTypedDataAddress$2.recoverTypedDataAddress = void 0;
const hashTypedData_js_1 = requireHashTypedData();
const recoverAddress_js_1 = require$$64;
async function recoverTypedDataAddress({ domain, message, primaryType, signature: signature2, types: types2 }) {
  return (0, recoverAddress_js_1.recoverAddress)({
    hash: (0, hashTypedData_js_1.hashTypedData)({
      domain,
      message,
      primaryType,
      types: types2
    }),
    signature: signature2
  });
}
recoverTypedDataAddress_2 = recoverTypedDataAddress$2.recoverTypedDataAddress = recoverTypedDataAddress;
const recoverTypedDataAddress$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: recoverTypedDataAddress$2,
  get recoverTypedDataAddress() {
    return recoverTypedDataAddress_2;
  }
}, [recoverTypedDataAddress$2]);
const require$$67 = /* @__PURE__ */ getAugmentedNamespace(recoverTypedDataAddress$1);
var verifyMessage$3 = {};
Object.defineProperty(verifyMessage$3, "__esModule", { value: true });
var verifyMessage_2 = verifyMessage$3.verifyMessage = void 0;
const getAddress_js_1$3 = require$$91;
const isAddressEqual_js_1$1 = require$$99;
const recoverMessageAddress_js_1 = require$$65;
async function verifyMessage$1({ address: address2, message, signature: signature2 }) {
  return (0, isAddressEqual_js_1$1.isAddressEqual)((0, getAddress_js_1$3.getAddress)(address2), await (0, recoverMessageAddress_js_1.recoverMessageAddress)({ message, signature: signature2 }));
}
verifyMessage_2 = verifyMessage$3.verifyMessage = verifyMessage$1;
const verifyMessage$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: verifyMessage$3,
  get verifyMessage() {
    return verifyMessage_2;
  }
}, [verifyMessage$3]);
const require$$72 = /* @__PURE__ */ getAugmentedNamespace(verifyMessage$2);
var verifyTypedData$3 = {};
Object.defineProperty(verifyTypedData$3, "__esModule", { value: true });
var verifyTypedData_2 = verifyTypedData$3.verifyTypedData = void 0;
const getAddress_js_1$2 = require$$91;
const isAddressEqual_js_1 = require$$99;
const recoverTypedDataAddress_js_1 = require$$67;
async function verifyTypedData$1({ address: address2, domain, message, primaryType, signature: signature2, types: types2 }) {
  return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1$2.getAddress)(address2), await (0, recoverTypedDataAddress_js_1.recoverTypedDataAddress)({
    domain,
    message,
    primaryType,
    signature: signature2,
    types: types2
  }));
}
verifyTypedData_2 = verifyTypedData$3.verifyTypedData = verifyTypedData$1;
const verifyTypedData$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: verifyTypedData$3,
  get verifyTypedData() {
    return verifyTypedData_2;
  }
}, [verifyTypedData$3]);
const require$$73 = /* @__PURE__ */ getAugmentedNamespace(verifyTypedData$2);
var getSerializedTransactionType$2 = {};
Object.defineProperty(getSerializedTransactionType$2, "__esModule", { value: true });
var getSerializedTransactionType_2 = getSerializedTransactionType$2.getSerializedTransactionType = void 0;
const transaction_js_1$5 = require$$34$1;
const slice_js_1 = require$$114;
const fromHex_js_1$5 = requireFromHex();
function getSerializedTransactionType(serializedTransaction) {
  const serializedType = (0, slice_js_1.sliceHex)(serializedTransaction, 0, 1);
  if (serializedType === "0x02")
    return "eip1559";
  if (serializedType === "0x01")
    return "eip2930";
  if (serializedType !== "0x" && (0, fromHex_js_1$5.hexToNumber)(serializedType) >= 192)
    return "legacy";
  throw new transaction_js_1$5.InvalidSerializedTransactionTypeError({ serializedType });
}
getSerializedTransactionType_2 = getSerializedTransactionType$2.getSerializedTransactionType = getSerializedTransactionType;
const getSerializedTransactionType$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getSerializedTransactionType$2,
  get getSerializedTransactionType() {
    return getSerializedTransactionType_2;
  }
}, [getSerializedTransactionType$2]);
const require$$58 = /* @__PURE__ */ getAugmentedNamespace(getSerializedTransactionType$1);
var assertTransaction$1 = {};
Object.defineProperty(assertTransaction$1, "__esModule", { value: true });
var assertTransactionLegacy_1 = assertTransaction$1.assertTransactionLegacy = assertTransactionEIP2930_1 = assertTransaction$1.assertTransactionEIP2930 = assertTransactionEIP1559_1 = assertTransaction$1.assertTransactionEIP1559 = void 0;
const address_js_1$2 = require$$33$1;
const base_js_1$1 = require$$21$2;
const chain_js_1 = require$$26$1;
const node_js_1 = require$$30$1;
const isAddress_js_1$2 = require$$98;
function assertTransactionEIP1559(transaction2) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction2;
  if (chainId <= 0)
    throw new chain_js_1.InvalidChainIdError({ chainId });
  if (to && !(0, isAddress_js_1$2.isAddress)(to))
    throw new address_js_1$2.InvalidAddressError({ address: to });
  if (gasPrice)
    throw new base_js_1$1.BaseError("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
    throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
var assertTransactionEIP1559_1 = assertTransaction$1.assertTransactionEIP1559 = assertTransactionEIP1559;
function assertTransactionEIP2930(transaction2) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction2;
  if (chainId <= 0)
    throw new chain_js_1.InvalidChainIdError({ chainId });
  if (to && !(0, isAddress_js_1$2.isAddress)(to))
    throw new address_js_1$2.InvalidAddressError({ address: to });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new base_js_1$1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (gasPrice && gasPrice > 2n ** 256n - 1n)
    throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
}
var assertTransactionEIP2930_1 = assertTransaction$1.assertTransactionEIP2930 = assertTransactionEIP2930;
function assertTransactionLegacy(transaction2) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList } = transaction2;
  if (to && !(0, isAddress_js_1$2.isAddress)(to))
    throw new address_js_1$2.InvalidAddressError({ address: to });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new chain_js_1.InvalidChainIdError({ chainId });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new base_js_1$1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (gasPrice && gasPrice > 2n ** 256n - 1n)
    throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
  if (accessList)
    throw new base_js_1$1.BaseError("`accessList` is not a valid Legacy Transaction attribute.");
}
assertTransactionLegacy_1 = assertTransaction$1.assertTransactionLegacy = assertTransactionLegacy;
const assertTransaction = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get assertTransactionEIP1559() {
    return assertTransactionEIP1559_1;
  },
  get assertTransactionEIP2930() {
    return assertTransactionEIP2930_1;
  },
  get assertTransactionLegacy() {
    return assertTransactionLegacy_1;
  },
  default: assertTransaction$1
}, [assertTransaction$1]);
const require$$75 = /* @__PURE__ */ getAugmentedNamespace(assertTransaction);
var parseTransaction$2 = {};
Object.defineProperty(parseTransaction$2, "__esModule", { value: true });
var parseAccessList_1 = parseTransaction$2.parseAccessList = toTransactionArray_1 = parseTransaction$2.toTransactionArray = parseTransaction_2 = parseTransaction$2.parseTransaction = void 0;
const address_js_1$1 = require$$33$1;
const transaction_js_1$4 = require$$34$1;
const isAddress_js_1$1 = require$$98;
const isHex_js_1$2 = require$$102;
const pad_js_1 = require$$106;
const trim_js_1 = require$$116;
const fromHex_js_1$4 = requireFromHex();
const fromRlp_js_1 = require$$90;
const isHash_js_1 = require$$101;
const assertTransaction_js_1 = require$$75;
const getSerializedTransactionType_js_1 = require$$58;
function parseTransaction(serializedTransaction) {
  const type = (0, getSerializedTransactionType_js_1.getSerializedTransactionType)(serializedTransaction);
  if (type === "eip1559")
    return parseTransactionEIP1559(serializedTransaction);
  if (type === "eip2930")
    return parseTransactionEIP2930(serializedTransaction);
  return parseTransactionLegacy(serializedTransaction);
}
var parseTransaction_2 = parseTransaction$2.parseTransaction = parseTransaction;
function parseTransactionEIP1559(serializedTransaction) {
  const transactionArray = toTransactionArray(serializedTransaction);
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data2, accessList, v2, r2, s] = transactionArray;
  if (!(transactionArray.length === 9 || transactionArray.length === 12))
    throw new transaction_js_1$4.InvalidSerializedTransactionError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to,
        value,
        data: data2,
        accessList,
        ...transactionArray.length > 9 ? {
          v: v2,
          r: r2,
          s
        } : {}
      },
      serializedTransaction,
      type: "eip1559"
    });
  const transaction2 = {
    chainId: (0, fromHex_js_1$4.hexToNumber)(chainId),
    type: "eip1559"
  };
  if ((0, isHex_js_1$2.isHex)(to) && to !== "0x")
    transaction2.to = to;
  if ((0, isHex_js_1$2.isHex)(gas) && gas !== "0x")
    transaction2.gas = (0, fromHex_js_1$4.hexToBigInt)(gas);
  if ((0, isHex_js_1$2.isHex)(data2) && data2 !== "0x")
    transaction2.data = data2;
  if ((0, isHex_js_1$2.isHex)(nonce) && nonce !== "0x")
    transaction2.nonce = (0, fromHex_js_1$4.hexToNumber)(nonce);
  if ((0, isHex_js_1$2.isHex)(value) && value !== "0x")
    transaction2.value = (0, fromHex_js_1$4.hexToBigInt)(value);
  if ((0, isHex_js_1$2.isHex)(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction2.maxFeePerGas = (0, fromHex_js_1$4.hexToBigInt)(maxFeePerGas);
  if ((0, isHex_js_1$2.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction2.maxPriorityFeePerGas = (0, fromHex_js_1$4.hexToBigInt)(maxPriorityFeePerGas);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction2.accessList = parseAccessList(accessList);
  (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction2);
  const signature2 = transactionArray.length === 12 ? parseEIP155Signature(transactionArray) : void 0;
  return { ...signature2, ...transaction2 };
}
function parseTransactionEIP2930(serializedTransaction) {
  const transactionArray = toTransactionArray(serializedTransaction);
  const [chainId, nonce, gasPrice, gas, to, value, data2, accessList, v2, r2, s] = transactionArray;
  if (!(transactionArray.length === 8 || transactionArray.length === 11))
    throw new transaction_js_1$4.InvalidSerializedTransactionError({
      attributes: {
        chainId,
        nonce,
        gasPrice,
        gas,
        to,
        value,
        data: data2,
        accessList,
        ...transactionArray.length > 8 ? {
          v: v2,
          r: r2,
          s
        } : {}
      },
      serializedTransaction,
      type: "eip2930"
    });
  const transaction2 = {
    chainId: (0, fromHex_js_1$4.hexToNumber)(chainId),
    type: "eip2930"
  };
  if ((0, isHex_js_1$2.isHex)(to) && to !== "0x")
    transaction2.to = to;
  if ((0, isHex_js_1$2.isHex)(gas) && gas !== "0x")
    transaction2.gas = (0, fromHex_js_1$4.hexToBigInt)(gas);
  if ((0, isHex_js_1$2.isHex)(data2) && data2 !== "0x")
    transaction2.data = data2;
  if ((0, isHex_js_1$2.isHex)(nonce) && nonce !== "0x")
    transaction2.nonce = (0, fromHex_js_1$4.hexToNumber)(nonce);
  if ((0, isHex_js_1$2.isHex)(value) && value !== "0x")
    transaction2.value = (0, fromHex_js_1$4.hexToBigInt)(value);
  if ((0, isHex_js_1$2.isHex)(gasPrice) && gasPrice !== "0x")
    transaction2.gasPrice = (0, fromHex_js_1$4.hexToBigInt)(gasPrice);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction2.accessList = parseAccessList(accessList);
  (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction2);
  const signature2 = transactionArray.length === 11 ? parseEIP155Signature(transactionArray) : void 0;
  return { ...signature2, ...transaction2 };
}
function parseTransactionLegacy(serializedTransaction) {
  const transactionArray = (0, fromRlp_js_1.fromRlp)(serializedTransaction, "hex");
  const [nonce, gasPrice, gas, to, value, data2, chainIdOrV_, r2, s] = transactionArray;
  if (!(transactionArray.length === 6 || transactionArray.length === 9))
    throw new transaction_js_1$4.InvalidSerializedTransactionError({
      attributes: {
        nonce,
        gasPrice,
        gas,
        to,
        value,
        data: data2,
        ...transactionArray.length > 6 ? {
          v: chainIdOrV_,
          r: r2,
          s
        } : {}
      },
      serializedTransaction,
      type: "legacy"
    });
  const transaction2 = {
    type: "legacy"
  };
  if ((0, isHex_js_1$2.isHex)(to) && to !== "0x")
    transaction2.to = to;
  if ((0, isHex_js_1$2.isHex)(gas) && gas !== "0x")
    transaction2.gas = (0, fromHex_js_1$4.hexToBigInt)(gas);
  if ((0, isHex_js_1$2.isHex)(data2) && data2 !== "0x")
    transaction2.data = data2;
  if ((0, isHex_js_1$2.isHex)(nonce) && nonce !== "0x")
    transaction2.nonce = (0, fromHex_js_1$4.hexToNumber)(nonce);
  if ((0, isHex_js_1$2.isHex)(value) && value !== "0x")
    transaction2.value = (0, fromHex_js_1$4.hexToBigInt)(value);
  if ((0, isHex_js_1$2.isHex)(gasPrice) && gasPrice !== "0x")
    transaction2.gasPrice = (0, fromHex_js_1$4.hexToBigInt)(gasPrice);
  (0, assertTransaction_js_1.assertTransactionLegacy)(transaction2);
  if (transactionArray.length === 6)
    return transaction2;
  const chainIdOrV = (0, isHex_js_1$2.isHex)(chainIdOrV_) && chainIdOrV_ !== "0x" ? (0, fromHex_js_1$4.hexToBigInt)(chainIdOrV_) : 0n;
  if (s === "0x" && r2 === "0x") {
    if (chainIdOrV > 0)
      transaction2.chainId = Number(chainIdOrV);
    return transaction2;
  }
  const v2 = chainIdOrV;
  const chainId = Number((v2 - 35n) / 2n);
  if (chainId > 0)
    transaction2.chainId = chainId;
  else if (v2 !== 27n && v2 !== 28n)
    throw new transaction_js_1$4.InvalidLegacyVError({ v: v2 });
  transaction2.v = v2;
  transaction2.s = s;
  transaction2.r = r2;
  return transaction2;
}
function toTransactionArray(serializedTransaction) {
  return (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, "hex");
}
var toTransactionArray_1 = parseTransaction$2.toTransactionArray = toTransactionArray;
function parseAccessList(accessList_) {
  const accessList = [];
  for (let i2 = 0; i2 < accessList_.length; i2++) {
    const [address2, storageKeys] = accessList_[i2];
    if (!(0, isAddress_js_1$1.isAddress)(address2))
      throw new address_js_1$1.InvalidAddressError({ address: address2 });
    accessList.push({
      address: address2,
      storageKeys: storageKeys.map((key) => (0, isHash_js_1.isHash)(key) ? key : (0, trim_js_1.trim)(key))
    });
  }
  return accessList;
}
parseAccessList_1 = parseTransaction$2.parseAccessList = parseAccessList;
function parseEIP155Signature(transactionArray) {
  const signature2 = transactionArray.slice(-3);
  const v2 = signature2[0] === "0x" || (0, fromHex_js_1$4.hexToBigInt)(signature2[0]) === 0n ? 27n : 28n;
  return {
    r: (0, pad_js_1.padHex)(signature2[1], { size: 32 }),
    s: (0, pad_js_1.padHex)(signature2[2], { size: 32 }),
    v: v2,
    yParity: v2 === 27n ? 0 : 1
  };
}
const parseTransaction$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: parseTransaction$2,
  get parseAccessList() {
    return parseAccessList_1;
  },
  get parseTransaction() {
    return parseTransaction_2;
  },
  get toTransactionArray() {
    return toTransactionArray_1;
  }
}, [parseTransaction$2]);
const require$$109 = /* @__PURE__ */ getAugmentedNamespace(parseTransaction$1);
var serializeTransaction = {};
var serializeAccessList$2 = {};
Object.defineProperty(serializeAccessList$2, "__esModule", { value: true });
var serializeAccessList_2 = serializeAccessList$2.serializeAccessList = void 0;
const address_js_1 = require$$33$1;
const transaction_js_1$3 = require$$34$1;
const isAddress_js_1 = require$$98;
function serializeAccessList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const serializedAccessList = [];
  for (let i2 = 0; i2 < accessList.length; i2++) {
    const { address: address2, storageKeys } = accessList[i2];
    for (let j2 = 0; j2 < storageKeys.length; j2++) {
      if (storageKeys[j2].length - 2 !== 64) {
        throw new transaction_js_1$3.InvalidStorageKeySizeError({ storageKey: storageKeys[j2] });
      }
    }
    if (!(0, isAddress_js_1.isAddress)(address2)) {
      throw new address_js_1.InvalidAddressError({ address: address2 });
    }
    serializedAccessList.push([address2, storageKeys]);
  }
  return serializedAccessList;
}
serializeAccessList_2 = serializeAccessList$2.serializeAccessList = serializeAccessList;
const serializeAccessList$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: serializeAccessList$2,
  get serializeAccessList() {
    return serializeAccessList_2;
  }
}, [serializeAccessList$2]);
const require$$111 = /* @__PURE__ */ getAugmentedNamespace(serializeAccessList$1);
var hasRequiredSerializeTransaction;
function requireSerializeTransaction() {
  if (hasRequiredSerializeTransaction)
    return serializeTransaction;
  hasRequiredSerializeTransaction = 1;
  Object.defineProperty(serializeTransaction, "__esModule", { value: true });
  serializeTransaction.serializeTransaction = void 0;
  const transaction_js_12 = require$$34$1;
  const concat_js_12 = require$$80;
  const trim_js_12 = require$$116;
  const toHex_js_12 = requireToHex();
  const toRlp_js_1 = requireToRlp();
  const assertTransaction_js_12 = require$$75;
  const getTransactionType_js_1 = require$$59;
  const serializeAccessList_js_1 = require$$111;
  function serializeTransaction$1(transaction2, signature2) {
    const type = (0, getTransactionType_js_1.getTransactionType)(transaction2);
    if (type === "eip1559")
      return serializeTransactionEIP1559(transaction2, signature2);
    if (type === "eip2930")
      return serializeTransactionEIP2930(transaction2, signature2);
    return serializeTransactionLegacy(transaction2, signature2);
  }
  serializeTransaction.serializeTransaction = serializeTransaction$1;
  function serializeTransactionEIP1559(transaction2, signature2) {
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data: data2 } = transaction2;
    (0, assertTransaction_js_12.assertTransactionEIP1559)(transaction2);
    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
    const serializedTransaction = [
      (0, toHex_js_12.toHex)(chainId),
      nonce ? (0, toHex_js_12.toHex)(nonce) : "0x",
      maxPriorityFeePerGas ? (0, toHex_js_12.toHex)(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? (0, toHex_js_12.toHex)(maxFeePerGas) : "0x",
      gas ? (0, toHex_js_12.toHex)(gas) : "0x",
      to ?? "0x",
      value ? (0, toHex_js_12.toHex)(value) : "0x",
      data2 ?? "0x",
      serializedAccessList
    ];
    if (signature2) {
      const yParity = (() => {
        if (signature2.v === 0n)
          return "0x";
        if (signature2.v === 1n)
          return (0, toHex_js_12.toHex)(1);
        return signature2.v === 27n ? "0x" : (0, toHex_js_12.toHex)(1);
      })();
      serializedTransaction.push(yParity, (0, trim_js_12.trim)(signature2.r), (0, trim_js_12.trim)(signature2.s));
    }
    return (0, concat_js_12.concatHex)([
      "0x02",
      (0, toRlp_js_1.toRlp)(serializedTransaction)
    ]);
  }
  function serializeTransactionEIP2930(transaction2, signature2) {
    const { chainId, gas, data: data2, nonce, to, value, accessList, gasPrice } = transaction2;
    (0, assertTransaction_js_12.assertTransactionEIP2930)(transaction2);
    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
    const serializedTransaction = [
      (0, toHex_js_12.toHex)(chainId),
      nonce ? (0, toHex_js_12.toHex)(nonce) : "0x",
      gasPrice ? (0, toHex_js_12.toHex)(gasPrice) : "0x",
      gas ? (0, toHex_js_12.toHex)(gas) : "0x",
      to ?? "0x",
      value ? (0, toHex_js_12.toHex)(value) : "0x",
      data2 ?? "0x",
      serializedAccessList
    ];
    if (signature2) {
      const yParity = (() => {
        if (signature2.v === 0n)
          return "0x";
        if (signature2.v === 1n)
          return (0, toHex_js_12.toHex)(1);
        return signature2.v === 27n ? "0x" : (0, toHex_js_12.toHex)(1);
      })();
      serializedTransaction.push(yParity, (0, trim_js_12.trim)(signature2.r), (0, trim_js_12.trim)(signature2.s));
    }
    return (0, concat_js_12.concatHex)([
      "0x01",
      (0, toRlp_js_1.toRlp)(serializedTransaction)
    ]);
  }
  function serializeTransactionLegacy(transaction2, signature2) {
    const { chainId = 0, gas, data: data2, nonce, to, value, gasPrice } = transaction2;
    (0, assertTransaction_js_12.assertTransactionLegacy)(transaction2);
    let serializedTransaction = [
      nonce ? (0, toHex_js_12.toHex)(nonce) : "0x",
      gasPrice ? (0, toHex_js_12.toHex)(gasPrice) : "0x",
      gas ? (0, toHex_js_12.toHex)(gas) : "0x",
      to ?? "0x",
      value ? (0, toHex_js_12.toHex)(value) : "0x",
      data2 ?? "0x"
    ];
    if (signature2) {
      const v2 = (() => {
        if (chainId > 0)
          return BigInt(chainId * 2) + BigInt(35n + signature2.v - 27n);
        if (signature2.v >= 35n) {
          const inferredChainId = (signature2.v - 35n) / 2n;
          if (inferredChainId > 0)
            return signature2.v;
          return 27n + (signature2.v === 35n ? 0n : 1n);
        }
        const v3 = 27n + (signature2.v === 27n ? 0n : 1n);
        if (signature2.v !== v3)
          throw new transaction_js_12.InvalidLegacyVError({ v: signature2.v });
        return v3;
      })();
      serializedTransaction = [
        ...serializedTransaction,
        (0, toHex_js_12.toHex)(v2),
        signature2.r,
        signature2.s
      ];
    } else if (chainId > 0) {
      serializedTransaction = [
        ...serializedTransaction,
        (0, toHex_js_12.toHex)(chainId),
        "0x",
        "0x"
      ];
    }
    return (0, toRlp_js_1.toRlp)(serializedTransaction);
  }
  return serializeTransaction;
}
var parseUnits$2 = {};
Object.defineProperty(parseUnits$2, "__esModule", { value: true });
var parseUnits_2 = parseUnits$2.parseUnits = void 0;
function parseUnits(value, decimals) {
  let [integer, fraction = "0"] = value.split(".");
  const negative = integer.startsWith("-");
  if (negative)
    integer = integer.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer = `${BigInt(integer) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left, unit2, right] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded2 = Math.round(Number(`${unit2}.${right}`));
    if (rounded2 > 9)
      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
    else
      fraction = `${left}${rounded2}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer = `${BigInt(integer) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
}
parseUnits_2 = parseUnits$2.parseUnits = parseUnits;
const parseUnits$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: parseUnits$2,
  get parseUnits() {
    return parseUnits_2;
  }
}, [parseUnits$2]);
const require$$110 = /* @__PURE__ */ getAugmentedNamespace(parseUnits$1);
var parseEther$2 = {};
Object.defineProperty(parseEther$2, "__esModule", { value: true });
var parseEther_2 = parseEther$2.parseEther = void 0;
const unit_js_1$1 = require$$16$2;
const parseUnits_js_1$1 = require$$110;
function parseEther(ether, unit2 = "wei") {
  return (0, parseUnits_js_1$1.parseUnits)(ether, unit_js_1$1.etherUnits[unit2]);
}
parseEther_2 = parseEther$2.parseEther = parseEther;
const parseEther$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: parseEther$2,
  get parseEther() {
    return parseEther_2;
  }
}, [parseEther$2]);
const require$$107 = /* @__PURE__ */ getAugmentedNamespace(parseEther$1);
var parseGwei$2 = {};
Object.defineProperty(parseGwei$2, "__esModule", { value: true });
var parseGwei_2 = parseGwei$2.parseGwei = void 0;
const unit_js_1 = require$$16$2;
const parseUnits_js_1 = require$$110;
function parseGwei(ether, unit2 = "wei") {
  return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.gweiUnits[unit2]);
}
parseGwei_2 = parseGwei$2.parseGwei = parseGwei;
const parseGwei$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: parseGwei$2,
  get parseGwei() {
    return parseGwei_2;
  }
}, [parseGwei$2]);
const require$$108 = /* @__PURE__ */ getAugmentedNamespace(parseGwei$1);
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$5;
  hasRequiredUtils = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = exports.extractFunctionParts = exports.extractFunctionType = exports.extractFunctionParams = exports.extractFunctionName = exports.isAddressEqual = exports.isAddress = exports.getAddress = exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = exports.publicKeyToAddress = exports.parseAccount = exports.formatAbiParams = exports.formatAbiItem = exports.formatAbiItemWithArgs = exports.encodePacked = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.getAbiItem = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeAbiParameters = exports.validateTypedData = exports.stringify = exports.rpc = exports.getSocket = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.buildRequest = exports.isDeterministicError = void 0;
    exports.getEstimateGasError = exports.getContractError = exports.getCallError = exports.getNodeError = exports.containsNodeError = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBigInt = exports.hexToBool = exports.fromHex = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.bytesToBigInt = exports.stringToHex = exports.numberToHex = exports.toHex = exports.bytesToHex = exports.boolToHex = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.toBytes = exports.boolToBytes = exports.toRlp = exports.extract = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.formatLog = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.formatBlock = exports.defineBlock = exports.trim = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.padHex = exports.padBytes = exports.pad = exports.isHex = exports.isBytes = exports.concatHex = exports.concatBytes = void 0;
    exports.parseGwei = exports.parseEther = exports.parseUnits = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.serializeAccessList = exports.serializeTransaction = exports.prepareTransactionRequest = exports.parseTransaction = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.getTransactionType = exports.getSerializedTransactionType = exports.hashMessage = exports.verifyTypedData = exports.verifyMessage = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hashTypedData = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.isHash = exports.getFunctionSelector = exports.getEventSelector = exports.defineFormatter = exports.getTransactionError = void 0;
    var buildRequest_js_12 = require$$0$F;
    Object.defineProperty(exports, "isDeterministicError", { enumerable: true, get: function() {
      return buildRequest_js_12.isDeterministicError;
    } });
    Object.defineProperty(exports, "buildRequest", { enumerable: true, get: function() {
      return buildRequest_js_12.buildRequest;
    } });
    var ccip_js_1 = requireCcip();
    Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var assertCurrentChain_js_12 = require$$81;
    Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
      return assertCurrentChain_js_12.assertCurrentChain;
    } });
    var defineChain_js_1 = require$$82;
    Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
      return defineChain_js_1.defineChain;
    } });
    var extractChain_js_1 = require$$83;
    Object.defineProperty(exports, "extractChain", { enumerable: true, get: function() {
      return extractChain_js_1.extractChain;
    } });
    var getChainContractAddress_js_12 = require$$84;
    Object.defineProperty(exports, "getChainContractAddress", { enumerable: true, get: function() {
      return getChainContractAddress_js_12.getChainContractAddress;
    } });
    var regex_js_12 = require$$6$5;
    Object.defineProperty(exports, "arrayRegex", { enumerable: true, get: function() {
      return regex_js_12.arrayRegex;
    } });
    Object.defineProperty(exports, "bytesRegex", { enumerable: true, get: function() {
      return regex_js_12.bytesRegex;
    } });
    Object.defineProperty(exports, "integerRegex", { enumerable: true, get: function() {
      return regex_js_12.integerRegex;
    } });
    var rpc_js_12 = require$$2$b;
    Object.defineProperty(exports, "getSocket", { enumerable: true, get: function() {
      return rpc_js_12.getSocket;
    } });
    Object.defineProperty(exports, "rpc", { enumerable: true, get: function() {
      return rpc_js_12.rpc;
    } });
    var stringify_js_12 = require$$115;
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_12.stringify;
    } });
    var typedData_js_12 = requireTypedData();
    Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_12.validateTypedData;
    } });
    var decodeAbiParameters_js_12 = require$$41$1;
    Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_12.decodeAbiParameters;
    } });
    var decodeErrorResult_js_12 = require$$43$1;
    Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_12.decodeErrorResult;
    } });
    var decodeEventLog_js_12 = require$$44;
    Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_12.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require$$45;
    Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_12 = require$$46;
    Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_12.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_12 = require$$47;
    Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_12.encodeAbiParameters;
    } });
    var encodeDeployData_js_12 = require$$48;
    Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_12.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require$$49;
    Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_12 = require$$50;
    Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_12.encodeEventTopics;
    } });
    var encodeFunctionData_js_12 = require$$51;
    Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_12.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require$$52;
    Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var getAbiItem_js_12 = require$$56$1;
    Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_12.getAbiItem;
    } });
    var abitype_12 = requireCjs();
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return abitype_12.parseAbi;
    } });
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_12.parseAbiItem;
    } });
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_12.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_12.parseAbiParameters;
    } });
    var encodePacked_js_1 = require$$85;
    Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatAbiItemWithArgs_js_12 = require$$24$3;
    Object.defineProperty(exports, "formatAbiItemWithArgs", { enumerable: true, get: function() {
      return formatAbiItemWithArgs_js_12.formatAbiItemWithArgs;
    } });
    var formatAbiItem_js_12 = requireFormatAbiItem();
    Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function() {
      return formatAbiItem_js_12.formatAbiItem;
    } });
    Object.defineProperty(exports, "formatAbiParams", { enumerable: true, get: function() {
      return formatAbiItem_js_12.formatAbiParams;
    } });
    var parseAccount_js_12 = require$$0$L;
    Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
      return parseAccount_js_12.parseAccount;
    } });
    var publicKeyToAddress_js_12 = require$$27$2;
    Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
      return publicKeyToAddress_js_12.publicKeyToAddress;
    } });
    var getContractAddress_js_1 = requireGetContractAddress();
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    var getAddress_js_12 = require$$91;
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_12.getAddress;
    } });
    var isAddress_js_12 = require$$98;
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_12.isAddress;
    } });
    var isAddressEqual_js_12 = require$$99;
    Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_12.isAddressEqual;
    } });
    var extractFunctionParts_js_1 = require$$32$1;
    Object.defineProperty(exports, "extractFunctionName", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionName;
    } });
    Object.defineProperty(exports, "extractFunctionParams", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParams;
    } });
    Object.defineProperty(exports, "extractFunctionType", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionType;
    } });
    Object.defineProperty(exports, "extractFunctionParts", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParts;
    } });
    var concat_js_12 = require$$80;
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_js_12.concat;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return concat_js_12.concatBytes;
    } });
    Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
      return concat_js_12.concatHex;
    } });
    var isBytes_js_1 = require$$100;
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHex_js_12 = require$$102;
    Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
      return isHex_js_12.isHex;
    } });
    var pad_js_12 = require$$106;
    Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
      return pad_js_12.pad;
    } });
    Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
      return pad_js_12.padBytes;
    } });
    Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
      return pad_js_12.padHex;
    } });
    var size_js_12 = require$$113;
    Object.defineProperty(exports, "size", { enumerable: true, get: function() {
      return size_js_12.size;
    } });
    var slice_js_12 = require$$114;
    Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
      return slice_js_12.slice;
    } });
    Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_12.sliceBytes;
    } });
    Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
      return slice_js_12.sliceHex;
    } });
    var trim_js_12 = require$$116;
    Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
      return trim_js_12.trim;
    } });
    var block_js_12 = require$$39$1;
    Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
      return block_js_12.defineBlock;
    } });
    Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
      return block_js_12.formatBlock;
    } });
    var transaction_js_12 = require$$53$1;
    Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_12.defineTransaction;
    } });
    Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_12.formatTransaction;
    } });
    Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
      return transaction_js_12.transactionType;
    } });
    var log_js_12 = require$$40$1;
    Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
      return log_js_12.formatLog;
    } });
    var transactionReceipt_js_12 = require$$54;
    Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_12.defineTransactionReceipt;
    } });
    var transactionRequest_js_12 = require$$55;
    Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_12.defineTransactionRequest;
    } });
    Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_12.formatTransactionRequest;
    } });
    var extract_js_12 = require$$0$J;
    Object.defineProperty(exports, "extract", { enumerable: true, get: function() {
      return extract_js_12.extract;
    } });
    var toRlp_js_1 = requireToRlp();
    Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var toBytes_js_12 = requireToBytes();
    Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_12.boolToBytes;
    } });
    Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_12.toBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_12.hexToBytes;
    } });
    Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_12.numberToBytes;
    } });
    Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_12.stringToBytes;
    } });
    var toHex_js_12 = requireToHex();
    Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_12.boolToHex;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_12.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return toHex_js_12.toHex;
    } });
    Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_12.numberToHex;
    } });
    Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_12.stringToHex;
    } });
    var fromBytes_js_1 = require$$78;
    Object.defineProperty(exports, "bytesToBigInt", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var fromHex_js_12 = requireFromHex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_12.fromHex;
    } });
    Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_12.hexToBool;
    } });
    Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_12.hexToBigInt;
    } });
    Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_12.hexToNumber;
    } });
    Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_12.hexToString;
    } });
    var fromRlp_js_12 = require$$90;
    Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_12.fromRlp;
    } });
    var getNodeError_js_12 = require$$52$1;
    Object.defineProperty(exports, "containsNodeError", { enumerable: true, get: function() {
      return getNodeError_js_12.containsNodeError;
    } });
    Object.defineProperty(exports, "getNodeError", { enumerable: true, get: function() {
      return getNodeError_js_12.getNodeError;
    } });
    var getCallError_js_1 = require$$53;
    Object.defineProperty(exports, "getCallError", { enumerable: true, get: function() {
      return getCallError_js_1.getCallError;
    } });
    var getContractError_js_12 = require$$92;
    Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_12.getContractError;
    } });
    var getEstimateGasError_js_1 = require$$55$1;
    Object.defineProperty(exports, "getEstimateGasError", { enumerable: true, get: function() {
      return getEstimateGasError_js_1.getEstimateGasError;
    } });
    var getTransactionError_js_12 = require$$56;
    Object.defineProperty(exports, "getTransactionError", { enumerable: true, get: function() {
      return getTransactionError_js_12.getTransactionError;
    } });
    var formatter_js_12 = require$$57;
    Object.defineProperty(exports, "defineFormatter", { enumerable: true, get: function() {
      return formatter_js_12.defineFormatter;
    } });
    var getEventSelector_js_12 = require$$93;
    Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_12.getEventSelector;
    } });
    var getFunctionSelector_js_12 = require$$95;
    Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_12.getFunctionSelector;
    } });
    var isHash_js_12 = require$$101;
    Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
      return isHash_js_12.isHash;
    } });
    var keccak256_js_12 = require$$103;
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_12.keccak256;
    } });
    var sha256_js_1 = require$$104;
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_js_1.sha256;
    } });
    var ripemd160_js_1 = require$$105;
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return ripemd160_js_1.ripemd160;
    } });
    var hashTypedData_js_12 = requireHashTypedData();
    Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_12.hashTypedData;
    } });
    var recoverAddress_js_12 = require$$64;
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_12.recoverAddress;
    } });
    var recoverMessageAddress_js_12 = require$$65;
    Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_12.recoverMessageAddress;
    } });
    var recoverPublicKey_js_12 = require$$66;
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_12.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_12 = require$$67;
    Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_12.recoverTypedDataAddress;
    } });
    var verifyMessage_js_1 = require$$72;
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require$$73;
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var hashMessage_js_12 = require$$97;
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_12.hashMessage;
    } });
    var getSerializedTransactionType_js_12 = require$$58;
    Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_12.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require$$59;
    Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var assertRequest_js_12 = require$$74;
    Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_12.assertRequest;
    } });
    var assertTransaction_js_12 = require$$75;
    Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_12.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_12.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_12.assertTransactionLegacy;
    } });
    var parseTransaction_js_1 = require$$109;
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var prepareTransactionRequest_js_12 = requirePrepareTransactionRequest();
    Object.defineProperty(exports, "prepareTransactionRequest", { enumerable: true, get: function() {
      return prepareTransactionRequest_js_12.prepareTransactionRequest;
    } });
    var serializeTransaction_js_1 = requireSerializeTransaction();
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var serializeAccessList_js_1 = require$$111;
    Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var formatEther_js_12 = require$$86;
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_12.formatEther;
    } });
    var formatGwei_js_12 = require$$87;
    Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_12.formatGwei;
    } });
    var formatUnits_js_12 = require$$88;
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_12.formatUnits;
    } });
    var parseUnits_js_12 = require$$110;
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_12.parseUnits;
    } });
    var parseEther_js_1 = require$$107;
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require$$108;
    Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
  })(utils$5);
  return utils$5;
}
var hasRequiredProof;
function requireProof() {
  if (hasRequiredProof)
    return proof;
  hasRequiredProof = 1;
  Object.defineProperty(proof, "__esModule", { value: true });
  proof.formatProof = void 0;
  const index_js_1 = requireUtils();
  function formatStorageProof2(storageProof) {
    return storageProof.map((proof2) => ({
      ...proof2,
      value: BigInt(proof2.value)
    }));
  }
  function formatProof2(proof2) {
    return {
      ...proof2,
      balance: proof2.balance ? BigInt(proof2.balance) : void 0,
      nonce: proof2.nonce ? (0, index_js_1.hexToNumber)(proof2.nonce) : void 0,
      storageProof: proof2.storageProof ? formatStorageProof2(proof2.storageProof) : void 0
    };
  }
  proof.formatProof = formatProof2;
  return proof;
}
var hasRequiredGetProof;
function requireGetProof() {
  if (hasRequiredGetProof)
    return getProof;
  hasRequiredGetProof = 1;
  Object.defineProperty(getProof, "__esModule", { value: true });
  getProof.getProof = void 0;
  const toHex_js_12 = requireToHex();
  const proof_js_1 = requireProof();
  async function getProof$12(client2, { address: address2, blockNumber, blockTag: blockTag_, storageKeys }) {
    const blockTag = blockTag_ ?? "latest";
    const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_12.numberToHex)(blockNumber) : void 0;
    const proof2 = await client2.request({
      method: "eth_getProof",
      params: [address2, storageKeys, blockNumberHex || blockTag]
    });
    return (0, proof_js_1.formatProof)(proof2);
  }
  getProof.getProof = getProof$12;
  return getProof;
}
var getStorageAt$2 = {};
Object.defineProperty(getStorageAt$2, "__esModule", { value: true });
var getStorageAt_2 = getStorageAt$2.getStorageAt = void 0;
const toHex_js_1$h = requireToHex();
async function getStorageAt(client2, { address: address2, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1$h.numberToHex)(blockNumber) : void 0;
  const data2 = await client2.request({
    method: "eth_getStorageAt",
    params: [address2, slot, blockNumberHex || blockTag]
  });
  return data2;
}
getStorageAt_2 = getStorageAt$2.getStorageAt = getStorageAt;
const getStorageAt$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getStorageAt$2,
  get getStorageAt() {
    return getStorageAt_2;
  }
}, [getStorageAt$2]);
const require$$27$1 = /* @__PURE__ */ getAugmentedNamespace(getStorageAt$1);
var getTransaction$2 = {};
Object.defineProperty(getTransaction$2, "__esModule", { value: true });
var getTransaction_2 = getTransaction$2.getTransaction = void 0;
const transaction_js_1$2 = require$$34$1;
const toHex_js_1$g = requireToHex();
const transaction_js_2 = require$$53$1;
async function getTransaction(client2, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1$g.numberToHex)(blockNumber) : void 0;
  let transaction2 = null;
  if (hash2) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByHash",
      params: [hash2]
    });
  } else if (blockHash) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, (0, toHex_js_1$g.numberToHex)(index2)]
    });
  } else if (blockNumberHex || blockTag) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, (0, toHex_js_1$g.numberToHex)(index2)]
    });
  }
  if (!transaction2)
    throw new transaction_js_1$2.TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash2,
      index: index2
    });
  const format = client2.chain?.formatters?.transaction?.format || transaction_js_2.formatTransaction;
  return format(transaction2);
}
getTransaction_2 = getTransaction$2.getTransaction = getTransaction;
const getTransaction$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getTransaction$2,
  get getTransaction() {
    return getTransaction_2;
  }
}, [getTransaction$2]);
const require$$28$1 = /* @__PURE__ */ getAugmentedNamespace(getTransaction$1);
var getTransactionConfirmations$2 = {};
Object.defineProperty(getTransactionConfirmations$2, "__esModule", { value: true });
var getTransactionConfirmations_2 = getTransactionConfirmations$2.getTransactionConfirmations = void 0;
const getAction_js_1$5 = require$$4$a;
const getBlockNumber_js_1$1 = require$$16$1;
const getTransaction_js_1$1 = require$$28$1;
async function getTransactionConfirmations(client2, { hash: hash2, transactionReceipt: transactionReceipt2 }) {
  const [blockNumber, transaction2] = await Promise.all([
    (0, getAction_js_1$5.getAction)(client2, getBlockNumber_js_1$1.getBlockNumber, "getBlockNumber")({}),
    hash2 ? (0, getAction_js_1$5.getAction)(client2, getTransaction_js_1$1.getTransaction, "getBlockNumber")({ hash: hash2 }) : void 0
  ]);
  const transactionBlockNumber = transactionReceipt2?.blockNumber || transaction2?.blockNumber;
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}
getTransactionConfirmations_2 = getTransactionConfirmations$2.getTransactionConfirmations = getTransactionConfirmations;
const getTransactionConfirmations$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getTransactionConfirmations$2,
  get getTransactionConfirmations() {
    return getTransactionConfirmations_2;
  }
}, [getTransactionConfirmations$2]);
const require$$29$1 = /* @__PURE__ */ getAugmentedNamespace(getTransactionConfirmations$1);
var getTransactionReceipt$2 = {};
Object.defineProperty(getTransactionReceipt$2, "__esModule", { value: true });
var getTransactionReceipt_2 = getTransactionReceipt$2.getTransactionReceipt = void 0;
const transaction_js_1$1 = require$$34$1;
const transactionReceipt_js_1 = require$$54;
async function getTransactionReceipt(client2, { hash: hash2 }) {
  const receipt = await client2.request({
    method: "eth_getTransactionReceipt",
    params: [hash2]
  });
  if (!receipt)
    throw new transaction_js_1$1.TransactionReceiptNotFoundError({ hash: hash2 });
  const format = client2.chain?.formatters?.transactionReceipt?.format || transactionReceipt_js_1.formatTransactionReceipt;
  return format(receipt);
}
getTransactionReceipt_2 = getTransactionReceipt$2.getTransactionReceipt = getTransactionReceipt;
const getTransactionReceipt$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getTransactionReceipt$2,
  get getTransactionReceipt() {
    return getTransactionReceipt_2;
  }
}, [getTransactionReceipt$2]);
const require$$31 = /* @__PURE__ */ getAugmentedNamespace(getTransactionReceipt$1);
var multicall$2 = {};
Object.defineProperty(multicall$2, "__esModule", { value: true });
var multicall_2 = multicall$2.multicall = void 0;
const abis_js_1 = require$$14$3;
const abi_js_1$1 = requireAbi();
const base_js_1 = require$$21$2;
const contract_js_1 = require$$23$2;
const decodeFunctionResult_js_1 = require$$46;
const encodeFunctionData_js_1 = require$$51;
const getChainContractAddress_js_1 = require$$84;
const getContractError_js_1 = require$$92;
const getAction_js_1$4 = require$$4$a;
const readContract_js_1 = require$$33;
async function multicall(client2, args) {
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts: contracts2, multicallAddress: multicallAddress_ } = args;
  const batchSize = batchSize_ ?? (typeof client2.batch?.multicall === "object" && client2.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
      blockNumber,
      chain: client2.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i2 = 0; i2 < contracts2.length; i2++) {
    const { abi: abi2, address: address2, args: args2, functionName } = contracts2[i2];
    try {
      const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi: abi2,
        args: args2,
        functionName
      });
      currentChunkSize += (callData.length - 2) / 2;
      if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address2
        }
      ];
    } catch (err) {
      const error = (0, getContractError_js_1.getContractError)(err, {
        abi: abi2,
        address: address2,
        args: args2,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address2
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => (0, getAction_js_1$4.getAction)(client2, readContract_js_1.readContract, "readContract")({
    abi: abis_js_1.multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3"
  })));
  const results = [];
  for (let i2 = 0; i2 < aggregate3Results.length; i2++) {
    const result = aggregate3Results[i2];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j2 = 0; j2 < chunkedCalls[i2].length; j2++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: void 0
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j2 = 0; j2 < aggregate3Result.length; j2++) {
      const { returnData, success } = aggregate3Result[j2];
      const { callData } = chunkedCalls[i2][j2];
      const { abi: abi2, address: address2, functionName, args: args2 } = contracts2[results.length];
      try {
        if (callData === "0x")
          throw new abi_js_1$1.AbiDecodingZeroDataError();
        if (!success)
          throw new contract_js_1.RawContractError({ data: returnData });
        const result2 = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi: abi2,
          args: args2,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err) {
        const error = (0, getContractError_js_1.getContractError)(err, {
          abi: abi2,
          address: address2,
          args: args2,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results.push({ error, result: void 0, status: "failure" });
      }
    }
  }
  if (results.length !== contracts2.length)
    throw new base_js_1.BaseError("multicall results mismatch");
  return results;
}
multicall_2 = multicall$2.multicall = multicall;
const multicall$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: multicall$2,
  get multicall() {
    return multicall_2;
  }
}, [multicall$2]);
const require$$32 = /* @__PURE__ */ getAugmentedNamespace(multicall$1);
var verifyMessage = {};
var verifyHash = {};
var contracts$1 = {};
Object.defineProperty(contracts$1, "__esModule", { value: true });
var universalSignatureValidatorByteCode = contracts$1.universalSignatureValidatorByteCode = void 0;
universalSignatureValidatorByteCode = contracts$1.universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
const contracts = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: contracts$1,
  get universalSignatureValidatorByteCode() {
    return universalSignatureValidatorByteCode;
  }
}, [contracts$1]);
const require$$1$f = /* @__PURE__ */ getAugmentedNamespace(contracts);
var isBytesEqual$2 = {};
const require$$0$v = /* @__PURE__ */ getAugmentedNamespace(utils$o);
Object.defineProperty(isBytesEqual$2, "__esModule", { value: true });
var isBytesEqual_2 = isBytesEqual$2.isBytesEqual = void 0;
const utils_1 = require$$0$v;
const toBytes_js_1$1 = requireToBytes();
const isHex_js_1$1 = require$$102;
function isBytesEqual(a_, b_) {
  const a2 = (0, isHex_js_1$1.isHex)(a_) ? (0, toBytes_js_1$1.toBytes)(a_) : a_;
  const b2 = (0, isHex_js_1$1.isHex)(b_) ? (0, toBytes_js_1$1.toBytes)(b_) : b_;
  return (0, utils_1.equalBytes)(a2, b2);
}
isBytesEqual_2 = isBytesEqual$2.isBytesEqual = isBytesEqual;
const isBytesEqual$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: isBytesEqual$2,
  get isBytesEqual() {
    return isBytesEqual_2;
  }
}, [isBytesEqual$2]);
const require$$3$8 = /* @__PURE__ */ getAugmentedNamespace(isBytesEqual$1);
var hasRequiredVerifyHash;
function requireVerifyHash() {
  if (hasRequiredVerifyHash)
    return verifyHash;
  hasRequiredVerifyHash = 1;
  Object.defineProperty(verifyHash, "__esModule", { value: true });
  verifyHash.verifyHash = void 0;
  const abis_js_12 = require$$14$3;
  const contracts_js_1 = require$$1$f;
  const contract_js_12 = require$$23$2;
  const isBytesEqual_js_1 = require$$3$8;
  const getAction_js_12 = require$$4$a;
  const index_js_1 = requireUtils();
  const call_js_12 = requireCall();
  async function verifyHash$12(client2, { address: address2, hash: hash2, signature: signature2, ...callRequest }) {
    const signatureHex = (0, index_js_1.isHex)(signature2) ? signature2 : (0, index_js_1.toHex)(signature2);
    try {
      const { data: data2 } = await (0, getAction_js_12.getAction)(client2, call_js_12.call, "call")({
        data: (0, index_js_1.encodeDeployData)({
          abi: abis_js_12.universalSignatureValidatorAbi,
          args: [address2, hash2, signatureHex],
          bytecode: contracts_js_1.universalSignatureValidatorByteCode
        }),
        ...callRequest
      });
      return (0, isBytesEqual_js_1.isBytesEqual)(data2 ?? "0x0", "0x1");
    } catch (error) {
      if (error instanceof contract_js_12.CallExecutionError) {
        return false;
      }
      throw error;
    }
  }
  verifyHash.verifyHash = verifyHash$12;
  return verifyHash;
}
var hasRequiredVerifyMessage;
function requireVerifyMessage() {
  if (hasRequiredVerifyMessage)
    return verifyMessage;
  hasRequiredVerifyMessage = 1;
  Object.defineProperty(verifyMessage, "__esModule", { value: true });
  verifyMessage.verifyMessage = void 0;
  const index_js_1 = requireUtils();
  const verifyHash_js_1 = requireVerifyHash();
  async function verifyMessage$12(client2, { address: address2, message, signature: signature2, ...callRequest }) {
    const hash2 = (0, index_js_1.hashMessage)(message);
    return (0, verifyHash_js_1.verifyHash)(client2, {
      address: address2,
      hash: hash2,
      signature: signature2,
      ...callRequest
    });
  }
  verifyMessage.verifyMessage = verifyMessage$12;
  return verifyMessage;
}
var verifyTypedData = {};
var hasRequiredVerifyTypedData;
function requireVerifyTypedData() {
  if (hasRequiredVerifyTypedData)
    return verifyTypedData;
  hasRequiredVerifyTypedData = 1;
  Object.defineProperty(verifyTypedData, "__esModule", { value: true });
  verifyTypedData.verifyTypedData = void 0;
  const hashTypedData_js_12 = requireHashTypedData();
  const verifyHash_js_1 = requireVerifyHash();
  async function verifyTypedData$12(client2, { address: address2, signature: signature2, message, primaryType, types: types2, domain, ...callRequest }) {
    const hash2 = (0, hashTypedData_js_12.hashTypedData)({ message, primaryType, types: types2, domain });
    return (0, verifyHash_js_1.verifyHash)(client2, {
      address: address2,
      hash: hash2,
      signature: signature2,
      ...callRequest
    });
  }
  verifyTypedData.verifyTypedData = verifyTypedData$12;
  return verifyTypedData;
}
var waitForTransactionReceipt$2 = {};
var watchBlockNumber$2 = {};
Object.defineProperty(watchBlockNumber$2, "__esModule", { value: true });
var watchBlockNumber_2 = watchBlockNumber$2.watchBlockNumber = void 0;
const fromHex_js_1$3 = requireFromHex();
const getAction_js_1$3 = require$$4$a;
const observe_js_1$3 = require$$1$m;
const poll_js_1$2 = require$$2$d;
const stringify_js_1$4 = require$$115;
const getBlockNumber_js_1 = require$$16$1;
function watchBlockNumber(client2, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = (0, stringify_js_1$4.stringify)([
      "watchBlockNumber",
      client2.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return (0, observe_js_1$3.observe)(observerId, { onBlockNumber, onError }, (emit3) => (0, poll_js_1$2.poll)(async () => {
      try {
        const blockNumber = await (0, getAction_js_1$3.getAction)(client2, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i2 = prevBlockNumber + 1n; i2 < blockNumber; i2++) {
              emit3.onBlockNumber(i2, prevBlockNumber);
              prevBlockNumber = i2;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit3.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        emit3.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["newHeads"],
          onData(data2) {
            if (!active)
              return;
            const blockNumber = (0, fromHex_js_1$3.hexToBigInt)(data2.result?.number);
            onBlockNumber(blockNumber, prevBlockNumber);
            prevBlockNumber = blockNumber;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}
watchBlockNumber_2 = watchBlockNumber$2.watchBlockNumber = watchBlockNumber;
const watchBlockNumber$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: watchBlockNumber$2,
  get watchBlockNumber() {
    return watchBlockNumber_2;
  }
}, [watchBlockNumber$2]);
const require$$39 = /* @__PURE__ */ getAugmentedNamespace(watchBlockNumber$1);
Object.defineProperty(waitForTransactionReceipt$2, "__esModule", { value: true });
var waitForTransactionReceipt_2 = waitForTransactionReceipt$2.waitForTransactionReceipt = void 0;
const block_js_1$1 = require$$22$2;
const transaction_js_1 = require$$34$1;
const getAction_js_1$2 = require$$4$a;
const observe_js_1$2 = require$$1$m;
const withRetry_js_1 = require$$4$9;
const stringify_js_1$3 = require$$115;
const getBlock_js_1$1 = require$$15$3;
const getTransaction_js_1 = require$$28$1;
const getTransactionReceipt_js_1 = require$$31;
const watchBlockNumber_js_1 = require$$39;
async function waitForTransactionReceipt(client2, { confirmations = 1, hash: hash2, onReplaced, pollingInterval = client2.pollingInterval, timeout }) {
  const observerId = (0, stringify_js_1$3.stringify)(["waitForTransactionReceipt", client2.uid, hash2]);
  let transaction2;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  return new Promise((resolve, reject) => {
    if (timeout)
      setTimeout(() => reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({ hash: hash2 })), timeout);
    const _unobserve = (0, observe_js_1$2.observe)(observerId, { onReplaced, resolve, reject }, (emit3) => {
      const _unwatch = (0, getAction_js_1$2.getAction)(client2, watchBlockNumber_js_1.watchBlockNumber, "watchBlockNumber")({
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          if (retrying)
            return;
          let blockNumber = blockNumber_;
          const done = (fn) => {
            _unwatch();
            fn();
            _unobserve();
          };
          try {
            if (receipt) {
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit3.resolve(receipt));
              return;
            }
            if (!transaction2) {
              retrying = true;
              await (0, withRetry_js_1.withRetry)(async () => {
                transaction2 = await (0, getAction_js_1$2.getAction)(client2, getTransaction_js_1.getTransaction, "getTransaction")({ hash: hash2 });
                if (transaction2.blockNumber)
                  blockNumber = transaction2.blockNumber;
              }, {
                delay: ({ count }) => ~~(1 << count) * 200,
                retryCount: 6
              });
              retrying = false;
            }
            receipt = await (0, getAction_js_1$2.getAction)(client2, getTransactionReceipt_js_1.getTransactionReceipt, "getTransactionReceipt")({ hash: hash2 });
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit3.resolve(receipt));
          } catch (err) {
            if (transaction2 && (err instanceof transaction_js_1.TransactionNotFoundError || err instanceof transaction_js_1.TransactionReceiptNotFoundError)) {
              try {
                replacedTransaction = transaction2;
                retrying = true;
                const block2 = await (0, withRetry_js_1.withRetry)(() => (0, getAction_js_1$2.getAction)(client2, getBlock_js_1$1.getBlock, "getBlock")({
                  blockNumber,
                  includeTransactions: true
                }), {
                  delay: ({ count }) => ~~(1 << count) * 200,
                  retryCount: 6,
                  shouldRetry: ({ error }) => error instanceof block_js_1$1.BlockNotFoundError
                });
                retrying = false;
                const replacementTransaction = block2.transactions.find(({ from: from2, nonce }) => from2 === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await (0, getAction_js_1$2.getAction)(client2, getTransactionReceipt_js_1.getTransactionReceipt, "getTransactionReceipt")({
                  hash: replacementTransaction.hash
                });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  emit3.onReplaced?.({
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit3.resolve(receipt);
                });
              } catch (err_) {
                done(() => emit3.reject(err_));
              }
            } else {
              done(() => emit3.reject(err));
            }
          }
        }
      });
    });
  });
}
waitForTransactionReceipt_2 = waitForTransactionReceipt$2.waitForTransactionReceipt = waitForTransactionReceipt;
const waitForTransactionReceipt$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: waitForTransactionReceipt$2,
  get waitForTransactionReceipt() {
    return waitForTransactionReceipt_2;
  }
}, [waitForTransactionReceipt$2]);
const require$$38 = /* @__PURE__ */ getAugmentedNamespace(waitForTransactionReceipt$1);
var watchBlocks$2 = {};
Object.defineProperty(watchBlocks$2, "__esModule", { value: true });
var watchBlocks_2 = watchBlocks$2.watchBlocks = void 0;
const block_js_1 = require$$39$1;
const getAction_js_1$1 = require$$4$a;
const observe_js_1$1 = require$$1$m;
const poll_js_1$1 = require$$2$d;
const stringify_js_1$2 = require$$115;
const getBlock_js_1 = require$$15$3;
function watchBlocks(client2, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = (0, stringify_js_1$2.stringify)([
      "watchBlocks",
      client2.uid,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return (0, observe_js_1$1.observe)(observerId, { onBlock, onError }, (emit3) => (0, poll_js_1$1.poll)(async () => {
      try {
        const block2 = await (0, getAction_js_1$1.getAction)(client2, getBlock_js_1.getBlock, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block2.number && prevBlock?.number) {
          if (block2.number === prevBlock.number)
            return;
          if (block2.number - prevBlock.number > 1 && emitMissed) {
            for (let i2 = prevBlock?.number + 1n; i2 < block2.number; i2++) {
              const block3 = await (0, getAction_js_1$1.getAction)(client2, getBlock_js_1.getBlock, "getBlock")({
                blockNumber: i2,
                includeTransactions
              });
              emit3.onBlock(block3, prevBlock);
              prevBlock = block3;
            }
          }
        }
        if (!prevBlock?.number || blockTag === "pending" && !block2?.number || block2.number && block2.number > prevBlock.number) {
          emit3.onBlock(block2, prevBlock);
          prevBlock = block2;
        }
      } catch (err) {
        emit3.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["newHeads"],
          onData(data2) {
            if (!active)
              return;
            const format = client2.chain?.formatters?.block?.format || block_js_1.formatBlock;
            const block2 = format(data2.result);
            onBlock(block2, prevBlock);
            prevBlock = block2;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}
watchBlocks_2 = watchBlocks$2.watchBlocks = watchBlocks;
const watchBlocks$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: watchBlocks$2,
  get watchBlocks() {
    return watchBlocks_2;
  }
}, [watchBlocks$2]);
const require$$40 = /* @__PURE__ */ getAugmentedNamespace(watchBlocks$1);
var watchEvent = {};
var hasRequiredWatchEvent;
function requireWatchEvent() {
  if (hasRequiredWatchEvent)
    return watchEvent;
  hasRequiredWatchEvent = 1;
  Object.defineProperty(watchEvent, "__esModule", { value: true });
  watchEvent.watchEvent = void 0;
  const observe_js_12 = require$$1$m;
  const poll_js_12 = require$$2$d;
  const stringify_js_12 = require$$115;
  const abi_js_12 = requireAbi();
  const rpc_js_12 = require$$25$2;
  const getAction_js_12 = require$$4$a;
  const index_js_1 = requireUtils();
  const createEventFilter_js_1 = require$$8$2;
  const getBlockNumber_js_12 = require$$16$1;
  const getFilterChanges_js_12 = require$$22$1;
  const getLogs_js_12 = require$$25$1;
  const uninstallFilter_js_12 = require$$35;
  function watchEvent$12(client2, { address: address2, args, batch: batch2 = true, event, events: events2, onError, onLogs, poll: poll_, pollingInterval = client2.pollingInterval, strict: strict_ }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
    const strict = strict_ ?? false;
    const pollEvent = () => {
      const observerId = (0, stringify_js_12.stringify)([
        "watchEvent",
        address2,
        args,
        batch2,
        client2.uid,
        event,
        pollingInterval
      ]);
      return (0, observe_js_12.observe)(observerId, { onLogs, onError }, (emit3) => {
        let previousBlockNumber;
        let filter2;
        let initialized = false;
        const unwatch = (0, poll_js_12.poll)(async () => {
          if (!initialized) {
            try {
              filter2 = await (0, getAction_js_12.getAction)(client2, createEventFilter_js_1.createEventFilter, "createEventFilter")({
                address: address2,
                args,
                event,
                events: events2,
                strict
              });
            } catch {
            }
            initialized = true;
            return;
          }
          try {
            let logs;
            if (filter2) {
              logs = await (0, getAction_js_12.getAction)(client2, getFilterChanges_js_12.getFilterChanges, "getFilterChanges")({ filter: filter2 });
            } else {
              const blockNumber = await (0, getAction_js_12.getAction)(client2, getBlockNumber_js_12.getBlockNumber, "getBlockNumber")({});
              if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                logs = await (0, getAction_js_12.getAction)(client2, getLogs_js_12.getLogs, "getLogs")({
                  address: address2,
                  args,
                  event,
                  events: events2,
                  fromBlock: previousBlockNumber + 1n,
                  toBlock: blockNumber
                });
              } else {
                logs = [];
              }
              previousBlockNumber = blockNumber;
            }
            if (logs.length === 0)
              return;
            if (batch2)
              emit3.onLogs(logs);
            else
              for (const log3 of logs)
                emit3.onLogs([log3]);
          } catch (err) {
            if (filter2 && err instanceof rpc_js_12.InvalidInputRpcError)
              initialized = false;
            emit3.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter2)
            await (0, getAction_js_12.getAction)(client2, uninstallFilter_js_12.uninstallFilter, "uninstallFilter")({ filter: filter2 });
          unwatch();
        };
      });
    };
    const subscribeEvent = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const events_ = events2 ?? (event ? [event] : void 0);
          let topics = [];
          if (events_) {
            topics = [
              events_.flatMap((event2) => (0, index_js_1.encodeEventTopics)({
                abi: [event2],
                eventName: event2.name,
                args
              }))
            ];
            if (event)
              topics = topics[0];
          }
          const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
            params: ["logs", { address: address2, topics }],
            onData(data2) {
              if (!active)
                return;
              const log3 = data2.result;
              try {
                const { eventName, args: args2 } = (0, index_js_1.decodeEventLog)({
                  abi: events_,
                  data: log3.data,
                  topics: log3.topics,
                  strict
                });
                const formatted = (0, index_js_1.formatLog)(log3, {
                  args: args2,
                  eventName
                });
                onLogs([formatted]);
              } catch (err) {
                let eventName;
                let isUnnamed;
                if (err instanceof abi_js_12.DecodeLogDataMismatch || err instanceof abi_js_12.DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName = err.abiItem.name;
                  isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
                }
                const formatted = (0, index_js_1.formatLog)(log3, {
                  args: isUnnamed ? [] : {},
                  eventName
                });
                onLogs([formatted]);
              }
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return unsubscribe;
    };
    return enablePolling ? pollEvent() : subscribeEvent();
  }
  watchEvent.watchEvent = watchEvent$12;
  return watchEvent;
}
var watchPendingTransactions$2 = {};
Object.defineProperty(watchPendingTransactions$2, "__esModule", { value: true });
var watchPendingTransactions_2 = watchPendingTransactions$2.watchPendingTransactions = void 0;
const getAction_js_1 = require$$4$a;
const observe_js_1 = require$$1$m;
const poll_js_1 = require$$2$d;
const stringify_js_1$1 = require$$115;
const createPendingTransactionFilter_js_1 = require$$9$3;
const getFilterChanges_js_1 = require$$22$1;
const uninstallFilter_js_1 = require$$35;
function watchPendingTransactions(client2, { batch: batch2 = true, onError, onTransactions, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = (0, stringify_js_1$1.stringify)([
      "watchPendingTransactions",
      client2.uid,
      batch2,
      pollingInterval
    ]);
    return (0, observe_js_1.observe)(observerId, { onTransactions, onError }, (emit3) => {
      let filter2;
      const unwatch = (0, poll_js_1.poll)(async () => {
        try {
          if (!filter2) {
            try {
              filter2 = await (0, getAction_js_1.getAction)(client2, createPendingTransactionFilter_js_1.createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await (0, getAction_js_1.getAction)(client2, getFilterChanges_js_1.getFilterChanges, "getFilterChanges")({ filter: filter2 });
          if (hashes.length === 0)
            return;
          if (batch2)
            emit3.onTransactions(hashes);
          else
            for (const hash2 of hashes)
              emit3.onTransactions([hash2]);
        } catch (err) {
          emit3.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await (0, getAction_js_1.getAction)(client2, uninstallFilter_js_1.uninstallFilter, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data2) {
            if (!active)
              return;
            const transaction2 = data2.result;
            onTransactions([transaction2]);
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}
watchPendingTransactions_2 = watchPendingTransactions$2.watchPendingTransactions = watchPendingTransactions;
const watchPendingTransactions$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: watchPendingTransactions$2,
  get watchPendingTransactions() {
    return watchPendingTransactions_2;
  }
}, [watchPendingTransactions$2]);
const require$$43 = /* @__PURE__ */ getAugmentedNamespace(watchPendingTransactions$1);
var hasRequired_public;
function require_public() {
  if (hasRequired_public)
    return _public;
  hasRequired_public = 1;
  Object.defineProperty(_public, "__esModule", { value: true });
  _public.publicActions = void 0;
  const getEnsAddress_js_1 = require$$0$D;
  const getEnsAvatar_js_1 = require$$1$h;
  const getEnsName_js_1 = require$$2$9;
  const getEnsResolver_js_1 = require$$3$9;
  const getEnsText_js_12 = require$$4$7;
  const call_js_12 = requireCall();
  const createBlockFilter_js_1 = require$$6$6;
  const createContractEventFilter_js_12 = require$$7$5;
  const createEventFilter_js_1 = require$$8$2;
  const createPendingTransactionFilter_js_12 = require$$9$3;
  const estimateContractGas_js_12 = require$$10$3;
  const estimateFeesPerGas_js_1 = require$$11$3;
  const estimateGas_js_12 = requireEstimateGas();
  const estimateMaxPriorityFeePerGas_js_12 = require$$13$3;
  const getBalance_js_1 = require$$14$2;
  const getBlock_js_12 = require$$15$3;
  const getBlockNumber_js_12 = require$$16$1;
  const getBlockTransactionCount_js_1 = require$$17$2;
  const getBytecode_js_1 = require$$18$2;
  const getChainId_js_12 = require$$0$H;
  const getContractEvents_js_12 = require$$20$1;
  const getFeeHistory_js_1 = require$$21$1;
  const getFilterChanges_js_12 = require$$22$1;
  const getFilterLogs_js_1 = require$$23$1;
  const getGasPrice_js_12 = require$$24$1;
  const getLogs_js_12 = require$$25$1;
  const getProof_js_1 = requireGetProof();
  const getStorageAt_js_1 = require$$27$1;
  const getTransaction_js_12 = require$$28$1;
  const getTransactionConfirmations_js_1 = require$$29$1;
  const getTransactionCount_js_1 = require$$30;
  const getTransactionReceipt_js_12 = require$$31;
  const multicall_js_1 = require$$32;
  const readContract_js_12 = require$$33;
  const simulateContract_js_12 = require$$34;
  const uninstallFilter_js_12 = require$$35;
  const verifyMessage_js_1 = requireVerifyMessage();
  const verifyTypedData_js_1 = requireVerifyTypedData();
  const waitForTransactionReceipt_js_1 = require$$38;
  const watchBlockNumber_js_12 = require$$39;
  const watchBlocks_js_1 = require$$40;
  const watchContractEvent_js_12 = require$$41;
  const watchEvent_js_1 = requireWatchEvent();
  const watchPendingTransactions_js_1 = require$$43;
  const prepareTransactionRequest_js_12 = requirePrepareTransactionRequest();
  const sendRawTransaction_js_12 = require$$8$3;
  function publicActions2(client2) {
    return {
      call: (args) => (0, call_js_12.call)(client2, args),
      createBlockFilter: () => (0, createBlockFilter_js_1.createBlockFilter)(client2),
      createContractEventFilter: (args) => (0, createContractEventFilter_js_12.createContractEventFilter)(client2, args),
      createEventFilter: (args) => (0, createEventFilter_js_1.createEventFilter)(client2, args),
      createPendingTransactionFilter: () => (0, createPendingTransactionFilter_js_12.createPendingTransactionFilter)(client2),
      estimateContractGas: (args) => (0, estimateContractGas_js_12.estimateContractGas)(client2, args),
      estimateGas: (args) => (0, estimateGas_js_12.estimateGas)(client2, args),
      getBalance: (args) => (0, getBalance_js_1.getBalance)(client2, args),
      getBlock: (args) => (0, getBlock_js_12.getBlock)(client2, args),
      getBlockNumber: (args) => (0, getBlockNumber_js_12.getBlockNumber)(client2, args),
      getBlockTransactionCount: (args) => (0, getBlockTransactionCount_js_1.getBlockTransactionCount)(client2, args),
      getBytecode: (args) => (0, getBytecode_js_1.getBytecode)(client2, args),
      getChainId: () => (0, getChainId_js_12.getChainId)(client2),
      getContractEvents: (args) => (0, getContractEvents_js_12.getContractEvents)(client2, args),
      getEnsAddress: (args) => (0, getEnsAddress_js_1.getEnsAddress)(client2, args),
      getEnsAvatar: (args) => (0, getEnsAvatar_js_1.getEnsAvatar)(client2, args),
      getEnsName: (args) => (0, getEnsName_js_1.getEnsName)(client2, args),
      getEnsResolver: (args) => (0, getEnsResolver_js_1.getEnsResolver)(client2, args),
      getEnsText: (args) => (0, getEnsText_js_12.getEnsText)(client2, args),
      getFeeHistory: (args) => (0, getFeeHistory_js_1.getFeeHistory)(client2, args),
      estimateFeesPerGas: (args) => (0, estimateFeesPerGas_js_1.estimateFeesPerGas)(client2, args),
      getFilterChanges: (args) => (0, getFilterChanges_js_12.getFilterChanges)(client2, args),
      getFilterLogs: (args) => (0, getFilterLogs_js_1.getFilterLogs)(client2, args),
      getGasPrice: () => (0, getGasPrice_js_12.getGasPrice)(client2),
      getLogs: (args) => (0, getLogs_js_12.getLogs)(client2, args),
      getProof: (args) => (0, getProof_js_1.getProof)(client2, args),
      estimateMaxPriorityFeePerGas: (args) => (0, estimateMaxPriorityFeePerGas_js_12.estimateMaxPriorityFeePerGas)(client2, args),
      getStorageAt: (args) => (0, getStorageAt_js_1.getStorageAt)(client2, args),
      getTransaction: (args) => (0, getTransaction_js_12.getTransaction)(client2, args),
      getTransactionConfirmations: (args) => (0, getTransactionConfirmations_js_1.getTransactionConfirmations)(client2, args),
      getTransactionCount: (args) => (0, getTransactionCount_js_1.getTransactionCount)(client2, args),
      getTransactionReceipt: (args) => (0, getTransactionReceipt_js_12.getTransactionReceipt)(client2, args),
      multicall: (args) => (0, multicall_js_1.multicall)(client2, args),
      prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_12.prepareTransactionRequest)(client2, args),
      readContract: (args) => (0, readContract_js_12.readContract)(client2, args),
      sendRawTransaction: (args) => (0, sendRawTransaction_js_12.sendRawTransaction)(client2, args),
      simulateContract: (args) => (0, simulateContract_js_12.simulateContract)(client2, args),
      verifyMessage: (args) => (0, verifyMessage_js_1.verifyMessage)(client2, args),
      verifyTypedData: (args) => (0, verifyTypedData_js_1.verifyTypedData)(client2, args),
      uninstallFilter: (args) => (0, uninstallFilter_js_12.uninstallFilter)(client2, args),
      waitForTransactionReceipt: (args) => (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)(client2, args),
      watchBlocks: (args) => (0, watchBlocks_js_1.watchBlocks)(client2, args),
      watchBlockNumber: (args) => (0, watchBlockNumber_js_12.watchBlockNumber)(client2, args),
      watchContractEvent: (args) => (0, watchContractEvent_js_12.watchContractEvent)(client2, args),
      watchEvent: (args) => (0, watchEvent_js_1.watchEvent)(client2, args),
      watchPendingTransactions: (args) => (0, watchPendingTransactions_js_1.watchPendingTransactions)(client2, args)
    };
  }
  _public.publicActions = publicActions2;
  return _public;
}
var hasRequiredCreatePublicClient;
function requireCreatePublicClient() {
  if (hasRequiredCreatePublicClient)
    return createPublicClient;
  hasRequiredCreatePublicClient = 1;
  Object.defineProperty(createPublicClient, "__esModule", { value: true });
  createPublicClient.createPublicClient = void 0;
  const createClient_js_12 = require$$2$c;
  const public_js_1 = require_public();
  function createPublicClient$12(parameters) {
    const { key = "public", name: name2 = "Public Client" } = parameters;
    const client2 = (0, createClient_js_12.createClient)({
      ...parameters,
      key,
      name: name2,
      type: "publicClient"
    });
    return client2.extend(public_js_1.publicActions);
  }
  createPublicClient.createPublicClient = createPublicClient$12;
  return createPublicClient;
}
var createTestClient$2 = {};
var test$2 = {};
var dropTransaction$2 = {};
Object.defineProperty(dropTransaction$2, "__esModule", { value: true });
var dropTransaction_2 = dropTransaction$2.dropTransaction = void 0;
async function dropTransaction(client2, { hash: hash2 }) {
  await client2.request({
    method: `${client2.mode}_dropTransaction`,
    params: [hash2]
  });
}
dropTransaction_2 = dropTransaction$2.dropTransaction = dropTransaction;
const dropTransaction$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: dropTransaction$2,
  get dropTransaction() {
    return dropTransaction_2;
  }
}, [dropTransaction$2]);
const require$$0$u = /* @__PURE__ */ getAugmentedNamespace(dropTransaction$1);
var dumpState$2 = {};
Object.defineProperty(dumpState$2, "__esModule", { value: true });
var dumpState_2 = dumpState$2.dumpState = void 0;
async function dumpState(client2) {
  return client2.request({
    method: `${client2.mode}_dumpState`
  });
}
dumpState_2 = dumpState$2.dumpState = dumpState;
const dumpState$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: dumpState$2,
  get dumpState() {
    return dumpState_2;
  }
}, [dumpState$2]);
const require$$1$e = /* @__PURE__ */ getAugmentedNamespace(dumpState$1);
var getAutomine$2 = {};
Object.defineProperty(getAutomine$2, "__esModule", { value: true });
var getAutomine_2 = getAutomine$2.getAutomine = void 0;
async function getAutomine(client2) {
  if (client2.mode === "ganache")
    return await client2.request({
      method: "eth_mining"
    });
  return await client2.request({
    method: `${client2.mode}_getAutomine`
  });
}
getAutomine_2 = getAutomine$2.getAutomine = getAutomine;
const getAutomine$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getAutomine$2,
  get getAutomine() {
    return getAutomine_2;
  }
}, [getAutomine$2]);
const require$$2$7 = /* @__PURE__ */ getAugmentedNamespace(getAutomine$1);
var getTxpoolContent$2 = {};
Object.defineProperty(getTxpoolContent$2, "__esModule", { value: true });
var getTxpoolContent_2 = getTxpoolContent$2.getTxpoolContent = void 0;
async function getTxpoolContent(client2) {
  return await client2.request({
    method: "txpool_content"
  });
}
getTxpoolContent_2 = getTxpoolContent$2.getTxpoolContent = getTxpoolContent;
const getTxpoolContent$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getTxpoolContent$2,
  get getTxpoolContent() {
    return getTxpoolContent_2;
  }
}, [getTxpoolContent$2]);
const require$$3$7 = /* @__PURE__ */ getAugmentedNamespace(getTxpoolContent$1);
var getTxpoolStatus$2 = {};
Object.defineProperty(getTxpoolStatus$2, "__esModule", { value: true });
var getTxpoolStatus_2 = getTxpoolStatus$2.getTxpoolStatus = void 0;
const fromHex_js_1$2 = requireFromHex();
async function getTxpoolStatus(client2) {
  const { pending, queued } = await client2.request({
    method: "txpool_status"
  });
  return {
    pending: (0, fromHex_js_1$2.hexToNumber)(pending),
    queued: (0, fromHex_js_1$2.hexToNumber)(queued)
  };
}
getTxpoolStatus_2 = getTxpoolStatus$2.getTxpoolStatus = getTxpoolStatus;
const getTxpoolStatus$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getTxpoolStatus$2,
  get getTxpoolStatus() {
    return getTxpoolStatus_2;
  }
}, [getTxpoolStatus$2]);
const require$$4$6 = /* @__PURE__ */ getAugmentedNamespace(getTxpoolStatus$1);
var impersonateAccount$2 = {};
Object.defineProperty(impersonateAccount$2, "__esModule", { value: true });
var impersonateAccount_2 = impersonateAccount$2.impersonateAccount = void 0;
async function impersonateAccount(client2, { address: address2 }) {
  await client2.request({
    method: `${client2.mode}_impersonateAccount`,
    params: [address2]
  });
}
impersonateAccount_2 = impersonateAccount$2.impersonateAccount = impersonateAccount;
const impersonateAccount$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: impersonateAccount$2,
  get impersonateAccount() {
    return impersonateAccount_2;
  }
}, [impersonateAccount$2]);
const require$$5$5 = /* @__PURE__ */ getAugmentedNamespace(impersonateAccount$1);
var increaseTime$2 = {};
Object.defineProperty(increaseTime$2, "__esModule", { value: true });
var increaseTime_2 = increaseTime$2.increaseTime = void 0;
const toHex_js_1$f = requireToHex();
async function increaseTime(client2, { seconds }) {
  return await client2.request({
    method: "evm_increaseTime",
    params: [(0, toHex_js_1$f.numberToHex)(seconds)]
  });
}
increaseTime_2 = increaseTime$2.increaseTime = increaseTime;
const increaseTime$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: increaseTime$2,
  get increaseTime() {
    return increaseTime_2;
  }
}, [increaseTime$2]);
const require$$6$4 = /* @__PURE__ */ getAugmentedNamespace(increaseTime$1);
var inspectTxpool$2 = {};
Object.defineProperty(inspectTxpool$2, "__esModule", { value: true });
var inspectTxpool_2 = inspectTxpool$2.inspectTxpool = void 0;
async function inspectTxpool(client2) {
  return await client2.request({
    method: "txpool_inspect"
  });
}
inspectTxpool_2 = inspectTxpool$2.inspectTxpool = inspectTxpool;
const inspectTxpool$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: inspectTxpool$2,
  get inspectTxpool() {
    return inspectTxpool_2;
  }
}, [inspectTxpool$2]);
const require$$7$4 = /* @__PURE__ */ getAugmentedNamespace(inspectTxpool$1);
var loadState$2 = {};
Object.defineProperty(loadState$2, "__esModule", { value: true });
var loadState_2 = loadState$2.loadState = void 0;
async function loadState(client2, { state }) {
  await client2.request({
    method: `${client2.mode}_loadState`,
    params: [state]
  });
}
loadState_2 = loadState$2.loadState = loadState;
const loadState$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: loadState$2,
  get loadState() {
    return loadState_2;
  }
}, [loadState$2]);
const require$$8$1 = /* @__PURE__ */ getAugmentedNamespace(loadState$1);
var mine$2 = {};
Object.defineProperty(mine$2, "__esModule", { value: true });
var mine_2 = mine$2.mine = void 0;
const toHex_js_1$e = requireToHex();
async function mine(client2, { blocks, interval }) {
  if (client2.mode === "ganache")
    await client2.request({
      method: "evm_mine",
      params: [{ blocks: (0, toHex_js_1$e.numberToHex)(blocks) }]
    });
  else
    await client2.request({
      method: `${client2.mode}_mine`,
      params: [(0, toHex_js_1$e.numberToHex)(blocks), (0, toHex_js_1$e.numberToHex)(interval || 0)]
    });
}
mine_2 = mine$2.mine = mine;
const mine$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: mine$2,
  get mine() {
    return mine_2;
  }
}, [mine$2]);
const require$$9$2 = /* @__PURE__ */ getAugmentedNamespace(mine$1);
var removeBlockTimestampInterval$2 = {};
Object.defineProperty(removeBlockTimestampInterval$2, "__esModule", { value: true });
var removeBlockTimestampInterval_2 = removeBlockTimestampInterval$2.removeBlockTimestampInterval = void 0;
async function removeBlockTimestampInterval(client2) {
  await client2.request({
    method: `${client2.mode}_removeBlockTimestampInterval`
  });
}
removeBlockTimestampInterval_2 = removeBlockTimestampInterval$2.removeBlockTimestampInterval = removeBlockTimestampInterval;
const removeBlockTimestampInterval$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: removeBlockTimestampInterval$2,
  get removeBlockTimestampInterval() {
    return removeBlockTimestampInterval_2;
  }
}, [removeBlockTimestampInterval$2]);
const require$$10$2 = /* @__PURE__ */ getAugmentedNamespace(removeBlockTimestampInterval$1);
var reset$2 = {};
Object.defineProperty(reset$2, "__esModule", { value: true });
var reset_2 = reset$2.reset = void 0;
async function reset(client2, { blockNumber, jsonRpcUrl } = {}) {
  await client2.request({
    method: `${client2.mode}_reset`,
    params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }]
  });
}
reset_2 = reset$2.reset = reset;
const reset$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: reset$2,
  get reset() {
    return reset_2;
  }
}, [reset$2]);
const require$$11$1 = /* @__PURE__ */ getAugmentedNamespace(reset$1);
var revert$2 = {};
Object.defineProperty(revert$2, "__esModule", { value: true });
var revert_2 = revert$2.revert = void 0;
async function revert(client2, { id: id2 }) {
  await client2.request({
    method: "evm_revert",
    params: [id2]
  });
}
revert_2 = revert$2.revert = revert;
const revert$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: revert$2,
  get revert() {
    return revert_2;
  }
}, [revert$2]);
const require$$12$2 = /* @__PURE__ */ getAugmentedNamespace(revert$1);
var sendUnsignedTransaction$2 = {};
Object.defineProperty(sendUnsignedTransaction$2, "__esModule", { value: true });
var sendUnsignedTransaction_2 = sendUnsignedTransaction$2.sendUnsignedTransaction = void 0;
const extract_js_1 = require$$0$J;
const transactionRequest_js_1 = require$$55;
async function sendUnsignedTransaction(client2, args) {
  const { accessList, data: data2, from: from2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
  const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
  const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
  const request2 = format({
    ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
    accessList,
    data: data2,
    from: from2,
    gas,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    to,
    value
  });
  const hash2 = await client2.request({
    method: "eth_sendUnsignedTransaction",
    params: [request2]
  });
  return hash2;
}
sendUnsignedTransaction_2 = sendUnsignedTransaction$2.sendUnsignedTransaction = sendUnsignedTransaction;
const sendUnsignedTransaction$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: sendUnsignedTransaction$2,
  get sendUnsignedTransaction() {
    return sendUnsignedTransaction_2;
  }
}, [sendUnsignedTransaction$2]);
const require$$13$2 = /* @__PURE__ */ getAugmentedNamespace(sendUnsignedTransaction$1);
var setAutomine$2 = {};
Object.defineProperty(setAutomine$2, "__esModule", { value: true });
var setAutomine_2 = setAutomine$2.setAutomine = void 0;
async function setAutomine(client2, enabled) {
  if (client2.mode === "ganache") {
    if (enabled)
      await client2.request({ method: "miner_start" });
    else
      await client2.request({ method: "miner_stop" });
  } else
    await client2.request({
      method: "evm_setAutomine",
      params: [enabled]
    });
}
setAutomine_2 = setAutomine$2.setAutomine = setAutomine;
const setAutomine$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setAutomine$2,
  get setAutomine() {
    return setAutomine_2;
  }
}, [setAutomine$2]);
const require$$14$1 = /* @__PURE__ */ getAugmentedNamespace(setAutomine$1);
var setBalance$2 = {};
Object.defineProperty(setBalance$2, "__esModule", { value: true });
var setBalance_2 = setBalance$2.setBalance = void 0;
const toHex_js_1$d = requireToHex();
async function setBalance(client2, { address: address2, value }) {
  if (client2.mode === "ganache")
    await client2.request({
      method: "evm_setAccountBalance",
      params: [address2, (0, toHex_js_1$d.numberToHex)(value)]
    });
  else
    await client2.request({
      method: `${client2.mode}_setBalance`,
      params: [address2, (0, toHex_js_1$d.numberToHex)(value)]
    });
}
setBalance_2 = setBalance$2.setBalance = setBalance;
const setBalance$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setBalance$2,
  get setBalance() {
    return setBalance_2;
  }
}, [setBalance$2]);
const require$$15$1 = /* @__PURE__ */ getAugmentedNamespace(setBalance$1);
var setBlockGasLimit$2 = {};
Object.defineProperty(setBlockGasLimit$2, "__esModule", { value: true });
var setBlockGasLimit_2 = setBlockGasLimit$2.setBlockGasLimit = void 0;
const toHex_js_1$c = requireToHex();
async function setBlockGasLimit(client2, { gasLimit }) {
  await client2.request({
    method: "evm_setBlockGasLimit",
    params: [(0, toHex_js_1$c.numberToHex)(gasLimit)]
  });
}
setBlockGasLimit_2 = setBlockGasLimit$2.setBlockGasLimit = setBlockGasLimit;
const setBlockGasLimit$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setBlockGasLimit$2,
  get setBlockGasLimit() {
    return setBlockGasLimit_2;
  }
}, [setBlockGasLimit$2]);
const require$$16 = /* @__PURE__ */ getAugmentedNamespace(setBlockGasLimit$1);
var setBlockTimestampInterval$2 = {};
Object.defineProperty(setBlockTimestampInterval$2, "__esModule", { value: true });
var setBlockTimestampInterval_2 = setBlockTimestampInterval$2.setBlockTimestampInterval = void 0;
async function setBlockTimestampInterval(client2, { interval }) {
  const interval_ = (() => {
    if (client2.mode === "hardhat")
      return interval * 1e3;
    return interval;
  })();
  await client2.request({
    method: `${client2.mode}_setBlockTimestampInterval`,
    params: [interval_]
  });
}
setBlockTimestampInterval_2 = setBlockTimestampInterval$2.setBlockTimestampInterval = setBlockTimestampInterval;
const setBlockTimestampInterval$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setBlockTimestampInterval$2,
  get setBlockTimestampInterval() {
    return setBlockTimestampInterval_2;
  }
}, [setBlockTimestampInterval$2]);
const require$$17$1 = /* @__PURE__ */ getAugmentedNamespace(setBlockTimestampInterval$1);
var setCode$2 = {};
Object.defineProperty(setCode$2, "__esModule", { value: true });
var setCode_2 = setCode$2.setCode = void 0;
async function setCode(client2, { address: address2, bytecode }) {
  await client2.request({
    method: `${client2.mode}_setCode`,
    params: [address2, bytecode]
  });
}
setCode_2 = setCode$2.setCode = setCode;
const setCode$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setCode$2,
  get setCode() {
    return setCode_2;
  }
}, [setCode$2]);
const require$$18$1 = /* @__PURE__ */ getAugmentedNamespace(setCode$1);
var setCoinbase$2 = {};
Object.defineProperty(setCoinbase$2, "__esModule", { value: true });
var setCoinbase_2 = setCoinbase$2.setCoinbase = void 0;
async function setCoinbase(client2, { address: address2 }) {
  await client2.request({
    method: `${client2.mode}_setCoinbase`,
    params: [address2]
  });
}
setCoinbase_2 = setCoinbase$2.setCoinbase = setCoinbase;
const setCoinbase$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setCoinbase$2,
  get setCoinbase() {
    return setCoinbase_2;
  }
}, [setCoinbase$2]);
const require$$19 = /* @__PURE__ */ getAugmentedNamespace(setCoinbase$1);
var setIntervalMining$2 = {};
Object.defineProperty(setIntervalMining$2, "__esModule", { value: true });
var setIntervalMining_2 = setIntervalMining$2.setIntervalMining = void 0;
async function setIntervalMining(client2, { interval }) {
  const interval_ = (() => {
    if (client2.mode === "hardhat")
      return interval * 1e3;
    return interval;
  })();
  await client2.request({
    method: "evm_setIntervalMining",
    params: [interval_]
  });
}
setIntervalMining_2 = setIntervalMining$2.setIntervalMining = setIntervalMining;
const setIntervalMining$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setIntervalMining$2,
  get setIntervalMining() {
    return setIntervalMining_2;
  }
}, [setIntervalMining$2]);
const require$$20 = /* @__PURE__ */ getAugmentedNamespace(setIntervalMining$1);
var setLoggingEnabled$2 = {};
Object.defineProperty(setLoggingEnabled$2, "__esModule", { value: true });
var setLoggingEnabled_2 = setLoggingEnabled$2.setLoggingEnabled = void 0;
async function setLoggingEnabled(client2, enabled) {
  await client2.request({
    method: `${client2.mode}_setLoggingEnabled`,
    params: [enabled]
  });
}
setLoggingEnabled_2 = setLoggingEnabled$2.setLoggingEnabled = setLoggingEnabled;
const setLoggingEnabled$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setLoggingEnabled$2,
  get setLoggingEnabled() {
    return setLoggingEnabled_2;
  }
}, [setLoggingEnabled$2]);
const require$$21 = /* @__PURE__ */ getAugmentedNamespace(setLoggingEnabled$1);
var setMinGasPrice$2 = {};
Object.defineProperty(setMinGasPrice$2, "__esModule", { value: true });
var setMinGasPrice_2 = setMinGasPrice$2.setMinGasPrice = void 0;
const toHex_js_1$b = requireToHex();
async function setMinGasPrice(client2, { gasPrice }) {
  await client2.request({
    method: `${client2.mode}_setMinGasPrice`,
    params: [(0, toHex_js_1$b.numberToHex)(gasPrice)]
  });
}
setMinGasPrice_2 = setMinGasPrice$2.setMinGasPrice = setMinGasPrice;
const setMinGasPrice$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setMinGasPrice$2,
  get setMinGasPrice() {
    return setMinGasPrice_2;
  }
}, [setMinGasPrice$2]);
const require$$22 = /* @__PURE__ */ getAugmentedNamespace(setMinGasPrice$1);
var setNextBlockBaseFeePerGas$2 = {};
Object.defineProperty(setNextBlockBaseFeePerGas$2, "__esModule", { value: true });
var setNextBlockBaseFeePerGas_2 = setNextBlockBaseFeePerGas$2.setNextBlockBaseFeePerGas = void 0;
const toHex_js_1$a = requireToHex();
async function setNextBlockBaseFeePerGas(client2, { baseFeePerGas }) {
  await client2.request({
    method: `${client2.mode}_setNextBlockBaseFeePerGas`,
    params: [(0, toHex_js_1$a.numberToHex)(baseFeePerGas)]
  });
}
setNextBlockBaseFeePerGas_2 = setNextBlockBaseFeePerGas$2.setNextBlockBaseFeePerGas = setNextBlockBaseFeePerGas;
const setNextBlockBaseFeePerGas$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setNextBlockBaseFeePerGas$2,
  get setNextBlockBaseFeePerGas() {
    return setNextBlockBaseFeePerGas_2;
  }
}, [setNextBlockBaseFeePerGas$2]);
const require$$23 = /* @__PURE__ */ getAugmentedNamespace(setNextBlockBaseFeePerGas$1);
var setNextBlockTimestamp$2 = {};
Object.defineProperty(setNextBlockTimestamp$2, "__esModule", { value: true });
var setNextBlockTimestamp_2 = setNextBlockTimestamp$2.setNextBlockTimestamp = void 0;
const toHex_js_1$9 = requireToHex();
async function setNextBlockTimestamp(client2, { timestamp }) {
  await client2.request({
    method: "evm_setNextBlockTimestamp",
    params: [(0, toHex_js_1$9.numberToHex)(timestamp)]
  });
}
setNextBlockTimestamp_2 = setNextBlockTimestamp$2.setNextBlockTimestamp = setNextBlockTimestamp;
const setNextBlockTimestamp$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setNextBlockTimestamp$2,
  get setNextBlockTimestamp() {
    return setNextBlockTimestamp_2;
  }
}, [setNextBlockTimestamp$2]);
const require$$24 = /* @__PURE__ */ getAugmentedNamespace(setNextBlockTimestamp$1);
var setNonce$2 = {};
Object.defineProperty(setNonce$2, "__esModule", { value: true });
var setNonce_2 = setNonce$2.setNonce = void 0;
const toHex_js_1$8 = requireToHex();
async function setNonce(client2, { address: address2, nonce }) {
  await client2.request({
    method: `${client2.mode}_setNonce`,
    params: [address2, (0, toHex_js_1$8.numberToHex)(nonce)]
  });
}
setNonce_2 = setNonce$2.setNonce = setNonce;
const setNonce$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setNonce$2,
  get setNonce() {
    return setNonce_2;
  }
}, [setNonce$2]);
const require$$25 = /* @__PURE__ */ getAugmentedNamespace(setNonce$1);
var setRpcUrl$2 = {};
Object.defineProperty(setRpcUrl$2, "__esModule", { value: true });
var setRpcUrl_2 = setRpcUrl$2.setRpcUrl = void 0;
async function setRpcUrl(client2, jsonRpcUrl) {
  await client2.request({
    method: `${client2.mode}_setRpcUrl`,
    params: [jsonRpcUrl]
  });
}
setRpcUrl_2 = setRpcUrl$2.setRpcUrl = setRpcUrl;
const setRpcUrl$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setRpcUrl$2,
  get setRpcUrl() {
    return setRpcUrl_2;
  }
}, [setRpcUrl$2]);
const require$$26 = /* @__PURE__ */ getAugmentedNamespace(setRpcUrl$1);
var setStorageAt$2 = {};
Object.defineProperty(setStorageAt$2, "__esModule", { value: true });
var setStorageAt_2 = setStorageAt$2.setStorageAt = void 0;
const toHex_js_1$7 = requireToHex();
async function setStorageAt(client2, { address: address2, index: index2, value }) {
  await client2.request({
    method: `${client2.mode}_setStorageAt`,
    params: [
      address2,
      typeof index2 === "number" ? (0, toHex_js_1$7.numberToHex)(index2) : index2,
      value
    ]
  });
}
setStorageAt_2 = setStorageAt$2.setStorageAt = setStorageAt;
const setStorageAt$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: setStorageAt$2,
  get setStorageAt() {
    return setStorageAt_2;
  }
}, [setStorageAt$2]);
const require$$27 = /* @__PURE__ */ getAugmentedNamespace(setStorageAt$1);
var snapshot$2 = {};
Object.defineProperty(snapshot$2, "__esModule", { value: true });
var snapshot_2 = snapshot$2.snapshot = void 0;
async function snapshot(client2) {
  return await client2.request({
    method: "evm_snapshot"
  });
}
snapshot_2 = snapshot$2.snapshot = snapshot;
const snapshot$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: snapshot$2,
  get snapshot() {
    return snapshot_2;
  }
}, [snapshot$2]);
const require$$28 = /* @__PURE__ */ getAugmentedNamespace(snapshot$1);
var stopImpersonatingAccount$2 = {};
Object.defineProperty(stopImpersonatingAccount$2, "__esModule", { value: true });
var stopImpersonatingAccount_2 = stopImpersonatingAccount$2.stopImpersonatingAccount = void 0;
async function stopImpersonatingAccount(client2, { address: address2 }) {
  await client2.request({
    method: `${client2.mode}_stopImpersonatingAccount`,
    params: [address2]
  });
}
stopImpersonatingAccount_2 = stopImpersonatingAccount$2.stopImpersonatingAccount = stopImpersonatingAccount;
const stopImpersonatingAccount$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: stopImpersonatingAccount$2,
  get stopImpersonatingAccount() {
    return stopImpersonatingAccount_2;
  }
}, [stopImpersonatingAccount$2]);
const require$$29 = /* @__PURE__ */ getAugmentedNamespace(stopImpersonatingAccount$1);
Object.defineProperty(test$2, "__esModule", { value: true });
var testActions_1 = test$2.testActions = void 0;
const dropTransaction_js_1 = require$$0$u;
const dumpState_js_1 = require$$1$e;
const getAutomine_js_1 = require$$2$7;
const getTxpoolContent_js_1 = require$$3$7;
const getTxpoolStatus_js_1 = require$$4$6;
const impersonateAccount_js_1 = require$$5$5;
const increaseTime_js_1 = require$$6$4;
const inspectTxpool_js_1 = require$$7$4;
const loadState_js_1 = require$$8$1;
const mine_js_1 = require$$9$2;
const removeBlockTimestampInterval_js_1 = require$$10$2;
const reset_js_1 = require$$11$1;
const revert_js_1 = require$$12$2;
const sendUnsignedTransaction_js_1 = require$$13$2;
const setAutomine_js_1 = require$$14$1;
const setBalance_js_1 = require$$15$1;
const setBlockGasLimit_js_1 = require$$16;
const setBlockTimestampInterval_js_1 = require$$17$1;
const setCode_js_1 = require$$18$1;
const setCoinbase_js_1 = require$$19;
const setIntervalMining_js_1 = require$$20;
const setLoggingEnabled_js_1 = require$$21;
const setMinGasPrice_js_1 = require$$22;
const setNextBlockBaseFeePerGas_js_1 = require$$23;
const setNextBlockTimestamp_js_1 = require$$24;
const setNonce_js_1 = require$$25;
const setRpcUrl_js_1 = require$$26;
const setStorageAt_js_1 = require$$27;
const snapshot_js_1 = require$$28;
const stopImpersonatingAccount_js_1 = require$$29;
function testActions({ mode: mode2 }) {
  return (client_) => {
    const client2 = client_.extend(() => ({
      mode: mode2
    }));
    return {
      dropTransaction: (args) => (0, dropTransaction_js_1.dropTransaction)(client2, args),
      dumpState: () => (0, dumpState_js_1.dumpState)(client2),
      getAutomine: () => (0, getAutomine_js_1.getAutomine)(client2),
      getTxpoolContent: () => (0, getTxpoolContent_js_1.getTxpoolContent)(client2),
      getTxpoolStatus: () => (0, getTxpoolStatus_js_1.getTxpoolStatus)(client2),
      impersonateAccount: (args) => (0, impersonateAccount_js_1.impersonateAccount)(client2, args),
      increaseTime: (args) => (0, increaseTime_js_1.increaseTime)(client2, args),
      inspectTxpool: () => (0, inspectTxpool_js_1.inspectTxpool)(client2),
      loadState: (args) => (0, loadState_js_1.loadState)(client2, args),
      mine: (args) => (0, mine_js_1.mine)(client2, args),
      removeBlockTimestampInterval: () => (0, removeBlockTimestampInterval_js_1.removeBlockTimestampInterval)(client2),
      reset: (args) => (0, reset_js_1.reset)(client2, args),
      revert: (args) => (0, revert_js_1.revert)(client2, args),
      sendUnsignedTransaction: (args) => (0, sendUnsignedTransaction_js_1.sendUnsignedTransaction)(client2, args),
      setAutomine: (args) => (0, setAutomine_js_1.setAutomine)(client2, args),
      setBalance: (args) => (0, setBalance_js_1.setBalance)(client2, args),
      setBlockGasLimit: (args) => (0, setBlockGasLimit_js_1.setBlockGasLimit)(client2, args),
      setBlockTimestampInterval: (args) => (0, setBlockTimestampInterval_js_1.setBlockTimestampInterval)(client2, args),
      setCode: (args) => (0, setCode_js_1.setCode)(client2, args),
      setCoinbase: (args) => (0, setCoinbase_js_1.setCoinbase)(client2, args),
      setIntervalMining: (args) => (0, setIntervalMining_js_1.setIntervalMining)(client2, args),
      setLoggingEnabled: (args) => (0, setLoggingEnabled_js_1.setLoggingEnabled)(client2, args),
      setMinGasPrice: (args) => (0, setMinGasPrice_js_1.setMinGasPrice)(client2, args),
      setNextBlockBaseFeePerGas: (args) => (0, setNextBlockBaseFeePerGas_js_1.setNextBlockBaseFeePerGas)(client2, args),
      setNextBlockTimestamp: (args) => (0, setNextBlockTimestamp_js_1.setNextBlockTimestamp)(client2, args),
      setNonce: (args) => (0, setNonce_js_1.setNonce)(client2, args),
      setRpcUrl: (args) => (0, setRpcUrl_js_1.setRpcUrl)(client2, args),
      setStorageAt: (args) => (0, setStorageAt_js_1.setStorageAt)(client2, args),
      snapshot: () => (0, snapshot_js_1.snapshot)(client2),
      stopImpersonatingAccount: (args) => (0, stopImpersonatingAccount_js_1.stopImpersonatingAccount)(client2, args)
    };
  };
}
testActions_1 = test$2.testActions = testActions;
const test$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: test$2,
  get testActions() {
    return testActions_1;
  }
}, [test$2]);
const require$$9$1 = /* @__PURE__ */ getAugmentedNamespace(test$1);
Object.defineProperty(createTestClient$2, "__esModule", { value: true });
var createTestClient_2 = createTestClient$2.createTestClient = void 0;
const createClient_js_1 = require$$2$c;
const test_js_1 = require$$9$1;
function createTestClient(parameters) {
  const { key = "test", name: name2 = "Test Client", mode: mode2 } = parameters;
  const client2 = (0, createClient_js_1.createClient)({
    ...parameters,
    key,
    name: name2,
    type: "testClient"
  });
  return client2.extend((config2) => ({
    mode: mode2,
    ...(0, test_js_1.testActions)({ mode: mode2 })(config2)
  }));
}
createTestClient_2 = createTestClient$2.createTestClient = createTestClient;
const createTestClient$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get createTestClient() {
    return createTestClient_2;
  },
  default: createTestClient$2
}, [createTestClient$2]);
const require$$7$3 = /* @__PURE__ */ getAugmentedNamespace(createTestClient$1);
var wallet$2 = {};
var addChain$2 = {};
Object.defineProperty(addChain$2, "__esModule", { value: true });
var addChain_2 = addChain$2.addChain = void 0;
const toHex_js_1$6 = requireToHex();
async function addChain(client2, { chain: chain2 }) {
  const { id: id2, name: name2, nativeCurrency, rpcUrls, blockExplorers } = chain2;
  await client2.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: (0, toHex_js_1$6.numberToHex)(id2),
        chainName: name2,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
      }
    ]
  });
}
addChain_2 = addChain$2.addChain = addChain;
const addChain$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get addChain() {
    return addChain_2;
  },
  default: addChain$2
}, [addChain$2]);
const require$$1$d = /* @__PURE__ */ getAugmentedNamespace(addChain$1);
var deployContract$2 = {};
Object.defineProperty(deployContract$2, "__esModule", { value: true });
var deployContract_2 = deployContract$2.deployContract = void 0;
const encodeDeployData_js_1 = require$$48;
const sendTransaction_js_1 = require$$9$4;
function deployContract(walletClient, { abi: abi2, args, bytecode, ...request2 }) {
  const calldata = (0, encodeDeployData_js_1.encodeDeployData)({
    abi: abi2,
    args,
    bytecode
  });
  return (0, sendTransaction_js_1.sendTransaction)(walletClient, {
    ...request2,
    data: calldata
  });
}
deployContract_2 = deployContract$2.deployContract = deployContract;
const deployContract$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: deployContract$2,
  get deployContract() {
    return deployContract_2;
  }
}, [deployContract$2]);
const require$$2$6 = /* @__PURE__ */ getAugmentedNamespace(deployContract$1);
var getAddresses$2 = {};
Object.defineProperty(getAddresses$2, "__esModule", { value: true });
var getAddresses_2 = getAddresses$2.getAddresses = void 0;
const getAddress_js_1$1 = require$$91;
async function getAddresses(client2) {
  if (client2.account?.type === "local")
    return [client2.account.address];
  const addresses = await client2.request({ method: "eth_accounts" });
  return addresses.map((address2) => (0, getAddress_js_1$1.checksumAddress)(address2));
}
getAddresses_2 = getAddresses$2.getAddresses = getAddresses;
const getAddresses$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getAddresses$2,
  get getAddresses() {
    return getAddresses_2;
  }
}, [getAddresses$2]);
const require$$3$6 = /* @__PURE__ */ getAugmentedNamespace(getAddresses$1);
var getPermissions$2 = {};
Object.defineProperty(getPermissions$2, "__esModule", { value: true });
var getPermissions_2 = getPermissions$2.getPermissions = void 0;
async function getPermissions(client2) {
  const permissions2 = await client2.request({ method: "wallet_getPermissions" });
  return permissions2;
}
getPermissions_2 = getPermissions$2.getPermissions = getPermissions;
const getPermissions$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: getPermissions$2,
  get getPermissions() {
    return getPermissions_2;
  }
}, [getPermissions$2]);
const require$$4$5 = /* @__PURE__ */ getAugmentedNamespace(getPermissions$1);
var requestAddresses$2 = {};
Object.defineProperty(requestAddresses$2, "__esModule", { value: true });
var requestAddresses_2 = requestAddresses$2.requestAddresses = void 0;
const getAddress_js_1 = require$$91;
async function requestAddresses(client2) {
  const addresses = await client2.request({ method: "eth_requestAccounts" });
  return addresses.map((address2) => (0, getAddress_js_1.getAddress)(address2));
}
requestAddresses_2 = requestAddresses$2.requestAddresses = requestAddresses;
const requestAddresses$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: requestAddresses$2,
  get requestAddresses() {
    return requestAddresses_2;
  }
}, [requestAddresses$2]);
const require$$6$3 = /* @__PURE__ */ getAugmentedNamespace(requestAddresses$1);
var requestPermissions$2 = {};
Object.defineProperty(requestPermissions$2, "__esModule", { value: true });
var requestPermissions_2 = requestPermissions$2.requestPermissions = void 0;
async function requestPermissions(client2, permissions2) {
  return client2.request({
    method: "wallet_requestPermissions",
    params: [permissions2]
  });
}
requestPermissions_2 = requestPermissions$2.requestPermissions = requestPermissions;
const requestPermissions$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: requestPermissions$2,
  get requestPermissions() {
    return requestPermissions_2;
  }
}, [requestPermissions$2]);
const require$$7$2 = /* @__PURE__ */ getAugmentedNamespace(requestPermissions$1);
var signMessage$2 = {};
Object.defineProperty(signMessage$2, "__esModule", { value: true });
var signMessage_2 = signMessage$2.signMessage = void 0;
const parseAccount_js_1$1 = require$$0$L;
const account_js_1$1 = require$$1$o;
const toHex_js_1$5 = requireToHex();
async function signMessage(client2, { account: account_ = client2.account, message }) {
  if (!account_)
    throw new account_js_1$1.AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account2 = (0, parseAccount_js_1$1.parseAccount)(account_);
  if (account2.type === "local")
    return account2.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return (0, toHex_js_1$5.stringToHex)(message);
    if (message.raw instanceof Uint8Array)
      return (0, toHex_js_1$5.toHex)(message.raw);
    return message.raw;
  })();
  return client2.request({
    method: "personal_sign",
    params: [message_, account2.address]
  });
}
signMessage_2 = signMessage$2.signMessage = signMessage;
const signMessage$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: signMessage$2,
  get signMessage() {
    return signMessage_2;
  }
}, [signMessage$2]);
const require$$10$1 = /* @__PURE__ */ getAugmentedNamespace(signMessage$1);
var signTransaction = {};
var hasRequiredSignTransaction;
function requireSignTransaction() {
  if (hasRequiredSignTransaction)
    return signTransaction;
  hasRequiredSignTransaction = 1;
  Object.defineProperty(signTransaction, "__esModule", { value: true });
  signTransaction.signTransaction = void 0;
  const parseAccount_js_12 = require$$0$L;
  const account_js_12 = require$$1$o;
  const assertCurrentChain_js_12 = require$$81;
  const transactionRequest_js_12 = require$$55;
  const getAction_js_12 = require$$4$a;
  const index_js_1 = requireUtils();
  const assertRequest_js_12 = require$$74;
  const getChainId_js_12 = require$$0$H;
  async function signTransaction$12(client2, args) {
    const { account: account_ = client2.account, chain: chain2 = client2.chain, ...transaction2 } = args;
    if (!account_)
      throw new account_js_12.AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signTransaction"
      });
    const account2 = (0, parseAccount_js_12.parseAccount)(account_);
    (0, assertRequest_js_12.assertRequest)({
      account: account2,
      ...args
    });
    const chainId = await (0, getAction_js_12.getAction)(client2, getChainId_js_12.getChainId, "getChainId")({});
    if (chain2 !== null)
      (0, assertCurrentChain_js_12.assertCurrentChain)({
        currentChainId: chainId,
        chain: chain2
      });
    const formatters = chain2?.formatters || client2.chain?.formatters;
    const format = formatters?.transactionRequest?.format || transactionRequest_js_12.formatTransactionRequest;
    if (account2.type === "local")
      return account2.signTransaction({
        ...transaction2,
        chainId
      }, { serializer: client2.chain?.serializers?.transaction });
    return await client2.request({
      method: "eth_signTransaction",
      params: [
        {
          ...format(transaction2),
          chainId: (0, index_js_1.numberToHex)(chainId),
          from: account2.address
        }
      ]
    });
  }
  signTransaction.signTransaction = signTransaction$12;
  return signTransaction;
}
var signTypedData$2 = {};
Object.defineProperty(signTypedData$2, "__esModule", { value: true });
var signTypedData_2 = signTypedData$2.signTypedData = void 0;
const parseAccount_js_1 = require$$0$L;
const account_js_1 = require$$1$o;
const isHex_js_1 = require$$102;
const stringify_js_1 = require$$115;
const typedData_js_1 = requireTypedData();
async function signTypedData(client2, { account: account_ = client2.account, domain, message, primaryType, types: types_ }) {
  if (!account_)
    throw new account_js_1.AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const account2 = (0, parseAccount_js_1.parseAccount)(account_);
  const types2 = {
    EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
    ...types_
  };
  (0, typedData_js_1.validateTypedData)({
    domain,
    message,
    primaryType,
    types: types2
  });
  if (account2.type === "local")
    return account2.signTypedData({
      domain,
      primaryType,
      types: types2,
      message
    });
  const typedData2 = (0, stringify_js_1.stringify)({ domain: domain ?? {}, primaryType, types: types2, message }, (_2, value) => (0, isHex_js_1.isHex)(value) ? value.toLowerCase() : value);
  return client2.request({
    method: "eth_signTypedData_v4",
    params: [account2.address, typedData2]
  });
}
signTypedData_2 = signTypedData$2.signTypedData = signTypedData;
const signTypedData$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: signTypedData$2,
  get signTypedData() {
    return signTypedData_2;
  }
}, [signTypedData$2]);
const require$$12$1 = /* @__PURE__ */ getAugmentedNamespace(signTypedData$1);
var switchChain$2 = {};
Object.defineProperty(switchChain$2, "__esModule", { value: true });
var switchChain_2 = switchChain$2.switchChain = void 0;
const toHex_js_1$4 = requireToHex();
async function switchChain(client2, { id: id2 }) {
  await client2.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: (0, toHex_js_1$4.numberToHex)(id2)
      }
    ]
  });
}
switchChain_2 = switchChain$2.switchChain = switchChain;
const switchChain$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: switchChain$2,
  get switchChain() {
    return switchChain_2;
  }
}, [switchChain$2]);
const require$$13$1 = /* @__PURE__ */ getAugmentedNamespace(switchChain$1);
var watchAsset$2 = {};
Object.defineProperty(watchAsset$2, "__esModule", { value: true });
var watchAsset_2 = watchAsset$2.watchAsset = void 0;
async function watchAsset(client2, params) {
  const added = await client2.request({
    method: "wallet_watchAsset",
    params
  });
  return added;
}
watchAsset_2 = watchAsset$2.watchAsset = watchAsset;
const watchAsset$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: watchAsset$2,
  get watchAsset() {
    return watchAsset_2;
  }
}, [watchAsset$2]);
const require$$14 = /* @__PURE__ */ getAugmentedNamespace(watchAsset$1);
var hasRequiredWallet;
function requireWallet() {
  if (hasRequiredWallet)
    return wallet$2;
  hasRequiredWallet = 1;
  Object.defineProperty(wallet$2, "__esModule", { value: true });
  wallet$2.walletActions = void 0;
  const getChainId_js_12 = require$$0$H;
  const addChain_js_1 = require$$1$d;
  const deployContract_js_1 = require$$2$6;
  const getAddresses_js_1 = require$$3$6;
  const getPermissions_js_1 = require$$4$5;
  const prepareTransactionRequest_js_12 = requirePrepareTransactionRequest();
  const requestAddresses_js_1 = require$$6$3;
  const requestPermissions_js_1 = require$$7$2;
  const sendRawTransaction_js_12 = require$$8$3;
  const sendTransaction_js_12 = require$$9$4;
  const signMessage_js_1 = require$$10$1;
  const signTransaction_js_1 = requireSignTransaction();
  const signTypedData_js_1 = require$$12$1;
  const switchChain_js_1 = require$$13$1;
  const watchAsset_js_1 = require$$14;
  const writeContract_js_12 = require$$15$2;
  function walletActions2(client2) {
    return {
      addChain: (args) => (0, addChain_js_1.addChain)(client2, args),
      deployContract: (args) => (0, deployContract_js_1.deployContract)(client2, args),
      getAddresses: () => (0, getAddresses_js_1.getAddresses)(client2),
      getChainId: () => (0, getChainId_js_12.getChainId)(client2),
      getPermissions: () => (0, getPermissions_js_1.getPermissions)(client2),
      prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_12.prepareTransactionRequest)(client2, args),
      requestAddresses: () => (0, requestAddresses_js_1.requestAddresses)(client2),
      requestPermissions: (args) => (0, requestPermissions_js_1.requestPermissions)(client2, args),
      sendRawTransaction: (args) => (0, sendRawTransaction_js_12.sendRawTransaction)(client2, args),
      sendTransaction: (args) => (0, sendTransaction_js_12.sendTransaction)(client2, args),
      signMessage: (args) => (0, signMessage_js_1.signMessage)(client2, args),
      signTransaction: (args) => (0, signTransaction_js_1.signTransaction)(client2, args),
      signTypedData: (args) => (0, signTypedData_js_1.signTypedData)(client2, args),
      switchChain: (args) => (0, switchChain_js_1.switchChain)(client2, args),
      watchAsset: (args) => (0, watchAsset_js_1.watchAsset)(client2, args),
      writeContract: (args) => (0, writeContract_js_12.writeContract)(client2, args)
    };
  }
  wallet$2.walletActions = walletActions2;
  return wallet$2;
}
var createWalletClient = {};
var hasRequiredCreateWalletClient;
function requireCreateWalletClient() {
  if (hasRequiredCreateWalletClient)
    return createWalletClient;
  hasRequiredCreateWalletClient = 1;
  Object.defineProperty(createWalletClient, "__esModule", { value: true });
  createWalletClient.createWalletClient = void 0;
  const createClient_js_12 = require$$2$c;
  const wallet_js_1 = requireWallet();
  function createWalletClient$12(parameters) {
    const { key = "wallet", name: name2 = "Wallet Client", transport: transport2 } = parameters;
    const client2 = (0, createClient_js_12.createClient)({
      ...parameters,
      key,
      name: name2,
      transport: (opts) => transport2({ ...opts, retryCount: 0 }),
      type: "walletClient"
    });
    return client2.extend(wallet_js_1.walletActions);
  }
  createWalletClient.createWalletClient = createWalletClient$12;
  return createWalletClient;
}
var webSocket$2 = {};
Object.defineProperty(webSocket$2, "__esModule", { value: true });
var webSocket_2 = webSocket$2.webSocket = void 0;
const request_js_1 = require$$32$2;
const transport_js_1 = require$$36;
const rpc_js_1 = require$$2$b;
const createTransport_js_1 = require$$11$2;
function webSocket(url, config2 = {}) {
  const { key = "webSocket", name: name2 = "WebSocket JSON-RPC", retryDelay } = config2;
  return ({ chain: chain2, retryCount: retryCount_, timeout: timeout_ }) => {
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = url || chain2?.rpcUrls.default.webSocket?.[0];
    if (!url_)
      throw new transport_js_1.UrlRequiredError();
    return (0, createTransport_js_1.createTransport)({
      key,
      name: name2,
      async request({ method, params }) {
        const body = { method, params };
        const socket = await (0, rpc_js_1.getSocket)(url_);
        const { error, result } = await rpc_js_1.rpc.webSocketAsync(socket, {
          body,
          timeout
        });
        if (error)
          throw new request_js_1.RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "webSocket"
    }, {
      getSocket() {
        return (0, rpc_js_1.getSocket)(url_);
      },
      async subscribe({ params, onData, onError }) {
        const socket = await (0, rpc_js_1.getSocket)(url_);
        const { result: subscriptionId } = await new Promise((resolve, reject) => rpc_js_1.rpc.webSocket(socket, {
          body: {
            method: "eth_subscribe",
            params
          },
          onResponse(response) {
            if (response.error) {
              reject(response.error);
              onError?.(response.error);
              return;
            }
            if (typeof response.id === "number") {
              resolve(response);
              return;
            }
            if (response.method !== "eth_subscription")
              return;
            onData(response.params);
          }
        }));
        return {
          subscriptionId,
          async unsubscribe() {
            return new Promise((resolve) => rpc_js_1.rpc.webSocket(socket, {
              body: {
                method: "eth_unsubscribe",
                params: [subscriptionId]
              },
              onResponse: resolve
            }));
          }
        };
      }
    });
  };
}
webSocket_2 = webSocket$2.webSocket = webSocket;
const webSocket$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: webSocket$2,
  get webSocket() {
    return webSocket_2;
  }
}, [webSocket$2]);
const require$$13 = /* @__PURE__ */ getAugmentedNamespace(webSocket$1);
var address$1 = {};
Object.defineProperty(address$1, "__esModule", { value: true });
var zeroAddress = address$1.zeroAddress = void 0;
zeroAddress = address$1.zeroAddress = "0x0000000000000000000000000000000000000000";
const address = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: address$1,
  get zeroAddress() {
    return zeroAddress;
  }
}, [address$1]);
const require$$15 = /* @__PURE__ */ getAugmentedNamespace(address);
var number$2 = {};
Object.defineProperty(number$2, "__esModule", { value: true });
var minInt144 = number$2.minInt144 = minInt136 = number$2.minInt136 = minInt128 = number$2.minInt128 = minInt120 = number$2.minInt120 = minInt112 = number$2.minInt112 = minInt104 = number$2.minInt104 = minInt96 = number$2.minInt96 = minInt88 = number$2.minInt88 = minInt80 = number$2.minInt80 = minInt72 = number$2.minInt72 = minInt64 = number$2.minInt64 = minInt56 = number$2.minInt56 = minInt48 = number$2.minInt48 = minInt40 = number$2.minInt40 = minInt32 = number$2.minInt32 = minInt24 = number$2.minInt24 = minInt16 = number$2.minInt16 = minInt8 = number$2.minInt8 = maxInt256 = number$2.maxInt256 = maxInt248 = number$2.maxInt248 = maxInt240 = number$2.maxInt240 = maxInt232 = number$2.maxInt232 = maxInt224 = number$2.maxInt224 = maxInt216 = number$2.maxInt216 = maxInt208 = number$2.maxInt208 = maxInt200 = number$2.maxInt200 = maxInt192 = number$2.maxInt192 = maxInt184 = number$2.maxInt184 = maxInt176 = number$2.maxInt176 = maxInt168 = number$2.maxInt168 = maxInt160 = number$2.maxInt160 = maxInt152 = number$2.maxInt152 = maxInt144 = number$2.maxInt144 = maxInt136 = number$2.maxInt136 = maxInt128 = number$2.maxInt128 = maxInt120 = number$2.maxInt120 = maxInt112 = number$2.maxInt112 = maxInt104 = number$2.maxInt104 = maxInt96 = number$2.maxInt96 = maxInt88 = number$2.maxInt88 = maxInt80 = number$2.maxInt80 = maxInt72 = number$2.maxInt72 = maxInt64 = number$2.maxInt64 = maxInt56 = number$2.maxInt56 = maxInt48 = number$2.maxInt48 = maxInt40 = number$2.maxInt40 = maxInt32$1 = number$2.maxInt32 = maxInt24 = number$2.maxInt24 = maxInt16 = number$2.maxInt16 = maxInt8 = number$2.maxInt8 = void 0;
var maxUint256 = number$2.maxUint256 = maxUint248 = number$2.maxUint248 = maxUint240 = number$2.maxUint240 = maxUint232 = number$2.maxUint232 = maxUint224 = number$2.maxUint224 = maxUint216 = number$2.maxUint216 = maxUint208 = number$2.maxUint208 = maxUint200 = number$2.maxUint200 = maxUint192 = number$2.maxUint192 = maxUint184 = number$2.maxUint184 = maxUint176 = number$2.maxUint176 = maxUint168 = number$2.maxUint168 = maxUint160 = number$2.maxUint160 = maxUint152 = number$2.maxUint152 = maxUint144 = number$2.maxUint144 = maxUint136 = number$2.maxUint136 = maxUint128 = number$2.maxUint128 = maxUint120 = number$2.maxUint120 = maxUint112 = number$2.maxUint112 = maxUint104 = number$2.maxUint104 = maxUint96 = number$2.maxUint96 = maxUint88 = number$2.maxUint88 = maxUint80 = number$2.maxUint80 = maxUint72 = number$2.maxUint72 = maxUint64 = number$2.maxUint64 = maxUint56 = number$2.maxUint56 = maxUint48 = number$2.maxUint48 = maxUint40 = number$2.maxUint40 = maxUint32 = number$2.maxUint32 = maxUint24 = number$2.maxUint24 = maxUint16 = number$2.maxUint16 = maxUint8 = number$2.maxUint8 = minInt256 = number$2.minInt256 = minInt248 = number$2.minInt248 = minInt240 = number$2.minInt240 = minInt232 = number$2.minInt232 = minInt224 = number$2.minInt224 = minInt216 = number$2.minInt216 = minInt208 = number$2.minInt208 = minInt200 = number$2.minInt200 = minInt192 = number$2.minInt192 = minInt184 = number$2.minInt184 = minInt176 = number$2.minInt176 = minInt168 = number$2.minInt168 = minInt160 = number$2.minInt160 = minInt152 = number$2.minInt152 = void 0;
var maxInt8 = number$2.maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = number$2.maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = number$2.maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32$1 = number$2.maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = number$2.maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = number$2.maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = number$2.maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = number$2.maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = number$2.maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = number$2.maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = number$2.maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = number$2.maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = number$2.maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = number$2.maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = number$2.maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = number$2.maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = number$2.maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = number$2.maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = number$2.maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = number$2.maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = number$2.maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = number$2.maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = number$2.maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = number$2.maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = number$2.maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = number$2.maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = number$2.maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = number$2.maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = number$2.maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = number$2.maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = number$2.maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = number$2.maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = number$2.minInt8 = -(2n ** (8n - 1n));
var minInt16 = number$2.minInt16 = -(2n ** (16n - 1n));
var minInt24 = number$2.minInt24 = -(2n ** (24n - 1n));
var minInt32 = number$2.minInt32 = -(2n ** (32n - 1n));
var minInt40 = number$2.minInt40 = -(2n ** (40n - 1n));
var minInt48 = number$2.minInt48 = -(2n ** (48n - 1n));
var minInt56 = number$2.minInt56 = -(2n ** (56n - 1n));
var minInt64 = number$2.minInt64 = -(2n ** (64n - 1n));
var minInt72 = number$2.minInt72 = -(2n ** (72n - 1n));
var minInt80 = number$2.minInt80 = -(2n ** (80n - 1n));
var minInt88 = number$2.minInt88 = -(2n ** (88n - 1n));
var minInt96 = number$2.minInt96 = -(2n ** (96n - 1n));
var minInt104 = number$2.minInt104 = -(2n ** (104n - 1n));
var minInt112 = number$2.minInt112 = -(2n ** (112n - 1n));
var minInt120 = number$2.minInt120 = -(2n ** (120n - 1n));
var minInt128 = number$2.minInt128 = -(2n ** (128n - 1n));
var minInt136 = number$2.minInt136 = -(2n ** (136n - 1n));
minInt144 = number$2.minInt144 = -(2n ** (144n - 1n));
var minInt152 = number$2.minInt152 = -(2n ** (152n - 1n));
var minInt160 = number$2.minInt160 = -(2n ** (160n - 1n));
var minInt168 = number$2.minInt168 = -(2n ** (168n - 1n));
var minInt176 = number$2.minInt176 = -(2n ** (176n - 1n));
var minInt184 = number$2.minInt184 = -(2n ** (184n - 1n));
var minInt192 = number$2.minInt192 = -(2n ** (192n - 1n));
var minInt200 = number$2.minInt200 = -(2n ** (200n - 1n));
var minInt208 = number$2.minInt208 = -(2n ** (208n - 1n));
var minInt216 = number$2.minInt216 = -(2n ** (216n - 1n));
var minInt224 = number$2.minInt224 = -(2n ** (224n - 1n));
var minInt232 = number$2.minInt232 = -(2n ** (232n - 1n));
var minInt240 = number$2.minInt240 = -(2n ** (240n - 1n));
var minInt248 = number$2.minInt248 = -(2n ** (248n - 1n));
var minInt256 = number$2.minInt256 = -(2n ** (256n - 1n));
var maxUint8 = number$2.maxUint8 = 2n ** 8n - 1n;
var maxUint16 = number$2.maxUint16 = 2n ** 16n - 1n;
var maxUint24 = number$2.maxUint24 = 2n ** 24n - 1n;
var maxUint32 = number$2.maxUint32 = 2n ** 32n - 1n;
var maxUint40 = number$2.maxUint40 = 2n ** 40n - 1n;
var maxUint48 = number$2.maxUint48 = 2n ** 48n - 1n;
var maxUint56 = number$2.maxUint56 = 2n ** 56n - 1n;
var maxUint64 = number$2.maxUint64 = 2n ** 64n - 1n;
var maxUint72 = number$2.maxUint72 = 2n ** 72n - 1n;
var maxUint80 = number$2.maxUint80 = 2n ** 80n - 1n;
var maxUint88 = number$2.maxUint88 = 2n ** 88n - 1n;
var maxUint96 = number$2.maxUint96 = 2n ** 96n - 1n;
var maxUint104 = number$2.maxUint104 = 2n ** 104n - 1n;
var maxUint112 = number$2.maxUint112 = 2n ** 112n - 1n;
var maxUint120 = number$2.maxUint120 = 2n ** 120n - 1n;
var maxUint128 = number$2.maxUint128 = 2n ** 128n - 1n;
var maxUint136 = number$2.maxUint136 = 2n ** 136n - 1n;
var maxUint144 = number$2.maxUint144 = 2n ** 144n - 1n;
var maxUint152 = number$2.maxUint152 = 2n ** 152n - 1n;
var maxUint160 = number$2.maxUint160 = 2n ** 160n - 1n;
var maxUint168 = number$2.maxUint168 = 2n ** 168n - 1n;
var maxUint176 = number$2.maxUint176 = 2n ** 176n - 1n;
var maxUint184 = number$2.maxUint184 = 2n ** 184n - 1n;
var maxUint192 = number$2.maxUint192 = 2n ** 192n - 1n;
var maxUint200 = number$2.maxUint200 = 2n ** 200n - 1n;
var maxUint208 = number$2.maxUint208 = 2n ** 208n - 1n;
var maxUint216 = number$2.maxUint216 = 2n ** 216n - 1n;
var maxUint224 = number$2.maxUint224 = 2n ** 224n - 1n;
var maxUint232 = number$2.maxUint232 = 2n ** 232n - 1n;
var maxUint240 = number$2.maxUint240 = 2n ** 240n - 1n;
var maxUint248 = number$2.maxUint248 = 2n ** 248n - 1n;
maxUint256 = number$2.maxUint256 = 2n ** 256n - 1n;
const number$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: number$2,
  get maxInt104() {
    return maxInt104;
  },
  get maxInt112() {
    return maxInt112;
  },
  get maxInt120() {
    return maxInt120;
  },
  get maxInt128() {
    return maxInt128;
  },
  get maxInt136() {
    return maxInt136;
  },
  get maxInt144() {
    return maxInt144;
  },
  get maxInt152() {
    return maxInt152;
  },
  get maxInt16() {
    return maxInt16;
  },
  get maxInt160() {
    return maxInt160;
  },
  get maxInt168() {
    return maxInt168;
  },
  get maxInt176() {
    return maxInt176;
  },
  get maxInt184() {
    return maxInt184;
  },
  get maxInt192() {
    return maxInt192;
  },
  get maxInt200() {
    return maxInt200;
  },
  get maxInt208() {
    return maxInt208;
  },
  get maxInt216() {
    return maxInt216;
  },
  get maxInt224() {
    return maxInt224;
  },
  get maxInt232() {
    return maxInt232;
  },
  get maxInt24() {
    return maxInt24;
  },
  get maxInt240() {
    return maxInt240;
  },
  get maxInt248() {
    return maxInt248;
  },
  get maxInt256() {
    return maxInt256;
  },
  get maxInt32() {
    return maxInt32$1;
  },
  get maxInt40() {
    return maxInt40;
  },
  get maxInt48() {
    return maxInt48;
  },
  get maxInt56() {
    return maxInt56;
  },
  get maxInt64() {
    return maxInt64;
  },
  get maxInt72() {
    return maxInt72;
  },
  get maxInt8() {
    return maxInt8;
  },
  get maxInt80() {
    return maxInt80;
  },
  get maxInt88() {
    return maxInt88;
  },
  get maxInt96() {
    return maxInt96;
  },
  get maxUint104() {
    return maxUint104;
  },
  get maxUint112() {
    return maxUint112;
  },
  get maxUint120() {
    return maxUint120;
  },
  get maxUint128() {
    return maxUint128;
  },
  get maxUint136() {
    return maxUint136;
  },
  get maxUint144() {
    return maxUint144;
  },
  get maxUint152() {
    return maxUint152;
  },
  get maxUint16() {
    return maxUint16;
  },
  get maxUint160() {
    return maxUint160;
  },
  get maxUint168() {
    return maxUint168;
  },
  get maxUint176() {
    return maxUint176;
  },
  get maxUint184() {
    return maxUint184;
  },
  get maxUint192() {
    return maxUint192;
  },
  get maxUint200() {
    return maxUint200;
  },
  get maxUint208() {
    return maxUint208;
  },
  get maxUint216() {
    return maxUint216;
  },
  get maxUint224() {
    return maxUint224;
  },
  get maxUint232() {
    return maxUint232;
  },
  get maxUint24() {
    return maxUint24;
  },
  get maxUint240() {
    return maxUint240;
  },
  get maxUint248() {
    return maxUint248;
  },
  get maxUint256() {
    return maxUint256;
  },
  get maxUint32() {
    return maxUint32;
  },
  get maxUint40() {
    return maxUint40;
  },
  get maxUint48() {
    return maxUint48;
  },
  get maxUint56() {
    return maxUint56;
  },
  get maxUint64() {
    return maxUint64;
  },
  get maxUint72() {
    return maxUint72;
  },
  get maxUint8() {
    return maxUint8;
  },
  get maxUint80() {
    return maxUint80;
  },
  get maxUint88() {
    return maxUint88;
  },
  get maxUint96() {
    return maxUint96;
  },
  get minInt104() {
    return minInt104;
  },
  get minInt112() {
    return minInt112;
  },
  get minInt120() {
    return minInt120;
  },
  get minInt128() {
    return minInt128;
  },
  get minInt136() {
    return minInt136;
  },
  get minInt144() {
    return minInt144;
  },
  get minInt152() {
    return minInt152;
  },
  get minInt16() {
    return minInt16;
  },
  get minInt160() {
    return minInt160;
  },
  get minInt168() {
    return minInt168;
  },
  get minInt176() {
    return minInt176;
  },
  get minInt184() {
    return minInt184;
  },
  get minInt192() {
    return minInt192;
  },
  get minInt200() {
    return minInt200;
  },
  get minInt208() {
    return minInt208;
  },
  get minInt216() {
    return minInt216;
  },
  get minInt224() {
    return minInt224;
  },
  get minInt232() {
    return minInt232;
  },
  get minInt24() {
    return minInt24;
  },
  get minInt240() {
    return minInt240;
  },
  get minInt248() {
    return minInt248;
  },
  get minInt256() {
    return minInt256;
  },
  get minInt32() {
    return minInt32;
  },
  get minInt40() {
    return minInt40;
  },
  get minInt48() {
    return minInt48;
  },
  get minInt56() {
    return minInt56;
  },
  get minInt64() {
    return minInt64;
  },
  get minInt72() {
    return minInt72;
  },
  get minInt8() {
    return minInt8;
  },
  get minInt80() {
    return minInt80;
  },
  get minInt88() {
    return minInt88;
  },
  get minInt96() {
    return minInt96;
  }
}, [number$2]);
const require$$17 = /* @__PURE__ */ getAugmentedNamespace(number$1);
var bytes$1 = {};
Object.defineProperty(bytes$1, "__esModule", { value: true });
var zeroHash = bytes$1.zeroHash = void 0;
zeroHash = bytes$1.zeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
const bytes = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: bytes$1,
  get zeroHash() {
    return zeroHash;
  }
}, [bytes$1]);
const require$$18 = /* @__PURE__ */ getAugmentedNamespace(bytes);
var decodeDeployData$2 = {};
Object.defineProperty(decodeDeployData$2, "__esModule", { value: true });
var decodeDeployData_2 = decodeDeployData$2.decodeDeployData = void 0;
const abi_js_1 = requireAbi();
const decodeAbiParameters_js_1 = require$$41$1;
const docsPath = "/docs/contract/decodeDeployData";
function decodeDeployData({ abi: abi2, bytecode, data: data2 }) {
  if (data2 === bytecode)
    return { bytecode };
  const description2 = abi2.find((x2) => "type" in x2 && x2.type === "constructor");
  if (!description2)
    throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
  if (!("inputs" in description2))
    throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
  if (!description2.inputs || description2.inputs.length === 0)
    throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
  const args = (0, decodeAbiParameters_js_1.decodeAbiParameters)(description2.inputs, `0x${data2.replace(bytecode, "")}`);
  return { args, bytecode };
}
decodeDeployData_2 = decodeDeployData$2.decodeDeployData = decodeDeployData;
const decodeDeployData$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get decodeDeployData() {
    return decodeDeployData_2;
  },
  default: decodeDeployData$2
}, [decodeDeployData$2]);
const require$$42 = /* @__PURE__ */ getAugmentedNamespace(decodeDeployData$1);
var compactSignatureToSignature$2 = {};
Object.defineProperty(compactSignatureToSignature$2, "__esModule", { value: true });
var compactSignatureToSignature_2 = compactSignatureToSignature$2.compactSignatureToSignature = void 0;
const toBytes_js_1 = requireToBytes();
const toHex_js_1$3 = requireToHex();
function compactSignatureToSignature({ r: r2, yParityAndS }) {
  const yParityAndS_bytes = (0, toBytes_js_1.hexToBytes)(yParityAndS);
  const v2 = yParityAndS_bytes[0] & 128 ? 28n : 27n;
  const s = yParityAndS_bytes;
  if (v2 === 28n)
    s[0] &= 127;
  return { r: r2, s: (0, toHex_js_1$3.bytesToHex)(s), v: v2 };
}
compactSignatureToSignature_2 = compactSignatureToSignature$2.compactSignatureToSignature = compactSignatureToSignature;
const compactSignatureToSignature$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get compactSignatureToSignature() {
    return compactSignatureToSignature_2;
  },
  default: compactSignatureToSignature$2
}, [compactSignatureToSignature$2]);
const require$$61 = /* @__PURE__ */ getAugmentedNamespace(compactSignatureToSignature$1);
var hexToCompactSignature$2 = {};
Object.defineProperty(hexToCompactSignature$2, "__esModule", { value: true });
var hexToCompactSignature_2 = hexToCompactSignature$2.hexToCompactSignature = void 0;
const secp256k1_1$3 = require$$0$w;
const toHex_js_1$2 = requireToHex();
function hexToCompactSignature(signatureHex) {
  const { r: r2, s } = secp256k1_1$3.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
  return {
    r: (0, toHex_js_1$2.numberToHex)(r2, { size: 32 }),
    yParityAndS: (0, toHex_js_1$2.numberToHex)(s, { size: 32 })
  };
}
hexToCompactSignature_2 = hexToCompactSignature$2.hexToCompactSignature = hexToCompactSignature;
const hexToCompactSignature$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: hexToCompactSignature$2,
  get hexToCompactSignature() {
    return hexToCompactSignature_2;
  }
}, [hexToCompactSignature$2]);
const require$$62 = /* @__PURE__ */ getAugmentedNamespace(hexToCompactSignature$1);
var hexToSignature$2 = {};
Object.defineProperty(hexToSignature$2, "__esModule", { value: true });
var hexToSignature_2 = hexToSignature$2.hexToSignature = void 0;
const secp256k1_1$2 = require$$0$w;
const toHex_js_1$1 = requireToHex();
function hexToSignature(signatureHex) {
  const { r: r2, s } = secp256k1_1$2.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
  const v2 = BigInt(`0x${signatureHex.slice(130)}`);
  return { r: (0, toHex_js_1$1.numberToHex)(r2, { size: 32 }), s: (0, toHex_js_1$1.numberToHex)(s, { size: 32 }), v: v2 };
}
hexToSignature_2 = hexToSignature$2.hexToSignature = hexToSignature;
const hexToSignature$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: hexToSignature$2,
  get hexToSignature() {
    return hexToSignature_2;
  }
}, [hexToSignature$2]);
const require$$63 = /* @__PURE__ */ getAugmentedNamespace(hexToSignature$1);
var signatureToCompactSignature = {};
var hasRequiredSignatureToCompactSignature;
function requireSignatureToCompactSignature() {
  if (hasRequiredSignatureToCompactSignature)
    return signatureToCompactSignature;
  hasRequiredSignatureToCompactSignature = 1;
  Object.defineProperty(signatureToCompactSignature, "__esModule", { value: true });
  signatureToCompactSignature.signatureToCompactSignature = void 0;
  const index_js_1 = requireUtils();
  function signatureToCompactSignature$1(signature2) {
    const { r: r2, s, v: v2 } = signature2;
    const yParity = v2 - 27n;
    let yParityAndS = s;
    if (yParity === 1n) {
      const bytes2 = (0, index_js_1.hexToBytes)(s);
      bytes2[0] |= 128;
      yParityAndS = (0, index_js_1.bytesToHex)(bytes2);
    }
    return { r: r2, yParityAndS };
  }
  signatureToCompactSignature.signatureToCompactSignature = signatureToCompactSignature$1;
  return signatureToCompactSignature;
}
var compactSignatureToHex$2 = {};
Object.defineProperty(compactSignatureToHex$2, "__esModule", { value: true });
var compactSignatureToHex_2 = compactSignatureToHex$2.compactSignatureToHex = void 0;
const secp256k1_1$1 = require$$0$w;
const fromHex_js_1$1 = requireFromHex();
function compactSignatureToHex({ r: r2, yParityAndS }) {
  return `0x${new secp256k1_1$1.secp256k1.Signature((0, fromHex_js_1$1.hexToBigInt)(r2), (0, fromHex_js_1$1.hexToBigInt)(yParityAndS)).toCompactHex()}`;
}
compactSignatureToHex_2 = compactSignatureToHex$2.compactSignatureToHex = compactSignatureToHex;
const compactSignatureToHex$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get compactSignatureToHex() {
    return compactSignatureToHex_2;
  },
  default: compactSignatureToHex$2
}, [compactSignatureToHex$2]);
const require$$69 = /* @__PURE__ */ getAugmentedNamespace(compactSignatureToHex$1);
var signatureToHex$2 = {};
Object.defineProperty(signatureToHex$2, "__esModule", { value: true });
var signatureToHex_2 = signatureToHex$2.signatureToHex = void 0;
const secp256k1_1 = require$$0$w;
const fromHex_js_1 = requireFromHex();
const toHex_js_1 = requireToHex();
function signatureToHex({ r: r2, s, v: v2 }) {
  return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r2), (0, fromHex_js_1.hexToBigInt)(s)).toCompactHex()}${(0, toHex_js_1.toHex)(v2).slice(2)}`;
}
signatureToHex_2 = signatureToHex$2.signatureToHex = signatureToHex;
const signatureToHex$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: signatureToHex$2,
  get signatureToHex() {
    return signatureToHex_2;
  }
}, [signatureToHex$2]);
const require$$70 = /* @__PURE__ */ getAugmentedNamespace(signatureToHex$1);
var hasRequired_cjs;
function require_cjs() {
  if (hasRequired_cjs)
    return _cjs;
  hasRequired_cjs = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = exports.weiUnits = exports.gweiUnits = exports.etherUnits = exports.zeroAddress = exports.multicall3Abi = exports.webSocket = exports.createWalletClient = exports.createTransport = exports.walletActions = exports.testActions = exports.publicActions = exports.createTestClient = exports.createPublicClient = exports.http = exports.fallback = exports.custom = exports.createClient = exports.getContract = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.UnknownSignatureError = exports.UnknownTypeError = exports.SolidityProtectedKeywordError = exports.InvalidStructSignatureError = exports.InvalidSignatureError = exports.InvalidParenthesisError = exports.InvalidParameterError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.InvalidAbiItemError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = exports.CircularReferenceError = void 0;
    exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = void 0;
    exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiEventNotFoundError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingBytesSizeMismatchError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeTooSmallError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = exports.presignMessagePrefix = exports.zeroHash = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = void 0;
    exports.InvalidHexBooleanError = exports.IntegerOutOfRangeError = exports.InvalidBytesBooleanError = exports.DataLengthTooShortError = exports.DataLengthTooLongError = exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = exports.UserRejectedRequestError = exports.UnsupportedProviderMethodError = exports.UnknownRpcError = exports.UnauthorizedProviderError = exports.TransactionRejectedRpcError = exports.SwitchChainError = exports.RpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.ProviderRpcError = exports.ProviderDisconnectedError = exports.ParseRpcError = exports.MethodNotSupportedRpcError = exports.MethodNotFoundRpcError = exports.LimitExceededRpcError = exports.JsonRpcVersionUnsupportedError = exports.InvalidRequestRpcError = exports.InvalidParamsRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.ChainDisconnectedError = exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = exports.BlockNotFoundError = exports.BaseError = exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiEncodingTypeError = exports.InvalidAbiDecodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiFunctionSignatureNotFoundError = void 0;
    exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeDeployData = exports.decodeAbiParameters = exports.formatLog = exports.formatBlock = exports.defineBlock = exports.namehash = exports.labelhash = exports.UrlRequiredError = exports.SliceOffsetOutOfBoundsError = exports.SizeExceedsPaddingSizeError = exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = exports.InvalidAddressError = exports.WebSocketRequestError = exports.TimeoutError = exports.RpcRequestError = exports.HttpRequestError = exports.FilterTypeNotSupportedError = exports.UnknownNodeError = exports.TransactionTypeNotSupportedError = exports.TipAboveFeeCapError = exports.NonceTooLowError = exports.NonceTooHighError = exports.NonceMaxValueError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = exports.EstimateGasExecutionError = exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarUriResolutionError = exports.SizeOverflowError = exports.OffsetOutOfBoundsError = exports.InvalidHexValueError = void 0;
    exports.toHex = exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toBytes = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.verifyTypedData = exports.verifyMessage = exports.toRlp = exports.hexToRlp = exports.bytesToRlp = exports.signatureToHex = exports.compactSignatureToHex = exports.signatureToCompactSignature = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hexToSignature = exports.hexToCompactSignature = exports.compactSignatureToSignature = exports.hashTypedData = exports.hashDomain = exports.getTransactionType = exports.getSerializedTransactionType = exports.getCreateAddress = exports.getCreate2Address = exports.getContractAddress = exports.getAbiItem = exports.rpcTransactionType = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.formatTransactionReceipt = exports.defineTransactionReceipt = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = void 0;
    exports.parseUnits = exports.parseTransaction = exports.parseGwei = exports.parseEther = exports.padHex = exports.padBytes = exports.pad = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.isHex = exports.isHash = exports.isBytes = exports.isAddressEqual = exports.isAddress = exports.hashMessage = exports.getFunctionSignature = exports.getFunctionSelector = exports.getEventSignature = exports.getEventSelector = exports.getContractError = exports.getAddress = exports.checksumAddress = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.encodePacked = exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.concatHex = exports.concatBytes = exports.concat = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.bytesToBigInt = void 0;
    exports.getTypesForEIP712Domain = exports.domainSeparator = exports.validateTypedData = exports.trim = exports.stringify = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.serializeTransaction = exports.serializeAccessList = void 0;
    var abitype_12 = requireCjs();
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return abitype_12.CircularReferenceError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abitype_12.InvalidAbiParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abitype_12.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abitype_12.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abitype_12.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abitype_12.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return abitype_12.InvalidModifierError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return abitype_12.InvalidParameterError;
    } });
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return abitype_12.InvalidParenthesisError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return abitype_12.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return abitype_12.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abitype_12.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return abitype_12.UnknownTypeError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return abitype_12.UnknownSignatureError;
    } });
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return abitype_12.parseAbi;
    } });
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_12.parseAbiItem;
    } });
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_12.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_12.parseAbiParameters;
    } });
    var getContract_js_1 = require$$1$k;
    Object.defineProperty(exports, "getContract", { enumerable: true, get: function() {
      return getContract_js_1.getContract;
    } });
    var createClient_js_12 = require$$2$c;
    Object.defineProperty(exports, "createClient", { enumerable: true, get: function() {
      return createClient_js_12.createClient;
    } });
    var custom_js_1 = require$$3$d;
    Object.defineProperty(exports, "custom", { enumerable: true, get: function() {
      return custom_js_1.custom;
    } });
    var fallback_js_1 = require$$4$8;
    Object.defineProperty(exports, "fallback", { enumerable: true, get: function() {
      return fallback_js_1.fallback;
    } });
    var http_js_1 = require$$5$6;
    Object.defineProperty(exports, "http", { enumerable: true, get: function() {
      return http_js_1.http;
    } });
    var createPublicClient_js_1 = requireCreatePublicClient();
    Object.defineProperty(exports, "createPublicClient", { enumerable: true, get: function() {
      return createPublicClient_js_1.createPublicClient;
    } });
    var createTestClient_js_1 = require$$7$3;
    Object.defineProperty(exports, "createTestClient", { enumerable: true, get: function() {
      return createTestClient_js_1.createTestClient;
    } });
    var public_js_1 = require_public();
    Object.defineProperty(exports, "publicActions", { enumerable: true, get: function() {
      return public_js_1.publicActions;
    } });
    var test_js_12 = require$$9$1;
    Object.defineProperty(exports, "testActions", { enumerable: true, get: function() {
      return test_js_12.testActions;
    } });
    var wallet_js_1 = requireWallet();
    Object.defineProperty(exports, "walletActions", { enumerable: true, get: function() {
      return wallet_js_1.walletActions;
    } });
    var createTransport_js_12 = require$$11$2;
    Object.defineProperty(exports, "createTransport", { enumerable: true, get: function() {
      return createTransport_js_12.createTransport;
    } });
    var createWalletClient_js_1 = requireCreateWalletClient();
    Object.defineProperty(exports, "createWalletClient", { enumerable: true, get: function() {
      return createWalletClient_js_1.createWalletClient;
    } });
    var webSocket_js_1 = require$$13;
    Object.defineProperty(exports, "webSocket", { enumerable: true, get: function() {
      return webSocket_js_1.webSocket;
    } });
    var abis_js_12 = require$$14$3;
    Object.defineProperty(exports, "multicall3Abi", { enumerable: true, get: function() {
      return abis_js_12.multicall3Abi;
    } });
    var address_js_12 = require$$15;
    Object.defineProperty(exports, "zeroAddress", { enumerable: true, get: function() {
      return address_js_12.zeroAddress;
    } });
    var unit_js_12 = require$$16$2;
    Object.defineProperty(exports, "etherUnits", { enumerable: true, get: function() {
      return unit_js_12.etherUnits;
    } });
    Object.defineProperty(exports, "gweiUnits", { enumerable: true, get: function() {
      return unit_js_12.gweiUnits;
    } });
    Object.defineProperty(exports, "weiUnits", { enumerable: true, get: function() {
      return unit_js_12.weiUnits;
    } });
    var number_js_1 = require$$17;
    Object.defineProperty(exports, "maxInt8", { enumerable: true, get: function() {
      return number_js_1.maxInt8;
    } });
    Object.defineProperty(exports, "maxInt16", { enumerable: true, get: function() {
      return number_js_1.maxInt16;
    } });
    Object.defineProperty(exports, "maxInt24", { enumerable: true, get: function() {
      return number_js_1.maxInt24;
    } });
    Object.defineProperty(exports, "maxInt32", { enumerable: true, get: function() {
      return number_js_1.maxInt32;
    } });
    Object.defineProperty(exports, "maxInt40", { enumerable: true, get: function() {
      return number_js_1.maxInt40;
    } });
    Object.defineProperty(exports, "maxInt48", { enumerable: true, get: function() {
      return number_js_1.maxInt48;
    } });
    Object.defineProperty(exports, "maxInt56", { enumerable: true, get: function() {
      return number_js_1.maxInt56;
    } });
    Object.defineProperty(exports, "maxInt64", { enumerable: true, get: function() {
      return number_js_1.maxInt64;
    } });
    Object.defineProperty(exports, "maxInt72", { enumerable: true, get: function() {
      return number_js_1.maxInt72;
    } });
    Object.defineProperty(exports, "maxInt80", { enumerable: true, get: function() {
      return number_js_1.maxInt80;
    } });
    Object.defineProperty(exports, "maxInt88", { enumerable: true, get: function() {
      return number_js_1.maxInt88;
    } });
    Object.defineProperty(exports, "maxInt96", { enumerable: true, get: function() {
      return number_js_1.maxInt96;
    } });
    Object.defineProperty(exports, "maxInt104", { enumerable: true, get: function() {
      return number_js_1.maxInt104;
    } });
    Object.defineProperty(exports, "maxInt112", { enumerable: true, get: function() {
      return number_js_1.maxInt112;
    } });
    Object.defineProperty(exports, "maxInt120", { enumerable: true, get: function() {
      return number_js_1.maxInt120;
    } });
    Object.defineProperty(exports, "maxInt128", { enumerable: true, get: function() {
      return number_js_1.maxInt128;
    } });
    Object.defineProperty(exports, "maxInt136", { enumerable: true, get: function() {
      return number_js_1.maxInt136;
    } });
    Object.defineProperty(exports, "maxInt144", { enumerable: true, get: function() {
      return number_js_1.maxInt144;
    } });
    Object.defineProperty(exports, "maxInt152", { enumerable: true, get: function() {
      return number_js_1.maxInt152;
    } });
    Object.defineProperty(exports, "maxInt160", { enumerable: true, get: function() {
      return number_js_1.maxInt160;
    } });
    Object.defineProperty(exports, "maxInt168", { enumerable: true, get: function() {
      return number_js_1.maxInt168;
    } });
    Object.defineProperty(exports, "maxInt176", { enumerable: true, get: function() {
      return number_js_1.maxInt176;
    } });
    Object.defineProperty(exports, "maxInt184", { enumerable: true, get: function() {
      return number_js_1.maxInt184;
    } });
    Object.defineProperty(exports, "maxInt192", { enumerable: true, get: function() {
      return number_js_1.maxInt192;
    } });
    Object.defineProperty(exports, "maxInt200", { enumerable: true, get: function() {
      return number_js_1.maxInt200;
    } });
    Object.defineProperty(exports, "maxInt208", { enumerable: true, get: function() {
      return number_js_1.maxInt208;
    } });
    Object.defineProperty(exports, "maxInt216", { enumerable: true, get: function() {
      return number_js_1.maxInt216;
    } });
    Object.defineProperty(exports, "maxInt224", { enumerable: true, get: function() {
      return number_js_1.maxInt224;
    } });
    Object.defineProperty(exports, "maxInt232", { enumerable: true, get: function() {
      return number_js_1.maxInt232;
    } });
    Object.defineProperty(exports, "maxInt240", { enumerable: true, get: function() {
      return number_js_1.maxInt240;
    } });
    Object.defineProperty(exports, "maxInt248", { enumerable: true, get: function() {
      return number_js_1.maxInt248;
    } });
    Object.defineProperty(exports, "maxInt256", { enumerable: true, get: function() {
      return number_js_1.maxInt256;
    } });
    Object.defineProperty(exports, "maxUint8", { enumerable: true, get: function() {
      return number_js_1.maxUint8;
    } });
    Object.defineProperty(exports, "maxUint16", { enumerable: true, get: function() {
      return number_js_1.maxUint16;
    } });
    Object.defineProperty(exports, "maxUint24", { enumerable: true, get: function() {
      return number_js_1.maxUint24;
    } });
    Object.defineProperty(exports, "maxUint32", { enumerable: true, get: function() {
      return number_js_1.maxUint32;
    } });
    Object.defineProperty(exports, "maxUint40", { enumerable: true, get: function() {
      return number_js_1.maxUint40;
    } });
    Object.defineProperty(exports, "maxUint48", { enumerable: true, get: function() {
      return number_js_1.maxUint48;
    } });
    Object.defineProperty(exports, "maxUint56", { enumerable: true, get: function() {
      return number_js_1.maxUint56;
    } });
    Object.defineProperty(exports, "maxUint64", { enumerable: true, get: function() {
      return number_js_1.maxUint64;
    } });
    Object.defineProperty(exports, "maxUint72", { enumerable: true, get: function() {
      return number_js_1.maxUint72;
    } });
    Object.defineProperty(exports, "maxUint80", { enumerable: true, get: function() {
      return number_js_1.maxUint80;
    } });
    Object.defineProperty(exports, "maxUint88", { enumerable: true, get: function() {
      return number_js_1.maxUint88;
    } });
    Object.defineProperty(exports, "maxUint96", { enumerable: true, get: function() {
      return number_js_1.maxUint96;
    } });
    Object.defineProperty(exports, "maxUint104", { enumerable: true, get: function() {
      return number_js_1.maxUint104;
    } });
    Object.defineProperty(exports, "maxUint112", { enumerable: true, get: function() {
      return number_js_1.maxUint112;
    } });
    Object.defineProperty(exports, "maxUint120", { enumerable: true, get: function() {
      return number_js_1.maxUint120;
    } });
    Object.defineProperty(exports, "maxUint128", { enumerable: true, get: function() {
      return number_js_1.maxUint128;
    } });
    Object.defineProperty(exports, "maxUint136", { enumerable: true, get: function() {
      return number_js_1.maxUint136;
    } });
    Object.defineProperty(exports, "maxUint144", { enumerable: true, get: function() {
      return number_js_1.maxUint144;
    } });
    Object.defineProperty(exports, "maxUint152", { enumerable: true, get: function() {
      return number_js_1.maxUint152;
    } });
    Object.defineProperty(exports, "maxUint160", { enumerable: true, get: function() {
      return number_js_1.maxUint160;
    } });
    Object.defineProperty(exports, "maxUint168", { enumerable: true, get: function() {
      return number_js_1.maxUint168;
    } });
    Object.defineProperty(exports, "maxUint176", { enumerable: true, get: function() {
      return number_js_1.maxUint176;
    } });
    Object.defineProperty(exports, "maxUint184", { enumerable: true, get: function() {
      return number_js_1.maxUint184;
    } });
    Object.defineProperty(exports, "maxUint192", { enumerable: true, get: function() {
      return number_js_1.maxUint192;
    } });
    Object.defineProperty(exports, "maxUint200", { enumerable: true, get: function() {
      return number_js_1.maxUint200;
    } });
    Object.defineProperty(exports, "maxUint208", { enumerable: true, get: function() {
      return number_js_1.maxUint208;
    } });
    Object.defineProperty(exports, "maxUint216", { enumerable: true, get: function() {
      return number_js_1.maxUint216;
    } });
    Object.defineProperty(exports, "maxUint224", { enumerable: true, get: function() {
      return number_js_1.maxUint224;
    } });
    Object.defineProperty(exports, "maxUint232", { enumerable: true, get: function() {
      return number_js_1.maxUint232;
    } });
    Object.defineProperty(exports, "maxUint240", { enumerable: true, get: function() {
      return number_js_1.maxUint240;
    } });
    Object.defineProperty(exports, "maxUint248", { enumerable: true, get: function() {
      return number_js_1.maxUint248;
    } });
    Object.defineProperty(exports, "maxUint256", { enumerable: true, get: function() {
      return number_js_1.maxUint256;
    } });
    Object.defineProperty(exports, "minInt8", { enumerable: true, get: function() {
      return number_js_1.minInt8;
    } });
    Object.defineProperty(exports, "minInt16", { enumerable: true, get: function() {
      return number_js_1.minInt16;
    } });
    Object.defineProperty(exports, "minInt24", { enumerable: true, get: function() {
      return number_js_1.minInt24;
    } });
    Object.defineProperty(exports, "minInt32", { enumerable: true, get: function() {
      return number_js_1.minInt32;
    } });
    Object.defineProperty(exports, "minInt40", { enumerable: true, get: function() {
      return number_js_1.minInt40;
    } });
    Object.defineProperty(exports, "minInt48", { enumerable: true, get: function() {
      return number_js_1.minInt48;
    } });
    Object.defineProperty(exports, "minInt56", { enumerable: true, get: function() {
      return number_js_1.minInt56;
    } });
    Object.defineProperty(exports, "minInt64", { enumerable: true, get: function() {
      return number_js_1.minInt64;
    } });
    Object.defineProperty(exports, "minInt72", { enumerable: true, get: function() {
      return number_js_1.minInt72;
    } });
    Object.defineProperty(exports, "minInt80", { enumerable: true, get: function() {
      return number_js_1.minInt80;
    } });
    Object.defineProperty(exports, "minInt88", { enumerable: true, get: function() {
      return number_js_1.minInt88;
    } });
    Object.defineProperty(exports, "minInt96", { enumerable: true, get: function() {
      return number_js_1.minInt96;
    } });
    Object.defineProperty(exports, "minInt104", { enumerable: true, get: function() {
      return number_js_1.minInt104;
    } });
    Object.defineProperty(exports, "minInt112", { enumerable: true, get: function() {
      return number_js_1.minInt112;
    } });
    Object.defineProperty(exports, "minInt120", { enumerable: true, get: function() {
      return number_js_1.minInt120;
    } });
    Object.defineProperty(exports, "minInt128", { enumerable: true, get: function() {
      return number_js_1.minInt128;
    } });
    Object.defineProperty(exports, "minInt136", { enumerable: true, get: function() {
      return number_js_1.minInt136;
    } });
    Object.defineProperty(exports, "minInt144", { enumerable: true, get: function() {
      return number_js_1.minInt144;
    } });
    Object.defineProperty(exports, "minInt152", { enumerable: true, get: function() {
      return number_js_1.minInt152;
    } });
    Object.defineProperty(exports, "minInt160", { enumerable: true, get: function() {
      return number_js_1.minInt160;
    } });
    Object.defineProperty(exports, "minInt168", { enumerable: true, get: function() {
      return number_js_1.minInt168;
    } });
    Object.defineProperty(exports, "minInt176", { enumerable: true, get: function() {
      return number_js_1.minInt176;
    } });
    Object.defineProperty(exports, "minInt184", { enumerable: true, get: function() {
      return number_js_1.minInt184;
    } });
    Object.defineProperty(exports, "minInt192", { enumerable: true, get: function() {
      return number_js_1.minInt192;
    } });
    Object.defineProperty(exports, "minInt200", { enumerable: true, get: function() {
      return number_js_1.minInt200;
    } });
    Object.defineProperty(exports, "minInt208", { enumerable: true, get: function() {
      return number_js_1.minInt208;
    } });
    Object.defineProperty(exports, "minInt216", { enumerable: true, get: function() {
      return number_js_1.minInt216;
    } });
    Object.defineProperty(exports, "minInt224", { enumerable: true, get: function() {
      return number_js_1.minInt224;
    } });
    Object.defineProperty(exports, "minInt232", { enumerable: true, get: function() {
      return number_js_1.minInt232;
    } });
    Object.defineProperty(exports, "minInt240", { enumerable: true, get: function() {
      return number_js_1.minInt240;
    } });
    Object.defineProperty(exports, "minInt248", { enumerable: true, get: function() {
      return number_js_1.minInt248;
    } });
    Object.defineProperty(exports, "minInt256", { enumerable: true, get: function() {
      return number_js_1.minInt256;
    } });
    var bytes_js_1 = require$$18;
    Object.defineProperty(exports, "zeroHash", { enumerable: true, get: function() {
      return bytes_js_1.zeroHash;
    } });
    var strings_js_12 = require$$19$1;
    Object.defineProperty(exports, "presignMessagePrefix", { enumerable: true, get: function() {
      return strings_js_12.presignMessagePrefix;
    } });
    var abi_js_12 = requireAbi();
    Object.defineProperty(exports, "AbiConstructorNotFoundError", { enumerable: true, get: function() {
      return abi_js_12.AbiConstructorNotFoundError;
    } });
    Object.defineProperty(exports, "AbiConstructorParamsNotFoundError", { enumerable: true, get: function() {
      return abi_js_12.AbiConstructorParamsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiDecodingDataSizeInvalidError", { enumerable: true, get: function() {
      return abi_js_12.AbiDecodingDataSizeInvalidError;
    } });
    Object.defineProperty(exports, "AbiDecodingDataSizeTooSmallError", { enumerable: true, get: function() {
      return abi_js_12.AbiDecodingDataSizeTooSmallError;
    } });
    Object.defineProperty(exports, "AbiDecodingZeroDataError", { enumerable: true, get: function() {
      return abi_js_12.AbiDecodingZeroDataError;
    } });
    Object.defineProperty(exports, "AbiEncodingArrayLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_12.AbiEncodingArrayLengthMismatchError;
    } });
    Object.defineProperty(exports, "AbiEncodingLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_12.AbiEncodingLengthMismatchError;
    } });
    Object.defineProperty(exports, "AbiEncodingBytesSizeMismatchError", { enumerable: true, get: function() {
      return abi_js_12.AbiEncodingBytesSizeMismatchError;
    } });
    Object.defineProperty(exports, "AbiErrorInputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_12.AbiErrorInputsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiErrorNotFoundError", { enumerable: true, get: function() {
      return abi_js_12.AbiErrorNotFoundError;
    } });
    Object.defineProperty(exports, "AbiErrorSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_12.AbiErrorSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "AbiEventNotFoundError", { enumerable: true, get: function() {
      return abi_js_12.AbiEventNotFoundError;
    } });
    Object.defineProperty(exports, "AbiEventSignatureEmptyTopicsError", { enumerable: true, get: function() {
      return abi_js_12.AbiEventSignatureEmptyTopicsError;
    } });
    Object.defineProperty(exports, "AbiEventSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_12.AbiEventSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionNotFoundError", { enumerable: true, get: function() {
      return abi_js_12.AbiFunctionNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionOutputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_12.AbiFunctionOutputsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_12.AbiFunctionSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "BytesSizeMismatchError", { enumerable: true, get: function() {
      return abi_js_12.BytesSizeMismatchError;
    } });
    Object.defineProperty(exports, "DecodeLogDataMismatch", { enumerable: true, get: function() {
      return abi_js_12.DecodeLogDataMismatch;
    } });
    Object.defineProperty(exports, "DecodeLogTopicsMismatch", { enumerable: true, get: function() {
      return abi_js_12.DecodeLogTopicsMismatch;
    } });
    Object.defineProperty(exports, "InvalidAbiDecodingTypeError", { enumerable: true, get: function() {
      return abi_js_12.InvalidAbiDecodingTypeError;
    } });
    Object.defineProperty(exports, "InvalidAbiEncodingTypeError", { enumerable: true, get: function() {
      return abi_js_12.InvalidAbiEncodingTypeError;
    } });
    Object.defineProperty(exports, "InvalidArrayError", { enumerable: true, get: function() {
      return abi_js_12.InvalidArrayError;
    } });
    Object.defineProperty(exports, "InvalidDefinitionTypeError", { enumerable: true, get: function() {
      return abi_js_12.InvalidDefinitionTypeError;
    } });
    Object.defineProperty(exports, "UnsupportedPackedAbiType", { enumerable: true, get: function() {
      return abi_js_12.UnsupportedPackedAbiType;
    } });
    var base_js_12 = require$$21$2;
    Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
      return base_js_12.BaseError;
    } });
    var block_js_12 = require$$22$2;
    Object.defineProperty(exports, "BlockNotFoundError", { enumerable: true, get: function() {
      return block_js_12.BlockNotFoundError;
    } });
    var contract_js_12 = require$$23$2;
    Object.defineProperty(exports, "CallExecutionError", { enumerable: true, get: function() {
      return contract_js_12.CallExecutionError;
    } });
    Object.defineProperty(exports, "ContractFunctionExecutionError", { enumerable: true, get: function() {
      return contract_js_12.ContractFunctionExecutionError;
    } });
    Object.defineProperty(exports, "ContractFunctionRevertedError", { enumerable: true, get: function() {
      return contract_js_12.ContractFunctionRevertedError;
    } });
    Object.defineProperty(exports, "ContractFunctionZeroDataError", { enumerable: true, get: function() {
      return contract_js_12.ContractFunctionZeroDataError;
    } });
    Object.defineProperty(exports, "RawContractError", { enumerable: true, get: function() {
      return contract_js_12.RawContractError;
    } });
    var fee_js_12 = require$$24$2;
    Object.defineProperty(exports, "BaseFeeScalarError", { enumerable: true, get: function() {
      return fee_js_12.BaseFeeScalarError;
    } });
    Object.defineProperty(exports, "Eip1559FeesNotSupportedError", { enumerable: true, get: function() {
      return fee_js_12.Eip1559FeesNotSupportedError;
    } });
    Object.defineProperty(exports, "MaxFeePerGasTooLowError", { enumerable: true, get: function() {
      return fee_js_12.MaxFeePerGasTooLowError;
    } });
    var rpc_js_12 = require$$25$2;
    Object.defineProperty(exports, "ChainDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_12.ChainDisconnectedError;
    } });
    Object.defineProperty(exports, "InternalRpcError", { enumerable: true, get: function() {
      return rpc_js_12.InternalRpcError;
    } });
    Object.defineProperty(exports, "InvalidInputRpcError", { enumerable: true, get: function() {
      return rpc_js_12.InvalidInputRpcError;
    } });
    Object.defineProperty(exports, "InvalidParamsRpcError", { enumerable: true, get: function() {
      return rpc_js_12.InvalidParamsRpcError;
    } });
    Object.defineProperty(exports, "InvalidRequestRpcError", { enumerable: true, get: function() {
      return rpc_js_12.InvalidRequestRpcError;
    } });
    Object.defineProperty(exports, "JsonRpcVersionUnsupportedError", { enumerable: true, get: function() {
      return rpc_js_12.JsonRpcVersionUnsupportedError;
    } });
    Object.defineProperty(exports, "LimitExceededRpcError", { enumerable: true, get: function() {
      return rpc_js_12.LimitExceededRpcError;
    } });
    Object.defineProperty(exports, "MethodNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_12.MethodNotFoundRpcError;
    } });
    Object.defineProperty(exports, "MethodNotSupportedRpcError", { enumerable: true, get: function() {
      return rpc_js_12.MethodNotSupportedRpcError;
    } });
    Object.defineProperty(exports, "ParseRpcError", { enumerable: true, get: function() {
      return rpc_js_12.ParseRpcError;
    } });
    Object.defineProperty(exports, "ProviderDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_12.ProviderDisconnectedError;
    } });
    Object.defineProperty(exports, "ProviderRpcError", { enumerable: true, get: function() {
      return rpc_js_12.ProviderRpcError;
    } });
    Object.defineProperty(exports, "ResourceNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_12.ResourceNotFoundRpcError;
    } });
    Object.defineProperty(exports, "ResourceUnavailableRpcError", { enumerable: true, get: function() {
      return rpc_js_12.ResourceUnavailableRpcError;
    } });
    Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
      return rpc_js_12.RpcError;
    } });
    Object.defineProperty(exports, "SwitchChainError", { enumerable: true, get: function() {
      return rpc_js_12.SwitchChainError;
    } });
    Object.defineProperty(exports, "TransactionRejectedRpcError", { enumerable: true, get: function() {
      return rpc_js_12.TransactionRejectedRpcError;
    } });
    Object.defineProperty(exports, "UnauthorizedProviderError", { enumerable: true, get: function() {
      return rpc_js_12.UnauthorizedProviderError;
    } });
    Object.defineProperty(exports, "UnknownRpcError", { enumerable: true, get: function() {
      return rpc_js_12.UnknownRpcError;
    } });
    Object.defineProperty(exports, "UnsupportedProviderMethodError", { enumerable: true, get: function() {
      return rpc_js_12.UnsupportedProviderMethodError;
    } });
    Object.defineProperty(exports, "UserRejectedRequestError", { enumerable: true, get: function() {
      return rpc_js_12.UserRejectedRequestError;
    } });
    var chain_js_12 = require$$26$1;
    Object.defineProperty(exports, "ChainDoesNotSupportContract", { enumerable: true, get: function() {
      return chain_js_12.ChainDoesNotSupportContract;
    } });
    Object.defineProperty(exports, "ChainMismatchError", { enumerable: true, get: function() {
      return chain_js_12.ChainMismatchError;
    } });
    Object.defineProperty(exports, "ChainNotFoundError", { enumerable: true, get: function() {
      return chain_js_12.ChainNotFoundError;
    } });
    Object.defineProperty(exports, "ClientChainNotConfiguredError", { enumerable: true, get: function() {
      return chain_js_12.ClientChainNotConfiguredError;
    } });
    Object.defineProperty(exports, "InvalidChainIdError", { enumerable: true, get: function() {
      return chain_js_12.InvalidChainIdError;
    } });
    var encoding_js_12 = require$$27$3;
    Object.defineProperty(exports, "DataLengthTooLongError", { enumerable: true, get: function() {
      return encoding_js_12.DataLengthTooLongError;
    } });
    Object.defineProperty(exports, "DataLengthTooShortError", { enumerable: true, get: function() {
      return encoding_js_12.DataLengthTooShortError;
    } });
    Object.defineProperty(exports, "InvalidBytesBooleanError", { enumerable: true, get: function() {
      return encoding_js_12.InvalidBytesBooleanError;
    } });
    Object.defineProperty(exports, "IntegerOutOfRangeError", { enumerable: true, get: function() {
      return encoding_js_12.IntegerOutOfRangeError;
    } });
    Object.defineProperty(exports, "InvalidHexBooleanError", { enumerable: true, get: function() {
      return encoding_js_12.InvalidHexBooleanError;
    } });
    Object.defineProperty(exports, "InvalidHexValueError", { enumerable: true, get: function() {
      return encoding_js_12.InvalidHexValueError;
    } });
    Object.defineProperty(exports, "OffsetOutOfBoundsError", { enumerable: true, get: function() {
      return encoding_js_12.OffsetOutOfBoundsError;
    } });
    Object.defineProperty(exports, "SizeOverflowError", { enumerable: true, get: function() {
      return encoding_js_12.SizeOverflowError;
    } });
    var ens_js_12 = require$$28$2;
    Object.defineProperty(exports, "EnsAvatarUriResolutionError", { enumerable: true, get: function() {
      return ens_js_12.EnsAvatarUriResolutionError;
    } });
    Object.defineProperty(exports, "EnsAvatarInvalidNftUriError", { enumerable: true, get: function() {
      return ens_js_12.EnsAvatarInvalidNftUriError;
    } });
    Object.defineProperty(exports, "EnsAvatarUnsupportedNamespaceError", { enumerable: true, get: function() {
      return ens_js_12.EnsAvatarUnsupportedNamespaceError;
    } });
    var estimateGas_js_12 = require$$29$2;
    Object.defineProperty(exports, "EstimateGasExecutionError", { enumerable: true, get: function() {
      return estimateGas_js_12.EstimateGasExecutionError;
    } });
    var node_js_12 = require$$30$1;
    Object.defineProperty(exports, "ExecutionRevertedError", { enumerable: true, get: function() {
      return node_js_12.ExecutionRevertedError;
    } });
    Object.defineProperty(exports, "FeeCapTooHighError", { enumerable: true, get: function() {
      return node_js_12.FeeCapTooHighError;
    } });
    Object.defineProperty(exports, "FeeCapTooLowError", { enumerable: true, get: function() {
      return node_js_12.FeeCapTooLowError;
    } });
    Object.defineProperty(exports, "InsufficientFundsError", { enumerable: true, get: function() {
      return node_js_12.InsufficientFundsError;
    } });
    Object.defineProperty(exports, "IntrinsicGasTooHighError", { enumerable: true, get: function() {
      return node_js_12.IntrinsicGasTooHighError;
    } });
    Object.defineProperty(exports, "IntrinsicGasTooLowError", { enumerable: true, get: function() {
      return node_js_12.IntrinsicGasTooLowError;
    } });
    Object.defineProperty(exports, "NonceMaxValueError", { enumerable: true, get: function() {
      return node_js_12.NonceMaxValueError;
    } });
    Object.defineProperty(exports, "NonceTooHighError", { enumerable: true, get: function() {
      return node_js_12.NonceTooHighError;
    } });
    Object.defineProperty(exports, "NonceTooLowError", { enumerable: true, get: function() {
      return node_js_12.NonceTooLowError;
    } });
    Object.defineProperty(exports, "TipAboveFeeCapError", { enumerable: true, get: function() {
      return node_js_12.TipAboveFeeCapError;
    } });
    Object.defineProperty(exports, "TransactionTypeNotSupportedError", { enumerable: true, get: function() {
      return node_js_12.TransactionTypeNotSupportedError;
    } });
    Object.defineProperty(exports, "UnknownNodeError", { enumerable: true, get: function() {
      return node_js_12.UnknownNodeError;
    } });
    var log_js_12 = require$$31$1;
    Object.defineProperty(exports, "FilterTypeNotSupportedError", { enumerable: true, get: function() {
      return log_js_12.FilterTypeNotSupportedError;
    } });
    var request_js_12 = require$$32$2;
    Object.defineProperty(exports, "HttpRequestError", { enumerable: true, get: function() {
      return request_js_12.HttpRequestError;
    } });
    Object.defineProperty(exports, "RpcRequestError", { enumerable: true, get: function() {
      return request_js_12.RpcRequestError;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return request_js_12.TimeoutError;
    } });
    Object.defineProperty(exports, "WebSocketRequestError", { enumerable: true, get: function() {
      return request_js_12.WebSocketRequestError;
    } });
    var address_js_2 = require$$33$1;
    Object.defineProperty(exports, "InvalidAddressError", { enumerable: true, get: function() {
      return address_js_2.InvalidAddressError;
    } });
    var transaction_js_12 = require$$34$1;
    Object.defineProperty(exports, "FeeConflictError", { enumerable: true, get: function() {
      return transaction_js_12.FeeConflictError;
    } });
    Object.defineProperty(exports, "InvalidLegacyVError", { enumerable: true, get: function() {
      return transaction_js_12.InvalidLegacyVError;
    } });
    Object.defineProperty(exports, "InvalidSerializableTransactionError", { enumerable: true, get: function() {
      return transaction_js_12.InvalidSerializableTransactionError;
    } });
    Object.defineProperty(exports, "InvalidSerializedTransactionError", { enumerable: true, get: function() {
      return transaction_js_12.InvalidSerializedTransactionError;
    } });
    Object.defineProperty(exports, "InvalidSerializedTransactionTypeError", { enumerable: true, get: function() {
      return transaction_js_12.InvalidSerializedTransactionTypeError;
    } });
    Object.defineProperty(exports, "InvalidStorageKeySizeError", { enumerable: true, get: function() {
      return transaction_js_12.InvalidStorageKeySizeError;
    } });
    Object.defineProperty(exports, "TransactionExecutionError", { enumerable: true, get: function() {
      return transaction_js_12.TransactionExecutionError;
    } });
    Object.defineProperty(exports, "TransactionNotFoundError", { enumerable: true, get: function() {
      return transaction_js_12.TransactionNotFoundError;
    } });
    Object.defineProperty(exports, "TransactionReceiptNotFoundError", { enumerable: true, get: function() {
      return transaction_js_12.TransactionReceiptNotFoundError;
    } });
    Object.defineProperty(exports, "WaitForTransactionReceiptTimeoutError", { enumerable: true, get: function() {
      return transaction_js_12.WaitForTransactionReceiptTimeoutError;
    } });
    var data_js_12 = require$$35$1;
    Object.defineProperty(exports, "SizeExceedsPaddingSizeError", { enumerable: true, get: function() {
      return data_js_12.SizeExceedsPaddingSizeError;
    } });
    Object.defineProperty(exports, "SliceOffsetOutOfBoundsError", { enumerable: true, get: function() {
      return data_js_12.SliceOffsetOutOfBoundsError;
    } });
    var transport_js_12 = require$$36;
    Object.defineProperty(exports, "UrlRequiredError", { enumerable: true, get: function() {
      return transport_js_12.UrlRequiredError;
    } });
    var labelhash_js_12 = require$$37;
    Object.defineProperty(exports, "labelhash", { enumerable: true, get: function() {
      return labelhash_js_12.labelhash;
    } });
    var namehash_js_12 = require$$38$1;
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return namehash_js_12.namehash;
    } });
    var block_js_22 = require$$39$1;
    Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
      return block_js_22.defineBlock;
    } });
    Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
      return block_js_22.formatBlock;
    } });
    var log_js_2 = require$$40$1;
    Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
      return log_js_2.formatLog;
    } });
    var decodeAbiParameters_js_12 = require$$41$1;
    Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_12.decodeAbiParameters;
    } });
    var decodeDeployData_js_1 = require$$42;
    Object.defineProperty(exports, "decodeDeployData", { enumerable: true, get: function() {
      return decodeDeployData_js_1.decodeDeployData;
    } });
    var decodeErrorResult_js_12 = require$$43$1;
    Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_12.decodeErrorResult;
    } });
    var decodeEventLog_js_12 = require$$44;
    Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_12.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require$$45;
    Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_12 = require$$46;
    Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_12.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_12 = require$$47;
    Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_12.encodeAbiParameters;
    } });
    var encodeDeployData_js_12 = require$$48;
    Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_12.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require$$49;
    Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_12 = require$$50;
    Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_12.encodeEventTopics;
    } });
    var encodeFunctionData_js_12 = require$$51;
    Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_12.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require$$52;
    Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var transaction_js_22 = require$$53$1;
    Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_22.defineTransaction;
    } });
    Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_22.formatTransaction;
    } });
    Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
      return transaction_js_22.transactionType;
    } });
    var transactionReceipt_js_12 = require$$54;
    Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_12.defineTransactionReceipt;
    } });
    Object.defineProperty(exports, "formatTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_12.formatTransactionReceipt;
    } });
    var transactionRequest_js_12 = require$$55;
    Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_12.defineTransactionRequest;
    } });
    Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_12.formatTransactionRequest;
    } });
    Object.defineProperty(exports, "rpcTransactionType", { enumerable: true, get: function() {
      return transactionRequest_js_12.rpcTransactionType;
    } });
    var getAbiItem_js_12 = require$$56$1;
    Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_12.getAbiItem;
    } });
    var getContractAddress_js_1 = requireGetContractAddress();
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    var getSerializedTransactionType_js_12 = require$$58;
    Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_12.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require$$59;
    Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var hashTypedData_js_12 = requireHashTypedData();
    Object.defineProperty(exports, "hashDomain", { enumerable: true, get: function() {
      return hashTypedData_js_12.hashDomain;
    } });
    Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_12.hashTypedData;
    } });
    var compactSignatureToSignature_js_1 = require$$61;
    Object.defineProperty(exports, "compactSignatureToSignature", { enumerable: true, get: function() {
      return compactSignatureToSignature_js_1.compactSignatureToSignature;
    } });
    var hexToCompactSignature_js_1 = require$$62;
    Object.defineProperty(exports, "hexToCompactSignature", { enumerable: true, get: function() {
      return hexToCompactSignature_js_1.hexToCompactSignature;
    } });
    var hexToSignature_js_1 = require$$63;
    Object.defineProperty(exports, "hexToSignature", { enumerable: true, get: function() {
      return hexToSignature_js_1.hexToSignature;
    } });
    var recoverAddress_js_12 = require$$64;
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_12.recoverAddress;
    } });
    var recoverMessageAddress_js_12 = require$$65;
    Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_12.recoverMessageAddress;
    } });
    var recoverPublicKey_js_12 = require$$66;
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_12.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_12 = require$$67;
    Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_12.recoverTypedDataAddress;
    } });
    var signatureToCompactSignature_js_1 = requireSignatureToCompactSignature();
    Object.defineProperty(exports, "signatureToCompactSignature", { enumerable: true, get: function() {
      return signatureToCompactSignature_js_1.signatureToCompactSignature;
    } });
    var compactSignatureToHex_js_1 = require$$69;
    Object.defineProperty(exports, "compactSignatureToHex", { enumerable: true, get: function() {
      return compactSignatureToHex_js_1.compactSignatureToHex;
    } });
    var signatureToHex_js_1 = require$$70;
    Object.defineProperty(exports, "signatureToHex", { enumerable: true, get: function() {
      return signatureToHex_js_1.signatureToHex;
    } });
    var toRlp_js_1 = requireToRlp();
    Object.defineProperty(exports, "bytesToRlp", { enumerable: true, get: function() {
      return toRlp_js_1.bytesToRlp;
    } });
    Object.defineProperty(exports, "hexToRlp", { enumerable: true, get: function() {
      return toRlp_js_1.hexToRlp;
    } });
    Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var verifyMessage_js_1 = require$$72;
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require$$73;
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var assertRequest_js_12 = require$$74;
    Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_12.assertRequest;
    } });
    var assertTransaction_js_12 = require$$75;
    Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_12.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_12.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_12.assertTransactionLegacy;
    } });
    var toBytes_js_12 = requireToBytes();
    Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_12.boolToBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_12.hexToBytes;
    } });
    Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_12.numberToBytes;
    } });
    Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_12.stringToBytes;
    } });
    Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_12.toBytes;
    } });
    var toHex_js_12 = requireToHex();
    Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_12.boolToHex;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_12.bytesToHex;
    } });
    Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_12.numberToHex;
    } });
    Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_12.stringToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return toHex_js_12.toHex;
    } });
    var fromBytes_js_1 = require$$78;
    Object.defineProperty(exports, "bytesToBigInt", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var ccip_js_1 = requireCcip();
    Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var concat_js_12 = require$$80;
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_js_12.concat;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return concat_js_12.concatBytes;
    } });
    Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
      return concat_js_12.concatHex;
    } });
    var assertCurrentChain_js_12 = require$$81;
    Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
      return assertCurrentChain_js_12.assertCurrentChain;
    } });
    var defineChain_js_1 = require$$82;
    Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
      return defineChain_js_1.defineChain;
    } });
    var extractChain_js_1 = require$$83;
    Object.defineProperty(exports, "extractChain", { enumerable: true, get: function() {
      return extractChain_js_1.extractChain;
    } });
    var getChainContractAddress_js_12 = require$$84;
    Object.defineProperty(exports, "getChainContractAddress", { enumerable: true, get: function() {
      return getChainContractAddress_js_12.getChainContractAddress;
    } });
    var encodePacked_js_1 = require$$85;
    Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatEther_js_12 = require$$86;
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_12.formatEther;
    } });
    var formatGwei_js_12 = require$$87;
    Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_12.formatGwei;
    } });
    var formatUnits_js_12 = require$$88;
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_12.formatUnits;
    } });
    var fromHex_js_12 = requireFromHex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_12.fromHex;
    } });
    Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_12.hexToBigInt;
    } });
    Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_12.hexToBool;
    } });
    Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_12.hexToNumber;
    } });
    Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_12.hexToString;
    } });
    var fromRlp_js_12 = require$$90;
    Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_12.fromRlp;
    } });
    var getAddress_js_12 = require$$91;
    Object.defineProperty(exports, "checksumAddress", { enumerable: true, get: function() {
      return getAddress_js_12.checksumAddress;
    } });
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_12.getAddress;
    } });
    var getContractError_js_12 = require$$92;
    Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_12.getContractError;
    } });
    var getEventSelector_js_12 = require$$93;
    Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_12.getEventSelector;
    } });
    var getEventSignature_js_12 = require$$94;
    Object.defineProperty(exports, "getEventSignature", { enumerable: true, get: function() {
      return getEventSignature_js_12.getEventSignature;
    } });
    var getFunctionSelector_js_12 = require$$95;
    Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_12.getFunctionSelector;
    } });
    var getFunctionSignature_js_12 = require$$96;
    Object.defineProperty(exports, "getFunctionSignature", { enumerable: true, get: function() {
      return getFunctionSignature_js_12.getFunctionSignature;
    } });
    var hashMessage_js_12 = require$$97;
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_12.hashMessage;
    } });
    var isAddress_js_12 = require$$98;
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_12.isAddress;
    } });
    var isAddressEqual_js_12 = require$$99;
    Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_12.isAddressEqual;
    } });
    var isBytes_js_1 = require$$100;
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHash_js_12 = require$$101;
    Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
      return isHash_js_12.isHash;
    } });
    var isHex_js_12 = require$$102;
    Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
      return isHex_js_12.isHex;
    } });
    var keccak256_js_12 = require$$103;
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_12.keccak256;
    } });
    var sha256_js_1 = require$$104;
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_js_1.sha256;
    } });
    var ripemd160_js_1 = require$$105;
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return ripemd160_js_1.ripemd160;
    } });
    var pad_js_12 = require$$106;
    Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
      return pad_js_12.pad;
    } });
    Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
      return pad_js_12.padBytes;
    } });
    Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
      return pad_js_12.padHex;
    } });
    var parseEther_js_1 = require$$107;
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require$$108;
    Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
    var parseTransaction_js_1 = require$$109;
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var parseUnits_js_12 = require$$110;
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_12.parseUnits;
    } });
    var serializeAccessList_js_1 = require$$111;
    Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var serializeTransaction_js_1 = requireSerializeTransaction();
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var size_js_12 = require$$113;
    Object.defineProperty(exports, "size", { enumerable: true, get: function() {
      return size_js_12.size;
    } });
    var slice_js_12 = require$$114;
    Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
      return slice_js_12.slice;
    } });
    Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_12.sliceBytes;
    } });
    Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
      return slice_js_12.sliceHex;
    } });
    var stringify_js_12 = require$$115;
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_12.stringify;
    } });
    var trim_js_12 = require$$116;
    Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
      return trim_js_12.trim;
    } });
    var typedData_js_12 = requireTypedData();
    Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_12.validateTypedData;
    } });
    Object.defineProperty(exports, "domainSeparator", { enumerable: true, get: function() {
      return typedData_js_12.domainSeparator;
    } });
    Object.defineProperty(exports, "getTypesForEIP712Domain", { enumerable: true, get: function() {
      return typedData_js_12.getTypesForEIP712Domain;
    } });
  })(_cjs);
  return _cjs;
}
var signatures$1 = {};
Object.defineProperty(signatures$1, "__esModule", { value: true });
var MAGIC_VALUE_BYTES_1 = signatures$1.MAGIC_VALUE_BYTES = MAGIC_VALUE_1 = signatures$1.MAGIC_VALUE = void 0;
const MAGIC_VALUE = "0x1626ba7e";
var MAGIC_VALUE_1 = signatures$1.MAGIC_VALUE = MAGIC_VALUE;
const MAGIC_VALUE_BYTES = "0x20c13b0b";
MAGIC_VALUE_BYTES_1 = signatures$1.MAGIC_VALUE_BYTES = MAGIC_VALUE_BYTES;
const signatures = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get MAGIC_VALUE() {
    return MAGIC_VALUE_1;
  },
  get MAGIC_VALUE_BYTES() {
    return MAGIC_VALUE_BYTES_1;
  },
  default: signatures$1
}, [signatures$1]);
const require$$1$c = /* @__PURE__ */ getAugmentedNamespace(signatures);
var requirePermissions$1 = {};
var wallet$1 = {};
var permissions$1 = {};
Object.defineProperty(permissions$1, "__esModule", { value: true });
var PermissionsError_1 = permissions$1.PermissionsError = PERMISSIONS_REQUEST_REJECTED = permissions$1.PERMISSIONS_REQUEST_REJECTED = void 0;
var PERMISSIONS_REQUEST_REJECTED = permissions$1.PERMISSIONS_REQUEST_REJECTED = 4001;
class PermissionsError extends Error {
  constructor(message, code2, data2) {
    super(message);
    this.code = code2;
    this.data = data2;
    Object.setPrototypeOf(this, PermissionsError.prototype);
  }
}
PermissionsError_1 = permissions$1.PermissionsError = PermissionsError;
const permissions = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get PERMISSIONS_REQUEST_REJECTED() {
    return PERMISSIONS_REQUEST_REJECTED;
  },
  get PermissionsError() {
    return PermissionsError_1;
  },
  default: permissions$1
}, [permissions$1]);
const require$$1$b = /* @__PURE__ */ getAugmentedNamespace(permissions);
Object.defineProperty(wallet$1, "__esModule", { value: true });
var Wallet_1 = wallet$1.Wallet = void 0;
const methods_1$1 = require$$2$m;
const permissions_1$1 = require$$1$b;
let Wallet$1 = class Wallet2 {
  constructor(communicator) {
    this.communicator = communicator;
  }
  async getPermissions() {
    const response = await this.communicator.send(methods_1$1.Methods.wallet_getPermissions, void 0);
    return response.data;
  }
  async requestPermissions(permissions2) {
    if (!this.isPermissionRequestValid(permissions2)) {
      throw new permissions_1$1.PermissionsError("Permissions request is invalid", permissions_1$1.PERMISSIONS_REQUEST_REJECTED);
    }
    try {
      const response = await this.communicator.send(methods_1$1.Methods.wallet_requestPermissions, permissions2);
      return response.data;
    } catch (_a2) {
      throw new permissions_1$1.PermissionsError("Permissions rejected", permissions_1$1.PERMISSIONS_REQUEST_REJECTED);
    }
  }
  isPermissionRequestValid(permissions2) {
    return permissions2.every((pr) => {
      if (typeof pr === "object") {
        return Object.keys(pr).every((method) => {
          if (Object.values(methods_1$1.RestrictedMethods).includes(method)) {
            return true;
          }
          return false;
        });
      }
      return false;
    });
  }
};
Wallet_1 = wallet$1.Wallet = Wallet$1;
const wallet = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get Wallet() {
    return Wallet_1;
  },
  default: wallet$1
}, [wallet$1]);
const require$$4$4 = /* @__PURE__ */ getAugmentedNamespace(wallet);
Object.defineProperty(requirePermissions$1, "__esModule", { value: true });
const wallet_1$1 = require$$4$4;
const permissions_1 = require$$1$b;
const hasPermission = (required, permissions2) => permissions2.some((permission) => permission.parentCapability === required);
const requirePermission = () => (_2, propertyKey, descriptor) => {
  const originalMethod = descriptor.value;
  descriptor.value = async function() {
    const wallet2 = new wallet_1$1.Wallet(this.communicator);
    let currentPermissions = await wallet2.getPermissions();
    if (!hasPermission(propertyKey, currentPermissions)) {
      currentPermissions = await wallet2.requestPermissions([{ [propertyKey]: {} }]);
    }
    if (!hasPermission(propertyKey, currentPermissions)) {
      throw new permissions_1.PermissionsError("Permissions rejected", permissions_1.PERMISSIONS_REQUEST_REJECTED);
    }
    return originalMethod.apply(this);
  };
  return descriptor;
};
var _default$1 = requirePermissions$1.default = requirePermission;
const requirePermissions = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default$1
}, [requirePermissions$1]);
const require$$5$4 = /* @__PURE__ */ getAugmentedNamespace(requirePermissions);
var __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(safe$2, "__esModule", { value: true });
var Safe_1 = safe$2.Safe = void 0;
const viem_1 = require_cjs();
const signatures_1 = require$$1$c;
const methods_1 = require$$2$m;
const constants_1 = require$$3$g;
const types_1 = require$$1$v;
const requirePermissions_1 = __importDefault$1(require$$5$4);
let Safe$1 = class Safe2 {
  constructor(communicator) {
    this.communicator = communicator;
  }
  async getChainInfo() {
    const response = await this.communicator.send(methods_1.Methods.getChainInfo, void 0);
    return response.data;
  }
  async getInfo() {
    const response = await this.communicator.send(methods_1.Methods.getSafeInfo, void 0);
    return response.data;
  }
  // There is a possibility that this method will change because we may add pagination to the endpoint
  async experimental_getBalances({ currency = "usd" } = {}) {
    const response = await this.communicator.send(methods_1.Methods.getSafeBalances, {
      currency
    });
    return response.data;
  }
  async check1271Signature(messageHash, signature2 = "0x") {
    const safeInfo2 = await this.getInfo();
    const encodedIsValidSignatureCall = (0, viem_1.encodeFunctionData)({
      abi: [
        {
          constant: false,
          inputs: [
            {
              name: "_dataHash",
              type: "bytes32"
            },
            {
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        }
      ],
      functionName: "isValidSignature",
      args: [messageHash, signature2]
    });
    const payload = {
      call: constants_1.RPC_CALLS.eth_call,
      params: [
        {
          to: safeInfo2.safeAddress,
          data: encodedIsValidSignatureCall
        },
        "latest"
      ]
    };
    try {
      const response = await this.communicator.send(methods_1.Methods.rpcCall, payload);
      return response.data.slice(0, 10).toLowerCase() === signatures_1.MAGIC_VALUE;
    } catch (err) {
      return false;
    }
  }
  async check1271SignatureBytes(messageHash, signature2 = "0x") {
    const safeInfo2 = await this.getInfo();
    const encodedIsValidSignatureCall = (0, viem_1.encodeFunctionData)({
      abi: [
        {
          constant: false,
          inputs: [
            {
              name: "_data",
              type: "bytes"
            },
            {
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        }
      ],
      functionName: "isValidSignature",
      args: [messageHash, signature2]
    });
    const payload = {
      call: constants_1.RPC_CALLS.eth_call,
      params: [
        {
          to: safeInfo2.safeAddress,
          data: encodedIsValidSignatureCall
        },
        "latest"
      ]
    };
    try {
      const response = await this.communicator.send(methods_1.Methods.rpcCall, payload);
      return response.data.slice(0, 10).toLowerCase() === signatures_1.MAGIC_VALUE_BYTES;
    } catch (err) {
      return false;
    }
  }
  calculateMessageHash(message) {
    return (0, viem_1.hashMessage)(message);
  }
  calculateTypedMessageHash(typedMessage) {
    const chainId = typeof typedMessage.domain.chainId === "object" ? typedMessage.domain.chainId.toNumber() : Number(typedMessage.domain.chainId);
    let primaryType = typedMessage.primaryType;
    if (!primaryType) {
      const fields = Object.values(typedMessage.types);
      const primaryTypes = Object.keys(typedMessage.types).filter((typeName) => fields.every((dataTypes) => dataTypes.every(({ type }) => type.replace("[", "").replace("]", "") !== typeName)));
      if (primaryTypes.length === 0 || primaryTypes.length > 1)
        throw new Error("Please specify primaryType");
      primaryType = primaryTypes[0];
    }
    return (0, viem_1.hashTypedData)({
      message: typedMessage.message,
      domain: Object.assign(Object.assign({}, typedMessage.domain), { chainId, verifyingContract: typedMessage.domain.verifyingContract, salt: typedMessage.domain.salt }),
      types: typedMessage.types,
      primaryType
    });
  }
  async getOffChainSignature(messageHash) {
    const response = await this.communicator.send(methods_1.Methods.getOffChainSignature, messageHash);
    return response.data;
  }
  async isMessageSigned(message, signature2 = "0x") {
    let check2;
    if (typeof message === "string") {
      check2 = async () => {
        const messageHash = this.calculateMessageHash(message);
        const messageHashSigned = await this.isMessageHashSigned(messageHash, signature2);
        return messageHashSigned;
      };
    }
    if ((0, types_1.isObjectEIP712TypedData)(message)) {
      check2 = async () => {
        const messageHash = this.calculateTypedMessageHash(message);
        const messageHashSigned = await this.isMessageHashSigned(messageHash, signature2);
        return messageHashSigned;
      };
    }
    if (check2) {
      const isValid3 = await check2();
      return isValid3;
    }
    throw new Error("Invalid message type");
  }
  async isMessageHashSigned(messageHash, signature2 = "0x") {
    const checks = [this.check1271Signature.bind(this), this.check1271SignatureBytes.bind(this)];
    for (const check2 of checks) {
      const isValid3 = await check2(messageHash, signature2);
      if (isValid3) {
        return true;
      }
    }
    return false;
  }
  async getEnvironmentInfo() {
    const response = await this.communicator.send(methods_1.Methods.getEnvironmentInfo, void 0);
    return response.data;
  }
  async requestAddressBook() {
    const response = await this.communicator.send(methods_1.Methods.requestAddressBook, void 0);
    return response.data;
  }
};
__decorate([
  (0, requirePermissions_1.default)()
], Safe$1.prototype, "requestAddressBook", null);
Safe_1 = safe$2.Safe = Safe$1;
const safe$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get Safe() {
    return Safe_1;
  },
  default: safe$2
}, [safe$2]);
const require$$3$5 = /* @__PURE__ */ getAugmentedNamespace(safe$1);
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(sdk$3, "__esModule", { value: true });
const communication_1 = __importDefault(require$$0$Y);
const txs_1 = require$$1$u;
const eth_1 = require$$2$j;
const safe_1 = require$$3$5;
const wallet_1 = require$$4$4;
let SafeAppsSDK$1 = class SafeAppsSDK2 {
  constructor(opts = {}) {
    const { allowedDomains = null, debug = false } = opts;
    this.communicator = new communication_1.default(allowedDomains, debug);
    this.eth = new eth_1.Eth(this.communicator);
    this.txs = new txs_1.TXs(this.communicator);
    this.safe = new safe_1.Safe(this.communicator);
    this.wallet = new wallet_1.Wallet(this.communicator);
  }
};
var _default = sdk$3.default = SafeAppsSDK$1;
const sdk = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _default
}, [sdk$3]);
const require$$0$t = /* @__PURE__ */ getAugmentedNamespace(sdk);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSDKVersion = void 0;
  const sdk_1 = __importDefault2(require$$0$t);
  exports.default = sdk_1.default;
  __exportStar2(require$$0$t, exports);
  __exportStar2(require$$1$v, exports);
  __exportStar2(require$$2$m, exports);
  __exportStar2(require$$3$j, exports);
  var utils_12 = require$$4$d;
  Object.defineProperty(exports, "getSDKVersion", { enumerable: true, get: function() {
    return utils_12.getSDKVersion;
  } });
})(src$2);
const SafeAppsSDK = /* @__PURE__ */ getDefaultExportFromCjs(src$2);
var _provider, _sdk;
var SafeConnector = class extends Connector {
  constructor({
    chains: chains2,
    options: options_
  }) {
    const options = {
      shimDisconnect: false,
      ...options_
    };
    super({ chains: chains2, options });
    this.id = "safe";
    this.name = "Safe";
    this.ready = !(typeof window === "undefined") && window?.parent !== window;
    __privateAdd$1(this, _provider, void 0);
    __privateAdd$1(this, _sdk, void 0);
    this.shimDisconnectKey = `${this.id}.shimDisconnect`;
    let SDK = SafeAppsSDK;
    if (typeof SafeAppsSDK !== "function" && typeof SafeAppsSDK.default === "function")
      SDK = SafeAppsSDK.default;
    __privateSet$1(this, _sdk, new SDK(options));
  }
  async connect() {
    const provider2 = await this.getProvider();
    if (!provider2)
      throw new ConnectorNotFoundError();
    if (provider2.on) {
      provider2.on("accountsChanged", this.onAccountsChanged);
      provider2.on("chainChanged", this.onChainChanged);
      provider2.on("disconnect", this.onDisconnect);
    }
    this.emit("message", { type: "connecting" });
    const account2 = await this.getAccount();
    const id2 = await this.getChainId();
    if (this.options.shimDisconnect)
      this.storage?.setItem(this.shimDisconnectKey, true);
    return {
      account: account2,
      chain: { id: id2, unsupported: this.isChainUnsupported(id2) }
    };
  }
  async disconnect() {
    const provider2 = await this.getProvider();
    if (!provider2?.removeListener)
      return;
    provider2.removeListener("accountsChanged", this.onAccountsChanged);
    provider2.removeListener("chainChanged", this.onChainChanged);
    provider2.removeListener("disconnect", this.onDisconnect);
    if (this.options.shimDisconnect)
      this.storage?.removeItem(this.shimDisconnectKey);
  }
  async getAccount() {
    const provider2 = await this.getProvider();
    if (!provider2)
      throw new ConnectorNotFoundError();
    const accounts2 = await provider2.request({
      method: "eth_accounts"
    });
    return getAddress$3(accounts2[0]);
  }
  async getChainId() {
    const provider2 = await this.getProvider();
    if (!provider2)
      throw new ConnectorNotFoundError();
    return normalizeChainId(provider2.chainId);
  }
  async getProvider() {
    if (!__privateGet$1(this, _provider)) {
      const safe2 = await __privateGet$1(this, _sdk).safe.getInfo();
      if (!safe2)
        throw new Error("Could not load Safe information");
      __privateSet$1(this, _provider, new dist$4.SafeAppProvider(safe2, __privateGet$1(this, _sdk)));
    }
    return __privateGet$1(this, _provider);
  }
  async getWalletClient({
    chainId
  } = {}) {
    const provider2 = await this.getProvider();
    const account2 = await this.getAccount();
    const chain2 = this.chains.find((x2) => x2.id === chainId);
    if (!provider2)
      throw new Error("provider is required.");
    return createWalletClient$1({
      account: account2,
      chain: chain2,
      transport: custom$3(provider2)
    });
  }
  async isAuthorized() {
    try {
      if (this.options.shimDisconnect && !this.storage?.getItem(this.shimDisconnectKey))
        return false;
      const account2 = await this.getAccount();
      return !!account2;
    } catch {
      return false;
    }
  }
  onAccountsChanged(_accounts) {
  }
  onChainChanged(_chainId) {
  }
  onDisconnect() {
    this.emit("disconnect");
  }
};
_provider = /* @__PURE__ */ new WeakMap();
_sdk = /* @__PURE__ */ new WeakMap();
function requestProviders(listener) {
  const handler = (event) => listener(event.detail);
  window.addEventListener("eip6963:announceProvider", handler);
  window.dispatchEvent(new CustomEvent("eip6963:requestProvider"));
  return () => window.removeEventListener("eip6963:announceProvider", handler);
}
function createStore() {
  const listeners2 = /* @__PURE__ */ new Set();
  let providerDetails = [];
  const request2 = () => requestProviders((providerDetail) => {
    if (providerDetails.some(({ info }) => info.uuid === providerDetail.info.uuid))
      return;
    providerDetails = [...providerDetails, providerDetail];
    listeners2.forEach((listener) => listener(providerDetails, { added: [providerDetail] }));
  });
  let unwatch = request2();
  return {
    _listeners() {
      return listeners2;
    },
    clear() {
      listeners2.forEach((listener) => listener([], { removed: [...providerDetails] }));
      providerDetails = [];
    },
    destroy() {
      this.clear();
      listeners2.clear();
      unwatch();
    },
    findProvider({ rdns }) {
      return providerDetails.find((providerDetail) => providerDetail.info.rdns === rdns);
    },
    getProviders() {
      return providerDetails;
    },
    reset() {
      this.clear();
      unwatch();
      unwatch = request2();
    },
    subscribe(listener, { emitImmediately } = {}) {
      listeners2.add(listener);
      if (emitImmediately)
        listener(providerDetails, { added: providerDetails });
      return () => listeners2.delete(listener);
    }
  };
}
var buffer$3 = {};
var base64Js$1 = {};
var byteLength_1 = base64Js$1.byteLength = byteLength;
var toByteArray_1 = base64Js$1.toByteArray = toByteArray;
var fromByteArray_1 = base64Js$1.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code$3.length; i < len; ++i) {
  lookup[i] = code$3[i];
  revLookup[code$3.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end2) {
  var tmp;
  var output2 = [];
  for (var i2 = start; i2 < end2; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output2.push(tripletToBase64(tmp));
  }
  return output2.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
const base64Js = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  byteLength: byteLength_1,
  default: base64Js$1,
  fromByteArray: fromByteArray_1,
  toByteArray: toByteArray_1
}, [base64Js$1]);
const require$$0$s = /* @__PURE__ */ getAugmentedNamespace(base64Js);
var ieee754$1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var read$1 = ieee754$1.read = function(buffer2, offset, isLE2, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE2 ? nBytes - 1 : 0;
  var d2 = isLE2 ? -1 : 1;
  var s = buffer2[offset + i2];
  i2 += d2;
  e2 = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
var write = ieee754$1.write = function(buffer2, value, offset, isLE2, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE2 ? 0 : nBytes - 1;
  var d2 = isLE2 ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d2] |= s * 128;
};
const ieee754 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ieee754$1,
  read: read$1,
  write
}, [ieee754$1]);
const require$$1$a = /* @__PURE__ */ getAugmentedNamespace(ieee754);
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base642 = require$$0$s;
  const ieee7542 = require$$1$a;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf2 = new Uint8Array(length2);
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize2(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc3(size2, fill, encoding2) {
    assertSize2(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding2 === "string" ? createBuffer(size2).fill(fill, encoding2) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding2) {
    return alloc3(size2, fill, encoding2);
  };
  function allocUnsafe2(size2) {
    assertSize2(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding2) {
    if (typeof encoding2 !== "string" || encoding2 === "") {
      encoding2 = "utf8";
    }
    if (!Buffer2.isEncoding(encoding2)) {
      throw new TypeError("Unknown encoding: " + encoding2);
    }
    const length2 = byteLength2(string2, encoding2) | 0;
    let buf2 = createBuffer(length2);
    const actual = buf2.write(string2, encoding2);
    if (actual !== length2) {
      buf2 = buf2.slice(0, actual);
    }
    return buf2;
  }
  function fromArrayLike(array) {
    const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf2 = createBuffer(length2);
    for (let i2 = 0; i2 < length2; i2 += 1) {
      buf2[i2] = array[i2] & 255;
    }
    return buf2;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length2) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf2;
    if (byteOffset === void 0 && length2 === void 0) {
      buf2 = new Uint8Array(array);
    } else if (length2 === void 0) {
      buf2 = new Uint8Array(array, byteOffset);
    } else {
      buf2 = new Uint8Array(array, byteOffset, length2);
    }
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf2 = createBuffer(len2);
      if (buf2.length === 0) {
        return buf2;
      }
      obj.copy(buf2, 0, 0, len2);
      return buf2;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2)
      return 0;
    let x2 = a2.length;
    let y2 = b2.length;
    for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding2) {
    switch (String(encoding2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length2 === void 0) {
      length2 = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length2 += list[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length2);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf2 = list[i2];
      if (isInstance(buf2, Uint8Array)) {
        if (pos + buf2.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf2))
            buf2 = Buffer2.from(buf2);
          buf2.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf2,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf2.copy(buffer2, pos);
      }
      pos += buf2.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding2) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding2, start, end2) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding2)
      encoding2 = "utf8";
    while (true) {
      switch (encoding2) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice2(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = (encoding2 + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    const i2 = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    const length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice2(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect2() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end2 - start;
    const len2 = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end2);
    for (let i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding2, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding2 = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding2);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding2, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding2, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding2 !== void 0) {
      encoding2 = String(encoding2).toLowerCase();
      if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf2, i3) {
      if (indexSize === 1) {
        return buf2[i3];
      } else {
        return buf2.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read2(arr, i2 + j2) !== read2(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding2) {
    return this.indexOf(val, byteOffset, encoding2) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
  };
  function hexWrite(buf2, string2, offset, length2) {
    offset = Number(offset) || 0;
    const remaining = buf2.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf2[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf2, string2, offset, length2) {
    return blitBuffer(utf8ToBytes2(string2, buf2.length - offset), buf2, offset, length2);
  }
  function asciiWrite(buf2, string2, offset, length2) {
    return blitBuffer(asciiToBytes(string2), buf2, offset, length2);
  }
  function base64Write(buf2, string2, offset, length2) {
    return blitBuffer(base64ToBytes(string2), buf2, offset, length2);
  }
  function ucs2Write(buf2, string2, offset, length2) {
    return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length2);
  }
  Buffer2.prototype.write = function write4(string2, offset, length2, encoding2) {
    if (offset === void 0) {
      encoding2 = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding2 = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding2 === void 0)
          encoding2 = "utf8";
      } else {
        encoding2 = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding2)
      encoding2 = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "hex":
          return hexWrite(this, string2, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length2);
        case "base64":
          return base64Write(this, string2, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf2, start, end2) {
    if (start === 0 && end2 === buf2.length) {
      return base642.fromByteArray(buf2);
    } else {
      return base642.fromByteArray(buf2.slice(start, end2));
    }
  }
  function utf8Slice2(buf2, start, end2) {
    end2 = Math.min(buf2.length, end2);
    const res = [];
    let i2 = start;
    while (i2 < end2) {
      const firstByte = buf2[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end2) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[i2 + 1];
            thirdByte = buf2[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[i2 + 1];
            thirdByte = buf2[i2 + 2];
            fourthByte = buf2[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  const MAX_ARGUMENTS_LENGTH2 = 4096;
  function decodeCodePointsArray2(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH2)
      );
    }
    return res;
  }
  function asciiSlice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf2[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf2[i2]);
    }
    return ret;
  }
  function hexSlice(buf2, start, end2) {
    const len2 = buf2.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len2)
      end2 = len2;
    let out = "";
    for (let i2 = start; i2 < end2; ++i2) {
      out += hexSliceLookupTable[buf2[i2]];
    }
    return out;
  }
  function utf16leSlice(buf2, start, end2) {
    const bytes2 = buf2.slice(start, end2);
    let res = "";
    for (let i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice3(start, end2) {
    const len2 = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len2 : ~~end2;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end2 < 0) {
      end2 += len2;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len2) {
      end2 = len2;
    }
    if (end2 < start)
      end2 = start;
    const newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length2) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul3 = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      val += this[offset + i2] * mul3;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul3 = 1;
    while (byteLength3 > 0 && (mul3 *= 256)) {
      val += this[offset + --byteLength3] * mul3;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul3 = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      val += this[offset + i2] * mul3;
    }
    mul3 *= 128;
    if (val >= mul3)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i2 = byteLength3;
    let mul3 = 1;
    let val = this[offset + --i2];
    while (i2 > 0 && (mul3 *= 256)) {
      val += this[offset + --i2] * mul3;
    }
    mul3 *= 128;
    if (val >= mul3)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, false, 52, 8);
  };
  function checkInt(buf2, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul3 = 1;
    let i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      this[offset + i2] = value / mul3 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul3 = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul3 *= 256)) {
      this[offset + i2] = value / mul3 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf2, value, offset, min, max) {
    checkIntBI(value, min, max, buf2, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf2, value, offset, min, max) {
    checkIntBI(value, min, max, buf2, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf2[offset + 7] = lo;
    lo = lo >> 8;
    buf2[offset + 6] = lo;
    lo = lo >> 8;
    buf2[offset + 5] = lo;
    lo = lo >> 8;
    buf2[offset + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul3 = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul3 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul3 = 1;
    let sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul3 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul3 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf2, value, offset, ext, max, min) {
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 4);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 8);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    const len2 = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end2),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end2, encoding2) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding2 = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding2 = end2;
        end2 = this.length;
      }
      if (encoding2 !== void 0 && typeof encoding2 !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding2 === "string" && !Buffer2.isEncoding(encoding2)) {
        throw new TypeError("Unknown encoding: " + encoding2);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding2 === "utf8" && code2 < 128 || encoding2 === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end2; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding2);
      const len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end2 - start; ++i2) {
        this[i2 + start] = bytes2[i2 % len2];
      }
    }
    return this;
  };
  const errors2 = {};
  function E2(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf2, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf2[offset] === void 0 || buf2[offset + byteLength3] === void 0) {
      boundsError(offset, buf2.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf2, offset, byteLength3) {
    if (value > max || value < min) {
      const n2 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      } else {
        range = `>= ${min}${n2} and <= ${max}${n2}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf2, offset, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length2, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length2 < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length2}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length2) {
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet2[i2] + alphabet2[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$3);
var defaultEnvironment = "production";
var env = typeof process === "undefined" || process.env === void 0 ? defaultEnvironment : "production";
var createDefinition = function(propNames) {
  return {
    isEnabled: function(props) {
      return propNames.some(function(name2) {
        return !!props[name2];
      });
    }
  };
};
var featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: createDefinition([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
function loadFeatures(features) {
  for (var key in features) {
    if (features[key] === null)
      continue;
    if (key === "projectionNodeConstructor") {
      featureDefinitions.projectionNodeConstructor = features[key];
    } else {
      featureDefinitions[key].Component = features[key];
    }
  }
}
var warning = function() {
};
var invariant = function() {
};
var LazyContext = reactExports.createContext({ strict: false });
var featureNames = Object.keys(featureDefinitions);
var numFeatures = featureNames.length;
function useFeatures(props, visualElement2, preloadedFeatures) {
  var features = [];
  var lazyContext = reactExports.useContext(LazyContext);
  if (!visualElement2)
    return null;
  if (env !== "production" && preloadedFeatures && lazyContext.strict)
    ;
  for (var i2 = 0; i2 < numFeatures; i2++) {
    var name_1 = featureNames[i2];
    var _a2 = featureDefinitions[name_1], isEnabled = _a2.isEnabled, Component2 = _a2.Component;
    if (isEnabled(props) && Component2) {
      features.push(reactExports.createElement(Component2, __assign$2({ key: name_1 }, props, { visualElement: visualElement2 })));
    }
  }
  return features;
}
var MotionConfigContext = reactExports.createContext({
  transformPagePoint: function(p2) {
    return p2;
  },
  isStatic: false,
  reducedMotion: "never"
});
var MotionContext = reactExports.createContext({});
function useVisualElementContext() {
  return reactExports.useContext(MotionContext).visualElement;
}
var PresenceContext = reactExports.createContext(null);
var isBrowser$1 = typeof document !== "undefined";
var useIsomorphicLayoutEffect$1 = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect;
var prefersReducedMotion = { current: null };
var hasDetected = false;
function initPrefersReducedMotion() {
  hasDetected = true;
  if (!isBrowser$1)
    return;
  if (window.matchMedia) {
    var motionMediaQuery_1 = window.matchMedia("(prefers-reduced-motion)");
    var setReducedMotionPreferences = function() {
      return prefersReducedMotion.current = motionMediaQuery_1.matches;
    };
    motionMediaQuery_1.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function useReducedMotion() {
  !hasDetected && initPrefersReducedMotion();
  var _a2 = __read$1(reactExports.useState(prefersReducedMotion.current), 1), shouldReduceMotion = _a2[0];
  return shouldReduceMotion;
}
function useReducedMotionConfig() {
  var reducedMotionPreference = useReducedMotion();
  var reducedMotion = reactExports.useContext(MotionConfigContext).reducedMotion;
  if (reducedMotion === "never") {
    return false;
  } else if (reducedMotion === "always") {
    return true;
  } else {
    return reducedMotionPreference;
  }
}
function useVisualElement(Component2, visualState, props, createVisualElement) {
  var lazyContext = reactExports.useContext(LazyContext);
  var parent = useVisualElementContext();
  var presenceContext = reactExports.useContext(PresenceContext);
  var shouldReduceMotion = useReducedMotionConfig();
  var visualElementRef = reactExports.useRef(void 0);
  if (!createVisualElement)
    createVisualElement = lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component2, {
      visualState,
      parent,
      props,
      presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,
      blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,
      shouldReduceMotion
    });
  }
  var visualElement2 = visualElementRef.current;
  useIsomorphicLayoutEffect$1(function() {
    visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
  });
  reactExports.useEffect(function() {
    var _a2;
    (_a2 = visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.animateChanges();
  });
  useIsomorphicLayoutEffect$1(function() {
    return function() {
      return visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.notifyUnmount();
    };
  }, []);
  return visualElement2;
}
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement2, externalRef) {
  return reactExports.useCallback(
    function(instance) {
      var _a2;
      instance && ((_a2 = visualState.mount) === null || _a2 === void 0 ? void 0 : _a2.call(visualState, instance));
      if (visualElement2) {
        instance ? visualElement2.mount(instance) : visualElement2.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement2]
  );
}
function isVariantLabels(v2) {
  return Array.isArray(v2);
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || isVariantLabels(v2);
}
function getCurrent(visualElement2) {
  var current = {};
  visualElement2.forEachValue(function(value, key) {
    return current[key] = value.get();
  });
  return current;
}
function getVelocity$1(visualElement2) {
  var velocity = {};
  visualElement2.forEachValue(function(value, key) {
    return velocity[key] = value.getVelocity();
  });
  return velocity;
}
function resolveVariantFromProps(props, definition, custom2, currentValues, currentVelocity) {
  var _a2;
  if (currentValues === void 0) {
    currentValues = {};
  }
  if (currentVelocity === void 0) {
    currentVelocity = {};
  }
  if (typeof definition === "function") {
    definition = definition(custom2 !== null && custom2 !== void 0 ? custom2 : props.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = (_a2 = props.variants) === null || _a2 === void 0 ? void 0 : _a2[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom2 !== null && custom2 !== void 0 ? custom2 : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
function resolveVariant(visualElement2, definition, custom2) {
  var props = visualElement2.getProps();
  return resolveVariantFromProps(props, definition, custom2 !== null && custom2 !== void 0 ? custom2 : props.custom, getCurrent(visualElement2), getVelocity$1(visualElement2));
}
function checkIfControllingVariants(props) {
  var _a2;
  return typeof ((_a2 = props.animate) === null || _a2 === void 0 ? void 0 : _a2.start) === "function" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);
}
function checkIfVariantNode(props) {
  return Boolean(checkIfControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (checkIfControllingVariants(props)) {
    var initial = props.initial, animate2 = props.animate;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  var _a2 = getCurrentTreeVariants(props, reactExports.useContext(MotionContext)), initial = _a2.initial, animate2 = _a2.animate;
  return reactExports.useMemo(function() {
    return { initial, animate: animate2 };
  }, [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
function useConstant(init) {
  var ref = reactExports.useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
var globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
var id = 1;
function useProjectionId() {
  return useConstant(function() {
    if (globalProjectionState.hasEverUpdated) {
      return id++;
    }
  });
}
var LayoutGroupContext = reactExports.createContext({});
var SwitchLayoutGroupContext = reactExports.createContext({});
function useProjection(projectionId, _a2, visualElement2, ProjectionNodeConstructor) {
  var _b;
  var layoutId = _a2.layoutId, layout = _a2.layout, drag2 = _a2.drag, dragConstraints = _a2.dragConstraints, layoutScroll = _a2.layoutScroll;
  var initialPromotionConfig = reactExports.useContext(SwitchLayoutGroupContext);
  if (!ProjectionNodeConstructor || !visualElement2 || (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.projection)) {
    return;
  }
  visualElement2.projection = new ProjectionNodeConstructor(projectionId, visualElement2.getLatestValues(), (_b = visualElement2.parent) === null || _b === void 0 ? void 0 : _b.projection);
  visualElement2.projection.setOptions({
    layoutId,
    layout,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement: visualElement2,
    scheduleRender: function() {
      return visualElement2.scheduleRender();
    },
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout === "string" ? layout : "both",
    initialPromotionConfig,
    layoutScroll
  });
}
var VisualElementHandler = (
  /** @class */
  function(_super) {
    __extends$1(VisualElementHandler2, _super);
    function VisualElementHandler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VisualElementHandler2.prototype.getSnapshotBeforeUpdate = function() {
      this.updateProps();
      return null;
    };
    VisualElementHandler2.prototype.componentDidUpdate = function() {
    };
    VisualElementHandler2.prototype.updateProps = function() {
      var _a2 = this.props, visualElement2 = _a2.visualElement, props = _a2.props;
      if (visualElement2)
        visualElement2.setProps(props);
    };
    VisualElementHandler2.prototype.render = function() {
      return this.props.children;
    };
    return VisualElementHandler2;
  }(React$1.Component)
);
function createMotionComponent(_a2) {
  var preloadedFeatures = _a2.preloadedFeatures, createVisualElement = _a2.createVisualElement, projectionNodeConstructor = _a2.projectionNodeConstructor, useRender = _a2.useRender, useVisualState = _a2.useVisualState, Component2 = _a2.Component;
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    var layoutId = useLayoutId(props);
    props = __assign$2(__assign$2({}, props), { layoutId });
    var config2 = reactExports.useContext(MotionConfigContext);
    var features = null;
    var context = useCreateMotionContext(props);
    var projectionId = config2.isStatic ? void 0 : useProjectionId();
    var visualState = useVisualState(props, config2.isStatic);
    if (!config2.isStatic && isBrowser$1) {
      context.visualElement = useVisualElement(Component2, visualState, __assign$2(__assign$2({}, config2), props), createVisualElement);
      useProjection(projectionId, props, context.visualElement, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor);
      features = useFeatures(props, context.visualElement, preloadedFeatures);
    }
    return reactExports.createElement(
      VisualElementHandler,
      { visualElement: context.visualElement, props: __assign$2(__assign$2({}, config2), props) },
      features,
      reactExports.createElement(MotionContext.Provider, { value: context }, useRender(Component2, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config2.isStatic, context.visualElement))
    );
  }
  return reactExports.forwardRef(MotionComponent);
}
function useLayoutId(_a2) {
  var _b;
  var layoutId = _a2.layoutId;
  var layoutGroupId = (_b = reactExports.useContext(LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function createMotionProxy(createConfig2) {
  function custom2(Component2, customMotionComponentConfig) {
    if (customMotionComponentConfig === void 0) {
      customMotionComponentConfig = {};
    }
    return createMotionComponent(createConfig2(Component2, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom2;
  }
  var componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom2, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: function(_target, key) {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom2(key));
      }
      return componentCache.get(key);
    }
  });
}
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component2) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component2 !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component2.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component2) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component2)
  ) {
    return true;
  }
  return false;
}
var scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
var transformAxes = ["", "X", "Y", "Z"];
var order = ["translate", "scale", "rotate", "skew"];
var transformProps = ["transformPerspective", "x", "y", "z"];
order.forEach(function(operationKey) {
  return transformAxes.forEach(function(axesKey) {
    return transformProps.push(operationKey + axesKey);
  });
});
function sortTransformProps(a2, b2) {
  return transformProps.indexOf(a2) - transformProps.indexOf(b2);
}
var transformPropSet = new Set(transformProps);
function isTransformProp(key) {
  return transformPropSet.has(key);
}
var transformOriginProps = /* @__PURE__ */ new Set(["originX", "originY", "originZ"]);
function isTransformOriginProp(key) {
  return transformOriginProps.has(key);
}
function isForcedMotionValue(key, _a2) {
  var layout = _a2.layout, layoutId = _a2.layoutId;
  return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
var isMotionValue = function(value) {
  return Boolean(value !== null && typeof value === "object" && value.getVelocity);
};
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
function buildTransform(_a2, _b, transformIsDefault, transformTemplate) {
  var transform2 = _a2.transform, transformKeys2 = _a2.transformKeys;
  var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;
  var transformString = "";
  transformKeys2.sort(sortTransformProps);
  var transformHasZ = false;
  var numTransformKeys = transformKeys2.length;
  for (var i2 = 0; i2 < numTransformKeys; i2++) {
    var key = transformKeys2[i2];
    transformString += "".concat(translateAlias[key] || key, "(").concat(transform2[key], ") ");
    if (key === "z")
      transformHasZ = true;
  }
  if (!transformHasZ && enableHardwareAcceleration) {
    transformString += "translateZ(0)";
  } else {
    transformString = transformString.trim();
  }
  if (transformTemplate) {
    transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildTransformOrigin(_a2) {
  var _b = _a2.originX, originX = _b === void 0 ? "50%" : _b, _c = _a2.originY, originY = _c === void 0 ? "50%" : _c, _d = _a2.originZ, originZ = _d === void 0 ? 0 : _d;
  return "".concat(originX, " ").concat(originY, " ").concat(originZ);
}
function isCSSVariable$1(key) {
  return key.startsWith("--");
}
var getValueAsType = function(value, type) {
  return type && typeof value === "number" ? type.transform(value) : value;
};
const clamp$1 = (min, max) => (v2) => Math.max(Math.min(v2, max), min);
const sanitize = (v2) => v2 % 1 ? Number(v2.toFixed(5)) : v2;
const floatRegex = /(-)?([\d]*\.?[\d])+/g;
const colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
const singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
function isString(v2) {
  return typeof v2 === "string";
}
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha = Object.assign(Object.assign({}, number), { transform: clamp$1(0, 1) });
const scale = Object.assign(Object.assign({}, number), { default: 1 });
const createUnitType = (unit2) => ({
  test: (v2) => isString(v2) && v2.endsWith(unit2) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit2}`
});
const degrees = createUnitType("deg");
const percent = createUnitType("%");
const px = createUnitType("px");
const vh = createUnitType("vh");
const vw = createUnitType("vw");
const progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v2) => percent.parse(v2) / 100, transform: (v2) => percent.transform(v2 * 100) });
const isColorString = (type, testProp) => (v2) => {
  return Boolean(isString(v2) && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (!isString(v2))
    return v2;
  const [a2, b2, c2, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const clampRgbUnit = clamp$1(0, 255);
const rgbUnit = Object.assign(Object.assign({}, number), { transform: (v2) => Math.round(clampRgbUnit(v2)) });
const rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v2) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a2 = "";
  if (v2.length > 5) {
    r2 = v2.substr(1, 2);
    g2 = v2.substr(3, 2);
    b2 = v2.substr(5, 2);
    a2 = v2.substr(7, 2);
  } else {
    r2 = v2.substr(1, 1);
    g2 = v2.substr(2, 1);
    b2 = v2.substr(3, 1);
    a2 = v2.substr(4, 1);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return isString(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  }
};
const colorToken = "${c}";
const numberToken = "${n}";
function test(v2) {
  var _a2, _b, _c, _d;
  return isNaN(v2) && isString(v2) && ((_b = (_a2 = v2.match(floatRegex)) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v2.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;
}
function analyse$1(v2) {
  if (typeof v2 === "number")
    v2 = `${v2}`;
  const values = [];
  let numColors = 0;
  const colors = v2.match(colorRegex);
  if (colors) {
    numColors = colors.length;
    v2 = v2.replace(colorRegex, colorToken);
    values.push(...colors.map(color.parse));
  }
  const numbers = v2.match(floatRegex);
  if (numbers) {
    v2 = v2.replace(floatRegex, numberToken);
    values.push(...numbers.map(number.parse));
  }
  return { values, numColors, tokenised: v2 };
}
function parse(v2) {
  return analyse$1(v2).values;
}
function createTransformer(v2) {
  const { values, numColors, tokenised } = analyse$1(v2);
  const numValues = values.length;
  return (v3) => {
    let output2 = tokenised;
    for (let i2 = 0; i2 < numValues; i2++) {
      output2 = output2.replace(i2 < numColors ? colorToken : numberToken, i2 < numColors ? color.transform(v3[i2]) : sanitize(v3[i2]));
    }
    return output2;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
function getAnimatableNone$1(v2) {
  const parsed = parse(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = { test, parse, createTransformer, getAnimatableNone: getAnimatableNone$1 };
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  let [name2, value] = v2.slice(0, -1).split("(");
  if (name2 === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit2 = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name2) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name2 + "(" + defaultValue + unit2 + ")";
}
const functionRegex = /([a-z-]*)\(.*?\)/g;
const filter$2 = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v2) => {
  const functions = v2.match(functionRegex);
  return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
} });
var int = __assign$2(__assign$2({}, number), { transform: Math.round });
var numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  var _a2;
  var style2 = state.style, vars = state.vars, transform2 = state.transform, transformKeys2 = state.transformKeys, transformOrigin = state.transformOrigin;
  transformKeys2.length = 0;
  var hasTransform2 = false;
  var hasTransformOrigin = false;
  var transformIsNone = true;
  for (var key in latestValues) {
    var value = latestValues[key];
    if (isCSSVariable$1(key)) {
      vars[key] = value;
      continue;
    }
    var valueType = numberValueTypes[key];
    var valueAsType = getValueAsType(value, valueType);
    if (isTransformProp(key)) {
      hasTransform2 = true;
      transform2[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      if (value !== ((_a2 = valueType.default) !== null && _a2 !== void 0 ? _a2 : 0))
        transformIsNone = false;
    } else if (isTransformOriginProp(key)) {
      transformOrigin[key] = valueAsType;
      hasTransformOrigin = true;
    } else {
      style2[key] = valueAsType;
    }
  }
  if (hasTransform2) {
    style2.transform = buildTransform(state, options, transformIsNone, transformTemplate);
  } else if (transformTemplate) {
    style2.transform = transformTemplate({}, "");
  } else if (!latestValues.transform && style2.transform) {
    style2.transform = "none";
  }
  if (hasTransformOrigin) {
    style2.transformOrigin = buildTransformOrigin(transformOrigin);
  }
}
var createHtmlRenderState = function() {
  return {
    style: {},
    transform: {},
    transformKeys: [],
    transformOrigin: {},
    vars: {}
  };
};
function copyRawValuesOnly(target, source, props) {
  for (var key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues(_a2, visualState, isStatic) {
  var transformTemplate = _a2.transformTemplate;
  return reactExports.useMemo(function() {
    var state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
    var vars = state.vars, style2 = state.style;
    return __assign$2(__assign$2({}, vars), style2);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  var styleProp = props.style || {};
  var style2 = {};
  copyRawValuesOnly(style2, styleProp, props);
  Object.assign(style2, useInitialMotionValues(props, visualState, isStatic));
  if (props.transformValues) {
    style2 = props.transformValues(style2);
  }
  return style2;
}
function useHTMLProps(props, visualState, isStatic) {
  var htmlProps = {};
  var style2 = useStyle(props, visualState, isStatic);
  if (Boolean(props.drag) && props.dragListener !== false) {
    htmlProps.draggable = false;
    style2.userSelect = style2.WebkitUserSelect = style2.WebkitTouchCallout = "none";
    style2.touchAction = props.drag === true ? "none" : "pan-".concat(props.drag === "x" ? "y" : "x");
  }
  htmlProps.style = style2;
  return htmlProps;
}
var validMotionProps = /* @__PURE__ */ new Set([
  "initial",
  "animate",
  "exit",
  "style",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "layout",
  "layoutId",
  "layoutDependency",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "drag",
  "dragControls",
  "dragListener",
  "dragConstraints",
  "dragDirectionLock",
  "dragSnapToOrigin",
  "_dragX",
  "_dragY",
  "dragElastic",
  "dragMomentum",
  "dragPropagation",
  "dragTransition",
  "whileDrag",
  "onPan",
  "onPanStart",
  "onPanEnd",
  "onPanSessionStart",
  "onTap",
  "onTapStart",
  "onTapCancel",
  "onHoverStart",
  "onHoverEnd",
  "whileFocus",
  "whileTap",
  "whileHover",
  "whileInView",
  "onViewportEnter",
  "onViewportLeave",
  "viewport",
  "layoutScroll"
]);
function isValidMotionProp(key) {
  return validMotionProps.has(key);
}
var shouldForward = function(key) {
  return !isValidMotionProp(key);
};
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = function(key) {
    return key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  };
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a2) {
}
function filterProps(props, isDom, forwardMotionProps) {
  var filteredProps = {};
  for (var key in props) {
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
function calcOrigin$1(origin, offset, size2) {
  return typeof origin === "string" ? origin : px.transform(offset + size2 * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return "".concat(pxOriginX, " ").concat(pxOriginY);
}
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing, offset, useDashCase) {
  if (spacing === void 0) {
    spacing = 1;
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (useDashCase === void 0) {
    useDashCase = true;
  }
  attrs.pathLength = 1;
  var keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px.transform(-offset);
  var pathLength = px.transform(length2);
  var pathSpacing = px.transform(spacing);
  attrs[keys2.array] = "".concat(pathLength, " ").concat(pathSpacing);
}
function buildSVGAttrs(state, _a2, options, transformTemplate) {
  var attrX = _a2.attrX, attrY = _a2.attrY, originX = _a2.originX, originY = _a2.originY, pathLength = _a2.pathLength, _b = _a2.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a2.pathOffset, pathOffset = _c === void 0 ? 0 : _c, latest = __rest$2(_a2, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
  buildHTMLStyles(state, latest, options, transformTemplate);
  state.attrs = state.style;
  state.style = {};
  var attrs = state.attrs, style2 = state.style, dimensions = state.dimensions;
  if (attrs.transform) {
    if (dimensions)
      style2.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style2.transform)) {
    style2.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
var createSvgRenderState = function() {
  return __assign$2(__assign$2({}, createHtmlRenderState()), { attrs: {} });
};
function useSVGProps(props, visualState) {
  var visualProps = reactExports.useMemo(function() {
    var state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);
    return __assign$2(__assign$2({}, state.attrs), { style: __assign$2({}, state.style) });
  }, [visualState]);
  if (props.style) {
    var rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = __assign$2(__assign$2({}, rawStyles), visualProps.style);
  }
  return visualProps;
}
function createUseRender(forwardMotionProps) {
  if (forwardMotionProps === void 0) {
    forwardMotionProps = false;
  }
  var useRender = function(Component2, props, projectionId, ref, _a2, isStatic) {
    var latestValues = _a2.latestValues;
    var useVisualProps = isSVGComponent(Component2) ? useSVGProps : useHTMLProps;
    var visualProps = useVisualProps(props, latestValues, isStatic);
    var filteredProps = filterProps(props, typeof Component2 === "string", forwardMotionProps);
    var elementProps = __assign$2(__assign$2(__assign$2({}, filteredProps), visualProps), { ref });
    if (projectionId) {
      elementProps["data-projection-id"] = projectionId;
    }
    return reactExports.createElement(Component2, elementProps);
  };
  return useRender;
}
var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = "$1-$2";
var camelToDash = function(str) {
  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};
function renderHTML(element, _a2, styleProp, projection) {
  var style2 = _a2.style, vars = _a2.vars;
  Object.assign(element.style, style2, projection && projection.getProjectionStyles(styleProp));
  for (var key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (var key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
function scrapeMotionValuesFromProps$1(props) {
  var style2 = props.style;
  var newValues = {};
  for (var key in style2) {
    if (isMotionValue(style2[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style2[key];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps(props) {
  var newValues = scrapeMotionValuesFromProps$1(props);
  for (var key in props) {
    if (isMotionValue(props[key])) {
      var targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
function isAnimationControls(v2) {
  return typeof v2 === "object" && typeof v2.start === "function";
}
var isKeyframesTarget = function(v2) {
  return Array.isArray(v2);
};
var isCustomValue = function(v2) {
  return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
};
var resolveFinalValueInKeyframes = function(v2) {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
};
function resolveMotionValue(value) {
  var unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState(_a2, props, context, presenceContext) {
  var scrapeMotionValuesFromProps2 = _a2.scrapeMotionValuesFromProps, createRenderState = _a2.createRenderState, onMount = _a2.onMount;
  var state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = function(instance) {
      return onMount(props, instance, state);
    };
  }
  return state;
}
var makeUseVisualState = function(config2) {
  return function(props, isStatic) {
    var context = reactExports.useContext(MotionContext);
    var presenceContext = reactExports.useContext(PresenceContext);
    return isStatic ? makeState(config2, props, context, presenceContext) : useConstant(function() {
      return makeState(config2, props, context, presenceContext);
    });
  };
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  var values = {};
  var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;
  var motionValues = scrapeMotionValues(props);
  for (var key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  var initial = props.initial, animate2 = props.animate;
  var isControllingVariants = checkIfControllingVariants(props);
  var isVariantNode = checkIfVariantNode(props);
  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {
    initial !== null && initial !== void 0 ? initial : initial = context.initial;
    animate2 !== null && animate2 !== void 0 ? animate2 : animate2 = context.animate;
  }
  var initialAnimationIsBlocked = blockInitialAnimation || initial === false;
  var variantToSet = initialAnimationIsBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach(function(definition) {
      var resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      var transitionEnd = resolved.transitionEnd;
      resolved.transition;
      var target = __rest$2(resolved, ["transitionEnd", "transition"]);
      for (var key2 in target) {
        var valueTarget = target[key2];
        if (Array.isArray(valueTarget)) {
          var index2 = initialAnimationIsBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index2];
        }
        if (valueTarget !== null) {
          values[key2] = valueTarget;
        }
      }
      for (var key2 in transitionEnd)
        values[key2] = transitionEnd[key2];
    });
  }
  return values;
}
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: function(props, instance, _a2) {
      var renderState = _a2.renderState, latestValues = _a2.latestValues;
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e2) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);
      renderSVG(instance, renderState);
    }
  })
};
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component2, _a2, preloadedFeatures, createVisualElement, projectionNodeConstructor) {
  var _b = _a2.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;
  var baseConfig = isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig;
  return __assign$2(__assign$2({}, baseConfig), { preloadedFeatures, useRender: createUseRender(forwardMotionProps), createVisualElement, projectionNodeConstructor, Component: Component2 });
}
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["InView"] = "whileInView";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));
function addDomEvent(target, eventName, handler, options) {
  if (options === void 0) {
    options = { passive: true };
  }
  target.addEventListener(eventName, handler, options);
  return function() {
    return target.removeEventListener(eventName, handler);
  };
}
function useDomEvent(ref, eventName, handler, options) {
  reactExports.useEffect(function() {
    var element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}
function useFocusGesture(_a2) {
  var whileFocus = _a2.whileFocus, visualElement2 = _a2.visualElement;
  var onFocus = function() {
    var _a3;
    (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Focus, true);
  };
  var onBlur = function() {
    var _a3;
    (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Focus, false);
  };
  useDomEvent(visualElement2, "focus", whileFocus ? onFocus : void 0);
  useDomEvent(visualElement2, "blur", whileFocus ? onBlur : void 0);
}
function isMouseEvent(event) {
  if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof MouseEvent;
}
function isTouchEvent(event) {
  var hasTouches = !!event.touches;
  return hasTouches;
}
function filterPrimaryPointer(eventHandler) {
  return function(event) {
    var isMouseEvent2 = event instanceof MouseEvent;
    var isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
var defaultPagePoint = { pageX: 0, pageY: 0 };
function pointFromTouch(e2, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  var primaryTouch = e2.touches[0] || e2.changedTouches[0];
  var point = primaryTouch || defaultPagePoint;
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function pointFromMouse(point, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function extractEventInfo(event, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
var wrapHandler = function(handler, shouldFilterPrimaryPointer) {
  if (shouldFilterPrimaryPointer === void 0) {
    shouldFilterPrimaryPointer = false;
  }
  var listener = function(event) {
    return handler(event, extractEventInfo(event));
  };
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
};
var supportsPointerEvents = function() {
  return isBrowser$1 && window.onpointerdown === null;
};
var supportsTouchEvents = function() {
  return isBrowser$1 && window.ontouchstart === null;
};
var supportsMouseEvents = function() {
  return isBrowser$1 && window.onmousedown === null;
};
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name2) {
  if (supportsPointerEvents()) {
    return name2;
  } else if (supportsTouchEvents()) {
    return touchEventNames[name2];
  } else if (supportsMouseEvents()) {
    return mouseEventNames[name2];
  }
  return name2;
}
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options);
}
function usePointerEvent(ref, eventName, handler, options) {
  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === "pointerdown"), options);
}
function createLock(name2) {
  var lock = null;
  return function() {
    var openLock = function() {
      lock = null;
    };
    if (lock === null) {
      lock = name2;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  var lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    var openHorizontal_1 = globalHorizontalLock();
    var openVertical_1 = globalVerticalLock();
    if (openHorizontal_1 && openVertical_1) {
      lock = function() {
        openHorizontal_1();
        openVertical_1();
      };
    } else {
      if (openHorizontal_1)
        openHorizontal_1();
      if (openVertical_1)
        openVertical_1();
    }
  }
  return lock;
}
function isDragActive() {
  var openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}
function createHoverEvent(visualElement2, isActive, callback) {
  return function(event, info) {
    var _a2;
    if (!isMouseEvent(event) || isDragActive())
      return;
    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Hover, isActive);
    callback === null || callback === void 0 ? void 0 : callback(event, info);
  };
}
function useHoverGesture(_a2) {
  var onHoverStart = _a2.onHoverStart, onHoverEnd = _a2.onHoverEnd, whileHover = _a2.whileHover, visualElement2 = _a2.visualElement;
  usePointerEvent(visualElement2, "pointerenter", onHoverStart || whileHover ? createHoverEvent(visualElement2, true, onHoverStart) : void 0, { passive: !onHoverStart });
  usePointerEvent(visualElement2, "pointerleave", onHoverEnd || whileHover ? createHoverEvent(visualElement2, false, onHoverEnd) : void 0, { passive: !onHoverEnd });
}
var isNodeOrChild = function(parent, child) {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
function useUnmountEffect(callback) {
  return reactExports.useEffect(function() {
    return function() {
      return callback();
    };
  }, []);
}
const clamp = (min, max, v2) => Math.min(Math.max(v2, min), max);
const safeMin = 1e-3;
const minDuration = 0.01;
const maxDuration = 10;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= maxDuration * 1e3);
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys2) {
  return keys2.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring(_a2) {
  var { from: from2 = 0, to = 1, restSpeed = 2, restDelta } = _a2, options = __rest$2(_a2, ["from", "to", "restSpeed", "restDelta"]);
  const state = { done: false, value: from2 };
  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  let resolveSpring = zero;
  let resolveVelocity = zero;
  function createSpring() {
    const initialVelocity = velocity ? -(velocity / 1e3) : 0;
    const initialDelta = to - from2;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    if (restDelta === void 0) {
      restDelta = Math.min(Math.abs(to - from2) / 100, 0.4);
    }
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
      };
      resolveVelocity = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t2) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t2)) - envelope * (Math.cos(angularFreq * t2) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t2));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t2) => to - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        const freqForT = Math.min(dampedAngularFreq * t2, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        const currentVelocity = resolveVelocity(t2) * 1e3;
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration;
      }
      state.value = state.done ? to : current;
      return state;
    },
    flipTarget: () => {
      velocity = -velocity;
      [from2, to] = [to, from2];
      createSpring();
    }
  };
}
spring.needsInterpolation = (a2, b2) => typeof a2 === "string" || typeof b2 === "string";
const zero = (_t2) => 0;
const progress = (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};
const mix = (from2, to, progress2) => -progress2 * from2 + progress2 * to + from2;
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red = hueToRgb(p2, q2, hue + 1 / 3);
    green = hueToRgb(p2, q2, hue);
    blue = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
const mixLinearColor = (from2, to, v2) => {
  const fromExpo = from2 * from2;
  const toExpo = to * to;
  return Math.sqrt(Math.max(0, v2 * (toExpo - fromExpo) + fromExpo));
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v2) => colorTypes.find((type) => type.test(v2));
const mixColor = (from2, to) => {
  let fromColorType = getColorType(from2);
  let toColorType = getColorType(to);
  let fromColor = fromColorType.parse(from2);
  let toColor = toColorType.parse(to);
  if (fromColorType === hsla) {
    fromColor = hslaToRgba(fromColor);
    fromColorType = rgba;
  }
  if (toColorType === hsla) {
    toColor = hslaToRgba(toColor);
    toColorType = rgba;
  }
  const blended = Object.assign({}, fromColor);
  return (v2) => {
    for (const key in blended) {
      if (key !== "alpha") {
        blended[key] = mixLinearColor(fromColor[key], toColor[key], v2);
      }
    }
    blended.alpha = mix(fromColor.alpha, toColor.alpha, v2);
    return fromColorType.transform(blended);
  };
};
const isNum = (v2) => typeof v2 === "number";
const combineFunctions = (a2, b2) => (v2) => b2(a2(v2));
const pipe$2 = (...transformers) => transformers.reduce(combineFunctions);
function getMixer(origin, target) {
  if (isNum(origin)) {
    return (v2) => mix(origin, target, v2);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
const mixArray = (from2, to) => {
  const output2 = [...from2];
  const numValues = output2.length;
  const blendValue = from2.map((fromThis, i2) => getMixer(fromThis, to[i2]));
  return (v2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output2[i2] = blendValue[i2](v2);
    }
    return output2;
  };
};
const mixObject = (origin, target) => {
  const output2 = Object.assign(Object.assign({}, origin), target);
  const blendValue = {};
  for (const key in output2) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output2[key] = blendValue[key](v2);
    }
    return output2;
  };
};
function analyse(value) {
  const parsed = complex.parse(value);
  const numValues = parsed.length;
  let numNumbers = 0;
  let numRGB = 0;
  let numHSL = 0;
  for (let i2 = 0; i2 < numValues; i2++) {
    if (numNumbers || typeof parsed[i2] === "number") {
      numNumbers++;
    } else {
      if (parsed[i2].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyse(origin);
  const targetStats = analyse(target);
  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe$2(mixArray(originStats.parsed, targetStats.parsed), template);
  } else {
    return (p2) => `${p2 > 0 ? target : origin}`;
  }
};
const mixNumber = (from2, to) => (p2) => mix(from2, to, p2);
function detectMixerFactory(v2) {
  if (typeof v2 === "number") {
    return mixNumber;
  } else if (typeof v2 === "string") {
    if (color.test(v2)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v2)) {
    return mixArray;
  } else if (typeof v2 === "object") {
    return mixObject;
  }
}
function createMixers(output2, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output2[0]);
  const numMixers = output2.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output2[i2], output2[i2 + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i2] : ease;
      mixer = pipe$2(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate([from2, to], [mixer]) {
  return (v2) => mixer(progress(from2, to, v2));
}
function slowInterpolate(input, mixers) {
  const inputLength = input.length;
  const lastInputIndex = inputLength - 1;
  return (v2) => {
    let mixerIndex = 0;
    let foundMixerIndex = false;
    if (v2 <= input[0]) {
      foundMixerIndex = true;
    } else if (v2 >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      let i2 = 1;
      for (; i2 < inputLength; i2++) {
        if (input[i2] > v2 || i2 === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i2 - 1;
    }
    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v2);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output2, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output2.length);
  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1);
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output2 = [].concat(output2);
    input.reverse();
    output2.reverse();
  }
  const mixers = createMixers(output2, ease, mixer);
  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}
const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
const createExpoIn = (power) => (p2) => Math.pow(p2, power);
const createBackIn = (power) => (p2) => p2 * p2 * ((power + 1) * p2 - power);
const createAnticipate = (power) => {
  const backEasing = createBackIn(power);
  return (p2) => (p2 *= 2) < 1 ? 0.5 * backEasing(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
};
const DEFAULT_OVERSHOOT_STRENGTH = 1.525;
const BOUNCE_FIRST_THRESHOLD = 4 / 11;
const BOUNCE_SECOND_THRESHOLD = 8 / 11;
const BOUNCE_THIRD_THRESHOLD = 9 / 10;
const linear = (p2) => p2;
const easeIn = createExpoIn(2);
const easeOut = reverseEasing(easeIn);
const easeInOut = mirrorEasing(easeIn);
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circOut);
const backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
const backOut = reverseEasing(backIn);
const backInOut = mirrorEasing(backIn);
const anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
const ca = 4356 / 361;
const cb = 35442 / 1805;
const cc = 16061 / 1805;
const bounceOut = (p2) => {
  if (p2 === 1 || p2 === 0)
    return p2;
  const p22 = p2 * p2;
  return p2 < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p22 : p2 < BOUNCE_SECOND_THRESHOLD ? 9.075 * p22 - 9.9 * p2 + 3.4 : p2 < BOUNCE_THIRD_THRESHOLD ? ca * p22 - cb * p2 + cc : 10.8 * p2 * p2 - 20.52 * p2 + 10.72;
};
const bounceIn = reverseEasing(bounceOut);
const bounceInOut = (p2) => p2 < 0.5 ? 0.5 * (1 - bounceOut(1 - p2 * 2)) : 0.5 * bounceOut(p2 * 2 - 1) + 0.5;
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value, i2) => i2 !== 0 ? i2 / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o) => o * duration);
}
function keyframes$1({ from: from2 = 0, to = 1, ease, offset, duration = 300 }) {
  const state = { done: false, value: from2 };
  const values = Array.isArray(to) ? to : [from2, to];
  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);
  function createInterpolator() {
    return interpolate(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: (t2) => {
      state.value = interpolator(t2);
      state.done = t2 >= duration;
      return state;
    },
    flipTarget: () => {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}
function decay({ velocity = 0, from: from2 = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {
  const state = { done: false, value: from2 };
  let amplitude = power * velocity;
  const ideal = from2 + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - from2;
  return {
    next: (t2) => {
      const delta = -amplitude * Math.exp(-t2 / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: () => {
    }
  };
}
const types$1 = { keyframes: keyframes$1, spring, decay };
function detectAnimationFromOptions(config2) {
  if (Array.isArray(config2.to)) {
    return keyframes$1;
  } else if (types$1[config2.type]) {
    return types$1[config2.type];
  }
  const keys2 = new Set(Object.keys(config2));
  if (keys2.has("ease") || keys2.has("duration") && !keys2.has("dampingRatio")) {
    return keyframes$1;
  } else if (keys2.has("dampingRatio") || keys2.has("stiffness") || keys2.has("mass") || keys2.has("damping") || keys2.has("restSpeed") || keys2.has("restDelta")) {
    return spring;
  }
  return keyframes$1;
}
const defaultTimestep = 1 / 60 * 1e3;
const getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
const onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer2 = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer2.indexOf(callback) === -1) {
        buffer2.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index2 = toRunNextFrame.indexOf(callback);
      if (index2 !== -1)
        toRunNextFrame.splice(index2, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i2 = 0; i2 < numToRun; i2++) {
          const callback = toRun[i2];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
let isProcessing = false;
const frame$1 = {
  delta: 0,
  timestamp: 0
};
const stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
const sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
const cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
const flushSync = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame$1);
  return acc;
}, {});
const processStep = (stepId) => steps[stepId].process(frame$1);
const processFrame = (timestamp) => {
  runNextFrame = false;
  frame$1.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame$1.timestamp, maxElapsed), 1);
  frame$1.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
const getFrameData = () => frame$1;
function loopElapsed(elapsed, duration, delay2 = 0) {
  return elapsed - duration - delay2;
}
function reverseElapsed(elapsed, duration, delay2 = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay2) : duration - (elapsed - duration) + delay2;
}
function hasRepeatDelayElapsed(elapsed, duration, delay2, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay2 : elapsed <= -delay2;
}
const framesync = (update) => {
  const passTimestamp = ({ delta }) => update(delta);
  return {
    start: () => sync.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
};
function animate$1(_a2) {
  var _b, _c;
  var { from: from2, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a2, options = __rest$2(_a2, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let { to } = options;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = options.duration;
  let latest;
  let isComplete = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = detectAnimationFromOptions(options);
  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from2, to)) {
    interpolateFromNumber = interpolate([0, 100], [from2, to], {
      clamp: false
    });
    from2 = 0;
    to = 100;
  }
  const animation = animator(Object.assign(Object.assign({}, options), { from: from2, to }));
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete) {
      const state = animation.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber)
        latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0)
        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
function inertia({ from: from2 = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {
  let currentAnimation;
  function isOutOfBounds(v2) {
    return min !== void 0 && v2 < min || max !== void 0 && v2 > max;
  }
  function boundaryNearest(v2) {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v2) < Math.abs(max - v2) ? min : max;
  }
  function startAnimation2(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate$1(Object.assign(Object.assign({}, options), {
      driver,
      onUpdate: (v2) => {
        var _a2;
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v2);
        (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, v2);
      },
      onComplete,
      onStop
    }));
  }
  function startSpring(options) {
    startAnimation2(Object.assign({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));
  }
  if (isOutOfBounds(from2)) {
    startSpring({ from: from2, velocity, to: boundaryNearest(from2) });
  } else {
    let target = power * velocity + from2;
    if (typeof modifyTarget !== "undefined")
      target = modifyTarget(target);
    const boundary = boundaryNearest(target);
    const heading = boundary === min ? -1 : 1;
    let prev;
    let current;
    const checkBoundary = (v2) => {
      prev = current;
      current = v2;
      velocity = velocityPerSecond(v2 - prev, getFrameData().delta);
      if (heading === 1 && v2 > boundary || heading === -1 && v2 < boundary) {
        startSpring({ from: v2, to: boundary, velocity });
      }
    };
    startAnimation2({
      type: "decay",
      from: from2,
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0
    });
  }
  return {
    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()
  };
}
const isPoint = (point) => point.hasOwnProperty("x") && point.hasOwnProperty("y");
const isPoint3D = (point) => isPoint(point) && point.hasOwnProperty("z");
const distance1D = (a2, b2) => Math.abs(a2 - b2);
function distance(a2, b2) {
  if (isNum(a2) && isNum(b2)) {
    return distance1D(a2, b2);
  } else if (isPoint(a2) && isPoint(b2)) {
    const xDelta = distance1D(a2.x, b2.x);
    const yDelta = distance1D(a2.y, b2.y);
    const zDelta = isPoint3D(a2) && isPoint3D(b2) ? distance1D(a2.z, b2.z) : 0;
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
}
const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;
const b$4 = (a1, a2) => 3 * a2 - 6 * a1;
const c$2 = (a1) => 3 * a1;
const calcBezier = (t2, a1, a2) => ((a(a1, a2) * t2 + b$4(a1, a2)) * t2 + c$2(a1)) * t2;
const getSlope = (t2, a1, a2) => 3 * a(a1, a2) * t2 * t2 + 2 * b$4(a1, a2) * t2 + c$2(a1);
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 10;
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
const newtonIterations = 8;
const newtonMinSlope = 1e-3;
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (let i2 = 0; i2 < newtonIterations; ++i2) {
    const currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
const kSplineTableSize = 11;
const kSampleStepSize = 1 / (kSplineTableSize - 1);
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return linear;
  const sampleValues = new Float32Array(kSplineTableSize);
  for (let i2 = 0; i2 < kSplineTableSize; ++i2) {
    sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    let intervalStart = 0;
    let currentSample = 1;
    const lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    const dist2 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    const guessForT = intervalStart + dist2 * kSampleStepSize;
    const initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= newtonMinSlope) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
function useTapGesture(_a2) {
  var onTap = _a2.onTap, onTapStart = _a2.onTapStart, onTapCancel = _a2.onTapCancel, whileTap = _a2.whileTap, visualElement2 = _a2.visualElement;
  var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
  var isPressing = reactExports.useRef(false);
  var cancelPointerEndListeners = reactExports.useRef(null);
  var eventOptions = {
    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)
  };
  function removePointerEndListener() {
    var _a3;
    (_a3 = cancelPointerEndListeners.current) === null || _a3 === void 0 ? void 0 : _a3.call(cancelPointerEndListeners);
    cancelPointerEndListeners.current = null;
  }
  function checkPointerEnd() {
    var _a3;
    removePointerEndListener();
    isPressing.current = false;
    (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Tap, false);
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    if (!checkPointerEnd())
      return;
    !isNodeOrChild(visualElement2.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);
  }
  function onPointerCancel(event, info) {
    if (!checkPointerEnd())
      return;
    onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);
  }
  function onPointerDown(event, info) {
    var _a3;
    removePointerEndListener();
    if (isPressing.current)
      return;
    isPressing.current = true;
    cancelPointerEndListeners.current = pipe$2(addPointerEvent(window, "pointerup", onPointerUp, eventOptions), addPointerEvent(window, "pointercancel", onPointerCancel, eventOptions));
    (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Tap, true);
    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);
  }
  usePointerEvent(visualElement2, "pointerdown", hasPressListeners ? onPointerDown : void 0, eventOptions);
  useUnmountEffect(removePointerEndListener);
}
var warned = /* @__PURE__ */ new Set();
function warnOnce(condition, message, element) {
  if (condition || warned.has(message))
    return;
  console.warn(message);
  if (element)
    console.warn(element);
  warned.add(message);
}
var observerCallbacks = /* @__PURE__ */ new WeakMap();
var observers$1 = /* @__PURE__ */ new WeakMap();
var fireObserverCallback = function(entry) {
  var _a2;
  (_a2 = observerCallbacks.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
};
var fireAllObserverCallbacks = function(entries) {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver(_a2) {
  var root2 = _a2.root, options = __rest$2(_a2, ["root"]);
  var lookupRoot = root2 || document;
  if (!observers$1.has(lookupRoot)) {
    observers$1.set(lookupRoot, {});
  }
  var rootObservers = observers$1.get(lookupRoot);
  var key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __assign$2({ root: root2 }, options));
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  var rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return function() {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
function useViewport(_a2) {
  var visualElement2 = _a2.visualElement, whileInView = _a2.whileInView, onViewportEnter = _a2.onViewportEnter, onViewportLeave = _a2.onViewportLeave, _b = _a2.viewport, viewport = _b === void 0 ? {} : _b;
  var state = reactExports.useRef({
    hasEnteredView: false,
    isInView: false
  });
  var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);
  if (viewport.once && state.current.hasEnteredView)
    shouldObserve = false;
  var useObserver = typeof IntersectionObserver === "undefined" ? useMissingIntersectionObserver : useIntersectionObserver;
  useObserver(shouldObserve, state.current, visualElement2, viewport);
}
var thresholdNames = {
  some: 0,
  all: 1
};
function useIntersectionObserver(shouldObserve, state, visualElement2, _a2) {
  var root2 = _a2.root, rootMargin = _a2.margin, _b = _a2.amount, amount = _b === void 0 ? "some" : _b, once3 = _a2.once;
  reactExports.useEffect(function() {
    if (!shouldObserve)
      return;
    var options = {
      root: root2 === null || root2 === void 0 ? void 0 : root2.current,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    var intersectionCallback = function(entry) {
      var _a3;
      var isIntersecting = entry.isIntersecting;
      if (state.isInView === isIntersecting)
        return;
      state.isInView = isIntersecting;
      if (once3 && !isIntersecting && state.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        state.hasEnteredView = true;
      }
      (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.InView, isIntersecting);
      var props = visualElement2.getProps();
      var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;
      callback === null || callback === void 0 ? void 0 : callback(entry);
    };
    return observeIntersection(visualElement2.getInstance(), options, intersectionCallback);
  }, [shouldObserve, root2, rootMargin, amount]);
}
function useMissingIntersectionObserver(shouldObserve, state, visualElement2, _a2) {
  var _b = _a2.fallback, fallback2 = _b === void 0 ? true : _b;
  reactExports.useEffect(function() {
    if (!shouldObserve || !fallback2)
      return;
    if (env !== "production") {
      warnOnce(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount.");
    }
    requestAnimationFrame(function() {
      var _a3;
      state.hasEnteredView = true;
      var onViewportEnter = visualElement2.getProps().onViewportEnter;
      onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);
      (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.InView, true);
    });
  }, [shouldObserve]);
}
var makeRenderlessComponent = function(hook) {
  return function(props) {
    hook(props);
    return null;
  };
};
var gestureAnimations = {
  inView: makeRenderlessComponent(useViewport),
  tap: makeRenderlessComponent(useTapGesture),
  focus: makeRenderlessComponent(useFocusGesture),
  hover: makeRenderlessComponent(useHoverGesture)
};
var counter = 0;
var incrementId = function() {
  return counter++;
};
var useId = function() {
  return useConstant(incrementId);
};
function usePresence() {
  var context = reactExports.useContext(PresenceContext);
  if (context === null)
    return [true, null];
  var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;
  var id2 = useId();
  reactExports.useEffect(function() {
    return register(id2);
  }, []);
  var safeToRemove = function() {
    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id2);
  };
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  var prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (var i2 = 0; i2 < prevLength; i2++) {
    if (prev[i2] !== next[i2])
      return false;
  }
  return true;
}
var secondsToMilliseconds = function(seconds) {
  return seconds * 1e3;
};
var easingLookup = {
  linear,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
  bounceIn,
  bounceInOut,
  bounceOut
};
var easingDefinitionToFunction = function(definition) {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4);
    var _a2 = __read$1(definition, 4), x1 = _a2[0], y1 = _a2[1], x2 = _a2[2], y2 = _a2[3];
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    return easingLookup[definition];
  }
  return definition;
};
var isEasingArray = function(ease) {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};
var isAnimatable = function(key, value) {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  complex.test(value) && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
var underDampedSpring = function() {
  return {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
};
var criticallyDampedSpring = function(to) {
  return {
    type: "spring",
    stiffness: 550,
    damping: to === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  };
};
var linearTween = function() {
  return {
    type: "keyframes",
    ease: "linear",
    duration: 0.3
  };
};
var keyframes = function(values) {
  return {
    type: "keyframes",
    duration: 0.8,
    values
  };
};
var defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
var getDefaultTransition = function(valueKey, to) {
  var transitionFactory;
  if (isKeyframesTarget(to)) {
    transitionFactory = keyframes;
  } else {
    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
  }
  return __assign$2({ to }, transitionFactory(to));
};
var defaultValueTypes = __assign$2(__assign$2({}, numberValueTypes), {
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter: filter$2,
  WebkitFilter: filter$2
});
var getDefaultValueType = function(key) {
  return defaultValueTypes[key];
};
function getAnimatableNone(key, value) {
  var _a2;
  var defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter$2)
    defaultValueType = complex;
  return (_a2 = defaultValueType.getAnimatableNone) === null || _a2 === void 0 ? void 0 : _a2.call(defaultValueType, value);
}
function isTransitionDefined(_a2) {
  _a2.when;
  _a2.delay;
  _a2.delayChildren;
  _a2.staggerChildren;
  _a2.staggerDirection;
  _a2.repeat;
  _a2.repeatType;
  _a2.repeatDelay;
  _a2.from;
  var transition2 = __rest$2(_a2, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);
  return !!Object.keys(transition2).length;
}
function convertTransitionToAnimationOptions(_a2) {
  var ease = _a2.ease, times = _a2.times, yoyo = _a2.yoyo, flip = _a2.flip, loop = _a2.loop, transition2 = __rest$2(_a2, ["ease", "times", "yoyo", "flip", "loop"]);
  var options = __assign$2({}, transition2);
  if (times)
    options["offset"] = times;
  if (transition2.duration)
    options["duration"] = secondsToMilliseconds(transition2.duration);
  if (transition2.repeatDelay)
    options.repeatDelay = secondsToMilliseconds(transition2.repeatDelay);
  if (ease) {
    options["ease"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  }
  if (transition2.type === "tween")
    options.type = "keyframes";
  if (yoyo || loop || flip) {
    if (yoyo) {
      options.repeatType = "reverse";
    } else if (loop) {
      options.repeatType = "loop";
    } else if (flip) {
      options.repeatType = "mirror";
    }
    options.repeat = loop || yoyo || flip || transition2.repeat;
  }
  if (transition2.type !== "spring")
    options.type = "keyframes";
  return options;
}
function getDelayFromTransition(transition2, key) {
  var _a2, _b;
  var valueTransition = getValueTransition(transition2, key) || {};
  return (_b = (_a2 = valueTransition.delay) !== null && _a2 !== void 0 ? _a2 : transition2.delay) !== null && _b !== void 0 ? _b : 0;
}
function hydrateKeyframes(options) {
  if (Array.isArray(options.to) && options.to[0] === null) {
    options.to = __spreadArray$1([], __read$1(options.to), false);
    options.to[0] = options.from;
  }
  return options;
}
function getPopmotionAnimationOptions(transition2, options, key) {
  var _a2;
  if (Array.isArray(options.to)) {
    (_a2 = transition2.duration) !== null && _a2 !== void 0 ? _a2 : transition2.duration = 0.8;
  }
  hydrateKeyframes(options);
  if (!isTransitionDefined(transition2)) {
    transition2 = __assign$2(__assign$2({}, transition2), getDefaultTransition(key, options.to));
  }
  return __assign$2(__assign$2({}, options), convertTransitionToAnimationOptions(transition2));
}
function getAnimation(key, value, target, transition2, onComplete) {
  var _a2;
  var valueTransition = getValueTransition(transition2, key);
  var origin = (_a2 = valueTransition.from) !== null && _a2 !== void 0 ? _a2 : value.get();
  var isTargetAnimatable = isAnimatable(key, target);
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    origin = getAnimatableNone(key, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  var isOriginAnimatable = isAnimatable(key, origin);
  function start() {
    var options = {
      from: origin,
      to: target,
      velocity: value.getVelocity(),
      onComplete,
      onUpdate: function(v2) {
        return value.set(v2);
      }
    };
    return valueTransition.type === "inertia" || valueTransition.type === "decay" ? inertia(__assign$2(__assign$2({}, options), valueTransition)) : animate$1(__assign$2(__assign$2({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function(v2) {
      var _a3;
      options.onUpdate(v2);
      (_a3 = valueTransition.onUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(valueTransition, v2);
    }, onComplete: function() {
      var _a3;
      options.onComplete();
      (_a3 = valueTransition.onComplete) === null || _a3 === void 0 ? void 0 : _a3.call(valueTransition);
    } }));
  }
  function set() {
    var _a3, _b;
    var finalTarget = resolveFinalValueInKeyframes(target);
    value.set(finalTarget);
    onComplete();
    (_a3 = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(valueTransition, finalTarget);
    (_b = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _b === void 0 ? void 0 : _b.call(valueTransition);
    return { stop: function() {
    } };
  }
  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone("", potentialUnitType);
}
function getValueTransition(transition2, key) {
  return transition2[key] || transition2["default"] || transition2;
}
function startAnimation(key, value, target, transition2) {
  if (transition2 === void 0) {
    transition2 = {};
  }
  return value.start(function(onComplete) {
    var delayTimer;
    var controls;
    var animation = getAnimation(key, value, target, transition2, onComplete);
    var delay2 = getDelayFromTransition(transition2, key);
    var start = function() {
      return controls = animation();
    };
    if (delay2) {
      delayTimer = window.setTimeout(start, secondsToMilliseconds(delay2));
    } else {
      start();
    }
    return function() {
      clearTimeout(delayTimer);
      controls === null || controls === void 0 ? void 0 : controls.stop();
    };
  });
}
var isNumericalString = function(v2) {
  return /^\-?\d*\.?\d+$/.test(v2);
};
var isZeroValueString = function(v2) {
  return /^0[^.\s]+$/.test(v2);
};
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  var index2 = arr.indexOf(item);
  index2 > -1 && arr.splice(index2, 1);
}
var SubscriptionManager = (
  /** @class */
  function() {
    function SubscriptionManager2() {
      this.subscriptions = [];
    }
    SubscriptionManager2.prototype.add = function(handler) {
      var _this = this;
      addUniqueItem(this.subscriptions, handler);
      return function() {
        return removeItem(_this.subscriptions, handler);
      };
    };
    SubscriptionManager2.prototype.notify = function(a2, b2, c2) {
      var numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a2, b2, c2);
      } else {
        for (var i2 = 0; i2 < numSubscriptions; i2++) {
          var handler = this.subscriptions[i2];
          handler && handler(a2, b2, c2);
        }
      }
    };
    SubscriptionManager2.prototype.getSize = function() {
      return this.subscriptions.length;
    };
    SubscriptionManager2.prototype.clear = function() {
      this.subscriptions.length = 0;
    };
    return SubscriptionManager2;
  }()
);
var isFloat = function(value) {
  return !isNaN(parseFloat(value));
};
var MotionValue = (
  /** @class */
  function() {
    function MotionValue2(init) {
      var _this = this;
      this.version = "6.5.1";
      this.timeDelta = 0;
      this.lastUpdated = 0;
      this.updateSubscribers = new SubscriptionManager();
      this.velocityUpdateSubscribers = new SubscriptionManager();
      this.renderSubscribers = new SubscriptionManager();
      this.canTrackVelocity = false;
      this.updateAndNotify = function(v2, render3) {
        if (render3 === void 0) {
          render3 = true;
        }
        _this.prev = _this.current;
        _this.current = v2;
        var _a2 = getFrameData(), delta = _a2.delta, timestamp = _a2.timestamp;
        if (_this.lastUpdated !== timestamp) {
          _this.timeDelta = delta;
          _this.lastUpdated = timestamp;
          sync.postRender(_this.scheduleVelocityCheck);
        }
        if (_this.prev !== _this.current) {
          _this.updateSubscribers.notify(_this.current);
        }
        if (_this.velocityUpdateSubscribers.getSize()) {
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
        if (render3) {
          _this.renderSubscribers.notify(_this.current);
        }
      };
      this.scheduleVelocityCheck = function() {
        return sync.postRender(_this.velocityCheck);
      };
      this.velocityCheck = function(_a2) {
        var timestamp = _a2.timestamp;
        if (timestamp !== _this.lastUpdated) {
          _this.prev = _this.current;
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
      };
      this.hasAnimated = false;
      this.prev = this.current = init;
      this.canTrackVelocity = isFloat(this.current);
    }
    MotionValue2.prototype.onChange = function(subscription) {
      return this.updateSubscribers.add(subscription);
    };
    MotionValue2.prototype.clearListeners = function() {
      this.updateSubscribers.clear();
    };
    MotionValue2.prototype.onRenderRequest = function(subscription) {
      subscription(this.get());
      return this.renderSubscribers.add(subscription);
    };
    MotionValue2.prototype.attach = function(passiveEffect) {
      this.passiveEffect = passiveEffect;
    };
    MotionValue2.prototype.set = function(v2, render3) {
      if (render3 === void 0) {
        render3 = true;
      }
      if (!render3 || !this.passiveEffect) {
        this.updateAndNotify(v2, render3);
      } else {
        this.passiveEffect(v2, this.updateAndNotify);
      }
    };
    MotionValue2.prototype.get = function() {
      return this.current;
    };
    MotionValue2.prototype.getPrevious = function() {
      return this.prev;
    };
    MotionValue2.prototype.getVelocity = function() {
      return this.canTrackVelocity ? (
        // These casts could be avoided if parseFloat would be typed better
        velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      ) : 0;
    };
    MotionValue2.prototype.start = function(animation) {
      var _this = this;
      this.stop();
      return new Promise(function(resolve) {
        _this.hasAnimated = true;
        _this.stopAnimation = animation(resolve);
      }).then(function() {
        return _this.clearAnimation();
      });
    };
    MotionValue2.prototype.stop = function() {
      if (this.stopAnimation)
        this.stopAnimation();
      this.clearAnimation();
    };
    MotionValue2.prototype.isAnimating = function() {
      return !!this.stopAnimation;
    };
    MotionValue2.prototype.clearAnimation = function() {
      this.stopAnimation = null;
    };
    MotionValue2.prototype.destroy = function() {
      this.updateSubscribers.clear();
      this.renderSubscribers.clear();
      this.stop();
    };
    return MotionValue2;
  }()
);
function motionValue(init) {
  return new MotionValue(init);
}
var testValueType = function(v2) {
  return function(type) {
    return type.test(v2);
  };
};
var auto = {
  test: function(v2) {
    return v2 === "auto";
  },
  parse: function(v2) {
    return v2;
  }
};
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var findDimensionValueType = function(v2) {
  return dimensionValueTypes.find(testValueType(v2));
};
var valueTypes = __spreadArray$1(__spreadArray$1([], __read$1(dimensionValueTypes), false), [color, complex], false);
var findValueType = function(v2) {
  return valueTypes.find(testValueType(v2));
};
function setMotionValue(visualElement2, key, value) {
  if (visualElement2.hasValue(key)) {
    visualElement2.getValue(key).set(value);
  } else {
    visualElement2.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement2, definition) {
  var resolved = resolveVariant(visualElement2, definition);
  var _a2 = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {}, _b = _a2.transitionEnd, transitionEnd = _b === void 0 ? {} : _b;
  _a2.transition;
  var target = __rest$2(_a2, ["transitionEnd", "transition"]);
  target = __assign$2(__assign$2({}, target), transitionEnd);
  for (var key in target) {
    var value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement2, key, value);
  }
}
function checkTargetForNewValues(visualElement2, target, origin) {
  var _a2, _b, _c;
  var _d;
  var newValueKeys = Object.keys(target).filter(function(key2) {
    return !visualElement2.hasValue(key2);
  });
  var numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (var i2 = 0; i2 < numNewValues; i2++) {
    var key = newValueKeys[i2];
    var targetValue = target[key];
    var value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a2 = origin[key]) !== null && _a2 !== void 0 ? _a2 : visualElement2.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone(key, targetValue);
    }
    visualElement2.addValue(key, motionValue(value));
    (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;
    visualElement2.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition2) {
  if (!transition2)
    return;
  var valueTransition = transition2[key] || transition2["default"] || transition2;
  return valueTransition.from;
}
function getOrigin(target, transition2, visualElement2) {
  var _a2, _b;
  var origin = {};
  for (var key in target) {
    origin[key] = (_a2 = getOriginFromTransition(key, transition2)) !== null && _a2 !== void 0 ? _a2 : (_b = visualElement2.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();
  }
  return origin;
}
function animateVisualElement(visualElement2, definition, options) {
  if (options === void 0) {
    options = {};
  }
  visualElement2.notifyAnimationStart(definition);
  var animation;
  if (Array.isArray(definition)) {
    var animations2 = definition.map(function(variant) {
      return animateVariant(visualElement2, variant, options);
    });
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement2, definition, options);
  } else {
    var resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement2, definition, options.custom) : definition;
    animation = animateTarget(visualElement2, resolvedDefinition, options);
  }
  return animation.then(function() {
    return visualElement2.notifyAnimationComplete(definition);
  });
}
function animateVariant(visualElement2, variant, options) {
  var _a2;
  if (options === void 0) {
    options = {};
  }
  var resolved = resolveVariant(visualElement2, variant, options.custom);
  var _b = (resolved || {}).transition, transition2 = _b === void 0 ? visualElement2.getDefaultTransition() || {} : _b;
  if (options.transitionOverride) {
    transition2 = options.transitionOverride;
  }
  var getAnimation2 = resolved ? function() {
    return animateTarget(visualElement2, resolved, options);
  } : function() {
    return Promise.resolve();
  };
  var getChildAnimations = ((_a2 = visualElement2.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.size) ? function(forwardDelay) {
    if (forwardDelay === void 0) {
      forwardDelay = 0;
    }
    var _a3 = transition2.delayChildren, delayChildren = _a3 === void 0 ? 0 : _a3, staggerChildren = transition2.staggerChildren, staggerDirection = transition2.staggerDirection;
    return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : function() {
    return Promise.resolve();
  };
  var when = transition2.when;
  if (when) {
    var _c = __read$1(when === "beforeChildren" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2], 2), first = _c[0], last2 = _c[1];
    return first().then(last2);
  } else {
    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);
  }
}
function animateTarget(visualElement2, definition, _a2) {
  var _b;
  var _c = _a2 === void 0 ? {} : _a2, _d = _c.delay, delay2 = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;
  var _e2 = visualElement2.makeTargetAnimatable(definition), _f = _e2.transition, transition2 = _f === void 0 ? visualElement2.getDefaultTransition() : _f, transitionEnd = _e2.transitionEnd, target = __rest$2(_e2, ["transition", "transitionEnd"]);
  if (transitionOverride)
    transition2 = transitionOverride;
  var animations2 = [];
  var animationTypeState = type && ((_b = visualElement2.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);
  for (var key in target) {
    var value = visualElement2.getValue(key);
    var valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    var valueTransition = __assign$2({ delay: delay2 }, transition2);
    if (visualElement2.shouldReduceMotion && isTransformProp(key)) {
      valueTransition = __assign$2(__assign$2({}, valueTransition), { type: false, delay: 0 });
    }
    var animation = startAnimation(key, value, valueTarget, valueTransition);
    animations2.push(animation);
  }
  return Promise.all(animations2).then(function() {
    transitionEnd && setTarget(visualElement2, transitionEnd);
  });
}
function animateChildren(visualElement2, variant, delayChildren, staggerChildren, staggerDirection, options) {
  if (delayChildren === void 0) {
    delayChildren = 0;
  }
  if (staggerChildren === void 0) {
    staggerChildren = 0;
  }
  if (staggerDirection === void 0) {
    staggerDirection = 1;
  }
  var animations2 = [];
  var maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;
  var generateStaggerDuration = staggerDirection === 1 ? function(i2) {
    if (i2 === void 0) {
      i2 = 0;
    }
    return i2 * staggerChildren;
  } : function(i2) {
    if (i2 === void 0) {
      i2 = 0;
    }
    return maxStaggerDuration - i2 * staggerChildren;
  };
  Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach(function(child, i2) {
    animations2.push(animateVariant(child, variant, __assign$2(__assign$2({}, options), { delay: delayChildren + generateStaggerDuration(i2) })).then(function() {
      return child.notifyAnimationComplete(variant);
    }));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function shouldBlockAnimation(_a2, key) {
  var protectedKeys = _a2.protectedKeys, needsAnimating = _a2.needsAnimating;
  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
var variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.InView,
  AnimationType.Focus,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Exit
];
var reversePriorityOrder = __spreadArray$1([], __read$1(variantPriorityOrder), false).reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement2) {
  return function(animations2) {
    return Promise.all(animations2.map(function(_a2) {
      var animation = _a2.animation, options = _a2.options;
      return animateVisualElement(visualElement2, animation, options);
    }));
  };
}
function createAnimationState(visualElement2) {
  var animate2 = animateList(visualElement2);
  var state = createState();
  var allAnimatedKeys = {};
  var isInitialRender = true;
  var buildResolvedTypeValues = function(acc, definition) {
    var resolved = resolveVariant(visualElement2, definition);
    if (resolved) {
      resolved.transition;
      var transitionEnd = resolved.transitionEnd, target = __rest$2(resolved, ["transition", "transitionEnd"]);
      acc = __assign$2(__assign$2(__assign$2({}, acc), target), transitionEnd);
    }
    return acc;
  };
  function isAnimated(key) {
    return allAnimatedKeys[key] !== void 0;
  }
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement2);
  }
  function animateChanges(options, changedActiveType) {
    var _a2;
    var props = visualElement2.getProps();
    var context = visualElement2.getVariantContext(true) || {};
    var animations2 = [];
    var removedKeys = /* @__PURE__ */ new Set();
    var encounteredKeys = {};
    var removedVariantIndex = Infinity;
    var _loop_1 = function(i3) {
      var type = reversePriorityOrder[i3];
      var typeState = state[type];
      var prop = (_a2 = props[type]) !== null && _a2 !== void 0 ? _a2 : context[type];
      var propIsVariant = isVariantLabel(prop);
      var activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i3;
      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = __assign$2({}, encounteredKeys);
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        return "continue";
      }
      var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      var shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i3 > removedVariantIndex && propIsVariant;
      var definitionList = Array.isArray(prop) ? prop : [prop];
      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;
      var allKeys = __assign$2(__assign$2({}, prevResolvedValues), resolvedValues);
      var markToAnimate = function(key2) {
        shouldAnimateType = true;
        removedKeys.delete(key2);
        typeState.needsAnimating[key2] = true;
      };
      for (var key in allKeys) {
        var next = resolvedValues[key];
        var prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev) || variantDidChange) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = __assign$2(__assign$2({}, encounteredKeys), resolvedValues);
      }
      if (isInitialRender && visualElement2.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push.apply(animations2, __spreadArray$1([], __read$1(definitionList.map(function(animation) {
          return {
            animation,
            options: __assign$2({ type }, options)
          };
        })), false));
      }
    };
    for (var i2 = 0; i2 < numAnimationTypes; i2++) {
      _loop_1(i2);
    }
    allAnimatedKeys = __assign$2({}, encounteredKeys);
    if (removedKeys.size) {
      var fallbackAnimation_1 = {};
      removedKeys.forEach(function(key) {
        var fallbackTarget = visualElement2.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation_1[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation_1 });
    }
    var shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate2(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a2;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a2 = visualElement2.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
      var _a3;
      return (_a3 = child.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    var animations2 = animateChanges(options, type);
    for (var key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    isAnimated,
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: function() {
      return state;
    }
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (isVariantLabels(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive) {
  if (isActive === void 0) {
    isActive = false;
  }
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  var _a2;
  return _a2 = {}, _a2[AnimationType.Animate] = createTypeState(true), _a2[AnimationType.InView] = createTypeState(), _a2[AnimationType.Hover] = createTypeState(), _a2[AnimationType.Tap] = createTypeState(), _a2[AnimationType.Drag] = createTypeState(), _a2[AnimationType.Focus] = createTypeState(), _a2[AnimationType.Exit] = createTypeState(), _a2;
}
var animations = {
  animation: makeRenderlessComponent(function(_a2) {
    var visualElement2 = _a2.visualElement, animate2 = _a2.animate;
    visualElement2.animationState || (visualElement2.animationState = createAnimationState(visualElement2));
    if (isAnimationControls(animate2)) {
      reactExports.useEffect(function() {
        return animate2.subscribe(visualElement2);
      }, [animate2]);
    }
  }),
  exit: makeRenderlessComponent(function(props) {
    var custom2 = props.custom, visualElement2 = props.visualElement;
    var _a2 = __read$1(usePresence(), 2), isPresent = _a2[0], safeToRemove = _a2[1];
    var presenceContext = reactExports.useContext(PresenceContext);
    reactExports.useEffect(function() {
      var _a3, _b;
      visualElement2.isPresent = isPresent;
      var animation = (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Exit, !isPresent, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom2 });
      !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(safeToRemove));
    }, [isPresent]);
  })
};
var PanSession = (
  /** @class */
  function() {
    function PanSession2(event, handlers, _a2) {
      var _this = this;
      var _b = _a2 === void 0 ? {} : _a2, transformPagePoint = _b.transformPagePoint;
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.updatePoint = function() {
        if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))
          return;
        var info2 = getPanInfo(_this.lastMoveEventInfo, _this.history);
        var isPanStarted = _this.startEvent !== null;
        var isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        var point2 = info2.point;
        var timestamp2 = getFrameData().timestamp;
        _this.history.push(__assign$2(__assign$2({}, point2), { timestamp: timestamp2 }));
        var _a3 = _this.handlers, onStart = _a3.onStart, onMove = _a3.onMove;
        if (!isPanStarted) {
          onStart && onStart(_this.lastMoveEvent, info2);
          _this.startEvent = _this.lastMoveEvent;
        }
        onMove && onMove(_this.lastMoveEvent, info2);
      };
      this.handlePointerMove = function(event2, info2) {
        _this.lastMoveEvent = event2;
        _this.lastMoveEventInfo = transformPoint(info2, _this.transformPagePoint);
        if (isMouseEvent(event2) && event2.buttons === 0) {
          _this.handlePointerUp(event2, info2);
          return;
        }
        sync.update(_this.updatePoint, true);
      };
      this.handlePointerUp = function(event2, info2) {
        _this.end();
        var _a3 = _this.handlers, onEnd = _a3.onEnd, onSessionEnd = _a3.onSessionEnd;
        var panInfo = getPanInfo(transformPoint(info2, _this.transformPagePoint), _this.history);
        if (_this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (isTouchEvent(event) && event.touches.length > 1)
        return;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      var info = extractEventInfo(event);
      var initialInfo = transformPoint(info, this.transformPagePoint);
      var point = initialInfo.point;
      var timestamp = getFrameData().timestamp;
      this.history = [__assign$2(__assign$2({}, point), { timestamp })];
      var onSessionStart = handlers.onSessionStart;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe$2(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
    }
    PanSession2.prototype.updateHandlers = function(handlers) {
      this.handlers = handlers;
    };
    PanSession2.prototype.end = function() {
      this.removeListeners && this.removeListeners();
      cancelSync.update(this.updatePoint);
    };
    return PanSession2;
  }()
);
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo(_a2, history) {
  var point = _a2.point;
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  var i2 = history.length - 1;
  var timestampedPoint = null;
  var lastPoint = lastDevicePoint(history);
  while (i2 >= 0) {
    timestampedPoint = history[i2];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i2--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  var time2 = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  var currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  if (target === void 0) {
    target = 0;
  }
  if (maxDistance === void 0) {
    maxDistance = 0.01;
  }
  return distance(value, target) < maxDistance;
}
function calcAxisDelta(delta, source, target, origin) {
  if (origin === void 0) {
    origin = 0.5;
  }
  delta.origin = origin;
  delta.originPoint = mix(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);
  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout, parent) {
  target.min = layout.min - parent.min;
  target.max = target.min + calcLength(layout);
}
function calcRelativePosition(target, layout, parent) {
  calcRelativeAxisPosition(target.x, layout.x, parent.x);
  calcRelativeAxisPosition(target.y, layout.y, parent.y);
}
function applyConstraints(point, _a2, elastic) {
  var min = _a2.min, max = _a2.max;
  if (min !== void 0 && point < min) {
    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, _a2) {
  var top = _a2.top, left = _a2.left, bottom = _a2.bottom, right = _a2.right;
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  var _a2;
  var min = constraintsAxis.min - layoutAxis.min;
  var max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    _a2 = __read$1([max, min], 2), min = _a2[0], max = _a2[1];
  }
  return { min, max };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  var origin = 0.5;
  var sourceLength = calcLength(source);
  var targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout, constraints) {
  var relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic) {
  if (dragElastic === void 0) {
    dragElastic = defaultElastic;
  }
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  var _a2;
  return typeof dragElastic === "number" ? dragElastic : (_a2 = dragElastic[label]) !== null && _a2 !== void 0 ? _a2 : 0;
}
var createAxisDelta = function() {
  return {
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  };
};
var createDelta = function() {
  return {
    x: createAxisDelta(),
    y: createAxisDelta()
  };
};
var createAxis = function() {
  return { min: 0, max: 0 };
};
var createBox = function() {
  return {
    x: createAxis(),
    y: createAxis()
  };
};
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox(_a2) {
  var top = _a2.top, left = _a2.left, right = _a2.right, bottom = _a2.bottom;
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox(_a2) {
  var x2 = _a2.x, y2 = _a2.y;
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  var topLeft = transformPoint2({ x: point.left, y: point.top });
  var bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale(_a2) {
  var scale2 = _a2.scale, scaleX = _a2.scaleX, scaleY = _a2.scaleY;
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || hasTranslate(values.x) || hasTranslate(values.y) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function hasTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  var distanceFromOrigin = point - originPoint;
  var scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate, scale2, originPoint, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, _a2) {
  var x2 = _a2.x, y2 = _a2.y;
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {
  var _a2, _b;
  if (isSharedTransition === void 0) {
    isSharedTransition = false;
  }
  var treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  var node2;
  var delta;
  for (var i2 = 0; i2 < treeLength; i2++) {
    node2 = treePath[i2];
    delta = node2.projectionDelta;
    if (((_b = (_a2 = node2.instance) === null || _a2 === void 0 ? void 0 : _a2.style) === null || _b === void 0 ? void 0 : _b.display) === "contents")
      continue;
    if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
      transformBox(box, { x: -node2.scroll.x, y: -node2.scroll.y });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node2.latestValues)) {
      transformBox(box, node2.latestValues);
    }
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms, _a2) {
  var _b = __read$1(_a2, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  var axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  var originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
}
var xKeys$1 = ["x", "scaleX", "originX"];
var yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(box, transform2) {
  transformAxis(box.x, transform2, xKeys$1);
  transformAxis(box.y, transform2, yKeys$1);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  var viewportBox = measureViewportBox(element, transformPagePoint);
  var scroll = rootProjectionNode2.scroll;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.x);
    translateAxis(viewportBox.y, scroll.y);
  }
  return viewportBox;
}
var elementDragControls = /* @__PURE__ */ new WeakMap();
var VisualElementDragControls = (
  /** @class */
  function() {
    function VisualElementDragControls2(visualElement2) {
      this.openGlobalLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.visualElement = visualElement2;
    }
    VisualElementDragControls2.prototype.start = function(originEvent, _a2) {
      var _this = this;
      var _b = _a2 === void 0 ? {} : _a2, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c;
      if (this.visualElement.isPresent === false)
        return;
      var onSessionStart = function(event) {
        _this.stopAnimation();
        if (snapToCursor) {
          _this.snapToCursor(extractEventInfo(event, "page").point);
        }
      };
      var onStart = function(event, info) {
        var _a3;
        var _b2 = _this.getProps(), drag2 = _b2.drag, dragPropagation = _b2.dragPropagation, onDragStart = _b2.onDragStart;
        if (drag2 && !dragPropagation) {
          if (_this.openGlobalLock)
            _this.openGlobalLock();
          _this.openGlobalLock = getGlobalLock(drag2);
          if (!_this.openGlobalLock)
            return;
        }
        _this.isDragging = true;
        _this.currentDirection = null;
        _this.resolveConstraints();
        if (_this.visualElement.projection) {
          _this.visualElement.projection.isAnimationBlocked = true;
          _this.visualElement.projection.target = void 0;
        }
        eachAxis(function(axis) {
          var _a4, _b3;
          var current = _this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            var measuredAxis = (_b3 = (_a4 = _this.visualElement.projection) === null || _a4 === void 0 ? void 0 : _a4.layout) === null || _b3 === void 0 ? void 0 : _b3.actual[axis];
            if (measuredAxis) {
              var length_1 = calcLength(measuredAxis);
              current = length_1 * (parseFloat(current) / 100);
            }
          }
          _this.originPoint[axis] = current;
        });
        onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);
        (_a3 = _this.visualElement.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Drag, true);
      };
      var onMove = function(event, info) {
        var _a3 = _this.getProps(), dragPropagation = _a3.dragPropagation, dragDirectionLock = _a3.dragDirectionLock, onDirectionLock = _a3.onDirectionLock, onDrag = _a3.onDrag;
        if (!dragPropagation && !_this.openGlobalLock)
          return;
        var offset = info.offset;
        if (dragDirectionLock && _this.currentDirection === null) {
          _this.currentDirection = getCurrentDirection(offset);
          if (_this.currentDirection !== null) {
            onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(_this.currentDirection);
          }
          return;
        }
        _this.updateAxis("x", info.point, offset);
        _this.updateAxis("y", info.point, offset);
        _this.visualElement.syncRender();
        onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);
      };
      var onSessionEnd = function(event, info) {
        return _this.stop(event, info);
      };
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd
      }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
    };
    VisualElementDragControls2.prototype.stop = function(event, info) {
      var isDragging = this.isDragging;
      this.cancel();
      if (!isDragging)
        return;
      var velocity = info.velocity;
      this.startAnimation(velocity);
      var onDragEnd = this.getProps().onDragEnd;
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
    };
    VisualElementDragControls2.prototype.cancel = function() {
      var _a2, _b;
      this.isDragging = false;
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = false;
      }
      (_a2 = this.panSession) === null || _a2 === void 0 ? void 0 : _a2.end();
      this.panSession = void 0;
      var dragPropagation = this.getProps().dragPropagation;
      if (!dragPropagation && this.openGlobalLock) {
        this.openGlobalLock();
        this.openGlobalLock = null;
      }
      (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);
    };
    VisualElementDragControls2.prototype.updateAxis = function(axis, _point, offset) {
      var drag2 = this.getProps().drag;
      if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      var axisValue = this.getAxisMotionValue(axis);
      var next = this.originPoint[axis] + offset[axis];
      if (this.constraints && this.constraints[axis]) {
        next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next);
    };
    VisualElementDragControls2.prototype.resolveConstraints = function() {
      var _this = this;
      var _a2 = this.getProps(), dragConstraints = _a2.dragConstraints, dragElastic = _a2.dragElastic;
      var layout = (this.visualElement.projection || {}).layout;
      var prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout) {
          this.constraints = calcRelativeConstraints(layout.actual, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
        eachAxis(function(axis) {
          if (_this.getAxisMotionValue(axis)) {
            _this.constraints[axis] = rebaseAxisConstraints(layout.actual[axis], _this.constraints[axis]);
          }
        });
      }
    };
    VisualElementDragControls2.prototype.resolveRefConstraints = function() {
      var _a2 = this.getProps(), constraints = _a2.dragConstraints, onMeasureDragConstraints = _a2.onMeasureDragConstraints;
      if (!constraints || !isRefObject(constraints))
        return false;
      var constraintsElement = constraints.current;
      var projection = this.visualElement.projection;
      if (!projection || !projection.layout)
        return false;
      var constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      var measuredConstraints = calcViewportConstraints(projection.layout.actual, constraintsBox);
      if (onMeasureDragConstraints) {
        var userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    };
    VisualElementDragControls2.prototype.startAnimation = function(velocity) {
      var _this = this;
      var _a2 = this.getProps(), drag2 = _a2.drag, dragMomentum = _a2.dragMomentum, dragElastic = _a2.dragElastic, dragTransition = _a2.dragTransition, dragSnapToOrigin = _a2.dragSnapToOrigin, onDragTransitionEnd = _a2.onDragTransitionEnd;
      var constraints = this.constraints || {};
      var momentumAnimations = eachAxis(function(axis) {
        var _a3;
        if (!shouldDrag(axis, drag2, _this.currentDirection)) {
          return;
        }
        var transition2 = (_a3 = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a3 !== void 0 ? _a3 : {};
        if (dragSnapToOrigin)
          transition2 = { min: 0, max: 0 };
        var bounceStiffness = dragElastic ? 200 : 1e6;
        var bounceDamping = dragElastic ? 40 : 1e7;
        var inertia2 = __assign$2(__assign$2({ type: "inertia", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness, bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition2);
        return _this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    };
    VisualElementDragControls2.prototype.startAxisValueAnimation = function(axis, transition2) {
      var axisValue = this.getAxisMotionValue(axis);
      return startAnimation(axis, axisValue, 0, transition2);
    };
    VisualElementDragControls2.prototype.stopAnimation = function() {
      var _this = this;
      eachAxis(function(axis) {
        return _this.getAxisMotionValue(axis).stop();
      });
    };
    VisualElementDragControls2.prototype.getAxisMotionValue = function(axis) {
      var _a2, _b;
      var dragKey = "_drag" + axis.toUpperCase();
      var externalMotionValue = this.visualElement.getProps()[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a2 = this.visualElement.getProps().initial) === null || _a2 === void 0 ? void 0 : _a2[axis]) !== null && _b !== void 0 ? _b : 0);
    };
    VisualElementDragControls2.prototype.snapToCursor = function(point) {
      var _this = this;
      eachAxis(function(axis) {
        var drag2 = _this.getProps().drag;
        if (!shouldDrag(axis, drag2, _this.currentDirection))
          return;
        var projection = _this.visualElement.projection;
        var axisValue = _this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          var _a2 = projection.layout.actual[axis], min = _a2.min, max = _a2.max;
          axisValue.set(point[axis] - mix(min, max, 0.5));
        }
      });
    };
    VisualElementDragControls2.prototype.scalePositionWithinConstraints = function() {
      var _this = this;
      var _a2;
      var _b = this.getProps(), drag2 = _b.drag, dragConstraints = _b.dragConstraints;
      var projection = this.visualElement.projection;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      var boxProgress = { x: 0, y: 0 };
      eachAxis(function(axis) {
        var axisValue = _this.getAxisMotionValue(axis);
        if (axisValue) {
          var latest = axisValue.get();
          boxProgress[axis] = calcOrigin({ min: latest, max: latest }, _this.constraints[axis]);
        }
      });
      var transformTemplate = this.visualElement.getProps().transformTemplate;
      this.visualElement.getInstance().style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      (_a2 = projection.root) === null || _a2 === void 0 ? void 0 : _a2.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis(function(axis) {
        if (!shouldDrag(axis, drag2, null))
          return;
        var axisValue = _this.getAxisMotionValue(axis);
        var _a3 = _this.constraints[axis], min = _a3.min, max = _a3.max;
        axisValue.set(mix(min, max, boxProgress[axis]));
      });
    };
    VisualElementDragControls2.prototype.addListeners = function() {
      var _this = this;
      var _a2;
      elementDragControls.set(this.visualElement, this);
      var element = this.visualElement.getInstance();
      var stopPointerListener = addPointerEvent(element, "pointerdown", function(event) {
        var _a3 = _this.getProps(), drag2 = _a3.drag, _b = _a3.dragListener, dragListener = _b === void 0 ? true : _b;
        drag2 && dragListener && _this.start(event);
      });
      var measureDragConstraints = function() {
        var dragConstraints = _this.getProps().dragConstraints;
        if (isRefObject(dragConstraints)) {
          _this.constraints = _this.resolveRefConstraints();
        }
      };
      var projection = this.visualElement.projection;
      var stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        (_a2 = projection.root) === null || _a2 === void 0 ? void 0 : _a2.updateScroll();
        projection.updateLayout();
      }
      measureDragConstraints();
      var stopResizeListener = addDomEvent(window, "resize", function() {
        return _this.scalePositionWithinConstraints();
      });
      projection.addEventListener("didUpdate", function(_a3) {
        var delta = _a3.delta, hasLayoutChanged = _a3.hasLayoutChanged;
        if (_this.isDragging && hasLayoutChanged) {
          eachAxis(function(axis) {
            var motionValue2 = _this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            _this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          _this.visualElement.syncRender();
        }
      });
      return function() {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
      };
    };
    VisualElementDragControls2.prototype.getProps = function() {
      var props = this.visualElement.getProps();
      var _a2 = props.drag, drag2 = _a2 === void 0 ? false : _a2, _b = props.dragDirectionLock, dragDirectionLock = _b === void 0 ? false : _b, _c = props.dragPropagation, dragPropagation = _c === void 0 ? false : _c, _d = props.dragConstraints, dragConstraints = _d === void 0 ? false : _d, _e2 = props.dragElastic, dragElastic = _e2 === void 0 ? defaultElastic : _e2, _f = props.dragMomentum, dragMomentum = _f === void 0 ? true : _f;
      return __assign$2(__assign$2({}, props), { drag: drag2, dragDirectionLock, dragPropagation, dragConstraints, dragElastic, dragMomentum });
    };
    return VisualElementDragControls2;
  }()
);
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold) {
  if (lockThreshold === void 0) {
    lockThreshold = 10;
  }
  var direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
function useDrag(props) {
  var groupDragControls = props.dragControls, visualElement2 = props.visualElement;
  var dragControls = useConstant(function() {
    return new VisualElementDragControls(visualElement2);
  });
  reactExports.useEffect(function() {
    return groupDragControls && groupDragControls.subscribe(dragControls);
  }, [dragControls, groupDragControls]);
  reactExports.useEffect(function() {
    return dragControls.addListeners();
  }, [dragControls]);
}
function usePanGesture(_a2) {
  var onPan = _a2.onPan, onPanStart = _a2.onPanStart, onPanEnd = _a2.onPanEnd, onPanSessionStart = _a2.onPanSessionStart, visualElement2 = _a2.visualElement;
  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  var panSession = reactExports.useRef(null);
  var transformPagePoint = reactExports.useContext(MotionConfigContext).transformPagePoint;
  var handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: function(event, info) {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  reactExports.useEffect(function() {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, {
      transformPagePoint
    });
  }
  usePointerEvent(visualElement2, "pointerdown", hasPanEvents && onPointerDown);
  useUnmountEffect(function() {
    return panSession.current && panSession.current.end();
  });
}
var drag = {
  pan: makeRenderlessComponent(usePanGesture),
  drag: makeRenderlessComponent(useDrag)
};
var names = [
  "LayoutMeasure",
  "BeforeLayoutMeasure",
  "LayoutUpdate",
  "ViewportBoxUpdate",
  "Update",
  "Render",
  "AnimationComplete",
  "LayoutAnimationComplete",
  "AnimationStart",
  "LayoutAnimationStart",
  "SetAxisTarget",
  "Unmount"
];
function createLifecycles() {
  var managers = names.map(function() {
    return new SubscriptionManager();
  });
  var propSubscriptions = {};
  var lifecycles = {
    clearAllListeners: function() {
      return managers.forEach(function(manager) {
        return manager.clear();
      });
    },
    updatePropListeners: function(props) {
      names.forEach(function(name2) {
        var _a2;
        var on2 = "on" + name2;
        var propListener = props[on2];
        (_a2 = propSubscriptions[name2]) === null || _a2 === void 0 ? void 0 : _a2.call(propSubscriptions);
        if (propListener) {
          propSubscriptions[name2] = lifecycles[on2](propListener);
        }
      });
    }
  };
  managers.forEach(function(manager, i2) {
    lifecycles["on" + names[i2]] = function(handler) {
      return manager.add(handler);
    };
    lifecycles["notify" + names[i2]] = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return manager.notify.apply(manager, __spreadArray$1([], __read$1(args), false));
    };
  });
  return lifecycles;
}
function updateMotionValuesFromProps(element, next, prev) {
  var _a2;
  for (var key in next) {
    var nextValue = next[key];
    var prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        var existingValue = element.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        element.addValue(key, motionValue((_a2 = element.getStaticValue(key)) !== null && _a2 !== void 0 ? _a2 : nextValue));
      }
    }
  }
  for (var key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
var visualElement = function(_a2) {
  var _b = _a2.treeType, treeType = _b === void 0 ? "" : _b, build = _a2.build, getBaseTarget = _a2.getBaseTarget, makeTargetAnimatable = _a2.makeTargetAnimatable, measureViewportBox2 = _a2.measureViewportBox, renderInstance = _a2.render, readValueFromInstance = _a2.readValueFromInstance, removeValueFromRenderState = _a2.removeValueFromRenderState, sortNodePosition = _a2.sortNodePosition, scrapeMotionValuesFromProps2 = _a2.scrapeMotionValuesFromProps;
  return function(_a3, options) {
    var parent = _a3.parent, props = _a3.props, presenceId = _a3.presenceId, blockInitialAnimation = _a3.blockInitialAnimation, visualState = _a3.visualState, shouldReduceMotion = _a3.shouldReduceMotion;
    if (options === void 0) {
      options = {};
    }
    var isMounted = false;
    var latestValues = visualState.latestValues, renderState = visualState.renderState;
    var instance;
    var lifecycles = createLifecycles();
    var values = /* @__PURE__ */ new Map();
    var valueSubscriptions = /* @__PURE__ */ new Map();
    var prevMotionValues = {};
    var baseTarget = __assign$2({}, latestValues);
    var removeFromVariantTree;
    function render3() {
      if (!instance || !isMounted)
        return;
      triggerBuild();
      renderInstance(instance, renderState, props.style, element.projection);
    }
    function triggerBuild() {
      build(element, renderState, latestValues, options, props);
    }
    function update() {
      lifecycles.notifyUpdate(latestValues);
    }
    function bindToMotionValue(key2, value2) {
      var removeOnChange = value2.onChange(function(latestValue) {
        latestValues[key2] = latestValue;
        props.onUpdate && sync.update(update, false, true);
      });
      var removeOnRenderRequest = value2.onRenderRequest(element.scheduleRender);
      valueSubscriptions.set(key2, function() {
        removeOnChange();
        removeOnRenderRequest();
      });
    }
    var initialMotionValues = scrapeMotionValuesFromProps2(props);
    for (var key in initialMotionValues) {
      var value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
    var isControllingVariants = checkIfControllingVariants(props);
    var isVariantNode = checkIfVariantNode(props);
    var element = __assign$2(__assign$2({
      treeType,
      /**
       * This is a mirror of the internal instance prop, which keeps
       * VisualElement type-compatible with React's RefObject.
       */
      current: null,
      /**
       * The depth of this visual element within the visual element tree.
       */
      depth: parent ? parent.depth + 1 : 0,
      parent,
      children: /* @__PURE__ */ new Set(),
      /**
       *
       */
      presenceId,
      shouldReduceMotion,
      /**
       * If this component is part of the variant tree, it should track
       * any children that are also part of the tree. This is essentially
       * a shadow tree to simplify logic around how to stagger over children.
       */
      variantChildren: isVariantNode ? /* @__PURE__ */ new Set() : void 0,
      /**
       * Whether this instance is visible. This can be changed imperatively
       * by the projection tree, is analogous to CSS's visibility in that
       * hidden elements should take up layout, and needs enacting by the configured
       * render function.
       */
      isVisible: void 0,
      /**
       * Normally, if a component is controlled by a parent's variants, it can
       * rely on that ancestor to trigger animations further down the tree.
       * However, if a component is created after its parent is mounted, the parent
       * won't trigger that mount animation so the child needs to.
       *
       * TODO: This might be better replaced with a method isParentMounted
       */
      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
      /**
       * This can be set by AnimatePresence to force components that mount
       * at the same time as it to mount as if they have initial={false} set.
       */
      blockInitialAnimation,
      /**
       * Determine whether this component has mounted yet. This is mostly used
       * by variant children to determine whether they need to trigger their
       * own animations on mount.
       */
      isMounted: function() {
        return Boolean(instance);
      },
      mount: function(newInstance) {
        isMounted = true;
        instance = element.current = newInstance;
        if (element.projection) {
          element.projection.mount(newInstance);
        }
        if (isVariantNode && parent && !isControllingVariants) {
          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);
        }
        values.forEach(function(value2, key2) {
          return bindToMotionValue(key2, value2);
        });
        parent === null || parent === void 0 ? void 0 : parent.children.add(element);
        element.setProps(props);
      },
      /**
       *
       */
      unmount: function() {
        var _a4;
        (_a4 = element.projection) === null || _a4 === void 0 ? void 0 : _a4.unmount();
        cancelSync.update(update);
        cancelSync.render(render3);
        valueSubscriptions.forEach(function(remove2) {
          return remove2();
        });
        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);
        lifecycles.clearAllListeners();
        instance = void 0;
        isMounted = false;
      },
      /**
       * Add a child visual element to our set of children.
       */
      addVariantChild: function(child) {
        var _a4;
        var closestVariantNode = element.getClosestVariantNode();
        if (closestVariantNode) {
          (_a4 = closestVariantNode.variantChildren) === null || _a4 === void 0 ? void 0 : _a4.add(child);
          return function() {
            return closestVariantNode.variantChildren.delete(child);
          };
        }
      },
      sortNodePosition: function(other) {
        if (!sortNodePosition || treeType !== other.treeType)
          return 0;
        return sortNodePosition(element.getInstance(), other.getInstance());
      },
      /**
       * Returns the closest variant node in the tree starting from
       * this visual element.
       */
      getClosestVariantNode: function() {
        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();
      },
      /**
       * Expose the latest layoutId prop.
       */
      getLayoutId: function() {
        return props.layoutId;
      },
      /**
       * Returns the current instance.
       */
      getInstance: function() {
        return instance;
      },
      /**
       * Get/set the latest static values.
       */
      getStaticValue: function(key2) {
        return latestValues[key2];
      },
      setStaticValue: function(key2, value2) {
        return latestValues[key2] = value2;
      },
      /**
       * Returns the latest motion value state. Currently only used to take
       * a snapshot of the visual element - perhaps this can return the whole
       * visual state
       */
      getLatestValues: function() {
        return latestValues;
      },
      /**
       * Set the visiblity of the visual element. If it's changed, schedule
       * a render to reflect these changes.
       */
      setVisibility: function(visibility) {
        if (element.isVisible === visibility)
          return;
        element.isVisible = visibility;
        element.scheduleRender();
      },
      /**
       * Make a target animatable by Popmotion. For instance, if we're
       * trying to animate width from 100px to 100vw we need to measure 100vw
       * in pixels to determine what we really need to animate to. This is also
       * pluggable to support Framer's custom value types like Color,
       * and CSS variables.
       */
      makeTargetAnimatable: function(target, canMutate) {
        if (canMutate === void 0) {
          canMutate = true;
        }
        return makeTargetAnimatable(element, target, props, canMutate);
      },
      /**
       * Measure the current viewport box with or without transforms.
       * Only measures axis-aligned boxes, rotate and skew must be manually
       * removed with a re-render to work.
       */
      measureViewportBox: function() {
        return measureViewportBox2(instance, props);
      },
      // Motion values ========================
      /**
       * Add a motion value and bind it to this visual element.
       */
      addValue: function(key2, value2) {
        if (element.hasValue(key2))
          element.removeValue(key2);
        values.set(key2, value2);
        latestValues[key2] = value2.get();
        bindToMotionValue(key2, value2);
      },
      /**
       * Remove a motion value and unbind any active subscriptions.
       */
      removeValue: function(key2) {
        var _a4;
        values.delete(key2);
        (_a4 = valueSubscriptions.get(key2)) === null || _a4 === void 0 ? void 0 : _a4();
        valueSubscriptions.delete(key2);
        delete latestValues[key2];
        removeValueFromRenderState(key2, renderState);
      },
      /**
       * Check whether we have a motion value for this key
       */
      hasValue: function(key2) {
        return values.has(key2);
      },
      /**
       * Get a motion value for this key. If called with a default
       * value, we'll create one if none exists.
       */
      getValue: function(key2, defaultValue) {
        var value2 = values.get(key2);
        if (value2 === void 0 && defaultValue !== void 0) {
          value2 = motionValue(defaultValue);
          element.addValue(key2, value2);
        }
        return value2;
      },
      /**
       * Iterate over our motion values.
       */
      forEachValue: function(callback) {
        return values.forEach(callback);
      },
      /**
       * If we're trying to animate to a previously unencountered value,
       * we need to check for it in our state and as a last resort read it
       * directly from the instance (which might have performance implications).
       */
      readValue: function(key2) {
        var _a4;
        return (_a4 = latestValues[key2]) !== null && _a4 !== void 0 ? _a4 : readValueFromInstance(instance, key2, options);
      },
      /**
       * Set the base target to later animate back to. This is currently
       * only hydrated on creation and when we first read a value.
       */
      setBaseTarget: function(key2, value2) {
        baseTarget[key2] = value2;
      },
      /**
       * Find the base target for a value thats been removed from all animation
       * props.
       */
      getBaseTarget: function(key2) {
        if (getBaseTarget) {
          var target = getBaseTarget(props, key2);
          if (target !== void 0 && !isMotionValue(target))
            return target;
        }
        return baseTarget[key2];
      }
    }, lifecycles), {
      /**
       * Build the renderer state based on the latest visual state.
       */
      build: function() {
        triggerBuild();
        return renderState;
      },
      /**
       * Schedule a render on the next animation frame.
       */
      scheduleRender: function() {
        sync.render(render3, false, true);
      },
      /**
       * Synchronously fire render. It's prefered that we batch renders but
       * in many circumstances, like layout measurement, we need to run this
       * synchronously. However in those instances other measures should be taken
       * to batch reads/writes.
       */
      syncRender: render3,
      /**
       * Update the provided props. Ensure any newly-added motion values are
       * added to our map, old ones removed, and listeners updated.
       */
      setProps: function(newProps) {
        if (newProps.transformTemplate || props.transformTemplate) {
          element.scheduleRender();
        }
        props = newProps;
        lifecycles.updatePropListeners(newProps);
        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps2(props), prevMotionValues);
      },
      getProps: function() {
        return props;
      },
      // Variants ==============================
      /**
       * Returns the variant definition with a given name.
       */
      getVariant: function(name2) {
        var _a4;
        return (_a4 = props.variants) === null || _a4 === void 0 ? void 0 : _a4[name2];
      },
      /**
       * Returns the defined default transition on this component.
       */
      getDefaultTransition: function() {
        return props.transition;
      },
      getTransformPagePoint: function() {
        return props.transformPagePoint;
      },
      /**
       * Used by child variant nodes to get the closest ancestor variant props.
       */
      getVariantContext: function(startAtParent) {
        if (startAtParent === void 0) {
          startAtParent = false;
        }
        if (startAtParent)
          return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
        if (!isControllingVariants) {
          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
          if (props.initial !== void 0) {
            context_1.initial = props.initial;
          }
          return context_1;
        }
        var context = {};
        for (var i2 = 0; i2 < numVariantProps; i2++) {
          var name_1 = variantProps[i2];
          var prop = props[name_1];
          if (isVariantLabel(prop) || prop === false) {
            context[name_1] = prop;
          }
        }
        return context;
      }
    });
    return element;
  };
};
var variantProps = __spreadArray$1(["initial"], __read$1(variantPriorityOrder), false);
var numVariantProps = variantProps.length;
function isCSSVariable(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  var match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  var _a2 = __read$1(match, 3), token2 = _a2[1], fallback2 = _a2[2];
  return [token2, fallback2];
}
function getVariableValue(current, element, depth) {
  var _a2 = __read$1(parseCSSVariable(current), 2), token2 = _a2[0], fallback2 = _a2[1];
  if (!token2)
    return;
  var resolved = window.getComputedStyle(element).getPropertyValue(token2);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable(fallback2)) {
    return getVariableValue(fallback2, element);
  } else {
    return fallback2;
  }
}
function resolveCSSVariables(visualElement2, _a2, transitionEnd) {
  var _b;
  var target = __rest$2(_a2, []);
  var element = visualElement2.getInstance();
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = __assign$2({}, transitionEnd);
  }
  visualElement2.forEachValue(function(value) {
    var current2 = value.get();
    if (!isCSSVariable(current2))
      return;
    var resolved2 = getVariableValue(current2, element);
    if (resolved2)
      value.set(resolved2);
  });
  for (var key in target) {
    var current = target[key];
    if (!isCSSVariable(current))
      continue;
    var resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (transitionEnd)
      (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;
  }
  return { target, transitionEnd };
}
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
var isPositionalKey = function(key) {
  return positionalKeys.has(key);
};
var hasPositionalKey = function(target) {
  return Object.keys(target).some(isPositionalKey);
};
var setAndResetVelocity = function(value, to) {
  value.set(to, false);
  value.set(to);
};
var isNumOrPxType = function(v2) {
  return v2 === number || v2 === px;
};
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
var getPosFromMatrix = function(matrix, pos) {
  return parseFloat(matrix.split(", ")[pos]);
};
var getTranslateFromMatrix = function(pos2, pos3) {
  return function(_bbox, _a2) {
    var transform2 = _a2.transform;
    if (transform2 === "none" || !transform2)
      return 0;
    var matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      var matrix = transform2.match(/^matrix\((.+)\)$/);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
};
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformProps.filter(function(key) {
  return !transformKeys.has(key);
});
function removeNonTranslationalTransform(visualElement2) {
  var removedTransforms = [];
  nonTranslationalTransformKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement2.syncRender();
  return removedTransforms;
}
var positionalValues = {
  // Dimensions
  width: function(_a2, _b) {
    var x2 = _a2.x;
    var _c = _b.paddingLeft, paddingLeft = _c === void 0 ? "0" : _c, _d = _b.paddingRight, paddingRight = _d === void 0 ? "0" : _d;
    return x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight);
  },
  height: function(_a2, _b) {
    var y2 = _a2.y;
    var _c = _b.paddingTop, paddingTop = _c === void 0 ? "0" : _c, _d = _b.paddingBottom, paddingBottom = _d === void 0 ? "0" : _d;
    return y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom);
  },
  top: function(_bbox, _a2) {
    var top = _a2.top;
    return parseFloat(top);
  },
  left: function(_bbox, _a2) {
    var left = _a2.left;
    return parseFloat(left);
  },
  bottom: function(_a2, _b) {
    var y2 = _a2.y;
    var top = _b.top;
    return parseFloat(top) + (y2.max - y2.min);
  },
  right: function(_a2, _b) {
    var x2 = _a2.x;
    var left = _b.left;
    return parseFloat(left) + (x2.max - x2.min);
  },
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
var convertChangedValueTypes = function(target, visualElement2, changedKeys) {
  var originBbox = visualElement2.measureViewportBox();
  var element = visualElement2.getInstance();
  var elementComputedStyle = getComputedStyle(element);
  var display = elementComputedStyle.display;
  var origin = {};
  if (display === "none") {
    visualElement2.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach(function(key) {
    origin[key] = positionalValues[key](originBbox, elementComputedStyle);
  });
  visualElement2.syncRender();
  var targetBbox = visualElement2.measureViewportBox();
  changedKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    setAndResetVelocity(value, origin[key]);
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
var checkAndConvertChangedValueTypes = function(visualElement2, target, origin, transitionEnd) {
  if (origin === void 0) {
    origin = {};
  }
  if (transitionEnd === void 0) {
    transitionEnd = {};
  }
  target = __assign$2({}, target);
  transitionEnd = __assign$2({}, transitionEnd);
  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  var removedTransformValues = [];
  var hasAttemptedToRemoveTransformValues = false;
  var changedValueTypeKeys = [];
  targetPositionalKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (!visualElement2.hasValue(key))
      return;
    var from2 = origin[key];
    var fromType = findDimensionValueType(from2);
    var to = target[key];
    var toType;
    if (isKeyframesTarget(to)) {
      var numKeyframes = to.length;
      var fromIndex = to[0] === null ? 1 : 0;
      from2 = to[fromIndex];
      fromType = findDimensionValueType(from2);
      for (var i2 = fromIndex; i2 < numKeyframes; i2++) {
        if (!toType) {
          toType = findDimensionValueType(to[i2]);
        } else {
          invariant(findDimensionValueType(to[i2]) === toType);
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        var current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from2 === 0 || to === 0)) {
        if (from2 === 0) {
          value.set(toType.transform(from2));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement2);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        setAndResetVelocity(value, to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    var scrollY_1 = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    var convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(function(_a2) {
        var _b = __read$1(_a2, 2), key = _b[0], value = _b[1];
        visualElement2.getValue(key).set(value);
      });
    }
    visualElement2.syncRender();
    if (scrollY_1 !== null)
      window.scrollTo({ top: scrollY_1 });
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement2, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin, transitionEnd) : { target, transitionEnd };
}
var parseDomVariant = function(visualElement2, target, origin, transitionEnd) {
  var resolved = resolveCSSVariables(visualElement2, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement2, target, origin, transitionEnd);
};
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
var htmlConfig = {
  treeType: "dom",
  readValueFromInstance: function(domElement, key) {
    if (isTransformProp(key)) {
      var defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      var computedStyle = getComputedStyle$1(domElement);
      return (isCSSVariable$1(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
    }
  },
  sortNodePosition: function(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  },
  getBaseTarget: function(props, key) {
    var _a2;
    return (_a2 = props.style) === null || _a2 === void 0 ? void 0 : _a2[key];
  },
  measureViewportBox: function(element, _a2) {
    var transformPagePoint = _a2.transformPagePoint;
    return measureViewportBox(element, transformPagePoint);
  },
  /**
   * Reset the transform on the current Element. This is called as part
   * of a batched process across the entire layout tree. To remove this write
   * cycle it'd be interesting to see if it's possible to "undo" all the current
   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms
   * works
   */
  resetTransform: function(element, domElement, props) {
    var transformTemplate = props.transformTemplate;
    domElement.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    element.scheduleRender();
  },
  restoreTransform: function(instance, mutableState) {
    instance.style.transform = mutableState.style.transform;
  },
  removeValueFromRenderState: function(key, _a2) {
    var vars = _a2.vars, style2 = _a2.style;
    delete vars[key];
    delete style2[key];
  },
  /**
   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`
   * can be animated by Motion.
   */
  makeTargetAnimatable: function(element, _a2, _b, isMounted) {
    var transformValues = _b.transformValues;
    if (isMounted === void 0) {
      isMounted = true;
    }
    var transition2 = _a2.transition, transitionEnd = _a2.transitionEnd, target = __rest$2(_a2, ["transition", "transitionEnd"]);
    var origin = getOrigin(target, transition2 || {}, element);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(element, target, origin);
      var parsed = parseDomVariant(element, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return __assign$2({ transition: transition2, transitionEnd }, target);
  },
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
  build: function(element, renderState, latestValues, options, props) {
    if (element.isVisible !== void 0) {
      renderState.style.visibility = element.isVisible ? "visible" : "hidden";
    }
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  },
  render: renderHTML
};
var htmlVisualElement = visualElement(htmlConfig);
var svgVisualElement = visualElement(__assign$2(__assign$2({}, htmlConfig), { getBaseTarget: function(props, key) {
  return props[key];
}, readValueFromInstance: function(domElement, key) {
  var _a2;
  if (isTransformProp(key)) {
    return ((_a2 = getDefaultValueType(key)) === null || _a2 === void 0 ? void 0 : _a2.default) || 0;
  }
  key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
  return domElement.getAttribute(key);
}, scrapeMotionValuesFromProps, build: function(_element, renderState, latestValues, options, props) {
  buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);
}, render: renderSVG }));
var createDomVisualElement = function(Component2, options) {
  return isSVGComponent(Component2) ? svgVisualElement(options, { enableHardwareAcceleration: false }) : htmlVisualElement(options, { enableHardwareAcceleration: true });
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
var correctBorderRadius = {
  correct: function(latest, node2) {
    if (!node2.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    var x2 = pixelsToPercent(latest, node2.target.x);
    var y2 = pixelsToPercent(latest, node2.target.y);
    return "".concat(x2, "% ").concat(y2, "%");
  }
};
var varToken = "_$css";
var correctBoxShadow = {
  correct: function(latest, _a2) {
    var treeScale = _a2.treeScale, projectionDelta = _a2.projectionDelta;
    var original = latest;
    var containsCSSVariables = latest.includes("var(");
    var cssVariables = [];
    if (containsCSSVariables) {
      latest = latest.replace(cssVariableRegex, function(match) {
        cssVariables.push(match);
        return varToken;
      });
    }
    var shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    var template = complex.createTransformer(latest);
    var offset = typeof shadow[0] !== "number" ? 1 : 0;
    var xScale = projectionDelta.x.scale * treeScale.x;
    var yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    var averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset] === "number")
      shadow[2 + offset] /= averageScale;
    if (typeof shadow[3 + offset] === "number")
      shadow[3 + offset] /= averageScale;
    var output2 = template(shadow);
    if (containsCSSVariables) {
      var i_1 = 0;
      output2 = output2.replace(varToken, function() {
        var cssVariable = cssVariables[i_1];
        i_1++;
        return cssVariable;
      });
    }
    return output2;
  }
};
var MeasureLayoutWithContext = (
  /** @class */
  function(_super) {
    __extends$1(MeasureLayoutWithContext2, _super);
    function MeasureLayoutWithContext2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MeasureLayoutWithContext2.prototype.componentDidMount = function() {
      var _this = this;
      var _a2 = this.props, visualElement2 = _a2.visualElement, layoutGroup = _a2.layoutGroup, switchLayoutGroup = _a2.switchLayoutGroup, layoutId = _a2.layoutId;
      var projection = visualElement2.projection;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
          layoutGroup.group.add(projection);
        if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {
          switchLayoutGroup.register(projection);
        }
        projection.root.didUpdate();
        projection.addEventListener("animationComplete", function() {
          _this.safeToRemove();
        });
        projection.setOptions(__assign$2(__assign$2({}, projection.options), { onExitComplete: function() {
          return _this.safeToRemove();
        } }));
      }
      globalProjectionState.hasEverUpdated = true;
    };
    MeasureLayoutWithContext2.prototype.getSnapshotBeforeUpdate = function(prevProps) {
      var _this = this;
      var _a2 = this.props, layoutDependency = _a2.layoutDependency, visualElement2 = _a2.visualElement, drag2 = _a2.drag, isPresent = _a2.isPresent;
      var projection = visualElement2.projection;
      if (!projection)
        return null;
      projection.isPresent = isPresent;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent) {
        if (isPresent) {
          projection.promote();
        } else if (!projection.relegate()) {
          sync.postRender(function() {
            var _a3;
            if (!((_a3 = projection.getStack()) === null || _a3 === void 0 ? void 0 : _a3.members.length)) {
              _this.safeToRemove();
            }
          });
        }
      }
      return null;
    };
    MeasureLayoutWithContext2.prototype.componentDidUpdate = function() {
      var projection = this.props.visualElement.projection;
      if (projection) {
        projection.root.didUpdate();
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      }
    };
    MeasureLayoutWithContext2.prototype.componentWillUnmount = function() {
      var _a2 = this.props, visualElement2 = _a2.visualElement, layoutGroup = _a2.layoutGroup, promoteContext = _a2.switchLayoutGroup;
      var projection = visualElement2.projection;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    };
    MeasureLayoutWithContext2.prototype.safeToRemove = function() {
      var safeToRemove = this.props.safeToRemove;
      safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();
    };
    MeasureLayoutWithContext2.prototype.render = function() {
      return null;
    };
    return MeasureLayoutWithContext2;
  }(React$1.Component)
);
function MeasureLayout(props) {
  var _a2 = __read$1(usePresence(), 2), isPresent = _a2[0], safeToRemove = _a2[1];
  var layoutGroup = reactExports.useContext(LayoutGroupContext);
  return React$1.createElement(MeasureLayoutWithContext, __assign$2({}, props, { layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove }));
}
var defaultScaleCorrectors = {
  borderRadius: __assign$2(__assign$2({}, correctBorderRadius), { applyTo: [
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ] }),
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
var layoutFeatures = {
  measureLayout: MeasureLayout
};
function animate(from2, to, transition2) {
  if (transition2 === void 0) {
    transition2 = {};
  }
  var value = isMotionValue(from2) ? from2 : motionValue(from2);
  startAnimation("", value, to, transition2);
  return {
    stop: function() {
      return value.stop();
    },
    isAnimating: function() {
      return value.isAnimating();
    }
  };
}
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
var asNumber = function(value) {
  return typeof value === "string" ? parseFloat(value) : value;
};
var isPx = function(value) {
  return typeof value === "number" || px.test(value);
};
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  var _a2, _b, _c, _d;
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(
      0,
      // (follow?.opacity as number) ?? 0,
      // TODO Reinstate this if only child
      (_a2 = lead.opacity) !== null && _a2 !== void 0 ? _a2 : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress2);
  }
  for (var i2 = 0; i2 < numBorders; i2++) {
    var borderLabel = "border".concat(borders[i2], "Radius");
    var followRadius = getRadius(follow, borderLabel);
    var leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    var canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  var _a2;
  return (_a2 = values[radiusName]) !== null && _a2 !== void 0 ? _a2 : values.borderRadius;
}
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, linear);
function compress(min, max, easing) {
  return function(p2) {
    if (p2 < min)
      return 0;
    if (p2 > max)
      return 1;
    return easing(progress(min, max, p2));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate, scale2, origin, boxScale, originAxis, sourceAxis) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  if (origin === void 0) {
    origin = 0.5;
  }
  if (originAxis === void 0) {
    originAxis = axis;
  }
  if (sourceAxis === void 0) {
    sourceAxis = axis;
  }
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    var relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  var originPoint = mix(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, _a2, origin, sourceAxis) {
  var _b = __read$1(_a2, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);
  removeAxisTransforms(box.y, transforms, yKeys, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a2, b2) {
  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;
}
var NodeStack = (
  /** @class */
  function() {
    function NodeStack2() {
      this.members = [];
    }
    NodeStack2.prototype.add = function(node2) {
      addUniqueItem(this.members, node2);
      node2.scheduleRender();
    };
    NodeStack2.prototype.remove = function(node2) {
      removeItem(this.members, node2);
      if (node2 === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node2 === this.lead) {
        var prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    };
    NodeStack2.prototype.relegate = function(node2) {
      var indexOfNode = this.members.findIndex(function(member2) {
        return node2 === member2;
      });
      if (indexOfNode === 0)
        return false;
      var prevLead;
      for (var i2 = indexOfNode; i2 >= 0; i2--) {
        var member = this.members[i2];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    };
    NodeStack2.prototype.promote = function(node2, preserveFollowOpacity) {
      var _a2;
      var prevLead = this.lead;
      if (node2 === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node2;
      node2.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node2.scheduleRender();
        node2.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node2.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node2.snapshot = prevLead.snapshot;
          node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
          node2.snapshot.isShared = true;
        }
        if ((_a2 = node2.root) === null || _a2 === void 0 ? void 0 : _a2.isUpdating) {
          node2.isLayoutDirty = true;
        }
        var crossfade = node2.options.crossfade;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    };
    NodeStack2.prototype.exitAnimationComplete = function() {
      this.members.forEach(function(node2) {
        var _a2, _b, _c, _d, _e2;
        (_b = (_a2 = node2.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a2);
        (_e2 = (_c = node2.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e2 === void 0 ? void 0 : _e2.call(_d);
      });
    };
    NodeStack2.prototype.scheduleRender = function() {
      this.members.forEach(function(node2) {
        node2.instance && node2.scheduleRender(false);
      });
    };
    NodeStack2.prototype.removeLeadSnapshot = function() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    };
    return NodeStack2;
  }()
);
var identityProjection = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";
function buildProjectionTransform(delta, treeScale, latestTransform) {
  var xTranslate = delta.x.translate / treeScale.x;
  var yTranslate = delta.y.translate / treeScale.y;
  var transform2 = "translate3d(".concat(xTranslate, "px, ").concat(yTranslate, "px, 0) ");
  transform2 += "scale(".concat(1 / treeScale.x, ", ").concat(1 / treeScale.y, ") ");
  if (latestTransform) {
    var rotate2 = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;
    if (rotate2)
      transform2 += "rotate(".concat(rotate2, "deg) ");
    if (rotateX)
      transform2 += "rotateX(".concat(rotateX, "deg) ");
    if (rotateY)
      transform2 += "rotateY(".concat(rotateY, "deg) ");
  }
  var elementScaleX = delta.x.scale * treeScale.x;
  var elementScaleY = delta.y.scale * treeScale.y;
  transform2 += "scale(".concat(elementScaleX, ", ").concat(elementScaleY, ")");
  return transform2 === identityProjection ? "none" : transform2;
}
var compareByDepth = function(a2, b2) {
  return a2.depth - b2.depth;
};
var FlatTree = (
  /** @class */
  function() {
    function FlatTree2() {
      this.children = [];
      this.isDirty = false;
    }
    FlatTree2.prototype.add = function(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.remove = function(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.forEach = function(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    };
    return FlatTree2;
  }()
);
var animationTarget = 1e3;
function createProjectionNode(_a2) {
  var attachResizeListener = _a2.attachResizeListener, defaultParent = _a2.defaultParent, measureScroll = _a2.measureScroll, checkIsScrollRoot = _a2.checkIsScrollRoot, resetTransform = _a2.resetTransform;
  return (
    /** @class */
    function() {
      function ProjectionNode(id2, latestValues, parent) {
        var _this = this;
        if (latestValues === void 0) {
          latestValues = {};
        }
        if (parent === void 0) {
          parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent();
        }
        this.children = /* @__PURE__ */ new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.potentialNodes = /* @__PURE__ */ new Map();
        this.checkUpdateFailed = function() {
          if (_this.isUpdating) {
            _this.isUpdating = false;
            _this.clearAllSnapshots();
          }
        };
        this.updateProjection = function() {
          _this.nodes.forEach(resolveTargetDelta);
          _this.nodes.forEach(calcProjection);
        };
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = /* @__PURE__ */ new Map();
        this.id = id2;
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? __spreadArray$1(__spreadArray$1([], __read$1(parent.path), false), [parent], false) : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        id2 && this.root.registerPotentialNode(id2, this);
        for (var i2 = 0; i2 < this.path.length; i2++) {
          this.path[i2].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      ProjectionNode.prototype.addEventListener = function(name2, handler) {
        if (!this.eventHandlers.has(name2)) {
          this.eventHandlers.set(name2, new SubscriptionManager());
        }
        return this.eventHandlers.get(name2).add(handler);
      };
      ProjectionNode.prototype.notifyListeners = function(name2) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var subscriptionManager = this.eventHandlers.get(name2);
        subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify.apply(subscriptionManager, __spreadArray$1([], __read$1(args), false));
      };
      ProjectionNode.prototype.hasListeners = function(name2) {
        return this.eventHandlers.has(name2);
      };
      ProjectionNode.prototype.registerPotentialNode = function(id2, node2) {
        this.potentialNodes.set(id2, node2);
      };
      ProjectionNode.prototype.mount = function(instance, isLayoutDirty) {
        var _this = this;
        var _a3;
        if (isLayoutDirty === void 0) {
          isLayoutDirty = false;
        }
        if (this.instance)
          return;
        this.isSVG = instance instanceof SVGElement && instance.tagName !== "svg";
        this.instance = instance;
        var _b = this.options, layoutId = _b.layoutId, layout = _b.layout, visualElement2 = _b.visualElement;
        if (visualElement2 && !visualElement2.getInstance()) {
          visualElement2.mount(instance);
        }
        this.root.nodes.add(this);
        (_a3 = this.parent) === null || _a3 === void 0 ? void 0 : _a3.children.add(this);
        this.id && this.root.potentialNodes.delete(this.id);
        if (isLayoutDirty && (layout || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          var unblockTimeout_1;
          var resizeUnblockUpdate_1 = function() {
            return _this.root.updateBlockedByResize = false;
          };
          attachResizeListener(instance, function() {
            _this.root.updateBlockedByResize = true;
            clearTimeout(unblockTimeout_1);
            unblockTimeout_1 = window.setTimeout(resizeUnblockUpdate_1, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              _this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement2 && (layoutId || layout)) {
          this.addEventListener("didUpdate", function(_a4) {
            var _b2, _c, _d, _e2, _f;
            var delta = _a4.delta, hasLayoutChanged = _a4.hasLayoutChanged, hasRelativeTargetChanged = _a4.hasRelativeTargetChanged, newLayout = _a4.layout;
            if (_this.isTreeAnimationBlocked()) {
              _this.target = void 0;
              _this.relativeTarget = void 0;
              return;
            }
            var layoutTransition = (_c = (_b2 = _this.options.transition) !== null && _b2 !== void 0 ? _b2 : visualElement2.getDefaultTransition()) !== null && _c !== void 0 ? _c : defaultLayoutTransition;
            var _g = visualElement2.getProps(), onLayoutAnimationStart = _g.onLayoutAnimationStart, onLayoutAnimationComplete = _g.onLayoutAnimationComplete;
            var targetChanged = !_this.targetLayout || !boxEquals(_this.targetLayout, newLayout) || hasRelativeTargetChanged;
            var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
            if (((_d = _this.resumeFrom) === null || _d === void 0 ? void 0 : _d.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !_this.currentAnimation)) {
              if (_this.resumeFrom) {
                _this.resumingFrom = _this.resumeFrom;
                _this.resumingFrom.resumingFrom = void 0;
              }
              _this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
              var animationOptions = __assign$2(__assign$2({}, getValueTransition(layoutTransition, "layout")), { onPlay: onLayoutAnimationStart, onComplete: onLayoutAnimationComplete });
              if (visualElement2.shouldReduceMotion) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              _this.startAnimation(animationOptions);
            } else {
              if (!hasLayoutChanged && _this.animationProgress === 0) {
                _this.finishAnimation();
              }
              _this.isLead() && ((_f = (_e2 = _this.options).onExitComplete) === null || _f === void 0 ? void 0 : _f.call(_e2));
            }
            _this.targetLayout = newLayout;
          });
        }
      };
      ProjectionNode.prototype.unmount = function() {
        var _a3, _b;
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        (_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.remove(this);
        (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);
        this.instance = void 0;
        cancelSync.preRender(this.updateProjection);
      };
      ProjectionNode.prototype.blockUpdate = function() {
        this.updateManuallyBlocked = true;
      };
      ProjectionNode.prototype.unblockUpdate = function() {
        this.updateManuallyBlocked = false;
      };
      ProjectionNode.prototype.isUpdateBlocked = function() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      };
      ProjectionNode.prototype.isTreeAnimationBlocked = function() {
        var _a3;
        return this.isAnimationBlocked || ((_a3 = this.parent) === null || _a3 === void 0 ? void 0 : _a3.isTreeAnimationBlocked()) || false;
      };
      ProjectionNode.prototype.startUpdate = function() {
        var _a3;
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        (_a3 = this.nodes) === null || _a3 === void 0 ? void 0 : _a3.forEach(resetRotation);
      };
      ProjectionNode.prototype.willUpdate = function(shouldNotifyListeners) {
        var _a3, _b, _c;
        if (shouldNotifyListeners === void 0) {
          shouldNotifyListeners = true;
        }
        if (this.root.isUpdateBlocked()) {
          (_b = (_a3 = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a3);
          return;
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (var i2 = 0; i2 < this.path.length; i2++) {
          var node2 = this.path[i2];
          node2.shouldResetTransform = true;
          node2.updateScroll();
        }
        var _d = this.options, layoutId = _d.layoutId, layout = _d.layout;
        if (layoutId === void 0 && !layout)
          return;
        var transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;
        this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      };
      ProjectionNode.prototype.didUpdate = function() {
        var updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (!this.isUpdating)
          return;
        this.isUpdating = false;
        if (this.potentialNodes.size) {
          this.potentialNodes.forEach(mountNodeEarly);
          this.potentialNodes.clear();
        }
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
        this.clearAllSnapshots();
        flushSync.update();
        flushSync.preRender();
        flushSync.render();
      };
      ProjectionNode.prototype.clearAllSnapshots = function() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      };
      ProjectionNode.prototype.scheduleUpdateProjection = function() {
        sync.preRender(this.updateProjection, false, true);
      };
      ProjectionNode.prototype.scheduleCheckAfterUnmount = function() {
        var _this = this;
        sync.postRender(function() {
          if (_this.isLayoutDirty) {
            _this.root.didUpdate();
          } else {
            _this.root.checkUpdateFailed();
          }
        });
      };
      ProjectionNode.prototype.updateSnapshot = function() {
        if (this.snapshot || !this.instance)
          return;
        var measured = this.measure();
        var layout = this.removeTransform(this.removeElementScroll(measured));
        roundBox(layout);
        this.snapshot = {
          measured,
          layout,
          latestValues: {}
        };
      };
      ProjectionNode.prototype.updateLayout = function() {
        var _a3;
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (var i2 = 0; i2 < this.path.length; i2++) {
            var node2 = this.path[i2];
            node2.updateScroll();
          }
        }
        var measured = this.measure();
        roundBox(measured);
        var prevLayout = this.layout;
        this.layout = {
          measured,
          actual: this.removeElementScroll(measured)
        };
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.actual);
        (_a3 = this.options.visualElement) === null || _a3 === void 0 ? void 0 : _a3.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);
      };
      ProjectionNode.prototype.updateScroll = function() {
        if (this.options.layoutScroll && this.instance) {
          this.isScrollRoot = checkIsScrollRoot(this.instance);
          this.scroll = measureScroll(this.instance);
        }
      };
      ProjectionNode.prototype.resetTransform = function() {
        var _a3;
        if (!resetTransform)
          return;
        var isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
        var hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        var transformTemplate = (_a3 = this.options.visualElement) === null || _a3 === void 0 ? void 0 : _a3.getProps().transformTemplate;
        var transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
        var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      };
      ProjectionNode.prototype.measure = function() {
        var visualElement2 = this.options.visualElement;
        if (!visualElement2)
          return createBox();
        var box = visualElement2.measureViewportBox();
        var scroll = this.root.scroll;
        if (scroll) {
          translateAxis(box.x, scroll.x);
          translateAxis(box.y, scroll.y);
        }
        return box;
      };
      ProjectionNode.prototype.removeElementScroll = function(box) {
        var boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        for (var i2 = 0; i2 < this.path.length; i2++) {
          var node2 = this.path[i2];
          var scroll_1 = node2.scroll, options = node2.options, isScrollRoot = node2.isScrollRoot;
          if (node2 !== this.root && scroll_1 && options.layoutScroll) {
            if (isScrollRoot) {
              copyBoxInto(boxWithoutScroll, box);
              var rootScroll = this.root.scroll;
              if (rootScroll) {
                translateAxis(boxWithoutScroll.x, -rootScroll.x);
                translateAxis(boxWithoutScroll.y, -rootScroll.y);
              }
            }
            translateAxis(boxWithoutScroll.x, scroll_1.x);
            translateAxis(boxWithoutScroll.y, scroll_1.y);
          }
        }
        return boxWithoutScroll;
      };
      ProjectionNode.prototype.applyTransform = function(box, transformOnly) {
        if (transformOnly === void 0) {
          transformOnly = false;
        }
        var withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (var i2 = 0; i2 < this.path.length; i2++) {
          var node2 = this.path[i2];
          if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
            transformBox(withTransforms, {
              x: -node2.scroll.x,
              y: -node2.scroll.y
            });
          }
          if (!hasTransform(node2.latestValues))
            continue;
          transformBox(withTransforms, node2.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      };
      ProjectionNode.prototype.removeTransform = function(box) {
        var _a3;
        var boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (var i2 = 0; i2 < this.path.length; i2++) {
          var node2 = this.path[i2];
          if (!node2.instance)
            continue;
          if (!hasTransform(node2.latestValues))
            continue;
          hasScale(node2.latestValues) && node2.updateSnapshot();
          var sourceBox = createBox();
          var nodeBox = node2.measure();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node2.latestValues, (_a3 = node2.snapshot) === null || _a3 === void 0 ? void 0 : _a3.layout, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      };
      ProjectionNode.prototype.setTargetDelta = function(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
      };
      ProjectionNode.prototype.setOptions = function(options) {
        var _a3;
        this.options = __assign$2(__assign$2(__assign$2({}, this.options), options), { crossfade: (_a3 = options.crossfade) !== null && _a3 !== void 0 ? _a3 : true });
      };
      ProjectionNode.prototype.clearMeasurements = function() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      };
      ProjectionNode.prototype.resolveTargetDelta = function() {
        var _a3;
        var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;
        if (!this.layout || !(layout || layoutId))
          return;
        if (!this.targetDelta && !this.relativeTarget) {
          this.relativeParent = this.getClosestProjectingParent();
          if (this.relativeParent && this.relativeParent.layout) {
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && ((_a3 = this.relativeParent) === null || _a3 === void 0 ? void 0 : _a3.target)) {
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.actual);
          } else {
            copyBoxInto(this.target, this.layout.actual);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.actual);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          this.relativeParent = this.getClosestProjectingParent();
          if (this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target) {
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          }
        }
      };
      ProjectionNode.prototype.getClosestProjectingParent = function() {
        if (!this.parent || hasTransform(this.parent.latestValues))
          return void 0;
        if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      };
      ProjectionNode.prototype.calcProjection = function() {
        var _a3;
        var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;
        this.isTreeAnimating = Boolean(((_a3 = this.parent) === null || _a3 === void 0 ? void 0 : _a3.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout || layoutId))
          return;
        var lead = this.getLead();
        copyBoxInto(this.layoutCorrected, this.layout.actual);
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);
        var target = lead.target;
        if (!target)
          return;
        if (!this.projectionDelta) {
          this.projectionDelta = createDelta();
          this.projectionDeltaWithTransform = createDelta();
        }
        var prevTreeScaleX = this.treeScale.x;
        var prevTreeScaleY = this.treeScale.y;
        var prevProjectionTransform = this.projectionTransform;
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
        if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
      };
      ProjectionNode.prototype.hide = function() {
        this.isVisible = false;
      };
      ProjectionNode.prototype.show = function() {
        this.isVisible = true;
      };
      ProjectionNode.prototype.scheduleRender = function(notifyAll) {
        var _a3, _b, _c;
        if (notifyAll === void 0) {
          notifyAll = true;
        }
        (_b = (_a3 = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a3);
        notifyAll && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      };
      ProjectionNode.prototype.setAnimationOrigin = function(delta, hasOnlyRelativeTargetChanged) {
        var _this = this;
        var _a3;
        if (hasOnlyRelativeTargetChanged === void 0) {
          hasOnlyRelativeTargetChanged = false;
        }
        var snapshot2 = this.snapshot;
        var snapshotLatestValues = (snapshot2 === null || snapshot2 === void 0 ? void 0 : snapshot2.latestValues) || {};
        var mixedValues = __assign$2({}, this.latestValues);
        var targetDelta = createDelta();
        this.relativeTarget = this.relativeTargetOrigin = void 0;
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        var relativeLayout = createBox();
        var isSharedLayoutAnimation = snapshot2 === null || snapshot2 === void 0 ? void 0 : snapshot2.isShared;
        var isOnlyMember = (((_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.members.length) || 0) <= 1;
        var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        this.mixTargetDelta = function(latest) {
          var _a4;
          var progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          _this.setTargetDelta(targetDelta);
          if (_this.relativeTarget && _this.relativeTargetOrigin && _this.layout && ((_a4 = _this.relativeParent) === null || _a4 === void 0 ? void 0 : _a4.layout)) {
            calcRelativePosition(relativeLayout, _this.layout.actual, _this.relativeParent.layout.actual);
            mixBox(_this.relativeTarget, _this.relativeTargetOrigin, relativeLayout, progress2);
          }
          if (isSharedLayoutAnimation) {
            _this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, _this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          _this.root.scheduleUpdateProjection();
          _this.scheduleRender();
          _this.animationProgress = progress2;
        };
        this.mixTargetDelta(0);
      };
      ProjectionNode.prototype.startAnimation = function(options) {
        var _this = this;
        var _a3, _b;
        this.notifyListeners("animationStart");
        (_a3 = this.currentAnimation) === null || _a3 === void 0 ? void 0 : _a3.stop();
        if (this.resumingFrom) {
          (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();
        }
        if (this.pendingAnimation) {
          cancelSync.update(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = sync.update(function() {
          globalProjectionState.hasAnimatedSinceResize = true;
          _this.currentAnimation = animate(0, animationTarget, __assign$2(__assign$2({}, options), { onUpdate: function(latest) {
            var _a4;
            _this.mixTargetDelta(latest);
            (_a4 = options.onUpdate) === null || _a4 === void 0 ? void 0 : _a4.call(options, latest);
          }, onComplete: function() {
            var _a4;
            (_a4 = options.onComplete) === null || _a4 === void 0 ? void 0 : _a4.call(options);
            _this.completeAnimation();
          } }));
          if (_this.resumingFrom) {
            _this.resumingFrom.currentAnimation = _this.currentAnimation;
          }
          _this.pendingAnimation = void 0;
        });
      };
      ProjectionNode.prototype.completeAnimation = function() {
        var _a3;
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        (_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      };
      ProjectionNode.prototype.finishAnimation = function() {
        var _a3;
        if (this.currentAnimation) {
          (_a3 = this.mixTargetDelta) === null || _a3 === void 0 ? void 0 : _a3.call(this, animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      };
      ProjectionNode.prototype.applyTransformsToTarget = function() {
        var _a3 = this.getLead(), targetWithTransforms = _a3.targetWithTransforms, target = _a3.target, layout = _a3.layout, latestValues = _a3.latestValues;
        if (!targetWithTransforms || !target || !layout)
          return;
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      };
      ProjectionNode.prototype.registerSharedNode = function(layoutId, node2) {
        var _a3, _b, _c;
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        var stack = this.sharedNodes.get(layoutId);
        stack.add(node2);
        node2.promote({
          transition: (_a3 = node2.options.initialPromotionConfig) === null || _a3 === void 0 ? void 0 : _a3.transition,
          preserveFollowOpacity: (_c = (_b = node2.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node2)
        });
      };
      ProjectionNode.prototype.isLead = function() {
        var stack = this.getStack();
        return stack ? stack.lead === this : true;
      };
      ProjectionNode.prototype.getLead = function() {
        var _a3;
        var layoutId = this.options.layoutId;
        return layoutId ? ((_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.lead) || this : this;
      };
      ProjectionNode.prototype.getPrevLead = function() {
        var _a3;
        var layoutId = this.options.layoutId;
        return layoutId ? (_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.prevLead : void 0;
      };
      ProjectionNode.prototype.getStack = function() {
        var layoutId = this.options.layoutId;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      };
      ProjectionNode.prototype.promote = function(_a3) {
        var _b = _a3 === void 0 ? {} : _a3, needsReset = _b.needsReset, transition2 = _b.transition, preserveFollowOpacity = _b.preserveFollowOpacity;
        var stack = this.getStack();
        if (stack)
          stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition2)
          this.setOptions({ transition: transition2 });
      };
      ProjectionNode.prototype.relegate = function() {
        var stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      };
      ProjectionNode.prototype.resetRotation = function() {
        var visualElement2 = this.options.visualElement;
        if (!visualElement2)
          return;
        var hasRotate = false;
        var resetValues = {};
        for (var i2 = 0; i2 < transformAxes.length; i2++) {
          var axis = transformAxes[i2];
          var key = "rotate" + axis;
          if (!visualElement2.getStaticValue(key)) {
            continue;
          }
          hasRotate = true;
          resetValues[key] = visualElement2.getStaticValue(key);
          visualElement2.setStaticValue(key, 0);
        }
        if (!hasRotate)
          return;
        visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
        for (var key in resetValues) {
          visualElement2.setStaticValue(key, resetValues[key]);
        }
        visualElement2.scheduleRender();
      };
      ProjectionNode.prototype.getProjectionStyles = function(styleProp) {
        var _a3, _b, _c, _d, _e2, _f;
        if (styleProp === void 0) {
          styleProp = {};
        }
        var styles2 = {};
        if (!this.instance || this.isSVG)
          return styles2;
        if (!this.isVisible) {
          return { visibility: "hidden" };
        } else {
          styles2.visibility = "";
        }
        var transformTemplate = (_a3 = this.options.visualElement) === null || _a3 === void 0 ? void 0 : _a3.getProps().transformTemplate;
        if (this.needsReset) {
          this.needsReset = false;
          styles2.opacity = "";
          styles2.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
          styles2.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return styles2;
        }
        var lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          var emptyStyles = {};
          if (this.options.layoutId) {
            emptyStyles.opacity = (_b = this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1;
            emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return emptyStyles;
        }
        var valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        styles2.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          styles2.transform = transformTemplate(valuesToRender, styles2.transform);
        }
        var _g = this.projectionDelta, x2 = _g.x, y2 = _g.y;
        styles2.transformOrigin = "".concat(x2.origin * 100, "% ").concat(y2.origin * 100, "% 0");
        if (lead.animationValues) {
          styles2.opacity = lead === this ? (_d = (_c = valuesToRender.opacity) !== null && _c !== void 0 ? _c : this.latestValues.opacity) !== null && _d !== void 0 ? _d : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          styles2.opacity = lead === this ? (_e2 = valuesToRender.opacity) !== null && _e2 !== void 0 ? _e2 : "" : (_f = valuesToRender.opacityExit) !== null && _f !== void 0 ? _f : 0;
        }
        for (var key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          var _h = scaleCorrectors[key], correct = _h.correct, applyTo = _h.applyTo;
          var corrected = correct(valuesToRender[key], lead);
          if (applyTo) {
            var num = applyTo.length;
            for (var i2 = 0; i2 < num; i2++) {
              styles2[applyTo[i2]] = corrected;
            }
          } else {
            styles2[key] = corrected;
          }
        }
        if (this.options.layoutId) {
          styles2.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
        }
        return styles2;
      };
      ProjectionNode.prototype.clearSnapshot = function() {
        this.resumeFrom = this.snapshot = void 0;
      };
      ProjectionNode.prototype.resetTree = function() {
        this.root.nodes.forEach(function(node2) {
          var _a3;
          return (_a3 = node2.currentAnimation) === null || _a3 === void 0 ? void 0 : _a3.stop();
        });
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      };
      return ProjectionNode;
    }()
  );
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  var _a2, _b, _c, _d;
  var snapshot2 = (_b = (_a2 = node2.resumeFrom) === null || _a2 === void 0 ? void 0 : _a2.snapshot) !== null && _b !== void 0 ? _b : node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot2 && node2.hasListeners("didUpdate")) {
    var _e2 = node2.layout, layout_1 = _e2.actual, measuredLayout = _e2.measured;
    if (node2.options.animationType === "size") {
      eachAxis(function(axis) {
        var axisSnapshot = snapshot2.isShared ? snapshot2.measured[axis] : snapshot2.layout[axis];
        var length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout_1[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (node2.options.animationType === "position") {
      eachAxis(function(axis) {
        var axisSnapshot = snapshot2.isShared ? snapshot2.measured[axis] : snapshot2.layout[axis];
        var length2 = calcLength(layout_1[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    }
    var layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout_1, snapshot2.layout);
    var visualDelta = createDelta();
    if (snapshot2.isShared) {
      calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot2.measured);
    } else {
      calcBoxDelta(visualDelta, layout_1, snapshot2.layout);
    }
    var hasLayoutChanged = !isDeltaZero(layoutDelta);
    var hasRelativeTargetChanged = false;
    if (!node2.resumeFrom) {
      node2.relativeParent = node2.getClosestProjectingParent();
      if (node2.relativeParent && !node2.relativeParent.resumeFrom) {
        var _f = node2.relativeParent, parentSnapshot = _f.snapshot, parentLayout = _f.layout;
        if (parentSnapshot && parentLayout) {
          var relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot2.layout, parentSnapshot.layout);
          var relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout_1, parentLayout.actual);
          if (!boxEquals(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout_1,
      snapshot: snapshot2,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node2.isLead()) {
    (_d = (_c = node2.options).onExitComplete) === null || _d === void 0 ? void 0 : _d.call(_c);
  }
  node2.options.transition = void 0;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function resetTransformStyle(node2) {
  var visualElement2 = node2.options.visualElement;
  if (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.getProps().onBeforeLayoutMeasure) {
    visualElement2.notifyBeforeLayoutMeasure();
  }
  node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation();
  node2.targetDelta = node2.relativeTarget = node2.target = void 0;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetRotation(node2) {
  node2.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output2, delta, p2) {
  output2.translate = mix(delta.translate, 0, p2);
  output2.scale = mix(delta.scale, 1, p2);
  output2.origin = delta.origin;
  output2.originPoint = delta.originPoint;
}
function mixAxis(output2, from2, to, p2) {
  output2.min = mix(from2.min, to.min, p2);
  output2.max = mix(from2.max, to.max, p2);
}
function mixBox(output2, from2, to, p2) {
  mixAxis(output2.x, from2.x, to.x, p2);
  mixAxis(output2.y, from2.y, to.y, p2);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function mountNodeEarly(node2, id2) {
  var searchNode = node2.root;
  for (var i2 = node2.path.length - 1; i2 >= 0; i2--) {
    if (Boolean(node2.path[i2].instance)) {
      searchNode = node2.path[i2];
      break;
    }
  }
  var searchElement = searchNode && searchNode !== node2.root ? searchNode.instance : document;
  var element = searchElement.querySelector('[data-projection-id="'.concat(id2, '"]'));
  if (element)
    node2.mount(element, true);
}
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
var DocumentProjectionNode = createProjectionNode({
  attachResizeListener: function(ref, notify) {
    return addDomEvent(ref, "resize", notify);
  },
  measureScroll: function() {
    return {
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    };
  },
  checkIsScrollRoot: function() {
    return true;
  }
});
var rootProjectionNode = {
  current: void 0
};
var HTMLProjectionNode = createProjectionNode({
  measureScroll: function(instance) {
    return {
      x: instance.scrollLeft,
      y: instance.scrollTop
    };
  },
  defaultParent: function() {
    if (!rootProjectionNode.current) {
      var documentNode = new DocumentProjectionNode(0, {});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: function(instance, value) {
    instance.style.transform = value !== null && value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: function(instance) {
    return Boolean(window.getComputedStyle(instance).position === "fixed");
  }
});
var featureBundle = __assign$2(__assign$2(__assign$2(__assign$2({}, animations), gestureAnimations), drag), layoutFeatures);
var motion = /* @__PURE__ */ createMotionProxy(function(Component2, config2) {
  return createDomMotionConfig(Component2, config2, featureBundle, createDomVisualElement, HTMLProjectionNode);
});
function useIsMounted$1() {
  var isMounted = reactExports.useRef(false);
  useIsomorphicLayoutEffect$1(function() {
    isMounted.current = true;
    return function() {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
function useForceUpdate() {
  var isMounted = useIsMounted$1();
  var _a2 = __read$1(reactExports.useState(0), 2), forcedRenderCount = _a2[0], setForcedRenderCount = _a2[1];
  var forceRender = reactExports.useCallback(function() {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  var deferredForceRender = reactExports.useCallback(function() {
    return sync.postRender(forceRender);
  }, [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
var PresenceChild = function(_a2) {
  var children = _a2.children, initial = _a2.initial, isPresent = _a2.isPresent, onExitComplete = _a2.onExitComplete, custom2 = _a2.custom, presenceAffectsLayout = _a2.presenceAffectsLayout;
  var presenceChildren = useConstant(newChildrenMap);
  var id2 = useId();
  var context = reactExports.useMemo(
    function() {
      return {
        id: id2,
        initial,
        isPresent,
        custom: custom2,
        onExitComplete: function(childId) {
          var e_1, _a3;
          presenceChildren.set(childId, true);
          try {
            for (var _b = __values$1(presenceChildren.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
              var isComplete = _c.value;
              if (!isComplete)
                return;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a3 = _b.return))
                _a3.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete();
        },
        register: function(childId) {
          presenceChildren.set(childId, false);
          return function() {
            return presenceChildren.delete(childId);
          };
        }
      };
    },
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent]
  );
  reactExports.useMemo(function() {
    presenceChildren.forEach(function(_2, key) {
      return presenceChildren.set(key, false);
    });
  }, [isPresent]);
  reactExports.useEffect(function() {
    !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());
  }, [isPresent]);
  return reactExports.createElement(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
var getChildKey = function(child) {
  return child.key || "";
};
function updateChildLookup(children, allChildren) {
  children.forEach(function(child) {
    var key = getChildKey(child);
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  var filtered = [];
  reactExports.Children.forEach(children, function(child) {
    if (reactExports.isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
var AnimatePresence = function(_a2) {
  var children = _a2.children, custom2 = _a2.custom, _b = _a2.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a2.onExitComplete, exitBeforeEnter = _a2.exitBeforeEnter, _c = _a2.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;
  var _d = __read$1(useForceUpdate(), 1), forceRender = _d[0];
  var forceRenderLayoutGroup = reactExports.useContext(LayoutGroupContext).forceRender;
  if (forceRenderLayoutGroup)
    forceRender = forceRenderLayoutGroup;
  var isMounted = useIsMounted$1();
  var filteredChildren = onlyElements(children);
  var childrenToRender = filteredChildren;
  var exiting = /* @__PURE__ */ new Set();
  var presentChildren = reactExports.useRef(childrenToRender);
  var allChildren = reactExports.useRef(/* @__PURE__ */ new Map()).current;
  var isInitialRender = reactExports.useRef(true);
  useIsomorphicLayoutEffect$1(function() {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect(function() {
    isInitialRender.current = true;
    allChildren.clear();
    exiting.clear();
  });
  if (isInitialRender.current) {
    return reactExports.createElement(reactExports.Fragment, null, childrenToRender.map(function(child) {
      return reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout }, child);
    }));
  }
  childrenToRender = __spreadArray$1([], __read$1(childrenToRender), false);
  var presentKeys = presentChildren.current.map(getChildKey);
  var targetKeys = filteredChildren.map(getChildKey);
  var numPresent = presentKeys.length;
  for (var i2 = 0; i2 < numPresent; i2++) {
    var key = presentKeys[i2];
    if (targetKeys.indexOf(key) === -1) {
      exiting.add(key);
    }
  }
  if (exitBeforeEnter && exiting.size) {
    childrenToRender = [];
  }
  exiting.forEach(function(key2) {
    if (targetKeys.indexOf(key2) !== -1)
      return;
    var child = allChildren.get(key2);
    if (!child)
      return;
    var insertionIndex = presentKeys.indexOf(key2);
    var onExit = function() {
      allChildren.delete(key2);
      exiting.delete(key2);
      var removeIndex = presentChildren.current.findIndex(function(presentChild) {
        return presentChild.key === key2;
      });
      presentChildren.current.splice(removeIndex, 1);
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        if (isMounted.current === false)
          return;
        forceRender();
        onExitComplete && onExitComplete();
      }
    };
    childrenToRender.splice(insertionIndex, 0, reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom2, presenceAffectsLayout }, child));
  });
  childrenToRender = childrenToRender.map(function(child) {
    var key2 = child.key;
    return exiting.has(key2) ? child : reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout }, child);
  });
  if (env !== "production" && exitBeforeEnter && childrenToRender.length > 1) {
    console.warn("You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.");
  }
  return reactExports.createElement(reactExports.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function(child) {
    return reactExports.cloneElement(child);
  }));
};
function MotionConfig(_a2) {
  var children = _a2.children, isValidProp = _a2.isValidProp, config2 = __rest$2(_a2, ["children", "isValidProp"]);
  isValidProp && loadExternalIsValidProp(isValidProp);
  config2 = __assign$2(__assign$2({}, reactExports.useContext(MotionConfigContext)), config2);
  config2.isStatic = useConstant(function() {
    return config2.isStatic;
  });
  var context = reactExports.useMemo(function() {
    return config2;
  }, [JSON.stringify(config2.transition), config2.transformPagePoint, config2.reducedMotion]);
  return reactExports.createElement(MotionConfigContext.Provider, { value: context }, children);
}
var reactIs$3 = { exports: {} };
var reactIs_production_min$3 = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$3 = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d$2 = Symbol.for("react.fragment"), e$1 = Symbol.for("react.strict_mode"), f$2 = Symbol.for("react.profiler"), g$3 = Symbol.for("react.provider"), h$2 = Symbol.for("react.context"), k$3 = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m$4 = Symbol.for("react.suspense"), n$1 = Symbol.for("react.suspense_list"), p$2 = Symbol.for("react.memo"), q$3 = Symbol.for("react.lazy"), t$1 = Symbol.for("react.offscreen"), u$1;
u$1 = Symbol.for("react.module.reference");
function v$3(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var r2 = a2.$$typeof;
    switch (r2) {
      case b$3:
        switch (a2 = a2.type, a2) {
          case d$2:
          case f$2:
          case e$1:
          case m$4:
          case n$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$3:
              case h$2:
              case l$1:
              case q$3:
              case p$2:
              case g$3:
                return a2;
              default:
                return r2;
            }
        }
      case c$1:
        return r2;
    }
  }
}
var ContextConsumer$1 = reactIs_production_min$3.ContextConsumer = h$2;
var ContextProvider$1 = reactIs_production_min$3.ContextProvider = g$3;
var Element$2 = reactIs_production_min$3.Element = b$3;
var ForwardRef$1 = reactIs_production_min$3.ForwardRef = l$1;
var Fragment$1 = reactIs_production_min$3.Fragment = d$2;
var Lazy$1 = reactIs_production_min$3.Lazy = q$3;
var Memo$1 = reactIs_production_min$3.Memo = p$2;
var Portal$2 = reactIs_production_min$3.Portal = c$1;
var Profiler$1 = reactIs_production_min$3.Profiler = f$2;
var StrictMode$1 = reactIs_production_min$3.StrictMode = e$1;
var Suspense$1 = reactIs_production_min$3.Suspense = m$4;
var SuspenseList = reactIs_production_min$3.SuspenseList = n$1;
var isAsyncMode$1 = reactIs_production_min$3.isAsyncMode = function() {
  return false;
};
var isConcurrentMode$1 = reactIs_production_min$3.isConcurrentMode = function() {
  return false;
};
var isContextConsumer$1 = reactIs_production_min$3.isContextConsumer = function(a2) {
  return v$3(a2) === h$2;
};
var isContextProvider$1 = reactIs_production_min$3.isContextProvider = function(a2) {
  return v$3(a2) === g$3;
};
var isElement$1 = reactIs_production_min$3.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$3;
};
var isForwardRef$1 = reactIs_production_min$3.isForwardRef = function(a2) {
  return v$3(a2) === l$1;
};
var isFragment$1 = reactIs_production_min$3.isFragment = function(a2) {
  return v$3(a2) === d$2;
};
var isLazy$1 = reactIs_production_min$3.isLazy = function(a2) {
  return v$3(a2) === q$3;
};
var isMemo$1 = reactIs_production_min$3.isMemo = function(a2) {
  return v$3(a2) === p$2;
};
var isPortal$1 = reactIs_production_min$3.isPortal = function(a2) {
  return v$3(a2) === c$1;
};
var isProfiler$1 = reactIs_production_min$3.isProfiler = function(a2) {
  return v$3(a2) === f$2;
};
var isStrictMode$1 = reactIs_production_min$3.isStrictMode = function(a2) {
  return v$3(a2) === e$1;
};
var isSuspense$1 = reactIs_production_min$3.isSuspense = function(a2) {
  return v$3(a2) === m$4;
};
var isSuspenseList = reactIs_production_min$3.isSuspenseList = function(a2) {
  return v$3(a2) === n$1;
};
var isValidElementType$1 = reactIs_production_min$3.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d$2 || a2 === f$2 || a2 === e$1 || a2 === m$4 || a2 === n$1 || a2 === t$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q$3 || a2.$$typeof === p$2 || a2.$$typeof === g$3 || a2.$$typeof === h$2 || a2.$$typeof === l$1 || a2.$$typeof === u$1 || void 0 !== a2.getModuleId) ? true : false;
};
var typeOf$1 = reactIs_production_min$3.typeOf = v$3;
const reactIs_production_min$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  ContextConsumer: ContextConsumer$1,
  ContextProvider: ContextProvider$1,
  Element: Element$2,
  ForwardRef: ForwardRef$1,
  Fragment: Fragment$1,
  Lazy: Lazy$1,
  Memo: Memo$1,
  Portal: Portal$2,
  Profiler: Profiler$1,
  StrictMode: StrictMode$1,
  Suspense: Suspense$1,
  SuspenseList,
  default: reactIs_production_min$3,
  isAsyncMode: isAsyncMode$1,
  isConcurrentMode: isConcurrentMode$1,
  isContextConsumer: isContextConsumer$1,
  isContextProvider: isContextProvider$1,
  isElement: isElement$1,
  isForwardRef: isForwardRef$1,
  isFragment: isFragment$1,
  isLazy: isLazy$1,
  isMemo: isMemo$1,
  isPortal: isPortal$1,
  isProfiler: isProfiler$1,
  isStrictMode: isStrictMode$1,
  isSuspense: isSuspense$1,
  isSuspenseList,
  isValidElementType: isValidElementType$1,
  typeOf: typeOf$1
}, [reactIs_production_min$3]);
const require$$0$r = /* @__PURE__ */ getAugmentedNamespace(reactIs_production_min$2);
{
  reactIs$3.exports = require$$0$r;
}
var reactIsExports$1 = reactIs$3.exports;
const ReactIs = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports$1);
function stylis_min(W2) {
  function M2(d2, c2, e2, h2, a2) {
    for (var m2 = 0, b2 = 0, v2 = 0, n2 = 0, q2, g2, x2 = 0, K2 = 0, k2, u2 = k2 = q2 = 0, l2 = 0, r2 = 0, I2 = 0, t2 = 0, B3 = e2.length, J2 = B3 - 1, y2, f2 = "", p2 = "", F3 = "", G3 = "", C2; l2 < B3; ) {
      g2 = e2.charCodeAt(l2);
      l2 === J2 && 0 !== b2 + n2 + v2 + m2 && (0 !== b2 && (g2 = 47 === b2 ? 10 : 47), n2 = v2 = m2 = 0, B3++, J2++);
      if (0 === b2 + n2 + v2 + m2) {
        if (l2 === J2 && (0 < r2 && (f2 = f2.replace(N10, "")), 0 < f2.trim().length)) {
          switch (g2) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              f2 += e2.charAt(l2);
          }
          g2 = 59;
        }
        switch (g2) {
          case 123:
            f2 = f2.trim();
            q2 = f2.charCodeAt(0);
            k2 = 1;
            for (t2 = ++l2; l2 < B3; ) {
              switch (g2 = e2.charCodeAt(l2)) {
                case 123:
                  k2++;
                  break;
                case 125:
                  k2--;
                  break;
                case 47:
                  switch (g2 = e2.charCodeAt(l2 + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u2 = l2 + 1; u2 < J2; ++u2) {
                          switch (e2.charCodeAt(u2)) {
                            case 47:
                              if (42 === g2 && 42 === e2.charCodeAt(u2 - 1) && l2 + 2 !== u2) {
                                l2 = u2 + 1;
                                break a;
                              }
                              break;
                            case 10:
                              if (47 === g2) {
                                l2 = u2 + 1;
                                break a;
                              }
                          }
                        }
                        l2 = u2;
                      }
                  }
                  break;
                case 91:
                  g2++;
                case 40:
                  g2++;
                case 34:
                case 39:
                  for (; l2++ < J2 && e2.charCodeAt(l2) !== g2; ) {
                  }
              }
              if (0 === k2)
                break;
              l2++;
            }
            k2 = e2.substring(t2, l2);
            0 === q2 && (q2 = (f2 = f2.replace(ca2, "").trim()).charCodeAt(0));
            switch (q2) {
              case 64:
                0 < r2 && (f2 = f2.replace(N10, ""));
                g2 = f2.charCodeAt(1);
                switch (g2) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r2 = c2;
                    break;
                  default:
                    r2 = O2;
                }
                k2 = M2(c2, r2, k2, g2, a2 + 1);
                t2 = k2.length;
                0 < A2 && (r2 = X2(O2, f2, I2), C2 = H2(3, k2, r2, c2, D2, z2, t2, g2, a2, h2), f2 = r2.join(""), void 0 !== C2 && 0 === (t2 = (k2 = C2.trim()).length) && (g2 = 0, k2 = ""));
                if (0 < t2)
                  switch (g2) {
                    case 115:
                      f2 = f2.replace(da2, ea2);
                    case 100:
                    case 109:
                    case 45:
                      k2 = f2 + "{" + k2 + "}";
                      break;
                    case 107:
                      f2 = f2.replace(fa2, "$1 $2");
                      k2 = f2 + "{" + k2 + "}";
                      k2 = 1 === w2 || 2 === w2 && L2("@" + k2, 3) ? "@-webkit-" + k2 + "@" + k2 : "@" + k2;
                      break;
                    default:
                      k2 = f2 + k2, 112 === h2 && (k2 = (p2 += k2, ""));
                  }
                else
                  k2 = "";
                break;
              default:
                k2 = M2(c2, X2(c2, f2, I2), k2, h2, a2 + 1);
            }
            F3 += k2;
            k2 = I2 = r2 = u2 = q2 = 0;
            f2 = "";
            g2 = e2.charCodeAt(++l2);
            break;
          case 125:
          case 59:
            f2 = (0 < r2 ? f2.replace(N10, "") : f2).trim();
            if (1 < (t2 = f2.length))
              switch (0 === u2 && (q2 = f2.charCodeAt(0), 45 === q2 || 96 < q2 && 123 > q2) && (t2 = (f2 = f2.replace(" ", ":")).length), 0 < A2 && void 0 !== (C2 = H2(1, f2, c2, d2, D2, z2, p2.length, h2, a2, h2)) && 0 === (t2 = (f2 = C2.trim()).length) && (f2 = "\0\0"), q2 = f2.charCodeAt(0), g2 = f2.charCodeAt(1), q2) {
                case 0:
                  break;
                case 64:
                  if (105 === g2 || 99 === g2) {
                    G3 += f2 + e2.charAt(l2);
                    break;
                  }
                default:
                  58 !== f2.charCodeAt(t2 - 1) && (p2 += P2(f2, q2, g2, f2.charCodeAt(2)));
              }
            I2 = r2 = u2 = q2 = 0;
            f2 = "";
            g2 = e2.charCodeAt(++l2);
        }
      }
      switch (g2) {
        case 13:
        case 10:
          47 === b2 ? b2 = 0 : 0 === 1 + q2 && 107 !== h2 && 0 < f2.length && (r2 = 1, f2 += "\0");
          0 < A2 * Y2 && H2(0, f2, c2, d2, D2, z2, p2.length, h2, a2, h2);
          z2 = 1;
          D2++;
          break;
        case 59:
        case 125:
          if (0 === b2 + n2 + v2 + m2) {
            z2++;
            break;
          }
        default:
          z2++;
          y2 = e2.charAt(l2);
          switch (g2) {
            case 9:
            case 32:
              if (0 === n2 + m2 + b2)
                switch (x2) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    y2 = "";
                    break;
                  default:
                    32 !== g2 && (y2 = " ");
                }
              break;
            case 0:
              y2 = "\\0";
              break;
            case 12:
              y2 = "\\f";
              break;
            case 11:
              y2 = "\\v";
              break;
            case 38:
              0 === n2 + b2 + m2 && (r2 = I2 = 1, y2 = "\f" + y2);
              break;
            case 108:
              if (0 === n2 + b2 + m2 + E2 && 0 < u2)
                switch (l2 - u2) {
                  case 2:
                    112 === x2 && 58 === e2.charCodeAt(l2 - 3) && (E2 = x2);
                  case 8:
                    111 === K2 && (E2 = K2);
                }
              break;
            case 58:
              0 === n2 + b2 + m2 && (u2 = l2);
              break;
            case 44:
              0 === b2 + v2 + n2 + m2 && (r2 = 1, y2 += "\r");
              break;
            case 34:
            case 39:
              0 === b2 && (n2 = n2 === g2 ? 0 : 0 === n2 ? g2 : n2);
              break;
            case 91:
              0 === n2 + b2 + v2 && m2++;
              break;
            case 93:
              0 === n2 + b2 + v2 && m2--;
              break;
            case 41:
              0 === n2 + b2 + m2 && v2--;
              break;
            case 40:
              if (0 === n2 + b2 + m2) {
                if (0 === q2)
                  switch (2 * x2 + 3 * K2) {
                    case 533:
                      break;
                    default:
                      q2 = 1;
                  }
                v2++;
              }
              break;
            case 64:
              0 === b2 + v2 + n2 + m2 + u2 + k2 && (k2 = 1);
              break;
            case 42:
            case 47:
              if (!(0 < n2 + m2 + v2))
                switch (b2) {
                  case 0:
                    switch (2 * g2 + 3 * e2.charCodeAt(l2 + 1)) {
                      case 235:
                        b2 = 47;
                        break;
                      case 220:
                        t2 = l2, b2 = 42;
                    }
                    break;
                  case 42:
                    47 === g2 && 42 === x2 && t2 + 2 !== l2 && (33 === e2.charCodeAt(t2 + 2) && (p2 += e2.substring(t2, l2 + 1)), y2 = "", b2 = 0);
                }
          }
          0 === b2 && (f2 += y2);
      }
      K2 = x2;
      x2 = g2;
      l2++;
    }
    t2 = p2.length;
    if (0 < t2) {
      r2 = c2;
      if (0 < A2 && (C2 = H2(2, p2, r2, d2, D2, z2, t2, h2, a2, h2), void 0 !== C2 && 0 === (p2 = C2).length))
        return G3 + p2 + F3;
      p2 = r2.join(",") + "{" + p2 + "}";
      if (0 !== w2 * E2) {
        2 !== w2 || L2(p2, 2) || (E2 = 0);
        switch (E2) {
          case 111:
            p2 = p2.replace(ha2, ":-moz-$1") + p2;
            break;
          case 112:
            p2 = p2.replace(Q2, "::-webkit-input-$1") + p2.replace(Q2, "::-moz-$1") + p2.replace(Q2, ":-ms-input-$1") + p2;
        }
        E2 = 0;
      }
    }
    return G3 + p2 + F3;
  }
  function X2(d2, c2, e2) {
    var h2 = c2.trim().split(ia2);
    c2 = h2;
    var a2 = h2.length, m2 = d2.length;
    switch (m2) {
      case 0:
      case 1:
        var b2 = 0;
        for (d2 = 0 === m2 ? "" : d2[0] + " "; b2 < a2; ++b2) {
          c2[b2] = Z2(d2, c2[b2], e2).trim();
        }
        break;
      default:
        var v2 = b2 = 0;
        for (c2 = []; b2 < a2; ++b2) {
          for (var n2 = 0; n2 < m2; ++n2) {
            c2[v2++] = Z2(d2[n2] + " ", h2[b2], e2).trim();
          }
        }
    }
    return c2;
  }
  function Z2(d2, c2, e2) {
    var h2 = c2.charCodeAt(0);
    33 > h2 && (h2 = (c2 = c2.trim()).charCodeAt(0));
    switch (h2) {
      case 38:
        return c2.replace(F2, "$1" + d2.trim());
      case 58:
        return d2.trim() + c2.replace(F2, "$1" + d2.trim());
      default:
        if (0 < 1 * e2 && 0 < c2.indexOf("\f"))
          return c2.replace(F2, (58 === d2.charCodeAt(0) ? "" : "$1") + d2.trim());
    }
    return d2 + c2;
  }
  function P2(d2, c2, e2, h2) {
    var a2 = d2 + ";", m2 = 2 * c2 + 3 * e2 + 4 * h2;
    if (944 === m2) {
      d2 = a2.indexOf(":", 9) + 1;
      var b2 = a2.substring(d2, a2.length - 1).trim();
      b2 = a2.substring(0, d2).trim() + b2 + ";";
      return 1 === w2 || 2 === w2 && L2(b2, 1) ? "-webkit-" + b2 + b2 : b2;
    }
    if (0 === w2 || 2 === w2 && !L2(a2, 1))
      return a2;
    switch (m2) {
      case 1015:
        return 97 === a2.charCodeAt(10) ? "-webkit-" + a2 + a2 : a2;
      case 951:
        return 116 === a2.charCodeAt(3) ? "-webkit-" + a2 + a2 : a2;
      case 963:
        return 110 === a2.charCodeAt(5) ? "-webkit-" + a2 + a2 : a2;
      case 1009:
        if (100 !== a2.charCodeAt(4))
          break;
      case 969:
      case 942:
        return "-webkit-" + a2 + a2;
      case 978:
        return "-webkit-" + a2 + "-moz-" + a2 + a2;
      case 1019:
      case 983:
        return "-webkit-" + a2 + "-moz-" + a2 + "-ms-" + a2 + a2;
      case 883:
        if (45 === a2.charCodeAt(8))
          return "-webkit-" + a2 + a2;
        if (0 < a2.indexOf("image-set(", 11))
          return a2.replace(ja2, "$1-webkit-$2") + a2;
        break;
      case 932:
        if (45 === a2.charCodeAt(4))
          switch (a2.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + a2.replace("-grow", "") + "-webkit-" + a2 + "-ms-" + a2.replace("grow", "positive") + a2;
            case 115:
              return "-webkit-" + a2 + "-ms-" + a2.replace("shrink", "negative") + a2;
            case 98:
              return "-webkit-" + a2 + "-ms-" + a2.replace("basis", "preferred-size") + a2;
          }
        return "-webkit-" + a2 + "-ms-" + a2 + a2;
      case 964:
        return "-webkit-" + a2 + "-ms-flex-" + a2 + a2;
      case 1023:
        if (99 !== a2.charCodeAt(8))
          break;
        b2 = a2.substring(a2.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify");
        return "-webkit-box-pack" + b2 + "-webkit-" + a2 + "-ms-flex-pack" + b2 + a2;
      case 1005:
        return ka2.test(a2) ? a2.replace(aa2, ":-webkit-") + a2.replace(aa2, ":-moz-") + a2 : a2;
      case 1e3:
        b2 = a2.substring(13).trim();
        c2 = b2.indexOf("-") + 1;
        switch (b2.charCodeAt(0) + b2.charCodeAt(c2)) {
          case 226:
            b2 = a2.replace(G2, "tb");
            break;
          case 232:
            b2 = a2.replace(G2, "tb-rl");
            break;
          case 220:
            b2 = a2.replace(G2, "lr");
            break;
          default:
            return a2;
        }
        return "-webkit-" + a2 + "-ms-" + b2 + a2;
      case 1017:
        if (-1 === a2.indexOf("sticky", 9))
          break;
      case 975:
        c2 = (a2 = d2).length - 10;
        b2 = (33 === a2.charCodeAt(c2) ? a2.substring(0, c2) : a2).substring(d2.indexOf(":", 7) + 1).trim();
        switch (m2 = b2.charCodeAt(0) + (b2.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b2.charCodeAt(8))
              break;
          case 115:
            a2 = a2.replace(b2, "-webkit-" + b2) + ";" + a2;
            break;
          case 207:
          case 102:
            a2 = a2.replace(b2, "-webkit-" + (102 < m2 ? "inline-" : "") + "box") + ";" + a2.replace(b2, "-webkit-" + b2) + ";" + a2.replace(b2, "-ms-" + b2 + "box") + ";" + a2;
        }
        return a2 + ";";
      case 938:
        if (45 === a2.charCodeAt(5))
          switch (a2.charCodeAt(6)) {
            case 105:
              return b2 = a2.replace("-items", ""), "-webkit-" + a2 + "-webkit-box-" + b2 + "-ms-flex-" + b2 + a2;
            case 115:
              return "-webkit-" + a2 + "-ms-flex-item-" + a2.replace(ba, "") + a2;
            default:
              return "-webkit-" + a2 + "-ms-flex-line-pack" + a2.replace("align-content", "").replace(ba, "") + a2;
          }
        break;
      case 973:
      case 989:
        if (45 !== a2.charCodeAt(3) || 122 === a2.charCodeAt(4))
          break;
      case 931:
      case 953:
        if (true === la2.test(d2))
          return 115 === (b2 = d2.substring(d2.indexOf(":") + 1)).charCodeAt(0) ? P2(d2.replace("stretch", "fill-available"), c2, e2, h2).replace(":fill-available", ":stretch") : a2.replace(b2, "-webkit-" + b2) + a2.replace(b2, "-moz-" + b2.replace("fill-", "")) + a2;
        break;
      case 962:
        if (a2 = "-webkit-" + a2 + (102 === a2.charCodeAt(5) ? "-ms-" + a2 : "") + a2, 211 === e2 + h2 && 105 === a2.charCodeAt(13) && 0 < a2.indexOf("transform", 10))
          return a2.substring(0, a2.indexOf(";", 27) + 1).replace(ma2, "$1-webkit-$2") + a2;
    }
    return a2;
  }
  function L2(d2, c2) {
    var e2 = d2.indexOf(1 === c2 ? ":" : "{"), h2 = d2.substring(0, 3 !== c2 ? e2 : 10);
    e2 = d2.substring(e2 + 1, d2.length - 1);
    return R2(2 !== c2 ? h2 : h2.replace(na, "$1"), e2, c2);
  }
  function ea2(d2, c2) {
    var e2 = P2(c2, c2.charCodeAt(0), c2.charCodeAt(1), c2.charCodeAt(2));
    return e2 !== c2 + ";" ? e2.replace(oa2, " or ($1)").substring(4) : "(" + c2 + ")";
  }
  function H2(d2, c2, e2, h2, a2, m2, b2, v2, n2, q2) {
    for (var g2 = 0, x2 = c2, w3; g2 < A2; ++g2) {
      switch (w3 = S2[g2].call(B2, d2, x2, e2, h2, a2, m2, b2, v2, n2, q2)) {
        case void 0:
        case false:
        case true:
        case null:
          break;
        default:
          x2 = w3;
      }
    }
    if (x2 !== c2)
      return x2;
  }
  function T2(d2) {
    switch (d2) {
      case void 0:
      case null:
        A2 = S2.length = 0;
        break;
      default:
        if ("function" === typeof d2)
          S2[A2++] = d2;
        else if ("object" === typeof d2)
          for (var c2 = 0, e2 = d2.length; c2 < e2; ++c2) {
            T2(d2[c2]);
          }
        else
          Y2 = !!d2 | 0;
    }
    return T2;
  }
  function U2(d2) {
    d2 = d2.prefix;
    void 0 !== d2 && (R2 = null, d2 ? "function" !== typeof d2 ? w2 = 1 : (w2 = 2, R2 = d2) : w2 = 0);
    return U2;
  }
  function B2(d2, c2) {
    var e2 = d2;
    33 > e2.charCodeAt(0) && (e2 = e2.trim());
    V2 = e2;
    e2 = [V2];
    if (0 < A2) {
      var h2 = H2(-1, c2, e2, e2, D2, z2, 0, 0, 0, 0);
      void 0 !== h2 && "string" === typeof h2 && (c2 = h2);
    }
    var a2 = M2(O2, e2, c2, 0, 0);
    0 < A2 && (h2 = H2(-2, a2, e2, e2, D2, z2, a2.length, 0, 0, 0), void 0 !== h2 && (a2 = h2));
    V2 = "";
    E2 = 0;
    z2 = D2 = 1;
    return a2;
  }
  var ca2 = /^\0+/g, N10 = /[\0\r\f]/g, aa2 = /: */g, ka2 = /zoo|gra/, ma2 = /([,: ])(transform)/g, ia2 = /,\r+?/g, F2 = /([\t\r\n ])*\f?&/g, fa2 = /@(k\w+)\s*(\S*)\s*/, Q2 = /::(place)/g, ha2 = /:(read-only)/g, G2 = /[svh]\w+-[tblr]{2}/, da2 = /\(\s*(.*)\s*\)/g, oa2 = /([\s\S]*?);/g, ba = /-self|flex-/g, na = /[^]*?(:[rp][el]a[\w-]+)[^]*/, la2 = /stretch|:\s*\w+\-(?:conte|avail)/, ja2 = /([^-])(image-set\()/, z2 = 1, D2 = 1, E2 = 0, w2 = 1, O2 = [], S2 = [], A2 = 0, R2 = null, Y2 = 0, V2 = "";
  B2.use = T2;
  B2.set = U2;
  void 0 !== W2 && U2(W2);
  return B2;
}
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
function memoize(fn) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0)
      cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var reactIs$2 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$2 = "function" === typeof Symbol && Symbol.for, c = b$2 ? Symbol.for("react.element") : 60103, d$1 = b$2 ? Symbol.for("react.portal") : 60106, e = b$2 ? Symbol.for("react.fragment") : 60107, f$1 = b$2 ? Symbol.for("react.strict_mode") : 60108, g$2 = b$2 ? Symbol.for("react.profiler") : 60114, h$1 = b$2 ? Symbol.for("react.provider") : 60109, k$2 = b$2 ? Symbol.for("react.context") : 60110, l = b$2 ? Symbol.for("react.async_mode") : 60111, m$3 = b$2 ? Symbol.for("react.concurrent_mode") : 60111, n = b$2 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$2 ? Symbol.for("react.suspense") : 60113, q$2 = b$2 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$2 ? Symbol.for("react.memo") : 60115, t = b$2 ? Symbol.for("react.lazy") : 60116, v$2 = b$2 ? Symbol.for("react.block") : 60121, w$1 = b$2 ? Symbol.for("react.fundamental") : 60117, x$1 = b$2 ? Symbol.for("react.responder") : 60118, y$2 = b$2 ? Symbol.for("react.scope") : 60119;
function z$2(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c:
        switch (a2 = a2.type, a2) {
          case l:
          case m$3:
          case e:
          case g$2:
          case f$1:
          case p$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case n:
              case t:
              case r$1:
              case h$1:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A$1(a2) {
  return z$2(a2) === m$3;
}
var AsyncMode = reactIs_production_min$1.AsyncMode = l;
var ConcurrentMode = reactIs_production_min$1.ConcurrentMode = m$3;
var ContextConsumer = reactIs_production_min$1.ContextConsumer = k$2;
var ContextProvider = reactIs_production_min$1.ContextProvider = h$1;
var Element$1 = reactIs_production_min$1.Element = c;
var ForwardRef = reactIs_production_min$1.ForwardRef = n;
var Fragment = reactIs_production_min$1.Fragment = e;
var Lazy = reactIs_production_min$1.Lazy = t;
var Memo = reactIs_production_min$1.Memo = r$1;
var Portal$1 = reactIs_production_min$1.Portal = d$1;
var Profiler = reactIs_production_min$1.Profiler = g$2;
var StrictMode = reactIs_production_min$1.StrictMode = f$1;
var Suspense = reactIs_production_min$1.Suspense = p$1;
var isAsyncMode = reactIs_production_min$1.isAsyncMode = function(a2) {
  return A$1(a2) || z$2(a2) === l;
};
var isConcurrentMode = reactIs_production_min$1.isConcurrentMode = A$1;
var isContextConsumer = reactIs_production_min$1.isContextConsumer = function(a2) {
  return z$2(a2) === k$2;
};
var isContextProvider = reactIs_production_min$1.isContextProvider = function(a2) {
  return z$2(a2) === h$1;
};
var isElement = reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c;
};
var isForwardRef = reactIs_production_min$1.isForwardRef = function(a2) {
  return z$2(a2) === n;
};
var isFragment = reactIs_production_min$1.isFragment = function(a2) {
  return z$2(a2) === e;
};
var isLazy = reactIs_production_min$1.isLazy = function(a2) {
  return z$2(a2) === t;
};
var isMemo = reactIs_production_min$1.isMemo = function(a2) {
  return z$2(a2) === r$1;
};
var isPortal = reactIs_production_min$1.isPortal = function(a2) {
  return z$2(a2) === d$1;
};
var isProfiler = reactIs_production_min$1.isProfiler = function(a2) {
  return z$2(a2) === g$2;
};
var isStrictMode = reactIs_production_min$1.isStrictMode = function(a2) {
  return z$2(a2) === f$1;
};
var isSuspense = reactIs_production_min$1.isSuspense = function(a2) {
  return z$2(a2) === p$1;
};
var isValidElementType = reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e || a2 === m$3 || a2 === g$2 || a2 === f$1 || a2 === p$1 || a2 === q$2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t || a2.$$typeof === r$1 || a2.$$typeof === h$1 || a2.$$typeof === k$2 || a2.$$typeof === n || a2.$$typeof === w$1 || a2.$$typeof === x$1 || a2.$$typeof === y$2 || a2.$$typeof === v$2);
};
var typeOf = reactIs_production_min$1.typeOf = z$2;
const reactIs_production_min = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  AsyncMode,
  ConcurrentMode,
  ContextConsumer,
  ContextProvider,
  Element: Element$1,
  ForwardRef,
  Fragment,
  Lazy,
  Memo,
  Portal: Portal$1,
  Profiler,
  StrictMode,
  Suspense,
  default: reactIs_production_min$1,
  isAsyncMode,
  isConcurrentMode,
  isContextConsumer,
  isContextProvider,
  isElement,
  isForwardRef,
  isFragment,
  isLazy,
  isMemo,
  isPortal,
  isProfiler,
  isStrictMode,
  isSuspense,
  isValidElementType,
  typeOf
}, [reactIs_production_min$1]);
const require$$0$q = /* @__PURE__ */ getAugmentedNamespace(reactIs_production_min);
{
  reactIs$2.exports = require$$0$q;
}
var reactIsExports = reactIs$2.exports;
const index$d = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports);
const reactIs$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$d
}, [reactIsExports]);
const require$$0$p = /* @__PURE__ */ getAugmentedNamespace(reactIs$1);
var reactIs = require$$0$p;
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
function getStatics(component) {
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty$1 = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }
    var keys2 = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
    }
    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);
    for (var i2 = 0; i2 < keys2.length; ++i2) {
      var key = keys2[i2];
      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty$1(targetComponent, key, descriptor);
        } catch (e2) {
        }
      }
    }
  }
  return targetComponent;
}
var hoistNonReactStatics_cjs = hoistNonReactStatics;
const m$2 = /* @__PURE__ */ getDefaultExportFromCjs(hoistNonReactStatics_cjs);
function y$1() {
  return (y$1 = Object.assign || function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }).apply(this, arguments);
}
var v$1 = function(e2, t2) {
  for (var n2 = [e2[0]], r2 = 0, o = t2.length; r2 < o; r2 += 1)
    n2.push(t2[r2], e2[r2 + 1]);
  return n2;
}, g$1 = function(t2) {
  return null !== t2 && "object" == typeof t2 && "[object Object]" === (t2.toString ? t2.toString() : Object.prototype.toString.call(t2)) && !reactIsExports$1.typeOf(t2);
}, S$1 = Object.freeze([]), w = Object.freeze({});
function E$1(e2) {
  return "function" == typeof e2;
}
function b$1(e2) {
  return e2.displayName || e2.name || "Component";
}
function _$1(e2) {
  return e2 && "string" == typeof e2.styledComponentId;
}
var N$1 = "undefined" != typeof process && void 0 !== process.env && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled", C$1 = "undefined" != typeof window && "HTMLElement" in window, I$1 = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && (void 0 !== {}.REACT_APP_SC_DISABLE_SPEEDY && "" !== {}.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== {}.REACT_APP_SC_DISABLE_SPEEDY && {}.REACT_APP_SC_DISABLE_SPEEDY : void 0 !== {}.SC_DISABLE_SPEEDY && "" !== {}.SC_DISABLE_SPEEDY ? "false" !== {}.SC_DISABLE_SPEEDY && {}.SC_DISABLE_SPEEDY : false));
function D$1(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  throw new Error("An error occurred. See https://git.io/JUIaE#" + e2 + " for more information." + (n2.length > 0 ? " Args: " + n2.join(", ") : ""));
}
var j = function() {
  function e2(e3) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
  }
  var t2 = e2.prototype;
  return t2.indexOfGroup = function(e3) {
    for (var t3 = 0, n2 = 0; n2 < e3; n2++)
      t3 += this.groupSizes[n2];
    return t3;
  }, t2.insertRules = function(e3, t3) {
    if (e3 >= this.groupSizes.length) {
      for (var n2 = this.groupSizes, r2 = n2.length, o = r2; e3 >= o; )
        (o <<= 1) < 0 && D$1(16, "" + e3);
      this.groupSizes = new Uint32Array(o), this.groupSizes.set(n2), this.length = o;
      for (var s = r2; s < o; s++)
        this.groupSizes[s] = 0;
    }
    for (var i2 = this.indexOfGroup(e3 + 1), a2 = 0, c2 = t3.length; a2 < c2; a2++)
      this.tag.insertRule(i2, t3[a2]) && (this.groupSizes[e3]++, i2++);
  }, t2.clearGroup = function(e3) {
    if (e3 < this.length) {
      var t3 = this.groupSizes[e3], n2 = this.indexOfGroup(e3), r2 = n2 + t3;
      this.groupSizes[e3] = 0;
      for (var o = n2; o < r2; o++)
        this.tag.deleteRule(n2);
    }
  }, t2.getGroup = function(e3) {
    var t3 = "";
    if (e3 >= this.length || 0 === this.groupSizes[e3])
      return t3;
    for (var n2 = this.groupSizes[e3], r2 = this.indexOfGroup(e3), o = r2 + n2, s = r2; s < o; s++)
      t3 += this.tag.getRule(s) + "/*!sc*/\n";
    return t3;
  }, e2;
}(), T$1 = /* @__PURE__ */ new Map(), x = /* @__PURE__ */ new Map(), k$1 = 1, V = function(e2) {
  if (T$1.has(e2))
    return T$1.get(e2);
  for (; x.has(k$1); )
    k$1++;
  var t2 = k$1++;
  return T$1.set(e2, t2), x.set(t2, e2), t2;
}, B$1 = function(e2) {
  return x.get(e2);
}, z$1 = function(e2, t2) {
  t2 >= k$1 && (k$1 = t2 + 1), T$1.set(e2, t2), x.set(t2, e2);
}, M$1 = "style[" + N$1 + '][data-styled-version="5.3.11"]', G = new RegExp("^" + N$1 + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'), L$1 = function(e2, t2, n2) {
  for (var r2, o = n2.split(","), s = 0, i2 = o.length; s < i2; s++)
    (r2 = o[s]) && e2.registerName(t2, r2);
}, F$1 = function(e2, t2) {
  for (var n2 = (t2.textContent || "").split("/*!sc*/\n"), r2 = [], o = 0, s = n2.length; o < s; o++) {
    var i2 = n2[o].trim();
    if (i2) {
      var a2 = i2.match(G);
      if (a2) {
        var c2 = 0 | parseInt(a2[1], 10), u2 = a2[2];
        0 !== c2 && (z$1(u2, c2), L$1(e2, u2, a2[3]), e2.getTag().insertRules(c2, r2)), r2.length = 0;
      } else
        r2.push(i2);
    }
  }
}, Y = function() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}, q$1 = function(e2) {
  var t2 = document.head, n2 = e2 || t2, r2 = document.createElement("style"), o = function(e3) {
    for (var t3 = e3.childNodes, n3 = t3.length; n3 >= 0; n3--) {
      var r3 = t3[n3];
      if (r3 && 1 === r3.nodeType && r3.hasAttribute(N$1))
        return r3;
    }
  }(n2), s = void 0 !== o ? o.nextSibling : null;
  r2.setAttribute(N$1, "active"), r2.setAttribute("data-styled-version", "5.3.11");
  var i2 = Y();
  return i2 && r2.setAttribute("nonce", i2), n2.insertBefore(r2, s), r2;
}, H$1 = function() {
  function e2(e3) {
    var t3 = this.element = q$1(e3);
    t3.appendChild(document.createTextNode("")), this.sheet = function(e4) {
      if (e4.sheet)
        return e4.sheet;
      for (var t4 = document.styleSheets, n2 = 0, r2 = t4.length; n2 < r2; n2++) {
        var o = t4[n2];
        if (o.ownerNode === e4)
          return o;
      }
      D$1(17);
    }(t3), this.length = 0;
  }
  var t2 = e2.prototype;
  return t2.insertRule = function(e3, t3) {
    try {
      return this.sheet.insertRule(t3, e3), this.length++, true;
    } catch (e4) {
      return false;
    }
  }, t2.deleteRule = function(e3) {
    this.sheet.deleteRule(e3), this.length--;
  }, t2.getRule = function(e3) {
    var t3 = this.sheet.cssRules[e3];
    return void 0 !== t3 && "string" == typeof t3.cssText ? t3.cssText : "";
  }, e2;
}(), $ = function() {
  function e2(e3) {
    var t3 = this.element = q$1(e3);
    this.nodes = t3.childNodes, this.length = 0;
  }
  var t2 = e2.prototype;
  return t2.insertRule = function(e3, t3) {
    if (e3 <= this.length && e3 >= 0) {
      var n2 = document.createTextNode(t3), r2 = this.nodes[e3];
      return this.element.insertBefore(n2, r2 || null), this.length++, true;
    }
    return false;
  }, t2.deleteRule = function(e3) {
    this.element.removeChild(this.nodes[e3]), this.length--;
  }, t2.getRule = function(e3) {
    return e3 < this.length ? this.nodes[e3].textContent : "";
  }, e2;
}(), W = function() {
  function e2(e3) {
    this.rules = [], this.length = 0;
  }
  var t2 = e2.prototype;
  return t2.insertRule = function(e3, t3) {
    return e3 <= this.length && (this.rules.splice(e3, 0, t3), this.length++, true);
  }, t2.deleteRule = function(e3) {
    this.rules.splice(e3, 1), this.length--;
  }, t2.getRule = function(e3) {
    return e3 < this.length ? this.rules[e3] : "";
  }, e2;
}(), U = C$1, J = { isServer: !C$1, useCSSOMInjection: !I$1 }, X = function() {
  function e2(e3, t3, n2) {
    void 0 === e3 && (e3 = w), void 0 === t3 && (t3 = {}), this.options = y$1({}, J, {}, e3), this.gs = t3, this.names = new Map(n2), this.server = !!e3.isServer, !this.server && C$1 && U && (U = false, function(e4) {
      for (var t4 = document.querySelectorAll(M$1), n3 = 0, r2 = t4.length; n3 < r2; n3++) {
        var o = t4[n3];
        o && "active" !== o.getAttribute(N$1) && (F$1(e4, o), o.parentNode && o.parentNode.removeChild(o));
      }
    }(this));
  }
  e2.registerId = function(e3) {
    return V(e3);
  };
  var t2 = e2.prototype;
  return t2.reconstructWithOptions = function(t3, n2) {
    return void 0 === n2 && (n2 = true), new e2(y$1({}, this.options, {}, t3), this.gs, n2 && this.names || void 0);
  }, t2.allocateGSInstance = function(e3) {
    return this.gs[e3] = (this.gs[e3] || 0) + 1;
  }, t2.getTag = function() {
    return this.tag || (this.tag = (n2 = (t3 = this.options).isServer, r2 = t3.useCSSOMInjection, o = t3.target, e3 = n2 ? new W(o) : r2 ? new H$1(o) : new $(o), new j(e3)));
    var e3, t3, n2, r2, o;
  }, t2.hasNameForId = function(e3, t3) {
    return this.names.has(e3) && this.names.get(e3).has(t3);
  }, t2.registerName = function(e3, t3) {
    if (V(e3), this.names.has(e3))
      this.names.get(e3).add(t3);
    else {
      var n2 = /* @__PURE__ */ new Set();
      n2.add(t3), this.names.set(e3, n2);
    }
  }, t2.insertRules = function(e3, t3, n2) {
    this.registerName(e3, t3), this.getTag().insertRules(V(e3), n2);
  }, t2.clearNames = function(e3) {
    this.names.has(e3) && this.names.get(e3).clear();
  }, t2.clearRules = function(e3) {
    this.getTag().clearGroup(V(e3)), this.clearNames(e3);
  }, t2.clearTag = function() {
    this.tag = void 0;
  }, t2.toString = function() {
    return function(e3) {
      for (var t3 = e3.getTag(), n2 = t3.length, r2 = "", o = 0; o < n2; o++) {
        var s = B$1(o);
        if (void 0 !== s) {
          var i2 = e3.names.get(s), a2 = t3.getGroup(o);
          if (i2 && a2 && i2.size) {
            var c2 = N$1 + ".g" + o + '[id="' + s + '"]', u2 = "";
            void 0 !== i2 && i2.forEach(function(e4) {
              e4.length > 0 && (u2 += e4 + ",");
            }), r2 += "" + a2 + c2 + '{content:"' + u2 + '"}/*!sc*/\n';
          }
        }
      }
      return r2;
    }(this);
  }, e2;
}(), Z = /(a)(d)/gi, K = function(e2) {
  return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
};
function Q$1(e2) {
  var t2, n2 = "";
  for (t2 = Math.abs(e2); t2 > 52; t2 = t2 / 52 | 0)
    n2 = K(t2 % 52) + n2;
  return (K(t2 % 52) + n2).replace(Z, "$1-$2");
}
var ee = function(e2, t2) {
  for (var n2 = t2.length; n2; )
    e2 = 33 * e2 ^ t2.charCodeAt(--n2);
  return e2;
}, te = function(e2) {
  return ee(5381, e2);
};
function ne(e2) {
  for (var t2 = 0; t2 < e2.length; t2 += 1) {
    var n2 = e2[t2];
    if (E$1(n2) && !_$1(n2))
      return false;
  }
  return true;
}
var re = te("5.3.11"), oe = function() {
  function e2(e3, t2, n2) {
    this.rules = e3, this.staticRulesId = "", this.isStatic = (void 0 === n2 || n2.isStatic) && ne(e3), this.componentId = t2, this.baseHash = ee(re, t2), this.baseStyle = n2, X.registerId(t2);
  }
  return e2.prototype.generateAndInjectStyles = function(e3, t2, n2) {
    var r2 = this.componentId, o = [];
    if (this.baseStyle && o.push(this.baseStyle.generateAndInjectStyles(e3, t2, n2)), this.isStatic && !n2.hash)
      if (this.staticRulesId && t2.hasNameForId(r2, this.staticRulesId))
        o.push(this.staticRulesId);
      else {
        var s = _e(this.rules, e3, t2, n2).join(""), i2 = Q$1(ee(this.baseHash, s) >>> 0);
        if (!t2.hasNameForId(r2, i2)) {
          var a2 = n2(s, "." + i2, void 0, r2);
          t2.insertRules(r2, i2, a2);
        }
        o.push(i2), this.staticRulesId = i2;
      }
    else {
      for (var c2 = this.rules.length, u2 = ee(this.baseHash, n2.hash), l2 = "", d2 = 0; d2 < c2; d2++) {
        var h2 = this.rules[d2];
        if ("string" == typeof h2)
          l2 += h2;
        else if (h2) {
          var p2 = _e(h2, e3, t2, n2), f2 = Array.isArray(p2) ? p2.join("") : p2;
          u2 = ee(u2, f2 + d2), l2 += f2;
        }
      }
      if (l2) {
        var m2 = Q$1(u2 >>> 0);
        if (!t2.hasNameForId(r2, m2)) {
          var y2 = n2(l2, "." + m2, void 0, r2);
          t2.insertRules(r2, m2, y2);
        }
        o.push(m2);
      }
    }
    return o.join(" ");
  }, e2;
}(), se = /^\s*\/\/.*$/gm, ie = [":", "[", ".", "#"];
function ae(e2) {
  var t2, n2, r2, o, s = void 0 === e2 ? w : e2, i2 = s.options, a2 = void 0 === i2 ? w : i2, c2 = s.plugins, u2 = void 0 === c2 ? S$1 : c2, l2 = new stylis_min(a2), d2 = [], p2 = function(e3) {
    function t3(t4) {
      if (t4)
        try {
          e3(t4 + "}");
        } catch (e4) {
        }
    }
    return function(n3, r3, o2, s2, i3, a3, c3, u3, l3, d3) {
      switch (n3) {
        case 1:
          if (0 === l3 && 64 === r3.charCodeAt(0))
            return e3(r3 + ";"), "";
          break;
        case 2:
          if (0 === u3)
            return r3 + "/*|*/";
          break;
        case 3:
          switch (u3) {
            case 102:
            case 112:
              return e3(o2[0] + r3), "";
            default:
              return r3 + (0 === d3 ? "/*|*/" : "");
          }
        case -2:
          r3.split("/*|*/}").forEach(t3);
      }
    };
  }(function(e3) {
    d2.push(e3);
  }), f2 = function(e3, r3, s2) {
    return 0 === r3 && -1 !== ie.indexOf(s2[n2.length]) || s2.match(o) ? e3 : "." + t2;
  };
  function m2(e3, s2, i3, a3) {
    void 0 === a3 && (a3 = "&");
    var c3 = e3.replace(se, ""), u3 = s2 && i3 ? i3 + " " + s2 + " { " + c3 + " }" : c3;
    return t2 = a3, n2 = s2, r2 = new RegExp("\\" + n2 + "\\b", "g"), o = new RegExp("(\\" + n2 + "\\b){2,}"), l2(i3 || !s2 ? "" : s2, u3);
  }
  return l2.use([].concat(u2, [function(e3, t3, o2) {
    2 === e3 && o2.length && o2[0].lastIndexOf(n2) > 0 && (o2[0] = o2[0].replace(r2, f2));
  }, p2, function(e3) {
    if (-2 === e3) {
      var t3 = d2;
      return d2 = [], t3;
    }
  }])), m2.hash = u2.length ? u2.reduce(function(e3, t3) {
    return t3.name || D$1(15), ee(e3, t3.name);
  }, 5381).toString() : "", m2;
}
var ce = React$1.createContext();
ce.Consumer;
var le = React$1.createContext(), de = (le.Consumer, new X()), he = ae();
function pe() {
  return reactExports.useContext(ce) || de;
}
function fe() {
  return reactExports.useContext(le) || he;
}
var ye = function() {
  function e2(e3, t2) {
    var n2 = this;
    this.inject = function(e4, t3) {
      void 0 === t3 && (t3 = he);
      var r2 = n2.name + t3.hash;
      e4.hasNameForId(n2.id, r2) || e4.insertRules(n2.id, r2, t3(n2.rules, r2, "@keyframes"));
    }, this.toString = function() {
      return D$1(12, String(n2.name));
    }, this.name = e3, this.id = "sc-keyframes-" + e3, this.rules = t2;
  }
  return e2.prototype.getName = function(e3) {
    return void 0 === e3 && (e3 = he), this.name + e3.hash;
  }, e2;
}(), ve = /([A-Z])/, ge = /([A-Z])/g, Se = /^ms-/, we = function(e2) {
  return "-" + e2.toLowerCase();
};
function Ee(e2) {
  return ve.test(e2) ? e2.replace(ge, we).replace(Se, "-ms-") : e2;
}
var be = function(e2) {
  return null == e2 || false === e2 || "" === e2;
};
function _e(e2, n2, r2, o) {
  if (Array.isArray(e2)) {
    for (var s, i2 = [], a2 = 0, c2 = e2.length; a2 < c2; a2 += 1)
      "" !== (s = _e(e2[a2], n2, r2, o)) && (Array.isArray(s) ? i2.push.apply(i2, s) : i2.push(s));
    return i2;
  }
  if (be(e2))
    return "";
  if (_$1(e2))
    return "." + e2.styledComponentId;
  if (E$1(e2)) {
    if ("function" != typeof (l2 = e2) || l2.prototype && l2.prototype.isReactComponent || !n2)
      return e2;
    var u2 = e2(n2);
    return _e(u2, n2, r2, o);
  }
  var l2;
  return e2 instanceof ye ? r2 ? (e2.inject(r2, o), e2.getName(o)) : e2 : g$1(e2) ? function e3(t2, n3) {
    var r3, o2, s2 = [];
    for (var i3 in t2)
      t2.hasOwnProperty(i3) && !be(t2[i3]) && (Array.isArray(t2[i3]) && t2[i3].isCss || E$1(t2[i3]) ? s2.push(Ee(i3) + ":", t2[i3], ";") : g$1(t2[i3]) ? s2.push.apply(s2, e3(t2[i3], i3)) : s2.push(Ee(i3) + ": " + (r3 = i3, null == (o2 = t2[i3]) || "boolean" == typeof o2 || "" === o2 ? "" : "number" != typeof o2 || 0 === o2 || r3 in unitlessKeys || r3.startsWith("--") ? String(o2).trim() : o2 + "px") + ";"));
    return n3 ? [n3 + " {"].concat(s2, ["}"]) : s2;
  }(e2) : e2.toString();
}
var Ne = function(e2) {
  return Array.isArray(e2) && (e2.isCss = true), e2;
};
function Ae(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  return E$1(e2) || g$1(e2) ? Ne(_e(v$1(S$1, [e2].concat(n2)))) : 0 === n2.length && 1 === e2.length && "string" == typeof e2[0] ? e2 : Ne(_e(v$1(e2, n2)));
}
var Oe = function(e2, t2, n2) {
  return void 0 === n2 && (n2 = w), e2.theme !== n2.theme && e2.theme || t2 || n2.theme;
}, Re = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, De = /(^-|-$)/g;
function je(e2) {
  return e2.replace(Re, "-").replace(De, "");
}
var Te = function(e2) {
  return Q$1(te(e2) >>> 0);
};
function xe(e2) {
  return "string" == typeof e2 && true;
}
var ke = function(e2) {
  return "function" == typeof e2 || "object" == typeof e2 && null !== e2 && !Array.isArray(e2);
}, Ve = function(e2) {
  return "__proto__" !== e2 && "constructor" !== e2 && "prototype" !== e2;
};
function Be(e2, t2, n2) {
  var r2 = e2[n2];
  ke(t2) && ke(r2) ? ze(r2, t2) : e2[n2] = t2;
}
function ze(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  for (var o = 0, s = n2; o < s.length; o++) {
    var i2 = s[o];
    if (ke(i2))
      for (var a2 in i2)
        Ve(a2) && Be(e2, i2[a2], a2);
  }
  return e2;
}
var Me = React$1.createContext();
Me.Consumer;
function Le(e2) {
  var t2 = reactExports.useContext(Me), n2 = reactExports.useMemo(function() {
    return function(e3, t3) {
      if (!e3)
        return D$1(14);
      if (E$1(e3)) {
        var n3 = e3(t3);
        return n3;
      }
      return Array.isArray(e3) || "object" != typeof e3 ? D$1(8) : t3 ? y$1({}, t3, {}, e3) : e3;
    }(e2.theme, t2);
  }, [e2.theme, t2]);
  return e2.children ? React$1.createElement(Me.Provider, { value: n2 }, e2.children) : null;
}
var Fe = {};
function Ye(e2, t2, n2) {
  var o = _$1(e2), i2 = !xe(e2), a2 = t2.attrs, c2 = void 0 === a2 ? S$1 : a2, l2 = t2.componentId, d2 = void 0 === l2 ? function(e3, t3) {
    var n3 = "string" != typeof e3 ? "sc" : je(e3);
    Fe[n3] = (Fe[n3] || 0) + 1;
    var r2 = n3 + "-" + Te("5.3.11" + n3 + Fe[n3]);
    return t3 ? t3 + "-" + r2 : r2;
  }(t2.displayName, t2.parentComponentId) : l2, h2 = t2.displayName, p2 = void 0 === h2 ? function(e3) {
    return xe(e3) ? "styled." + e3 : "Styled(" + b$1(e3) + ")";
  }(e2) : h2, v2 = t2.displayName && t2.componentId ? je(t2.displayName) + "-" + t2.componentId : t2.componentId || d2, g2 = o && e2.attrs ? Array.prototype.concat(e2.attrs, c2).filter(Boolean) : c2, N10 = t2.shouldForwardProp;
  o && e2.shouldForwardProp && (N10 = t2.shouldForwardProp ? function(n3, r2, o2) {
    return e2.shouldForwardProp(n3, r2, o2) && t2.shouldForwardProp(n3, r2, o2);
  } : e2.shouldForwardProp);
  var A2, C2 = new oe(n2, v2, o ? e2.componentStyle : void 0), I2 = C2.isStatic && 0 === c2.length, P2 = function(e3, t3) {
    return function(e4, t4, n3, r2) {
      var o2 = e4.attrs, i3 = e4.componentStyle, a3 = e4.defaultProps, c3 = e4.foldedComponentIds, l3 = e4.shouldForwardProp, d3 = e4.styledComponentId, h3 = e4.target, p3 = function(e5, t5, n4) {
        void 0 === e5 && (e5 = w);
        var r3 = y$1({}, t5, { theme: e5 }), o3 = {};
        return n4.forEach(function(e6) {
          var t6, n5, s, i4 = e6;
          for (t6 in E$1(i4) && (i4 = i4(r3)), i4)
            r3[t6] = o3[t6] = "className" === t6 ? (n5 = o3[t6], s = i4[t6], n5 && s ? n5 + " " + s : n5 || s) : i4[t6];
        }), [r3, o3];
      }(Oe(t4, reactExports.useContext(Me), a3) || w, t4, o2), m2 = p3[0], v3 = p3[1], g3 = function(e5, t5, n4, r3) {
        var o3 = pe(), s = fe(), i4 = t5 ? e5.generateAndInjectStyles(w, o3, s) : e5.generateAndInjectStyles(n4, o3, s);
        return i4;
      }(i3, r2, m2), S2 = n3, b2 = v3.$as || t4.$as || v3.as || t4.as || h3, _2 = xe(b2), N11 = v3 !== t4 ? y$1({}, t4, {}, v3) : t4, A3 = {};
      for (var C3 in N11)
        "$" !== C3[0] && "as" !== C3 && ("forwardedAs" === C3 ? A3.as = N11[C3] : (l3 ? l3(C3, isPropValid, b2) : !_2 || isPropValid(C3)) && (A3[C3] = N11[C3]));
      return t4.style && v3.style !== t4.style && (A3.style = y$1({}, t4.style, {}, v3.style)), A3.className = Array.prototype.concat(c3, d3, g3 !== d3 ? g3 : null, t4.className, v3.className).filter(Boolean).join(" "), A3.ref = S2, reactExports.createElement(b2, A3);
    }(A2, e3, t3, I2);
  };
  return P2.displayName = p2, (A2 = React$1.forwardRef(P2)).attrs = g2, A2.componentStyle = C2, A2.displayName = p2, A2.shouldForwardProp = N10, A2.foldedComponentIds = o ? Array.prototype.concat(e2.foldedComponentIds, e2.styledComponentId) : S$1, A2.styledComponentId = v2, A2.target = o ? e2.target : e2, A2.withComponent = function(e3) {
    var r2 = t2.componentId, o2 = function(e4, t3) {
      if (null == e4)
        return {};
      var n3, r3, o3 = {}, s2 = Object.keys(e4);
      for (r3 = 0; r3 < s2.length; r3++)
        n3 = s2[r3], t3.indexOf(n3) >= 0 || (o3[n3] = e4[n3]);
      return o3;
    }(t2, ["componentId"]), s = r2 && r2 + "-" + (xe(e3) ? e3 : je(b$1(e3)));
    return Ye(e3, y$1({}, o2, { attrs: g2, componentId: s }), n2);
  }, Object.defineProperty(A2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(t3) {
    this._foldedDefaultProps = o ? ze({}, e2.defaultProps, t3) : t3;
  } }), Object.defineProperty(A2, "toString", { value: function() {
    return "." + A2.styledComponentId;
  } }), i2 && m$2(A2, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), A2;
}
var qe = function(e2) {
  return function e3(t2, r2, o) {
    if (void 0 === o && (o = w), !reactIsExports$1.isValidElementType(r2))
      return D$1(1, String(r2));
    var s = function() {
      return t2(r2, o, Ae.apply(void 0, arguments));
    };
    return s.withConfig = function(n2) {
      return e3(t2, r2, y$1({}, o, {}, n2));
    }, s.attrs = function(n2) {
      return e3(t2, r2, y$1({}, o, { attrs: Array.prototype.concat(o.attrs, n2).filter(Boolean) }));
    }, s;
  }(Ye, e2);
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e2) {
  qe[e2] = qe(e2);
});
function We(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  var o = Ae.apply(void 0, [e2].concat(n2)).join(""), s = Te(o);
  return new ye(s, o);
}
const styled$1 = qe;
function debounce(func, wait2, immediate) {
  var timeout, args, context, timestamp, result;
  if (null == wait2)
    wait2 = 100;
  function later() {
    var last2 = Date.now() - timestamp;
    if (last2 < wait2 && last2 >= 0) {
      timeout = setTimeout(later, wait2 - last2);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  }
  var debounced = function() {
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout)
      timeout = setTimeout(later, wait2);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }
    return result;
  };
  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      context = args = null;
      clearTimeout(timeout);
      timeout = null;
    }
  };
  return debounced;
}
debounce.debounce = debounce;
var debounce_1 = debounce;
const createDebounce = /* @__PURE__ */ getDefaultExportFromCjs(debounce_1);
function useMeasure(_temp) {
  let {
    debounce: debounce2,
    scroll,
    polyfill,
    offsetSize
  } = _temp === void 0 ? {
    debounce: 0,
    scroll: false,
    offsetSize: false
  } : _temp;
  const ResizeObserver2 = polyfill || (typeof window === "undefined" ? class ResizeObserver {
  } : window.ResizeObserver);
  if (!ResizeObserver2) {
    throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  }
  const [bounds, set] = reactExports.useState({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  });
  const state = reactExports.useRef({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: bounds
  });
  const scrollDebounce = debounce2 ? typeof debounce2 === "number" ? debounce2 : debounce2.scroll : null;
  const resizeDebounce = debounce2 ? typeof debounce2 === "number" ? debounce2 : debounce2.resize : null;
  const mounted = reactExports.useRef(false);
  reactExports.useEffect(() => {
    mounted.current = true;
    return () => void (mounted.current = false);
  });
  const [forceRefresh, resizeChange, scrollChange] = reactExports.useMemo(() => {
    const callback = () => {
      if (!state.current.element)
        return;
      const {
        left,
        top,
        width,
        height,
        bottom,
        right,
        x: x2,
        y: y2
      } = state.current.element.getBoundingClientRect();
      const size2 = {
        left,
        top,
        width,
        height,
        bottom,
        right,
        x: x2,
        y: y2
      };
      if (state.current.element instanceof HTMLElement && offsetSize) {
        size2.height = state.current.element.offsetHeight;
        size2.width = state.current.element.offsetWidth;
      }
      Object.freeze(size2);
      if (mounted.current && !areBoundsEqual(state.current.lastBounds, size2))
        set(state.current.lastBounds = size2);
    };
    return [callback, resizeDebounce ? createDebounce(callback, resizeDebounce) : callback, scrollDebounce ? createDebounce(callback, scrollDebounce) : callback];
  }, [set, offsetSize, scrollDebounce, resizeDebounce]);
  function removeListeners() {
    if (state.current.scrollContainers) {
      state.current.scrollContainers.forEach((element) => element.removeEventListener("scroll", scrollChange, true));
      state.current.scrollContainers = null;
    }
    if (state.current.resizeObserver) {
      state.current.resizeObserver.disconnect();
      state.current.resizeObserver = null;
    }
  }
  function addListeners() {
    if (!state.current.element)
      return;
    state.current.resizeObserver = new ResizeObserver2(scrollChange);
    state.current.resizeObserver.observe(state.current.element);
    if (scroll && state.current.scrollContainers) {
      state.current.scrollContainers.forEach((scrollContainer) => scrollContainer.addEventListener("scroll", scrollChange, {
        capture: true,
        passive: true
      }));
    }
  }
  const ref = (node2) => {
    if (!node2 || node2 === state.current.element)
      return;
    removeListeners();
    state.current.element = node2;
    state.current.scrollContainers = findScrollContainers(node2);
    addListeners();
  };
  useOnWindowScroll(scrollChange, Boolean(scroll));
  useOnWindowResize(resizeChange);
  reactExports.useEffect(() => {
    removeListeners();
    addListeners();
  }, [scroll, scrollChange, resizeChange]);
  reactExports.useEffect(() => removeListeners, []);
  return [ref, bounds, forceRefresh];
}
function useOnWindowResize(onWindowResize) {
  reactExports.useEffect(() => {
    const cb2 = onWindowResize;
    window.addEventListener("resize", cb2);
    return () => void window.removeEventListener("resize", cb2);
  }, [onWindowResize]);
}
function useOnWindowScroll(onScroll, enabled) {
  reactExports.useEffect(() => {
    if (enabled) {
      const cb2 = onScroll;
      window.addEventListener("scroll", cb2, {
        capture: true,
        passive: true
      });
      return () => void window.removeEventListener("scroll", cb2, true);
    }
  }, [onScroll, enabled]);
}
function findScrollContainers(element) {
  const result = [];
  if (!element || element === document.body)
    return result;
  const {
    overflow,
    overflowX,
    overflowY
  } = window.getComputedStyle(element);
  if ([overflow, overflowX, overflowY].some((prop) => prop === "auto" || prop === "scroll"))
    result.push(element);
  return [...result, ...findScrollContainers(element.parentElement)];
}
const keys = ["x", "y", "top", "bottom", "left", "right", "width", "height"];
const areBoundsEqual = (a2, b2) => keys.every((key) => a2[key] === b2[key]);
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index2 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index2];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index2 = getIndex(this.__entries__, key);
        if (~index2) {
          this.__entries__[index2][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index2 = getIndex(entries, key);
        if (~index2) {
          entries.splice(index2, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
          var entry = _a2[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay2) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay2);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
      var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a2 = Object.keys(props); _i < _a2.length; _i++) {
    var key = _a2[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles2) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size2, position) {
    var value = styles2["border-" + position + "-width"];
    return size2 + toFloat(value);
  }, 0);
}
function getPaddings(styles2) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles2["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles2 = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles2);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles2.width), height = toFloat(styles2.height);
  if (styles2.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles2, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles2, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a2) {
  var x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y2, width, height) {
  return { x: x2, y: y2, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = (
  /** @class */
  function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a2;
    return (_a2 = observers.get(this))[method].apply(_a2, arguments);
  };
});
var index$c = function() {
  if (typeof global$1$1.ResizeObserver !== "undefined") {
    return global$1$1.ResizeObserver;
  }
  return ResizeObserver;
}();
var browser$1 = {};
var canPromise$1 = function() {
  return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};
const canPromise$2 = /* @__PURE__ */ getDefaultExportFromCjs(canPromise$1);
const canPromise$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: canPromise$2
}, [canPromise$1]);
const require$$0$o = /* @__PURE__ */ getAugmentedNamespace(canPromise$3);
var qrcode$1 = {};
var utils$4 = {};
let toSJISFunction;
const CODEWORDS_COUNT = [
  0,
  // Not used
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
var getSymbolSize$1 = utils$4.getSymbolSize = function getSymbolSize2(version2) {
  if (!version2)
    throw new Error('"version" cannot be null or undefined');
  if (version2 < 1 || version2 > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return version2 * 4 + 17;
};
var getSymbolTotalCodewords = utils$4.getSymbolTotalCodewords = function getSymbolTotalCodewords2(version2) {
  return CODEWORDS_COUNT[version2];
};
var getBCHDigit = utils$4.getBCHDigit = function(data2) {
  let digit = 0;
  while (data2 !== 0) {
    digit++;
    data2 >>>= 1;
  }
  return digit;
};
var setToSJISFunction = utils$4.setToSJISFunction = function setToSJISFunction2(f2) {
  if (typeof f2 !== "function") {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction = f2;
};
var isKanjiModeEnabled = utils$4.isKanjiModeEnabled = function() {
  return typeof toSJISFunction !== "undefined";
};
var toSJIS = utils$4.toSJIS = function toSJIS2(kanji2) {
  return toSJISFunction(kanji2);
};
const utils$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils$4,
  getBCHDigit,
  getSymbolSize: getSymbolSize$1,
  getSymbolTotalCodewords,
  isKanjiModeEnabled,
  setToSJISFunction,
  toSJIS
}, [utils$4]);
const require$$0$n = /* @__PURE__ */ getAugmentedNamespace(utils$3);
var errorCorrectionLevel$2 = {};
(function(exports) {
  exports.L = { bit: 1 };
  exports.M = { bit: 0 };
  exports.Q = { bit: 3 };
  exports.H = { bit: 2 };
  function fromString2(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports.L;
      case "m":
      case "medium":
        return exports.M;
      case "q":
      case "quartile":
        return exports.Q;
      case "h":
      case "high":
        return exports.H;
      default:
        throw new Error("Unknown EC Level: " + string2);
    }
  }
  exports.isValid = function isValid3(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports.from = function from2(value, defaultValue) {
    if (exports.isValid(value)) {
      return value;
    }
    try {
      return fromString2(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(errorCorrectionLevel$2);
const errorCorrectionLevel = /* @__PURE__ */ getDefaultExportFromCjs(errorCorrectionLevel$2);
const errorCorrectionLevel$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: errorCorrectionLevel
}, [errorCorrectionLevel$2]);
const require$$1$9 = /* @__PURE__ */ getAugmentedNamespace(errorCorrectionLevel$1);
function BitBuffer$1() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer$1.prototype = {
  get: function(index2) {
    const bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
  },
  put: function(num, length2) {
    for (let i2 = 0; i2 < length2; i2++) {
      this.putBit((num >>> length2 - i2 - 1 & 1) === 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var bitBuffer = BitBuffer$1;
const bitBuffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(bitBuffer);
const bitBuffer$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: bitBuffer$1
}, [bitBuffer]);
const require$$2$5 = /* @__PURE__ */ getAugmentedNamespace(bitBuffer$2);
function BitMatrix$1(size2) {
  if (!size2 || size2 < 1) {
    throw new Error("BitMatrix size must be defined and greater than 0");
  }
  this.size = size2;
  this.data = new Uint8Array(size2 * size2);
  this.reservedBit = new Uint8Array(size2 * size2);
}
BitMatrix$1.prototype.set = function(row, col, value, reserved) {
  const index2 = row * this.size + col;
  this.data[index2] = value;
  if (reserved)
    this.reservedBit[index2] = true;
};
BitMatrix$1.prototype.get = function(row, col) {
  return this.data[row * this.size + col];
};
BitMatrix$1.prototype.xor = function(row, col, value) {
  this.data[row * this.size + col] ^= value;
};
BitMatrix$1.prototype.isReserved = function(row, col) {
  return this.reservedBit[row * this.size + col];
};
var bitMatrix = BitMatrix$1;
const bitMatrix$1 = /* @__PURE__ */ getDefaultExportFromCjs(bitMatrix);
const bitMatrix$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: bitMatrix$1
}, [bitMatrix]);
const require$$3$4 = /* @__PURE__ */ getAugmentedNamespace(bitMatrix$2);
var alignmentPattern$2 = {};
(function(exports) {
  const getSymbolSize3 = require$$0$n.getSymbolSize;
  exports.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1)
      return [];
    const posCount = Math.floor(version2 / 7) + 2;
    const size2 = getSymbolSize3(version2);
    const intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
    const positions = [size2 - 7];
    for (let i2 = 1; i2 < posCount - 1; i2++) {
      positions[i2] = positions[i2 - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports.getPositions = function getPositions3(version2) {
    const coords = [];
    const pos = exports.getRowColCoords(version2);
    const posLength = pos.length;
    for (let i2 = 0; i2 < posLength; i2++) {
      for (let j2 = 0; j2 < posLength; j2++) {
        if (i2 === 0 && j2 === 0 || // top-left
        i2 === 0 && j2 === posLength - 1 || // bottom-left
        i2 === posLength - 1 && j2 === 0) {
          continue;
        }
        coords.push([pos[i2], pos[j2]]);
      }
    }
    return coords;
  };
})(alignmentPattern$2);
const alignmentPattern = /* @__PURE__ */ getDefaultExportFromCjs(alignmentPattern$2);
const alignmentPattern$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: alignmentPattern
}, [alignmentPattern$2]);
const require$$4$3 = /* @__PURE__ */ getAugmentedNamespace(alignmentPattern$1);
var finderPattern$1 = {};
const getSymbolSize = require$$0$n.getSymbolSize;
const FINDER_PATTERN_SIZE = 7;
var getPositions = finderPattern$1.getPositions = function getPositions2(version2) {
  const size2 = getSymbolSize(version2);
  return [
    // top-left
    [0, 0],
    // top-right
    [size2 - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size2 - FINDER_PATTERN_SIZE]
  ];
};
const finderPattern = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: finderPattern$1,
  getPositions
}, [finderPattern$1]);
const require$$5$3 = /* @__PURE__ */ getAugmentedNamespace(finderPattern);
var maskPattern$2 = {};
(function(exports) {
  exports.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports.isValid = function isValid3(mask) {
    return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
  };
  exports.from = function from2(value) {
    return exports.isValid(value) ? parseInt(value, 10) : void 0;
  };
  exports.getPenaltyN1 = function getPenaltyN1(data2) {
    const size2 = data2.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for (let row = 0; row < size2; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (let col = 0; col < size2; col++) {
        let module2 = data2.get(row, col);
        if (module2 === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module2;
          sameCountCol = 1;
        }
        module2 = data2.get(col, row);
        if (module2 === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module2;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5)
        points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5)
        points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports.getPenaltyN2 = function getPenaltyN2(data2) {
    const size2 = data2.size;
    let points = 0;
    for (let row = 0; row < size2 - 1; row++) {
      for (let col = 0; col < size2 - 1; col++) {
        const last2 = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
        if (last2 === 4 || last2 === 0)
          points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports.getPenaltyN3 = function getPenaltyN3(data2) {
    const size2 = data2.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for (let row = 0; row < size2; row++) {
      bitsCol = bitsRow = 0;
      for (let col = 0; col < size2; col++) {
        bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
          points++;
        bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
          points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports.getPenaltyN4 = function getPenaltyN4(data2) {
    let darkCount = 0;
    const modulesCount = data2.data.length;
    for (let i2 = 0; i2 < modulesCount; i2++)
      darkCount += data2.data[i2];
    const k2 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k2 * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern2, i2, j2) {
    switch (maskPattern2) {
      case exports.Patterns.PATTERN000:
        return (i2 + j2) % 2 === 0;
      case exports.Patterns.PATTERN001:
        return i2 % 2 === 0;
      case exports.Patterns.PATTERN010:
        return j2 % 3 === 0;
      case exports.Patterns.PATTERN011:
        return (i2 + j2) % 3 === 0;
      case exports.Patterns.PATTERN100:
        return (Math.floor(i2 / 2) + Math.floor(j2 / 3)) % 2 === 0;
      case exports.Patterns.PATTERN101:
        return i2 * j2 % 2 + i2 * j2 % 3 === 0;
      case exports.Patterns.PATTERN110:
        return (i2 * j2 % 2 + i2 * j2 % 3) % 2 === 0;
      case exports.Patterns.PATTERN111:
        return (i2 * j2 % 3 + (i2 + j2) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  }
  exports.applyMask = function applyMask(pattern, data2) {
    const size2 = data2.size;
    for (let col = 0; col < size2; col++) {
      for (let row = 0; row < size2; row++) {
        if (data2.isReserved(row, col))
          continue;
        data2.xor(row, col, getMaskAt(pattern, row, col));
      }
    }
  };
  exports.getBestMask = function getBestMask(data2, setupFormatFunc) {
    const numPatterns = Object.keys(exports.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for (let p2 = 0; p2 < numPatterns; p2++) {
      setupFormatFunc(p2);
      exports.applyMask(p2, data2);
      const penalty = exports.getPenaltyN1(data2) + exports.getPenaltyN2(data2) + exports.getPenaltyN3(data2) + exports.getPenaltyN4(data2);
      exports.applyMask(p2, data2);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p2;
      }
    }
    return bestPattern;
  };
})(maskPattern$2);
const maskPattern = /* @__PURE__ */ getDefaultExportFromCjs(maskPattern$2);
const maskPattern$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: maskPattern
}, [maskPattern$2]);
const require$$6$2 = /* @__PURE__ */ getAugmentedNamespace(maskPattern$1);
var errorCorrectionCode$1 = {};
const ECLevel$1 = require$$1$9;
const EC_BLOCKS_TABLE = [
  // L  M  Q  H
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
];
const EC_CODEWORDS_TABLE = [
  // L  M  Q  H
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
var getBlocksCount = errorCorrectionCode$1.getBlocksCount = function getBlocksCount2(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var getTotalCodewordsCount = errorCorrectionCode$1.getTotalCodewordsCount = function getTotalCodewordsCount2(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
const errorCorrectionCode = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: errorCorrectionCode$1,
  getBlocksCount,
  getTotalCodewordsCount
}, [errorCorrectionCode$1]);
const require$$7$1 = /* @__PURE__ */ getAugmentedNamespace(errorCorrectionCode);
var polynomial$2 = {};
var galoisField$1 = {};
const EXP_TABLE = new Uint8Array(512);
const LOG_TABLE = new Uint8Array(256);
(function initTables() {
  let x2 = 1;
  for (let i2 = 0; i2 < 255; i2++) {
    EXP_TABLE[i2] = x2;
    LOG_TABLE[x2] = i2;
    x2 <<= 1;
    if (x2 & 256) {
      x2 ^= 285;
    }
  }
  for (let i2 = 255; i2 < 512; i2++) {
    EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
  }
})();
var log = galoisField$1.log = function log2(n2) {
  if (n2 < 1)
    throw new Error("log(" + n2 + ")");
  return LOG_TABLE[n2];
};
var exp = galoisField$1.exp = function exp2(n2) {
  return EXP_TABLE[n2];
};
var mul = galoisField$1.mul = function mul2(x2, y2) {
  if (x2 === 0 || y2 === 0)
    return 0;
  return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
};
const galoisField = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: galoisField$1,
  exp,
  log,
  mul
}, [galoisField$1]);
const require$$0$m = /* @__PURE__ */ getAugmentedNamespace(galoisField);
(function(exports) {
  const GF = require$$0$m;
  exports.mul = function mul3(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1);
    for (let i2 = 0; i2 < p1.length; i2++) {
      for (let j2 = 0; j2 < p2.length; j2++) {
        coeff[i2 + j2] ^= GF.mul(p1[i2], p2[j2]);
      }
    }
    return coeff;
  };
  exports.mod = function mod2(divident, divisor) {
    let result = new Uint8Array(divident);
    while (result.length - divisor.length >= 0) {
      const coeff = result[0];
      for (let i2 = 0; i2 < divisor.length; i2++) {
        result[i2] ^= GF.mul(divisor[i2], coeff);
      }
      let offset = 0;
      while (offset < result.length && result[offset] === 0)
        offset++;
      result = result.slice(offset);
    }
    return result;
  };
  exports.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1]);
    for (let i2 = 0; i2 < degree; i2++) {
      poly = exports.mul(poly, new Uint8Array([1, GF.exp(i2)]));
    }
    return poly;
  };
})(polynomial$2);
const polynomial = /* @__PURE__ */ getDefaultExportFromCjs(polynomial$2);
const polynomial$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: polynomial
}, [polynomial$2]);
const require$$0$l = /* @__PURE__ */ getAugmentedNamespace(polynomial$1);
const Polynomial = require$$0$l;
function ReedSolomonEncoder$1(degree) {
  this.genPoly = void 0;
  this.degree = degree;
  if (this.degree)
    this.initialize(this.degree);
}
ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$1.prototype.encode = function encode2(data2) {
  if (!this.genPoly) {
    throw new Error("Encoder not initialized");
  }
  const paddedData = new Uint8Array(data2.length + this.degree);
  paddedData.set(data2);
  const remainder = Polynomial.mod(paddedData, this.genPoly);
  const start = this.degree - remainder.length;
  if (start > 0) {
    const buff = new Uint8Array(this.degree);
    buff.set(remainder, start);
    return buff;
  }
  return remainder;
};
var reedSolomonEncoder = ReedSolomonEncoder$1;
const reedSolomonEncoder$1 = /* @__PURE__ */ getDefaultExportFromCjs(reedSolomonEncoder);
const reedSolomonEncoder$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: reedSolomonEncoder$1
}, [reedSolomonEncoder]);
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(reedSolomonEncoder$2);
var version$2 = {};
var mode$3 = {};
var versionCheck$1 = {};
var isValid = versionCheck$1.isValid = function isValid2(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40;
};
const versionCheck = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: versionCheck$1,
  isValid
}, [versionCheck$1]);
const require$$4$2 = /* @__PURE__ */ getAugmentedNamespace(versionCheck);
var regex$1 = {};
const numeric = "[0-9]+";
const alphanumeric = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
var KANJI = regex$1.KANJI = new RegExp(kanji, "g");
var BYTE_KANJI = regex$1.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
var BYTE = regex$1.BYTE = new RegExp(byte, "g");
var NUMERIC = regex$1.NUMERIC = new RegExp(numeric, "g");
var ALPHANUMERIC = regex$1.ALPHANUMERIC = new RegExp(alphanumeric, "g");
const TEST_KANJI = new RegExp("^" + kanji + "$");
const TEST_NUMERIC = new RegExp("^" + numeric + "$");
const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
var testKanji = regex$1.testKanji = function testKanji2(str) {
  return TEST_KANJI.test(str);
};
var testNumeric = regex$1.testNumeric = function testNumeric2(str) {
  return TEST_NUMERIC.test(str);
};
var testAlphanumeric = regex$1.testAlphanumeric = function testAlphanumeric2(str) {
  return TEST_ALPHANUMERIC.test(str);
};
const regex = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  ALPHANUMERIC,
  BYTE,
  BYTE_KANJI,
  KANJI,
  NUMERIC,
  default: regex$1,
  testAlphanumeric,
  testKanji,
  testNumeric
}, [regex$1]);
const require$$5$2 = /* @__PURE__ */ getAugmentedNamespace(regex);
(function(exports) {
  const VersionCheck = require$$4$2;
  const Regex = require$$5$2;
  exports.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports.MIXED = {
    bit: -1
  };
  exports.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
    if (!mode2.ccBits)
      throw new Error("Invalid mode: " + mode2);
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid version: " + version2);
    }
    if (version2 >= 1 && version2 < 10)
      return mode2.ccBits[0];
    else if (version2 < 27)
      return mode2.ccBits[1];
    return mode2.ccBits[2];
  };
  exports.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr))
      return exports.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr))
      return exports.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr))
      return exports.KANJI;
    else
      return exports.BYTE;
  };
  exports.toString = function toString3(mode2) {
    if (mode2 && mode2.id)
      return mode2.id;
    throw new Error("Invalid mode");
  };
  exports.isValid = function isValid3(mode2) {
    return mode2 && mode2.bit && mode2.ccBits;
  };
  function fromString2(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports.NUMERIC;
      case "alphanumeric":
        return exports.ALPHANUMERIC;
      case "kanji":
        return exports.KANJI;
      case "byte":
        return exports.BYTE;
      default:
        throw new Error("Unknown mode: " + string2);
    }
  }
  exports.from = function from2(value, defaultValue) {
    if (exports.isValid(value)) {
      return value;
    }
    try {
      return fromString2(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(mode$3);
const mode$1 = /* @__PURE__ */ getDefaultExportFromCjs(mode$3);
const mode$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: mode$1
}, [mode$3]);
const require$$11 = /* @__PURE__ */ getAugmentedNamespace(mode$2);
(function(exports) {
  const Utils2 = require$$0$n;
  const ECCode2 = require$$7$1;
  const ECLevel2 = require$$1$9;
  const Mode2 = require$$11;
  const VersionCheck = require$$4$2;
  const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  const G18_BCH = Utils2.getBCHDigit(G18);
  function getBestVersionForDataLength(mode2, length2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4;
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    let totalBits = 0;
    segments2.forEach(function(data2) {
      const reservedBits = getReservedBitsCount(data2.mode, version2);
      totalBits += reservedBits + data2.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      const length2 = getTotalBitsFromDataArray(segments2, currentVersion);
      if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  exports.from = function from2(value, defaultValue) {
    if (VersionCheck.isValid(value)) {
      return parseInt(value, 10);
    }
    return defaultValue;
  };
  exports.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode2 === "undefined")
      mode2 = Mode2.BYTE;
    const totalCodewords = Utils2.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode2 === Mode2.MIXED)
      return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode2.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode2.KANJI:
        return Math.floor(usableBits / 13);
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports.getBestVersionForData = function getBestVersionForData(data2, errorCorrectionLevel2) {
    let seg;
    const ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
    if (Array.isArray(data2)) {
      if (data2.length > 1) {
        return getBestVersionForMixedData(data2, ecl);
      }
      if (data2.length === 0) {
        return 1;
      }
      seg = data2[0];
    } else {
      seg = data2;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports.getEncodedBits = function getEncodedBits3(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error("Invalid QR Code version");
    }
    let d2 = version2 << 12;
    while (Utils2.getBCHDigit(d2) - G18_BCH >= 0) {
      d2 ^= G18 << Utils2.getBCHDigit(d2) - G18_BCH;
    }
    return version2 << 12 | d2;
  };
})(version$2);
const version = /* @__PURE__ */ getDefaultExportFromCjs(version$2);
const version$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: version
}, [version$2]);
const require$$9 = /* @__PURE__ */ getAugmentedNamespace(version$1);
var formatInfo$1 = {};
const Utils$3 = require$$0$n;
const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
const G15_BCH = Utils$3.getBCHDigit(G15);
var getEncodedBits = formatInfo$1.getEncodedBits = function getEncodedBits2(errorCorrectionLevel2, mask) {
  const data2 = errorCorrectionLevel2.bit << 3 | mask;
  let d2 = data2 << 10;
  while (Utils$3.getBCHDigit(d2) - G15_BCH >= 0) {
    d2 ^= G15 << Utils$3.getBCHDigit(d2) - G15_BCH;
  }
  return (data2 << 10 | d2) ^ G15_MASK;
};
const formatInfo = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: formatInfo$1,
  getEncodedBits
}, [formatInfo$1]);
const require$$10 = /* @__PURE__ */ getAugmentedNamespace(formatInfo);
var segments$2 = {};
const Mode$4 = require$$11;
function NumericData(data2) {
  this.mode = Mode$4.NUMERIC;
  this.data = data2.toString();
}
NumericData.getBitsLength = function getBitsLength(length2) {
  return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength2() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write2(bitBuffer2) {
  let i2, group, value;
  for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
    group = this.data.substr(i2, 3);
    value = parseInt(group, 10);
    bitBuffer2.put(value, 10);
  }
  const remainingNum = this.data.length - i2;
  if (remainingNum > 0) {
    group = this.data.substr(i2);
    value = parseInt(group, 10);
    bitBuffer2.put(value, remainingNum * 3 + 1);
  }
};
var numericData = NumericData;
const numericData$1 = /* @__PURE__ */ getDefaultExportFromCjs(numericData);
const numericData$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: numericData$1
}, [numericData]);
const require$$1$8 = /* @__PURE__ */ getAugmentedNamespace(numericData$2);
const Mode$3 = require$$11;
const ALPHA_NUM_CHARS = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function AlphanumericData(data2) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data2;
}
AlphanumericData.getBitsLength = function getBitsLength3(length2) {
  return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
};
AlphanumericData.prototype.getLength = function getLength2() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength4() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write3(bitBuffer2) {
  let i2;
  for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
    value += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
    bitBuffer2.put(value, 11);
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
  }
};
var alphanumericData = AlphanumericData;
const alphanumericData$1 = /* @__PURE__ */ getDefaultExportFromCjs(alphanumericData);
const alphanumericData$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: alphanumericData$1
}, [alphanumericData]);
const require$$2$4 = /* @__PURE__ */ getAugmentedNamespace(alphanumericData$2);
var encodeUtf8$1 = function encodeUtf82(input) {
  var result = [];
  var size2 = input.length;
  for (var index2 = 0; index2 < size2; index2++) {
    var point = input.charCodeAt(index2);
    if (point >= 55296 && point <= 56319 && size2 > index2 + 1) {
      var second = input.charCodeAt(index2 + 1);
      if (second >= 56320 && second <= 57343) {
        point = (point - 55296) * 1024 + second - 56320 + 65536;
        index2 += 1;
      }
    }
    if (point < 128) {
      result.push(point);
      continue;
    }
    if (point < 2048) {
      result.push(point >> 6 | 192);
      result.push(point & 63 | 128);
      continue;
    }
    if (point < 55296 || point >= 57344 && point < 65536) {
      result.push(point >> 12 | 224);
      result.push(point >> 6 & 63 | 128);
      result.push(point & 63 | 128);
      continue;
    }
    if (point >= 65536 && point <= 1114111) {
      result.push(point >> 18 | 240);
      result.push(point >> 12 & 63 | 128);
      result.push(point >> 6 & 63 | 128);
      result.push(point & 63 | 128);
      continue;
    }
    result.push(239, 191, 189);
  }
  return new Uint8Array(result).buffer;
};
const index$b = /* @__PURE__ */ getDefaultExportFromCjs(encodeUtf8$1);
const encodeUtf8$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$b
}, [encodeUtf8$1]);
const require$$0$k = /* @__PURE__ */ getAugmentedNamespace(encodeUtf8$2);
const encodeUtf8 = require$$0$k;
const Mode$2 = require$$11;
function ByteData(data2) {
  this.mode = Mode$2.BYTE;
  if (typeof data2 === "string") {
    data2 = encodeUtf8(data2);
  }
  this.data = new Uint8Array(data2);
}
ByteData.getBitsLength = function getBitsLength5(length2) {
  return length2 * 8;
};
ByteData.prototype.getLength = function getLength3() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength6() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(bitBuffer2) {
  for (let i2 = 0, l2 = this.data.length; i2 < l2; i2++) {
    bitBuffer2.put(this.data[i2], 8);
  }
};
var byteData = ByteData;
const byteData$1 = /* @__PURE__ */ getDefaultExportFromCjs(byteData);
const byteData$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: byteData$1
}, [byteData]);
const require$$3$3 = /* @__PURE__ */ getAugmentedNamespace(byteData$2);
const Mode$1 = require$$11;
const Utils$2 = require$$0$n;
function KanjiData(data2) {
  this.mode = Mode$1.KANJI;
  this.data = data2;
}
KanjiData.getBitsLength = function getBitsLength7(length2) {
  return length2 * 13;
};
KanjiData.prototype.getLength = function getLength4() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength8() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(bitBuffer2) {
  let i2;
  for (i2 = 0; i2 < this.data.length; i2++) {
    let value = Utils$2.toSJIS(this.data[i2]);
    if (value >= 33088 && value <= 40956) {
      value -= 33088;
    } else if (value >= 57408 && value <= 60351) {
      value -= 49472;
    } else {
      throw new Error(
        "Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8"
      );
    }
    value = (value >>> 8 & 255) * 192 + (value & 255);
    bitBuffer2.put(value, 13);
  }
};
var kanjiData = KanjiData;
const kanjiData$1 = /* @__PURE__ */ getDefaultExportFromCjs(kanjiData);
const kanjiData$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: kanjiData$1
}, [kanjiData]);
const require$$4$1 = /* @__PURE__ */ getAugmentedNamespace(kanjiData$2);
var dijkstra$2 = { exports: {} };
(function(module2) {
  var dijkstra2 = {
    single_source_shortest_paths: function(graph, s, d2) {
      var predecessors = {};
      var costs = {};
      costs[s] = 0;
      var open = dijkstra2.PriorityQueue.make();
      open.push(s, 0);
      var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open.empty()) {
        closest = open.pop();
        u2 = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u2] || {};
        for (v2 in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v2)) {
            cost_of_e = adjacent_nodes[v2];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v2];
            first_visit = typeof costs[v2] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v2] = cost_of_s_to_u_plus_cost_of_e;
              open.push(v2, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v2] = u2;
            }
          }
        }
      }
      if (typeof d2 !== "undefined" && typeof costs[d2] === "undefined") {
        var msg = ["Could not find a path from ", s, " to ", d2, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d2) {
      var nodes = [];
      var u2 = d2;
      while (u2) {
        nodes.push(u2);
        predecessors[u2];
        u2 = predecessors[u2];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s, d2) {
      var predecessors = dijkstra2.single_source_shortest_paths(graph, s, d2);
      return dijkstra2.extract_shortest_path_from_predecessor_list(
        predecessors,
        d2
      );
    },
    /**
     * A very naive priority queue implementation.
     */
    PriorityQueue: {
      make: function(opts) {
        var T2 = dijkstra2.PriorityQueue, t2 = {}, key;
        opts = opts || {};
        for (key in T2) {
          if (T2.hasOwnProperty(key)) {
            t2[key] = T2[key];
          }
        }
        t2.queue = [];
        t2.sorter = opts.sorter || T2.default_sorter;
        return t2;
      },
      default_sorter: function(a2, b2) {
        return a2.cost - b2.cost;
      },
      /**
       * Add a new item to the queue and ensure the highest priority element
       * is at the front of the queue.
       */
      push: function(value, cost) {
        var item = { value, cost };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      /**
       * Return the highest priority element in the queue.
       */
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  {
    module2.exports = dijkstra2;
  }
})(dijkstra$2);
var dijkstraExports = dijkstra$2.exports;
const dijkstra = /* @__PURE__ */ getDefaultExportFromCjs(dijkstraExports);
const dijkstra$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: dijkstra
}, [dijkstraExports]);
const require$$7 = /* @__PURE__ */ getAugmentedNamespace(dijkstra$1);
(function(exports) {
  const Mode2 = require$$11;
  const NumericData2 = require$$1$8;
  const AlphanumericData2 = require$$2$4;
  const ByteData2 = require$$3$3;
  const KanjiData2 = require$$4$1;
  const Regex = require$$5$2;
  const Utils2 = require$$0$n;
  const dijkstra2 = require$$7;
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex2, mode2, str) {
    const segments2 = [];
    let result;
    while ((result = regex2.exec(str)) !== null) {
      segments2.push({
        data: result[0],
        index: result.index,
        mode: mode2,
        length: result[0].length
      });
    }
    return segments2;
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
      kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
      return s1.index - s2.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length2, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length2);
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length2);
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length2);
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length2);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    const nodes = [];
    for (let i2 = 0; i2 < segs.length; i2++) {
      const seg = segs[i2];
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.KANJI:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
          break;
        case Mode2.BYTE:
          nodes.push([
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version2) {
    const table = {};
    const graph = { start: {} };
    let prevNodeIds = ["start"];
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const nodeGroup = nodes[i2];
      const currentNodeIds = [];
      for (let j2 = 0; j2 < nodeGroup.length; j2++) {
        const node2 = nodeGroup[j2];
        const key = "" + i2 + j2;
        currentNodeIds.push(key);
        table[key] = { node: node2, lastCount: 0 };
        graph[key] = {};
        for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
          const prevNodeId = prevNodeIds[n2];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node2.mode) {
            graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node2.length, node2.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node2.mode);
            table[prevNodeId].lastCount += node2.length;
          } else {
            if (table[prevNodeId])
              table[prevNodeId].lastCount = node2.length;
            graph[prevNodeId][key] = getSegmentBitsLength(node2.length, node2.mode) + 4 + Mode2.getCharCountIndicator(node2.mode, version2);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
      graph[prevNodeIds[n2]].end = 0;
    }
    return { map: graph, table };
  }
  function buildSingleSegment(data2, modesHint) {
    let mode2;
    const bestMode = Mode2.getBestModeForData(data2);
    mode2 = Mode2.from(modesHint, bestMode);
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE;
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data2);
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data2);
      case Mode2.KANJI:
        return new KanjiData2(data2);
      case Mode2.BYTE:
        return new ByteData2(data2);
    }
  }
  exports.fromArray = function fromArray2(array) {
    return array.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports.fromString = function fromString2(data2, version2) {
    const segs = getSegmentsFromString(data2, Utils2.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version2);
    const path = dijkstra2.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for (let i2 = 1; i2 < path.length - 1; i2++) {
      optimizedSegs.push(graph.table[path[i2]].node);
    }
    return exports.fromArray(mergeSegments(optimizedSegs));
  };
  exports.rawSplit = function rawSplit(data2) {
    return exports.fromArray(
      getSegmentsFromString(data2, Utils2.isKanjiModeEnabled())
    );
  };
})(segments$2);
const segments = /* @__PURE__ */ getDefaultExportFromCjs(segments$2);
const segments$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: segments
}, [segments$2]);
const require$$12 = /* @__PURE__ */ getAugmentedNamespace(segments$1);
const Utils$1 = require$$0$n;
const ECLevel = require$$1$9;
const BitBuffer = require$$2$5;
const BitMatrix = require$$3$4;
const AlignmentPattern = require$$4$3;
const FinderPattern = require$$5$3;
const MaskPattern = require$$6$2;
const ECCode = require$$7$1;
const ReedSolomonEncoder = require$$8;
const Version = require$$9;
const FormatInfo = require$$10;
const Mode = require$$11;
const Segments = require$$12;
function setupFinderPattern(matrix, version2) {
  const size2 = matrix.size;
  const pos = FinderPattern.getPositions(version2);
  for (let i2 = 0; i2 < pos.length; i2++) {
    const row = pos[i2][0];
    const col = pos[i2][1];
    for (let r2 = -1; r2 <= 7; r2++) {
      if (row + r2 <= -1 || size2 <= row + r2)
        continue;
      for (let c2 = -1; c2 <= 7; c2++) {
        if (col + c2 <= -1 || size2 <= col + c2)
          continue;
        if (r2 >= 0 && r2 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c2 >= 2 && c2 <= 4) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupTimingPattern(matrix) {
  const size2 = matrix.size;
  for (let r2 = 8; r2 < size2 - 8; r2++) {
    const value = r2 % 2 === 0;
    matrix.set(r2, 6, value, true);
    matrix.set(6, r2, value, true);
  }
}
function setupAlignmentPattern(matrix, version2) {
  const pos = AlignmentPattern.getPositions(version2);
  for (let i2 = 0; i2 < pos.length; i2++) {
    const row = pos[i2][0];
    const col = pos[i2][1];
    for (let r2 = -2; r2 <= 2; r2++) {
      for (let c2 = -2; c2 <= 2; c2++) {
        if (r2 === -2 || r2 === 2 || c2 === -2 || c2 === 2 || r2 === 0 && c2 === 0) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupVersionInfo(matrix, version2) {
  const size2 = matrix.size;
  const bits = Version.getEncodedBits(version2);
  let row, col, mod2;
  for (let i2 = 0; i2 < 18; i2++) {
    row = Math.floor(i2 / 3);
    col = i2 % 3 + size2 - 8 - 3;
    mod2 = (bits >> i2 & 1) === 1;
    matrix.set(row, col, mod2, true);
    matrix.set(col, row, mod2, true);
  }
}
function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
  const size2 = matrix.size;
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
  let i2, mod2;
  for (i2 = 0; i2 < 15; i2++) {
    mod2 = (bits >> i2 & 1) === 1;
    if (i2 < 6) {
      matrix.set(i2, 8, mod2, true);
    } else if (i2 < 8) {
      matrix.set(i2 + 1, 8, mod2, true);
    } else {
      matrix.set(size2 - 15 + i2, 8, mod2, true);
    }
    if (i2 < 8) {
      matrix.set(8, size2 - i2 - 1, mod2, true);
    } else if (i2 < 9) {
      matrix.set(8, 15 - i2 - 1 + 1, mod2, true);
    } else {
      matrix.set(8, 15 - i2 - 1, mod2, true);
    }
  }
  matrix.set(size2 - 8, 8, 1, true);
}
function setupData(matrix, data2) {
  const size2 = matrix.size;
  let inc = -1;
  let row = size2 - 1;
  let bitIndex = 7;
  let byteIndex = 0;
  for (let col = size2 - 1; col > 0; col -= 2) {
    if (col === 6)
      col--;
    while (true) {
      for (let c2 = 0; c2 < 2; c2++) {
        if (!matrix.isReserved(row, col - c2)) {
          let dark = false;
          if (byteIndex < data2.length) {
            dark = (data2[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix.set(row, col - c2, dark);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if (row < 0 || size2 <= row) {
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
}
function createData(version2, errorCorrectionLevel2, segments2) {
  const buffer2 = new BitBuffer();
  segments2.forEach(function(data2) {
    buffer2.put(data2.mode.bit, 4);
    buffer2.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version2));
    data2.write(buffer2);
  });
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(0);
  }
  const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
  for (let i2 = 0; i2 < remainingByte; i2++) {
    buffer2.put(i2 % 2 ? 17 : 236, 8);
  }
  return createCodewords(buffer2, version2, errorCorrectionLevel2);
}
function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewords = totalCodewords - ecTotalCodewords;
  const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  const rs = new ReedSolomonEncoder(ecCount);
  let offset = 0;
  const dcData = new Array(ecTotalBlocks);
  const ecData = new Array(ecTotalBlocks);
  let maxDataSize = 0;
  const buffer2 = new Uint8Array(bitBuffer2.buffer);
  for (let b2 = 0; b2 < ecTotalBlocks; b2++) {
    const dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b2] = buffer2.slice(offset, offset + dataSize);
    ecData[b2] = rs.encode(dcData[b2]);
    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  const data2 = new Uint8Array(totalCodewords);
  let index2 = 0;
  let i2, r2;
  for (i2 = 0; i2 < maxDataSize; i2++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      if (i2 < dcData[r2].length) {
        data2[index2++] = dcData[r2][i2];
      }
    }
  }
  for (i2 = 0; i2 < ecCount; i2++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      data2[index2++] = ecData[r2][i2];
    }
  }
  return data2;
}
function createSymbol(data2, version2, errorCorrectionLevel2, maskPattern2) {
  let segments2;
  if (Array.isArray(data2)) {
    segments2 = Segments.fromArray(data2);
  } else if (typeof data2 === "string") {
    let estimatedVersion = version2;
    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data2);
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
    }
    segments2 = Segments.fromString(data2, estimatedVersion || 40);
  } else {
    throw new Error("Invalid data");
  }
  const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
  if (!bestVersion) {
    throw new Error("The amount of data is too big to be stored in a QR Code");
  }
  if (!version2) {
    version2 = bestVersion;
  } else if (version2 < bestVersion) {
    throw new Error(
      "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
    );
  }
  const dataBits = createData(version2, errorCorrectionLevel2, segments2);
  const moduleCount = Utils$1.getSymbolSize(version2);
  const modules = new BitMatrix(moduleCount);
  setupFinderPattern(modules, version2);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version2);
  setupFormatInfo(modules, errorCorrectionLevel2, 0);
  if (version2 >= 7) {
    setupVersionInfo(modules, version2);
  }
  setupData(modules, dataBits);
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern.getBestMask(
      modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
    );
  }
  MaskPattern.applyMask(maskPattern2, modules);
  setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2
  };
}
var create$6 = qrcode$1.create = function create2(data2, options) {
  if (typeof data2 === "undefined" || data2 === "") {
    throw new Error("No input text");
  }
  let errorCorrectionLevel2 = ECLevel.M;
  let version2;
  let mask;
  if (typeof options !== "undefined") {
    errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version2 = Version.from(options.version);
    mask = MaskPattern.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol(data2, version2, errorCorrectionLevel2, mask);
};
const qrcode = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  create: create$6,
  default: qrcode$1
}, [qrcode$1]);
const require$$1$7 = /* @__PURE__ */ getAugmentedNamespace(qrcode);
var canvas$2 = {};
var utils$2 = {};
(function(exports) {
  function hex2rgba(hex2) {
    if (typeof hex2 === "number") {
      hex2 = hex2.toString();
    }
    if (typeof hex2 !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    let hexCode = hex2.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex2);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
        return [c2, c2];
      }));
    }
    if (hexCode.length === 6)
      hexCode.push("F", "F");
    const hexValue = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue >> 24 & 255,
      g: hexValue >> 16 & 255,
      b: hexValue >> 8 & 255,
      a: hexValue & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports.getOptions = function getOptions(options) {
    if (!options)
      options = {};
    if (!options.color)
      options.color = {};
    const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width = options.width && options.width >= 21 ? options.width : void 0;
    const scale2 = options.scale || 4;
    return {
      width,
      scale: width ? 4 : scale2,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale2 = exports.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale2);
  };
  exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size2 = qr.modules.size;
    const data2 = qr.modules.data;
    const scale2 = exports.getScale(size2, opts);
    const symbolSize = Math.floor((size2 + opts.margin * 2) * scale2);
    const scaledMargin = opts.margin * scale2;
    const palette = [opts.color.light, opts.color.dark];
    for (let i2 = 0; i2 < symbolSize; i2++) {
      for (let j2 = 0; j2 < symbolSize; j2++) {
        let posDst = (i2 * symbolSize + j2) * 4;
        let pxColor = opts.color.light;
        if (i2 >= scaledMargin && j2 >= scaledMargin && i2 < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
          const iSrc = Math.floor((i2 - scaledMargin) / scale2);
          const jSrc = Math.floor((j2 - scaledMargin) / scale2);
          pxColor = palette[data2[iSrc * size2 + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
})(utils$2);
const utils = /* @__PURE__ */ getDefaultExportFromCjs(utils$2);
const utils$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: utils
}, [utils$2]);
const require$$0$j = /* @__PURE__ */ getAugmentedNamespace(utils$1);
(function(exports) {
  const Utils2 = require$$0$j;
  function clearCanvas(ctx, canvas2, size2) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height);
    if (!canvas2.style)
      canvas2.style = {};
    canvas2.height = size2;
    canvas2.width = size2;
    canvas2.style.height = size2 + "px";
    canvas2.style.width = size2 + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e2) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports.render = function render3(qrData, canvas2, options) {
    let opts = options;
    let canvasEl = canvas2;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!canvas2) {
      canvasEl = getCanvasElement();
    }
    opts = Utils2.getOptions(opts);
    const size2 = Utils2.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image = ctx.createImageData(size2, size2);
    Utils2.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size2);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!opts)
      opts = {};
    const canvasEl = exports.render(qrData, canvas2, opts);
    const type = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type, rendererOpts.quality);
  };
})(canvas$2);
const canvas = /* @__PURE__ */ getDefaultExportFromCjs(canvas$2);
const canvas$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: canvas
}, [canvas$2]);
const require$$2$3 = /* @__PURE__ */ getAugmentedNamespace(canvas$1);
var svgTag$1 = {};
const Utils = require$$0$j;
function getColorAttrib(color2, attrib) {
  const alpha2 = color2.a / 255;
  const str = attrib + '="' + color2.hex + '"';
  return alpha2 < 1 ? str + " " + attrib + '-opacity="' + alpha2.toFixed(2).slice(1) + '"' : str;
}
function svgCmd(cmd, x2, y2) {
  let str = cmd + x2;
  if (typeof y2 !== "undefined")
    str += " " + y2;
  return str;
}
function qrToPath(data2, size2, margin) {
  let path = "";
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;
  for (let i2 = 0; i2 < data2.length; i2++) {
    const col = Math.floor(i2 % size2);
    const row = Math.floor(i2 / size2);
    if (!col && !newRow)
      newRow = true;
    if (data2[i2]) {
      lineLength++;
      if (!(i2 > 0 && col > 0 && data2[i2 - 1])) {
        path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col + 1 < size2 && data2[i2 + 1])) {
        path += svgCmd("h", lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
var render = svgTag$1.render = function render2(qrData, options, cb2) {
  const opts = Utils.getOptions(options);
  const size2 = qrData.modules.size;
  const data2 = qrData.modules.data;
  const qrcodesize = size2 + opts.margin * 2;
  const bg2 = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
  const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data2, size2, opts.margin) + '"/>';
  const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
  const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
  const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg2 + path + "</svg>\n";
  if (typeof cb2 === "function") {
    cb2(null, svgTag2);
  }
  return svgTag2;
};
const svgTag = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: svgTag$1,
  render
}, [svgTag$1]);
const require$$3$2 = /* @__PURE__ */ getAugmentedNamespace(svgTag);
const canPromise = require$$0$o;
const QRCode$1 = require$$1$7;
const CanvasRenderer = require$$2$3;
const SvgRenderer = require$$3$2;
function renderCanvas(renderFunc, canvas2, text, opts, cb2) {
  const args = [].slice.call(arguments, 1);
  const argsNum = args.length;
  const isLastArgCb = typeof args[argsNum - 1] === "function";
  if (!isLastArgCb && !canPromise()) {
    throw new Error("Callback required as last argument");
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 2) {
      cb2 = text;
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb2 === "undefined") {
        cb2 = opts;
        opts = void 0;
      } else {
        cb2 = opts;
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 1) {
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text;
      text = canvas2;
      canvas2 = void 0;
    }
    return new Promise(function(resolve, reject) {
      try {
        const data2 = QRCode$1.create(text, opts);
        resolve(renderFunc(data2, canvas2, opts));
      } catch (e2) {
        reject(e2);
      }
    });
  }
  try {
    const data2 = QRCode$1.create(text, opts);
    cb2(null, renderFunc(data2, canvas2, opts));
  } catch (e2) {
    cb2(e2);
  }
}
var create$5 = browser$1.create = QRCode$1.create;
var toCanvas = browser$1.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
var toDataURL = browser$1.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
var toString$1 = browser$1.toString = renderCanvas.bind(null, function(data2, _2, opts) {
  return SvgRenderer.render(data2, opts);
});
const browser = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  create: create$5,
  default: browser$1,
  toCanvas,
  toDataURL,
  toString: toString$1
}, [browser$1]);
var PRE_ENTER = 0;
var ENTERING = 1;
var ENTERED = 2;
var PRE_EXIT = 3;
var EXITING = 4;
var EXITED = 5;
var UNMOUNTED = 6;
var STATES = ["preEnter", "entering", "entered", "preExit", "exiting", "exited", "unmounted"];
var startOrEnd = function startOrEnd2(unmounted) {
  return unmounted ? UNMOUNTED : EXITED;
};
var updateState = function updateState2(state, setState, latestState, timeoutId, onChange) {
  clearTimeout(timeoutId.current);
  setState(state);
  latestState.current = state;
  onChange && onChange({
    state: STATES[state]
  });
};
var useTransition = function useTransition2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$enter = _ref.enter, enter = _ref$enter === void 0 ? true : _ref$enter, _ref$exit = _ref.exit, exit = _ref$exit === void 0 ? true : _ref$exit, preEnter = _ref.preEnter, preExit = _ref.preExit, timeout = _ref.timeout, initialEntered = _ref.initialEntered, mountOnEnter = _ref.mountOnEnter, unmountOnExit = _ref.unmountOnExit, onChange = _ref.onChange;
  var _useState = reactExports.useState(initialEntered ? ENTERED : startOrEnd(mountOnEnter)), state = _useState[0], setState = _useState[1];
  var latestState = reactExports.useRef(state);
  var timeoutId = reactExports.useRef();
  var enterTimeout, exitTimeout;
  if (typeof timeout === "object") {
    enterTimeout = timeout.enter;
    exitTimeout = timeout.exit;
  } else {
    enterTimeout = exitTimeout = timeout;
  }
  var endTransition = reactExports.useCallback(function() {
    var newState;
    switch (latestState.current) {
      case ENTERING:
      case PRE_ENTER:
        newState = ENTERED;
        break;
      case EXITING:
      case PRE_EXIT:
        newState = startOrEnd(unmountOnExit);
        break;
    }
    if (newState !== void 0) {
      updateState(newState, setState, latestState, timeoutId, onChange);
    }
  }, [onChange, unmountOnExit]);
  var toggle = reactExports.useCallback(function(toEnter) {
    var transitState = function transitState2(newState) {
      updateState(newState, setState, latestState, timeoutId, onChange);
      switch (newState) {
        case ENTERING:
          if (enterTimeout >= 0)
            timeoutId.current = setTimeout(endTransition, enterTimeout);
          break;
        case EXITING:
          if (exitTimeout >= 0)
            timeoutId.current = setTimeout(endTransition, exitTimeout);
          break;
        case PRE_ENTER:
        case PRE_EXIT:
          timeoutId.current = setTimeout(function() {
            return transitState2(newState + 1);
          }, 0);
          break;
      }
    };
    var enterStage = latestState.current <= ENTERED;
    if (typeof toEnter !== "boolean")
      toEnter = !enterStage;
    if (toEnter) {
      if (!enterStage) {
        transitState(enter ? preEnter ? PRE_ENTER : ENTERING : ENTERED);
      }
    } else {
      if (enterStage) {
        transitState(exit ? preExit ? PRE_EXIT : EXITING : startOrEnd(unmountOnExit));
      }
    }
  }, [endTransition, onChange, enter, exit, preEnter, preExit, enterTimeout, exitTimeout, unmountOnExit]);
  reactExports.useEffect(function() {
    return function() {
      return clearTimeout(timeoutId.current);
    };
  }, []);
  return [STATES[state], toggle, endTransition];
};
const createMipd = () => {
  if (typeof window === "undefined")
    return null;
  const store = createStore();
  const connectors = [];
  const providers = store.getProviders();
  providers.map((provider2) => {
    connectors.push({
      uuid: provider2.info.uuid,
      name: provider2.info.name,
      icon: provider2.info.icon,
      rdns: provider2.info.rdns,
      provider: provider2.provider
    });
  });
  return {
    connectors,
    findConnectorByUUID: (uuid) => connectors.find((c2) => c2.uuid === uuid),
    findConnectorByName: (name2) => connectors.find((c2) => c2.name === name2)
  };
};
const defaultConnectors = ({ chains: chains2, app, walletConnectProjectId }) => {
  const hasAllAppData = app.name && app.icon && app.description && app.url;
  const shouldUseSafeConnector = !(typeof window === "undefined") && (window === null || window === void 0 ? void 0 : window.parent) !== window;
  let connectors = [];
  const mipd2 = createMipd();
  if (mipd2) {
    connectors.push(...mipd2.connectors.map((c2) => new InjectedConnector({
      chains: chains2,
      options: {
        getProvider: () => typeof window !== "undefined" ? c2.provider : void 0,
        name: c2.uuid
        // use uuid as name so we can differentiate between multiple instances
      }
    })));
  }
  if (shouldUseSafeConnector) {
    connectors = [
      ...connectors,
      new SafeConnector({
        chains: chains2,
        options: {
          allowedDomains: [/gnosis-safe.io$/, /app.safe.global$/],
          debug: false
        }
      })
    ];
  }
  connectors = [
    ...connectors,
    new MetaMaskConnector({
      chains: chains2,
      options: {
        shimDisconnect: true,
        UNSTABLE_shimOnConnectSelectAccount: true
      }
    }),
    new CoinbaseWalletConnector({
      chains: chains2,
      options: {
        appName: app.name,
        headlessMode: true
      }
    }),
    walletConnectProjectId ? new WalletConnectConnector({
      chains: chains2,
      options: {
        showQrModal: false,
        projectId: walletConnectProjectId,
        metadata: hasAllAppData ? {
          name: app.name,
          description: app.description,
          url: app.url,
          icons: [app.icon]
        } : void 0
      }
    }) : new WalletConnectLegacyConnector({
      chains: chains2,
      options: {
        qrcode: false
      }
    }),
    new InjectedConnector({
      chains: chains2,
      options: {
        shimDisconnect: true,
        name: (detectedName) => `Injected (${typeof detectedName === "string" ? detectedName : detectedName.join(", ")})`
      }
    })
  ];
  return connectors;
};
let globalAppName;
let globalAppIcon;
const getAppName = () => globalAppName;
const getAppIcon = () => globalAppIcon;
const defaultChains = [mainnet, polygon, optimism, arbitrum];
const defaultConfig = ({ autoConnect = true, appName = "ConnectKit", appIcon, appDescription, appUrl, chains: chains2 = defaultChains, alchemyId, infuraId, connectors, publicClient, stallTimeout, webSocketPublicClient, enableWebSocketPublicClient, walletConnectProjectId }) => {
  globalAppName = appName;
  if (appIcon)
    globalAppIcon = appIcon;
  const providers = [];
  if (alchemyId) {
    providers.push(alchemyProvider({ apiKey: alchemyId }));
  }
  if (infuraId) {
    providers.push(infuraProvider({ apiKey: infuraId }));
  }
  providers.push(jsonRpcProvider({
    rpc: (c2) => {
      return { http: c2.rpcUrls.default.http[0] };
    }
  }));
  providers.push(publicProvider());
  const { publicClient: configuredPublicClient, chains: configuredChains, webSocketPublicClient: configuredWebSocketPublicClient } = configureChains(chains2, providers, { stallTimeout });
  const connectKitClient = {
    autoConnect,
    connectors: connectors !== null && connectors !== void 0 ? connectors : defaultConnectors({
      chains: configuredChains,
      app: {
        name: appName,
        icon: appIcon,
        description: appDescription,
        url: appUrl
      },
      walletConnectProjectId
    }),
    publicClient: publicClient !== null && publicClient !== void 0 ? publicClient : configuredPublicClient,
    webSocketPublicClient: enableWebSocketPublicClient ? webSocketPublicClient !== null && webSocketPublicClient !== void 0 ? webSocketPublicClient : configuredWebSocketPublicClient : void 0
  };
  return { ...connectKitClient };
};
const defaultLightTheme = {
  font: {
    family: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, 'Apple Color Emoji', Arial, sans-serif, 'Segoe UI Emoji'`
  },
  text: {
    primary: {
      color: "#373737"
    },
    secondary: {
      color: "#999999",
      hover: {
        color: "#111111"
      }
    },
    error: "#FC6464",
    valid: "#32D74B"
  },
  buttons: {
    primary: {
      borderRadius: 16,
      color: "#000373737000",
      background: "#FFFFFF",
      border: "#F0F0F0",
      hover: {
        color: "#000000",
        border: "#1A88F8"
      }
    },
    secondary: {
      borderRadius: 16,
      background: "#F6F7F9",
      color: "#000000"
    }
  },
  navigation: {
    color: "#999999"
  },
  modal: {
    background: "#ffffff",
    divider: "#f7f6f8"
  },
  tooltips: {
    color: "#999999",
    background: "#ffffff",
    hover: {
      background: "#f6f7f9"
    }
  },
  overlay: {
    background: "rgba(0, 0, 0, 0.06)"
  },
  qrCode: {
    accentColor: "#F7F6F8"
  }
};
const parseTheme = (theme) => {
  return theme;
};
const userPrefersDarkMode = () => {
  if (typeof window === "undefined")
    return false;
  return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
};
userPrefersDarkMode();
const defaultTheme$1 = {
  connectKit: {
    options: {
      iconStyle: "light"
    },
    //theme: parseTheme(defaultLightTheme),
    theme: {
      preferred: "dark",
      light: parseTheme(defaultLightTheme),
      dark: parseTheme(defaultLightTheme)
    }
  }
};
var styled = typeof styled$1.div === "function" ? styled$1 : styled$1["default"];
const hexToP3 = (hex2) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex2);
  if (result == null)
    return hex2;
  const values = {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  };
  return `color(display-p3 ${values.r / 255} ${values.g / 255} ${values.b / 255})`;
};
var base = {
  light: {
    /** Connect Wallet Button */
    "--ck-connectbutton-font-size": "15px",
    "--ck-connectbutton-color": "#373737",
    "--ck-connectbutton-background": "#F6F7F9",
    "--ck-connectbutton-background-secondary": "#FFFFFF",
    "--ck-connectbutton-hover-color": "#373737",
    "--ck-connectbutton-hover-background": "#F0F2F5",
    "--ck-connectbutton-active-color": "#373737",
    "--ck-connectbutton-active-background": "#EAECF1",
    "--ck-connectbutton-balance-color": "#373737",
    "--ck-connectbutton-balance-background": "#fff",
    "--ck-connectbutton-balance-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-background)",
    "--ck-connectbutton-balance-hover-background": "#F6F7F9",
    "--ck-connectbutton-balance-hover-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-hover-background)",
    "--ck-connectbutton-balance-active-background": "#F0F2F5",
    "--ck-connectbutton-balance-active-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-active-background)",
    /** Primary Button */
    "--ck-primary-button-border-radius": "16px",
    "--ck-primary-button-color": "#373737",
    "--ck-primary-button-background": "#F6F7F9",
    //'--ck-primary-button-box-shadow': 'inset 0 0 0 1px #F0F0F0',
    "--ck-primary-button-font-weight": "600",
    "--ck-primary-button-hover-color": "#373737",
    "--ck-primary-button-hover-background": "#F0F2F5",
    //'--ck-primary-button-hover-box-shadow': 'inset 0 0 0 2px var(--ck-focus-color)',
    //'--ck-primary-button-active-background': '#EAECF1',
    /** Secondary Button */
    "--ck-secondary-button-border-radius": "16px",
    "--ck-secondary-button-color": "#373737",
    "--ck-secondary-button-background": "#F6F7F9",
    //'--ck-secondary-button-box-shadow': '',
    //'--ck-secondary-button-font-weight': '',
    /** Tertiary Button */
    "--ck-tertiary-button-background": "#FFFFFF",
    "--ck-secondary-button-hover-background": "#e0e4eb",
    /** Modal */
    "--ck-modal-box-shadow": "0px 2px 4px rgba(0, 0, 0, 0.02)",
    "--ck-overlay-background": "rgba(71, 88, 107, 0.24)",
    "--ck-body-color": "#373737",
    "--ck-body-color-muted": "#999999",
    "--ck-body-color-muted-hover": "#111111",
    "--ck-body-background": "#ffffff",
    "--ck-body-background-transparent": "rgba(255,255,255,0)",
    "--ck-body-background-secondary": "#f6f7f9",
    "--ck-body-background-secondary-hover-background": "#e0e4eb",
    "--ck-body-background-secondary-hover-outline": "#4282FF",
    "--ck-body-background-tertiary": "#F3F4F7",
    "--ck-body-action-color": "#999999",
    "--ck-body-divider": "#f7f6f8",
    "--ck-body-color-danger": "#FF4E4E",
    "--ck-body-color-valid": "#32D74B",
    "--ck-siwe-border": "#F0F0F0",
    /** Disclaimer */
    //'--ck-body-disclaimer-background': '#E3D6C9',
    //'--ck-body-disclaimer-box-shadow': 'none',
    "--ck-body-disclaimer-color": "#AAAAAB",
    "--ck-body-disclaimer-link-color": "#838485",
    "--ck-body-disclaimer-link-hover-color": "#000000",
    /** Tooltips */
    "--ck-tooltip-background": "#ffffff",
    "--ck-tooltip-background-secondary": "#ffffff",
    "--ck-tooltip-color": "#999999",
    "--ck-tooltip-shadow": "0px 2px 10px rgba(0, 0, 0, 0.08)",
    /** Network dropdown */
    "--ck-dropdown-button-color": "#999999",
    "--ck-dropdown-button-box-shadow": "0 0 0 1px rgba(0,0,0,0.01), 0px 0px 7px rgba(0, 0, 0, 0.05)",
    "--ck-dropdown-button-background": "#fff",
    "--ck-dropdown-button-hover-color": "#8B8B8B",
    "--ck-dropdown-button-hover-background": "#F5F7F9",
    /** QR Code */
    "--ck-qr-dot-color": "#000000",
    "--ck-qr-border-color": "#f7f6f8",
    /** Misc. */
    "--ck-focus-color": "#1A88F8",
    "--ck-spinner-color": "var(--ck-focus-color)",
    "--ck-copytoclipboard-stroke": "#CCCCCC"
  },
  dark: {
    "--ck-connectbutton-font-size": "15px",
    "--ck-connectbutton-color": "#ffffff",
    "--ck-connectbutton-background": "#383838",
    "--ck-connectbutton-background-secondary": "#282828",
    "--ck-connectbutton-hover-background": "#404040",
    "--ck-connectbutton-active-background": "#4D4D4D",
    "--ck-connectbutton-balance-color": "#fff",
    "--ck-connectbutton-balance-background": "#282828",
    "--ck-connectbutton-balance-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-background)",
    "--ck-connectbutton-balance-hover-background": "#383838",
    "--ck-connectbutton-balance-hover-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-hover-background)",
    "--ck-connectbutton-balance-active-background": "#404040",
    "--ck-connectbutton-balance-active-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-active-background)",
    "--ck-primary-button-color": "#ffffff",
    "--ck-primary-button-background": "#383838",
    //'--ck-primary-button-box-shadow': 'inset 0 0 0 1px #3D3D3D',
    "--ck-primary-button-border-radius": "16px",
    "--ck-primary-button-font-weight": "600",
    "--ck-primary-button-hover-background": "#404040",
    //'--ck-primary-button-hover-box-shadow': 'inset 0 0 0 2px rgba(255, 255, 255, 0.4)',
    //'--ck-primary-button-active-background': '#4D4D4D',
    "--ck-primary-button-active-border-radius": "16px",
    "--ck-secondary-button-color": "#ffffff",
    "--ck-secondary-button-background": "#333333",
    "--ck-secondary-button-hover-background": "#4D4D4D",
    /** Tertiary Button */
    "--ck-tertiary-button-background": "#424242",
    "--ck-focus-color": "#1A88F8",
    "--ck-overlay-background": "rgba(0,0,0,0.4)",
    "--ck-body-color": "#ffffff",
    "--ck-body-color-muted": "rgba(255, 255, 255, 0.4)",
    "--ck-body-color-muted-hover": "rgba(255, 255, 255, 0.8)",
    "--ck-body-background": "#2B2B2B",
    "--ck-body-background-transparent": "rgba(0,0,0,0)",
    "--ck-body-background-secondary": "#333333",
    "--ck-body-background-secondary-hover-background": "#4D4D4D",
    "--ck-body-background-secondary-hover-outline": "#ffffff",
    "--ck-body-background-tertiary": "#333333",
    "--ck-body-action-color": "#808080",
    "--ck-body-divider": "#383838",
    "--ck-body-color-danger": "#FF4E4E",
    "--ck-body-disclaimer-color": "#858585",
    "--ck-body-disclaimer-link-color": "#ADADAD",
    "--ck-body-disclaimer-link-hover-color": "#FFFFFF",
    "--ck-modal-box-shadow": "0px 2px 4px rgba(0, 0, 0, 0.02)",
    "--ck-copytoclipboard-stroke": "#555555",
    "--ck-tooltip-background": "#2B2B2B",
    "--ck-tooltip-background-secondary": "#333333",
    "--ck-tooltip-color": "#999999",
    "--ck-tooltip-shadow": "0px 2px 10px rgba(0, 0, 0, 0.08)",
    /** Network dropdown */
    "--ck-dropdown-button-color": "#6C7381",
    "--ck-spinner-color": "var(--ck-focus-color)",
    "--ck-qr-dot-color": "#ffffff",
    "--ck-qr-border-color": "#3d3d3d"
  }
};
var web95 = {
  "--ck-font-family": "Lato",
  "--ck-border-radius": "0px",
  "--ck-connectbutton-color": "#373737",
  "--ck-connectbutton-background": "linear-gradient(180deg, #F0F0EA 0%, #FFFFFF 50%, #F0F0EA 100%) 100% 100% / 200% 200%, #F5F5F1",
  "--ck-connectbutton-box-shadow": " 0 0 0 1px #003C74, 2px 2px 0px rgba(255, 255, 255, 0.75), -2px -2px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-connectbutton-border-radius": "4.5px",
  "--ck-connectbutton-hover-color": "#373737",
  "--ck-connectbutton-hover-background": "linear-gradient(180deg, #F0F0EA 0%, #FFFFFF 50%, #F0F0EA 100%) 100% 0% / 200% 200%, #F5F5F1",
  "--ck-connectbutton-active-background": "linear-gradient(180deg, #F0F0EA 0%, #FFFFFF 50%, #F0F0EA 100%) 100% 100% / 200% 200%, #F5F5F1",
  "--ck-connectbutton-balance-color": "#373737",
  "--ck-connectbutton-balance-background": "#fff",
  "--ck-connectbutton-balance-box-shadow": "0 0 0 1px #E4E7E7",
  "--ck-connectbutton-balance-hover-box-shadow": "0 0 0 1px #d7dbdb",
  "--ck-connectbutton-balance-active-box-shadow": "0 0 0 1px #bbc0c0",
  "--ck-focus-color": "#1A88F8",
  "--ck-overlay-background": "rgba(0, 127,  128, 0.8)",
  "--ck-body-color": "#373737",
  "--ck-body-color-muted": "#808080",
  "--ck-body-color-muted-hover": "#111111",
  "--ck-body-background": "#F0EDE2",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary-hover-background": "#FAFAFA",
  "--ck-body-background-secondary-hover-outline": "#4282FF",
  "--ck-body-action-color": "#373737",
  "--ck-body-color-danger": "#FC6464",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-divider": "#919B9C",
  "--ck-body-divider-box-shadow": "0px 1px 0px #FBFBF8",
  // Primary button
  "--ck-primary-button-background": "linear-gradient(180deg, #FFFFFF 0%, #F0F0EA 100%), #F5F5F1",
  "--ck-primary-button-box-shadow": "inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-primary-button-border-radius": "6px",
  // Primary button hover
  "--ck-primary-button-hover-box-shadow": "inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 5px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-primary-button-hover-border-radius": "6px",
  // Modal
  "--ck-modal-heading-font-weight": 400,
  "--ck-modal-box-shadow": `
    inset 0px -3px 0px #0F37A9,
    inset -2px 0px 0px #0F37A9,
    inset 0px -4px 0px #0D5DDF,
    inset -4px 0px 0px #0D5DDF,
    inset 2px 0px 0px #0453DD,
    inset 0px 2px 0px #044FD1,
    inset 4px 0px 0px #4283EB,
    inset 0px 4px 0px #4283EB
  `,
  "--ck-modal-h1-font-weight": 400,
  // Secondary button
  "--ck-secondary-button-color": "#373737",
  "--ck-secondary-button-border-radius": "6px",
  "--ck-secondary-button-box-shadow": "inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-secondary-button-background": "linear-gradient(180deg, #FFFFFF 0%, #F0F0EA 100%), #F5F5F1",
  // Secondary button hover
  "--ck-secondary-button-hover-box-shadow": "inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 4px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-body-background-secondary": "rgba(0, 0, 0, 0.1)",
  "--ck-body-background-tertiary": "linear-gradient(180deg, #FBFBFB 0%, #EFEFEE 100%)",
  "--ck-tertiary-border-radius": "0px",
  "--ck-tertiary-box-shadow": "inset 0 0 0 1px #919B9C, 1px 1px 2px rgba(0, 0, 0, 0.15), inset -2px -2px 0px #FFFFFF",
  "--ck-body-button-text-align": "left",
  "--ck-body-button-box-shadow": "0 2px 4px rgba(0, 0, 0, 0.05 )",
  "--ck-body-disclaimer-background": "linear-gradient(180deg, #FBFBFB 0%, #EFEFEE 100%)",
  "--ck-body-disclaimer-box-shadow": `
    inset 0px -3px 0px #0F37A9,
    inset -2px 0px 0px #0F37A9,
    inset 0px -4px 0px #0D5DDF,
    inset -4px 0px 0px #0D5DDF,
    inset 2px 0px 0px #0453DD,
    inset 4px 0px 0px #4283EB,
    inset 0 1px 0 0 #919B9C`,
  "--ck-body-disclaimer-font-size": "14px",
  "--ck-body-disclaimer-color": "#959594",
  "--ck-body-disclaimer-link-color": "#626262",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-qr-dot-color": "#000000",
  "--ck-qr-border-color": "#919B9C",
  "--ck-qr-border-radius": "0",
  "--ck-qr-background": "#FFFFFF",
  "--ck-copytoclipboard-stroke": "rgba(55, 55, 55, 0.4)",
  "--ck-tooltip-background": "linear-gradient(270deg, #F7F3E6 7.69%, #F5F7DA 100%)",
  "--ck-tooltip-background-secondary": "#f6f7f9",
  "--ck-tooltip-color": "#000000",
  "--ck-tooltip-shadow": " 0 0 0 1.5px #2b2622, 0px 2px 10px rgba(0, 0, 0, 0.08)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-button-color": "#999999",
  "--ck-dropdown-button-box-shadow": "0 0 0 1px #A0A0A0, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-dropdown-button-background": "linear-gradient(180deg, #FFFFFF 0%, #F0F0EA 100%), #F5F5F1",
  "--ck-dropdown-button-hover-background": "linear-gradient(0deg, #FFFFFF 0%, #F0F0EA 100%), #F5F5F1",
  "--ck-dropdown-pending-color": "#ACA899",
  "--ck-dropdown-active-color": "#FFFFFF",
  "--ck-dropdown-active-static-color": "#ACA899",
  "--ck-dropdown-active-background": "#3F69BF",
  "--ck-dropdown-active-border-radius": "0",
  "--ck-dropdown-active-inset": "-12px",
  "--ck-dropdown-color": "#ACA899",
  "--ck-dropdown-background": "#FFFFFF",
  "--ck-dropdown-box-shadow": "inset 0 0 0 1px #ACA899, 2px 2px 7px rgba(0, 0, 0, 0.15)",
  "--ck-dropdown-border-radius": "0",
  "--ck-alert-color": "#ACA899",
  "--ck-alert-background": "linear-gradient(180deg, #FBFBFB 0%, #EFEFEE 100%)",
  "--ck-alert-box-shadow": "inset 0 0 0 1px #919B9C, 1px 1px 2px rgba(0, 0, 0, 0.15), inset -2px -2px 0px #FFFFFF",
  "--ck-alert-border-radius": "0",
  "--ck-recent-badge-border-radius": "32px",
  "--ck-recent-badge-top-offset": "0px",
  /** Graphics options for our themes, not to be exposed to devs */
  "--ck-graphic-primary-color": "#333333",
  "--ck-graphic-primary-background": "#FFFFFF",
  /*
    '--ck-graphic-secondary-color': '#7D7D7D',
    '--ck-graphic-secondary-background':
      'linear-gradient(180deg, #FFFFFF 0%, #F0F0EA 100%), #F5F5F1',
    '--ck-graphic-secondary-box-shadow':
      'inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)',
  
    '--ck-graphic-compass-color': '#7D7D7D',
    */
  "--ck-graphic-compass-background": "#FFFFFF",
  /*
    '--ck-graphic-compass-box-shadow':
      'inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)',
  
    '--ck-graphic-globe-background': '#ffffff',
    '--ck-graphic-globe-lines': '#808080',
    '--ck-graphic-globe-box-shadow':
      ' 0 0 0 1px #999A9E, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC',
      */
  "--ck-siwe-border": "#919B9C"
};
var retro = {
  "--ck-font-family": '"SF Pro Rounded",ui-rounded,"Nunito",-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,"Apple Color Emoji",Arial,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"',
  "--ck-border-radius": "8px",
  "--ck-connectbutton-font-size": "17px",
  "--ck-connectbutton-color": "#000000",
  "--ck-connectbutton-background": "#ffffff",
  "--ck-connectbutton-box-shadow": "-4px 4px 0px #000000, inset 0 0 0 2px #000000",
  "--ck-connectbutton-border-radius": "8px",
  "--ck-connectbutton-hover-background": "#F3EDE8",
  "--ck-connectbutton-active-box-shadow": "0 0 0 0 #000000, inset 0 0 0 2px #000000",
  "--ck-connectbutton-balance-color": "#000000",
  "--ck-connectbutton-balance-background": "#F3EDE8",
  "--ck-connectbutton-balance-box-shadow": "-4px 4px 0px #000000, inset 0 0 0 2px #000000",
  "--ck-connectbutton-balance-hover-background": "#eee5dd",
  "--ck-connectbutton-balance-connectbutton-box-shadow": "-4px 8px 0px -4px #000000, inset 0 0 0 2px #000000",
  "--ck-connectbutton-balance-connectbutton-border-radius": "0px 8px 8px 0",
  "--ck-primary-button-color": "#373737",
  "--ck-primary-button-background": "#ffffff",
  "--ck-primary-button-box-shadow": "inset 0 0 0 2px #000000, -4px 4px 0 0 #000000",
  "--ck-primary-button-border-radius": "8px",
  "--ck-primary-button-hover-background": "#F3EDE8",
  "--ck-primary-button-hover-box-shadow": "inset 0 0 0 2px #000000, -0px 0px 0 0 #000000",
  "--ck-secondary-button-border-radius": "8px",
  "--ck-secondary-button-color": "#373737",
  "--ck-secondary-button-background": "#ffffff",
  "--ck-secondary-button-box-shadow": "-4px 4px 0 0 #000000, inset 0 0 0 2px #000000",
  "--ck-secondary-button-hover-background": "#F3EDE8",
  "--ck-secondary-button-hover-box-shadow": "0 0 0 0 #000000, inset 0 0 0 2px #000000",
  "--ck-focus-color": "#3B99FC",
  "--ck-overlay-background": "rgba(133, 120, 122, 0.8)",
  "--ck-body-color": "#373737",
  "--ck-body-color-muted": "rgba(0, 0, 0, 0.5)",
  "--ck-body-color-muted-hover": "#000000",
  "--ck-body-background": "#EBE1D8",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary": "rgba(0,0,0,0.1)",
  "--ck-body-background-secondary-hover-background": "#4D4D4D",
  "--ck-body-background-secondary-hover-outline": "#373737",
  "--ck-body-background-tertiary": "#ffffff",
  "--ck-tertiary-border-radius": "8px",
  "--ck-tertiary-box-shadow": "-4px 4px 0 0 #000000, inset 0 0 0 2px #000000",
  "--ck-body-action-color": "#373737",
  "--ck-body-divider": "#373737",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-disclaimer-background": "#E3D6C9",
  "--ck-body-disclaimer-box-shadow": "-4px 4px 0 0 #000000, inset 2px 0 0 0 #000000, inset -2px 0 0 0 #000000, inset 0 -2px 0 0 #000000",
  "--ck-body-disclaimer-font-weight": "500",
  "--ck-body-disclaimer-color": "#888079",
  "--ck-body-disclaimer-link-color": "#5B5650",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-modal-box-shadow": "-10px 10px 0px #000000, inset 0 0 0 2px #000000",
  "--ck-copytoclipboard-stroke": "#555555",
  "--ck-tooltip-border-radius": "8px",
  "--ck-tooltip-color": "#373737",
  "--ck-tooltip-background": "#ffffff",
  "--ck-tooltip-background-secondary": "#EBE1D8",
  "--ck-tooltip-shadow": "-6px 6px 0 0 #000000, 0 0 0 2px #000000",
  "--ck-spinner-color": "#1A88F8",
  "--ck-dropdown-button-color": "#000",
  "--ck-dropdown-button-box-shadow": "-2px 2px 0 2px #000000,  0 0 0 2px #000000",
  "--ck-dropdown-button-background": "#ffffff",
  "--ck-dropdown-button-hover-background": "#F3EDE8",
  "--ck-dropdown-button-hover-box-shadow": "-2px 2px 0 0 #000000,  0 0 0 2px #000000",
  "--ck-dropdown-pending-color": "rgba(0, 0, 0, 0.5)",
  "--ck-dropdown-active-color": "#FFFFFF",
  "--ck-dropdown-active-static-color": "rgba(0, 0, 0, 0.5)",
  "--ck-dropdown-active-background": "#3B99FC",
  "--ck-dropdown-active-box-shadow": "inset 0 0 0 2px #000000",
  "--ck-dropdown-active-border-radius": "8px",
  "--ck-dropdown-color": "rgba(0, 0, 0, 0.5)",
  "--ck-dropdown-background": "#FFFFFF",
  "--ck-dropdown-box-shadow": "-4px 4px 0 0 #000000, inset 0 0 0 2px #000000",
  "--ck-dropdown-border-radius": "8px",
  "--ck-alert-color": "rgba(0, 0, 0, 0.5)",
  "--ck-alert-background": " #F5F5F5",
  "--ck-alert-border-radius": "8px",
  "--ck-qr-border-radius": "8px",
  "--ck-qr-dot-color": "#000000",
  "--ck-qr-border-color": "#000000",
  "--ck-qr-background": "#ffffff",
  "--ck-recent-badge-border-radius": "32px",
  "--ck-recent-badge-box-shadow": "inset 0 0 0 2px currentColor",
  /** Graphics options for our themes, not to be exposed to devs */
  "--ck-graphic-primary-color": "#000000",
  "--ck-graphic-primary-background": "#ffffff",
  /*
    '--ck-graphic-secondary-color': '#ffffff',
    '--ck-graphic-secondary-background': '#808080',
    '--ck-graphic-secondary-box-shadow':
      '-4px 4px 0 2px #000000, 0 0 0 2px #000000',
  
    '--ck-graphic-compass-color': '#ffffff',*/
  "--ck-graphic-compass-background": "#FFFFFF",
  /*
    '--ck-graphic-compass-box-shadow':
      '-4px 4px 0 0 #000000, inset 0 0 0 2px #000000',
  
    '--ck-graphic-globe-background': '#ffffff',
    '--ck-graphic-globe-lines': '#808080',
    '--ck-graphic-globe-box-shadow': '6px -6px 0 2px #000000, 0 0 0 2px #000000',
    */
  "--ck-siwe-border": "#8E8985"
};
var soft = {
  "--ck-border-radius": "12px",
  "--ck-connectbutton-font-size": "17px",
  "--ck-connectbutton-border-radius": "12px",
  "--ck-connectbutton-color": "#414451",
  "--ck-connectbutton-background": "#ffffff",
  "--ck-connectbutton-box-shadow": "inset 0 0 0 1px #E9EAEC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-hover-background": "#F6F7F9",
  "--ck-connectbutton-hover-box-shadow": "inset 0 0 0 1px #E9EAEC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-balance-color": "#373737",
  "--ck-connectbutton-balance-background": "#F6F7F9",
  "--ck-connectbutton-balance-box-shadow": "none",
  "--ck-connectbutton-balance-hover-background": "#f1f1f3",
  "--ck-primary-button-border-radius": "12px",
  "--ck-primary-button-color": "#414451",
  "--ck-primary-button-background": "#ffffff",
  "--ck-primary-button-box-shadow": "0 0 0 1px #E9EAEC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-primary-button-hover-background": "#F6F7F9",
  "--ck-primary-button-hover-box-shadow": "0 0 0 1px #D9DBDD, 0px 0 0 rgba(0, 0, 0, 0.02)",
  "--ck-secondary-button-border-radius": "12px",
  "--ck-secondary-button-color": "#414451",
  "--ck-secondary-button-background": "#ffffff",
  "--ck-secondary-button-box-shadow": "0 0 0 1px #E9EAEC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-secondary-button-hover-background": "#F6F7F9",
  "--ck-secondary-button-hover-box-shadow": "0 0 0 1px #D9DBDD, 0px 0 0 rgba(0, 0, 0, 0.02)",
  "--ck-focus-color": "#1A88F8",
  "--ck-modal-box-shadow": `0px 3px 16px rgba(0, 0, 0, 0.08)`,
  "--ck-body-color": "#414451",
  "--ck-body-color-muted": "#9196A1",
  "--ck-body-color-muted-hover": "#000000",
  "--ck-body-background": "#ffffff",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary": "#f6f7f9",
  "--ck-body-background-secondary-hover-background": "#e0e4eb",
  "--ck-body-background-secondary-hover-outline": "#4282FF",
  "--ck-body-background-tertiary": "#F6F8FA",
  "--ck-tertiary-border-radius": "13px",
  "--ck-tertiary-box-shadow": "inset 0 0 0 1px rgba(0, 0, 0, 0.04)",
  "--ck-body-action-color": "#999999",
  "--ck-body-divider": "#f7f6f8",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-disclaimer-background": "#F9FAFA",
  "--ck-body-disclaimer-color": "#AFB1B6",
  "--ck-body-disclaimer-link-color": "#787B84",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-copytoclipboard-stroke": "#CCCCCC",
  "--ck-tooltip-background": "#ffffff",
  "--ck-tooltip-background-secondary": "#ffffff",
  "--ck-tooltip-color": "#999999",
  "--ck-tooltip-shadow": "0px 2px 10px rgba(0, 0, 0, 0.08)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-button-color": "#999999",
  "--ck-dropdown-button-box-shadow": "0 0 0 1px rgba(0, 0, 0, 0.01), 0px 0px 7px rgba(0, 0, 0, 0.05)",
  "--ck-dropdown-button-background": "#fff",
  "--ck-dropdown-button-hover-color": "#8B8B8B",
  "--ck-dropdown-button-hover-background": "#E7E7E7",
  "--ck-dropdown-color": "rgba(55, 55, 55, 0.4)",
  "--ck-dropdown-box-shadow": "0px 2px 15px rgba(0, 0, 0, 0.15)",
  "--ck-alert-color": "#9196A1",
  "--ck-alert-background": "#F6F8FA",
  "--ck-alert-box-shadow": "inset 0 0 0 1px rgba(0, 0, 0, 0.04)",
  "--ck-alert-border-radius": "8px",
  "--ck-qr-border-radius": "12px",
  "--ck-qr-dot-color": "#2E3138",
  "--ck-qr-border-color": "#E9EAEC",
  "--ck-siwe-border": "#EAEBED"
};
var midnight = {
  "--ck-font-family": '"Inter",-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,"Apple Color Emoji",Arial,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"',
  "--ck-border-radius": "10px",
  "--ck-connectbutton-font-size": "17px",
  "--ck-connectbutton-border-radius": "8px",
  "--ck-connectbutton-color": "#ffffff",
  "--ck-connectbutton-background": "#313235",
  "--ck-connectbutton-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.05)",
  "--ck-connectbutton-hover-background": "#414144",
  "--ck-connectbutton-active-background": "#4C4D4F",
  "--ck-connectbutton-balance-color": "#ffffff",
  "--ck-connectbutton-balance-background": "#1F2023",
  "--ck-connectbutton-balance-box-shadow": "inset 0 0 0 1px #313235",
  "--ck-connectbutton-balance-hover-background": "#313235",
  "--ck-connectbutton-balance-active-background": "#414144",
  "--ck-primary-button-border-radius": "8px",
  "--ck-primary-button-color": "#ffffff",
  "--ck-primary-button-background": "rgba(255, 255, 255, 0.08)",
  "--ck-primary-button-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.05)",
  "--ck-primary-button-hover-background": "rgba(255, 255, 255, 0.2)",
  "--ck-secondary-button-border-radius": "8px",
  "--ck-secondary-button-color": "#ffffff",
  "--ck-secondary-button-background": "#363638",
  "--ck-secondary-button-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.05)",
  "--ck-secondary-button-hover-background": "#3c3c3e",
  "--ck-overlay-background": "rgba(0,0,0,0.4)",
  "--ck-modal-box-shadow": `inset 0 0 0 1px #38393C, 0px 2px 4px rgba(0, 0, 0, 0.02)`,
  "--ck-focus-color": "#1A88F8",
  "--ck-body-color": "#ffffff",
  "--ck-body-color-muted": "#8B8F97",
  "--ck-body-color-muted-hover": "#ffffff",
  "--ck-body-background": "#1F2023",
  "--ck-body-background-transparent": "rgba(31, 32, 35, 0)",
  "--ck-body-background-secondary": "#313235",
  "--ck-body-background-secondary-hover-background": "#e0e4eb",
  "--ck-body-background-secondary-hover-outline": "rgba(255, 255, 255, 0.02)",
  "--ck-body-background-tertiary": "#313235",
  "--ck-tertiary-border-radius": "12px",
  "--ck-tertiary-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.02)",
  "--ck-body-action-color": "#8B8F97",
  "--ck-body-divider": "rgba(255,255,255,0.1)",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-disclaimer-background": "#2B2D31",
  "--ck-body-disclaimer-box-shadow": "none",
  "--ck-body-disclaimer-color": "#808183",
  "--ck-body-disclaimer-link-color": "#AAABAD",
  "--ck-body-disclaimer-link-hover-color": "#ffffff",
  "--ck-copytoclipboard-stroke": "#CCCCCC",
  "--ck-tooltip-background": "#1F2023",
  "--ck-tooltip-background-secondary": "#1F2023",
  "--ck-tooltip-color": "#ffffff",
  "--ck-tooltip-shadow": " 0 0 0 1px rgba(255, 255, 255, 0.1), 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-button-color": "#6C7381",
  "--ck-dropdown-button-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.05)",
  "--ck-dropdown-button-background": "#313235",
  "--ck-dropdown-pending-color": "#8B8F97",
  "--ck-dropdown-active-color": "#FFF",
  "--ck-dropdown-active-static-color": "#FFF",
  "--ck-dropdown-active-background": "rgba(255, 255, 255, 0.07)",
  "--ck-dropdown-color": "#8B8F97",
  "--ck-dropdown-background": "#313235",
  "--ck-dropdown-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.03)",
  "--ck-dropdown-border-radius": "8px",
  "--ck-alert-color": "#8B8F97",
  "--ck-alert-background": "#404145",
  "--ck-alert-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.02)",
  "--ck-qr-border-radius": "12px",
  "--ck-qr-dot-color": "#ffffff",
  "--ck-qr-border-color": "rgba(255,255,255,0.1)",
  "--ck-recent-badge-border-radius": "32px"
};
var minimal$2 = {
  "--ck-font-family": '"Inter",-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,"Apple Color Emoji",Arial,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"',
  "--ck-border-radius": "0px",
  "--ck-connectbutton-font-size": "17px",
  "--ck-connectbutton-border-radius": "0px",
  "--ck-connectbutton-color": "#414451",
  "--ck-connectbutton-background": "#ffffff",
  "--ck-connectbutton-box-shadow": "inset 0 0 0 1px #EBEBEB",
  "--ck-connectbutton-hover-color": "#111",
  "--ck-connectbutton-hover-box-shadow": "inset 0 0 0 1px #111",
  "--ck-connectbutton-balance-color": "#111111",
  "--ck-connectbutton-balance-background": "#F7F7F7",
  "--ck-connectbutton-balance-box-shadow": "inset 0 0 0 1px #F7F7F7",
  "--ck-connectbutton-balance-hover-background": "#f1f1f3",
  "--ck-connectbutton-balance-hover-box-shadow": "inset 0 0 0 1px #111",
  "--ck-primary-button-border-radius": "0px",
  "--ck-primary-button-color": "#111111",
  "--ck-primary-button-background": "#ffffff",
  "--ck-primary-button-box-shadow": "inset 0 0 0 1px #EBEBEB",
  "--ck-primary-button-hover-box-shadow": "inset 0 0 0 1px #111111",
  "--ck-secondary-button-border-radius": "0px",
  "--ck-secondary-button-color": "#111111",
  "--ck-secondary-button-background": "#ffffff",
  "--ck-secondary-button-box-shadow": "inset 0 0 0 1px #EBEBEB",
  "--ck-secondary-button-hover-box-shadow": "inset 0 0 0 1px #111111",
  "--ck-dropdown-button-color": "#999999",
  "--ck-dropdown-button-box-shadow": "0 0 0 1px rgba(0, 0, 0, 0.01), 0px 0px 7px rgba(0, 0, 0, 0.05)",
  "--ck-dropdown-button-background": "#fff",
  "--ck-dropdown-button-hover-color": "#8B8B8B",
  "--ck-dropdown-button-hover-background": "#E7E7E7",
  "--ck-focus-color": "#1A88F8",
  "--ck-modal-box-shadow": `0px 3px 16px rgba(0, 0, 0, 0.08)`,
  "--ck-body-color": "#111111",
  "--ck-body-color-muted": "#A0A0A0",
  "--ck-body-color-muted-hover": "#000000",
  "--ck-body-background": "#ffffff",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary": "#f6f7f9",
  "--ck-body-background-secondary-hover-background": "#e0e4eb",
  "--ck-body-background-secondary-hover-outline": "#4282FF",
  "--ck-body-background-tertiary": "#ffffff",
  "--ck-tertiary-border-radius": "0px",
  "--ck-tertiary-box-shadow": "inset 0 0 0 1px rgba(0, 0, 0, 0.04)",
  "--ck-body-action-color": "#A0A0A0",
  "--ck-body-divider": "#EBEBEB",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-disclaimer-background": "#FAFAFA",
  "--ck-body-disclaimer-box-shadow": "inset 0 1px 0 0 #ECECEC",
  "--ck-body-disclaimer-color": "#9D9D9D",
  "--ck-body-disclaimer-link-color": "#6E6E6E",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-copytoclipboard-stroke": "#CCCCCC",
  "--ck-tooltip-border-radius": "0px",
  "--ck-tooltip-background": "#ffffff",
  "--ck-tooltip-background-secondary": "#ffffff",
  "--ck-tooltip-color": "#999999",
  "--ck-tooltip-shadow": "0px 2px 10px rgba(0, 0, 0, 0.08)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-active-border-radius": "0",
  "--ck-dropdown-box-shadow": "0px 2px 15px rgba(0, 0, 0, 0.15)",
  "--ck-dropdown-border-radius": "0",
  "--ck-alert-color": "rgba(17, 17, 17, 0.4)",
  "--ck-alert-background": "#fff",
  "--ck-alert-box-shadow": "inset 0 0 0 1px #EBEBEB",
  "--ck-alert-border-radius": "0",
  "--ck-qr-border-radius": "0px",
  "--ck-qr-dot-color": "#111111",
  "--ck-qr-border-color": "#EBEBEB",
  "--ck-modal-h1-font-weight": "400",
  "--ck-modal-heading-font-weight": "400",
  "--ck-primary-button-font-weight": "400",
  "--ck-recent-badge-top-offset": "0px",
  /** Graphics options for our themes, not to be exposed to devs */
  /**
    '--ck-graphic-primary-color': '#111111',
    '--ck-graphic-primary-background': '#ffffff',
    '--ck-graphic-primary-box-shadow': 'inset 0 0 0 1px #EBEBEB',
  
    '--ck-graphic-secondary-color': '#DCDDDE',
    '--ck-graphic-secondary-background': '#ffffff',
    '--ck-graphic-secondary-box-shadow': 'inset 0 0 0 1px #EBEBEB',
  
    '--ck-graphic-compass-color': '#111111',
    '--ck-graphic-compass-background': '#ffffff',
    '--ck-graphic-compass-box-shadow': 'inset 0 0 0 1px #EBEBEB',
  
    '--ck-graphic-globe-background': '#D9D9D9',
    '--ck-graphic-globe-lines': '#ffffff',
    '--ck-graphic-globe-box-shadow': 'inset 0 0 0 1px #EBEBEB',
    */
  "--ck-siwe-border": "#EBEBEB"
};
var rounded = {
  "--ck-font-family": '"Nunito",ui-rounded,-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,"Apple Color Emoji",Arial,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"',
  "--ck-border-radius": "24px",
  "--ck-connectbutton-font-size": "17px",
  "--ck-connectbutton-font-weight": "700",
  "--ck-connectbutton-border-radius": "14px",
  "--ck-connectbutton-color": "#000000",
  "--ck-connectbutton-background": "#ffffff",
  "--ck-connectbutton-box-shadow": "inset 0 0 0 2px #DFE4EC, 0 2px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-hover-background": "#F9FAFB",
  "--ck-connectbutton-balance-color": "#414451",
  "--ck-connectbutton-balance-background": "#F9FAFB",
  "--ck-connectbutton-balance-box-shadow": "0 2px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-balance-hover-background": "#F5F7F9",
  "--ck-connectbutton-balance-hover-box-shadow": "0 2px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-balance-active-box-shadow": "0 0 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-active-background": "#F5F7F9",
  "--ck-connectbutton-active-box-shadow": "inset 0 0 0 2px #CFD7E2, 0 0px 0 0 #CFD7E2, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-primary-button-border-radius": "18px",
  "--ck-primary-button-color": "#000000",
  "--ck-primary-button-background": "#ffffff",
  "--ck-primary-button-box-shadow": "inset 0 0 0 2px #DFE4EC, inset  0 -4px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-primary-button-hover-background": "#F5F7F9",
  "--ck-primary-button-hover-box-shadow": "inset 0 0 0 2px #DFE4EC, inset  0 -2px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-secondary-button-border-radius": "16px",
  "--ck-secondary-button-color": "#000000",
  "--ck-secondary-button-background": "#ffffff",
  "--ck-secondary-button-box-shadow": "inset 0 0 0 2px #DFE4EC, inset  0 -4px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-secondary-button-hover-background": "#F5F7F9",
  "--ck-secondary-button-hover-box-shadow": "inset 0 0 0 2px #DFE4EC, inset  0 -2px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-focus-color": "#1A88F8",
  "--ck-modal-box-shadow": `0px 3px 16px rgba(0, 0, 0, 0.08)`,
  "--ck-body-color": "#000000",
  "--ck-body-color-muted": "#93989F",
  "--ck-body-color-muted-hover": "#000000",
  "--ck-body-background": "#ffffff",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary": "#f6f7f9",
  "--ck-body-background-secondary-hover-background": "#e0e4eb",
  "--ck-body-background-secondary-hover-outline": "#4282FF",
  "--ck-body-background-tertiary": "#ffffff",
  "--ck-tertiary-border-radius": "22px",
  "--ck-tertiary-box-shadow": "inset 0 0 0 2px #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-body-action-color": "#93989F",
  "--ck-body-divider": "#DFE4EC",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-disclaimer-background": "#F9FAFB",
  "--ck-body-disclaimer-font-size": "14px",
  "--ck-body-disclaimer-font-weight": "700",
  "--ck-body-disclaimer-color": "#959697",
  "--ck-body-disclaimer-link-color": "#646464",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-copytoclipboard-stroke": "#CCCCCC",
  "--ck-tooltip-background": "#ffffff",
  "--ck-tooltip-background-secondary": "#ffffff",
  "--ck-tooltip-color": "#999999",
  "--ck-tooltip-shadow": " 0 0 0 2px #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-button-color": "#999999",
  "--ck-dropdown-button-box-shadow": "0 0 0 2px #DFE4EC,  0 2px 0 2px #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-dropdown-button-background": "#fff",
  "--ck-dropdown-button-hover-color": "#8B8B8B",
  "--ck-dropdown-button-hover-background": "#F5F7F9",
  "--ck-dropdown-pending-color": "#848D9A",
  "--ck-dropdown-active-color": "#000000",
  "--ck-dropdown-active-static-color": "#848D9A",
  "--ck-dropdown-active-background": "#F5F7F9",
  "--ck-dropdown-color": "#848D9A",
  "--ck-dropdown-background": "#FFFFFF",
  "--ck-dropdown-box-shadow": "0px 2px 15px rgba(0, 0, 0, 0.15)",
  "--ck-dropdown-border-radius": "16px",
  "--ck-alert-color": "#848D9A",
  "--ck-alert-background": "#F5F7F9",
  "--ck-qr-border-radius": "24px",
  "--ck-qr-dot-color": "#111111",
  "--ck-qr-border-color": "#DFE4EC",
  "--ck-modal-h1-font-weight": "700",
  "--ck-modal-heading-font-weight": "700",
  "--ck-primary-button-font-weight": "700",
  "--ck-recent-badge-box-shadow": "inset 0 0 0 2px currentColor",
  "--ck-recent-badge-top-offset": "0px",
  /** Graphics options for our themes, not to be exposed to devs */
  /*
    '--ck-graphic-primary-color': '#6C7381',
    '--ck-graphic-primary-background': '#ffffff',
    '--ck-graphic-primary-box-shadow': 'inset 0 0 0 2px #DFE4EC',
  
    '--ck-graphic-secondary-color': '#DFE4EC',
    '--ck-graphic-secondary-background': '#ffffff',
    '--ck-graphic-secondary-box-shadow': 'inset 0 0 0 2px #DFE4EC',
  
    '--ck-graphic-compass-color': '#ffffff',
    '--ck-graphic-compass-background': '#6C7381',
    '--ck-graphic-compass-box-shadow': 'inset 0 0 0 2px rgba(0,0,0,0.1)',
  
    '--ck-graphic-globe-background':
      'radial-gradient(84.37% 84.37% at 50% 15.63%, rgba(255, 255, 255, 0.2) 0%, rgba(0, 0, 0, 0) 100%), linear-gradient(180deg, #DFE4EC 0%, #DFE4EC 114.06%), #DFE4EC',
    '--ck-graphic-globe-lines': '#ffffff',
    '--ck-graphic-globe-box-shadow': 'inset 0 0 0 2px #DFE4EC',
    */
  "--ck-siwe-border": "#DFE4EC"
};
var nouns = {
  "--ck-font-family": '"PT Root UI",ui-rounded,"Nunito",-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,"Apple Color Emoji",Arial,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"',
  "--ck-border-radius": "24px",
  "--ck-connectbutton-font-size": "16px",
  "--ck-connectbutton-font-weight": "700",
  "--ck-connectbutton-border-radius": "10px",
  "--ck-connectbutton-color": "#151C3B",
  "--ck-connectbutton-background": "#ffffff",
  "--ck-connectbutton-box-shadow": "inset 0 0 0 1px #D6D8E1",
  "--ck-connectbutton-hover-background": "#E9EBF3",
  "--ck-connectbutton-hover-box-shadow": "inset 0 0 0 1px #D4D8E8",
  "--ck-connectbutton-active-background": "#D4D8E8",
  "--ck-connectbutton-active-box-shadow": "inset 0 0 0 1px #D4D8E8",
  "--ck-connectbutton-balance-color": "#373737",
  "--ck-connectbutton-balance-background": "#F6F7F9",
  "--ck-connectbutton-balance-box-shadow": "none",
  "--ck-connectbutton-balance-hover-background": "#f1f1f3",
  "--ck-primary-button-border-radius": "16px",
  "--ck-primary-button-color": "#151C3B",
  "--ck-primary-button-background": "#ffffff",
  "--ck-primary-button-font-weight": "700",
  "--ck-primary-button-hover-background": "#DEE1ED",
  "--ck-secondary-button-border-radius": "16px",
  "--ck-secondary-button-color": "#151C3B",
  "--ck-secondary-button-background": "#ffffff",
  "--ck-secondary-button-font-weight": "700",
  "--ck-secondary-button-hover-background": "#DEE1ED",
  "--ck-focus-color": "#1A88F8",
  "--ck-modal-box-shadow": `0px 2px 4px rgba(0, 0, 0, 0.02)`,
  "--ck-overlay-background": "rgba(213, 215, 225, 0.8)",
  "--ck-overlay-backdrop-filter": "blur(6px)",
  "--ck-body-color": "#151C3B",
  "--ck-body-color-muted": "#757A8E",
  "--ck-body-color-muted-hover": "#000000",
  "--ck-body-background": "#F4F4F8",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary": "#E9E9F1",
  "--ck-body-background-secondary-hover-background": "#e0e4eb",
  "--ck-body-background-tertiary": "#E9E9F1",
  "--ck-tertiary-border-radius": "24px",
  "--ck-body-action-color": "#79809C",
  "--ck-body-divider": "#D9DBE3",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-disclaimer-background": "#F9FAFA",
  "--ck-body-disclaimer-color": "#AFB1B6",
  "--ck-body-disclaimer-link-color": "#787B84",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-copytoclipboard-stroke": "#79809C",
  "--ck-tooltip-background": "#ffffff",
  "--ck-tooltip-background-secondary": "#ffffff",
  "--ck-tooltip-color": "#999999",
  "--ck-tooltip-shadow": "0px 2px 10px rgba(0, 0, 0, 0.08)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-button-color": "#999999",
  "--ck-dropdown-button-box-shadow": "0 0 0 1px rgba(0, 0, 0, 0.01), 0px 0px 7px rgba(0, 0, 0, 0.05)",
  "--ck-dropdown-button-background": "#fff",
  "--ck-dropdown-button-hover-color": "#8B8B8B",
  "--ck-dropdown-button-hover-background": "#DEE1ED",
  "--ck-dropdown-button-hover-box-shadow": "0px 0px 7px rgba(0, 0, 0, 0.05)",
  "--ck-dropdown-color": "#757A8E",
  "--ck-dropdown-box-shadow": "0 0 0 1px rgba(0, 0, 0, 0.01), 0px 0px 7px rgba(0, 0, 0, 0.05)",
  "--ck-alert-color": "#9196A1",
  "--ck-alert-background": "#F6F8FA",
  "--ck-alert-box-shadow": "inset 0 0 0 1px rgba(0, 0, 0, 0.04)",
  "--ck-alert-border-radius": "8px",
  "--ck-qr-border-radius": "24px",
  "--ck-qr-dot-color": "#000000",
  "--ck-qr-background": "#ffffff",
  "--ck-recent-badge-color": "#79809C",
  "--ck-recent-badge-background": "#F4F4F8",
  "--ck-recent-badge-box-shadow": "none",
  "--ck-siwe-border": "#DFE4EC",
  "--ck-graphic-primary-background": "#fff",
  "--ck-graphic-compass-background": "#fff",
  "--ck-graphic-primary-box-shadow": "0px 2.94737px 14.7368px rgba(0, 0, 0, 0.1)",
  "--ck-graphic-compass-box-shadow": "0px 2px 9px rgba(0, 0, 0, 0.15)"
};
var predefinedThemes = { base, web95, retro, soft, midnight, minimal: minimal$2, rounded, nouns };
const themeGlobals = {
  default: {
    "--ck-font-family": `-apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica,
    'Apple Color Emoji', Arial, sans-serif, 'Segoe UI Emoji',
    'Segoe UI Symbol'`,
    "--ck-border-radius": "20px",
    "--ck-secondary-button-border-radius": "16px"
  },
  graphics: {
    light: {
      "--ck-graphic-wave-stop-01": "#E8F17D",
      "--ck-graphic-wave-stop-02": "#A8ECDE",
      "--ck-graphic-wave-stop-03": "#7AA1F2",
      "--ck-graphic-wave-stop-04": "#DEA1E8",
      "--ck-graphic-wave-stop-05": "#F46D98",
      "--ck-graphic-scaniconwithlogos-01": "#4E4E4E",
      "--ck-graphic-scaniconwithlogos-02": "#272727",
      "--ck-graphic-scaniconwithlogos-03": "#F8D74A",
      "--ck-graphic-scaniconwithlogos-04": "#F6F7F9",
      "--ck-chain-ethereum-01": "#25292E",
      "--ck-chain-ethereum-02": "#fff",
      "--ck-chain-ethereum-03": "#DFE0E0"
    },
    dark: {
      "--ck-graphic-wave-stop-01": "#E8F17D",
      "--ck-graphic-wave-stop-02": "#A8ECDE",
      "--ck-graphic-wave-stop-03": "#7AA1F2",
      "--ck-graphic-wave-stop-04": "#DEA1E8",
      "--ck-graphic-wave-stop-05": "#F46D98",
      "--ck-graphic-scaniconwithlogos-01": "#AFAFAF",
      "--ck-graphic-scaniconwithlogos-02": "#696969",
      "--ck-graphic-scaniconwithlogos-03": "#F8D74A",
      "--ck-graphic-scaniconwithlogos-04": "#3D3D3D"
      //'--ck-chain-ethereum-01': '#fff',
      //'--ck-chain-ethereum-02': '#000',
      //'--ck-chain-ethereum-03': '#000',
    }
  },
  ens: {
    light: {
      "--ck-ens-01-start": "#FF3B30",
      "--ck-ens-01-stop": "#FF9500",
      "--ck-ens-02-start": "#FF9500",
      "--ck-ens-02-stop": "#FFCC00",
      "--ck-ens-03-start": "#FFCC00",
      "--ck-ens-03-stop": "#34C759",
      "--ck-ens-04-start": "#5856D6",
      "--ck-ens-04-stop": "#AF52DE",
      "--ck-ens-05-start": "#5AC8FA",
      "--ck-ens-05-stop": "#007AFF",
      "--ck-ens-06-start": "#007AFF",
      "--ck-ens-06-stop": "#5856D6",
      "--ck-ens-07-start": "#5856D6",
      "--ck-ens-07-stop": "#AF52DE",
      "--ck-ens-08-start": "#AF52DE",
      "--ck-ens-08-stop": "#FF2D55"
    },
    dark: {
      "--ck-ens-01-start": "#FF453A",
      "--ck-ens-01-stop": "#FF9F0A",
      "--ck-ens-02-start": "#FF9F0A",
      "--ck-ens-02-stop": "#FFD60A",
      "--ck-ens-03-start": "#FFD60A",
      "--ck-ens-03-stop": "#32D74B",
      "--ck-ens-04-start": "#32D74B",
      "--ck-ens-04-stop": "#64D2FF",
      "--ck-ens-05-start": "#64D2FF",
      "--ck-ens-05-stop": "#0A84FF",
      "--ck-ens-06-start": "#0A84FF",
      "--ck-ens-06-stop": "#5E5CE6",
      "--ck-ens-07-start": "#5E5CE6",
      "--ck-ens-07-stop": "#BF5AF2",
      "--ck-ens-08-start": "#BF5AF2",
      "--ck-ens-08-stop": "#FF2D55"
    }
  },
  brand: {
    "--ck-family-brand": "#1A88F8",
    "--ck-brand-walletConnect": "#3B99FC",
    "--ck-brand-coinbaseWallet": "#0052FF",
    "--ck-brand-metamask": "#f6851b",
    "--ck-brand-metamask-01": "#F6851B",
    "--ck-brand-metamask-02": "#E2761B",
    "--ck-brand-metamask-03": "#CD6116",
    "--ck-brand-metamask-04": "#161616",
    "--ck-brand-metamask-05": "#763D16",
    "--ck-brand-metamask-06": "#D7C1B3",
    "--ck-brand-metamask-07": "#C0AD9E",
    "--ck-brand-metamask-08": "#E4761B",
    "--ck-brand-metamask-09": "#233447",
    "--ck-brand-metamask-10": "#E4751F",
    "--ck-brand-metamask-11": "#FEF5E7",
    "--ck-brand-metamask-12": "#E3C8AB",
    "--ck-brand-trust-01": "#3375BB",
    "--ck-brand-trust-02": "#ffffff",
    "--ck-brand-trust-01b": "#ffffff",
    "--ck-brand-trust-02b": "#3375BB",
    "--ck-brand-argent": "#f36a3d",
    "--ck-brand-imtoken-01": "#11C4D1",
    "--ck-brand-imtoken-02": "#0062AD",
    "--ck-brand-safe": "#12FF80",
    "--ck-brand-dawn": "#000000"
  }
};
const themeColors = {
  light: predefinedThemes.base.light,
  dark: predefinedThemes.base.dark,
  web95: predefinedThemes.web95,
  retro: predefinedThemes.retro,
  soft: predefinedThemes.soft,
  midnight: predefinedThemes.midnight,
  minimal: predefinedThemes.minimal,
  rounded: predefinedThemes.rounded,
  nouns: predefinedThemes.nouns
};
const createCssVars = (scheme, important) => {
  return Ae`
    ${Object.keys(scheme).map((key) => {
    const value = scheme[key];
    return value && `${key}:${value};`;
  })}
  `;
};
const createCssColors = (scheme, override) => {
  const important = override ? " !important" : "";
  return Ae`
    ${Object.keys(scheme).map((key) => {
    const value = scheme[key];
    return value && `${key}:${value}${important};`;
  })}
    @supports (color: color(display-p3 1 1 1)) {
      ${Object.keys(scheme).map((key) => {
    const value = scheme[key];
    return `${key}:${hexToP3(value)}${important};`;
  })}
    }
  `;
};
const themes = {
  default: createCssVars(themeGlobals.default),
  light: createCssColors(themeColors.light),
  dark: createCssColors(themeColors.dark),
  web95: createCssColors(themeColors.web95),
  retro: createCssColors(themeColors.retro),
  soft: createCssColors(themeColors.soft),
  midnight: createCssColors(themeColors.midnight),
  minimal: createCssColors(themeColors.minimal),
  rounded: createCssColors(themeColors.rounded),
  nouns: createCssColors(themeColors.nouns)
};
const globals = {
  brand: createCssVars(themeGlobals.brand),
  ensLight: createCssVars(themeGlobals.ens.light),
  ensDark: createCssVars(themeGlobals.ens.dark),
  graphicsLight: createCssVars(themeGlobals.graphics.light),
  graphicsDark: createCssVars(themeGlobals.graphics.dark)
};
const globalsLight = Ae`
  ${globals.brand}
  ${globals.ensLight}
  ${globals.graphicsLight}
`;
const globalsDark = Ae`
  ${globals.brand}
  ${globals.ensDark}
  ${globals.graphicsDark}
`;
let mode = "auto";
const ResetContainer = styled(motion.div)`
  ${themes.default}

  ${(props) => {
  switch (props.$useTheme) {
    case "web95":
      mode = "light";
      return themes.web95;
    case "retro":
      mode = "light";
      return themes.retro;
    case "soft":
      mode = "light";
      return themes.soft;
    case "midnight":
      mode = "dark";
      return themes.midnight;
    case "minimal":
      mode = "light";
      return themes.minimal;
    case "rounded":
      mode = "light";
      return themes.rounded;
    case "nouns":
      mode = "light";
      return themes.nouns;
    default:
      if (props.$useMode === "light") {
        mode = "light";
        return themes.light;
      } else if (props.$useMode === "dark") {
        mode = "dark";
        return themes.dark;
      } else {
        return Ae`
            @media (prefers-color-scheme: light) {
              ${themes.light}
            }
            @media (prefers-color-scheme: dark) {
              ${themes.dark}
            }
          `;
      }
  }
}}

  ${(props) => {
  switch (mode) {
    case "light":
      return globalsLight;
    case "dark":
      return globalsDark;
    default:
      return Ae`
          ${globalsLight}
          @media (prefers-color-scheme: dark) {
            ${globalsDark}
          }
        `;
  }
}}


  ${(props) => {
  var _a2;
  if (props.$customTheme && props.$customTheme["--ck-accent-color"] && ["light", "dark", "auto", "", void 0].includes(props.$useTheme)) {
    const accentColor = props.$customTheme["--ck-accent-color"];
    const accentTextColor = (_a2 = props.$customTheme["--ck-accent-text-color"]) !== null && _a2 !== void 0 ? _a2 : "#ffffff";
    return {
      "--ck-accent-color": accentColor,
      "--ck-accent-text-color": accentTextColor,
      // '--ck-connectbutton-color': accentTextColor,
      // '--ck-connectbutton-background': accentColor,
      // '--ck-connectbutton-background-hover': accentColor,
      // '--ck-connectbutton-background-active': LightenDarkenColor(
      // accentColor,
      // 20
      // ),
      "--ck-secondary-button-background": accentColor,
      "--ck-secondary-button-hover-background": accentColor,
      "--ck-secondary-button-color": accentTextColor,
      "--ck-button-primary-color": accentTextColor,
      "--ck-focus-color": accentColor
    };
  }
  if (props.$customTheme) {
    return createCssColors(props.$customTheme, true);
  }
}}

  all: initial;
  text-align: left;
  text-direction: ltr;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  -webkit-text-stroke: 0.001px transparent;
  text-size-adjust: none;
  font-size: 16px;

  button {
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    -webkit-text-stroke: 0.001px transparent;
  }

  &,
  * {
    font-family: var(--ck-font-family);
    box-sizing: border-box;
    outline: none;
    border: none;
  }
  /*
  @media (prefers-reduced-motion) {
    * {
      animation-duration: 60ms !important;
      transition-duration: 60ms !important;
    }
  }
  */
  img,
  svg {
    max-width: 100%;
  }
  strong {
    font-weight: 600;
  }
  a:focus-visible,
  button:focus-visible {
    outline: 2px solid var(--ck-focus-color);
  }
`;
const Portal = (props) => {
  props = {
    selector: "__CONNECTKIT__",
    ...props
  };
  const { selector, children } = props;
  const ref = reactExports.useRef(null);
  const [mounted, setMounted] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const selectorPrefixed = "#" + selector.replace(/^#/, "");
    ref.current = document.querySelector(selectorPrefixed);
    if (!ref.current) {
      const div = document.createElement("div");
      div.setAttribute("id", selector);
      div.setAttribute("data-connectkit", `${CONNECTKIT_VERSION}`);
      document.body.appendChild(div);
      ref.current = div;
    }
    setMounted(true);
  }, [selector]);
  if (!ref.current)
    return null;
  return mounted ? reactDomExports.createPortal(children, ref.current) : null;
};
const truncateRegex = /^(0x[a-zA-Z0-9]{4})[a-zA-Z0-9]+([a-zA-Z0-9]{4})$/;
const truncateEthAddress = (address2, separator = "••••") => {
  if (!address2)
    return "";
  const match = address2.match(truncateRegex);
  if (!match)
    return address2;
  return `${match[1]}${separator}${match[2]}`;
};
const truncateENSAddress = (ensName, maxLength) => {
  if (ensName.length > maxLength) {
    return ensName.replace(".eth", "").slice(0, maxLength) + "...";
  } else {
    return ensName;
  }
};
const nFormatter = (num, digits = 2) => {
  if (num < 1e4)
    return num.toFixed(2);
  const lookup2 = [
    { value: 1, symbol: "" },
    { value: 1e3, symbol: "k" },
    { value: 1e6, symbol: "m" },
    { value: 1e9, symbol: "g" },
    { value: 1e12, symbol: "t" },
    { value: 1e15, symbol: "p" },
    { value: 1e18, symbol: "e" }
  ];
  const rx = /\.0+$|(\.[0-9]*[1-9])0+$/;
  var item = lookup2.slice().reverse().find(function(item2) {
    return num >= item2.value;
  });
  return item ? (num / item.value).toFixed(digits).replace(rx, "$1") + item.symbol : "0";
};
const detectBrowser = () => {
  var _a2;
  const browser2 = detect();
  return (_a2 = browser2 === null || browser2 === void 0 ? void 0 : browser2.name) !== null && _a2 !== void 0 ? _a2 : "";
};
const detectOS = () => {
  var _a2;
  const browser2 = detect();
  return (_a2 = browser2 === null || browser2 === void 0 ? void 0 : browser2.os) !== null && _a2 !== void 0 ? _a2 : "";
};
const isIOS = () => {
  const os = detectOS();
  return os.toLowerCase().includes("ios");
};
const isAndroid = () => {
  const os = detectOS();
  return os.toLowerCase().includes("android");
};
const isMobile = () => {
  return isAndroid() || isIOS();
};
function flattenChildren(children) {
  const childrenArray = React$1.Children.toArray(children);
  return childrenArray.reduce((flatChildren, child) => {
    if (child.type === React$1.Fragment) {
      return flatChildren.concat(flattenChildren(child.props.children));
    }
    flatChildren.push(child);
    return flatChildren;
  }, []);
}
const isWalletConnectConnector = (connectorId) => connectorId === "walletConnect" || connectorId === "walletConnectLegacy";
const isCoinbaseWalletConnector = (connectorId) => connectorId === "coinbaseWallet";
const isSafeConnector = (connectorId) => connectorId === "safe";
const isInjectedConnector = (connectorId) => connectorId === "injected";
var defaultTheme = {
  mobileWidth: 560
};
const ErrorMessage = styled(motion.div)`
  z-index: -1;
  pointer-events: auto;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  width: var(--width);
  top: 64px;
  color: #fff;
  font-size: 14px;
  line-height: 20px;
  font-weight: 500;
  background: var(--ck-body-color-danger);
  border-radius: 20px;
  padding: 24px 46px 82px 24px;
  transition: width var(--duration) var(--ease);
  a {
    font-weight: 700;
    text-decoration: underline;
  }
  code {
    font-size: 0.9em;
    display: inline-block;
    font-family: monospace;
    margin: 1px;
    padding: 0 4px;
    border-radius: 8px;
    font-weight: bold;
    background: rgba(255, 255, 255, 0.1);
  }
`;
const FadeIn = We`
from { opacity: 0; }
  to { opacity: 1; }
`;
const FadeInScaleUp = We`
from { opacity: 0; transform: scale(0.85); }
  to { opacity: 1; transform: scale(1); }
`;
const FadeInScaleDown = We`
from { opacity: 0; transform: scale(1.1); }
  to { opacity: 1; transform: scale(1); }
`;
const FadeOut = We`
from { opacity: 1; }
  to { opacity: 0; }
`;
const FadeOutScaleUp = We`
from { opacity: 1; transform: scale(1); }
  to { opacity: 0; transform: scale(1.1); }
`;
const FadeOutScaleDown = We`
from { opacity: 1; transform: scale(1); }
  to { opacity: 0; transform: scale(0.85); }
`;
const PageContent = styled(motion.div)`
  max-width: 100%;
  width: 295px;
  padding-top: 48px;
`;
const TextWithHr = styled(motion.div)`
  user-select: none;
  position: relative;
  display: block;
  text-align: center;
  color: var(--ck-body-color-muted);
  font-size: 15px;
  font-weight: 400;
  line-height: 21px;
  span {
    z-index: 2;
    position: relative;
    display: inline-block;
    user-select: none;
    pointer-events: none;
    padding: 0 14px;
    background: var(--ck-body-background);
    transition: background-color 200ms ease;
  }
  &:before {
    z-index: 2;
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 1px;
    transform: translateY(-1px);
    background: var(--ck-body-divider);
    box-shadow: var(--ck-body-divider-box-shadow);
  }
`;
const ModalHeading = styled(motion.div)`
  z-index: 3;
  pointer-events: none;
  user-select: none;
  position: absolute;
  top: 25px;
  left: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 26px;
  transform: translateX(-50%);
  width: var(--width);
  text-align: center;
  font-size: 17px;
  line-height: 20px;
  font-weight: var(--ck-modal-heading-font-weight, 600);
  color: var(--ck-body-color);
  span {
    display: inline-block;
  }
`;
const ModalContentContainer = styled(motion.div)`
  position: relative;
  padding: 0;
`;
const ModalContent = styled(motion.div)`
  left: 0;
  right: 0;
  text-align: center;
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 0 0 16px;

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    display: block;
  }
`;
const ModalH1 = styled(motion.h1)`
  margin: 0;
  padding: 0;
  line-height: ${(props) => props.$small ? 20 : 22}px;
  font-size: ${(props) => props.$small ? 17 : 19}px;
  font-weight: var(--ck-modal-h1-font-weight, 600);
  color: ${(props) => {
  if (props.$error)
    return "var(--ck-body-color-danger)";
  if (props.$valid)
    return "var(--ck-body-color-valid)";
  return "var(--ck-body-color)";
}};
  > svg {
    position: relative;
    top: -2px;
    display: inline-block;
    vertical-align: middle;
    margin-right: 6px;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    margin-bottom: 6px;
    font-size: 17px;
  }
`;
const ModalBody = styled.div`
  font-size: 16px;
  font-weight: 400;
  line-height: 21px;
  color: var(--ck-body-color-muted);
  strong {
    font-weight: 500;
    color: var(--ck-body-color);
  }
`;
styled.div`
  padding: 0 12px;
  font-size: 13px;
  font-weight: 400;
  line-height: 16px;
  color: var(--ck-body-color-muted);
  strong {
    font-weight: 500;
    color: var(--ck-body-color);
  }
`;
const BackgroundOverlay = styled(motion.div)`
  z-index: 1;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: var(--ck-overlay-background, rgba(71, 88, 107, 0.24));
  backdrop-filter: ${(props) => props.$blur ? `blur(${props.$blur}px)` : "var(--ck-overlay-backdrop-filter, none)"};
  opacity: 0;
  animation: ${(props) => props.$active ? FadeIn : FadeOut} 150ms ease-out
    both;
`;
const BoxIn = We`
  from{ opacity: 0; transform: scale(0.97); }
  to{ opacity: 1; transform: scale(1); }
`;
const BoxOut = We`
  from{ opacity: 1; transform: scale(1); }
  to{ opacity: 0; transform: scale(0.97); }
`;
const MobileBoxIn = We`
  from { transform: translate3d(0, 100%, 0); }
  to { transform: translate3d(0, 0%, 0); }
`;
const MobileBoxOut = We`
  from { opacity: 1; }
  to { opacity: 0; }
`;
const BoxContainer = styled(motion.div)`
  z-index: 2;
  position: relative;
  color: var(--ck-body-color);

  animation: 150ms ease both;
  animation-name: ${BoxOut};
  &.active {
    animation-name: ${BoxIn};
  }

  &:before {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 50%;
    width: var(--width);
    height: var(--height);
    transform: translateX(-50%);
    backface-visibility: hidden;
    transition: all 200ms ease;
    border-radius: var(--ck-border-radius, 20px);
    background: var(--ck-body-background);
    box-shadow: var(--ck-modal-box-shadow);
  }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    animation-name: ${MobileBoxOut};
    animation-duration: 130ms;
    animation-timing-function: ease;

    &.active {
      animation-name: ${MobileBoxIn};
      animation-duration: 300ms;
      animation-delay: 32ms;
      animation-timing-function: cubic-bezier(0.15, 1.15, 0.6, 1);
    }

    &:before {
      width: 100%;
      transition: 0ms height cubic-bezier(0.15, 1.15, 0.6, 1);
      will-change: height;
    }
  }
`;
const ControllerContainer = styled(motion.div)`
  z-index: 3;
  position: absolute;
  top: 0;
  left: 50%;
  height: 64px;
  transform: translateX(-50%);
  backface-visibility: hidden;
  width: var(--width);
  transition: 0.2s ease width;
  pointer-events: auto;
  //border-bottom: 1px solid var(--ck-body-divider);
`;
const InnerContainer$1 = styled(motion.div)`
  position: relative;
  overflow: hidden;
  height: var(--height);
  transition: 0.2s ease height;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    transition: 0ms height cubic-bezier(0.15, 1.15, 0.6, 1);
    /* animation-delay: 34ms; */
  }
`;
const PageContainer = styled(motion.div)`
  z-index: 2;
  position: relative;
  top: 0;
  left: 50%;
  margin-left: calc(var(--width) / -2);
  width: var(--width);
  /* left: 0; */
  /* width: 100%; */
  display: flex;
  justify-content: center;
  align-items: center;
  transform-origin: center center;
  animation: 200ms ease both;

  &.active {
    animation-name: ${FadeInScaleDown};
  }
  &.active-scale-up {
    animation-name: ${FadeInScaleUp};
  }
  &.exit-scale-down {
    z-index: 1;
    pointer-events: none;
    position: absolute;
    /* top: 0; */
    /* left: 0; */
    animation-name: ${FadeOutScaleDown};
  }
  &.exit {
    z-index: 1;
    pointer-events: none;
    position: absolute;
    /* top: 0; */
    /* left: 0; */
    /* left: 50%; */
    /* transform: translateX(-50%); */
    animation-name: ${FadeOutScaleUp};
    animation-delay: 16.6667ms;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    /* animation: 0ms ease both; */
    /* animation-delay: 35ms; */
    animation: 0ms cubic-bezier(0.15, 1.15, 0.6, 1) both;

    &.active {
      animation-name: ${FadeIn};
    }
    &.active-scale-up {
      animation-name: ${FadeIn};
    }
    &.exit-scale-down {
      z-index: 3;
      animation-name: ${FadeOut};
    }
    &.exit {
      z-index: 3;
      animation-name: ${FadeOut};
      animation-delay: 0ms;
    }
  }
`;
const PageContents = styled(motion.div)`
  margin: 0 auto;
  width: fit-content;
  padding: 29px 24px 24px;
  backface-visibility: hidden;
`;
const ModalContainer = styled.div`
  z-index: 2147483646; // z-index set one below max (2147483647) for if we wish to layer things ontop of the modal in a seperate Portal
  position: fixed;
  inset: 0;
`;
const CloseButton = styled(motion.button)`
  z-index: 3;
  cursor: pointer;
  position: absolute;
  top: 22px;
  right: 17px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  padding: 0;
  margin: 0;
  color: var(--ck-body-action-color);
  background: var(--ck-body-background);
  transition: background-color 200ms ease, transform 100ms ease;
  /* will-change: transform; */
  svg {
    display: block;
  }

  &:hover {
    background: var(--ck-body-background-secondary);
  }
  &:active {
    transform: scale(0.9);
  }
`;
const SiweButton = styled(motion.button)`
  z-index: 3;
  position: absolute;
  inset: 0;
  width: 100%; // FireFox fix
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  padding: 0;
  margin: 0;
  color: var(--ck-body-action-color);
  background: var(--ck-body-background);
  transition: background-color 200ms ease, transform 100ms ease;
  /* will-change: transform; */
  svg {
    display: block;
    position: relative;
  }

  &:enabled {
    cursor: pointer;
    &:hover {
      background: var(--ck-body-background-secondary);
    }
    &:active {
      transform: scale(0.9);
    }
  }
`;
const BackButton = styled(motion.button)`
  z-index: 3;
  position: absolute;
  inset: 0;
  width: 100%; // FireFox fix
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  padding: 0;
  margin: 0;
  color: var(--ck-body-action-color);
  background: var(--ck-body-background);
  transition: background-color 200ms ease, transform 100ms ease;
  /* will-change: transform; */
  svg {
    display: block;
    position: relative;
    left: -1px;
  }

  &:enabled {
    cursor: pointer;
    &:hover {
      background: var(--ck-body-background-secondary);
    }
    &:active {
      transform: scale(0.9);
    }
  }
`;
const InfoButton = styled(motion.button)`
  z-index: 3;
  position: absolute;
  inset: 0;
  width: 100%; // FireFox fix
  transform: translateX(-1px);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  padding: 0;
  margin: 0;
  color: var(--ck-body-action-color);
  background: var(--ck-body-background);
  transition: background-color 200ms ease, transform 100ms ease;
  /* will-change: transform; */
  svg {
    display: block;
    position: relative;
  }
  &:enabled {
    cursor: pointer;
    &:hover {
      background: var(--ck-body-background-secondary);
    }
    &:active {
      transform: scale(0.9);
    }
  }
`;
const Container$7 = styled(motion.div)`
  --ease: cubic-bezier(0.25, 0.1, 0.25, 1);
  --duration: 200ms;
  --transition: height var(--duration) var(--ease),
    width var(--duration) var(--ease);
  z-index: 3;
  display: block;
  pointer-events: none;
  position: absolute;
  left: 50%;
  top: 50%;
  width: 100%;
  transform: translate3d(-50%, -50%, 0);
  backface-visibility: hidden;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    pointer-events: auto;
    left: 0;
    top: auto;
    bottom: -5px;
    transform: none;
    ${BoxContainer} {
      max-width: 448px;
      margin: 0 auto;
      &:before {
        width: 100%;
        border-radius: var(--ck-border-radius, 30px)
          var(--ck-border-radius, 30px) 0 0;
      }
    }
    ${PageContainer} {
      left: 0;
      right: 0;
      margin: 0 auto;
      width: auto;
    }
    ${PageContent} {
      margin: 0 auto;
      width: 100% !important;
    }
    ${ModalHeading} {
      top: 29px;
    }
    ${ModalContent} {
      gap: 12px;
    }
    ${ModalBody} {
      margin: 0 auto;
      max-width: 295px;
    }
    ${PageContents} {
      width: 100%;
      padding: 31px 24px;
    }
    ${ControllerContainer} {
      width: 100%;
      top: 4px;
      border-bottom: 0;
    }
    ${CloseButton} {
      right: 22px;
    }
    ${BackButton} {
      top: -1px;
      left: -3px;
    }
    ${InfoButton} {
      top: -1px;
      left: -3px;
      svg {
        width: 65%;
        height: auto;
      }
    }
    ${CloseButton},
    ${BackButton},
    ${InfoButton} {
      // Quick hack for bigger tappable area on mobile
      transform: scale(1.4) !important;
      background: transparent !important;
      svg {
        transform: scale(0.8) !important;
      }
    }
  }
`;
const Disclaimer = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 16px -24px -24px -24px;
  padding: 15px 40px 18px;
  font-size: var(--ck-body-disclaimer-font-size, 13px);
  font-weight: var(--ck-body-disclaimer-font-weight, 400);
  text-align: center;
  line-height: 19px;
  color: var(--ck-body-disclaimer-color, var(--ck-body-color-muted, inherit));

  & a {
    color: var(--ck-body-disclaimer-link-color, inherit);
    font-weight: var(--ck-body-disclaimer-font-weight, 400);
    text-decoration: none;
    transition: color 200ms ease;
    &:hover {
      color: var(--ck-body-disclaimer-link-hover-color, inherit);
    }
  }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    margin: 24px -24px -26px -24px;
    padding: 20px 42px 22px 42px;
  }
`;
const DisclaimerBackground = styled(motion.div)`
  pointer-events: all;
  z-index: 9;
  position: absolute;
  bottom: 0;
  left: 50%;
  width: var(--width);
  backface-visibility: hidden;
  transform: translateX(-50%);
  transform-origin: bottom center;

  border-radius: var(--ck-border-radius, 30px);
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  transition: width 200ms ease;

  background: var(
    --ck-body-disclaimer-background,
    var(--ck-body-background-secondary)
  );
  box-shadow: var(--ck-body-disclaimer-box-shadow);

  ${Disclaimer} {
    margin: 0 !important;
    /* visibility: hidden; */
  }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    border-radius: 0;
  }
`;
const SignInTooltip = styled(motion.div)`
  z-index: 2;
  position: absolute;
  top: 100%;
  white-space: nowrap;
  padding: 8px 16px;
  color: #fff;
  font-size: 13px;
  line-height: 1.5;
  background: #1a88f8;
  border-radius: calc(var(--ck-border-radius) * 0.75);
  transform: translateY(8px) translateX(-48px);
  box-shadow: var(--ck-modal-box-shadow);
  &:before {
    content: '';
    position: absolute;
    box-shadow: var(--shadow);
    width: 18px;
    height: 18px;
    transform: translate(215%, -75%) rotate(45deg);
    background: inherit;
    border-radius: 3px 0 0 0;
  }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    transform: translateY(8px) translateX(-16px);
    &:before {
      transform: translate(40%, -75%) rotate(45deg);
    }
  }
`;
const useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useLockBodyScroll(initialLocked) {
  const [locked, setLocked] = reactExports.useState(initialLocked);
  const context = useContext();
  useIsomorphicLayoutEffect(() => {
    var _a2;
    if (!locked)
      return;
    const original = {
      overflow: document.body.style.overflow,
      position: document.body.style.position,
      touchAction: document.body.style.touchAction,
      paddingRight: document.body.style.paddingRight
      //htmlOverflow: document.documentElement.style.overflow,
    };
    const style2 = getComputedStyle(document.body);
    const offsetX = parseInt(style2.marginRight) + parseInt(style2.paddingRight) + parseInt(style2.borderRight) + parseInt(style2.marginLeft) + parseInt(style2.paddingLeft) + parseInt(style2.borderLeft);
    const scrollBarWidth = window.innerWidth - document.body.offsetWidth - offsetX;
    document.documentElement.style.setProperty("--ck-scrollbar-width", `${scrollBarWidth}px`);
    document.body.style.overflow = "hidden";
    document.body.style.position = "relative";
    document.body.style.touchAction = "none";
    if ((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.avoidLayoutShift) {
      document.body.style.paddingRight = `${scrollBarWidth}px`;
    }
    return () => {
      var _a3;
      document.documentElement.style.removeProperty("--ck-scrollbar-width");
      document.body.style.overflow = original.overflow;
      document.body.style.position = original.position;
      document.body.style.touchAction = original.touchAction;
      if ((_a3 = context.options) === null || _a3 === void 0 ? void 0 : _a3.avoidLayoutShift) {
        document.body.style.paddingRight = original.paddingRight;
      }
    };
  }, [locked]);
  reactExports.useEffect(() => {
    if (locked !== initialLocked)
      setLocked(initialLocked);
  }, [initialLocked]);
  return [locked, setLocked];
}
const KEYCODE_TAB = 9;
function useFocusTrap() {
  const elRef = reactExports.useRef(null);
  function handleFocus(e2) {
    if (!elRef.current)
      return;
    var focusableEls = elRef.current.querySelectorAll(`
        a[href]:not(:disabled),
        button:not(:disabled),
        textarea:not(:disabled),
        input[type="text"]:not(:disabled),
        input[type="radio"]:not(:disabled),
        input[type="checkbox"]:not(:disabled),
        select:not(:disabled)
      `), firstFocusableEl = focusableEls[0], lastFocusableEl = focusableEls[focusableEls.length - 1];
    var isTabPressed = e2.key === "Tab" || e2.keyCode === KEYCODE_TAB;
    if (!isTabPressed) {
      return;
    }
    if (e2.shiftKey) {
      if (document.activeElement === firstFocusableEl) {
        lastFocusableEl.focus();
        e2.preventDefault();
      }
    } else {
      if (document.activeElement === lastFocusableEl) {
        firstFocusableEl.focus();
        e2.preventDefault();
      }
    }
  }
  reactExports.useEffect(() => {
    if (elRef.current) {
      elRef.current.addEventListener("keydown", handleFocus);
      elRef.current.focus({ preventScroll: true });
    }
    return () => {
      if (elRef.current) {
        elRef.current.removeEventListener("keydown", handleFocus);
      }
    };
  }, []);
  return elRef;
}
function FocusTrap(props) {
  const elRef = useFocusTrap();
  reactExports.useEffect(() => {
    if (!elRef.current)
      return;
    elRef.current.focus({ preventScroll: true });
  }, []);
  return jsx("div", { ref: elRef, tabIndex: 0, children: props.children });
}
function usePrevious(value, initial) {
  const ref = reactExports.useRef({ target: value, previous: initial });
  if (ref.current.target !== value) {
    ref.current.previous = ref.current.target;
    ref.current.target = value;
  }
  return ref.current.previous;
}
const Context$1 = reactExports.createContext(null);
const ConnectKitThemeProvider = ({ children, theme = "auto", mode: mode2 = "auto", customTheme }) => {
  const value = {
    theme,
    mode: mode2,
    customTheme
  };
  return reactExports.createElement(Context$1.Provider, { value }, jsx(Fragment$2, { children }));
};
const useThemeContext = () => {
  const context = React$1.useContext(Context$1);
  if (!context)
    throw Error("ConnectKitThemeProvider must be inside a Provider.");
  return context;
};
const Scan = ({ ...props }) => jsx("svg", { "aria-hidden": "true", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0 2.82561C0 1.26507 1.26507 0 2.82561 0H4.59161C6.15215 0 7.41722 1.26507 7.41722 2.82561V4.59161C7.41722 6.15215 6.15215 7.41722 4.59161 7.41722H2.82561C1.26507 7.41722 0 6.15215 0 4.59161V2.82561ZM2.82561 1.69536C2.20139 1.69536 1.69536 2.20139 1.69536 2.82561V4.59161C1.69536 5.21583 2.20139 5.72185 2.82561 5.72185H4.59161C5.21583 5.72185 5.72185 5.21583 5.72185 4.59161V2.82561C5.72185 2.20139 5.21583 1.69536 4.59161 1.69536H2.82561ZM0 11.4084C0 9.84791 1.26507 8.58284 2.82561 8.58284H4.59161C6.15215 8.58284 7.41722 9.8479 7.41722 11.4084V13.1744C7.41722 14.735 6.15215 16.0001 4.59161 16.0001H2.82561C1.26507 16.0001 0 14.735 0 13.1744V11.4084ZM2.82561 10.2782C2.20139 10.2782 1.69536 10.7842 1.69536 11.4084V13.1744C1.69536 13.7987 2.20139 14.3047 2.82561 14.3047H4.59161C5.21583 14.3047 5.72185 13.7987 5.72185 13.1744V11.4084C5.72185 10.7842 5.21583 10.2782 4.59161 10.2782H2.82561ZM11.4083 0C9.84779 0 8.58272 1.26507 8.58272 2.82561V4.59161C8.58272 6.15215 9.84779 7.41722 11.4083 7.41722H13.1743C14.7349 7.41722 15.9999 6.15215 15.9999 4.59161V2.82561C15.9999 1.26507 14.7349 0 13.1743 0H11.4083ZM10.2781 2.82561C10.2781 2.20139 10.7841 1.69536 11.4083 1.69536H13.1743C13.7985 1.69536 14.3046 2.20139 14.3046 2.82561V4.59161C14.3046 5.21583 13.7985 5.72185 13.1743 5.72185H11.4083C10.7841 5.72185 10.2781 5.21583 10.2781 4.59161V2.82561ZM15.7351 9.96026C15.7351 10.7795 15.0709 11.4437 14.2516 11.4437C13.4323 11.4437 12.7682 10.7795 12.7682 9.96026C12.7682 9.14098 13.4323 8.47682 14.2516 8.47682C15.0709 8.47682 15.7351 9.14098 15.7351 9.96026ZM9.96026 11.4437C10.7795 11.4437 11.4437 10.7795 11.4437 9.96026C11.4437 9.14098 10.7795 8.47682 9.96026 8.47682C9.14098 8.47682 8.47682 9.14098 8.47682 9.96026C8.47682 10.7795 9.14098 11.4437 9.96026 11.4437ZM15.7351 14.2517C15.7351 15.071 15.0709 15.7352 14.2516 15.7352C13.4323 15.7352 12.7682 15.071 12.7682 14.2517C12.7682 13.4325 13.4323 12.7683 14.2516 12.7683C15.0709 12.7683 15.7351 13.4325 15.7351 14.2517ZM9.96026 15.7352C10.7795 15.7352 11.4437 15.071 11.4437 14.2517C11.4437 13.4325 10.7795 12.7683 9.96026 12.7683C9.14098 12.7683 8.47682 13.4325 8.47682 14.2517C8.47682 15.071 9.14098 15.7352 9.96026 15.7352Z", fill: "currentColor", fillOpacity: "0.3" }) });
const ExternalLinkIcon = ({ ...props }) => jsxs("svg", { "aria-hidden": "true", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  left: 0,
  top: 0
}, ...props, children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 4C2.89543 4 2 4.89543 2 6V12C2 13.1046 2.89543 14 4 14H10C11.1046 14 12 13.1046 12 12V9.66667C12 9.11438 12.4477 8.66667 13 8.66667C13.5523 8.66667 14 9.11438 14 9.66667V12C14 14.2091 12.2091 16 10 16H4C1.79086 16 0 14.2091 0 12V6C0 3.79086 1.79086 2 4 2H6.33333C6.88562 2 7.33333 2.44772 7.33333 3C7.33333 3.55228 6.88562 4 6.33333 4H4Z", fill: "currentColor", fillOpacity: 0.3 }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.5 1C9.5 0.447715 9.94772 0 10.5 0H15C15.5523 0 16 0.447715 16 1V5.5C16 6.05228 15.5523 6.5 15 6.5C14.4477 6.5 14 6.05228 14 5.5V3.41421L8.70711 8.70711C8.31658 9.09763 7.68342 9.09763 7.29289 8.70711C6.90237 8.31658 6.90237 7.68342 7.29289 7.29289L12.5858 2H10.5C9.94772 2 9.5 1.55228 9.5 1Z", fill: "currentColor", fillOpacity: 0.3 })] });
const AlertIcon = ({ ...props }) => {
  return jsxs("svg", { "aria-hidden": "true", width: "19", height: "18", viewBox: "0 0 19 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.81753 1.60122C7.39283 0.530035 8.46953 0 9.50409 0C10.5507 0 11.6022 0.539558 12.1805 1.59767L18.6047 13.3334C18.882 13.8283 19 14.3568 19 14.8622C19 16.5296 17.7949 18 15.9149 18H3.08514C1.20508 18 0 16.5296 0 14.8622C0 14.3454 0.131445 13.8172 0.405555 13.3379L6.81753 1.60122ZM9.50409 2C9.13355 2 8.77256 2.18675 8.57866 2.54907L8.57458 2.5567L2.14992 14.3166L2.144 14.3268C2.04638 14.4959 2 14.6817 2 14.8622C2 15.5497 2.43032 16 3.08514 16H15.9149C16.5697 16 17 15.5497 17 14.8622C17 14.6681 16.9554 14.4805 16.8588 14.309L16.8529 14.2986L10.4259 2.55741C10.2191 2.1792 9.86395 2 9.50409 2Z", fill: "currentColor" }), jsx("path", { d: "M9.5 11.2297C9.01639 11.2297 8.7459 10.9419 8.72951 10.4186L8.60656 6.4157C8.59016 5.88372 8.95902 5.5 9.4918 5.5C10.0164 5.5 10.4016 5.89244 10.3852 6.42442L10.2623 10.4099C10.2377 10.9419 9.96721 11.2297 9.5 11.2297ZM9.5 14.5C8.95082 14.5 8.5 14.0901 8.5 13.5058C8.5 12.9215 8.95082 12.5116 9.5 12.5116C10.0492 12.5116 10.5 12.9128 10.5 13.5058C10.5 14.0988 10.041 14.5 9.5 14.5Z", fill: "currentColor" })] });
};
const DisconnectIcon = ({ ...props }) => {
  return jsx("svg", { "aria-hidden": "true", width: "15", height: "14", viewBox: "0 0 15 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
    left: 0,
    top: 0
  }, ...props, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 0C1.79086 0 0 1.79086 0 4V10C0 12.2091 1.79086 14 4 14H6C6.55228 14 7 13.5523 7 13C7 12.4477 6.55228 12 6 12H4C2.89543 12 2 11.1046 2 10V4C2 2.89543 2.89543 2 4 2H6C6.55228 2 7 1.55228 7 1C7 0.447715 6.55228 0 6 0H4ZM11.7071 3.29289C11.3166 2.90237 10.6834 2.90237 10.2929 3.29289C9.90237 3.68342 9.90237 4.31658 10.2929 4.70711L11.5858 6H9.5H6C5.44772 6 5 6.44772 5 7C5 7.55228 5.44772 8 6 8H9.5H11.5858L10.2929 9.29289C9.90237 9.68342 9.90237 10.3166 10.2929 10.7071C10.6834 11.0976 11.3166 11.0976 11.7071 10.7071L14.7071 7.70711C15.0976 7.31658 15.0976 6.68342 14.7071 6.29289L11.7071 3.29289Z", fill: "currentColor", fillOpacity: "0.4" }) });
};
const TickIcon = ({ ...props }) => {
  return jsx("svg", { "aria-hidden": "true", width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9 18C13.9706 18 18 13.9706 18 9C18 4.02944 13.9706 0 9 0C4.02944 0 0 4.02944 0 9C0 13.9706 4.02944 18 9 18ZM13.274 7.13324C13.6237 6.70579 13.5607 6.07577 13.1332 5.72604C12.7058 5.37632 12.0758 5.43932 11.726 5.86676L7.92576 10.5115L6.20711 8.79289C5.81658 8.40237 5.18342 8.40237 4.79289 8.79289C4.40237 9.18342 4.40237 9.81658 4.79289 10.2071L7.29289 12.7071C7.49267 12.9069 7.76764 13.0128 8.04981 12.9988C8.33199 12.9847 8.59505 12.8519 8.77396 12.6332L13.274 7.13324Z", fill: "currentColor" }) });
};
const RetryIconCircle = ({ ...props }) => {
  return jsx("svg", { "aria-hidden": "true", width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M32 16C32 24.8366 24.8366 32 16 32C7.16344 32 0 24.8366 0 16C0 7.16344 7.16344 0 16 0C24.8366 0 32 7.16344 32 16ZM24.5001 8.74263C25.0834 8.74263 25.5563 9.21551 25.5563 9.79883V14.5997C25.5563 15.183 25.0834 15.6559 24.5001 15.6559H19.6992C19.1159 15.6559 18.643 15.183 18.643 14.5997C18.643 14.0164 19.1159 13.5435 19.6992 13.5435H21.8378L20.071 11.8798C20.0632 11.8724 20.0555 11.865 20.048 11.8574C19.1061 10.915 17.8835 10.3042 16.5643 10.1171C15.2452 9.92999 13.9009 10.1767 12.7341 10.82C11.5674 11.4634 10.6413 12.4685 10.0955 13.684C9.54968 14.8994 9.41368 16.2593 9.70801 17.5588C10.0023 18.8583 10.711 20.0269 11.7273 20.8885C12.7436 21.7502 14.0124 22.2582 15.3425 22.336C16.6726 22.4138 17.9919 22.0572 19.1017 21.3199C19.5088 21.0495 19.8795 20.7333 20.2078 20.3793C20.6043 19.9515 21.2726 19.9262 21.7004 20.3228C22.1282 20.7194 22.1534 21.3876 21.7569 21.8154C21.3158 22.2912 20.8176 22.7161 20.2706 23.0795C18.7793 24.0702 17.0064 24.5493 15.2191 24.4448C13.4318 24.3402 11.7268 23.6576 10.3612 22.4998C8.9956 21.3419 8.0433 19.7716 7.6478 18.0254C7.2523 16.2793 7.43504 14.4519 8.16848 12.8186C8.90192 11.1854 10.1463 9.83471 11.7142 8.97021C13.282 8.10572 15.0884 7.77421 16.861 8.02565C18.6282 8.27631 20.2664 9.09278 21.5304 10.3525L23.4439 12.1544V9.79883C23.4439 9.21551 23.9168 8.74263 24.5001 8.74263Z", fill: "currentColor" }) });
};
const RetryIcon = ({ ...props }) => jsxs("svg", { "aria-hidden": "true", width: "16", height: "14", viewBox: "0 0 16 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [jsx("path", { d: "M14.5 2V6H10.5", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M14 5.66537L10.9899 2.75871C10.0931 1.83853 8.92897 1.24216 7.6729 1.05947C6.41683 0.876774 5.13688 1.11765 4.02592 1.7458C2.91497 2.37395 2.0332 3.35534 1.5135 4.54208C0.993792 5.72883 0.864305 7.05663 1.14455 8.3254C1.42479 9.59418 2.09958 10.7352 3.06724 11.5765C4.03489 12.4178 5.24298 12.9138 6.50946 12.9898C7.77594 13.0657 9.03219 12.7176 10.0889 11.9977C10.4765 11.7337 10.8295 11.4249 11.142 11.0792", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" })] });
const CopyToClipboardIcon$1 = ({ ...props }) => jsxs("svg", { "aria-hidden": "true", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [jsx("path", { d: "M14 9.5V7C14 5.89543 13.1046 5 12 5H7C5.89543 5 5 5.89543 5 7V12C5 13.1046 5.89543 14 7 14H9.5", stroke: "var(--ck-body-color-muted)", strokeWidth: "2" }), jsx("rect", { x: "10", y: "10", width: "9", height: "9", rx: "2", stroke: "var(--ck-body-color-muted)", strokeWidth: "2" }), jsx("path", { d: "M1 3L3 5L7 1", stroke: "var(--ck-body-color)", strokeWidth: "1.75", strokeLinecap: "round", strokeLinejoin: "round" })] });
const AuthIcon = ({ ...props }) => jsx("div", { ...props, style: {
  zIndex: 2,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  position: "absolute",
  bottom: 0,
  right: 0,
  background: "#34C759",
  borderRadius: 10,
  boxShadow: "0 0 0 1.5px var(--background)",
  width: 10,
  height: 10,
  ...props === null || props === void 0 ? void 0 : props.style
}, children: jsx("svg", { "aria-hidden": "true", width: "6", height: "6", viewBox: "0 0 6 6", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M0.75 3L2.25 4.5L5.25 1.5", stroke: "white", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }) }) });
var StatusState;
(function(StatusState2) {
  StatusState2["READY"] = "ready";
  StatusState2["LOADING"] = "loading";
  StatusState2["SUCCESS"] = "success";
  StatusState2["REJECTED"] = "rejected";
  StatusState2["ERROR"] = "error";
})(StatusState || (StatusState = {}));
const SIWEContext = reactExports.createContext(null);
const useSIWE = ({ onSignIn, onSignOut } = {}) => {
  const siweContextValue = reactExports.useContext(SIWEContext);
  if (!siweContextValue) {
    return {
      isSignedIn: false,
      data: void 0,
      status: StatusState.ERROR,
      error: new Error("useSIWE hook must be inside a SIWEProvider."),
      isRejected: false,
      isError: true,
      isLoading: false,
      isSuccess: false,
      isReady: false,
      reset: () => {
      },
      signIn: () => Promise.reject(),
      signOut: () => Promise.reject()
    };
  }
  const { session, nonce, status, signOut, signIn, resetStatus } = siweContextValue;
  const { address: address2, chainId } = session.data || {};
  const currentStatus = address2 ? StatusState.SUCCESS : session.isLoading || nonce.isLoading ? StatusState.LOADING : status;
  const isLoading = currentStatus === StatusState.LOADING;
  const isSuccess = currentStatus === StatusState.SUCCESS;
  const isRejected = currentStatus === StatusState.REJECTED;
  const isError = currentStatus === StatusState.ERROR;
  const isReady = !address2 || nonce.isFetching || isLoading || isSuccess;
  const reset3 = () => resetStatus();
  const isSignedIn = !!address2;
  return {
    isSignedIn,
    data: isSignedIn ? {
      address: address2,
      chainId
    } : void 0,
    status: currentStatus,
    error: session.error || nonce.error,
    isRejected,
    isError,
    isLoading,
    isSuccess,
    isReady,
    signIn: async () => {
      if (!isSignedIn) {
        const data2 = await signIn();
        if (data2)
          onSignIn === null || onSignIn === void 0 ? void 0 : onSignIn(data2);
      }
    },
    signOut: async () => {
      if (isSignedIn) {
        await signOut();
        onSignOut === null || onSignOut === void 0 ? void 0 : onSignOut();
      }
    },
    reset: reset3
  };
};
const isWalletInstalled = (name2) => {
  if (typeof window === "undefined")
    return false;
  const { ethereum } = window;
  return !!((ethereum === null || ethereum === void 0 ? void 0 : ethereum[`is${name2}`]) || (ethereum === null || ethereum === void 0 ? void 0 : ethereum.providers) && (ethereum === null || ethereum === void 0 ? void 0 : ethereum.providers.find((provider2) => provider2 === null || provider2 === void 0 ? void 0 : provider2[`is${name2}`])));
};
const isMetaMask = () => isWalletInstalled("MetaMask");
const isCoinbaseWallet = () => isWalletInstalled("CoinbaseWallet");
const isFamily = () => isWalletInstalled("Family");
const isBrave = () => isWalletInstalled("BraveWallet");
const isDawn = () => isWalletInstalled("Dawn");
const isFrame = () => isWalletInstalled("Frame");
const isPhantom = () => isWalletInstalled("Phantom");
const isInfinityWallet = () => isWalletInstalled("InfinityWallet");
const isRabby = () => isWalletInstalled("Rabby");
const isFrontier = () => isWalletInstalled("Frontier");
const isTrust = () => {
  var _a2, _b;
  if (typeof window === "undefined")
    return false;
  return isWalletInstalled("Trust") || ((_a2 = window === null || window === void 0 ? void 0 : window.trustWallet) === null || _a2 === void 0 ? void 0 : _a2.isTrust) || ((_b = window === null || window === void 0 ? void 0 : window.trustwallet) === null || _b === void 0 ? void 0 : _b.isTrust);
};
const isTokenPocket = () => isWalletInstalled("TokenPocket");
const isTalisman = () => isWalletInstalled("Talisman");
const isFordefi = () => isWalletInstalled("Fordefi");
const isRainbow = () => isWalletInstalled("Rainbow");
const isZerion = () => isWalletInstalled("Zerion");
const Injected = ({ ...props }) => jsx("svg", { ...props, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.6505 3.64041C15.6501 3.64062 15.6497 3.64083 15.6493 3.64103L6.05165 8.43985L16.2501 13.5391L26.4484 8.43987L16.8508 3.64103C16.8504 3.64083 16.85 3.64063 16.8496 3.64043C16.6632 3.54806 16.458 3.5 16.25 3.5C16.042 3.5 15.8369 3.54806 15.6505 3.64041ZM28 10.4592L17.5001 15.7091L17.5 28.5205L27.248 23.6465L27.2508 23.6452C27.4757 23.5334 27.665 23.3611 27.7973 23.1477C27.9297 22.9342 27.9999 22.6881 28 22.4369V10.4592ZM15 28.527L15.0001 15.7091L4.50006 10.4591V22.4333C4.49831 22.6849 4.56687 22.9319 4.69807 23.1466C4.82896 23.3608 5.01696 23.5342 5.24095 23.6475C5.24148 23.6477 5.242 23.648 5.24253 23.6483L15 28.527ZM14.5207 31.0824L4.12104 25.8826L4.11759 25.8809C3.47681 25.558 2.93902 25.0625 2.56486 24.4502C2.19154 23.8394 1.99597 23.1365 2.00006 22.4207V10.0486C2.00044 9.33234 2.20062 8.62972 2.5781 8.021C2.95529 7.41274 3.49457 6.92167 4.13537 6.60291C4.13585 6.60267 4.13633 6.60243 4.13681 6.60219L14.534 1.40359L14.5368 1.40221C15.0692 1.13767 15.6556 1 16.25 1C16.8445 1 17.4309 1.13767 17.9633 1.40221L17.966 1.40358L28.3633 6.60219C28.3638 6.60245 28.3643 6.6027 28.3648 6.60295C29.0055 6.92171 29.5448 7.41276 29.922 8.021C30.2994 8.62973 30.4996 9.33168 30.5 10.0479V22.4376C30.4996 23.1538 30.2994 23.8565 29.922 24.4652C29.5448 25.0734 29.0056 25.5644 28.365 25.8831C28.3644 25.8834 28.3638 25.8837 28.3633 25.884L17.9664 31.0824C17.9663 31.0825 17.9665 31.0824 17.9664 31.0824C17.4316 31.3499 16.8415 31.4894 16.2435 31.4894C15.6455 31.4894 15.0554 31.3499 14.5207 31.0824C14.5205 31.0824 14.5208 31.0825 14.5207 31.0824Z", fill: "#CCCCCC" }) });
const WalletConnect = ({ background = false, ...props }) => jsx("svg", { ...props, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: background ? { background: "var(--ck-brand-walletConnect)" } : void 0, children: jsx("path", { d: "M9.58818 11.8556C13.1293 8.31442 18.8706 8.31442 22.4117 11.8556L22.8379 12.2818C23.015 12.4588 23.015 12.7459 22.8379 12.9229L21.3801 14.3808C21.2915 14.4693 21.148 14.4693 21.0595 14.3808L20.473 13.7943C18.0026 11.3239 13.9973 11.3239 11.5269 13.7943L10.8989 14.4223C10.8104 14.5109 10.6668 14.5109 10.5783 14.4223L9.12041 12.9645C8.94336 12.7875 8.94336 12.5004 9.12041 12.3234L9.58818 11.8556ZM25.4268 14.8706L26.7243 16.1682C26.9013 16.3452 26.9013 16.6323 26.7243 16.8093L20.8737 22.6599C20.6966 22.8371 20.4096 22.8371 20.2325 22.6599L16.0802 18.5076C16.0359 18.4634 15.9641 18.4634 15.9199 18.5076L11.7675 22.6599C11.5905 22.8371 11.3034 22.8371 11.1264 22.66C11.1264 22.66 11.1264 22.6599 11.1264 22.6599L5.27561 16.8092C5.09856 16.6322 5.09856 16.3451 5.27561 16.168L6.57313 14.8706C6.75019 14.6934 7.03726 14.6934 7.21431 14.8706L11.3668 19.023C11.411 19.0672 11.4828 19.0672 11.5271 19.023L15.6793 14.8706C15.8563 14.6934 16.1434 14.6934 16.3205 14.8706L20.473 19.023C20.5172 19.0672 20.589 19.0672 20.6332 19.023L24.7856 14.8706C24.9627 14.6935 25.2498 14.6935 25.4268 14.8706Z", fill: background ? "white" : "var(--ck-brand-walletConnect)" }) });
const WalletConnectLegacy = ({ background = false, ...props }) => WalletConnect({ background, ...props });
const MetaMask = ({ background = false, ...props }) => jsxs("svg", { ...props, style: background ? {
  background: "linear-gradient(0deg, var(--ck-brand-metamask-12), var(--ck-brand-metamask-11))",
  borderRadius: "27.5%"
} : void 0, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M27.2684 4.03027L17.5018 11.2841L19.3079 7.00442L27.2684 4.03027Z", fill: "var(--ck-brand-metamask-02)", stroke: "var(--ck-brand-metamask-02)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M4.7218 4.03027L14.4099 11.3528L12.6921 7.00442L4.7218 4.03027Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M23.7544 20.8438L21.1532 24.8289L26.7187 26.3602L28.3187 20.9321L23.7544 20.8438Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M3.69104 20.9321L5.28117 26.3602L10.8467 24.8289L8.24551 20.8438L3.69104 20.9321Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M10.5327 14.1108L8.98181 16.4568L14.5081 16.7022L14.3117 10.7637L10.5327 14.1108Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M21.4576 14.1111L17.6295 10.6953L17.5018 16.7025L23.0182 16.4571L21.4576 14.1111Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M10.8469 24.8292L14.1647 23.2096L11.2984 20.9717L10.8469 24.8292Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M17.8257 23.2096L21.1531 24.8292L20.6918 20.9717L17.8257 23.2096Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M21.1531 24.8296L17.8257 23.21L18.0906 25.3793L18.0612 26.2921L21.1531 24.8296Z", fill: "var(--ck-brand-metamask-06)", stroke: "var(--ck-brand-metamask-06)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M10.8469 24.8296L13.9388 26.2921L13.9192 25.3793L14.1647 23.21L10.8469 24.8296Z", fill: "var(--ck-brand-metamask-06)", stroke: "var(--ck-brand-metamask-06)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M13.9877 19.5389L11.2196 18.7242L13.1729 17.8311L13.9877 19.5389Z", fill: "var(--ck-brand-metamask-09)", stroke: "var(--ck-brand-metamask-09)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M18.0023 19.5389L18.8171 17.8311L20.7802 18.7242L18.0023 19.5389Z", fill: "var(--ck-brand-metamask-09)", stroke: "var(--ck-brand-metamask-09)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M10.8468 24.8289L11.3179 20.8438L8.24561 20.9321L10.8468 24.8289Z", fill: "var(--ck-brand-metamask-03)", stroke: "var(--ck-brand-metamask-03)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M20.6821 20.8438L21.1532 24.8289L23.7544 20.9321L20.6821 20.8438Z", fill: "var(--ck-brand-metamask-03)", stroke: "var(--ck-brand-metamask-03)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M23.0182 16.4565L17.5018 16.7019L18.0122 19.5387L18.827 17.8308L20.7902 18.7239L23.0182 16.4565Z", fill: "var(--ck-brand-metamask-03)", stroke: "var(--ck-brand-metamask-03)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M11.2198 18.7239L13.1829 17.8308L13.9878 19.5387L14.5081 16.7019L8.98181 16.4565L11.2198 18.7239Z", fill: "var(--ck-brand-metamask-03)", stroke: "var(--ck-brand-metamask-03)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M8.98181 16.4565L11.2983 20.9718L11.2198 18.7239L8.98181 16.4565Z", fill: "var(--ck-brand-metamask-10)", stroke: "var(--ck-brand-metamask-10)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M20.7901 18.7239L20.6919 20.9718L23.0181 16.4565L20.7901 18.7239Z", fill: "var(--ck-brand-metamask-10)", stroke: "var(--ck-brand-metamask-10)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M14.508 16.7021L13.9878 19.5389L14.6356 22.886L14.7828 18.4788L14.508 16.7021Z", fill: "var(--ck-brand-metamask-10)", stroke: "var(--ck-brand-metamask-10)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M17.5017 16.7021L17.2367 18.4689L17.3545 22.886L18.0121 19.5389L17.5017 16.7021Z", fill: "var(--ck-brand-metamask-10)", stroke: "var(--ck-brand-metamask-10)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M18.0121 19.5388L17.3545 22.886L17.8257 23.2099L20.6918 20.972L20.79 18.7241L18.0121 19.5388Z", fill: "var(--ck-brand-metamask-01)", stroke: "var(--ck-brand-metamask-01)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M11.2196 18.7241L11.2981 20.972L14.1644 23.2099L14.6355 22.886L13.9877 19.5388L11.2196 18.7241Z", fill: "var(--ck-brand-metamask-01)", stroke: "var(--ck-brand-metamask-01)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M18.0615 26.2917L18.0908 25.3788L17.8455 25.1628H14.145L13.9192 25.3788L13.9388 26.2917L10.8469 24.8291L11.9267 25.7126L14.1155 27.234H17.875L20.0736 25.7126L21.1533 24.8291L18.0615 26.2917Z", fill: "var(--ck-brand-metamask-07)", stroke: "var(--ck-brand-metamask-07)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M17.8258 23.2096L17.3546 22.8857H14.6357L14.1646 23.2096L13.9191 25.379L14.1449 25.163H17.8454L18.0907 25.379L17.8258 23.2096Z", fill: "var(--ck-brand-metamask-04)", stroke: "var(--ck-brand-metamask-04)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M27.6806 11.7552L28.5149 7.75041L27.2683 4.03027L17.8257 11.0387L21.4575 14.1109L26.591 15.6128L27.7296 14.2876L27.2389 13.9342L28.0241 13.2178L27.4156 12.7465L28.2007 12.1478L27.6806 11.7552Z", fill: "var(--ck-brand-metamask-05)", stroke: "var(--ck-brand-metamask-05)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M3.48486 7.75041L4.3192 11.7552L3.78916 12.1478L4.57441 12.7465L3.97566 13.2178L4.7609 13.9342L4.27012 14.2876L5.39892 15.6128L10.5325 14.1109L14.1644 11.0387L4.72164 4.03027L3.48486 7.75041Z", fill: "var(--ck-brand-metamask-05)", stroke: "var(--ck-brand-metamask-05)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M26.591 15.6122L21.4575 14.1104L23.0181 16.4564L20.6919 20.9716L23.7544 20.9323H28.3186L26.591 15.6122Z", fill: "var(--ck-brand-metamask-01)", stroke: "var(--ck-brand-metamask-01)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M10.5326 14.1104L5.39897 15.6122L3.69104 20.9323H8.24551L11.2982 20.9716L8.98168 16.4564L10.5326 14.1104Z", fill: "var(--ck-brand-metamask-01)", stroke: "var(--ck-brand-metamask-01)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M17.5018 16.7018L17.8258 11.0381L19.3177 7.00391H12.6921L14.1645 11.0381L14.5081 16.7018L14.6258 18.4883L14.6356 22.8856H17.3546L17.3742 18.4883L17.5018 16.7018Z", fill: "var(--ck-brand-metamask-01)", stroke: "var(--ck-brand-metamask-01)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" })] });
const Coinbase = ({ background = false, ...props }) => jsxs("svg", { ...props, width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("circle", { cx: "10", cy: "10", r: "10", fill: "var(--ck-brand-coinbaseWallet)" }), background && jsx("rect", { rx: "27%", width: "20", height: "20", fill: "var(--ck-brand-coinbaseWallet)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.0001 17C13.8661 17 17.0001 13.866 17.0001 10C17.0001 6.13401 13.8661 3 10.0001 3C6.13413 3 3.00012 6.13401 3.00012 10C3.00012 13.866 6.13413 17 10.0001 17ZM8.25012 7.71429C7.95427 7.71429 7.71441 7.95414 7.71441 8.25V11.75C7.71441 12.0459 7.95427 12.2857 8.25012 12.2857H11.7501C12.046 12.2857 12.2858 12.0459 12.2858 11.75V8.25C12.2858 7.95414 12.046 7.71429 11.7501 7.71429H8.25012Z", fill: "white" })] });
const Family = ({ ...props }) => {
  const img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAYAAAA9zQYyAAABQGlDQ1BzUDNDAAB4nGNgYHyQk5xbzKLAwJCbV1IU5O6kEBEZpcD+iIGZQYSBk4GPQTYxubjAN9gthAEIihPLi5NLinIYUMC3awyMIPqybkZiXopc+xz3pvOzD4rlWyascy2VY8APuFJSi5OB9B8gVkkuKCphYGAEuoZBqbykAMR2AbJFkjMSU4DsCCBbpwjoQCC7BSSeDmHPALGTIOw1IHZRSJAzkH0AyFZIR2InIbFzc0qToW4AuZ4nNS80GEhzALEMQzFDAIMxgzMONWxgNc5AaMCgCAov9HAoTjM2gujicWJgYL33//9nVQYG9skMDH8n/P//e+H////8GBiYZzEwHBBB6G++z8Bgux/EQoh5AfkbzYHBtBUhpmHBwCDIxcBwoqIgsSgRLMQMxExpmQwMn5YzMPBGMjAIXwDqiQYAOQZcLsEClb4AAGmfSURBVHgB1b0J1G3HVR6497n3/98o6Q0anubBludJeAiTbYwd2gGC6UACBFZY7gVNB3CaJEB3VhbQhNW9OtDQkAYSIOkEGhJCGJrEBGzJkrEsT7Jky5JszXrSexqf3qw3/v891TXsvWvvferce/8nyabrvfPfc+rUqdq166u9d+06pwrP+/CHA3AI8RQRmqFxbyRliVdpcSQ9jj27IASwdAVHVxi7l65hcZAn6NlFdOOce4vCgB5Fc5iXdiN1abSFP1/2PrRoUtiYR/Oy9C9Tr7EwNVc4pwojTDFxC0CMI2nH8hwlhX4D5ZOvWwzy9cHlS8FlzhfwZNlyDN2pPlSXwT0VAtd7yTL8+SDuHOvCzzKdyOButIeuj6HfpTXtu8Ew3WD6NpjnALnFuI1IPB9GK0n5ZiCM9H4GyTJhLqAX1GHZMoJK70Etp0tK4nlhLqBfQF08CFnAgPrN8SHMz0N1YmjluYGwNKDnSeV5DEOnttHnpZ7fKBDyuWJWUHnKqWLUsgyaJ4WbjT2nDv56TCWL6gaw0vklrAv/vpD2mNcWrTpAI00+H9G0G5XWU/1gs8fBSCM1gMq/Y/d9BzD3WiqUpS4zQakyBkDQ6k7HQ5uZi4CgQepphJE66DiuC9PM57lcpsU1auA6Ul1Q1S399o6mF1qXFDq5NbyHqi7QoBmZ5wp8wdn+3G6o6qifRV0vQ3QtbxGwPUbT+RSXeEj/NiUyqQwP5BaIOw8Gl94HAwTKS0viXkk1fejeru02k2+jrNb1gE7d4GA7YwtEYYEtHyhN0HWh6/Q7AQV4bmidPwzDaF00rbpdGnHQqI+vh26LoPjNdQCi3XeAlL7zcaA6g5PYCDBqMup70xahvpK2DkMACmjVvc4904EFApL08dJgAAxVUX3OTEIlFcYYigooPi9fZ0nPtCj6fKPr+2MSD+fUARzNDBCJ0yBR9ZT6qjKC8jRImcxfvuf4b84pLXBdsG1bG94pLSL00i0taHpdP4rv6XnoOiut1aDSaCyYI3AV7aM29KAyc1QwNqSyZ5gHdEcM7kbyaAXfmOYg5vaF2MrQxCzFGFZ3Oj9dH98xPc263t0YQKAdPCA0CHxn1CDo+Z4ysSQvrovTPjkksHCdoLYDtOpCaY3AAZgvYBjABFShWdGfjs7VKcepugSiS3dK/6vt80HHUnVfalA4b2CHDROCG1uDmM87dd4Cgy5HiG1I2OB6uwEC9VhOhxosytZrSSAg2nU9dZ2wRT+MaB+mXwdtd7pD6qJA3ENtQCOxAYZ2d6M+Y3w2dQEL9rntQXXSAGOaO2f+zcACGZVwMRJZ5QtULxE+/OvKHAvTFhMs7bZx5XyOVNZg7kAxT0nkTkmNVNFunoRz6rZXKi4xxvR2YhoDm5ntJRxxroJhBMQtIHe+vj6e8muBTMwKJgFqg/eUV0/8aNWnWRfn/QBV/gDUrh2w0Un9PZMv063axEtfXxehn/JhgdNzHRoDQM2fWiU12Hb3OMyV0K3KeDAbadUA8AQsIDqVRqS1VndOOoCuWCBmIavgdE0MI/D2JCl61eAi7RSYWVWO1Rddp9QN7evQAnk5tJyRUgemknQ6rgMfyozyoNHqfTDo1PWAtkQWuhttxveB6lDqpWtQz7XG0HTqw8fNFF3mOWU+5eKcRNYSG6AN6qk2wNHZKWJPkgqQHstSFZxUpvOJZhTlNaHryQig828AwBFzoFQ0MQ8ziDOYMTGhJ6akhq+gnjGoYWjD8YBEQK0GFbrjAYyD2AAhd6KSFQNZQBCcOMDaTj1wfahjgjU5pB7U2B1UbcPqfCDJuC6qzYxWTPGR3xPTBqm9dD1R6gLAHdO2SSDaU6MJX/u+CA3XMWdES0edk6UzUr14nNDxs/QrfnPlANBSnmkKCsNTQ6gGk+r1A3uR47ykggrmibrWcRbQLOGGErEVqkRT6jjm2qtG5/MJAXwGwajApunhB0QODFrTtECd03VWwmk+1QqEobnBEjrTXkDOkjkBYUIgSHGmkyIaST/wCuCQnk4ETW2TBOSBSei1UkMDcJlFkBBPu0mhnwA6I3BO0nlMs574SrydoRt7Qe0A2VRRYDbjKIVRI6kpvpgcaJWjrkCnC8Wh50I3rkhhdT1RQJ5AZaIBNjZUdqOHDtSub2xEB+5YTpSQM2ApUk0PaA0wEF3Du/qBBcBE1Vnbn1wXAKtxuNzg6qCBrTtlp0FO5Zl0YMHMdeBfDUoteSe+ftxhVVov3TWPQNOv24bbIZ33SaOU81mU4h1pmBkdPEBE6rg6yLgIQAb1fvAbPF0UN5hY0b3GxI+AWYOXwTzRYCYglHN7TzPQgDoUM0QTUCUrSzEl4bCaGTOodhoDPEvr9Gwo5kp+tsOB71ZLpPpb6DYN7+qLyBpJaRwYDqiCrouugx8HxLqzNJ5BBbnutMYT4iUoCYNkBhWTCJrmoBU0heaJ/Or2BlUbMjWAgdww9aCAWOoQUnukMgjY8VgHEBM3g5qvCcAz6vxsZg0EkBIOmsfW5OCEKpGW2PMkM/fwdD51gJ4OAA71GfRmS2oAa9MOJxpIMkOpeJZiufGKqVFUNWSmiS2HKObKhJiuxw8AUMtnerDS5U2nOh6gdMD1YL5hFZYChfpbxwDa/scMBLYnRf1C6aCdgF55CAhMpmWx2vBm4Ad2LMNAnrTa1LW/RkVQvz0SqEmbzLDSOyOAI4E4CyqlTGYAYusz9tiG7uhX28/efQsNoFsJ7aTVIjNDwAkV2CsUxyCepgEIn9MzU8VII6mBTZxu0Mm4LxZgFk9HH9hOLoydEUNnGeCJjpAlQxo4zrB6C/TslkhodLYmWM1R60qgRjAdskq5CuiuYkB0pAZzoQVIqiHVAXPdZoE7axBg8AAraFDTL41ATVsyLRMPaAJz4k+HOJDURZr7+tiKsJZhM7AnwTIjzZN+14nvqdz19BsHjetprBH6iq0krWO8ES5OUouzAut7MQxs78qbagaAIV7hSR2+FwuDSBJPiTHTzsalgqY0us73FSgK07vCQG0OKsIDeQuyT0M1fC82clFjEwZ1aphQ8u9j3myKGFCr+gFJBRiRVtV0AiPhJtToDPTKJwvu5KGRupBUyx0T2EYO1VSCamumDjkDZUqxlA7VG1AHuEPtqr0YRiKHInSqhq0dtQ7WM+VO42DtlCylCdgzoT+QidFl4dLFmGw/0zQ3BvqNQM64i/HrDNqgXsrCOkcR9GA4uPc7FKiH73JQZtq3DNBQXQrMGsgGxJHQBOQVD/RScJVwWCUgWEEjhBYGBlHB1b5ij0Yqm+w1sTeBwIDk4bAN4AdTnZNqbFMycLWZNAUwEk1AQLDNT5PNL1PtSH+oSPbozUgDyYAqJliPfzU41sksYcnNklGm+509WQFNNjSoekDxykwRlLSm9KFAll18bIYBtbuRNsjjGDVucQIl//ZdHiCugRWWeZzUB4lc122OzMnqj0elVVEBHxRd1YbGxswSWneOPrRknjgJzQBeSQXEXlriC4jzgWAGi2xf8UBjU6zohaurcPnmzXDhpk2wfTrN6VJYiww4urYGz545HY8z8FQ8nl9fJ3VTGmad6ElgTnlP2FOAIICBUAEFaAFQzQ0w9r4e3IrXgyVYKEp4c6J902a4YssW2BXrcIGifT0mObJ2Fg6ePQvPpuP0aTg163MjBCqnF7o7GkwFMg0YLKTaMZCEZ5+8FUwMYgxBBniTGDPpap0Sz/PAkbr6aqR9T+T3ZYnvkfYdK6uwQoPztShNj6yvwcHI70OR/wfi71oocnKSNVDRmKklspuuLzRnV12H1L4I1P0K3mKesZoQLRAxwQCgvl0Itl49COKNIBLhBM5tJ+2Lbb+z9zUXScUgJRBHBqxgjVtByEcBeKxsVwBfGFmBsDsy7y07dsDrLjgfrti61fiijXoBG1Lc/pOn4LaDB+ELR4/CExHoE6h2bx6ksInCg8v0r3MAgDqZoDutsZs7HhBSJ8y9IsDO1RV4285d8MZI+1WRdmjQPhYeO3kSPnv4MNx97Dg8d/ZMAW/uOB3Z0oX2DBJkSVht7p5MFxYG0oaBtARWLcJ1wcD+4BA73Ap89a6d8NadO+G6bduk8y0KqaxHnj8Bdx45DPcePw6HI8iZ71nDTAqPOnLfFewEKLosZDv6LCIBtmfXjwCbQd0pHgplJJmDaT9Kt+MjHwk8KzaQ0NAYAPJvNicSgK1kLkeXpfCKiqu2NKu3ItleFpn4zgsvhOu3b4ctkwm8kHB6NovgOJLB/cCJE1k6BG50UDNxoQ5okMSz7rzae6HtzokAuaS7LoL37ZH2V5+3HbZON/w1mwlnorS668hR+EwE94PPP0/mRPWArIdgBl3F2xGMXz6HUA2PjqU0qAF3KGB/VaT5a3ftjkDeAdsi7QHOPSS+fz7Sfnuk/eHIdx6j5MkUoj0da3Tocx233vO9XsxGGUuE6n/n+vo3FLOpvDMCWrtl6mDASWMA671g4HYKzPE+S+gVksgrnQI0VKYmc+JvXroHXhGBPO06eDFDqmgCx588+SQ8dupUUUuIakDGDAABM1uKqEAsPmg2LWg0tCNKte+96kp4RQRFt6REWzakBrvv+PPwB/v3Z9Ok0A7i1eBJojqrCKJ1St1BNA2bUEDSOMTEF0VT4u9ccTm8MWrDTS8y35O34gtHj8EHn34q0r5WXHohmYAgIE6/ZxuA1qBOgF4nQK+HOljWM6UMaDZD+Bp33Xxz0CaHnhmc52NOYNbSeVWBd8VdywCQ7Ll3XXQRvOfii7JkaIWNSosxSCVb+2PPHYQ/fvIJksQo7wME9aAfQ0xATUJAsTETs1L811+4G755z55RbfJi0v6JSPtHDhwgW5VnRosZUj02QTSOJyKra3LzrcZn3x35/k2XXAI7VlfgpaT9yNnE9+ci7c/KmCWZSwLoBFqwYD4bO0MaNM76XtLMwIGaB8TpnREqS795mTvurltuCaJuQzBvvlW7y87wMWjT+aoyMzKQs6nRxQFGBfOUpNv2CIIkHb4q2msvBkOXZfDnjhyB33p0b2Za1j7Kfg5gvTnFi6EnWbJ+jwDu4G9dfjm8ddcu+HLSfmek/T/t2x8HjzOlaQqoxdMR9Dsiyk/bFzAngfM9V14B74yA/nLRnvL89KFD8B8j7Wtk+qUB4zowgIskzucB5HyNJHO6z+aKMT+CMrNC48MHA2iwgz8D6K4TG9hIZgEzCLg3sX0NNOqMBe6Oqu6HrrsWLo+j/40GPSgcY+BY4LTPxFH5P7/vfng+AmNKkpols6TDAuKJPFsAcX40MX7k5S+Di6IHwOcbXkKaOSTT41cfeih6SNbFF6xfudQ0VDdnAcN5UYj841dcD5cpvnvazoXmscGuj9sXTb5/8eBDcCJ1yA5zR0yS+GwC9qzPQD4DUCV1qCA+21vTQ3zxLVDT0XkwyygZ3bsWQC4eBOuLJjuT/bJTSsv2cpIS26YT+B8jIOaBOcw5ACzzwxLpfdqLIxj/yateCTsjLezDLrOWoUz6xCN1wNUcTxM+8cGdEcwfePnLDZiXpWEjNM9Lm9x/P3jttdF2n+aIRHv2HvFv5j/Vg/hfbP0p/Nj1L4dLI99btL0QmmHJuOS+/PFXviK6AKcZC0lIVCFZvDlm4goAzNt/+gDCKGITsymY2Vk5x6HbLoOYZv8Q0cyUsSuLz6eB3paKPWwaH/yxCIjdDhAA4yB8oWEsz+TT/tFIy7YotbJ/FoqfXA9icx1K14etUdP8wHXXRdpXR8v5ctCdQgLlD0RQbyVbMQsNHnhD0pQdTV4V03FTbKvUEa9wbkRd1osdxvJMwuSHIh+3RH5mUCczKJDQwzp/IJNYIRiBarCovEwcPE6rVG4k4BlCfmlHu4D8Sy/sh8xqi1Tf9111VXTUb5HWCvqAL++RQmrg74r2JKT3B/o+D/hEYkDxj2fAxOM7or1/6ZbN0lhfrqMfof2yrVvgu6++Kr8TAQQMkWpQ/L1pliIB5TuvuCLWdcuXnfYW3SlcRXzPcQqU5lVWsO/PdAp7nZPMgxluCnV4pG1JgIGETrf1K5R62rcQRUzNPE1+xB7ee8nF0c+5SzLVFQwNTmuwvxghjFy/OQ7s3hcHeOkLizRb1ZG0Tu8cYF80y7suvhjeSIPXVj4vEomjYYz2115wAXxDpC3RWKamifaYgGl/T/RkfG30j4/l81LS7vPX52+LfH9XpCthIwuTAFkay3Q8VN8/v5ZbDmhaDC1wdwMgq0FhzdD2EHnHFqDOygHbL2UgtXtlJYOCy9Ijz6B+5RysGmkBeyMNEUae4eu3RffbxXGKOvFWXm/MXoEeLki077lk8Py5gOFcaB4rj8+/Mfrvz4/2cT8rHbC8OlDAvCvOuL7z4osG+W2E9hdCcyten39LpP3S1U3lDUEynXhsVj+WAPNujFgIjEXKK3umDCaR3zdBaAE7hQ6UkR7Um1dQ3+LStk5ShcmX+LejykvA4AoxOMNYhdGCXqQ6Abtn6Q3LHbAgPvnA33fl5TCLo+9AhfDvt0Xa03sNPh9Ysuxl6Fg2bav8RNu3RA2TrvI3lUR3mtj45ssugy1q5u/FouNc+Qzu/LyIif82mnKJ1uyfCEraOiBrSZzGb4IxJZH1dQG2KlQjXq7pqvYO/Uph8QTwb5J2aaYnzf69Kc5E+RoGOg/+gJGggM00eft7meAZy9evjur7+jjb10dQJ2CvR4l37bbtMf78QVqfz5crjJX/hl074cpol84izcl0Sr9Xb9sGN+zeJWm/krTPK+/1ke/plYdEM7/fzC9KCZC1V0OeVBIZrEbnIINCbTvbN++GtrQBNhFUZqSi37CfwTuiAz+5YzJTcQnGkgTmY9DjvfSmZzY6uHRF5uPN0aY7G8GcfaKR9q+O6ppnE33ar/QB7vyrI5+TPbq2Pst1+Np43QLyV5pWH59ej/jr0aRLUrr40QO9C88vMhG20L71yVhMQeNUBzOZrxN7/Egvol+2oXMhGVTllcH0rsCbd9XB1DKAA1eWGRx6JKrE6MySdm+hNCPlJkm3ParB9HLQjmjbXRslNkC7cb5SoQWQFF5NLxYl2tNk1us03+ErS/uA38Eerzv/fNgZ+Z60S5bSYSg8BWuUZwuT4OI6j3C9iqjpHfyk8QNW8Zu+8k3S+YZoamzuJpaZDqCtwd4ouAFGvR+BEjMjFqVtSY80A/raHTvh9NpaNjW2OvtT/4LLw9/zYUEfW5i2Va4+ki39mgt2RNrX4U27d2fJt0g6Amyc5jAvrQYqzOlMzgmQbOmviTRnKd0HSay/jClvWllvhuDVu+1kzDdyQ//1lCGpB21upJ6WiHt7GmEzfaqiwgBo91h9T38q5cOoaYJDcoNKp6vg6bkhejwSU18f7U//OuY8UMwDzyIwLpMWRtLo+K+6KJlM6/CGSPsi8J4rzfk6WN7XT9nASqAlAueb3HjrNAaQdesIECZbusWYRBwvrJgcPBhEhwh1qW1oLUoLcPpsbqR3Oa7Zus2+orlMMOIYqKcOogwdfHPgs2ZzREVpid2i6Yrt2+DKaGpcFgcqPixdh69QuChO/FwaeZ7q4MMLpd0IHGXmedNg9Hn368PLIs83T8qSDcnlmIM1ksupLgRdMu2hQ2wsY8CJWnlnFcCfvDCxxXZOg5Mr4/RsNufnSEU5H6slMasPrmyowPb0ttKaHsGnrYehfLz7/a98BWyaTJqS8K9K8OSn8+Si++HXvUZo1/LmnGhXHb8lCJfOM7QvjQ0cC0gfdtx19BgNxIORXg0cm3P5rhBqvQfvcmAjgzCH2rKEVcgumEs2bR6kNwM2fQ5O/XFd+grQfA9hYBer7IRWbUMbApwo8WYIh0u3DT+d+qsEZg7ebEjh4q1bBvc3Srsx/RAA8RyedXlou9nPMbBQ27N5c563KFI6qDqotwiDbetyUgnUpE45A6uiw8iKlvy5ePksP3+wG4BeVezzSygepIqmltC00tql5xNDiQNry+LQeQ7UFXeKAYeGQUu8ZVTruaSFBenH6FgE2IV0NDr9WN4BRm4w/9Hauj5/LZUlPQmqHXFwuN6XGc8cJ5KvpA668jqP0OZANTmCRwC6HqJBXpbVKgPR4ktMZsfO6LIbY0aABpBhhOkuk7JiZTud1BXbWTSqpeq0iJBmXxsN55J2o+mXSQtz0hqgIcylKbQyGbFpwlhGMJBBtU2gzNjmla7y6wdxcIjsqXEfwQawcxojKqR+A4X606QqDyxYaPlXypzX880zVfHgT96NdG5wtRJllmVogkrw5/Ix74gEIddKEyXWQqg2dtBV9OmXCBtI+pKl3UhoDZxxUVqvQkbas4X3VnwrTQrJbzyjl9nSnbqVSC2B1zSEUZpraVO9ZpgRYnrWAvVqOQRqqMtQycIuDTUwhmvd+42QNBfjjGlpHNTPeomsymxJa/ldwgTxfWHs2WUat5UNwNDEOJfgeYwNXrQGS0IDQ2OJCmi54mmw5myNSD/5S3bCDkthvY43Y80WhgYAemZX1uXwRJjtD/ggiSrrytFUJS9Ntdb3g3zsicqfajSo7AgnWjakUV9OOiMo6Y3OjgtOKyiEaknuA7rGsDcd6apcHwZAddoE5jy7LMq9jdx8BNtpuYFawqiBfwFmq6eH8WLzvfTuD+Mnf4zc1wWBAjWG4C/Ubwh9EEB7kMivNkEALLAlU6xfIMfrQ2fOwrygwWKkMcVBsCCE0KDNSxmVN5Fd74V2A+j7Uvw825oBho1ygorXtGObJtN/VL76PuCweB1QlTsgtQHkwQCYCup7MJqMXzBbpKX0SQAYdGauc3BpMAyzPr6+Jt9FzqROdUGg1rs9GZshGHwyn6ZjBGu+lAWoSwHF7KjL2aaIQIXuP3lCAGEc8uAq54HrCmaws1aQ4FoX1X2fDUtIkZbqIS2dg6s8qvOA7lmwwJdrBa65aVs0jKQfpNW9YSRt0M+4zqo7aRPgUPntaWNBpNtM918tBExnVcW0tG+i8eDpM/myeMxC9p7NNNbQdSLXiX2Y2loHVwt+URTM7J9soQCgtkwL8PCxYzZ3lrrQICLYiqP8aUgc5rCTKMF3UXAA1M/qcnF4v2VqoEqLwdanNXtViXb5jkk8Fy9pcTytpFEAb3ouNPhCOy8BH47w3AHID/SDa191a3BtOmX9gX0nnidMlQ8VeACY41AJR6jxY9u7pTynLL7NGryZWDRiP73SVwqoawLnRbiB4xAeTUtYETe0lOW6hFYtVY8HJ0m1JNeSkxvJ8XyYt6LBgEpJHANULdl0owebdlAejv9ii8hGPSUtzEkHVnJL3Rp5SRZhPEsxl9x90xah/SxHDPgPDUHUCEWDB7jr0GGpOO/XUsZpYCS0frfHrO+dC6x77ph3OXSFmkcI5uWU+hJRaeWT6zP40tGjlWBVcZM5MyOoHti6Vs9YOmqcgF3HaSkL4xJSD/JETTcaEjXQwdWlBdRBy4/ELUqLjfLcuQGzT9voOIYVaNvItEGjOAN0V2xwYNHtxGj05Dx8/Hgcd52Bmiw4XLmX0EKbxRrYHYQxTquKgj3MwuEApJbLikS3PP1UW2L6YlABERxjW+USsz1t6PI22l9JNX101H99fOvFG7nm3wD23V2+9s/jgrRjecNIOWP0wkjeisd8H4iPqPjX7Bz+NrWFFgAtkOnnTMBKiw4f3L+/rBFNpq3BWAB5+V+RaPvpYGYo1Hc5Br0xhCaIZcX5YFe+LEtsdfCnjz1e1mv2EgOlzLoCaF/j+De4Hu4ldx+cNACwkhpUgxIgOK2Ol3vQAAo4oIzdw0baMPIcNs7DAqAvQ4dLq4OPF0VsUNEGS4ARgOs2ChbUrUOeDWDGYQkjH3v6aUCqgDYtZgrIjDcWnB6bPgxXS5TBoAO3KhChuurqCv8F1M+cOg23PPkUfOtVV7KWg3pSOaMlMmgm4zDeMFeBeHRgFm8eiAPUX/uvN8Itd98Ljzz9bHmJnAYdQHUCfW5Y0GKVC75OX4GAjgGI6pdGl3yetNLVl1wE3/yWr4L3//V3wJ6dO5qg5mphcKBs1FU/Y9pUxfPGR3oskU4/8sST0YlwHLZu2SQTI7LhKNTtLVodRM65/VT81NOq24l3nLITLOU9Dl54G4mxefPytIfKpIM/2/84vPuyS2HTpLG6KDa4xyBtiASHU0D9S8/pdk2ndzyyF3783/4ePPzMgbL1wuoq1YfBqlbsDB7AwXSa5cKLhWzceCqsMSztUF3n866k2H/4KPzGh2+Gm+66B37m7/4teMdrXmUpZyk6B+iDENrxnkYvqz74+OMZK2kfFiD8yC6yAAN7uXo6lM0DNk0Kxm3H6omEtAUwsi8aRUqXtdgrqvKn5t0EbjvwLHzi2WfhGy+9rPoudal8GhYzh/2ixdNimSRpCPgp7dNHjsBP/s5/gMfi6HnTls3QTTrgr9eFKUEDur3Y4cbDQMYtkR4b58uHgmVU1ygS0KwBR+Ixz8LF2ZS9Bw/Bz/z7P4Y/+MkPwIXnn2coCiOdOYTlu62ZA9BgJto+9tRTcMfBg9CtTq0NjTwwrGt56y9jqmljcaf5YTYNkiZBNhXQVLIAuSxAy4tts0rJ2wuThJ5EUP/SPXfDDbt25w9PTd6qsAANldaQ0uLvbIlrVaf08zt/eVtssCOwGsE8XZlGQE/iDVkCR9nwQWyxcnPcLvurGgyUFS9kKwoAMMsApO/30nINa2uwL0rrf/Whm+Gn/vb7hnVWPAdoyqMBDUGZE14ia1v+udOn4dfv/SL0Xfr6e5K1esDi/O1J89e9cJwLD6qQLQJMVZqk8HSebPAyJEAFcJbUNKuTpTP9TiKAJtMJPB5nDX/v4YfgR1/zWjOy1p0GWtKAJQHdN+mGnXLA2Q994V6YblqBlc2bIh0rmR7eT4VHzWIfkqQmWQ3a1Pr/Q/DbaeQ4GvnJFhRpu7wcn+od22wWB+y5k5+FW+970OQnPGAB4u61QmgkYsmsaWP6/t9H98IXo2t38+bV3DbscgoaxIRP3oexVtjZlp4W0CaH2BlhUEGZfqSK9iSlda8pNkiXiVxJ77hGSfDvHnwQrty2Hb7tqqsNogNn7mgzQlqBGHUicNJApU/k7z9yDFY2rWa7eZpWbsoSgF5L5IKdk1zAremDNsMcKXNDeInSChFOl5PlXPmFtF5cR1I7DeLTNlhpQ6J4/vjhozUrJYb1Ng/6RGNA32e6/edP3u34l3Eg+Cv33AMrqyswjeOrpM2hKwLH+J8DezawmhoIRuhUPljMmlFbq8FEMoeqzvI0JZQtEpAkXsZzUh1RVCdCp2m9iPUz8M/uvANu2L0brti2XTJHpdKQKiGMUi1rOr+Xzq4XiPaJHapLpkZaS3lazA1WU9zri7M+iATQqkyX5XnDHaf1vgNAm4e1OkPI6mLQp9WFjKBd6hwqoHl5NqzGdH5c9u7uijadRFCtr88smMGaFyw4vAbVNDNtehZVDgXmJ54/AT/56U+RwEuAnkRaJlmjyN7lAOKA6D0tMAR0K24KDZ7lc2r0uksnmvqwlObBGm+VkBmWiY5Xqz2cOXMWvufmm+DfvvNdcP35F9AmkZYo6fTEiWDfQm2/3O2AzDSD9Ppim+XdmEKdgSrbKBd7LZUle3SEYkblvLyNpKSSLns0YCsNbjytL9NlgQElNQOnjHOwbBQPdQHxkjDfibwJNOZB40vWRQlQwljZNVp2/3XWAS/X9cSJk/C9N90EZ2K61diRVnhsk9sIaG9G/R50FTS8G5h8Fui0g6Y5hc7c1IMk0lu5PtTVOHPvpzbraEQik6E/nRbTI1XgWLTb/v7Hb4UHjx6pPVcfjpONCaAB4b5Ckm9Z4zcDOm+yQwxjpuV9s9PCuVi2HS4b8WBNg/W8z3sFduZ+jW/FdYP82mnxHNI6OmIdNK25LnIfch3T/bQ7a+nENW1S8XkgNumsKefaQeJY7atGD475DH7pXJTggcOH4e/d9JG8WedqBHI6knTuJp3gSBcZNB3KzNCf/8EgroYpqFGwF0b1RR0U/SNTkYhkhvB+00XChdz5yzYDsBIonwDPnj0N33fLzfBPb/gq+JtXX2PVujNDRFqHBoCVamtpZt2oxT/Oe/uhbFzJEkBLAlMO+g7TkK7YkKI6rWHkBtKCq5BPjzpLvbBmbT9eLVb+kOTgvbtzW3WlA4ArqmVe6JccXbOZKqA7v3HfPvi5z34Wjsfx1OYo2FbjuCZJ5zJQ74rggerVYJdw0fb1qyiRcoxB3wkVhqfMS6cxABrXtQdVYHPv7aUiJbfiwpvStG5B5um1s/Czd3wWnj55Er7r5dfDedGW0iZIAMs548NWNKBOr86RmUEHsIQOxcyozvsuL2ySpTiZF1rFNqXPWMAN3NtI2kacviQuS4fmMb0AHRU/gDs6zR1QR2cV7sHMJsigo3s6sJobYi/H4+jZM/DnceLkf7/jzuzx2kxATho7gVkPTGWvcuqsUi7jF2AgtT1PNG3NhWYM0whY+VyjP5SlDMoItPai6oHA7P7tphORGskaOLO2Dr9y793wx48+Aj/+hhvgXXmd48qcAahYuIVKQ3A0GymtGhDZrMh7pPO0Kt3vOqG9NCC9P0CACE1mgJK6MB40gWGDaeflrdIiEYNQec03i2sVqRN38tyMUicu9L6OVDc2LTy4USdDa1boLD7zzDPwC5+7Ex46djSCeKVI5vg7mRavBsrYpjzBZoN0Iqz1GJC3iJfQeJdDp8fGRVCMqB8nltlEFv/lHY+ySHXeeWVSV2fn7eGeOnUK/sFtH4M3X3gRfHeU1u+4LC0yPjHdrSWB5VqBWDc0qywg27MyivbHBm1ysJkSiO7CgaDz9CDrGvdAXaOLgzlpfZqxMJJ3BXX1bBThwa634oPONjPUmThklU6SmkVgUHQEHQfz+1paV+NjTz4Bf/rww3BrnAVcjUJsS5TKCcjpSJIZp8WrUex3EiAde6CoDEQZ2LIlUDRkQ8DAkK0pND/B4i/BRb2PqMNSKGWJaGbeOJ8M7OzIR7OBZ1p+ay322LsOH4Q7Pvks7Nq0Cb7lqmuixL4Krt+xE7bweyCKaiEFhxI7aNpp8ANYJDX7oYsqq1+r16lV8lMj2spR+lbdze+8+EVpF8VBlYrlHBWJhSPsnWHPQpXQJR3PFmY3a+Jbj9U+cNXrnYT2gQVJAvEjcYLkxsf2ws37H4f90S2XgLs1zgGsxl82MVaS63SiwUzg7IY7+labWZXnGTF2j8LiHde70rih2TDV7uGepCdoGHCFoR1lR5t2pj3Bk786VnatW4Nj62vwOw98CX73/i/Ba3buhn90w1vgDbsvqiNrxUwPbFR08UieX/EKaNcRoW+L6QWroDoGCkAss+iLHlAdRvcwGArPSh89q0yKuWkBqixqgUp5BWyfIdrJHu0oF9GgCNVTRav29B2aF314QoNp4l8Wavprnk8+9QT89r33wL0HD8GZfj0DN5sWUwZx8WQkTxeqyZMwUDGoOiWohgzDSoYhL8zkBJ2bdzncyGIYjLejlCIOfCWpAar3gPPN7xbQQjRp0iNJ6TWoWy3vXtkEb9+zB959xVVw+bbzYOvU7ketgc2VNUKVkYEgHpcisrC6nGQQRINazZScB6qBUjD15iv28zINoOJ1lNYYAezNABbYtmrtvJstQhJX92jdgUHbp2xeUHygjh+g0q5DaERw3F+79DJ444UXw31Ru378ySfh9gPPwoEzp2ETSeTslovnub3JfVqkcjUltMYx5xCknaB5rhpd45TOp55BzaCYY0ZlWlwEqC48oJdlggKNPE47amUvCMCrdu2CvxHt57dGBq120/rJTbDMNLadizNMR6RBBw9AFHjp+WK/seYJkl0gaVwYr9A3KKZVeDv5RtLOS18lGLi6IzC1JZq0ZrruCuDZwigdPNW9LLnVXGc5VPzojqabPGmArdE2fsvFe+Ctl+yBY2tn4IuHDsGH9u+HLx47UvaLx/IFk3QiZRoZ/57vwFxRb+uKhaBxOORgc1CIMGSp//5uUJBIarAtpVpCppbjvws3b4YfuO56+Gu7L8r3+c0q8I/6iwaILT1l4oBGSQPnuwGG0Kt8mxnwCAohoKU1UqfR/dkIEh8C2nuhLRPqPTRpAXU60g3iuAikPVhSS2yFeadJwWreZN50ltRgAayBDfqaeMUvqp2/ugm+bs+l8DUR3HceOgD/5oEH4bkIcp223XnRMQGbKVuxHmqcxvih7RMoX4KjtAC9DxCKqYE4LE5G3iqa7dfEsbQo33dffS18xxVX5+18jUTW57XWVkUH27HBVaA0ElKjkfM+qA7lXtDGvN1mLSuHLpjy0XGnIdeqUBkJvt04Lc5J65WgScPI5tC18iquVQSe8QVaSCYR0NkJCmJN0/8cwChvXo+QvSkyEI0Rb4ua9g07d8EfRz/0H+57nFZUqsANHQg2mnWngpDOMVRXKig8tviSzo0fuiWZwT3APbxcl0LQi3+XSa5U/HNe9Fz85KtfBW+Jg76UfBbA+D39wSG430ERWrqWjRXJBYRgjewuI0kkMNh69I1M2xgdioA5WG4+Pf+uLdvWm7UcKhMABCXycr1ko1qVToPSXgbAI4JEYYmAVuLLuiwwCJtjO3/ftdfB1du3wa8/9CAcm/W84WWdETb2L/+xqo5BDXpQDvP5JyYHKoNbZ8T3cCQbrBlAVYzCk/IhQBxa74l+yZ97zevg2q3bq2sogJHQ5hdqJtzJW0HUpLRbJ35osaeNnletzVIJQEkr1zkVHca8Gr0HTg8uEN1G1CxoLq4o6t+guF7Kqnv1odDGg+L8YlJP2qthjgXNE1ASWl3Ly0hhKGR6dfH2iy6BK7Zug5+OHpEDZ8/mWWQ2c7Rg5NP0spVwQN8DaJsc4kWisQ+03HZa2rLNxSYGQEOKq/cJlE0UmNXx2Uuib/J/ffUb4OqtWwXM/QiY5V3cMGS0x1MLQ0H21sU8wma3ox4to3JXFcb1ogvZzRbAlaFB6wE8L8zrjc30uDBv3dSIxUmHZD4hMUrkS1fbMGutbC90xQ5HrPxXgsT4oYPjf2WjlMPP8cJDoO6njUx//g1vhH941+fhUHTN5o29lamErYqhh7Adh4jJYdxc5bmpj5BfY0JY6YagdpNlVQcsjOoL88npeX5k3v/5ujfl7SqCA7Ps5qWYKcwYntbrUM+Hn2WhSCdWbahsONMiHM8vOoogx0Wy8q9EQP4rAGBxE2rHEMFdUvNsXK5zN7/niI8elHRW9yQdHR1Ld/plMi7dvAV+IYL6A5//HDyfHOFsCmqLAEBwlalDmnFW5UubaPeyEr4pzH2XgxM2l8BqPUeABQJzGgD+WJzW3hPB3Dsga6kMYNWbzm8ecaH1y7NRWkJDxbKWLEkqB6xAyA6+vkqA+XyBNuJH9eNI/EbyCPayaht1M3tVwlDFSGU64g00KyhtElyxaCV15k8Q2ZGD2NRKg/KA8cotW+GHr3sZ/MJDD2QTlN/HblW9OFpxXvVH443JYfdVrg/o32GoAxEkRCbpnDYRev+VV8G74qh3RvyVjx6DVW0M5EWgboGMn5FBEBKQlaRm+rVG4YmXOmaszn+v4kYDLhGvicZzzMPFockbQcxBJYmLAGqMfZBMDuyabjvdETS4fZPoTkpkiCFhNn2C2jbfFN16Xzp+DP746afyhBroBQO5h5hCQMZvdWIsGHb4ybHpUjzGsXviECKi6POmWRkEfssll8rdwYaNAYy7bOA6WzJ47PCAkO3o8oEsyzOa9JFrkPNiawcY2GV/BUMFNO+HbU3A6glRTwhgqKPzx6lKW0q2MJwTGITgzBBqQ7HulPmhxeh/d821cMtzB+Bw3xfes7YIunbBncHgeuzeYFs3YRS0TArbOwYVTPZzP4vM6OEfvex62B0d7t7UGAAbykyWH1mbQzEPYHhuAzUUSSFtS/M1H2VNiI4kujs6d+jnx9K37p1zWlycdkA/A6Q8i4Zm7uz10zTWUF4ocOgd7+e1j1l2IKhz/RuP7ZMV+J+vfxX0eQfZWRlrkVoWM4qaUVNWh3fYanH5nXrjXJ4USVWnseug0Kk9ILdJktDRvnjz+RfAW3fstBUMbXNDshgisxmkh/ruyT/80g37rrCtU8oFWXjKLBHN5gtONh+oPj3kay2LPAtBO283nFY3Zn15B3X7gDSRekYzQ8kxPRWKlS8esADtpgijF8N0rOwkwvHzzXHi5TXbt8M9J54v73uI6w0sr5qmQgAzsYI4tKFReTcqb9BkI7OFRtgr1RbKyjzrsxm8N/ofJzQL6D9Pp6SGgWBya7d/UCUX26kt1QXELK2okYMbrVRgFy8I22KoO3cj4AbMkRczLbbSq9E+irnU0W8gs4C4xun5fWQ2O8AKFD43g/URAHuQ61WuUnHyNT/3XSjaOEpR+PZLL4e77v9iERSqg5VHEDS6ZfYwODMDcWCC1IkVIcy95Ic1XoM5AMggsDCgz+bGZdF2/oY4EBQprA5tZoxJZ31vDNj6XkuSAgNUg5pEmbz8wxKM/LPS4AttaNUxXtKgy7Fl6rZiQAfVGUVrsqKiNmKbuZoxEzCZqnWcA6g5AU0WtinlW/4LfcEB1inzBOqv3r0bLlxZhYNRAOYPQeT9GX7jztY7SAGqrEZbdbBsUGq5UkvgTqYGSee377oQtqaPIIP+LB2Mm24emD0zlr2WjpDaU+xFqIMOusZO2dHs1tMLRstX41jvdapzmOdHDnTn89Jj49rRhnw+llbFo7qHavwQlLEs0hnB2MEBqubTkhX8NcC4hg1Drcn5azxcsLIC3xy9HrM05upDNbnE1aILC0uLkMUv+EOVxmikcwDRDInYtHliNPT/mz17bCXCEMQtZkAjDnWcEqymyugliGtoMTPUr5zSm2qctndpPTGtc4ChzD7XtO5ap0V3L5/yC0n0joShHVUm5rrUtX7eVJONfZQMYSg8WjS2Qu8S6OWY33HRRfBvHtsLOOlLpx18V1d/gzIFw5zy7KZBriba3PDACvKbattnQG+NRL32vAvs5Ik2ORxj5klnVRTRB1Vz+oQaBB3NGKRGS+9Dd0oJyeCKPkmCMnUcnA0HG7B9XfHzQ9hY1rggr/rKXnnpCrlRsIKgY3OEHhETjNfm8HlqQamiF5LiyAoj0lyPn14dsXJB1ObHI3Y6Ze4FJbwG5bNpOBKmJoE/x0Ym6CrN3o1I1FVxNihIPAzUmSbOMyHYrEcFjA4BGpJf1KlSxYoZuQzj1cAqybsRCb1IDPm0sGR6nXaZMlxDy/MdGmbkAS91Ho378kxXPUHs6XBFDMqcd3+cTPMrOLCkwuuiR+y2o4dpJ1l6E3IseHzqXwplYqUlnRq1rMCriM5xaZnWKH6v2LRlkFayCENmhJFffW56Png6hs9l6sh2lKqoypeGxkGvL14P+hpPNXTpAG06TJpavPyMpZVztGXk5yhikNbRUYuiiSKPA9brA8mgvt6RASSozgADb9QYqNHdGhM62toRgUeRaUq8P3woC0R24dVdrtCqaHFV4qBcvh68D+0TDRpGIbMuHl4k9OVbNksluIB+RDpr4C8bWkJs8LwaELHZUdIRc9jNhUoasBpOL3KEKqnH+AKN61Zj4pxrXPD8vLRyHqrJkZtYOX+T1yC9KoryDVa5F7ind50BO7fJAMwAoxLcn7faJwV245mBJ52nwWGfPWRBFv0Z9GgYCscxwSFbUjCDEGqeY8xmKc1M6DMxPVyc3qijAoNmDljmhEa+LWAjjEvqUQZifTFJv/OLyn6uJgY/UtaHkI/vEIcEtK49sQDj4mtR5TaSFlx6+hAY5X4BhJga7JqmRkWZfOqaoIQl4lokzrsXGkcK50+nWRim9+YnQZfB4MGBK9CU5ezp5tt23r2XgRPql9wazGn5liyho4djhQcZyPdcviPXY20ZYAhkfz54hiUzYm04ig+6p2p9T/H5o1pwlQdoistip4Zx0Zry7lRaiVwi30Vp+TrU2V3UqMlx/N5KAQfS8g252syjFhe57VqdGRptRTxsC5eaxC+DwaRO0xp7PUvoOEwPk6pNQGEPsfqdEcwYQYfhV9+ukUKw0XI7aNWhP3+d36vDkBeD66YEp5tjQK51ACijfiA7ml1UoZohQNKqq2BnCnLDIwgUhm6JWgM0XgJHNbq0tefAIh1l0/K9IR0y1ymDXPvqKPtyzFOsobImAwGjBnGohGgrpkFpO4L6mrkGbW6ox4omD7Q8c5AbgiHU7WMLEY0bKgF2j5VQGhCDpdB/5lIWlOmFKHaMn+2HKzxocI+B2l+3znXP9irMlJdmvzITOkA9oWDcc7TgjEiNrvCFyK+DDt0qWHsVYKPkF5LW10yn82AucXnhHiGYOhaPAVDlxy8pM3o6GnSxJ4iYyLf1uzatxWf8uadUSg42Xg8INajX88tsALw9CHIOiA47wfGMsBhq2hRGJlawimNNpDpnYiszAhw4c8YkEGKCajMVWsxyVLTvIaiJhMqknBetDT1w2ynJVDJQkhTppKP3GNEDiIjttN5EW1EESxB1pJKKJXkD2NyKUmZXy0NVvhaX4r7p1HVQC3CoorraYbIZxhMrPDBcFEYb4dyCl7VHzq4De8sEzgFk3ZQCZWw8PcRoCnZQOC8IKIPKS1aLzoBK65uNVUKDG7AthwZFamwFlxiH9Jm2V9PdbC+iXo6KXXUpiQyqUibO5FDpLSEAyki2BIrbTzcTQlMkqLSoOWI6VWjGiVyiupTlFwIYkwP7KsgJ1IHfhR5r9OB+/fmisKDNdLGHzpxWu1yR10xWuwrVtSht28hEheZOsnriodanfjdYrtU9Sv+lo0dMVnodZzHtGrgQ6a3vIQw6pCETxqQ3DwRbElmBAt15Dp27bnFtDAXYiBnrdSNpTc92PdSnTzT2TmLnx6r6KnzH+h2UpMX6bjQzUh1sGnAeVZiBUVgGqBqwpDElmvujA3U69j7/PN1U5QGBG5mkOsAFw6Kg+Ffip/OaDsTBbXnt6CfN2MGjJ07YfCihMRPVvSwV6X6v2xOHNAVdOLTpzUlY+nTki+bGk7fu6Gl97Xs9joEWYOAC8gTMedTcHEsrrYbDDu4DWwyo0BBoYRleST4zF0zd9Bp3TSqDJUeK16BDm2asKuZAe53CHYcO5gUdDVhHtLjGoKePabSbBhGAsfGQDhrg+suHE7N1uOfIEXj1BTtECxtCAYxTnEEN/p76Ne6eMKTDS+rgpHIYvHlGQ/tOZcrJ6btCSUu3tAsLtaoOtaEZ52bGT2hScWj7hC5Hp9Vli6Zr8AD1M4VAZegkBvblDbwAMksK4qeHJhINPz24AgxNFVS0oQK/l3ooJObzew4fhsNnz8KmrZuBNWt5rBpgGi8BxgMX01x9NP/wZwdYkwfu/RDcrCpmoKRnbnrqCXgNAZrHKkiNItovDCnBFsGacfNqY55RElmtcWdEBADZ01Dqgwi23+iPZw0LJI3vqeKCd5qESGqmnZt3GD47SKsBBLXs/NupXsCjcn43lDulAnrvf0EJiwDW5Ajgx2IVzKF2QvMsBzXs+C/7HiNw86KanJXqlNJulqGhD4M4lX2lqV7YIU2NDiY9q3mkrZH/095H4ejaWT0e81ga/Dqa7L0W4+YF5eEQWxoa3+Pxd/z6+73WN4PdyDH2zaD/1m/ed4MbyXtuWqx1oLoGXy64Dx8kfn4QLUhAbbE/KNCKpFYdUoSbki0n19fhpiefzPtKopiHXusODYzABSr6NHC6eRXRBXCGrDL11g98JFto/+mTcOszT1WhCCPA5huuUF7rwRhG0Eg7Qi9wBVlKo3rfOfub6yc/SGDgOJQ0uLGjewFxG8nTHVy3vGKS1EXFq06Kgii0nX6kzduMBSudhwJSNLKAVwnS3K2IhA8/sR/2nnietmmuryWIpA6s+RXQCUDBla1De0sKHYEAowYl1M+XMO9PWDYj/92HH4L3XnZlZig6LonPODgGhhEilJrT9yWJZm4AA+QUiV1tSLZ/6/d7WnzoOo/3ngF/5oSXKq0OIhz0tWJa8YagVHXoARqRumCBGwKMaktUJWozE8DKFv54KE1x/+lje8uGUoQdmfhqcMJYCsr90vrca6nN6wcdklWPTCWhmB2JyNsPHoBPH3g2rxfM9rNIaEUTzFFVnhCDaWyrQjZ/RGNojsoBYNUE1MkHwTlaOhSfscUwn5ZPfdpRhqq0rV+X1uSlz/vWbWI+zRnJjc4C2vCzYqZkyd8aNuqi95fMbFM0yJyWO2575hm47dmnodu8iSQ0vaNNhRQPFZg6t+RaK4jJYfg1gvD6fmopzXx7lmzo1OOmUwiTKfzE7Z+EE2trw3EZDPHVbDgP7jGafLwTCbwCaVZVtF5FGIC8cZAnwHzLR6bAeNpuGN+65vRj9xalbeVtxGCNs68AKPOLhJBrYBh0QNUuGGyctB3/hNq+HbTJOnDqJPzs7Z/JGOmmK1kAajpaUleEk2nnNiQkK1NhegI9UMBKSRRgM4PSlrfRcbIyhSdOn4JfufcusZs6B2JU+TAjhIeoDo4Plr/eQtGVr7OBZD8SEbxoIxoQdEbtobI/669dtEXHDY+WPe7Tdy9aWvYu1WsHXKyTKKCAzfaoB4n8jhyadYM4Hr9ilQUTdaTrP3r0Edh76gR0ar9v+QwuI0pnVvFl5R2aejJm01/jtsMBeOuLSkGii+7S343l4vKHmph73GQ2hX5lFX4v2tJvu/ASeM/lVxq1xhNXKBnTj1J180JL60s+Ipn1OtGd6kUMZLAMFB2KhgeguFPobaQdBGKw7f0ATZni00JFy2ASpzZcHXgQHUGLTRDzA5VNwO7VIDbrkNdGcKibTQsoVHKR6sCSmf1I+vjQY4/Br3/x3gjm1bKpUPZwdCJsRKhKmSisq6apIxrrgBLAezkaDVSXX2UGQ2OmiRidXXeTDOrUA0/F6J/49Cfg8RPHW9pwKLFR52aZGRo3jJRGVQctIsTe6ZR/uhPpXJct6KoYaal4oz+7kYq8GGlV2XPpoLQTdHXRYpK0ledHp+IavOSIlsWH/ly1H4N5oorg86dPPg8/dfunIyYCdKvTMiCcVI9T0BkCmEkfng6pn9LBaOhcHUYuGDRob6OKZ/EfiUxmx2Ql2kfxOBxm8Hdu/At4MlZIqx7+1W0EXB+0jJMylQQPY3Tq4XSngQE0cKV7WHdq4nhxebmGx5EDGgduIP2yaXFeeqRBlJEWYNLXDtM4Wk3ueBoabOZ26kCKGxxT+n306BH4rg9/CA716xkXk2Q7J9OUJbRkCCQwa+sHVRY06Bs0v7s2NrLEMZPSuZ9w6RQSsdiiidBJlNCT1Uh8VC9PnTkD33PTX8ADRw4bKe3bwHTAxZ1R6OXReaGHpVpn3/vN0SVeJJh0xG5wjs5nbQ1F1YFR27rdaFpYKm3XTAsL6bA0DydcbBsBS22aWGHzQgRGsKaHP/ghxpluvwmBin8fPHwI3v+RG+GJU6cyFiarqxkbWUJrDcT0UaMHwhpAo0NhbXsfOhgBSTNoCY1Qu49Bo5bSkfhNqzDdvAqPxQr93QjqG/ftNSqJe3h+NNjyvStJ3Ejuvr7WYBYA53g1KGJpTGqbvR9GbWu1bI5W3Fj6jabFJdP6vMlkEoaWZwIOTZb6+ijV3fFRL//FfGfvRnDto9stS2k6WBN//Mn98L0f/gvYf+Y0TDYXLGTNnSSz0Aa1XRAHps4A7GBp8KEbfbCRUQUMqQP5pY8tOyWBaDfRrGJSr9y0CZ6brcP/8LFb4Ne+8Hk4G8/FAwJOUsOQeSKFg13ERjO6dLBOJFzQnc1LbLpn1sDDZQ5YMl1JixtIu3y+7WPgmlMdeCipARaqPxeUAJUsuO20kEpt+y9jG//AzTfCkX4WBdommCYMrK5kTGAyNzplP3tBKQV6c8QR3cCo9XIggneBYagP1BdPyug7u8LVtkeBE2WTFYtbhhFHjF6P5sc/v+sO+I8P3g8/+7avha+77AroqGdWVUOg1nWDOZpDh86ty6HB5cAMUD69yq3gRs7NkSnfaxHCBBpCUf1dIm2rks20dN2P01FeUIK6vFlHz6e6zpQrb0HAxq/xXiggJwR8dN9j8HOf+VR+BWKyGoG8aSUem/J4aiKejfoWpOSM5aW4YsLWOQ5U9ytGHJCVN8h89R0aFZFzLDM5qKa+q1slqNnxOmLNg5KQPB6g7K0C7Mejn/oHPvpheMeey+F7rn813HDRHtgeGSBVRD26tcQNANJqhdzhnBRj0KBqZE5jnsd2nq3zVhos3JlLqUeKxDeeW3qTG2jYA1TvvHmMykd3Wq0Ng9WGuh8PqkTnZ9bX4RNPPA6/f/+X4PY4A7geTc4E4mxukmROE27JA8ZChds56GxVG/G7JxnHlD40qleJK2G6kEdoMxGzQ14thboXAYRqKrD663jbsSlotdrHnjo7uwY3P/0k3BR79cvPuwDefeXV8O6rXgYv27ELNiW1BNbkgAXnOSgpHJRak0EQn2dSOjvBYEAwYMNyGkLS15dsFvVAk3fAdiO00vYqQlqcwMvCINU12WhZCyW7OQBPJmVtZmy6eqp/TTXo5MTZs7Dv2BH4yGOPwI3xeOLkiTj7F8dOEbwrEcRddgqsFqkcvRri0UD13jNrfmTgwiivREjC/GA3DZITBPvmfbkZ2Mxwb3MHrqn+4lg5+vOCgdk/XRo6/eu7AvY+MmEWzx+Obr2H4szib3/xbrjhwovh+197A3zd5VfDhgMDtkPTgXiWMDhJXc0SVVVss83HLsIqAixuAZ1WnczLW+LJYrB9oHzRXn4Lv+sH4gG8vc0dQX+VrUNo0Hd3lML/4vbb4AsHnoX1DsskSQTylFy1xWU7zWDOQJ6wZGZzIYCxjzletw2otmkxZKSNllpOV2cU5BoHta9fW2C1a/QX0HmwqOhR7qjLz9sE33jJ5fDeK6+BV+68EFYi+oMzM4x6GqW1SmLjV9amBzOqQ/uc/CyHQhyLDHMeWFLM40bSpj9iR6ajr5n02ZAmEzTxJdS6Iw68HABK0IfBcCCH1128B371ve+D+w8diJ6MffDnUcMenK1VIOf3NJyfGSwPeE2QodStLbwRjcjB7LEy/AwBbLycC3KJokBblWC9nVxCZdM/Mt0C8FfX2CO9btrD11xyKXzbZVfCe/ZcASsR7bNQN5rx1VwUcppOgVkDubMvJaEGt3CW69nBUDb5EUZonNM1wsj91j0Yzwtxflpt6HLaPCDsgPe8yRvk9sSLvD8gVp88DYbFdlb28wDkQVEY/yST8IaLL4W3xPb7wJveDB9/5in4w8cfgTuPxrmGSXm/pJPBH4A2NcoMZeE5GlSXOkg6biO91MPgdQAbP1w5qRVK9zbnvKwWybXKb/TdOkjanjiVlOE1286Dn3j5q+DtaR/DvgBY9jNUDB0DdvAHdyQjkbvqjyXah+48MqMKp3NupYrooIgiO4LUDdTdSldJg4oDnq817xeWlmhGereG+V2NDRnz8DYPdrJo6OUII7+ozBJjosRjJZqT74neqvdefgV8/MAz8MsP3RfnHU4W5QCVd0QARTZ+0X16pXgglPjnJEm5njZvclwYkYvcTSEM5IecZYEXKpMTE/JK6D384wjkb4/ejQumq4PdZf1Os5l/oTYoV00kCJEpzB645kDZyQTgfG1n30QikEEq/VMGEIqXUtdQCcAKtIIdFzfCRsKZZtsG0iJotMueNyqS6ShNljpzqLzocCAg+BwaUhpIe7KXk/dM4SPt9Z02rH/Lrt3wh08+Dr+59xE4lRJNwCjCIZi5HIc3w3AcxjfCYLHGEQib3o6NpQ3Mjp6uQxWA9rAj2lX/5JWvgW+95LKs/WYklc0Os6HSMSotGnGmsomU5kQJVIYydjWDU2C7us6lU77BcUP9emnirwchuLS+Zv63kRYdkynfMGhN3TtJCqIaFFKy4A+wgqRXxfAneEyxFNMVUG+N5sj7r7oO9mzaAv9blNbHs9dlonSLpxABYBykLBs8R1ph2krQAngrs0DgZmmuP60qpwhld6weLp6swK+//k3w6u3nZxNDwByUuaHALYAOlo4x2iSQe66+OwwCYuOX5tyQGQq2dTqcwxVY4t5G0uPwXFwX6l4mrZEWgpIlLKor+upileX5Ym3UOrbmZ3QI6sSbHTOlHWbBPvM3on39qvPPgx+9+/PwRHTzsWjX4GTpjKrTDYVUW6gN6IM6tWAOL4sQYKBua9paQ/SFJWamrSo2bYbfueGtAzDro2+B2REcWoeW6MGWbSkFhxtqhczNAGbRlnlYNJxZNpxD2mX6COLwRnNixj9cz/0rBgOtDwp8dF/zno8kmVvteu2W7fCrr78BLkoLmye1TFPLlhrukFWGLzo8jXw05z4HvJxjsyDX0quSUNb73Rzjf/N1b4IrN2+pYO7L0fcwvmWyVn3QALWTBmJzEyDlKwZsdEiSyhKvegO6f8OY8TsvVdp5sRr/ui9WBw4qa0vlxgNk02YDPMt173ivN1RddyBed8e1W7fBb0dPyBagtaB94wEqqylsrP+DqjDwywz+0IlEPyB4VW2lYFCMKVtUhNkMfj7azFdu3poBvM5gdpI5gxvqN7cayPPUod9mOf121FA4QLEmHWGABu6aGMwnYKDOFx0vVdrR9GDrxSc8bezrzQffTrzywqS5lTUdJr6haVP7roXazuuUJv1etmkr/PT1r8wCToN6gF0vPNER3sKnGmS2306ZI5HtbIdlWrlVtkhOYP5AHBi8e/fFUjEBtTv0xucMYgE4wGAHWi+5tdS4dss2KHYYGrFleRHUOJElFplMga6VoMCRAxZc4waePae8pV+GKoFd29kxMXVaSp037HG8Np2l0YFyeyAd6lltcmTJDOVYU3HfEv3W358+x5uVcVXGClHklbwZ3Noq1Yo1wuLXrRoZFdwSBUEbBMVESlskvyqqme+Mg4Je+ZhbPV8kQG+vPWKD+pUSdT5E0jt27C43mvyocAiidSiepjnrErX+2QYrFlzDBp49p7xFyhH9pUe6p+jJUCU9R31TFDYiSPQBVUiYNoDKd/DtF6yEZxD3wQqx74mAvnrTpgzoIJMMWDMUTJ1baAPaZ4g1PkiN1G8oPSrQILCLhP5InMK+cLqpAlnZzTPFjL53IFUMazKTy1MdQXeOH7z0Srgu2ut17epGPQjwQYMXB4leYNhoo5xLIypa1Xsdhluo40udE2+u2bwZvvviy9rjGA9saJsecg8aZkivzA5lelwQvV3/8NqXw2w2K4PEXm0wDgCGD9KrYNgsI6BfOChEWCClGOBU2z5K59dt2w7v2nWRVJQrpE0LPb3N6o7pbOBZ953BoRti12QVfvaKl0cpsBlkyznJQzMrEB898AMMnbLncsBLnD6AbnypR4BBXYJOE5l01epm+PHLrxWBMwsLvEtt7EBotQmDnto15w9qvBSPr9mxC752x84ipUN1OdbC69ziMkFjdKojszkRQrNSOgbliTrNyv7mZDt/Z5w4SSKhNdhoTW97Bo2FIKWWIPtGh+oDTRL7TVvPh//76lfBfzj8LNx04hjsWz9b3u7Ls2MBZEbFuQXqYBEWE8IsWCaElzAtAAE5WAQy4Gn/m0k8rooA/przt8P7d10KO+Lkx3oYd5kOMDZGQgDxG3DQryuke6mMVKX8Bkc8X8UJfOtFe+AThw/n5eOwo0y4QxIOB+MBqPc8G6QZr/zc54Khbiwl9yRmlJIU6R2NZOj3a+tw9XQFfv+Nb4Wt3VTUTFY7oLwZWiipopbqlGgHRfqrCfP5fGfvySCqYRsvwo+wgXnOeVTz1CUcVsV3xrFyWhdhIWGNfILVYPyrJSW3j0jSoDxNUCXuouB5qj+p4+8Lk+Rc6cpMXvo906/D++74FDwXZuo7w5RJZ8c22mMl5gcOC6fQ3tZtNDiZGhTz8vbIM3jHzj2wXfX+BGRjZsBiMGsKsEWCAk2vHkg/HVeqr9O1MgseKrCNlFV5oqNBbrtxCzSJs7QMgmOvATnXqdETmnkpAseEQQvQRlsqU3AWbHuMgVnzReKUlEZVJn9bkLUoS+oE8FCmx7/9kj3wm0/ui2OuXjZ6KjPPAIOGyVEIi4Te+PvQwVLcYnQVA8U266O58b7o2WBm8K+RyP1iMAdXDEtkRY6pL4M6v/mbpA5JZ1ZzvDa2dHpfgKOhiXdsly8NqYGH86VqcHUz5PT1HsC8hGCcA2G8OBEi+lcG51B/Nfh9xwOY3y6jpgfWNpAxFYH6XdHL8hv79kKYTgkYtOmm+WKBrkE34niY/4I/jkVaSBbDvoft0R56RRwQ9r2VBMbPOXi6hnmN0orLL3sqUAeSCtnzgUpCsHRmvsASQQM2OECrziQrbbFBD3Pq1ei4SBfVC1HycvJETK1BXvPAHCyvjaTW5wADIeTzHGsDqQO0EwTVBjKvEEr7vHr7edGWn8Dx7MIjW7qR2+CrtDmFjgO6qU6D+Q2kQ9ldl97ZSB/RejDLyDfUAYNm9Fw1PacOjCEtLVhjZQYqUwOUyTFWPak6g1gBTfZHYWIoE2PChXHpls/RpjP14/yDep46CpepAb3MABpcegYT09gSMqZdXB4Lg2okLXD0hlB6MmYSmfem83bAx44fIQnd1Rfecl4NaQIwt/GW+wSLM/FiRzhTAH11nOI2zApgZv9aDGMA9rA4GFCH2nNR1T+Fju7rdanB9fJWXKtAb37kaIMspWoV6JlWkbzBdQamP9g00ik4bbD1NnnoOLD5mijX0Xr1nO+AXGed91weUcCRa22embKo8Ku3xDmDo4cgKCeDBTAuTwRoQOveYIxUzlSLEBCq2NzI/s0tWw2TmPktuwwABlJkmdACtcRRRjMGOsWZX9daZsDM0b5RqQDhSHDEBKspWCoNaO+H4OOj19KbeaeaQOc94JeOYI0UhvwN7tx3njAn26WDaiCNIoMLrFJ618pqeVUiqK2RWw1l7A4vnapEGF1ON5DI45f5pXrefqSMEqgvXl09J6ZslHEe1PnHixWwDNUiTpsdxmsBMBRPrV/uREoG1AxV52U54B7XhLEnRkwxnT6UTmBkSytoHjQawJM/qFIYz/6cQO2e58O/sZeO5BHLApEJocDv2QudWN8S1PSa5or3pjhCxXyzxc7uBPJyrKrF/7Q0mFvbcwweh9yJmdZBIwZlZzfuWZ0+LKw18NZb1Q1wpKTUoDyv6MCaXKIRejVJ0UKj7jDObhupxvBeWKqvzA1Olw9IDa5T9aqtpjxRQgdrU+ZvS4OKFmpgdLENHdwTvSabDupd2HhUKhLmM/lcwqCXslSkc98pQ+MZnJPvWJwHRl+LFm1g0rPkZomu81BSHdTzHNcaW7SUSIvoMHLOEWO832ibeDDjgnTmmhHu7o7lsSi0AY3zSQmtk/j/bD9rpB420jyh84IDc3TOWKIFiEWNEFS+Bgyq4wiY6ab3agwGfT5/cB1jhLCxDjdicQyfUXTASF6Lgi5Paz7vixYJje2815K5YXo4M9S3nrseabDFEpoNdG1jtDgXw4H03Rice+861zAA7ghKrb1VG0LuKZu49y0W6jNmyarQaDDNrgatetCk+ajBF8bqBjC0+VWn4nGBLr8fo2MD8YvShpEbWpjla1eZo2trdqKLnsqbHcHGQ3sZA+/t0Ht1NVqLXxx//OTz0AxBnhyZcXzhodnwPl4B0WNiEHDeTRATysgSVRizbzApADAwL4LuFOpmcOmXeXndegpgYOJwXPNZeHFDZrcXKmhZe/DMaStZ+I5vUNSN5+6rVza6QYlS1EhmY8THNPcdP9rOQUmkpY6wgbTqWDRRwA0pC3QjyAtLT508XgYbxPBOV1uZMNLowXaUfM+lL8sKQ/2MyjEGNV0ufw8uDVIGCh97jx2SF7DkRSx+bn6zgarOSxsUb5nuFPaePAGAOK6FdMVb9+W6ZLrxL1YG+aLs9bH35EkzA6zbFlzcgkzPOXhADDp+UGCAAoDT62vwU7feCCfXzgy3yZhTzkCdAhg/awZyB+Ir77GCmz9h8p2Ega3rwLQbIEPpdGcj7b92+62wlhaQx9oRDajn0B/ghYPZ8ELFGbrdM3x95+GDwMtL4AtoeH6y8xH+nK+1NMJB4gLq07MZ3HX4kH3DDU2yHIQBYdigoxKW1TLMl8IAI+q1IcH4uP/wAbj38LPw2LGjAzBji3bXQoYOBOvShBYT7XOeZgQHCFQNRuf8WuYjRw7C3QefhYcjMMxWH1jrr/mnJ7n80W/wCHMOUOVKBR1f7z16GI6tr6sNmywP2sbDfNB3vicbZvq8JK1ycgt6u7wA40effdqCYQTUfC70BYB5HVR7DFoEekmsJzs8OBnY6Z3pvBfIU/vyB50373vEbJFhwI2OfvrtB4UrglogpjgvffVvUHXQr7wybXonsdueeAzOhBnc/PhDeaOeCdo3DXGMPGyTvGzABfn5cvnddW0q/dmTT+S94dHZIsVERpMPjuXr7rU/wZL80c6CNbzcslsTrff8n5/cF3vd2YpzsKAGaDBzpCcNJK0CA0uZQXq0z0rHAQUKtRfPegTDBx9/OK9r/JEnH8/7gzDQtQoXm9rTzWVjI16VG3D00VJ1tI0tDYm1ofSmPGlG7EQ0kW6NnTEtKP6XTz2e66K3zht83ADDjq95tdEwT8Nwh2Sa0V2fipL5o88+WRbEz4viE44oB6HTjyLVKTZoqoPCUVGO4FBd+w6DGQuY01cHaW+NTx08INKtpeI1R7TP1khhPtVpggWtJtnYs3T4vqhpYgmdAHHo7Jm8nvEzZ07BbU/vL4DohuobdB1QsUafa3taHbpqZnbP5cv30cWL1ugK3QnQ9xx6FvadeD7TfuDMGfjoE3ulM2pQG23uCYPaDmGePeeO0MjDXxvtAlbz3fLMk/BYHBAWCd3ROtKVIShMrlxo2tjGBOBBoQY16tZxD+pfUzhmwhKg03Zuv/3og1Fa9Haf584x2BXjpzmFIegOxSgNfKQ8AG0dfZnc0FNq+D945AHaT3ElRk7gDx59ANIaHQO6u6G0KwXU8oNli6mLodPfV52iU3XWHUoDuWweG+BPEu0rtNNYPP7r44/k+1NVP94vUH8W5VsQG829TPDmpD40r/QncumYRWz80eN7C16mE6h7lcMAoCBqDsCqe0c0nXeLKWZydbzKHMBK6UjgZw8fhk8ceNbaoyo76bnpYTWAMJILQQZY5gA7AOMgj9JJLrdTQAb1fRv9fjRK589GKVf2AynA+Pyh5+DmaHrkNJ0FtedfRx0MGuuj67FBa5UjbwJ4a85rEk37Sjw+9fST8JkDz5TOmGmfwO3x+rZYp6kCvv7WUuMBHQIzL5VdE9y9sCCNViWylU2ngKzOb33mqYiRg2WV/7RVCdvRhhEOc9Bo7EYYWTlp/AEDcAXsBOZJ2rh+WnYJ/cUv3Q1HkirvhpIGPXMBmpLLd0gtfX16VCdMYl6DEWGw/Vhi7snZGvzS3Z+j7cZou960oGC8+fN33Zk/4vS2aBMcmpOuIoM06K7pOW0nC5hBgRpq2Qmsa5G2n7/r9kxrJ7SXHVp/8Qt3wrGzpwX8GtiirbpGh/L8bPEch+0DFgbVvFC8zr9Q6DgUafs/vvSFrA0TXspq/938Rm0V7KJ0M7haUHBq0qJQIqXGbAfljesjqO8/cQx+66H7TQ9t2XVjzNJBC785nXNIIsLAK8DH7z98P+w9cTyrvdQJ80HnT0Vb+l/fd4+R5gLmDoZmEMAArEYC6mvFtk5dexOpc+VqcP72/V+CJ6LPP29sSkJkQttR74t26Z/sfUjS+kN3Ri/0/CBca00+b74Oy3UAMB4Wz7e0PevvP/IQ7Dt1qmw0lPZi6SZ1E07B05BAnNfoKtTldEe7HxLDVeaoDHSyfdjLUTeuX4V/F23pv4heD89QM2iBBjhgSAo6svw9n0fnmUkdKn1C/2f7HoV/dd+9tO902egmdcQJb0UWj9+4/4vRJNkvdqsxQbBhRvE5qVyhFRtp6DrofEKVnppfbGLw70eeeBx+6767YbJphWznKe3YOy3aJpog/9e9d8EHH3ukLBvAtndXXXrieXD0MG+D8x0HjXZ0fAcwGiXzvquSeaqOD0Us/OsoSDK/eb/vSfFwaKnG66Ogxp2AvB2Ylo6XVA30LqrYwwDGrgl8nW3CCnIGNw8MJxMyPSLBSSX+7BfugPuPHxEpzcAYmCKKud0yAFdpWGoaNY1qMIWlQdPx8LEj8M8+91k4neIJEJM8mJ3IICXFpy+R/6fPfBIeOHJ4KOXAaprW3uVeeosUVucizdSzvizmVwLzQ0ePwM/dcXve4zGbSStTorsjTVNAjvH3FyLfvxTt1Ck9K/ynQ0tQGTAC2MEjtoFrTCN18GCUtcNKVzvjo8ePwk9/7jMZE4nG6YRox44GhYwnICHJjKo49HjTeGWCO/CR0kVrJtJrOK3qRbr1qvuu7vF9pO/h73/qY/DUqeeNlOPKD4DtQO1tuGYcOHBpqaSkUwLzf3/bR+F4nA6ZrGySBU462ksvg2JSpF3aATVtpfBDH/8oPBif0w017WwjzgOzsSvBSmNtVmg7mQ8GQzqePPk8/Eik/XC0n7u8sWWL9kmW0NN4HItt+IGYfv/zxwywWl4Q7QnhJs3XwQK8C/Y+P5eWJBC6QbUvnT8daX//rTfDmSTwWCtOaTBoGlrkp+BPRFhLOjfi8Jq777ZmqTeSsMTJJzLKuDIfNvI6ZbQc2PraOqyfPQuzeKydOg07I/H/z9e/G1523gV1ERq1ao9fxXKMFEt9Za6W7hpszOj90V7+7ls+BIfixEnatndKG0VOaC89pDLSAoJ9JGx97Wykfy3vTb5ndTP8+298D1y6bbssnCOL6GClmd/h0DSHEdqZnZn+INURAE2hStEnjh+Dv3fLTXAg0lRoX420k4RTtCfez/pZoZtov2LTFvj1r3sXXHXe+WZpW1lkJkBzNasgRDqWV9w1B9zaPEudKAmDf/DJKNDiZFvexD7SzzvNdnkTe16irQ5OMsidLc2Se8BMB+rJjh/+4f8F5gXUDzHruDx1DaxeiSiAahvFcDLODP3Row/BVdu2wSsuuADqrBAMTQgYSl4ttb1fU2zkzrrlsrqNx3+JNvMPfvwWeD7Fpf2naQ/qTjZT76qGEW3TSWHHYqf8k0cehiu2b4NX7txR6Waed65DUaWEXufZYfWuTZiJphlrPT6yfx/8yMf/Eg5HbZGBvKlIuMmAdiKEAA4EiuRp+qM4lnlZBPT1519glKqx7xVfEYbnk86acVrbshZc0b8x/qZo7//EZ2+DgyxEEqBXqqmU7WfXuIXvAjBiXrUUKtBUI8wF9NiDgzgEh2eTRNs6DP61KEFujJWcxd/E3G3J3tNMhSG4NXM7BQ593emBlDIzjsXG/K0Hvgi/GAdJZ7ATIBdATCoglC9LQN0RE2mvw1NR69y0b1/+oPOa886D80Zo9+aQNkUMQBqAnlJ8+j0ZJdov3fU5+OV774aTKT7SvbKpRXsnTKu0E7CJiLUofv/8sUdz21x7/vmwPdEOli5PoxEg6toM7qE9eH0+8v1f3veFyPfPw6mYMG9kT6ZQcZFW2mUDUGIceheYs6PngTlHDUyOFEbeAA+ik/oq+vvyxXf169BC1oEWcEzmx/paND3Ws/nBZsjVm7fAT7z+q+Cdey6PDOkG664xGU1KcAh+bYOeiRLhtmefjgOjO2FvtN+K5yKZGKt5AiK7ubqJME73fl7ZMn9aH9X3bD3RT+bTWqrHGlweaf+ZN78Fvv7Sy/KAzK8IZNQ22DpgY9aQ9yzqch49fPqZZ+CffvqTcSr+tKO9uOk6nioeoT0RMiPaZ5n2tczzRPsroqT+4de8Hr7h0itz6WZrEGi76wy9CmsT/qXzNAP4mQNPwy/f8zl44Pnj0RNDAmS1emTy/t9KIxpTg8EdQIHcSWeDg3mA1jf79rIvZhlT/rDR2NIAvKQBr4Bd1rxbz4ydra1npiZw9BEcIca9bfdF8J3XvBzefdmVsGU6ta84wpCxqOpiJEk8PxE7zs3RNfSf47Tqrc8+lScdpnkWjcAgdudEADEaAtAq831enDuDOY0Loh3bn020z+CrL74Y3nfttfBNV12Vpd5gSVq0tOuLTL+yoY9Ge/fWOPv3+w8+CHcefC6q47Qh/JRUdOmIxW/bKdpHVKTQXkGd6M/AjnXoYn1eu2MnfMe1L4f3XH41bIt80qtc8a8Onu9a2xyPPLk9Avl3H7ov0n6gDFizRF6VafmJTHNP8kNDMAOYUT8BGnXB8r1hI9B9vPaeeyrt/EAIlVXaCB8MDivajJSmDhFohfZAA60C7JlIugRqZvY1ccD1jXuugG+/5jp4ZWR2KrQlJTSDS90C3HP4UDZl/mTvI/DM6VNlKpt8s8zQjtR0deRzvii4EJ4BrUUSaBFKBsdaAkcBxSw2YqpLH+m/aus2eOell8L7XnYdvCl2UNmPRPjW6JBQAH3Xc8/Bjfsehz999FF4+vQpmiyZin9cBq5Tol1UNEiDq2ar3CJQ8+ZNBdhr0jHT0sepPa7del7eb/19174MXnXBTuClxlvaUWMuCbG7Dz0Ht0Zf/QejAHni9IncCQvPiwDp2MRIbsWueGOA5ityfmn/9XTSVds5l58L6gSnAuKgpAEUya35mqHKgJYIboMgzW1upLWg7ar9UJpfJHZGcr6OrAQkSd0rEySBOAFhRkdibmJ4ktipEc6PDfrmCy+Ga7afBxdG9X5+sh+JgLWYz/FoXx6MnpO9cTbyzgiIw2tnyjsBNEvJEw1ZKrB7iyRbp2xOgkRFXf6rUVjq03OnTEeiN0vsdalHn4AdwZHqd0Es780XXQTXRFt195bNcEGincpKtuzRqJ0OnY60R8/F5yPtB8+cNTOs2Q+eNEukP7vjplUqi5mhGzV3HKwLs7DJpMxD9twk/s4GtJf6JNp3Rtpft+vC7InavXlzHCes5vXnUogp8uD4udjpHovmxF1RixyJnRrFB86TJVM5Ty5QZD851lFlBm1nB4DJdg7GxKjnDDcWQlxngKGSzYCGVhizo/meA3WGtTJDyAdW05NbLzO2nxWJvb4uUruAYpalSU8bsvRkk4vIMHqvU7OTXQX0ZCqDJlZx7O+UKVbdc1HLzGDrzp0V2Kb2wE6dcVb2CyHaWRsF3gXJ85JUbWrUTDcN7jKQJ9OqSQztRL+g2dPebjutZRI9zPvAZghpzcT7zHfZnaov30XrsZIMygotQhdpDn6Hp+NOyG0y6Spw2dRA6/bRAG4OBFth5N507gMNR7CVZ6yuS/dJdMoH4lyBQFvzpsqnDYUmHc009qUh+8QIZuiMVCRtbxF6JWmG6gZI4qK8utoViUHqLcejArLoTPVrEUKVq4BG6qBZgmA5WFp2swn00zhJQ2BIC75nLUQ7pga/vpfy+Ajtk05evUUBwRzaofFrQgC2eVghs/RLwOr7JB2TCRP5nrXKtPB9VjsrjPGdaJeX8h3txa9M8ZjukX0iLjkE4xoCBWapTwPMWgCN1ruEja0+ajLkxkKoi9xpUEvXjrf7AuJU2QQOJID0XWZiVqWRKazaZTMZ9qAAGCM0k9LV/bxRqWQUkNMLUwbAlXFo6qUrF4oECUGtA106dx7ERTDk1wQS7dRJQ+pM3AFZktPoVvY/UdKg0K20hjmQ7HwE80qlp320UQvRTdonpNozj0t5YdIX2jXfaYJM+J6Obg7tJIUHmlAdAzCjm53WUrpVJTkfB3MK87ek8NcmKS/oSAAQBhCoZRVwECAH0AwuwM62VPo0ui9xxUwJ4vrLwHKjKv0yS/W9FjUIZI8NmCXPcSbYZpjaQAXVaMvQnssk2vtUZho4VrNKz6AuTTv7wVu0E78r7Ypo075YtaVI6hbtSUqHzHfueL3srxdqHTiPIu6HtJP/3ggWJzw8sOvzmnjbHrgAtPPCdID4RZlpTwjSICr34I7AX6RRYQOafJH91KoiWVqTfZx/J50CBVTGUnrJ34AUrY2pQbsIzD54aZCL6/NC7kHVveTYZ6lXBiwh84D3Aay0g6IfLO2IDiScxA1ccQHtWvAgOl5pkms65HwTnV2QjhkE1OD4DoYW4bumXUtZHSevH+pnoKaFeo4D3jfqOicsb3IMCiJQA3diRQ1J7jwY6INdEQgnWU2D8BZFMiCbLZSH2WAueJsDrOo1IKZ8jIRGWwd5RpUpZCqpyvqWO1w2RZj4yQjtQeUFA1ygq8eARlyedqx2jOOXTT+gXQ1YBdx0rbvfwFyaR7t0QAAZ+Ml9UJ1X5aE6wQsFcwpTjbVmUBWVtHwyCupQJFpKlE0KxewQSJqTVOPGR8pUhFooDGBJgR1UicP54RDQAIBO5QV9XzO2PmJPVQ+sp1ReNjPSNfnaNY8g1A1FSL1L5waiGX2h2KAdXN0U0M11bYpyqfilaWfNwlqS8hCNw3wXcwWE/wGHgsTSrujmarBEVmlqvQCqr/nFBXMKZuNNqxhrvj5/c88wiWznTHxhEtLgShqXMFyaVzFZSYKgGbsMHU6CMYil8QXElZm2fjpXMqW4oQgkgW1+BmgyL6h+tSOivDq3iOZKru2QfM31CqoDapkRTI4cF1Q+NTGbbTJ2z0IGlKSu6ZaiGSzfmc+8KLmhnUAr5ikDGXGw4ZW0G8LAyGydt/hsTI5Bp9C/oma5cCApCwLKoOINgVoqAJJkhjpBg1WKo86EH2MbW2qAhglYiTRSgJlHlqq6Jyn0IxIbGBcQNANMvVnDBKKd0RKU1gJdd8VHLY1atNdzpElBHKWdfwLUzgdEOypeMFSlGZE1iGpXqhwaLWlpr+RZMGvaUfO9EV/4AnYFWBU/aBPEAZDBXfPvtJVoNKAd+fsGQGJCYG5nSwHNLKKuYHBbSxUQ8iruOOyGo3S5E7TMMw/XnmB/VTkCwlDjURAkibI2MqzO/3WdYJB3m3aFTAI5eoDDCO0WiyBodPtTiMQOoaLJPSwQDUMyxWxxJGnazMcgDhtSjsqjVNcxhdvNlbcURmN66+XwROtrf48yKPdUkRrY8uYUWN3AmBB7SW9xQYl0e4wCQV0oqSESQz/fArDPSC/sAa7uwRPD0ockMxfm9iscFINQeRkqregb3nQAtHVo0WzOcQjaUhFgyVnpINoNwGEIalO+ohNgfudjfqqOizAHS63rFib9L92bbjhTbLSWAU8thIWCrHOlgco2HD2jwQ1BD+Ra4qIWjIY2dUuBxdI9TKvlgDEQdJ1QgxqgaigCJPuv2YaeR7uyK5envUkwKAMGzFggKBAx7SLRg8qXaCeAByZg0Mw4LLFFO0e0OiBWSBth2IBUE2emTBymyxL6XAMDV65BEVh7jICaEykholV6uV0NKA2yprRoE1V/Rhg693F/Txfd6pRMuxoUV6nlM2gV0Cj9y017TqsEi87pXPhO+bQ6oBE+nP9GwLxEOHdAc8HB1boBbNR+WZYaGvgi/eYxcsT+QEePv4HtpMsyzXhwwNPuAMIheDJeGO3nQrce0M2lXZMHG6AdWvSPgNikASvUBnmeO5hTeGGA1gRsANg5WtMtEgSy0h/uOei7MsK4SoTlgTAmIXS80zZMrpSQcNGhnVkz9L8ItGs6WjT6eJ++QTt7c2paR7sZM+j7uDHacUFHWJTWPRZgfpiWdzKU/5Ey1e9D13rj0FdJUjo4aT2UDjZvW+nyE9QFC4eQB5RolEGllU3DlqhRNOtn1L3RJW7RyyVUQABomloZpx1REXj8pX0HjmbK19RaiAaemBnQ7Mod3ENFM+eNdWyQ2cltizUH7o+opLmlGW2nMGmpDYxbF4c0W9IVzTgfdy6PeWmnzDh9Ax0T6qyXTQtgO4GvVKD0qK8BqQJg03K5YGuueA4amrVMUPR48FJa3Umw0iVxaqTcphkkt1J2nbVUpKoGwDbNFG/GMTDkfYnoVL1KJ9kQzahyD5UHmndgylQ059lcrM/pduBidVr0g/OC9ADu+RbNiJYOVQ+NBXR8ZozKfcp78HJSMxNNqAuDwrWKtuLINYh6CtXzXnqbwlpVtfc4b1XVQXLfKXW95tLMZ452uRPCKF0wXqsB7fYe/yyg2WQ3ntaoJcUaQ3urvceq0alpbj3YxAU0y8ts87NvhWYayvuF29Cjpere2mroxjPB3RiIrbFnwOqnpbiyGGBNurmMFg2A42lg7Bl4cWmXPM+R9nk81+rPP78M7Yjzr1+E8P8B0szv+tLrxRwAAAAASUVORK5CYII=";
  return jsx("svg", { ...props, width: "120", height: "120", viewBox: "0 0 120 120", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
    backgroundSize: "100% 100%",
    backgroundImage: `url("${img}")`
  } });
};
const Trust = ({ theme = "light", ...props }) => jsxs("svg", { ...props, width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "44", height: "44", fill: theme === "light" ? "var(--ck-brand-trust-02)" : "var(--ck-brand-trust-02b)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M33.0246 11.8662C33.4096 11.8662 33.774 12.0243 34.0421 12.2925C34.3102 12.5675 34.4615 12.9387 34.4546 13.3168C34.3859 17.4143 34.2277 20.5493 33.9321 23.0312C33.6433 25.5131 33.2102 27.3556 32.5571 28.8475C32.1171 29.8443 31.574 30.6693 30.9346 31.3706C30.0752 32.2987 29.0921 32.9725 28.0196 33.6119C27.561 33.8861 27.0843 34.1568 26.5842 34.4408C25.5172 35.0468 24.3441 35.713 23.0146 36.6025C22.5333 36.9256 21.9077 36.9256 21.4265 36.6025C20.0766 35.7026 18.8879 35.0281 17.8112 34.4173C17.5718 34.2815 17.3379 34.1488 17.109 34.0175C15.8509 33.2887 14.7165 32.5943 13.7265 31.5906C13.0665 30.9306 12.4959 30.1262 12.0421 29.1706C11.4234 27.8918 11.004 26.345 10.6946 24.3443C10.2821 21.67 10.0759 18.1706 10.0002 13.3168C9.99336 12.9387 10.1377 12.5675 10.4059 12.2925C10.674 12.0243 11.0452 11.8662 11.4302 11.8662H12.0215C13.8433 11.8731 17.8652 11.6943 21.344 8.98559C21.8596 8.58683 22.5815 8.58683 23.0971 8.98559C26.5759 11.6943 30.5977 11.8731 32.4265 11.8662H33.0246ZM29.8277 27.9331C30.2746 27.0118 30.6459 25.74 30.9277 23.9112C31.2646 21.725 31.4709 18.755 31.5671 14.7125C29.4221 14.6506 25.7371 14.2381 22.224 11.8731C18.7109 14.2312 15.0259 14.6437 12.8877 14.7125C12.9633 18.0537 13.1146 20.6525 13.3552 22.6943C13.6302 25.0181 14.0221 26.5925 14.5102 27.6993C14.8333 28.435 15.1909 28.9643 15.6171 29.4318C16.1877 30.0575 16.9096 30.5731 17.8927 31.1643C18.3005 31.409 18.7502 31.6635 19.2396 31.9406C20.1116 32.4341 21.1099 32.9991 22.224 33.7081C23.3175 33.0107 24.3014 32.4515 25.1633 31.9616C25.4231 31.8139 25.6717 31.6725 25.909 31.5356C27.119 30.8412 28.0127 30.2637 28.6796 29.59C29.1265 29.1293 29.4909 28.6275 29.8277 27.9331Z", fill: theme === "light" ? "var(--ck-brand-trust-01)" : "var(--ck-brand-trust-01b)" })] });
const Argent = ({ ...props }) => jsxs("svg", { ...props, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "32", height: "32", fill: "white" }), jsx("path", { d: "M18.3242 7.63647H13.6516C13.4955 7.63647 13.3704 7.76611 13.367 7.92726C13.2726 12.4568 10.9768 16.7559 7.02532 19.8009C6.89986 19.8976 6.87128 20.0792 6.963 20.21L9.69685 24.112C9.78986 24.2448 9.97107 24.2747 10.0986 24.1772C12.5694 22.2856 14.5567 20.0038 15.9879 17.4746C17.4191 20.0038 19.4065 22.2856 21.8773 24.1772C22.0047 24.2747 22.186 24.2448 22.2791 24.112L25.013 20.21C25.1045 20.0792 25.0759 19.8976 24.9506 19.8009C20.999 16.7559 18.7033 12.4568 18.609 7.92726C18.6056 7.76611 18.4803 7.63647 18.3242 7.63647Z", fill: "var(--ck-brand-argent)" })] });
const ImToken = ({ ...props }) => jsx("svg", { ...props, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: `linear-gradient(
      180deg,
      var(--ck-brand-imtoken-01) 0%,
      var(--ck-brand-imtoken-02) 100%
    )`
}, children: jsx("path", { d: "M26.8543 9.96509C27.5498 19.3857 21.4942 23.8384 16.0655 24.3132C11.0184 24.7546 6.26765 21.6534 5.85087 16.8885C5.50707 12.952 7.94004 11.2761 9.8516 11.109C11.8177 10.9367 13.4698 12.2925 13.6132 13.9342C13.7512 15.5125 12.7664 16.2308 12.0815 16.2906C11.5398 16.3381 10.8584 16.0093 10.7968 15.3032C10.7441 14.6965 10.9744 14.6138 10.9182 13.9693C10.8179 12.8219 9.81731 12.6882 9.26951 12.7357C8.60654 12.7937 7.40368 13.5675 7.5725 15.4949C7.7422 17.439 9.60628 18.9751 12.0498 18.7614C14.6868 18.531 16.5227 16.4779 16.6608 13.5983C16.6595 13.4458 16.6916 13.2948 16.7548 13.156L16.7557 13.1525C16.7841 13.0922 16.8174 13.0342 16.8551 12.9793C16.9113 12.8949 16.9835 12.8016 17.0767 12.6997C17.0775 12.697 17.0775 12.697 17.0793 12.697C17.147 12.6205 17.2288 12.5379 17.3211 12.4491C18.473 11.3623 22.6214 8.79916 26.5448 9.61074C26.6277 9.62851 26.7026 9.67262 26.7584 9.73649C26.8142 9.80035 26.8478 9.88054 26.8543 9.96509", fill: "white" }) });
const Frame = ({ ...props }) => jsxs("svg", { width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "32", height: "32", fill: "white" }), jsx("path", { d: "M24.9055 15.8824V8.30065C24.9055 7.63399 24.3583 7.08497 23.6938 7.08497H16.1238C16.0456 7.08497 15.9805 7.05882 15.9153 7.00654L15.0033 6.0915C14.9511 6.03922 14.873 6 14.7948 6H7.21173C6.54723 6 6 6.53595 6 7.21569V14.7974C6 14.8758 6.02606 14.9412 6.07818 15.0065L6.99023 15.9216C7.04235 15.9739 7.08143 16.0523 7.08143 16.1307V23.7124C7.08143 24.3791 7.62866 24.9281 8.29316 24.9281H15.8762C15.9544 24.9281 16.0195 24.9542 16.0847 25.0065L16.9967 25.9216C17.0489 25.9739 17.127 26 17.2052 26H24.7883C25.4528 26 26 25.4641 26 24.7843V17.2026C26 17.1242 25.9739 17.0588 25.9218 16.9935L25.0098 16.0784C24.9446 16.0261 24.9055 15.9608 24.9055 15.8824ZM19.759 19.9346H12.241C12.1498 19.9346 12.0717 19.8562 12.0717 19.7647V12.2353C12.0717 12.1438 12.1498 12.0654 12.241 12.0654H19.759C19.8502 12.0654 19.9283 12.1438 19.9283 12.2353V19.7647C19.9414 19.8562 19.8632 19.9346 19.759 19.9346Z", fill: "#00D2BE" })] });
const Rainbow = ({ round = false, ...props }) => {
  const withBackground = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgdmlld0JveD0iMCAwIDEyMCAxMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfNjJfMzI5KSIvPgo8cGF0aCBkPSJNMjAgMzhIMjZDNTYuOTI3OSAzOCA4MiA2My4wNzIxIDgyIDk0VjEwMEg5NEM5Ny4zMTM3IDEwMCAxMDAgOTcuMzEzNyAxMDAgOTRDMTAwIDUzLjEzMDkgNjYuODY5MSAyMCAyNiAyMEMyMi42ODYzIDIwIDIwIDIyLjY4NjMgMjAgMjZWMzhaIiBmaWxsPSJ1cmwoI3BhaW50MV9yYWRpYWxfNjJfMzI5KSIvPgo8cGF0aCBkPSJNODQgOTRIMTAwQzEwMCA5Ny4zMTM3IDk3LjMxMzcgMTAwIDk0IDEwMEg4NFY5NFoiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl82Ml8zMjkpIi8+CjxwYXRoIGQ9Ik0yNiAyMEwyNiAzNkgyMEwyMCAyNkMyMCAyMi42ODYzIDIyLjY4NjMgMjAgMjYgMjBaIiBmaWxsPSJ1cmwoI3BhaW50M19saW5lYXJfNjJfMzI5KSIvPgo8cGF0aCBkPSJNMjAgMzZIMjZDNTguMDMyNSAzNiA4NCA2MS45Njc1IDg0IDk0VjEwMEg2NlY5NEM2NiA3MS45MDg2IDQ4LjA5MTQgNTQgMjYgNTRIMjBWMzZaIiBmaWxsPSJ1cmwoI3BhaW50NF9yYWRpYWxfNjJfMzI5KSIvPgo8cGF0aCBkPSJNNjggOTRIODRWMTAwSDY4Vjk0WiIgZmlsbD0idXJsKCNwYWludDVfbGluZWFyXzYyXzMyOSkiLz4KPHBhdGggZD0iTTIwIDUyTDIwIDM2TDI2IDM2TDI2IDUySDIwWiIgZmlsbD0idXJsKCNwYWludDZfbGluZWFyXzYyXzMyOSkiLz4KPHBhdGggZD0iTTIwIDYyQzIwIDY1LjMxMzcgMjIuNjg2MyA2OCAyNiA2OEM0MC4zNTk0IDY4IDUyIDc5LjY0MDYgNTIgOTRDNTIgOTcuMzEzNyA1NC42ODYzIDEwMCA1OCAxMDBINjhWOTRDNjggNzAuODA0IDQ5LjE5NiA1MiAyNiA1MkgyMFY2MloiIGZpbGw9InVybCgjcGFpbnQ3X3JhZGlhbF82Ml8zMjkpIi8+CjxwYXRoIGQ9Ik01MiA5NEg2OFYxMDBINThDNTQuNjg2MyAxMDAgNTIgOTcuMzEzNyA1MiA5NFoiIGZpbGw9InVybCgjcGFpbnQ4X3JhZGlhbF82Ml8zMjkpIi8+CjxwYXRoIGQ9Ik0yNiA2OEMyMi42ODYzIDY4IDIwIDY1LjMxMzcgMjAgNjJMMjAgNTJMMjYgNTJMMjYgNjhaIiBmaWxsPSJ1cmwoI3BhaW50OV9yYWRpYWxfNjJfMzI5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzYyXzMyOSIgeDE9IjYwIiB5MT0iMCIgeDI9IjYwIiB5Mj0iMTIwIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiMxNzQyOTkiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDAxRTU5Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQxX3JhZGlhbF82Ml8zMjkiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYgOTQpIHJvdGF0ZSgtOTApIHNjYWxlKDc0KSI+CjxzdG9wIG9mZnNldD0iMC43NzAyNzciIHN0b3AtY29sb3I9IiNGRjQwMDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjODc1NEM5Ii8+CjwvcmFkaWFsR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl82Ml8zMjkiIHgxPSI4MyIgeTE9Ijk3IiB4Mj0iMTAwIiB5Mj0iOTciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0ZGNDAwMCIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM4NzU0QzkiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDNfbGluZWFyXzYyXzMyOSIgeDE9IjIzIiB5MT0iMjAiIHgyPSIyMyIgeTI9IjM3IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiM4NzU0QzkiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY0MDAwIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQ0X3JhZGlhbF82Ml8zMjkiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYgOTQpIHJvdGF0ZSgtOTApIHNjYWxlKDU4KSI+CjxzdG9wIG9mZnNldD0iMC43MjM5MjkiIHN0b3AtY29sb3I9IiNGRkY3MDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5OTAxIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ1X2xpbmVhcl82Ml8zMjkiIHgxPSI2OCIgeTE9Ijk3IiB4Mj0iODQiIHkyPSI5NyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjRkZGNzAwIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTkwMSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50Nl9saW5lYXJfNjJfMzI5IiB4MT0iMjMiIHkxPSI1MiIgeDI9IjIzIiB5Mj0iMzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0ZGRjcwMCIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk5MDEiLz4KPC9saW5lYXJHcmFkaWVudD4KPHJhZGlhbEdyYWRpZW50IGlkPSJwYWludDdfcmFkaWFsXzYyXzMyOSIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgyNiA5NCkgcm90YXRlKC05MCkgc2NhbGUoNDIpIj4KPHN0b3Agb2Zmc2V0PSIwLjU5NTEzIiBzdG9wLWNvbG9yPSIjMDBBQUZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAxREE0MCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50OF9yYWRpYWxfNjJfMzI5IiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDUxIDk3KSBzY2FsZSgxNyA0NS4zMzMzKSI+CjxzdG9wIHN0b3AtY29sb3I9IiMwMEFBRkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDFEQTQwIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQ5X3JhZGlhbF82Ml8zMjkiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjMgNjkpIHJvdGF0ZSgtOTApIHNjYWxlKDE3IDMyMi4zNykiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMDBBQUZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAxREE0MCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=";
  const roundWithBackground = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgdmlld0JveD0iMCAwIDEyMCAxMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF84XzU1NCkiPgo8bWFzayBpZD0ibWFzazBfOF81NTQiIHN0eWxlPSJtYXNrLXR5cGU6YWxwaGEiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjAiIHk9IjAiIHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIj4KPGNpcmNsZSBjeD0iNjAiIGN5PSI2MCIgcj0iNjAiIGZpbGw9IiNEOUQ5RDkiLz4KPC9tYXNrPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzhfNTU0KSI+CjxyZWN0IHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfOF81NTQpIi8+CjwvZz4KPHBhdGggZD0iTTI2LjY2NjcgNDEuNjY2N0gzMS42NjY3QzU3LjQ0IDQxLjY2NjcgNzguMzMzMyA2Mi41NiA3OC4zMzMzIDg4LjMzMzNWOTMuMzMzM0g4OC4zMzMzQzkxLjA5NDggOTMuMzMzMyA5My4zMzMzIDkxLjA5NDcgOTMuMzMzMyA4OC4zMzMzQzkzLjMzMzMgNTQuMjc1OCA2NS43MjQyIDI2LjY2NjcgMzEuNjY2NyAyNi42NjY3QzI4LjkwNTIgMjYuNjY2NyAyNi42NjY3IDI4LjkwNTIgMjYuNjY2NyAzMS42NjY3VjQxLjY2NjdaIiBmaWxsPSJ1cmwoI3BhaW50MV9yYWRpYWxfOF81NTQpIi8+CjxwYXRoIGQ9Ik04MCA4OC4zMzMzSDkzLjMzMzNDOTMuMzMzMyA5MS4wOTQ4IDkxLjA5NDcgOTMuMzMzMyA4OC4zMzMzIDkzLjMzMzNIODBWODguMzMzM1oiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl84XzU1NCkiLz4KPHBhdGggZD0iTTMxLjY2NjcgMjYuNjY2N0wzMS42NjY3IDQwSDI2LjY2NjdMMjYuNjY2NyAzMS42NjY3QzI2LjY2NjcgMjguOTA1MiAyOC45MDUyIDI2LjY2NjcgMzEuNjY2NyAyNi42NjY3WiIgZmlsbD0idXJsKCNwYWludDNfbGluZWFyXzhfNTU0KSIvPgo8cGF0aCBkPSJNMjYuNjY2NiA0MEgzMS42NjY2QzU4LjM2MDQgNDAgODAgNjEuNjM5NiA4MCA4OC4zMzMzVjkzLjMzMzNINjVWODguMzMzM0M2NSA2OS45MjM4IDUwLjA3NjEgNTUgMzEuNjY2NiA1NUgyNi42NjY2VjQwWiIgZmlsbD0idXJsKCNwYWludDRfcmFkaWFsXzhfNTU0KSIvPgo8cGF0aCBkPSJNNjYuNjY2NiA4OC4zMzMzSDgwVjkzLjMzMzNINjYuNjY2NlY4OC4zMzMzWiIgZmlsbD0idXJsKCNwYWludDVfbGluZWFyXzhfNTU0KSIvPgo8cGF0aCBkPSJNMjYuNjY2NiA1My4zMzMzTDI2LjY2NjYgNDBMMzEuNjY2NiA0MEwzMS42NjY2IDUzLjMzMzNIMjYuNjY2NloiIGZpbGw9InVybCgjcGFpbnQ2X2xpbmVhcl84XzU1NCkiLz4KPHBhdGggZD0iTTI2LjY2NjYgNjEuNjY2N0MyNi42NjY2IDY0LjQyODEgMjguOTA1MiA2Ni42NjY3IDMxLjY2NjYgNjYuNjY2N0M0My42MzI4IDY2LjY2NjcgNTMuMzMzMyA3Ni4zNjcyIDUzLjMzMzMgODguMzMzM0M1My4zMzMzIDkxLjA5NDcgNTUuNTcxOSA5My4zMzMzIDU4LjMzMzMgOTMuMzMzM0g2Ni42NjY2Vjg4LjMzMzNDNjYuNjY2NiA2OS4wMDM0IDUwLjk5NjYgNTMuMzMzMyAzMS42NjY2IDUzLjMzMzNIMjYuNjY2NlY2MS42NjY3WiIgZmlsbD0idXJsKCNwYWludDdfcmFkaWFsXzhfNTU0KSIvPgo8cGF0aCBkPSJNNTMuMzMzMyA4OC4zMzMzSDY2LjY2NjZWOTMuMzMzM0g1OC4zMzMzQzU1LjU3MTkgOTMuMzMzMyA1My4zMzMzIDkxLjA5NDggNTMuMzMzMyA4OC4zMzMzWiIgZmlsbD0idXJsKCNwYWludDhfcmFkaWFsXzhfNTU0KSIvPgo8cGF0aCBkPSJNMzEuNjY2NiA2Ni42NjY3QzI4LjkwNTIgNjYuNjY2NyAyNi42NjY2IDY0LjQyODEgMjYuNjY2NiA2MS42NjY3TDI2LjY2NjYgNTMuMzMzM0wzMS42NjY2IDUzLjMzMzNMMzEuNjY2NiA2Ni42NjY3WiIgZmlsbD0idXJsKCNwYWludDlfcmFkaWFsXzhfNTU0KSIvPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfOF81NTQiIHgxPSI2MCIgeTE9IjAiIHgyPSI2MCIgeTI9IjEyMCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMTc0Mjk5Ii8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAwMUU1OSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50MV9yYWRpYWxfOF81NTQiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzEuNjY2NyA4OC4zMzMzKSByb3RhdGUoLTkwKSBzY2FsZSg2MS42NjY3KSI+CjxzdG9wIG9mZnNldD0iMC43NzAyNzciIHN0b3AtY29sb3I9IiNGRjQwMDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjODc1NEM5Ii8+CjwvcmFkaWFsR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl84XzU1NCIgeDE9Ijc5LjE2NjYiIHkxPSI5MC44MzMzIiB4Mj0iOTMuMzMzMyIgeTI9IjkwLjgzMzMiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0ZGNDAwMCIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM4NzU0QzkiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDNfbGluZWFyXzhfNTU0IiB4MT0iMjkuMTY2NyIgeTE9IjI2LjY2NjciIHgyPSIyOS4xNjY3IiB5Mj0iNDAuODMzMyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjODc1NEM5Ii8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGNDAwMCIvPgo8L2xpbmVhckdyYWRpZW50Pgo8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50NF9yYWRpYWxfOF81NTQiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzEuNjY2NiA4OC4zMzMzKSByb3RhdGUoLTkwKSBzY2FsZSg0OC4zMzMzKSI+CjxzdG9wIG9mZnNldD0iMC43MjM5MjkiIHN0b3AtY29sb3I9IiNGRkY3MDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5OTAxIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ1X2xpbmVhcl84XzU1NCIgeDE9IjY2LjY2NjYiIHkxPSI5MC44MzMzIiB4Mj0iODAiIHkyPSI5MC44MzMzIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNGRkY3MDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5OTAxIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ2X2xpbmVhcl84XzU1NCIgeDE9IjI5LjE2NjYiIHkxPSI1My4zMzMzIiB4Mj0iMjkuMTY2NiIgeTI9IjQwIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNGRkY3MDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5OTAxIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQ3X3JhZGlhbF84XzU1NCIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgzMS42NjY2IDg4LjMzMzMpIHJvdGF0ZSgtOTApIHNjYWxlKDM1KSI+CjxzdG9wIG9mZnNldD0iMC41OTUxMyIgc3RvcC1jb2xvcj0iIzAwQUFGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMURBNDAiLz4KPC9yYWRpYWxHcmFkaWVudD4KPHJhZGlhbEdyYWRpZW50IGlkPSJwYWludDhfcmFkaWFsXzhfNTU0IiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDUyLjUgOTAuODMzMykgc2NhbGUoMTQuMTY2NyAzNy43Nzc4KSI+CjxzdG9wIHN0b3AtY29sb3I9IiMwMEFBRkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDFEQTQwIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQ5X3JhZGlhbF84XzU1NCIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgyOS4xNjY2IDY3LjUpIHJvdGF0ZSgtOTApIHNjYWxlKDE0LjE2NjcgMjY4LjY0MikiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMDBBQUZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAxREE0MCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzhfNTU0Ij4KPHJlY3Qgd2lkdGg9IjEyMCIgaGVpZ2h0PSIxMjAiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==";
  return jsx("svg", { ...props, width: "120", height: "120", viewBox: "0 0 120 120", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
    backgroundSize: "100% 100%",
    backgroundImage: `url("${round ? roundWithBackground : withBackground}")`
  } });
};
const Brave$1 = ({ ...props }) => jsxs("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { rx: "27%", width: "88", height: "88", fill: "white" }), jsx("path", { d: "M69.0892 28.2123L70.5781 24.5643L66.3594 20.1967C64.0763 17.9136 59.2123 19.2537 59.2123 19.2537L53.7031 13H34.2721L28.7381 19.2785C28.7381 19.2785 23.8741 17.9632 21.591 20.1967L17.3722 24.5395L18.8612 28.1875L17 33.5974L23.204 57.2472C24.4945 62.3097 25.3631 64.2702 29.011 66.8511L40.352 74.5441C41.4439 75.2142 42.784 76.3805 44 76.3805C45.216 76.3805 46.5561 75.2142 47.648 74.5441L58.989 66.8511C62.6369 64.2702 63.5055 62.3097 64.796 57.2472L71 33.5974L69.0892 28.2123Z", fill: "url(#paint0_linear_2183_5890)" }), jsx("path", { d: "M57.6737 23.2739C57.6737 23.2739 64.796 31.8851 64.796 33.6967C64.796 35.5579 63.9026 36.0294 63.0092 36.9972L57.6737 42.705C57.1774 43.2013 56.1103 44.045 56.7307 45.5092C57.3511 46.9982 58.2197 48.8346 57.227 50.7206C56.2344 52.6314 54.4972 53.8971 53.3805 53.6985C51.7195 53.1594 50.1348 52.4088 48.6654 51.4651C47.7224 50.8447 44.6949 48.3382 44.6949 47.3704C44.6949 46.4026 47.8217 44.6406 48.4173 44.2932C48.9881 43.8961 51.6434 42.3575 51.693 41.7619C51.7427 41.1664 51.7427 41.0175 50.9485 39.5285C50.1544 38.0395 48.7647 36.0542 48.9632 34.7638C49.2114 33.4733 51.4449 32.7785 53.1075 32.1581L58.2445 30.2224C58.6415 30.0239 58.5423 29.8502 57.3511 29.7261C56.1599 29.6268 52.8097 29.1801 51.296 29.602C49.7822 30.0239 47.2509 30.6691 47.0028 31.0165C46.8042 31.364 46.6057 31.364 46.829 32.5551L48.2684 40.3722C48.3677 41.3649 48.5662 42.0349 47.5239 42.2831C46.432 42.5313 44.6204 42.9531 44 42.9531C43.3796 42.9531 41.5432 42.5313 40.4761 42.2831C39.409 42.0349 39.6075 41.3649 39.7316 40.3722C39.8309 39.3796 40.9228 33.7215 41.1461 32.5551C41.3943 31.364 41.171 31.364 40.9724 31.0165C40.7243 30.6691 38.1682 30.0239 36.6544 29.602C35.1654 29.1801 31.7904 29.6268 30.5993 29.7509C29.4081 29.8502 29.3088 29.9991 29.7059 30.2472L34.8428 32.1581C36.4807 32.7785 38.7638 33.4733 38.9871 34.7638C39.2353 36.079 37.8208 38.0395 37.0018 39.5285C36.1829 41.0175 36.2077 41.1664 36.2574 41.7619C36.307 42.3575 38.9871 43.8961 39.5331 44.2932C40.1287 44.6654 43.2555 46.4026 43.2555 47.3704C43.2555 48.3382 40.3024 50.8447 39.3097 51.4651C37.8404 52.4088 36.2557 53.1594 34.5947 53.6985C33.4779 53.8971 31.7408 52.6314 30.7233 50.7206C29.7307 48.8346 30.6241 46.9982 31.2197 45.5092C31.8401 44.0202 30.7978 43.2261 30.2767 42.705L24.9412 36.9972C24.0726 36.079 23.1792 35.5827 23.1792 33.7463C23.1792 31.9099 30.3015 23.3235 30.3015 23.3235L37.0763 24.4154C37.8704 24.4154 39.6324 23.7454 41.2454 23.1746C42.8585 22.6783 43.9752 22.6287 43.9752 22.6287C43.9752 22.6287 45.0671 22.6287 46.705 23.1746C48.3428 23.7206 50.08 24.4154 50.8741 24.4154C51.693 24.4154 57.6985 23.2491 57.6985 23.2491L57.6737 23.2739ZM52.3382 56.2298C52.7849 56.4779 52.512 57.0239 52.0901 57.3217L45.7868 62.2353C45.2904 62.7316 44.4963 63.4761 43.9752 63.4761C43.454 63.4761 42.6847 62.7316 42.1636 62.2353C40.0743 60.5717 37.9648 58.9337 35.8355 57.3217C35.4384 57.0239 35.1654 56.5028 35.5873 56.2298L39.3097 54.2445C40.7894 53.4618 42.3551 52.8539 43.9752 52.4329C44.3474 52.4329 46.705 53.2767 48.6158 54.2445L52.3382 56.2298Z", fill: "white" }), jsx("path", { d: "M59.262 19.2785L53.7032 13H34.2721L28.7381 19.2785C28.7381 19.2785 23.8741 17.9632 21.591 20.1967C21.591 20.1967 28.0432 19.6259 30.2767 23.2491L37.126 24.4154C37.9201 24.4154 39.682 23.7454 41.2951 23.1746C42.9081 22.6783 44.0249 22.6287 44.0249 22.6287C44.0249 22.6287 45.1168 22.6287 46.7546 23.1746C48.3925 23.7206 50.1296 24.4154 50.9238 24.4154C51.7427 24.4154 57.7482 23.2491 57.7482 23.2491C59.9817 19.6259 66.4339 20.1967 66.4339 20.1967C64.1508 17.9136 59.2868 19.2537 59.2868 19.2537", fill: "url(#paint1_linear_2183_5890)" }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_2183_5890", x1: "17", y1: "45.3241", x2: "71", y2: "45.3241", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { offset: "0.4", stopColor: "#FF5500" }), jsx("stop", { offset: "0.6", stopColor: "#FF2000" })] }), jsxs("linearGradient", { id: "paint1_linear_2183_5890", x1: "22.4879", y1: "18.8219", x2: "66.4339", y2: "18.8219", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#FF452A" }), jsx("stop", { offset: "1", stopColor: "#FF2000" })] })] })] });
const Crypto = ({ ...props }) => jsxs("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "white" }, children: [jsx("mask", { id: "mask0_2091_4394", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "13", y: "9", width: "62", height: "71", children: jsx("path", { d: "M44 9L13 26.75V62.25L44 80L75 62.25V26.75L44 9ZM31.7577 24.3492H56.1513L59.0935 36.684H28.9307L31.7577 24.3492ZM41.5613 61.2993L36.2955 66.161H31.8427L20.6924 46.9369L28.8701 40.9079L36.0953 45.4627V53.6578L41.5552 58.8504V61.2993H41.5613ZM37.9759 53.1584L38.7888 45.4326L36.1256 38.5432H51.9229L49.3204 45.4326L50.0787 53.1283L44 53.1584H37.9759ZM56.2059 66.1069H51.8076L46.5419 61.2993V58.8564L52.0018 53.6638V45.4627L59.1421 40.8537L67.2955 46.9369L56.2059 66.1069Z", fill: "#002D74" }) }), jsxs("g", { mask: "url(#mask0_2091_4394)", children: [jsx("rect", { y: "8", width: "44", height: "72", fill: "url(#paint0_linear_2091_4394)" }), jsx("rect", { x: "88", y: "80", width: "44", height: "72", transform: "rotate(-180 88 80)", fill: "url(#paint1_linear_2091_4394)" })] }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_2091_4394", x1: "22", y1: "8", x2: "22", y2: "80", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#010935" }), jsx("stop", { offset: "1", stopColor: "#142C70" })] }), jsxs("linearGradient", { id: "paint1_linear_2091_4394", x1: "110", y1: "80", x2: "110", y2: "152", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#010935" }), jsx("stop", { offset: "1", stopColor: "#142C70" })] })] })] });
const Ledger = ({ ...props }) => jsx("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "black" }, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M37.2106 16H16V29.4577H19.2182V19.2182L37.2106 19.1011V16ZM37.3568 33.4073V54.6179H50.8146V51.3997H40.575L40.458 33.4073H37.3568ZM16 72.1714H37.2106V69.0703L19.2182 68.9533V58.7137H16V72.1714ZM50.9609 16H72.1714V29.4577H68.9533V19.2182L50.9609 19.1011V16ZM72.1714 72.1714H50.9609V69.0703L68.9533 68.9533V58.7137H72.1714V72.1714Z", fill: "white" }) });
const Steak = ({ ...props }) => jsxs("svg", { ...props, width: "600", height: "600", viewBox: "0 0 600 600", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "black" }, children: [jsx("path", { d: "M470.747 209.191C462.305 192.354 448.646 178.695 431.808 170.253C413.337 161 389.233 161 341.006 161C331.236 161 307.916 161 300 161C292.084 161 268.728 161 258.994 161C210.856 161 186.662 161 168.191 170.253C151.354 178.69 137.7 192.35 129.27 209.191C119.999 227.662 120 251.767 120 299.976C120 348.185 119.999 372.308 129.27 390.778C137.7 407.619 151.354 421.279 168.191 429.716C186.662 438.97 210.784 438.97 258.994 438.97C268.764 438.97 292.084 438.97 300 438.97C307.916 438.97 331.272 438.97 341.006 438.97C389.144 438.97 413.337 438.97 431.808 429.716C448.646 421.274 462.305 407.616 470.747 390.778C480 372.308 480 348.203 480 299.976C480 251.749 480 227.662 470.747 209.191Z", fill: "#FFCEAA" }), jsx("path", { d: "M218.557 350.342C216.323 345.957 212.922 342.274 208.729 339.698C204.536 337.121 199.713 335.752 194.791 335.741H166.747C163.876 335.755 161.041 336.37 158.422 337.548C155.804 338.725 153.462 340.439 151.547 342.577C149.632 344.716 148.186 347.232 147.303 349.964C146.42 352.696 146.12 355.582 146.422 358.437C147.385 367.476 148.954 374.34 151.575 379.564C157.629 391.573 167.378 401.323 179.388 407.377C188.195 411.798 201.674 413.26 222.444 413.742C225.415 413.812 228.353 413.109 230.97 411.702C233.587 410.295 235.793 408.232 237.373 405.715C238.953 403.199 239.852 400.315 239.982 397.346C240.113 394.378 239.47 391.427 238.116 388.781L218.557 350.342Z", fill: "#FF3B9A" }), jsx("path", { d: "M180.618 312.563C189.852 312.562 198.95 310.335 207.14 306.071C215.33 301.806 222.371 295.63 227.668 288.066L254.856 249.253C259.761 242.25 262.839 234.134 263.81 225.64C264.782 217.146 263.616 208.545 260.419 200.616V200.384C258.913 196.555 256.409 193.2 253.167 190.666C249.925 188.133 246.064 186.514 241.985 185.978C209.732 186.085 190.726 186.887 179.405 192.575C167.37 198.586 157.611 208.339 151.592 220.37C146.725 230.247 145.227 258.007 144.87 280.507C144.797 284.698 145.56 288.862 147.114 292.754C148.668 296.647 150.983 300.191 153.923 303.179C156.863 306.167 160.369 308.539 164.236 310.156C168.103 311.774 172.254 312.604 176.445 312.599L180.618 312.563Z", fill: "#FF3B9A" }), jsx("path", { d: "M449.702 220.356C443.655 208.365 433.909 198.639 421.906 192.614C409.89 186.588 389.262 186.053 353.337 186C304.664 186 289.528 242 279.134 256.834L248.556 300.497C243.645 307.51 240.729 315.725 240.12 324.266C239.511 332.806 241.231 341.352 245.098 348.991L267.758 393.813C270.842 399.931 275.578 405.063 281.43 408.627C287.282 412.191 294.016 414.045 300.867 413.978H301.49C309.495 413.978 334.171 413.978 342.283 413.978C385.072 413.978 408.713 413.977 421.906 407.381C433.914 401.331 443.66 391.58 449.702 379.568C456.317 366.374 456.316 342.787 456.316 299.944C456.316 257.101 456.317 233.621 449.702 220.356Z", fill: "#FF3B9A" })] });
const Unstoppable = ({ ...props }) => jsx("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "linear-gradient(180deg, #FED812 0%, #FFAF00 100%)" }, children: jsx("path", { d: "M47.4 43.7163C47.4 45.6251 45.8781 47.1714 44.0001 47.1714C42.1219 47.1714 40.6 45.6251 40.6 43.7163L40.6 -7H27L27 43.7163C27 53.2612 34.6106 61 44.0001 61C53.3882 61 61 53.2612 61 43.7163V-7H47.4V43.7163Z", fill: "#1F2129" }) });
const ONTO = ({ ...props }) => jsx("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "white" }, children: jsx("path", { d: "M20 16L28.675 24.677C32.1885 21.8644 36.4154 20.0873 40.8816 19.545C45.348 19.0026 49.8769 19.7164 53.9604 21.6063C58.0438 23.4963 61.5207 26.4876 64.0005 30.2447C66.4804 34.0019 67.8653 38.3763 68 42.8772V43.5854V72L59.3367 63.3231C55.8263 66.1389 51.6014 67.9196 47.1361 68.4655C42.6708 69.0112 38.1419 68.3007 34.0577 66.4135C29.9734 64.5262 26.4956 61.537 24.0144 57.7813C21.5333 54.0255 20.1472 49.6521 20.0115 45.1515V44.4433L20 16ZM25.931 30.3311V44.4146C25.9323 47.7294 26.8335 50.9817 28.5384 53.8236C30.2432 56.6655 32.6875 58.9902 35.6101 60.5497C38.5328 62.1089 41.8238 62.8439 45.1313 62.6764C48.439 62.5087 51.639 61.4445 54.3894 59.5978L54.8611 59.2754L27.0873 31.4884L25.931 30.3311ZM33.6223 28.4022L33.1505 28.7304L60.9186 56.5117L62.069 57.6632V43.5854C62.0683 40.2717 61.1679 37.0204 59.464 34.179C57.7603 31.3377 55.3171 29.0132 52.3957 27.4539C49.4742 25.8946 46.1844 25.1592 42.8777 25.3262C39.5712 25.4933 36.372 26.5565 33.6223 28.4022Z", fill: "#23262F" }) });
const Slope = ({ ...props }) => jsxs("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "#6C67F1" }, children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M50.6667 24.3696L34.8872 40.1864L24.0001 37.7402L37.3334 24.3696L48.4438 13.3798C49.268 12.5646 50.6667 13.1484 50.6667 14.3077V24.3696ZM37.3339 51.0358L50.6672 37.74V24.3694L35.2001 39.8737L37.3339 51.0358Z", fill: "url(#paint0_linear_2593_6077)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M37.3337 64.2947V50.9617L50.667 37.6284L55.7849 45.8435L55.9822 45.6463L64 50.9616L39.5582 75.2343C38.7347 76.0521 37.3336 75.4687 37.3336 74.3082V64.2949L37.3337 64.2947Z", fill: "url(#paint1_linear_2593_6077)" }), jsx("path", { d: "M24 37.7405H32.573C35.202 37.7405 37.3333 39.8718 37.3333 42.5009V51.0359H28.7602C26.1313 51.0359 24 48.9046 24 46.2757V37.7405Z", fill: "#F1F0FF" }), jsx("path", { d: "M50.6667 37.7405H59.2398C61.8688 37.7405 64 39.8718 64 42.5009V51.0359H55.4271C52.798 51.0359 50.6667 48.9046 50.6667 46.2757V37.7405Z", fill: "#F1F0FF" }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_2593_6077", x1: "37.3336", y1: "13", x2: "37.3336", y2: "51.0358", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#A8ADFF" }), jsx("stop", { offset: "0.648556", stopColor: "white" })] }), jsxs("linearGradient", { id: "paint1_linear_2593_6077", x1: "50.6668", y1: "37.6284", x2: "50.6668", y2: "75.616", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { offset: "0.260784", stopColor: "#B6BAFF" }), jsx("stop", { offset: "1", stopColor: "#E4E2FF" })] })] })] });
const Safe = ({ ...props }) => jsxs("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "var(--ck-brand-safe)" }, children: [jsx("path", { d: "M68.7186 44H62.6472C60.8339 44 59.3646 45.4686 59.3646 47.281V56.0888C59.3646 57.9012 57.8952 59.3697 56.0819 59.3697H31.9278C30.1145 59.3697 28.6452 60.8383 28.6452 62.6507V68.719C28.6452 70.5314 30.1145 72 31.9278 72H57.48C59.2933 72 60.7417 70.5314 60.7417 68.719V63.8504C60.7417 62.038 62.2111 60.7524 64.0244 60.7524H68.7174C70.5307 60.7524 72 59.2838 72 57.4714V47.2429C72 45.4305 70.5307 44 68.7174 44H68.7186Z", fill: "#121312" }), jsx("path", { d: "M28.6406 31.9308C28.6406 30.1162 30.1104 28.6458 31.9243 28.6458H56.0712C57.8851 28.6458 59.3548 27.1754 59.3548 25.3608V19.285C59.3548 17.4704 57.8851 16 56.0712 16H30.5245C28.7107 16 27.2409 17.4704 27.2409 19.285V23.9666C27.2409 25.7813 25.7711 27.2516 23.9572 27.2516H19.2837C17.4698 27.2516 16 28.722 16 30.5366V40.7888C16 42.6034 17.4759 44 19.2898 44H25.3631C27.177 44 28.6468 42.5296 28.6468 40.715L28.6406 31.932V31.9308Z", fill: "#121312" }), jsx("path", { d: "M41.1004 37.6774H46.8995C48.7894 37.6774 50.3226 39.2117 50.3226 41.1004V46.8995C50.3226 48.7894 48.7882 50.3225 46.8995 50.3225H41.1004C39.2106 50.3225 37.6774 48.7882 37.6774 46.8995V41.1004C37.6774 39.2105 39.2118 37.6774 41.1004 37.6774V37.6774Z", fill: "#121312" })] });
const Frontier = ({ ...props }) => jsx("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "#CC703C" }, children: jsx("path", { d: "M63.6429 20L63.3645 20.7254L62.4521 23.0445L61.8461 24.5395C57.2427 35.7491 53.6629 41.0688 49.8557 41.0688C48.8938 41.0936 47.9371 40.9212 47.0465 40.5625C46.156 40.2038 45.3512 39.6667 44.6834 38.9852L44.1979 38.5518C42.9885 37.4538 42.4799 37.1831 41.3154 37.1832C40.7094 37.1832 39.6238 37.9435 38.2521 39.7303C36.4147 42.2912 34.8522 45.0327 33.59 47.9106L33.4353 48.2482L49.7645 48.2483L47.7312 52.4075H32.4845L32.4843 69.44L28 69.44L28.0001 20L63.6429 20ZM57.2889 24.1518L32.4843 24.1518L32.4843 40.6262C35.4564 35.5545 38.2816 33.0086 41.32 33.0086C42.3421 32.9765 43.3595 33.1534 44.3082 33.5284C45.2569 33.9034 46.1159 34.468 46.8311 35.1865L47.3323 35.6335C48.4611 36.6585 48.8956 36.8941 49.8604 36.8941C50.9211 36.8957 53.7433 32.4855 57.2889 24.1518Z", fill: "white" }) });
const Zerion = ({ ...props }) => jsxs("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: "linear-gradient(120.22deg, #2962EF 0%, #255CE5 100%)"
}, children: [jsx("path", { d: "M19.0864 22C17.5783 22 16.9973 23.8648 18.2628 24.6438L49.9199 43.732C50.709 44.2178 51.7614 44.0258 52.3048 43.2969L66.2236 25.024C67.17 23.7545 66.2138 22 64.5757 22H19.0864Z", fill: "white" }), jsx("path", { d: "M68.8425 66C70.3503 66 70.9466 64.1252 69.6814 63.3464L38.015 44.2605C37.2259 43.7748 36.1989 43.991 35.6558 44.7198L21.7099 62.9891C20.7639 64.2582 21.7499 66 23.3877 66H68.8425Z", fill: "white" })] });
const Phantom = ({ background = false, ...props }) => jsx("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: background ? { background: "#AB9FF2" } : void 0, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M37.7425 57.0705C34.1942 62.3362 28.2483 69 20.3366 69C16.5965 69 13.0001 67.5093 13 61.0322C12.9997 44.5362 36.2555 19.0003 57.8334 19C70.1084 18.9998 75 27.2474 75 36.6136C75 48.6357 66.9442 62.3824 58.9368 62.3824C56.3955 62.3824 55.1487 61.031 55.1487 58.888C55.1487 58.3288 55.2442 57.7228 55.4365 57.0705C52.7029 61.5902 47.4285 65.7849 42.4896 65.7849C38.8933 65.7849 37.0713 63.5944 37.0713 60.5187C37.0713 59.4003 37.311 58.2357 37.7425 57.0705ZM53.7586 31.6834C51.8054 31.6868 50.4738 33.2938 50.478 35.5864C50.4822 37.879 51.8198 39.5273 53.7729 39.5241C55.6789 39.5208 57.0099 37.8679 57.0058 35.5752C57.0016 33.2827 55.6646 31.6802 53.7586 31.6834ZM64.1193 31.6725C62.1661 31.6759 60.8345 33.2829 60.8387 35.5755C60.8429 37.868 62.1798 39.5164 64.1336 39.5131C66.0396 39.5099 67.3706 37.8569 67.3664 35.5643C67.3622 33.2718 66.0253 31.6693 64.1193 31.6725Z", fill: background ? "#ffffff" : "currentColor" }) });
const PlaceHolder = () => {
  return jsx("div", { style: { width: 80, height: 80, background: "#555" } });
};
const Dawn = ({ ...props }) => jsxs("svg", { ...props, width: "88px", height: "88px", viewBox: "0 0 192 192", version: "1.1", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", children: [jsxs("defs", { children: [jsxs("linearGradient", { x1: "50%", y1: "0%", x2: "50%", y2: "100%", id: "linearGradient-1", children: [jsx("stop", { stopColor: "#151515", offset: "0%" }), jsx("stop", { stopColor: "#232323", offset: "100%" })] }), jsx("rect", { rx: "27%", id: "path-2", x: "0", y: "0", width: "192", height: "192" }), jsxs("linearGradient", { x1: "50%", y1: "0%", x2: "50%", y2: "99.7051532%", id: "linearGradient-3", children: [jsx("stop", { stopColor: "#F3DC83", offset: "0%" }), jsx("stop", { stopColor: "#F9EEC8", offset: "100%" })] })] }), jsx("g", { id: "Icons---Pixel-Fitted", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: jsxs("g", { id: "Group", children: [jsxs("g", { id: "Rectangle", children: [jsx("use", { fill: "#232323", xlinkHref: "#path-2" }), jsx("use", { fill: "url(#linearGradient-1)", xlinkHref: "#path-2" })] }), jsx("path", { d: "M123.748399,157.001808 C115.293464,160.853955 105.89735,163 96,163 C86.1026503,163 76.7065363,160.853955 68.2516012,157.001808 Z M146.526595,140.002206 C144.677242,142.123986 142.696426,144.128189 140.59684,146.002121 L51.4031598,146.002121 C49.3035743,144.128189 47.3227581,142.123986 45.4734054,140.002206 Z M157.337411,122.999613 C155.955969,126.133404 154.34141,129.141319 152.515704,132.001388 L39.484296,132.001388 C37.6585895,129.141319 36.0440306,126.133404 34.662589,122.999613 Z M96,29 C133.003078,29 163,58.9969218 163,96 C163,103.706309 161.69895,111.108742 159.304524,117.999626 L32.6954763,117.999626 C30.3010496,111.108742 29,103.706309 29,96 C29,58.9969218 58.9969218,29 96,29 Z", id: "Combined-Shape", fill: "url(#linearGradient-3)" })] }) })] });
const InfinityWallet = ({ ...props }) => jsxs("svg", { ...props, version: "1.1", id: "e551690a-81c0-4880-9b93-334a37ce6796", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", x: "0px", y: "0px", viewBox: "0 0 1025 1025", children: [jsx("style", { type: "text/css", children: `
        .infinityWallet-st0{fill:url(#ID_InfinityWallet_1);}
        .infinityWallet-st1{fill:url(#ID_InfinityWallet_2);}
        .infinityWallet-st2{opacity:0.49;fill:url(#ID_InfinityWallet_3);enable-background:new;}
        .infinityWallet-st3{opacity:0.49;fill:url(#ID_InfinityWallet_4);enable-background:new;}
        .infinityWallet-st4{opacity:0.49;fill:url(#ID_InfinityWallet_5);enable-background:new;}
        .infinityWallet-st5{fill:url(#ID_InfinityWallet_6);}
        .infinityWallet-st6{opacity:0.49;fill:url(#ID_InfinityWallet_7);enable-background:new;}
        .infinityWallet-st7{opacity:0.49;fill:url(#ID_InfinityWallet_8);enable-background:new;}
        .infinityWallet-st8{opacity:0.49;fill:url(#ID_InfinityWallet_9);enable-background:new;}
      ` }), jsxs("linearGradient", { id: "ID_InfinityWallet_1", gradientUnits: "userSpaceOnUse", x1: "512.5", y1: "1056.1801", x2: "512.5", y2: "317.03", gradientTransform: "matrix(1 0 0 -1 0 1260)", children: [jsx("stop", { offset: "0", style: { stopColor: "#1D2643" } }), jsx("stop", { offset: "1", style: { stopColor: "#12142C" } })] }), jsx("path", { className: "infinityWallet-st0", d: "M130,0H895c71.8,0,130,58.2,130,130V895c0,71.8-58.2,130-130,130H130C58.2,1025,0,966.8,0,895V130\n    	C0,58.2,58.2,0,130,0z" }), jsxs("g", { children: [jsxs("g", { children: [jsxs("linearGradient", { id: "ID_InfinityWallet_2", gradientUnits: "userSpaceOnUse", x1: "326.0557", y1: "-1280.3162", x2: "326.0557", y2: "-296.3967", gradientTransform: "matrix(1 0 0 1 0 1474)", children: [jsx("stop", { offset: "1.000000e-02", style: { stopColor: "#00BFE1" } }), jsx("stop", { offset: "0.97", style: { stopColor: "#2738AB" } })] }), jsx("path", { className: "infinityWallet-st1", d: "M550.9,380.8c-0.7-2-2.4-3.4-4.4-3.9c-2.3-0.6-4.7,0-6.4,1.7l-13.4,13.4l-2.2,2.2L418.3,288.5\n    			c-40.2-40-105.2-40-145.4,0L121.7,439.9c-40,40.5-40,105.6,0,146.1l151.4,150.5c40.2,40,105.1,40,145.3,0l34.4-34.4\n    			c4.5-4.5,9.9-10.7,12.9-18.7c4.7-13.1,2.8-27.7-5.2-39.1c-1.5-2.2-3.2-4.2-5.1-6c-16.9-16.5-43.9-16.3-60.7,0.3l-37.2,37.1\n    			c-2.2,2.3-5,3.8-8.1,4.5c-2.9,0.7-6,0.5-8.8-0.6c-2.9-1-5.5-2.7-7.7-5L182.6,524.2c-2.3-2.3-3.9-5.2-4.6-8.4\n    			c-0.8-4-0.1-8.2,2.1-11.8l0.8-0.9L334,350.3c2.4-2.4,5.4-4,8.7-4.6c1-0.2,2.1-0.3,3.1-0.3c4.4-0.1,8.7,1.7,11.7,5l105.8,105.2\n    			l-5.3,5.3l-10.4,10.6c-1.7,1.7-2.3,4.1-1.7,6.4c0.5,2,2,3.7,3.9,4.4l95.7,11.7c8.2-0.1,14.8-6.7,15-15L550.9,380.8z" }), jsxs("linearGradient", { id: "ID_InfinityWallet_3", gradientUnits: "userSpaceOnUse", x1: "137.7126", y1: "-935.1906", x2: "201.098", y2: "-882.1746", gradientTransform: "matrix(1 0 0 1 -0.94 1473.3899)", children: [jsx("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), jsx("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), jsx("path", { className: "infinityWallet-st2", d: "M181.4,522.9c-4.3-4.9-5.1-13.3-1.3-19c0,0-49.7,54.3-25.8,114.4l31.5,31.3l45.8-76.2L181.4,522.9z" }), jsxs("linearGradient", { id: "ID_InfinityWallet_4", gradientUnits: "userSpaceOnUse", x1: "4132.3252", y1: "1674.2513", x2: "4102.1333", y2: "1717.0756", gradientTransform: "matrix(-1 0 0 -1 4515 2382.0898)", children: [jsx("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), jsx("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), jsx("path", { className: "infinityWallet-st3", d: "M336.4,677.7c56.1,51.6,117.9,22.9,117.9,22.9s8.1-7.5,11.4-17.4c-8.3-4-68.6-47.2-68.6-47.2l-35.6,35.6\n    			C348.6,687.1,336.4,677.7,336.4,677.7z" }), jsxs("linearGradient", { id: "ID_InfinityWallet_5", gradientUnits: "userSpaceOnUse", x1: "4217.4238", y1: "2067.1885", x2: "4240.0796", y2: "2011.1337", gradientTransform: "matrix(-1 0 0 -1 4515 2382.0898)", children: [jsx("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), jsx("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), jsx("path", { className: "infinityWallet-st4", d: "M299.4,385c0,0,35.9-36.2,36-36c0,0,9.6-7.7,19.7-0.7c0,0-59.7-49.2-123.6-18.3l-18.6,18.7L299.4,385z" })] }), jsxs("g", { children: [jsxs("linearGradient", { id: "ID_InfinityWallet_6", gradientUnits: "userSpaceOnUse", x1: "698.9443", y1: "-1280.3162", x2: "698.9443", y2: "-296.3967", gradientTransform: "matrix(1 0 0 1 0 1474)", children: [jsx("stop", { offset: "1.000000e-02", style: { stopColor: "#00BFE1" } }), jsx("stop", { offset: "0.97", style: { stopColor: "#2738AB" } })] }), jsx("path", { className: "infinityWallet-st5", d: "M474.1,644.3c0.7,2,2.4,3.4,4.4,3.9c2.3,0.6,4.7,0,6.4-1.7l13.4-13.4l2.2-2.2l106.2,105.6\n    			c40.2,40,105.2,40,145.4,0l151.2-151.4c40-40.5,40-105.6,0-146.1L751.9,288.5c-40.2-40-105.1-40-145.3,0l-34.4,34.4\n    			c-4.5,4.5-9.9,10.7-12.9,18.7c-4.7,13.1-2.8,27.7,5.2,39.1c1.5,2.2,3.2,4.2,5.1,6c16.9,16.5,43.9,16.3,60.7-0.3l37.2-37.1\n    			c2.2-2.3,5-3.8,8.1-4.5c2.9-0.7,6-0.5,8.8,0.6c2.9,1,5.5,2.7,7.7,5l150.3,150.3c2.3,2.3,3.9,5.2,4.6,8.4c0.8,4,0.1,8.2-2.1,11.8\n    			l-0.8,0.9L691,674.5c-2.4,2.4-5.4,4-8.7,4.6c-1,0.2-2.1,0.3-3.1,0.3c-4.4,0.1-8.7-1.7-11.7-5L561.6,569.7l5.3-5.3l10.4-10.6\n    			c1.7-1.7,2.3-4.1,1.7-6.4c-0.5-2-2-3.7-3.9-4.4l-95.6-11.7c-8.2,0.1-14.8,6.7-15,15L474.1,644.3z" }), jsxs("linearGradient", { id: "ID_InfinityWallet_7", gradientUnits: "userSpaceOnUse", x1: "3824.9182", y1: "1469.7789", x2: "3888.3037", y2: "1522.7949", gradientTransform: "matrix(-1 0 0 -1 4713.1299 1956.6599)", children: [jsx("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), jsx("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), jsx("path", { className: "infinityWallet-st6", d: "M843.6,502.2c4.3,4.9,5.1,13.3,1.3,19c0,0,49.7-54.3,25.8-114.4l-31.5-31.3l-45.8,76.2L843.6,502.2z" }), jsxs("linearGradient", { id: "ID_InfinityWallet_8", gradientUnits: "userSpaceOnUse", x1: "445.1279", y1: "-730.6945", x2: "414.9359", y2: "-687.8702", gradientTransform: "matrix(1 0 0 1 197.19 1047.96)", children: [jsx("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), jsx("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), jsx("path", { className: "infinityWallet-st7", d: "M688.6,347.4c-56.1-51.6-117.9-22.9-117.9-22.9s-8.1,7.5-11.4,17.4c8.3,4,68.6,47.2,68.6,47.2l35.6-35.6\n    			C676.4,338,688.6,347.4,688.6,347.4z" }), jsxs("linearGradient", { id: "ID_InfinityWallet_9", gradientUnits: "userSpaceOnUse", x1: "530.1512", y1: "-337.7953", x2: "552.8069", y2: "-393.8502", gradientTransform: "matrix(1 0 0 1 197.19 1047.96)", children: [jsx("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), jsx("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), jsx("path", { className: "infinityWallet-st8", d: "M725.5,640.1c0,0-35.9,36.2-36,36c0,0-9.6,7.7-19.7,0.7c0,0,59.7,49.2,123.6,18.3l18.6-18.7L725.5,640.1z" })] })] })] });
const Rabby = ({ ...props }) => jsxs("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "#8697FF" }, children: [jsx("path", { d: "M76.2062 48.0657C78.7621 42.356 66.1267 26.404 54.0555 19.7581C46.4467 14.6095 38.5183 15.3169 36.9125 17.5775C33.3886 22.5385 48.5814 26.7423 58.742 31.6478C56.5579 32.5964 54.4996 34.2987 53.2893 36.4758C49.5013 32.3404 41.1872 28.7791 31.4315 31.6478C24.8574 33.5809 19.3937 38.1382 17.2821 45.0216C16.7689 44.7936 16.2009 44.6669 15.6032 44.6669C13.3176 44.6669 11.4648 46.5197 11.4648 48.8052C11.4648 51.0908 13.3176 52.9435 15.6032 52.9435C16.0268 52.9435 17.3514 52.6594 17.3514 52.6594L38.5183 52.8128C30.0532 66.2418 23.3634 68.2049 23.3634 70.5314C23.3634 72.8579 29.7643 72.2274 32.1678 71.3602C43.6732 67.2088 56.0306 54.2706 58.1511 50.5462C67.056 51.6572 74.5397 51.7886 76.2062 48.0657Z", fill: "url(#paint0_linear_60607_36577)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M58.65 31.6053C58.682 31.6193 58.7139 31.6332 58.7458 31.6471C59.2168 31.4616 59.1406 30.766 59.0113 30.2198C58.714 28.9643 53.5856 23.9001 48.7696 21.6318C42.1984 18.5367 37.3618 18.7007 36.6582 20.1307C37.9975 22.8695 44.1927 25.441 50.663 28.1266C53.3909 29.2589 56.1676 30.4114 58.65 31.6053Z", fill: "url(#paint1_linear_60607_36577)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M50.4154 59.2247C49.0895 58.7182 47.592 58.2536 45.8898 57.8319C47.707 54.5801 48.0884 49.7663 46.3721 46.7226C43.9635 42.4512 40.9399 40.1777 33.9139 40.1777C30.0495 40.1777 19.6451 41.4794 19.4603 50.1648C19.441 51.0763 19.4599 51.9118 19.5259 52.68L38.5175 52.8176C35.9568 56.8798 33.5586 59.8928 31.4589 62.1841C33.9831 62.8309 36.0657 63.3738 37.9775 63.8722C39.7885 64.3443 41.4462 64.7764 43.1809 65.2191C45.8007 63.3102 48.2635 61.2288 50.4154 59.2247Z", fill: "url(#paint2_linear_60607_36577)" }), jsx("path", { d: "M17.0296 51.7821C17.8058 58.38 21.5555 60.9657 29.2177 61.7309C36.8799 62.4961 41.2751 61.9828 47.1265 62.5151C52.0136 62.9598 56.3772 65.4502 57.996 64.5895C59.4529 63.815 58.6378 61.0167 56.6884 59.2214C54.1614 56.8943 50.6641 55.2763 44.5104 54.7021C45.7368 51.3443 45.3931 46.6362 43.4885 44.0748C40.7345 40.3711 35.6513 38.6967 29.2177 39.4282C22.4962 40.1926 16.0556 43.5018 17.0296 51.7821Z", fill: "url(#paint3_linear_60607_36577)" }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_60607_36577", x1: "30.666", y1: "43.0094", x2: "75.6558", y2: "55.7677", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "white" }), jsx("stop", { offset: "1", stopColor: "white" })] }), jsxs("linearGradient", { id: "paint1_linear_60607_36577", x1: "68.0842", y1: "42.1521", x2: "35.6221", y2: "9.60636", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#7258DC" }), jsx("stop", { offset: "1", stopColor: "#797DEA", stopOpacity: "0" })] }), jsxs("linearGradient", { id: "paint2_linear_60607_36577", x1: "51.3184", y1: "60.3591", x2: "20.1383", y2: "42.4347", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#7461EA" }), jsx("stop", { offset: "1", stopColor: "#BFC2FF", stopOpacity: "0" })] }), jsxs("linearGradient", { id: "paint3_linear_60607_36577", x1: "33.3531", y1: "42.6732", x2: "54.4308", y2: "69.4547", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "white" }), jsx("stop", { offset: "0.983895", stopColor: "#D5CEFF" })] })] })] });
const TokenPocket = ({ ...props }) => jsxs("svg", { ...props, width: "88px", height: "88px", viewBox: "0 0 88 88", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: [jsx("defs", { children: jsxs("linearGradient", { x1: "107.511425%", y1: "50.0147427%", x2: "0.0459570557%", y2: "50.0147427%", id: "linearGradient-1", children: [jsx("stop", { stopColor: "#FFFFFF", offset: "0%" }), jsx("stop", { stopColor: "#FFFFFF", stopOpacity: "0.3233", offset: "96.67%" }), jsx("stop", { stopColor: "#FFFFFF", stopOpacity: "0.3", offset: "100%" })] }) }), jsx("g", { stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: jsxs("g", { id: "tokenpocket", fillRule: "nonzero", children: [jsx("polygon", { fill: "#2980FE", points: "87.9604864 0 0 0 0 88 87.9604864 88" }), jsxs("g", { transform: "translate(16.052385, 23.804688)", children: [jsx("path", { d: "M19.6653508,13.8911953 L19.6784508,13.8911953 C19.6653508,13.8236484 19.6653508,13.7448437 19.6653508,13.6772969 L19.6653508,13.8911953 Z", fill: "#29AEFF" }), jsx("path", { d: "M41.1271993,16.0301797 L29.2440711,16.0301797 L29.2440711,38.4205938 C29.2440711,39.4787422 30.0635659,40.3343359 31.0771712,40.3343359 L39.2940168,40.3343359 C40.3077044,40.3343359 41.1271993,39.4787422 41.1271993,38.4205938 L41.1271993,16.0301797 Z", fill: "#FFFFFF" }), jsx("path", { d: "M23.5075248,0 L23.1085201,0 L1.83318241,0 C0.819494855,0 0,0.855507812 0,1.91374219 L0,9.68111719 C0,10.7393516 0.819494855,11.5948594 1.83318241,11.5948594 L6.82580355,11.5948594 L8.80996071,11.5948594 L8.80996071,13.8912813 L8.80996071,38.4768828 C8.80996071,39.5351172 9.62945557,40.390625 10.6430608,40.390625 L18.4502002,40.390625 C19.4638054,40.390625 20.2833003,39.5351172 20.2833003,38.4768828 L20.2833003,13.8912813 L20.2833003,13.6774688 L20.2833003,11.5948594 L22.2674574,11.5948594 L23.0761684,11.5948594 L23.4751731,11.5948594 C26.5376389,11.5948594 29.0285575,8.99447656 29.0285575,5.79742969 C29.0609093,2.60038281 26.5699906,0 23.5075248,0 Z", fill: "#FFFFFF" }), jsx("path", { d: "M41.1381478,16.0301797 L41.1381478,31.6550781 C41.5479364,31.7563984 41.9684266,31.8352031 42.399783,31.90275 C43.0036819,31.9928125 43.6290664,32.0491016 44.2545332,32.0603594 C44.2868849,32.0603594 44.3192367,32.0603594 44.3623723,32.0603594 L44.3623723,19.6324219 C42.5615416,19.5085859 41.1381478,17.9438359 41.1381478,16.0301797 Z", fill: "url(#linearGradient-1)" }), jsx("path", { d: "M44.5993714,0 C36.1237942,0 29.2440711,7.18205469 29.2440711,16.0301797 C29.2440711,23.6400312 34.3229635,30.0115234 41.1379832,31.6550781 L41.1379832,16.0301797 C41.1379832,14.0376328 42.6907839,12.4165937 44.5993714,12.4165937 C46.5080412,12.4165937 48.0608419,14.0376328 48.0608419,16.0301797 C48.0608419,17.7075078 46.9717493,19.1146484 45.483652,19.5198437 C45.2032703,19.5986484 44.9013209,19.6436797 44.5993714,19.6436797 L44.5993714,32.0603594 C44.9013209,32.0603594 45.1924864,32.0491016 45.483652,32.0378438 C53.5495229,31.5537578 59.9547666,24.5743438 59.9547666,16.0301797 C59.9655379,7.18205469 53.0858148,0 44.5993714,0 Z", fill: "#FFFFFF" }), jsx("path", { d: "M44.5992891,32.0603594 L44.5992891,19.6436797 C44.5131001,19.6436797 44.4376127,19.6436797 44.3513414,19.6324219 L44.3513414,32.0603594 C44.4376127,32.0603594 44.523884,32.0603594 44.5992891,32.0603594 Z", fill: "#FFFFFF" })] })] }) })] });
const Talisman = ({ ...props }) => jsxs("svg", { ...props, width: "82", height: "82", viewBox: "0 0 82 82", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { width: "82", height: "82", rx: "12", fill: "#D5FF5C" }), jsx("path", { d: "M35.04 55C35.04 58.2905 37.6887 60.9623 40.9703 60.9996C44.2519 60.9623 46.9006 58.2905 46.9006 55C46.9006 51.7096 44.2519 49.0377 40.9703 49.0004C37.6887 49.0377 35.04 51.7096 35.04 55Z", fill: "#FD4848" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22.8544 44.6623C22.2462 45.9868 20.4553 46.4546 19.4248 45.4241L17.5356 43.5349C15.583 41.5823 12.4171 41.5823 10.4645 43.5349C8.51184 45.4875 8.51184 48.6534 10.4645 50.606L25.7391 65.8807C29.3942 70.2176 34.8595 72.9788 40.9703 72.9994C47.0811 72.9788 52.5464 70.2176 56.2014 65.8807L71.4761 50.606C73.4287 48.6534 73.4287 45.4875 71.4761 43.5349C69.5234 41.5823 66.3576 41.5823 64.4049 43.5349L62.5158 45.4241C61.4852 46.4546 59.6943 45.9868 59.0861 44.6623C58.9663 44.4013 58.901 44.1213 58.901 43.8341L58.901 20.9995C58.901 18.2381 56.6624 15.9995 53.901 15.9995C51.1396 15.9995 48.901 18.2381 48.901 20.9995L48.901 32.5568C48.901 33.5506 47.8829 34.2252 46.9353 33.9257C46.3356 33.7361 45.9023 33.1901 45.9023 32.5611L45.9023 13.9996C45.9023 11.2608 43.7004 9.03637 40.9703 9C38.2402 9.03637 36.0382 11.2608 36.0382 13.9996L36.0382 32.5611C36.0382 33.1901 35.605 33.7361 35.0052 33.9257C34.0576 34.2252 33.0395 33.5506 33.0395 32.5568L33.0396 20.9995C33.0396 18.2381 30.801 15.9995 28.0395 15.9995C25.2781 15.9995 23.0395 18.2381 23.0395 20.9995L23.0395 43.8341C23.0395 44.1213 22.9743 44.4013 22.8544 44.6623ZM40.9703 44.9999C32.1659 45.0525 25.0403 54.9997 25.0403 54.9997C25.0403 54.9997 32.1659 64.9469 40.9703 64.9995C49.7746 64.9469 56.9002 54.9997 56.9002 54.9997C56.9002 54.9997 49.7746 45.0525 40.9703 44.9999Z", fill: "#FD4848" })] });
const OtherWallets = ({ ...props }) => {
  const column = {
    position: "relative",
    display: "flex",
    flexDirection: "column",
    gap: 2
  };
  const row = {
    position: "relative",
    display: "flex",
    gap: 2
  };
  const cell = {
    width: "50%",
    overflow: "hidden",
    borderRadius: "27.5%"
  };
  return jsxs("div", { style: column, ...props, children: [jsxs("div", { style: row, children: [jsx("div", { style: cell, children: jsx(WalletConnect, { background: true }) }), jsx("div", { style: cell, children: !isZerion() ? jsx(Zerion, {}) : jsx(Phantom, {}) })] }), jsxs("div", { style: row, children: [jsx("div", { style: cell, children: !isFamily() ? jsx(Family, {}) : jsx(ImToken, {}) }), jsx("div", { style: cell, children: !isRainbow() ? jsx(Rainbow, {}) : jsx(Trust, {}) })] })] });
};
const Fordefi = ({ ...props }) => jsxs("svg", { ...props, width: "88", height: "88", viewBox: "0 0 96 96", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxs("g", { clipPath: "url(#clip0_14298_75627)", children: [jsx("path", { d: "M43.5075 62.5508H6V73.5954C6 79.2046 10.5379 83.7515 16.1357 83.7515H32.9997L43.5075 62.5508Z", fill: "#7994FF" }), jsx("path", { d: "M6.00098 39.1016H76.2075L68.0567 55.4841H6.00098V39.1016Z", fill: "#486DFF" }), jsx("path", { d: "M30.6398 12H6.09766V32.0282H89.8447V12H65.3025V26.9577H60.2423V12H35.7001V26.9577H30.6398V12Z", fill: "#5CD1FA" })] }), jsx("defs", { children: jsx("clipPath", { id: "clip0_14298_75627", children: jsx("rect", { width: "84", height: "72", fill: "white", transform: "translate(6 12)" }) }) })] });
var Logos = {
  Injected,
  OtherWallets,
  WalletConnect,
  WalletConnectLegacy,
  MetaMask,
  Coinbase,
  Family,
  Trust,
  Argent,
  ImToken,
  Rainbow,
  Crypto,
  Ledger,
  Brave: Brave$1,
  Steak,
  Unstoppable,
  ONTO,
  Slope,
  Safe,
  Frontier,
  Zerion,
  Phantom,
  PlaceHolder,
  Frame,
  Dawn,
  InfinityWallet,
  Rabby,
  Fordefi,
  TokenPocket,
  Talisman
};
const enUS = {
  connectWallet: "Connect Wallet",
  disconnect: "Disconnect",
  connected: "Connected",
  wrongNetwork: "Wrong Network",
  switchNetworks: "Switch Networks",
  chainNetwork: "{{ CHAIN }} Network",
  copyToClipboard: "Copy to Clipboard",
  copyCode: "Copy Code",
  moreInformation: "More Information",
  back: "Back",
  close: "Close",
  or: "or",
  more: "More",
  tryAgain: "Try Again",
  tryAgainQuestion: "Try Again?",
  dontHaveTheApp: "Don't have the app?",
  scanTheQRCode: "Scan the QR code",
  useWalletConnectModal: "Use WalletConnect Modal",
  useModal: "Use Modal",
  installTheExtension: "Install the Extension",
  getWalletName: "Get {{ CONNECTORNAME }}",
  otherWallets: "Other Wallets",
  learnMore: "Learn More",
  getWallet: "Get a Wallet",
  approveInWallet: "Approve in Wallet",
  confirmInWallet: "Confirm in Wallet",
  awaitingConfirmation: "Awaiting Confirmation",
  signIn: "Sign In",
  signOut: "Sign Out",
  signedIn: "Signed In",
  signedOut: "Signed Out",
  walletNotConnected: "Wallet Not Connected",
  warnings_walletSwitchingUnsupported: `Your wallet does not support switching networks from this app.`,
  warnings_walletSwitchingUnsupportedResolve: `Try switching networks from within your wallet instead.`,
  warnings_chainUnsupported: `This app does not support the current connected network.`,
  warnings_chainUnsupportedResolve: `Switch or disconnect to continue.`,
  onboardingScreen_heading: `Get a Wallet`,
  onboardingScreen_h1: `Start Exploring Web3`,
  onboardingScreen_p: `Your wallet is the gateway to all things Ethereum, the magical technology that makes it possible to explore web3.`,
  onboardingScreen_ctaText: `Choose Your First Wallet`,
  onboardingScreen_ctaUrl: `https://ethereum.org/en/wallets/find-wallet/`,
  aboutScreen_heading: `About Wallets`,
  aboutScreen_a_h1: `For your digital assets`,
  aboutScreen_a_p: `Wallets let you send, receive, store, and interact with digital assets like NFTs and other Ethereum tokens.`,
  aboutScreen_b_h1: `A better way to login`,
  aboutScreen_b_p: `With modern apps, your wallet can be used as an easy way to login, instead of having to remember a password.`,
  aboutScreen_c_h1: `Explore the world of web3`,
  aboutScreen_c_p: `Your wallet is an essential utility that lets you explore and participate in the fast evolving world of web3.`,
  aboutScreen_ctaText: `Learn More`,
  aboutScreen_ctaUrl: `https://ethereum.org/en/wallets/`,
  connectorsScreen_heading: `Connect Wallet`,
  connectorsScreen_newcomer: `I don’t have a wallet`,
  connectorsScreen_h1: `What is a wallet?`,
  connectorsScreen_p: `Wallets are used to send, receive, and store digital assets. Connecting a wallet lets you interact with apps.`,
  mobileConnectorsScreen_heading: `Choose Wallet`,
  scanScreen_heading: `Scan with Phone`,
  scanScreen_heading_withConnector: `Scan with {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `Open a [WALLETCONNECTLOGO] WalletConnect 
supported wallet to scan`,
  scanScreen_tooltip_default: `Open {{ CONNECTORNAME }} on 
your mobile phone to scan`,
  downloadAppScreen_heading: `Get {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `Scan with your phone camera to download on iOS or Android.`,
  downloadAppScreen_ios: `Scan with your phone camera to download on iOS.`,
  downloadAppScreen_android: `Scan with your phone camera to download Android.`,
  injectionScreen_unavailable_h1: `Unsupported Browser`,
  injectionScreen_unavailable_p: `To connect your {{ CONNECTORSHORTNAME }} wallet,
install the extension on {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: `Install {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `To connect your {{ CONNECTORSHORTNAME }} wallet,
install the browser extension.`,
  injectionScreen_connecting_h1: `Requesting Connection`,
  injectionScreen_connecting_p: `Open the {{ CONNECTORSHORTNAME }} browser 
extension to connect your wallet.`,
  injectionScreen_connecting_injected_h1: `Requesting Connection`,
  injectionScreen_connecting_injected_p: `Accept the request through your wallet to connect to this app.`,
  injectionScreen_connected_h1: `Already Connected`,
  injectionScreen_connected_p: `It is now okay to close this popup`,
  injectionScreen_rejected_h1: `Request Cancelled`,
  injectionScreen_rejected_p: `You cancelled the request.
Click above to try again.`,
  injectionScreen_failed_h1: `Connection Failed`,
  injectionScreen_failed_p: `Sorry, something went wrong.
Please try connecting again.`,
  injectionScreen_notconnected_h1: `Login to {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `To continue, please login to your {{ CONNECTORNAME }} extension.`,
  profileScreen_heading: "Connected",
  switchNetworkScreen_heading: "Switch Networks",
  signInWithEthereumScreen_tooltip: "You’re not signed in to this app.\n**Sign In With Ethereum** to continue.",
  signInWithEthereumScreen_signedOut_heading: "Sign In With Ethereum",
  signInWithEthereumScreen_signedOut_h1: "This app would like to verify you \n as the owner of this wallet.",
  signInWithEthereumScreen_signedOut_p: `Please sign the message request 
 in your wallet to continue.`,
  signInWithEthereumScreen_signedOut_button: "Sign In",
  signInWithEthereumScreen_signedIn_heading: "Signed In With Ethereum",
  signInWithEthereumScreen_signedIn_h1: "You successfully verified yourself \n as the owner of this wallet.",
  signInWithEthereumScreen_signedIn_p: `Signing out will require you to 
 authenticate again in the future.`,
  signInWithEthereumScreen_signedIn_button: "Sign Out"
};
const esES = {
  connectWallet: "Conecta una cartera",
  disconnect: "Desconectar",
  connected: "Conectado",
  wrongNetwork: "Red incorrecta",
  switchNetworks: "Cambio de red",
  chainNetwork: "Red {{ CHAIN }}",
  copyToClipboard: "Copiar al portapapeles",
  copyCode: "Copiar código",
  moreInformation: "Más información",
  back: "Atrás",
  close: "Cerrar",
  or: "o",
  more: "Más",
  tryAgain: "Intentar de nuevo",
  tryAgainQuestion: "¿Intentar de nuevo?",
  dontHaveTheApp: "¿No tienes la aplicación?",
  scanTheQRCode: "Escanea el código QR",
  useWalletConnectModal: "Utilizar WalletConnect Modal",
  useModal: "Utilizar Modal",
  installTheExtension: "Instalar la extensión",
  getWalletName: "Obtén {{ CONNECTORNAME }}",
  otherWallets: "Otras carteras",
  learnMore: "Más información",
  getWallet: "Obtén una cartera",
  approveInWallet: "Aprobar en la cartera",
  confirmInWallet: "Confirmar en la cartera",
  awaitingConfirmation: "A la espera de confirmación",
  signIn: "Iniciar sesión",
  signOut: "Cerrar sesión",
  signedIn: "Sesión iniciada",
  signedOut: "Sesión cerrada",
  walletNotConnected: "Cartera no conectada",
  warnings_walletSwitchingUnsupported: `Tu cartera no permite cambiar de red desde esta aplicación.`,
  warnings_walletSwitchingUnsupportedResolve: `Prueba a cambiar de red desde tu cartera.`,
  warnings_chainUnsupported: `Esta aplicación no es compatible con la red conectada actualmente.`,
  warnings_chainUnsupportedResolve: `Cambia o desconecta para continuar.`,
  onboardingScreen_heading: `Obtén una cartera`,
  onboardingScreen_h1: `Comienza a explorar la Web3`,
  onboardingScreen_p: `Tu cartera es el portal de acceso a todo lo relacionado con Ethereum, la tecnología mágica que permite explorar la Web3.`,
  onboardingScreen_ctaText: `Elige tu primera cartera`,
  onboardingScreen_ctaUrl: `https://ethereum.org/es/wallets/find-wallet/`,
  aboutScreen_heading: `Acerca de las carteras`,
  aboutScreen_a_h1: `Para tus activos digitales`,
  aboutScreen_a_p: `Las carteras te permiten enviar, recibir, almacenar e interactuar con activos digitales como los NFT y otros tokens de Ethereum.`,
  aboutScreen_b_h1: `Una manera mejor de iniciar sesión`,
  aboutScreen_b_p: `Con las aplicaciones modernas, puedes utilizar tu cartera para iniciar sesión fácilmente, en vez de tener que recordar una contraseña.`,
  aboutScreen_c_h1: `Explora el mundo de la Web3`,
  aboutScreen_c_p: `Tu cartera es una herramienta esencial que te permite explorar y participar en el mundo en rápida evolución de la Web3.`,
  aboutScreen_ctaText: `Más información`,
  aboutScreen_ctaUrl: `https://ethereum.org/es/wallets/`,
  connectorsScreen_heading: `Conecta una cartera`,
  connectorsScreen_newcomer: `No tengo una cartera`,
  connectorsScreen_h1: `¿Qué es una cartera?`,
  connectorsScreen_p: `Las carteras se utilizan para enviar, recibir y almacenar activos digitales. Si conectas una cartera, podrás interactuar con las aplicaciones.`,
  mobileConnectorsScreen_heading: `Elige una cartera`,
  scanScreen_heading: `Escanea con el teléfono`,
  scanScreen_heading_withConnector: `Escanea con {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `Abre una cartera compatible con WalletConnect [WALLETCONNECTLOGO] para escanear`,
  scanScreen_tooltip_default: `Abre {{ CONNECTORNAME }} en tu teléfono móvil para escanear`,
  downloadAppScreen_heading: `Obtén {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `Escanea con la cámara de tu teléfono para descargarla en iOS o Android.`,
  downloadAppScreen_ios: `Escanea con la cámara de tu teléfono para descargarla en iOS.`,
  downloadAppScreen_android: `Escanea con la cámara de tu teléfono para descargarla en Android.`,
  injectionScreen_unavailable_h1: `Navegador no compatible`,
  injectionScreen_unavailable_p: `Para conectar tu cartera de {{ CONNECTORSHORTNAME }}, instala la extensión en {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: `Instala {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `Para conectar tu cartera de {{ CONNECTORSHORTNAME }}, instala la extensión del navegador.`,
  injectionScreen_connecting_h1: `Solicitud de conexión`,
  injectionScreen_connecting_p: `Abre la extensión del navegador de {{ CONNECTORSHORTNAME }}  para conectar tu cartera.`,
  injectionScreen_connecting_injected_h1: `Solicitud de conexión`,
  injectionScreen_connecting_injected_p: `Acepta la solicitud a través de tu cartera para conectarte a esta aplicación.`,
  injectionScreen_connected_h1: `Ya conectada`,
  injectionScreen_connected_p: `Ya puedes cerrar esta ventana emergente`,
  injectionScreen_rejected_h1: `Solicitud cancelada`,
  injectionScreen_rejected_p: `Has cancelado la solicitud. Haz clic arriba para intentarlo de nuevo.`,
  injectionScreen_failed_h1: `Error de conexión`,
  injectionScreen_failed_p: `Lo sentimos, ha habido un problema. Intenta conectarte de nuevo.`,
  injectionScreen_notconnected_h1: `Inicia sesión en {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `Para continuar, inicia sesión en tu extensión de {{ CONNECTORNAME }}.`,
  profileScreen_heading: "Conectado",
  switchNetworkScreen_heading: "Cambio de red",
  signInWithEthereumScreen_tooltip: "No has iniciado sesión en esta aplicación.\n**Inicia sesión con Ethereum** para continuar.",
  signInWithEthereumScreen_signedOut_heading: "Inicia sesión con Ethereum",
  signInWithEthereumScreen_signedOut_h1: "Esta aplicación desea verificar que eres el propietario de esta cartera.",
  signInWithEthereumScreen_signedOut_p: `Firma la solicitud de mensaje en tu cartera para continuar.`,
  signInWithEthereumScreen_signedOut_button: "Iniciar sesión",
  signInWithEthereumScreen_signedIn_heading: "Sesión iniciada con Ethereum",
  signInWithEthereumScreen_signedIn_h1: "Te has verificado correctamente como propietario de esta cartera.",
  signInWithEthereumScreen_signedIn_p: `Si cierras la sesión, tendrás que volver a autenticarte más adelante.`,
  signInWithEthereumScreen_signedIn_button: "Cerrar sesión"
};
const frFR = {
  connectWallet: "Connecter le portefeuille",
  disconnect: "Déconnecter",
  connected: "Connecté",
  wrongNetwork: "Réseau incorrect",
  switchNetworks: "Changer de réseau",
  chainNetwork: "Réseau {{ CHAIN }}",
  copyToClipboard: "Copier dans le presse-papiers",
  copyCode: "Copier le code",
  moreInformation: "Plus d’informations",
  back: "Retour",
  close: "Fermer",
  or: "ou",
  more: "Plus",
  tryAgain: "Réessayer",
  tryAgainQuestion: "Réessayer ?",
  dontHaveTheApp: "Vous n’avez pas l’application ?",
  scanTheQRCode: "Scannez le code QR",
  useWalletConnectModal: "Utiliser la modale WalletConnect",
  useModal: "Utiliser la modale",
  installTheExtension: "Installer l’extension",
  getWalletName: "Obtenez {{ CONNECTORNAME }}",
  otherWallets: "Autres portefeuilles",
  learnMore: "En savoir plus",
  getWallet: "Obtenir un portefeuille",
  approveInWallet: "Approuver dans le portefeuille",
  confirmInWallet: "Confirmer dans le portefeuille",
  awaitingConfirmation: "En attente de confirmation",
  signIn: "Se connecter",
  signOut: "Se déconnecter",
  signedIn: "Connecté",
  signedOut: "Déconnecté",
  walletNotConnected: "Portefeuille non connecté",
  warnings_walletSwitchingUnsupported: `Votre portefeuille ne prend pas en charge le changement de réseau à partir de cette application.`,
  warnings_walletSwitchingUnsupportedResolve: `Essayez plutôt de changer de réseau à partir de votre portefeuille.`,
  warnings_chainUnsupported: `Cette application ne prend pas en charge le réseau connecté actuel.`,
  warnings_chainUnsupportedResolve: `Changez ou déconnectez-vous pour continuer.`,
  onboardingScreen_heading: `Obtenez un portefeuille`,
  onboardingScreen_h1: `Commencez à explorer le Web3`,
  onboardingScreen_p: `Votre portefeuille est la porte d'entrée vers tout ce qui concerne l'Ethereum, la technologie magique qui permet d'explorer le Web3.`,
  onboardingScreen_ctaText: `Choisissez votre premier portefeuille`,
  onboardingScreen_ctaUrl: `https://ethereum.org/fr/wallets/find-wallet/`,
  aboutScreen_heading: `À propos des portefeuilles`,
  aboutScreen_a_h1: `Pour vos actifs numériques`,
  aboutScreen_a_p: `Les portefeuilles vous permettent d'envoyer, de recevoir, de stocker et d'interagir avec des actifs numériques tels que des NFT et d'autres jetons Ethereum.`,
  aboutScreen_b_h1: `Une meilleure façon de se connecter`,
  aboutScreen_b_p: `Avec les applications modernes, votre portefeuille peut s'utiliser pour vous connecter facilement, au lieu d'avoir à mémoriser un mot de passe.`,
  aboutScreen_c_h1: `Explorez le monde du Web3`,
  aboutScreen_c_p: `Votre portefeuille est un utilitaire essentiel qui vous permet d'explorer et de participer au monde en évolution rapide du Web3.`,
  aboutScreen_ctaText: `En savoir plus`,
  aboutScreen_ctaUrl: `https://ethereum.org/fr/wallets/`,
  connectorsScreen_heading: `Connectez le portefeuille`,
  connectorsScreen_newcomer: `Je n’ai pas de portefeuille`,
  connectorsScreen_h1: `Qu’est-ce qu’un portefeuille ?`,
  connectorsScreen_p: `Les portefeuilles s'utilisent pour envoyer, recevoir et stocker des actifs numériques. La connexion d'un portefeuille vous permet d'interagir avec les applications.`,
  mobileConnectorsScreen_heading: `Choisissez le portefeuille`,
  scanScreen_heading: `Scannez avec le téléphone`,
  scanScreen_heading_withConnector: `Scannez avec {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `Ouvrez un portefeuille pris en charge par WalletConnect [WALLETCONNECTLOGO] pour scanner`,
  scanScreen_tooltip_default: `Ouvrez {{ CONNECTORNAME }} sur votre téléphone mobile pour scanner`,
  downloadAppScreen_heading: `Obtenez {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `Scannez avec l'appareil photo de votre téléphone pour le télécharger sur iOS ou Android.`,
  downloadAppScreen_ios: `Scannez avec l'appareil photo de votre téléphone pour le télécharger sur iOS.`,
  downloadAppScreen_android: `Scannez avec l'appareil photo de votre téléphone pour le télécharger sur Android.`,
  injectionScreen_unavailable_h1: `Navigateur non pris en charge`,
  injectionScreen_unavailable_p: `Pour connecter votre portefeuille {{ CONNECTORSHORTNAME }}, installez l’extension sur {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: `Installez {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `Pour connecter votre portefeuille {{ CONNECTORSHORTNAME }}, installez l’extension de navigateur.`,
  injectionScreen_connecting_h1: `Demande de connexion`,
  injectionScreen_connecting_p: `Ouvrez l’extension de navigateur {{ CONNECTORSHORTNAME }} pour connecter votre portefeuille.`,
  injectionScreen_connecting_injected_h1: `Demande de connexion`,
  injectionScreen_connecting_injected_p: `Acceptez la demande via votre portefeuille pour vous connecter à cette application.`,
  injectionScreen_connected_h1: `Déjà connecté`,
  injectionScreen_connected_p: `Vous pouvez maintenant fermer ce pop-up`,
  injectionScreen_rejected_h1: `Demande annulée`,
  injectionScreen_rejected_p: `Vous avez annulé la demande. Cliquez ci-dessus pour réessayer.`,
  injectionScreen_failed_h1: `Échec de la connexion`,
  injectionScreen_failed_p: `Malheureusement, un problème est survenu. Veuillez réessayer de vous connecter.`,
  injectionScreen_notconnected_h1: `Connectez-vous à {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `Pour continuer, veuillez vous connecter à votre extension {{ CONNECTORNAME }} .`,
  profileScreen_heading: "Connecté",
  switchNetworkScreen_heading: "Changer de réseau",
  signInWithEthereumScreen_tooltip: "Vous n’êtes pas connecté à cette application.\n**Connectez-vous avec Ethereum** pour continuer.",
  signInWithEthereumScreen_signedOut_heading: "Connectez-vous avec Ethereum",
  signInWithEthereumScreen_signedOut_h1: "Cette application souhaite vérifier que vous êtes bien le propriétaire de ce portefeuille.",
  signInWithEthereumScreen_signedOut_p: `Veuillez signer la demande de message dans votre portefeuille pour continuer.`,
  signInWithEthereumScreen_signedOut_button: "Se connecter",
  signInWithEthereumScreen_signedIn_heading: "Connecté avec Ethereum",
  signInWithEthereumScreen_signedIn_h1: "Vous avez réussi à vous identifier en tant que propriétaire de ce portefeuille.",
  signInWithEthereumScreen_signedIn_p: `La déconnexion vous obligera à vous authentifier à nouveau à l'avenir.`,
  signInWithEthereumScreen_signedIn_button: "Se déconnecter"
};
var jaJP = {
  connectWallet: "ウォレットの接続",
  disconnect: "切断",
  connected: "接続されました",
  wrongNetwork: "間違ったネットワーク",
  switchNetworks: "ネットワークの切り替え",
  chainNetwork: "{{ CHAIN }} ネットワーク",
  copyToClipboard: "クリップボードにコピー",
  copyCode: "コードをコピー",
  moreInformation: "詳細情報",
  back: "戻る",
  close: "閉じる",
  or: "または",
  more: "その他",
  tryAgain: "再試行",
  tryAgainQuestion: "もう一度試しますか？",
  dontHaveTheApp: "アプリをお持ちではありませんか？",
  scanTheQRCode: "QR コードをスキャン",
  useWalletConnectModal: "WalletConnect モーダルを使用",
  useModal: "モーダルを使用",
  installTheExtension: "拡張機能をインストール",
  getWalletName: "{{ CONNECTORNAME }} を取得",
  otherWallets: "その他のウォレット",
  learnMore: "詳細情報",
  getWallet: "ウォレットを入手",
  approveInWallet: "ウォレットで承認",
  confirmInWallet: "ウォレットで確認",
  awaitingConfirmation: "確認を待っています",
  signIn: "サインイン",
  signOut: "サインアウト",
  signedIn: "サインインしました",
  signedOut: "サインアウトしました",
  walletNotConnected: "ウォレットが接続されていません",
  warnings_walletSwitchingUnsupported: `お使いのウォレットは、このアプリからのネットワークの切り替えをサポートしていません。`,
  warnings_walletSwitchingUnsupportedResolve: `代わりにウォレット内からネットワークを切り替えてみてください。`,
  warnings_chainUnsupported: `このアプリは、現在接続されているネットワークをサポートしていません。`,
  warnings_chainUnsupportedResolve: `切り替えるか切断して続行します。`,
  onboardingScreen_heading: `ウォレットを入手`,
  onboardingScreen_h1: `Web3 の探索を開始`,
  onboardingScreen_p: `ウォレットは、web3 の探索を可能にする魔法のテクノロジーであるイーサリアムのすべてへのゲートウェイです。`,
  onboardingScreen_ctaText: `最初のウォレットを選択してください`,
  onboardingScreen_ctaUrl: `https://ethereum.org/ja/wallets/find-wallet/`,
  aboutScreen_heading: `ウォレットについて`,
  aboutScreen_a_h1: `デジタル資産用`,
  aboutScreen_a_p: `ウォレットを使用すると、NFT やその他のイーサリアム トークンなどのデジタル資産を送信、受信、保存、および操作できます。`,
  aboutScreen_b_h1: `より良いログイン方法`,
  aboutScreen_b_p: `最新のアプリでは、パスワードを覚える必要がなく、ウォレットを簡単なログイン方法として使用できます。`,
  aboutScreen_c_h1: `web3 の世界を探索`,
  aboutScreen_c_p: `ウォレットは、急速に進化する web3 の世界を探索し、参加するために不可欠なユーティリティです。`,
  aboutScreen_ctaText: `詳細情報`,
  aboutScreen_ctaUrl: `https://ethereum.org/ja/wallets/`,
  connectorsScreen_heading: `ウォレットの接続`,
  connectorsScreen_newcomer: `ウォレットを持っていません`,
  connectorsScreen_h1: `ウォレットとは何ですか？`,
  connectorsScreen_p: `ウォレットは、デジタル資産の送信、受信、および保存に使用されます。 ウォレットを接続すると、アプリとやり取りできます。`,
  mobileConnectorsScreen_heading: `ウォレットを選択`,
  scanScreen_heading: `電話でスキャンする`,
  scanScreen_heading_withConnector: `{{ CONNECTORNAME }}でスキャンする`,
  scanScreen_tooltip_walletConnect: `[WALLETCONNECTLOGO] WalletConnect 対応の ウォレットを開いてスキャンします`,
  scanScreen_tooltip_default: `携帯電話で {{ CONNECTORNAME }} を 開いてスキャンします`,
  downloadAppScreen_heading: `{{ CONNECTORNAME }} を取得`,
  downloadAppScreen_iosAndroid: `携帯電話のカメラでスキャンして、iOS または Android にダウンロードします。`,
  downloadAppScreen_ios: `携帯電話のカメラでスキャンして、iOS にダウンロードします。`,
  downloadAppScreen_android: `携帯電話のカメラでスキャンして、Android にダウンロードします。`,
  injectionScreen_unavailable_h1: `サポートされていないブラウザ`,
  injectionScreen_unavailable_p: `{{ CONNECTORSHORTNAME }} ウォレットを接続するには、{{ SUGGESTEDEXTENSIONBROWSER }} に拡張機能をインストールします。`,
  injectionScreen_install_h1: `{{ CONNECTORNAME }} をインストール`,
  injectionScreen_install_p: `{{ CONNECTORSHORTNAME }} ウォレットを接続するには、ブラウザ拡張機能をインストールします。`,
  injectionScreen_connecting_h1: `接続を要求`,
  injectionScreen_connecting_p: `{{ CONNECTORSHORTNAME }} ブラウザ拡張機能を 開いて、ウォレットを接続します。`,
  injectionScreen_connecting_injected_h1: `接続を要求`,
  injectionScreen_connecting_injected_p: `このアプリに接続するには、ウォレットを介して要求を受け入れます。`,
  injectionScreen_connected_h1: `すでに接続済み`,
  injectionScreen_connected_p: `このポップアップを閉じてもかまいません`,
  injectionScreen_rejected_h1: `要求がキャンセルされました`,
  injectionScreen_rejected_p: `要求をキャンセルしました。上をクリックしてもう一度お試しください。`,
  injectionScreen_failed_h1: `接続に失敗しました`,
  injectionScreen_failed_p: `申し訳ありませんが、問題が発生しました。もう一度接続してみてください。`,
  injectionScreen_notconnected_h1: `{{ CONNECTORNAME }} にログイン`,
  injectionScreen_notconnected_p: `続行するには、 {{ CONNECTORNAME }} 拡張機能にログインしてください。`,
  profileScreen_heading: "接続されました",
  switchNetworkScreen_heading: "ネットワークの切り替え",
  signInWithEthereumScreen_tooltip: "このアプリにサインインしていません。\n続行するには、**イーサリアムでサインイン**してください。",
  signInWithEthereumScreen_signedOut_heading: "イーサリアムでサインイン",
  signInWithEthereumScreen_signedOut_h1: "このアプリは、あなたがこのウォレットの 所有者であることを確認しようとしています。",
  signInWithEthereumScreen_signedOut_p: `続行するには、ウォレットで メッセージ リクエストに署名してください。`,
  signInWithEthereumScreen_signedOut_button: "サインイン",
  signInWithEthereumScreen_signedIn_heading: "イーサリアムでサインインしました",
  signInWithEthereumScreen_signedIn_h1: "このウォレットの所有者であることが 正常に確認されました。",
  signInWithEthereumScreen_signedIn_p: `サインアウトすると、今後 再度認証する必要があります。`,
  signInWithEthereumScreen_signedIn_button: "サインアウト"
};
const ptBR = {
  connectWallet: "Conectar carteira",
  disconnect: "Desconectar",
  connected: "Conectado",
  wrongNetwork: "Rede incorreta",
  switchNetworks: "Alternar rede",
  chainNetwork: "Rede {{ CHAIN }}",
  copyToClipboard: "Copiar para a área de transferência",
  copyCode: "Copiar código",
  moreInformation: "Mais informações",
  back: "Voltar",
  close: "Fechar",
  or: "ou",
  more: "Mais",
  tryAgain: "Tentar novamente",
  tryAgainQuestion: "Tentar novamente?",
  dontHaveTheApp: "Não tem o aplicativo?",
  scanTheQRCode: "Escaneie o código QR",
  useWalletConnectModal: "Use o modal do WalletConnect",
  useModal: "Usar modal",
  installTheExtension: "Instale a extensão",
  getWalletName: "Obter {{ CONNECTORNAME }}",
  otherWallets: "Outras carteiras",
  learnMore: "Saiba mais",
  getWallet: "Obtenha uma carteira",
  approveInWallet: "Aprovar na carteira",
  confirmInWallet: "Confirmar na carteira",
  awaitingConfirmation: "Aguardando confirmação",
  signIn: "Entrar",
  signOut: "Sair",
  signedIn: "Conectado",
  signedOut: "Desconectado",
  walletNotConnected: "Carteira não conectada",
  warnings_walletSwitchingUnsupported: `A sua carteira não permite a troca de rede a partir deste aplicativo.`,
  warnings_walletSwitchingUnsupportedResolve: `Tente trocar de rede de dentro da sua carteira.`,
  warnings_chainUnsupported: `Este aplicativo não é compatível com a rede conectada.`,
  warnings_chainUnsupportedResolve: `Altere a rede ou desconecte para continuar.`,
  onboardingScreen_heading: `Obtenha uma carteira`,
  onboardingScreen_h1: `Comece a explorar a Web3`,
  onboardingScreen_p: `Sua carteira é a porta de entrada para todas as coisas Ethereum, a tecnologia mágica que torna possível explorar a web3.`,
  onboardingScreen_ctaText: `Escolha sua primeira carteira`,
  onboardingScreen_ctaUrl: `https://ethereum.org/pt-br/wallets/find-wallet/`,
  aboutScreen_heading: `Sobre as carteiras`,
  aboutScreen_a_h1: `Para seus ativos digitais`,
  aboutScreen_a_p: `As carteiras permitem que você envie, receba, armazene e interaja com ativos digitais como NFTs e outros tokens Ethereum.`,
  aboutScreen_b_h1: `Uma maneira melhor de fazer login`,
  aboutScreen_b_p: `Com aplicativos modernos, sua carteira pode ser usada como uma maneira fácil de fazer login, em vez de ter que lembrar uma senha.`,
  aboutScreen_c_h1: `Explore o mundo da Web3`,
  aboutScreen_c_p: `Sua carteira é uma utilidade essencial que permite explorar e participar do mundo em rápida evolução da Web3.`,
  aboutScreen_ctaText: `Saiba mais`,
  aboutScreen_ctaUrl: `https://ethereum.org/pt-br/wallets/`,
  connectorsScreen_heading: `Conectar carteira`,
  connectorsScreen_newcomer: `Eu não tenho uma carteira`,
  connectorsScreen_h1: `O que é uma carteira?`,
  connectorsScreen_p: `As carteiras são usadas para enviar, receber e armazenar ativos digitais. A conexão de uma carteira permite que você interaja com aplicativos.`,
  mobileConnectorsScreen_heading: `Escolha uma carteira`,
  scanScreen_heading: `Escanear com o celular`,
  scanScreen_heading_withConnector: `Escanear com o {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `Abra uma carteira compatível 
com o WalletConnect [WALLETCONNECTLOGO] para escanear`,
  scanScreen_tooltip_default: `Abra o {{ CONNECTORNAME }} no 
seu celular para escanear`,
  downloadAppScreen_heading: `Obter {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `Escaneie com a câmera do seu celular para baixar no iOS ou Android.`,
  downloadAppScreen_ios: `Escaneie com a câmera do seu celular para baixar no iOS.`,
  downloadAppScreen_android: `Escaneie com a câmera do seu celular para baixar no Android.`,
  injectionScreen_unavailable_h1: `Navegador não compatível`,
  injectionScreen_unavailable_p: `Para conectar sua carteira {{ CONNECTORSHORTNAME }},
instale a extensão no {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: `Instalar {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `Para conectar sua carteira {{ CONNECTORSHORTNAME }},
instale a extensão do navegador`,
  injectionScreen_connecting_h1: `Solicitando conexão`,
  injectionScreen_connecting_p: `Abra a extensão do navegador do {{ CONNECTORSHORTNAME }} 
para conectar a sua carteira.`,
  injectionScreen_connecting_injected_h1: `Solicitando conexão`,
  injectionScreen_connecting_injected_p: `Aceite a solicitação por meio de sua carteira para se conectar a este aplicativo.`,
  injectionScreen_connected_h1: `Já conectado`,
  injectionScreen_connected_p: `Agora você já pode fechar esta janela`,
  injectionScreen_rejected_h1: `Solicitação cancelada`,
  injectionScreen_rejected_p: `Você cancelou a solicitação.
Clique acima para tentar novamente.`,
  injectionScreen_failed_h1: `A conexão falhou`,
  injectionScreen_failed_p: `Desculpe, ocorreu um erro.
Por favor, tente conectar novamente.`,
  injectionScreen_notconnected_h1: `Faça login no {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `Para continuar, faça login na sua extensão do {{ CONNECTORNAME }}.`,
  profileScreen_heading: "Conectado",
  switchNetworkScreen_heading: "Alternar rede",
  signInWithEthereumScreen_tooltip: "Você não está conectado a este aplicativo.\n**Entre com Ethereum** para continuar.",
  signInWithEthereumScreen_signedOut_heading: "Entrar com Ethereum",
  signInWithEthereumScreen_signedOut_h1: "Este aplicativo gostaria de verificar você \n como o proprietário desta carteira.",
  signInWithEthereumScreen_signedOut_p: `Por favor, assine o pedido de mensagem 
 em sua carteira para continuar.`,
  signInWithEthereumScreen_signedOut_button: "Entrar",
  signInWithEthereumScreen_signedIn_heading: "Conectado com Ethereum",
  signInWithEthereumScreen_signedIn_h1: "Você se verificou com sucesso \n como o proprietário desta carteira",
  signInWithEthereumScreen_signedIn_p: `Se sair, será necessário que você 
 autentique novamente no futuro.`,
  signInWithEthereumScreen_signedIn_button: "Sair"
};
const zhCN = {
  connectWallet: "绑定钱包",
  disconnect: "解除绑定",
  connected: "已绑定",
  wrongNetwork: "错误网络",
  switchNetworks: "切换网络",
  chainNetwork: "{{ CHAIN }}网络",
  copyToClipboard: "复制到剪贴板",
  copyCode: "复制代码",
  moreInformation: "更多信息",
  back: "返回",
  close: "关闭",
  or: "或",
  more: "更多",
  tryAgain: "重试",
  tryAgainQuestion: "重试？",
  dontHaveTheApp: "没有该应用？",
  scanTheQRCode: "扫描二维码",
  useWalletConnectModal: "使用 WalletConnect 模态窗",
  useModal: "使用模态窗",
  installTheExtension: "安装扩展程序",
  getWalletName: "获取{{ CONNECTORNAME }}",
  otherWallets: "其他钱包",
  learnMore: "了解更多",
  getWallet: "获取钱包",
  approveInWallet: "在钱包中批准",
  confirmInWallet: "在钱包中确认",
  awaitingConfirmation: "等待确认",
  signIn: "登录",
  signOut: "登出",
  signedIn: "已登录",
  signedOut: "已登出",
  walletNotConnected: "钱包未绑定",
  warnings_walletSwitchingUnsupported: `您的钱包不支持从此应用切换网络。`,
  warnings_walletSwitchingUnsupportedResolve: `请尝试从钱包中切换网络。`,
  warnings_chainUnsupported: `此应用不支持当前连接的网络。`,
  warnings_chainUnsupportedResolve: `请切换网络或断开连接以继续。`,
  onboardingScreen_heading: `获取钱包`,
  onboardingScreen_h1: `开始探索 Web3`,
  onboardingScreen_p: `您的钱包是通往以太坊的一扇大门，而以太坊是探索 Web3 的一项神奇技术。`,
  onboardingScreen_ctaText: `选择您的第一钱包`,
  onboardingScreen_ctaUrl: `https://ethereum.org/zh/wallets/find-wallet/`,
  aboutScreen_heading: `关于钱包`,
  aboutScreen_a_h1: `对于您的数字资产`,
  aboutScreen_a_p: `有了钱包，您可以发送、接收、存储数字资产及使用数字资产进行交互，例如 NFT 和其他以太坊通证等。`,
  aboutScreen_b_h1: `更好的登录方式`,
  aboutScreen_b_p: `使用现代应用，您的钱包可以用作简便的登录方法，而不必记住密码。`,
  aboutScreen_c_h1: `探索 Web3 世界`,
  aboutScreen_c_p: `您的钱包是一个重要的工具，可以让您探索并参与到快速发展的 Web3 世界。`,
  aboutScreen_ctaText: `了解更多`,
  aboutScreen_ctaUrl: `https://ethereum.org/zh/wallets/`,
  connectorsScreen_heading: `绑定钱包`,
  connectorsScreen_newcomer: `我没有钱包`,
  connectorsScreen_h1: `什么是钱包？`,
  connectorsScreen_p: `钱包可用于发送、接收和存储数字资产。通过绑定钱包，您可以与应用进行交互。`,
  mobileConnectorsScreen_heading: `选择钱包`,
  scanScreen_heading: `手机扫描`,
  scanScreen_heading_withConnector: `手机扫描{{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `打开 [WALLETCONNECTLOGO] WalletConnect 支持的钱包进行扫描`,
  scanScreen_tooltip_default: `打开您手机上的{{ CONNECTORNAME }} 进行扫描`,
  downloadAppScreen_heading: `获取{{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `使用手机相机扫描以下载 iOS 或 Android 应用。`,
  downloadAppScreen_ios: `使用手机相机扫描以下载 iOS 应用。`,
  downloadAppScreen_android: `使用手机相机扫描以下载 Android 应用。`,
  injectionScreen_unavailable_h1: `不支持的浏览器`,
  injectionScreen_unavailable_p: `要绑定您的{{ CONNECTORSHORTNAME }}钱包，请在{{ SUGGESTEDEXTENSIONBROWSER }}上安装此扩展程序。`,
  injectionScreen_install_h1: `安装{{ CONNECTORNAME }}`,
  injectionScreen_install_p: `要绑定您的{{ CONNECTORSHORTNAME }}钱包，请安装此浏览器扩展程序。`,
  injectionScreen_connecting_h1: `请求绑定`,
  injectionScreen_connecting_p: `打开{{ CONNECTORSHORTNAME }}浏览器 扩展程序以绑定您的钱包。`,
  injectionScreen_connecting_injected_h1: `请求绑定`,
  injectionScreen_connecting_injected_p: `通过您的钱包接受请求，以绑定到此应用。`,
  injectionScreen_connected_h1: `已绑定`,
  injectionScreen_connected_p: `现在可以关闭此弹窗`,
  injectionScreen_rejected_h1: `请求已取消`,
  injectionScreen_rejected_p: `您已取消请求。n点击上面可重试。`,
  injectionScreen_failed_h1: `绑定失败`,
  injectionScreen_failed_p: `抱歉，发生错误。请尝试重新绑定。`,
  injectionScreen_notconnected_h1: `登录{{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `要继续，请登录到您的{{ CONNECTORNAME }}扩展程序。`,
  profileScreen_heading: "已绑定",
  switchNetworkScreen_heading: "切换网络",
  signInWithEthereumScreen_tooltip: "您尚未登录到此应用。\n请选择**使用以太坊登录**以继续。",
  signInWithEthereumScreen_signedOut_heading: "使用以太坊登录",
  signInWithEthereumScreen_signedOut_h1: "此应用希望验证您是 此钱包的所有者。",
  signInWithEthereumScreen_signedOut_p: `请签署钱包中的消息请求 以继续。`,
  signInWithEthereumScreen_signedOut_button: "登录",
  signInWithEthereumScreen_signedIn_heading: "已使用以太坊登录",
  signInWithEthereumScreen_signedIn_h1: "您已成功验证自己 是此钱包的所有者。",
  signInWithEthereumScreen_signedIn_p: `登出后，将来您还需要 再次进行身份验证。`,
  signInWithEthereumScreen_signedIn_button: "登出"
};
const getLocale = (lang) => {
  switch (lang) {
    case "es-ES":
      return esES;
    case "fr-FR":
      return frFR;
    case "ja-JP":
      return jaJP;
    case "pt-BR":
      return ptBR;
    case "zh-CN":
      return zhCN;
    default:
      return enUS;
  }
};
function useLocales(replacements) {
  var _a2, _b;
  const context = useContext();
  const language = (_b = (_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.language) !== null && _b !== void 0 ? _b : "en-US";
  const translations = reactExports.useMemo(() => {
    return getLocale(language);
  }, [language]);
  if (!translations) {
    console.error(`Missing translations for: ${language}`);
    return `Missing translations for: ${language}`;
  }
  const translated = {};
  Object.keys(translations).map((key) => {
    const string2 = translations[key];
    return translated[key] = localize(string2, replacements);
  });
  return translated;
}
const localize = (text, replacements) => {
  let parsedText = text;
  if (replacements) {
    Object.keys(replacements).forEach((key) => {
      parsedText = parsedText.replace(new RegExp(`({{ ${key} }})`, "g"), replacements[key]);
    });
  }
  return replaceMarkdown(parsedText);
};
const replaceMarkdown = (markdownText) => {
  let text = markdownText;
  text = text.split("\n");
  text = text.map((t2, i2) => {
    return jsxs(React$1.Fragment, { children: [wrapTags(t2), i2 < text.length - 1 && jsx("br", {})] }, i2);
  });
  return text;
};
const wrapTags = (text) => {
  const textArray = text.split(/(\*\*[^\*]*\*\*)/g);
  let result = textArray.map((str, i2) => {
    if (/(\*\*.*\*\*)/g.test(str)) {
      return jsx("strong", { children: str.replace(/\*\*/g, "") }, i2);
    }
    return `${str}`;
  });
  return result.map((r2) => {
    if (typeof r2 === "string") {
      return r2.split(/(\[WALLETCONNECTLOGO\])/g).map((s) => {
        if (s === "[WALLETCONNECTLOGO]") {
          return jsx("span", { className: "ck-tt-logo", children: jsx(Logos.WalletConnect, {}) }, s);
        }
        return s;
      });
    }
    return r2;
  });
};
const LOG_LEVEL = {
  debug: 10,
  info: 20,
  warn: 30,
  error: 40,
  none: 100
};
const useIsoLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement !== void 0 ? reactExports.useLayoutEffect : reactExports.useEffect;
const useFitText = ({ logLevel: logLevelOption = "info", maxFontSize = 100, minFontSize = 20, onFinish, onStart, resolution = 5 } = {}) => {
  const logLevel = LOG_LEVEL[logLevelOption];
  const initState = reactExports.useCallback(() => {
    return {
      calcKey: 0,
      fontSize: maxFontSize,
      fontSizePrev: minFontSize,
      fontSizeMax: maxFontSize,
      fontSizeMin: minFontSize
    };
  }, [maxFontSize, minFontSize]);
  const ref = reactExports.useRef(null);
  const innerHtmlPrevRef = reactExports.useRef();
  const isCalculatingRef = reactExports.useRef(false);
  const [state, setState] = reactExports.useState(initState);
  const { calcKey, fontSize, fontSizeMax, fontSizeMin, fontSizePrev } = state;
  let animationFrameId = null;
  const [ro] = reactExports.useState(() => new index$c(() => {
    animationFrameId = window.requestAnimationFrame(() => {
      if (isCalculatingRef.current) {
        return;
      }
      onStart && onStart();
      isCalculatingRef.current = true;
      setState({
        ...initState(),
        calcKey: calcKey + 1
      });
    });
  }));
  reactExports.useEffect(() => {
    if (ref.current) {
      ro.observe(ref.current);
    }
    return () => {
      animationFrameId && window.cancelAnimationFrame(animationFrameId);
      ro.disconnect();
    };
  }, [animationFrameId, ro]);
  const innerHtml = ref.current && ref.current.innerHTML;
  reactExports.useEffect(() => {
    if (calcKey === 0 || isCalculatingRef.current)
      return;
    if (innerHtml !== innerHtmlPrevRef.current) {
      onStart && onStart();
      setState({
        ...initState(),
        calcKey: calcKey + 1
      });
    }
    innerHtmlPrevRef.current = innerHtml;
  }, [calcKey, initState, innerHtml, onStart]);
  useIsoLayoutEffect(() => {
    if (calcKey === 0) {
      return;
    }
    const isWithinResolution = Math.abs(fontSize - fontSizePrev) <= resolution;
    const isOverflow = !!ref.current && (ref.current.scrollHeight > ref.current.offsetHeight || ref.current.scrollWidth > ref.current.offsetWidth);
    const isFailed = isOverflow && fontSize === fontSizePrev;
    const isAsc = fontSize > fontSizePrev;
    if (isWithinResolution) {
      if (isFailed) {
        isCalculatingRef.current = false;
        if (logLevel <= LOG_LEVEL.info) {
          console.info(`[use-fit-text] reached \`minFontSize = ${minFontSize}\` without fitting text`);
        }
      } else if (isOverflow) {
        setState({
          fontSize: isAsc ? fontSizePrev : fontSizeMin,
          fontSizeMax,
          fontSizeMin,
          fontSizePrev,
          calcKey
        });
      } else {
        isCalculatingRef.current = false;
        onFinish && onFinish(fontSize);
      }
      return;
    }
    let delta;
    let newMax = fontSizeMax;
    let newMin = fontSizeMin;
    if (isOverflow) {
      delta = isAsc ? fontSizePrev - fontSize : fontSizeMin - fontSize;
      newMax = Math.min(fontSizeMax, fontSize);
    } else {
      delta = isAsc ? fontSizeMax - fontSize : fontSizePrev - fontSize;
      newMin = Math.max(fontSizeMin, fontSize);
    }
    setState({
      calcKey,
      fontSize: fontSize + delta / 2,
      fontSizeMax: newMax,
      fontSizeMin: newMin,
      fontSizePrev: fontSize
    });
  }, [
    calcKey,
    fontSize,
    fontSizeMax,
    fontSizeMin,
    fontSizePrev,
    onFinish,
    ref,
    resolution
  ]);
  return { fontSize, ref };
};
const FitText = ({ children }) => {
  const [ready, setReady] = React$1.useState(false);
  const { fontSize, ref: textRef } = useFitText({
    logLevel: "none",
    maxFontSize: 100,
    minFontSize: 70,
    onStart: () => setReady(true),
    onFinish: () => setReady(true)
  });
  return jsx("div", { ref: textRef, style: {
    visibility: ready ? "visible" : "hidden",
    fontSize: `${fontSize}%`,
    maxHeight: "100%",
    maxWidth: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  }, children });
};
FitText.displayName = "FitText";
function useConnectors() {
  const { connectors } = useConnect$1();
  return connectors;
}
function useConnector(id2, uuid) {
  const connectors = useConnectors();
  if (id2 === "injected" && uuid) {
    return connectors.find((c2) => c2.id === id2 && c2.name === uuid);
  } else if (id2 === "injected") {
    return connectors.find((c2) => c2.id === id2 && c2.name.includes("Injected"));
  }
  return connectors.find((c2) => c2.id === id2);
}
function useInjectedConnector(uuid) {
  return useConnector("injected", uuid);
}
function useWalletConnectConnector() {
  var _a2;
  return (_a2 = useConnector("walletConnect")) !== null && _a2 !== void 0 ? _a2 : useConnector("walletConnectLegacy");
}
function useCoinbaseWalletConnector() {
  return useConnector("coinbaseWallet");
}
const injected = () => {
  const isInstalled = typeof window !== "undefined" && Boolean(window.ethereum);
  const shouldUseWalletConnect = isMobile() && !isInstalled;
  return {
    id: "injected",
    name: "Browser Wallet",
    shortName: "browser",
    scannable: false,
    icon: jsx(Logos.Injected, {}),
    installed: Boolean(!shouldUseWalletConnect ? isInstalled : false)
  };
};
const walletConnect = () => {
  return {
    id: "walletConnect",
    name: "Other Wallets",
    icon: jsx(Logos.WalletConnect, {}),
    scannable: true,
    createUri: (uri) => uri
  };
};
const metaMask = () => {
  const isInstalled = isMetaMask();
  const shouldUseWalletConnect = isMobile() && !isInstalled;
  return {
    id: "metaMask",
    name: "MetaMask",
    icon: jsx(Logos.MetaMask, { background: true }),
    iconShouldShrink: true,
    scannable: false,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/metamask",
      website: "https://metamask.io/download/",
      android: "https://play.google.com/store/apps/details?id=io.metamask",
      ios: "https://apps.apple.com/app/metamask/id1438144202",
      chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      firefox: "https://addons.mozilla.org/firefox/addon/ether-metamask/",
      brave: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      edge: "https://microsoftedge.microsoft.com/addons/detail/metamask/ejbalbakoplchlghecdalmeeeajnimhm"
    },
    installed: Boolean(!shouldUseWalletConnect ? isInstalled : false),
    createUri: (uri) => {
      return isAndroid() ? uri : `https://metamask.app.link/wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const infinityWallet = () => {
  const isInstalled = isInfinityWallet();
  return {
    id: "infinityWallet",
    name: "Infinity Wallet",
    icon: jsx(Logos.InfinityWallet, {}),
    scannable: false,
    downloadUrls: {
      download: "https://infinitywallet.io/download",
      website: "https://infinitywallet.io/download",
      chrome: "https://infinitywallet.io/download",
      firefox: "https://infinitywallet.io/download",
      brave: "https://infinitywallet.io/download",
      edge: "https://infinitywallet.io/download"
    },
    installed: Boolean(isInstalled)
  };
};
const coinbaseWallet = () => {
  const isInstalled = isCoinbaseWallet();
  const shouldUseWalletConnect = isMobile() && !isInstalled;
  return {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    shortName: "Coinbase",
    icon: jsx(Logos.Coinbase, {}),
    scannable: true,
    installed: Boolean(!shouldUseWalletConnect ? isInstalled : false),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/coinbasewallet",
      website: "https://www.coinbase.com/wallet/getting-started-extension",
      android: "https://play.google.com/store/apps/details?id=org.toshi",
      ios: "https://apps.apple.com/app/coinbase-wallet-store-crypto/id1278383455",
      chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad"
    },
    createUri: (uri) => {
      return `https://go.cb-w.com/wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const rainbow = () => {
  const isInstalled = isRainbow();
  const shouldUseWalletConnect = isMobile() && !isInstalled;
  return {
    id: "rainbow",
    name: "Rainbow",
    icon: jsx(Logos.Rainbow, {}),
    scannable: false,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/rainbow",
      website: "https://rainbow.me/?utm_source=connectkit",
      android: "https://play.google.com/store/apps/details?id=me.rainbow&referrer=utm_source%3Dconnectkit&utm_source=connectkit",
      ios: "https://apps.apple.com/app/rainbow-ethereum-wallet/id1457119021?pt=119997837&ct=connectkit&mt=8",
      chrome: "https://rainbow.me/extension?utm_source=connectkit",
      edge: "https://rainbow.me/extension?utm_source=connectkit",
      brave: "https://rainbow.me/extension?utm_source=connectkit"
    },
    installed: !shouldUseWalletConnect ? isInstalled : void 0,
    createUri: (uri) => {
      return isAndroid() ? uri : `https://rnbwapp.com/wc?uri=${encodeURIComponent(uri)}&connector=connectkit`;
    }
  };
};
const argent = () => {
  return {
    id: "argent",
    name: "Argent",
    icon: jsx(Logos.Argent, {}),
    scannable: false,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/argent",
      android: "https://play.google.com/store/apps/details?id=im.argent.contractwalletclient",
      ios: "https://apps.apple.com/app/argent/id1358741926"
    },
    createUri: (uri) => {
      return isAndroid() ? uri : `https://argent.link/app/wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const trust = () => {
  const isInstalled = isTrust();
  return {
    id: "trust",
    name: "Trust Wallet",
    shortName: "Trust",
    icon: jsx(Logos.Trust, {}),
    scannable: false,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/trust",
      android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
      ios: "https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409"
    },
    installed: isInstalled,
    createUri: (uri) => {
      return isAndroid() ? uri : `https://link.trustwallet.com/wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const ledger = () => {
  return {
    id: "ledger",
    name: "Ledger Live",
    shortName: "Ledger",
    icon: jsx(Logos.Ledger, {}),
    scannable: false,
    downloadUrls: {
      website: "https://www.ledger.com/ledger-live/download#download-device-2",
      download: "https://connect.family.co/v0/download/ledger",
      android: "https://play.google.com/store/apps/details?id=com.ledger.live",
      ios: "https://apps.apple.com/app/ledger-live-web3-wallet/id1361671700"
    },
    createUri: (uri) => {
      return isAndroid() ? uri : `ledgerlive://wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const imToken = () => {
  return {
    id: "imToken",
    name: "imToken",
    icon: jsx(Logos.ImToken, {}),
    scannable: false,
    downloadUrls: {
      //website: 'https://support.token.im/hc/en-us/categories/360000925393',
      download: "https://connect.family.co/v0/download/imToken",
      android: "https://play.google.com/store/apps/details?id=im.token.app",
      ios: "https://itunes.apple.com/us/app/imtoken2/id1384798940"
    },
    createUri: (uri) => {
      return `imtokenv2://wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const brave = () => {
  const isInstalled = isBrave();
  return {
    id: "brave",
    name: "Brave Wallet",
    shortName: "Brave",
    icon: jsx(Logos.Brave, {}),
    scannable: false,
    downloadUrls: {},
    installed: isInstalled,
    createUri: (uri) => uri
  };
};
const steak = () => {
  return {
    id: "steak",
    name: "Steak",
    icon: jsx(Logos.Steak, {}),
    scannable: false,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/steak",
      android: "https://play.google.com/store/apps/details?id=fi.steakwallet.app",
      ios: "https://apps.apple.com/app/steakwallet/id1569375204",
      website: "https://steakwallet.fi/download"
    },
    createUri: (uri) => {
      return isAndroid() ? uri : `https://links.steakwallet.fi/wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const unstoppable = () => {
  return {
    id: "unstoppable",
    name: "Unstoppable",
    icon: jsx(Logos.Unstoppable, {}),
    scannable: false,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/unstoppable",
      ios: "https://apps.apple.com/app/bank-bitcoin-wallet/id1447619907",
      android: "https://play.google.com/store/apps/details?id=io.horizontalsystems.bankwallet"
    },
    createUri: (uri) => {
      return isAndroid() ? uri : `https://unstoppable.money/wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const onto = () => {
  return {
    id: "onto",
    name: "ONTO",
    icon: jsx(Logos.ONTO, {}),
    scannable: false,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/onto",
      ios: "https://apps.apple.com/app/onto-an-ontology-dapp/id1436009823",
      android: "https://play.google.com/store/apps/details?id=com.github.ontio.onto",
      website: "https://onto.app/en/download/"
    },
    createUri: (uri) => {
      return isAndroid() ? uri : `https://onto.app/wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const safe = () => {
  return {
    id: "safe",
    name: "Safe",
    shortName: "Safe",
    icon: jsx(Logos.Safe, {}),
    scannable: false,
    installed: !(typeof window === "undefined") && (window === null || window === void 0 ? void 0 : window.parent) !== window,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/safe",
      ios: "https://apps.apple.com/app/id1515759131",
      android: "https://play.google.com/store/apps/details?id=io.gnosis.safe",
      website: "https://safe.global/"
    },
    createUri: (uri) => {
      return isAndroid() ? uri : `https://gnosis-safe.io/wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const frontier = () => {
  const isInstalled = isFrontier();
  return {
    id: "frontier",
    name: "Frontier Wallet",
    shortName: "Frontier",
    icon: jsx(Logos.Frontier, {}),
    scannable: false,
    installed: isInstalled,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/frontier",
      ios: "https://apps.apple.com/app/frontier-crypto-defi-wallet/id1482380988",
      android: "https://play.google.com/store/apps/details?id=com.frontierwallet",
      website: "https://frontier.xyz/",
      chrome: "https://chrome.google.com/webstore/detail/frontier-wallet/kppfdiipphfccemcignhifpjkapfbihd"
    },
    createUri: (uri) => {
      return isAndroid() ? uri : `frontier://wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const zerion = () => {
  const isInstalled = isZerion();
  return {
    id: "zerion",
    name: "Zerion",
    icon: jsx(Logos.Zerion, {}),
    scannable: false,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/zerion",
      ios: "https://apps.apple.com/app/apple-store/id1456732565",
      android: "https://play.google.com/store/apps/details?id=io.zerion.android",
      website: "https://zerion.io/"
    },
    createUri: (uri) => {
      return isAndroid() ? uri : `https://app.zerion.io/wc?uri=${encodeURIComponent(uri)}`;
    },
    installed: isInstalled
  };
};
const family = () => {
  const isInstalled = isFamily();
  return {
    id: "family",
    name: "Family",
    icon: jsx(Logos.Family, {}),
    iconShape: "squircle",
    installed: Boolean(isInstalled) ? true : void 0,
    scannable: true,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/family",
      ios: "https://family.co/download",
      website: "https://family.co"
    },
    createUri: (uri) => {
      return isAndroid() ? uri : `familywallet://wc?uri=${encodeURIComponent(uri)}`;
    }
  };
};
const frame = () => {
  const isInstalled = isFrame();
  return {
    id: "frame",
    name: "Frame",
    icon: jsx(Logos.Frame, {}),
    iconShouldShrink: true,
    scannable: false,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/frame",
      website: "https://frame.sh",
      chrome: "https://chrome.google.com/webstore/detail/frame-companion/ldcoohedfbjoobcadoglnnmmfbdlmmhf",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/frame-extension",
      brave: "https://chrome.google.com/webstore/detail/frame-companion/ldcoohedfbjoobcadoglnnmmfbdlmmhf"
    },
    installed: isInstalled,
    createUri: (uri) => uri
  };
};
const phantom = () => {
  const isInstalled = isPhantom();
  return {
    id: "phantom",
    name: "Phantom",
    shortName: "Phantom",
    scannable: false,
    icon: jsx(Logos.Phantom, { background: true }),
    installed: Boolean(isInstalled)
  };
};
const dawn = () => {
  const isInstalled = isDawn();
  return {
    id: "dawn",
    name: "Dawn Wallet",
    shortName: "Dawn",
    icon: jsx(Logos.Dawn, {}),
    scannable: false,
    installed: Boolean(isInstalled),
    downloadUrls: {
      download: "https://apps.apple.com/us/app/dawn-ethereum-wallet/id1673143782",
      website: "https://www.dawnwallet.xyz/",
      ios: "https://apps.apple.com/us/app/dawn-ethereum-wallet/id1673143782"
    }
  };
};
const rabby = () => {
  const isInstalled = isRabby();
  return {
    id: "rabby",
    name: "Rabby Wallet",
    icon: jsx(Logos.Rabby, {}),
    scannable: false,
    downloadUrls: {
      website: "https://rabby.io",
      chrome: "https://chrome.google.com/webstore/detail/rabby-wallet/acmacodkjbdgmoleebolmdjonilkdbch"
    },
    installed: isInstalled
  };
};
const fordefi = () => {
  const isInstalled = isFordefi();
  return {
    id: "fordefi",
    name: "Fordefi",
    icon: jsx(Logos.Fordefi, {}),
    scannable: false,
    downloadUrls: {},
    installed: isInstalled
  };
};
const tokenPocket = () => {
  const isInstalled = isTokenPocket();
  return {
    id: "tokenPocket",
    name: "TokenPocket Wallet",
    icon: jsx(Logos.TokenPocket, {}),
    scannable: false,
    downloadUrls: {
      website: "https://www.tokenpocket.pro/en/download/app",
      download: "https://www.tokenpocket.pro/en/download/app",
      android: "https://play.google.com/store/apps/details?id=vip.mytokenpocket",
      ios: "https://apps.apple.com/us/app/tp-global-wallet/id6444625622",
      chrome: "https://chrome.google.com/webstore/detail/tokenpocket/mfgccjchihfkkindfppnaooecgfneiii"
    },
    installed: isInstalled
  };
};
const talisman = () => {
  const isInstalled = isTalisman();
  return {
    id: "talisman",
    name: "Talisman",
    shortName: "Talisman",
    scannable: false,
    icon: jsx(Logos.Talisman, {}),
    downloadUrls: {
      download: "https://talisman.xyz/download",
      website: "https://talisman.xyz",
      chrome: "https://chrome.google.com/webstore/detail/talisman-polkadot-wallet/fijngjgcjhjmmpcmkeiomlglpeiijkld",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/talisman-wallet-extension/"
    },
    installed: isInstalled
  };
};
const getWallets = () => {
  return [
    injected(),
    walletConnect(),
    metaMask(),
    infinityWallet(),
    coinbaseWallet(),
    argent(),
    trust(),
    ledger(),
    family(),
    imToken(),
    unstoppable(),
    onto(),
    steak(),
    frontier(),
    zerion(),
    //slope(),
    // injected
    brave(),
    safe(),
    frame(),
    rainbow(),
    phantom(),
    dawn(),
    rabby(),
    fordefi(),
    tokenPocket(),
    talisman()
  ];
};
function useLegacyWallets() {
  const { connectors } = useConnect$1();
  let legacyWallets = [];
  if (!connectors.find((c2) => c2.id === "metaMask"))
    legacyWallets.push("metaMask");
  if (!connectors.find((c2) => c2.id === "coinbaseWallet"))
    legacyWallets.push("coinbaseWallet");
  legacyWallets.push(
    "argent",
    "trust",
    "ledger",
    "infinityWallet",
    "family",
    "imToken",
    "rainbow",
    "unstoppable",
    "onto",
    "steak",
    "frontier",
    "zerion",
    "safe",
    "brave",
    //'slope',
    "frame",
    "phantom",
    "dawn",
    "rabby",
    "talisman",
    "fordefi",
    "tokenPocket"
  );
  const wallets = getWallets();
  return wallets.filter((wallet2) => legacyWallets.includes(wallet2.id));
}
const getInjectedNames = (connector) => {
  if (!connector)
    return [];
  let names2 = connector.name.split(/[(),]+/);
  names2.shift();
  names2 = names2.map((x2) => x2.trim()).filter((x2) => x2 !== "").filter((x2) => x2 !== "Injected");
  return names2;
};
const useInjectedWallet = () => {
  const wallets = useWallets();
  const injectedWallets = useLegacyWallets();
  const connector = useInjectedConnector();
  const shouldShow = () => {
    if (!(typeof window !== "undefined" && (window === null || window === void 0 ? void 0 : window.ethereum)))
      return false;
    const names2 = getInjectedNames(connector);
    if (names2.length === 1 && (names2[0] === "MetaMask" || names2[0] === "Coinbase Wallet")) {
      return false;
    }
    if (names2.length === 2 && names2.includes("MetaMask") && names2.includes("Coinbase Wallet")) {
      return false;
    }
    return true;
  };
  const getWallet = () => {
    var _a2, _b, _c, _d, _e2;
    const installedLegacyWallets = injectedWallets.filter((wallet3) => wallet3.installed);
    if (installedLegacyWallets.length > 0) {
      const installedWallets = wallets.filter((wallet3) => wallet3.id !== installedLegacyWallets[0].id);
      const filteredWallets = installedLegacyWallets.filter((wallet3) => !installedWallets.find((w2) => w2.name === wallet3.name));
      if (filteredWallets.length > 0)
        return filteredWallets[0];
    }
    return {
      id: "injected",
      name: (_b = (_a2 = getInjectedNames(connector)) === null || _a2 === void 0 ? void 0 : _a2[0]) !== null && _b !== void 0 ? _b : "Browser Wallet",
      shortName: (_e2 = (_d = (_c = getInjectedNames(connector)) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.replace(" Wallet", "")) !== null && _e2 !== void 0 ? _e2 : "Browser",
      icon: jsx(Logos.Injected, {})
    };
  };
  const wallet2 = getWallet();
  return {
    wallet: wallet2,
    enabled: shouldShow() && wallet2 !== null
  };
};
const walletConfigs = {
  argent: {
    downloadUrls: {
      download: "https://connect.family.co/v0/download/argent",
      android: "https://play.google.com/store/apps/details?id=im.argent.contractwalletclient",
      ios: "https://apps.apple.com/app/argent/id1358741926"
    }
  },
  coinbaseWallet: {
    rdns: "com.coinbase.wallet",
    name: "Coinbase Wallet",
    shortName: "Coinbase",
    icon: jsx(Logos.Coinbase, { background: true }),
    iconShape: "squircle",
    downloadUrls: {
      download: "https://connect.family.co/v0/download/coinbasewallet",
      website: "https://www.coinbase.com/wallet/getting-started-extension",
      android: "https://play.google.com/store/apps/details?id=org.toshi",
      ios: "https://apps.apple.com/app/coinbase-wallet-store-crypto/id1278383455",
      chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad"
    }
  },
  crypto: {
    rdns: "com.crypto.wallet",
    name: "Crypto.com",
    shortName: "Crypto"
  },
  dawn: {
    downloadUrls: {
      download: "https://apps.apple.com/us/app/dawn-ethereum-wallet/id1673143782",
      website: "https://www.dawnwallet.xyz/",
      ios: "https://apps.apple.com/us/app/dawn-ethereum-wallet/id1673143782"
    }
  },
  family: {
    rdns: "co.family.wallet",
    name: "Family",
    shortName: "Family",
    iconShape: "squircle",
    downloadUrls: {
      download: "https://connect.family.co/v0/download/family",
      website: "https://family.co",
      ios: "https://family.co/download"
    }
  },
  frame: {
    name: "Frame",
    icon: jsx(Logos.Frame, {}),
    iconShouldShrink: true,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/frame",
      website: "https://frame.sh",
      chrome: "https://chrome.google.com/webstore/detail/frame-companion/ldcoohedfbjoobcadoglnnmmfbdlmmhf",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/frame-extension",
      brave: "https://chrome.google.com/webstore/detail/frame-companion/ldcoohedfbjoobcadoglnnmmfbdlmmhf"
    }
  },
  frontier: {
    name: "Frontier Wallet",
    shortName: "Frontier",
    downloadUrls: {
      download: "https://connect.family.co/v0/download/frontier",
      ios: "https://apps.apple.com/app/frontier-crypto-defi-wallet/id1482380988",
      android: "https://play.google.com/store/apps/details?id=com.frontierwallet",
      website: "https://frontier.xyz/",
      chrome: "https://chrome.google.com/webstore/detail/frontier-wallet/kppfdiipphfccemcignhifpjkapfbihd"
    }
  },
  injected: {
    name: "Browser Wallet",
    shortName: "Browser",
    icon: jsx(Logos.Injected, {})
  },
  metaMask: {
    rdns: "io.metamask",
    name: "MetaMask",
    icon: jsx(Logos.MetaMask, {}),
    iconConnector: jsx(Logos.MetaMask, {}),
    iconShouldShrink: true,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/metamask",
      website: "https://metamask.io/download/",
      android: "https://play.google.com/store/apps/details?id=io.metamask",
      ios: "https://apps.apple.com/app/metamask/id1438144202",
      chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/ether-metamask/",
      brave: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      edge: "https://microsoftedge.microsoft.com/addons/detail/metamask/ejbalbakoplchlghecdalmeeeajnimhm"
    }
  },
  phantom: {
    rdns: "app.phantom",
    name: "Phantom",
    iconShape: "squircle"
  },
  rainbow: {
    rdns: "me.rainbow",
    name: "Rainbow Wallet",
    shortName: "Rainbow",
    iconShape: "squircle",
    downloadUrls: {
      download: "https://connect.family.co/v0/download/rainbow",
      website: "https://rainbow.me/?utm_source=connectkit",
      android: "https://play.google.com/store/apps/details?id=me.rainbow&referrer=utm_source%3Dconnectkit&utm_source=connectkit",
      ios: "https://apps.apple.com/app/rainbow-ethereum-wallet/id1457119021?pt=119997837&ct=connectkit&mt=8",
      chrome: "https://rainbow.me/extension?utm_source=connectkit",
      edge: "https://rainbow.me/extension?utm_source=connectkit",
      brave: "https://rainbow.me/extension?utm_source=connectkit"
    }
  },
  rabby: {
    rdns: "io.rabby",
    name: "Rabby Wallet",
    shortName: "Rabby",
    downloadUrls: {
      website: "https://rabby.io",
      chrome: "https://chrome.google.com/webstore/detail/rabby-wallet/acmacodkjbdgmoleebolmdjonilkdbch"
    }
  },
  safe: {
    name: "Safe",
    icon: jsx(Logos.Safe, {}),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/safe",
      website: "https://safe.global/wallet",
      android: "https://play.google.com/store/apps/details?id=io.gnosis.safe",
      ios: "https://apps.apple.com/app/id1515759131"
    }
  },
  talisman: {
    rdns: "xyz.talisman",
    name: "Talisman",
    shortName: "Talisman",
    iconShape: "squircle",
    downloadUrls: {
      download: "https://talisman.xyz/download",
      website: "https://talisman.xyz",
      chrome: "https://chrome.google.com/webstore/detail/talisman-polkadot-wallet/fijngjgcjhjmmpcmkeiomlglpeiijkld",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/talisman-wallet-extension/"
    }
  },
  trustWallet: {
    rdns: "com.trustwallet.app",
    name: "Trust Wallet",
    shortName: "Trust",
    iconShouldShrink: true,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/trust",
      android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
      ios: "https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409"
    }
  },
  walletConnect: {
    name: "Other Wallets",
    shortName: "Other",
    icon: jsx(Logos.WalletConnect, { background: true }),
    iconConnector: jsx(Logos.OtherWallets, {})
  },
  walletConnectLegacy: {
    name: "Other Wallets",
    shortName: "Other",
    icon: jsx(Logos.WalletConnectLegacy, { background: true }),
    iconConnector: jsx(Logos.OtherWallets, {})
  }
};
const mipd = createMipd();
const useWallet = (id2, name2) => {
  const wallets = useWallets();
  const wallet2 = wallets.find((c2) => c2.id === id2 && (id2 === "injected" ? c2.name === name2 : true));
  if (!wallet2)
    return null;
  return wallet2;
};
const compareWallets = (wallet_a, wallet_b) => {
  var _a2, _b, _c, _d;
  const a2 = {
    name: (_a2 = wallet_a.name) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase().replace(" wallet", "").split(", ")[0],
    shortName: (_b = wallet_a.shortName) === null || _b === void 0 ? void 0 : _b.toLowerCase().replace(" wallet", "")
  };
  const b2 = {
    name: (_c = wallet_b.name) === null || _c === void 0 ? void 0 : _c.toLowerCase().replace(" wallet", "").split(", ")[0],
    shortName: (_d = wallet_b.shortName) === null || _d === void 0 ? void 0 : _d.toLowerCase().replace(" wallet", "")
  };
  return a2.name === b2.name || a2.name === b2.shortName || a2.shortName === b2.name;
};
const useWallets = () => {
  const connectors = useConnectors();
  const locales = useLocales();
  const context = useContext();
  const injectedConnector = useInjectedConnector();
  const wallets = connectors.map((c2) => {
    if (c2.id === "injected") {
      const mipdConnector = mipd === null || mipd === void 0 ? void 0 : mipd.findConnectorByUUID(c2.name);
      if (mipdConnector) {
        return {
          id: mipdConnector.uuid,
          rdns: mipdConnector.rdns,
          name: mipdConnector.name,
          icon: jsx("img", { src: mipdConnector.icon, alt: mipdConnector.name }),
          connector: c2,
          isInstalled: true
        };
      }
    }
    const wallet2 = getWallets().find((w2) => w2.id === c2.id);
    if (wallet2) {
      if (wallet2.id === "injected") {
        const names2 = getInjectedNames(c2);
        return {
          id: wallet2.id,
          name: names2 ? names2.join(", ") : injectedConnector.name,
          icon: wallet2.icon,
          connector: c2,
          isInstalled: wallet2.installed,
          createUri: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.createUri
        };
      }
      return {
        id: wallet2.id,
        name: wallet2.name,
        icon: wallet2.icon,
        connector: c2,
        isInstalled: wallet2.installed,
        createUri: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.createUri
      };
    }
    return {
      id: c2.id,
      name: c2.name,
      icon: jsx("img", { src: "#", alt: "" }),
      connector: c2
    };
  });
  const filtered = [];
  wallets.forEach((wallet2, i2) => {
    if (filtered.find((w2) => w2.id === wallet2.id))
      return;
    if (wallet2.name === "")
      return;
    const duplicates = wallets.filter((wallet_b, j2) => i2 !== j2 && compareWallets(wallet2, wallet_b));
    if (!duplicates.length) {
      filtered.push(wallet2);
    } else if (wallet2.rdns) {
      filtered.push(wallet2);
    } else if (duplicates.filter((d2) => d2.rdns).length === 0) {
      filtered.push(wallet2);
    } else
      ;
  });
  return filtered.map((w2) => {
    var _a2, _b;
    if (w2.rdns) {
      const override = Object.values(walletConfigs).find(({ rdns }) => rdns === w2.rdns);
      if (override) {
        w2 = { ...w2, ...override };
      }
    } else {
      const override = walletConfigs[w2.id];
      if (override) {
        if (w2.id === "injected") {
          w2 = { ...override, ...w2 };
        } else {
          w2 = { ...w2, ...override };
        }
      }
    }
    if (isWalletConnectConnector(w2.connector.id)) {
      w2.name = (_b = (_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.walletConnectName) !== null && _b !== void 0 ? _b : locales.otherWallets;
    }
    return w2;
  });
};
const ProfileIcon = ({ isSignedIn }) => jsxs("div", { style: { position: "relative" }, children: [isSignedIn ? jsx(AuthIcon, { style: {
  bottom: -1,
  right: -1
} }) : jsx("div", { style: {
  zIndex: 2,
  position: "absolute",
  top: -2,
  right: -2,
  background: "#1A88F8",
  borderRadius: 8,
  boxShadow: "0 0 0 2px var(--ck-body-background)",
  width: 8,
  height: 8
} }), jsxs("svg", { "aria-hidden": "true", width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { overflow: "visible" }, children: [jsx("circle", { cx: "10", cy: "10", r: "9", stroke: "currentColor", strokeWidth: "2" }), jsx("path", { d: "M16.5 16.775C14.8618 15.0649 12.5552 14 10 14C7.44477 14 5.13825 15.0649 3.5 16.775", stroke: "currentColor", strokeWidth: "2" }), jsx("circle", { cx: "10", cy: "8", r: "3", stroke: "currentColor", strokeWidth: "2" })] })] });
const InfoIcon = ({ ...props }) => jsx("svg", { "aria-hidden": "true", width: "22", height: "22", viewBox: "0 0 22 22", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20 11C20 15.9706 15.9706 20 11 20C6.02944 20 2 15.9706 2 11C2 6.02944 6.02944 2 11 2C15.9706 2 20 6.02944 20 11ZM22 11C22 17.0751 17.0751 22 11 22C4.92487 22 0 17.0751 0 11C0 4.92487 4.92487 0 11 0C17.0751 0 22 4.92487 22 11ZM11.6445 12.7051C11.6445 13.1348 11.3223 13.4678 10.7744 13.4678C10.2266 13.4678 9.92578 13.1885 9.92578 12.6191V12.4795C9.92578 11.4268 10.4951 10.8574 11.2686 10.3203C12.2031 9.67578 12.665 9.32129 12.665 8.59082C12.665 7.76367 12.0205 7.21582 11.043 7.21582C10.3232 7.21582 9.80762 7.57031 9.45312 8.16113C9.38282 8.24242 9.32286 8.32101 9.2667 8.39461C9.04826 8.68087 8.88747 8.8916 8.40039 8.8916C8.0459 8.8916 7.66992 8.62305 7.66992 8.15039C7.66992 7.96777 7.70215 7.7959 7.75586 7.61328C8.05664 6.625 9.27051 5.75488 11.1182 5.75488C12.9336 5.75488 14.5234 6.71094 14.5234 8.50488C14.5234 9.7832 13.7822 10.417 12.7402 11.1045C11.999 11.5986 11.6445 11.9746 11.6445 12.5762V12.7051ZM11.9131 15.5625C11.9131 16.1855 11.376 16.6797 10.7529 16.6797C10.1299 16.6797 9.59277 16.1748 9.59277 15.5625C9.59277 14.9395 10.1191 14.4453 10.7529 14.4453C11.3867 14.4453 11.9131 14.9287 11.9131 15.5625Z", fill: "currentColor" }) });
const CloseIcon = ({ ...props }) => jsx(motion.svg, { width: 14, height: 14, viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: jsx("path", { d: "M1 13L13 1M1 1L13 13", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round" }) });
const BackIcon = ({ ...props }) => jsx(motion.svg, { width: 9, height: 16, viewBox: "0 0 9 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: jsx("path", { d: "M8 1L1 8L8 15", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }) });
const contentTransitionDuration = 0.22;
const contentVariants$2 = {
  initial: {
    //willChange: 'transform,opacity',
    zIndex: 2,
    opacity: 0
  },
  animate: {
    opacity: 1,
    scale: 1,
    transition: {
      duration: contentTransitionDuration * 0.75,
      delay: contentTransitionDuration * 0.25,
      ease: [0.26, 0.08, 0.25, 1]
    }
  },
  exit: {
    zIndex: 1,
    opacity: 0,
    pointerEvents: "none",
    position: "absolute",
    left: ["50%", "50%"],
    x: ["-50%", "-50%"],
    transition: {
      duration: contentTransitionDuration,
      ease: [0.26, 0.08, 0.25, 1]
    }
  }
};
const Modal = ({ open, pages, pageId, positionInside, inline, demo, onClose, onBack, onInfo }) => {
  var _a2, _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2, _u;
  const context = useContext();
  const themeContext = useThemeContext();
  const mobile = isMobile();
  const { isSignedIn, reset: reset3 } = useSIWE();
  const wallet2 = useWallet((_a2 = context.connector) === null || _a2 === void 0 ? void 0 : _a2.id, (_b = context === null || context === void 0 ? void 0 : context.connector) === null || _b === void 0 ? void 0 : _b.name);
  const injectedWallet = useInjectedWallet();
  const walletInfo = isInjectedConnector(wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.id) && injectedWallet.enabled ? {
    name: injectedWallet.wallet.name,
    shortName: (_d = (_c = injectedWallet.wallet) === null || _c === void 0 ? void 0 : _c.shortName) !== null && _d !== void 0 ? _d : injectedWallet.wallet.name,
    icon: (_e2 = injectedWallet.wallet) === null || _e2 === void 0 ? void 0 : _e2.icon,
    iconShape: (_g = (_f = injectedWallet.wallet) === null || _f === void 0 ? void 0 : _f.iconShape) !== null && _g !== void 0 ? _g : "circle",
    iconShouldShrink: (_h = injectedWallet.wallet) === null || _h === void 0 ? void 0 : _h.iconShouldShrink
  } : {
    name: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.name,
    shortName: (_j = wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.shortName) !== null && _j !== void 0 ? _j : wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.name,
    icon: (_k = wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.iconConnector) !== null && _k !== void 0 ? _k : wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.icon,
    iconShape: (_l = wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.iconShape) !== null && _l !== void 0 ? _l : "circle",
    iconShouldShrink: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.iconShouldShrink
  };
  const locales = useLocales({
    CONNECTORNAME: walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name
  });
  const [state, setOpen] = useTransition({
    timeout: mobile ? 160 : 160,
    preEnter: true,
    mountOnEnter: true,
    unmountOnExit: true
  });
  const mounted = !(state === "exited" || state === "unmounted");
  const rendered = state === "preEnter" || state !== "exiting";
  const currentDepth = context.route === routes.CONNECTORS ? 0 : context.route === routes.DOWNLOAD ? 2 : 1;
  const prevDepth = usePrevious(currentDepth, currentDepth);
  if (!positionInside)
    useLockBodyScroll(mounted);
  usePrevious(pageId, pageId);
  reactExports.useEffect(() => {
    setOpen(open);
    if (open)
      setInTransition(void 0);
  }, [open]);
  const [dimensions, setDimensions] = reactExports.useState({
    width: void 0,
    height: void 0
  });
  const [inTransition, setInTransition] = reactExports.useState(void 0);
  const updateBounds = (node2) => {
    const bounds = {
      width: node2 === null || node2 === void 0 ? void 0 : node2.offsetWidth,
      height: node2 === null || node2 === void 0 ? void 0 : node2.offsetHeight
    };
    setDimensions({
      width: `${bounds === null || bounds === void 0 ? void 0 : bounds.width}px`,
      height: `${bounds === null || bounds === void 0 ? void 0 : bounds.height}px`
    });
  };
  let blockTimeout;
  const contentRef = reactExports.useCallback((node2) => {
    if (!node2)
      return;
    ref.current = node2;
    setInTransition(inTransition === void 0 ? false : true);
    clearTimeout(blockTimeout);
    blockTimeout = setTimeout(() => setInTransition(false), 360);
    updateBounds(node2);
  }, [open, inTransition]);
  const { chain: chain2 } = useNetwork();
  const { switchNetwork: switchNetwork2 } = useSwitchNetwork();
  const ref = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (ref.current)
      updateBounds(ref.current);
  }, [
    chain2,
    switchNetwork2,
    mobile,
    isSignedIn,
    context.options,
    context.resize
  ]);
  reactExports.useEffect(() => {
    if (!mounted) {
      setDimensions({
        width: void 0,
        height: void 0
      });
      return;
    }
    const listener = (e2) => {
      if (e2.key === "Escape" && onClose)
        onClose();
    };
    document.addEventListener("keydown", listener);
    return () => {
      document.removeEventListener("keydown", listener);
    };
  }, [mounted, onClose]);
  const dimensionsCSS = {
    "--height": dimensions.height,
    "--width": dimensions.width
  };
  function shouldUseQrcode() {
    if (!wallet2)
      return false;
    const useInjector = !wallet2.createUri || wallet2.isInstalled;
    return !useInjector;
  }
  function getHeading() {
    var _a3;
    switch (context.route) {
      case routes.ABOUT:
        return locales.aboutScreen_heading;
      case routes.CONNECT:
        if (shouldUseQrcode()) {
          return isWalletConnectConnector((_a3 = wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.connector) === null || _a3 === void 0 ? void 0 : _a3.id) ? locales.scanScreen_heading : locales.scanScreen_heading_withConnector;
        } else {
          return walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name;
        }
      case routes.CONNECTORS:
        return locales.connectorsScreen_heading;
      case routes.MOBILECONNECTORS:
        return locales.mobileConnectorsScreen_heading;
      case routes.DOWNLOAD:
        return locales.downloadAppScreen_heading;
      case routes.ONBOARDING:
        return locales.onboardingScreen_heading;
      case routes.PROFILE:
        return locales.profileScreen_heading;
      case routes.SWITCHNETWORKS:
        return locales.switchNetworkScreen_heading;
      case routes.SIGNINWITHETHEREUM:
        return isSignedIn ? locales.signInWithEthereumScreen_signedIn_heading : locales.signInWithEthereumScreen_signedOut_heading;
      default:
        return "";
    }
  }
  const Content2 = jsx(ResetContainer, { "$useTheme": (_m = demo === null || demo === void 0 ? void 0 : demo.theme) !== null && _m !== void 0 ? _m : themeContext.theme, "$useMode": (_o = demo === null || demo === void 0 ? void 0 : demo.mode) !== null && _o !== void 0 ? _o : themeContext.mode, "$customTheme": (_p = demo === null || demo === void 0 ? void 0 : demo.customTheme) !== null && _p !== void 0 ? _p : themeContext.customTheme, children: jsxs(ModalContainer, { role: "dialog", style: {
    pointerEvents: rendered ? "auto" : "none",
    position: positionInside ? "absolute" : void 0
  }, children: [!inline && jsx(BackgroundOverlay, { "$active": rendered, onClick: onClose, "$blur": (_q = context.options) === null || _q === void 0 ? void 0 : _q.overlayBlur }), jsxs(Container$7, { style: dimensionsCSS, initial: false, children: [jsx("div", { style: {
    pointerEvents: inTransition ? "all" : "none",
    position: "absolute",
    top: 0,
    bottom: 0,
    left: "50%",
    transform: "translateX(-50%)",
    width: "var(--width)",
    zIndex: 9,
    transition: "width 200ms ease"
  } }), jsxs(BoxContainer, { className: `${rendered && "active"}`, children: [jsx(AnimatePresence, { initial: false, children: ((_r = context.options) === null || _r === void 0 ? void 0 : _r.disclaimer) && context.route === routes.CONNECTORS && jsx(DisclaimerBackground, { initial: {
    opacity: 0
  }, animate: {
    opacity: 1
  }, exit: { opacity: 0 }, transition: {
    delay: 0,
    duration: 0.2,
    ease: [0.25, 0.1, 0.25, 1]
  }, children: jsx(Disclaimer, { children: jsx("div", { children: (_s = context.options) === null || _s === void 0 ? void 0 : _s.disclaimer }) }) }) }), jsx(AnimatePresence, { initial: false, children: context.errorMessage && jsxs(ErrorMessage, { initial: { y: "10%", x: "-50%" }, animate: { y: "-100%" }, exit: { y: "100%" }, transition: { duration: 0.2, ease: "easeInOut" }, children: [jsx("span", { children: context.errorMessage }), jsx("div", { onClick: () => context.displayError(null), style: {
    position: "absolute",
    right: 24,
    top: 24,
    cursor: "pointer"
  }, children: jsx(CloseIcon, {}) })] }) }), jsxs(ControllerContainer, { children: [onClose && jsx(CloseButton, { "aria-label": flattenChildren(locales.close).toString(), onClick: onClose, children: jsx(CloseIcon, {}) }), jsx("div", { style: {
    position: "absolute",
    top: 23,
    left: 20,
    width: 32,
    height: 32
  }, children: jsx(AnimatePresence, { children: onBack ? jsx(BackButton, { disabled: inTransition, "aria-label": flattenChildren(locales.back).toString(), onClick: onBack, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
    duration: mobile ? 0 : 0.1,
    delay: mobile ? 0.01 : 0
  }, children: jsx(BackIcon, {}) }, "backButton") : context.route === routes.PROFILE && context.signInWithEthereum ? jsxs(Fragment$2, { children: [!isSignedIn && !((_t2 = context.options) === null || _t2 === void 0 ? void 0 : _t2.hideTooltips) && jsx(motion.div, { style: {
    position: "absolute",
    inset: 0,
    pointerEvents: "none"
  }, initial: { opacity: 0, scale: 0.8 }, animate: {
    opacity: 1,
    scale: 1,
    transition: { delay: 0.5, duration: 0.2 }
  }, exit: {
    opacity: 0,
    scale: 0.6,
    transition: {
      delay: 0,
      duration: mobile ? 0 : 0.1
    }
  }, children: jsx(SignInTooltip, { children: locales.signInWithEthereumScreen_tooltip }) }), jsx(SiweButton, { disabled: inTransition, "aria-label": locales.signInWithEthereumScreen_signedOut_heading, onClick: () => {
    reset3();
    context.setRoute(routes.SIGNINWITHETHEREUM);
  }, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
    duration: mobile ? 0 : 0.1,
    delay: mobile ? 0.01 : 0
  }, children: jsx(ProfileIcon, { isSignedIn }) }, "siweButton")] }) : onInfo && !((_u = context.options) === null || _u === void 0 ? void 0 : _u.hideQuestionMarkCTA) && jsx(InfoButton, { disabled: inTransition, "aria-label": flattenChildren(locales.moreInformation).toString(), onClick: onInfo, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
    duration: mobile ? 0 : 0.1,
    delay: mobile ? 0.01 : 0
  }, children: jsx(InfoIcon, {}) }, "infoButton") }) })] }), jsx(ModalHeading, { children: jsx(AnimatePresence, { children: jsx(motion.div, { style: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 52,
    right: 52,
    display: "flex",
    //alignItems: 'center',
    justifyContent: "center"
  }, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
    duration: mobile ? 0 : 0.17,
    delay: mobile ? 0.01 : 0
  }, children: jsx(FitText, { children: getHeading() }) }, `${context.route}-${isSignedIn ? "signedIn" : ""}`) }) }), jsx(InnerContainer$1, { children: Object.keys(pages).map((key) => {
    const page = pages[key];
    return (
      // TODO: We may need to use the follow check avoid unnecessary computations, but this causes a bug where the content flashes
      // (key === pageId || key === prevPage) && (
      jsx(Page, { open: key === pageId, initial: !positionInside && state !== "entered", enterAnim: key === pageId ? currentDepth > prevDepth ? "active-scale-up" : "active" : "", exitAnim: key !== pageId ? currentDepth < prevDepth ? "exit-scale-down" : "exit" : "", children: jsx(PageContents, { ref: contentRef, style: {
        pointerEvents: key === pageId && rendered ? "auto" : "none"
      }, children: page }, `inner-${key}`) }, key)
    );
  }) })] })] })] }) });
  return jsx(Fragment$2, { children: mounted && jsx(Fragment$2, { children: positionInside ? Content2 : jsx(Fragment$2, { children: jsx(Portal, { children: jsx(FocusTrap, { children: Content2 }) }) }) }) });
};
const Page = ({ children, open, initial, prevDepth, currentDepth, enterAnim, exitAnim }) => {
  const [state, setOpen] = useTransition({
    timeout: 400,
    preEnter: true,
    initialEntered: open,
    mountOnEnter: true,
    unmountOnExit: true
  });
  const mounted = !(state === "exited" || state === "unmounted");
  const rendered = state === "preEnter" || state !== "exiting";
  reactExports.useEffect(() => {
    setOpen(open);
  }, [open]);
  if (!mounted)
    return null;
  return jsx(PageContainer, { className: `${rendered ? enterAnim : exitAnim}`, style: {
    animationDuration: initial ? "0ms" : void 0,
    animationDelay: initial ? "0ms" : void 0
  }, children });
};
const OrDivider = ({ children }) => {
  const locales = useLocales();
  return jsx(TextWithHr, { children: jsx("span", { children: children !== null && children !== void 0 ? children : locales.or }) });
};
const Graphic = styled(motion.div)`
  position: relative;
  margin: 16px auto 20px;
  height: 190px;
  max-width: 295px;
  pointer-events: none;
  user-select: none;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    height: 200px;
    max-width: 100%;
    margin-bottom: 32px;
  }
`;
const LogoGroup = styled(motion.div)`
  position: absolute;
  inset: 0;
  z-index: 2;
`;
const graphicIn = We`
  0%{
    opacity:0;
    transform:scale(0.9);
  }
  100%{
    opacity:1;
    transform:none;
  }
`;
const GraphicBackground = styled(motion.div)`
  z-index: 1;
  position: absolute;
  inset: 0;
  top: -2px;
  overflow: hidden;
  &:before {
    content: '';
    position: absolute;
    inset: 0;
    background: var(--ck-body-background);
    background: radial-gradient(
      closest-side,
      var(--ck-body-background-transparent, transparent) 18.75%,
      var(--ck-body-background) 100%
    );
    background-size: 100%;
  }
  svg {
    display: block;
    width: 100%;
    height: auto;
  }
  animation: ${graphicIn} 1000ms 100ms ease both;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    animation: none;
  }
`;
const logoIn = We`
  0%{
    opacity:0;
    transform:scale(0) translateY(40%);
  }
  100%{
    opacity:1;
    transform:none;
  }
`;
const LogoPosition = styled(motion.div)`
  position: absolute;
  inset: 0;
  animation: cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite both;
  animation-delay: inherit;
`;
const LogoInner = styled(motion.div)`
  position: absolute;
`;
const LogoGraphic = styled(motion.div)`
  position: relative;
  overflow: hidden;
  height: 58px;
  width: 58px;
  border-radius: 13.84px;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.05), 0 2px 20px 0 rgba(0, 0, 0, 0.03);

  svg {
    display: block;
    width: 100%;
    height: 100%;
  }
`;
const float$2 = We`
  0%,100%{ transform:none; }
  50%{ transform: translateY(-10%) }
`;
const FloatWrapper = styled(motion.div)`
  position: relative;
  animation: cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite both;
  animation-name: ${float$2};
  animation-duration: 3600ms;
`;
const rotate = We`
  0%,100%{ transform:rotate(-3deg); }
  50%{ transform:rotate(3deg); }
`;
const RotateWrapper = styled(motion.div)`
  position: relative;
  animation: cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite both;
  animation-name: ${rotate};
  animation-duration: 3200ms;
`;
const Logo$2 = styled(motion.div)`
  position: absolute;
  inset: 0;

  animation: ${logoIn} 750ms cubic-bezier(0.19, 1, 0.22, 1) both;
  &:nth-child(1){ z-index:2; animation-delay:0ms;  }
  &:nth-child(2){ z-index:1; animation-delay:60ms; }
  &:nth-child(3){ z-index:1; animation-delay:30ms; }
  &:nth-child(4){ z-index:1; animation-delay:90ms; }
  &:nth-child(5){ z-index:1; animation-delay:120ms;}

  &:nth-child(1){ ${RotateWrapper}{ animation-delay:0ms; } }
  &:nth-child(2){ ${RotateWrapper}{ animation-delay:-600ms; } }
  &:nth-child(3){ ${RotateWrapper}{ animation-delay:-1200ms; } }
  &:nth-child(4){ ${RotateWrapper}{ animation-delay:-1800ms; } }
  &:nth-child(5){ ${RotateWrapper}{ animation-delay:-2400ms; } }

  &:nth-child(1){ ${FloatWrapper}{ animation-delay:-200ms; } }
  &:nth-child(2){ ${FloatWrapper}{ animation-delay:-600ms; } }
  &:nth-child(3){ ${FloatWrapper}{ animation-delay:-800ms; } }
  &:nth-child(4){ ${FloatWrapper}{ animation-delay:-300ms; } }
  &:nth-child(5){ ${FloatWrapper}{ animation-delay:-3200ms; } }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    animation: none !important;
    ${RotateWrapper},${FloatWrapper} {
      animation: none !important;
    }
  }

  ${LogoInner} {
    transform: translate(-50%, -50%);
  }

  &:nth-child(1) ${LogoPosition} {
    transform: translate(50%, 50%);
    ${LogoGraphic} {
      border-radius: 17.2px;
      width: 72px;
      height: 72px;
    }
  }
  &:nth-child(2) ${LogoPosition} {
    transform: translate(21%, 21.5%);
  }
  &:nth-child(3) ${LogoPosition} {
    transform: translate(78%, 14%);
  }
  &:nth-child(4) ${LogoPosition} {
    transform: translate(22.5%, 76%);
  }
  &:nth-child(5) ${LogoPosition} {
    transform: translate(76%, 80%);
  }
`;
var wave = jsxs("svg", { "aria-hidden": "true", width: "298", height: "188", viewBox: "0 0 298 188", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M1 55.2757L21.6438 46.0285C55.5896 30.8228 94.4104 30.8228 128.356 46.0286L169.644 64.5229C203.59 79.7287 242.41 79.7286 276.356 64.5229L297 55.2757M1 44.2118L21.6438 34.9646C55.5896 19.7589 94.4104 19.7589 128.356 34.9646L169.644 53.459C203.59 68.6647 242.41 68.6647 276.356 53.459L297 44.2118M1 33.1477L21.6438 23.9005C55.5896 8.69479 94.4104 8.69479 128.356 23.9005L169.644 42.3949C203.59 57.6006 242.41 57.6006 276.356 42.3949L297 33.1477M1 22.1477L21.6438 12.9005C55.5896 -2.30521 94.4104 -2.30521 128.356 12.9005L169.644 31.3949C203.59 46.6006 242.41 46.6006 276.356 31.3949L297 22.1477M1 66.3398L21.6438 57.0926C55.5896 41.8869 94.4104 41.8869 128.356 57.0926L169.644 75.587C203.59 90.7927 242.41 90.7927 276.356 75.587L297 66.3398M1 77.404L21.6438 68.1568C55.5896 52.9511 94.4104 52.9511 128.356 68.1569L169.644 86.6512C203.59 101.857 242.41 101.857 276.356 86.6512L297 77.404M1 88.4681L21.6438 79.2209C55.5896 64.0152 94.4104 64.0152 128.356 79.2209L169.644 97.7153C203.59 112.921 242.41 112.921 276.356 97.7153L297 88.4681M1 121.66L21.6438 112.413C55.5896 97.2075 94.4104 97.2075 128.356 112.413L169.644 130.908C203.59 146.113 242.41 146.113 276.356 130.908L297 121.66M1 110.596L21.6438 101.349C55.5896 86.1433 94.4104 86.1433 128.356 101.349L169.644 119.843C203.59 135.049 242.41 135.049 276.356 119.843L297 110.596M1 99.5321L21.6438 90.2849C55.5896 75.0792 94.4104 75.0792 128.356 90.2849L169.644 108.779C203.59 123.985 242.41 123.985 276.356 108.779L297 99.5321M1 132.724L21.6438 123.477C55.5896 108.271 94.4104 108.271 128.356 123.477L169.644 141.971C203.59 157.177 242.41 157.177 276.356 141.971L297 132.724M1 143.788L21.6438 134.541C55.5896 119.336 94.4104 119.336 128.356 134.541L169.644 153.036C203.59 168.241 242.41 168.241 276.356 153.036L297 143.788M1 154.853L21.6438 145.605C55.5896 130.4 94.4104 130.4 128.356 145.605L169.644 164.1C203.59 179.305 242.41 179.305 276.356 164.1L297 154.853M1 165.853L21.6438 156.605C55.5896 141.4 94.4104 141.4 128.356 156.605L169.644 175.1C203.59 190.305 242.41 190.305 276.356 175.1L297 165.853", stroke: "url(#paint0_linear_1094_2077)", strokeOpacity: "0.9", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_1094_2077", x1: "1", y1: "112.587", x2: "297.034", y2: "79.6111", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "var(--ck-graphic-wave-stop-01)" }), jsx("stop", { stopColor: "var(--ck-graphic-wave-stop-02)", offset: "0.239583" }), jsx("stop", { stopColor: "var(--ck-graphic-wave-stop-03)", offset: "0.515625" }), jsx("stop", { stopColor: "var(--ck-graphic-wave-stop-04)", offset: "0.739583" }), jsx("stop", { stopColor: "var(--ck-graphic-wave-stop-05)", offset: "1" })] }) })] });
const SpinnerContainer$3 = styled(motion.div)`
  position: absolute;
  right: 16px;
  top: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
`;
const Arrow = styled.svg`
  --x: -3px;
  --stroke-width: 2;
  position: relative;
  top: 1px;
  left: -0.5px;
  display: inline-block;
  vertical-align: middle;
  margin-left: 9px;
  margin-right: 1px;
  transition: all 100ms ease;
  transform: translateX(var(--x, -3px));
  color: currentColor;
  opacity: 0.4;
`;
const ArrowChevron = styled.path``;
const ArrowLine = styled.line`
  transition: inherit;
  transition-property: transform;
  transform-origin: 90% 50%;
  transform: scaleX(0.1);
`;
const DownloadArrow = styled.div`
  display: inline-block;
  vertical-align: middle;
  position: relative;
  margin-right: 6px;
  color: currentColor;
`;
const DownloadArrowInner = styled.div`
  transform: rotate(90deg);
  ${Arrow} {
    margin: 0 auto;
  }
`;
const ButtonContainerInner = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  inset: 0;
  height: 100%;
`;
const ButtonContainer$1 = styled.button`

  ${({ disabled }) => disabled && Ae`
      cursor: not-allowed;
      pointer-events: none;
      ${InnerContainer} {
        opacity: 0.4;
      }
    `}

  ${({ $variant }) => {
  if ($variant === "primary") {
    return Ae`
        --color: var(--ck-primary-button-color, var(--ck-body-color));
        --background: var(
          --ck-primary-button-background,
          var(--ck-body-background-primary)
        );
        --box-shadow: var(--ck-primary-button-box-shadow);
        --border-radius: var(--ck-primary-button-border-radius);
        --font-weight: var(--ck-primary-button-font-weight, 500);

        --hover-color: var(--ck-button-primary-hover-color, var(--color));
        --hover-background: var(
          --ck-primary-button-hover-background,
          var(--background)
        );
        --hover-box-shadow: var(
          --ck-primary-button-hover-box-shadow,
          var(--box-shadow)
        );
        --hover-border-radius: var(
          --ck-primary-button-hover-border-radius,
          var(--border-radius)
        );
        --hover-font-weight: var(
          --ck-primary-button-font-weight,
          var(--font-weight)
        );
      `;
  } else if ($variant === "secondary") {
    return Ae`
        --color: var(--ck-secondary-button-color, var(--ck-body-color));
        --background: var(
          --ck-secondary-button-background,
          var(--ck-body-background-secondary)
        );
        --box-shadow: var(--ck-secondary-button-box-shadow);
        --border-radius: var(--ck-secondary-button-border-radius);
        --font-weight: var(--ck-secondary-button-font-weight, 500);

        --hover-color: var(--ck-secondary-button-hover-color, var(--color));
        --hover-background: var(
          --ck-secondary-button-hover-background,
          var(--background)
        );
        --hover-box-shadow: var(
          --ck-secondary-button-hover-box-shadow,
          var(--box-shadow)
        );
        --hover-border-radius: var(
          --ck-secondary-button-hover-border-radius,
          var(--border-radius)
        );
        --hover-font-weight: var(
          --ck-secondary-button-font-weight,
          var(--font-weight)
        );
      `;
  } else if ($variant === "tertiary") {
    return Ae`
        --color: var(
          --ck-tertiary-button-color,
          var(--ck-secondary-button-color)
        );
        --background: var(
          --ck-tertiary-button-background,
          var(--ck-secondary-button-background)
        );
        --box-shadow: var(
          --ck-tertiary-button-box-shadow,
          var(--ck-secondary-button-box-shadow)
        );
        --border-radius: var(
          --ck-tertiary-button-border-radius,
          var(--ck-secondary-button-border-radius)
        );
        --font-weight: var(
          --ck-tertiary-button-font-weight,
          var(--ck-secondary-button-font-weight)
        );

        --hover-color: var(
          --button-tertiary-hover-color,
          var(--ck-tertiary-button-color)
        );
        --hover-background: var(
          --ck-tertiary-button-hover-background,
          var(--ck-tertiary-button-background)
        );
        --hover-box-shadow: var(
          --ck-tertiary-button-hover-box-shadow,
          var(--ck-tertiary-button-box-shadow)
        );
        --hover-border-radius: var(
          --ck-tertiary-button-hover-border-radius,
          var(--ck-tertiary-button-border-radius, var(--border-radius))
        );
        --hover-font-weight: var(
          --ck-tertiary-button-font-weight,
          var(--ck-secondary-button-font-weight)
        );
      `;
  }
}}

  appearance: none;
  cursor: pointer;
  user-select: none;
  min-width: fit-content;
  width: 100%;
  display:block;
  text-align: center;
  height: 48px;
  margin: 12px 0 0;
  line-height: 48px;
  padding: 0 4px;
  font-size: 16px;
  font-weight: var(--font-weight,500);
  text-decoration: none;
  white-space: nowrap;
  transition: 100ms ease;
  transition-property: box-shadow, background-color;
  color: var(--color);
  background: var(--background);
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  will-change: transform, box-shadow, background-color, color;

  ${DownloadArrow} {
    ${Arrow} {
      transform: translateX(0);
      ${ArrowLine} {
        transform: none;
      }
      ${ArrowChevron} {
      }
    }
  }
}

  @media only screen and (min-width: ${defaultTheme.mobileWidth + 1}px) {
    &:hover,
    &:focus-visible {
      color: var(--ck-accent-text-color, var(--hover-color));
      background: var(--ck-accent-color, var(--hover-background));
      border-radius: var(--hover-border-radius);
      box-shadow: var(--hover-box-shadow);

      ${Arrow} {
        transform: translateX(0);
        ${ArrowLine} {
          transform: none;
        }
        ${ArrowChevron} {
        }
      }
      ${DownloadArrow} {
        ${Arrow} {
          transform: translateX(var(--x));
          ${ArrowLine} {
            transform: scaleX(0.1);
          }
          ${ArrowChevron} {
          }
        }
      }
    }
    &:active {
      box-shadow: var(--ck-secondary-button-active-box-shadow, var(--hover-box-shadow));
    }
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    transition: transform 100ms ease;
    transform: scale(1);
    font-size: 17px;
    &:active {
    }
  }
`;
const InnerContainer = styled.div`
  transform: translateZ(0); // Shifting fix
  position: relative;
  display: inline-block;
  vertical-align: middle;
  max-width: calc(100% - 42px);
  transition: opacity 300ms ease;
  /*
  overflow: hidden;
  text-overflow: ellipsis;
  */
`;
const IconContainer$4 = styled(motion.div)`
  position: relative;
  display: inline-block;
  vertical-align: middle;
  max-width: 20px;
  max-height: 20px;
  margin: 0 10px;
  &:first-child {
    margin-left: 0;
  }
  &:last-child {
    margin-right: 0;
  }
  ${(props) => {
  return props.$rounded && Ae`
        overflow: hidden;
        border-radius: 5px;
      `;
}}
  svg {
    display: block;
    position: relative;
    max-width: 100%;
    height: auto;
  }
`;
const Spin$1 = We`
  0%{ transform: rotate(0deg); }
  100%{ transform: rotate(360deg); }
`;
const SpinnerContainer$2 = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  animation: ${Spin$1} 1s linear infinite;
  svg {
    display: block;
    position: relative;
    animation: ${Spin$1} 1s ease-in-out infinite;
  }
`;
const transition$2 = {
  duration: 0.4,
  ease: [0.175, 0.885, 0.32, 0.98]
};
const Spinner$4 = () => jsx(SpinnerContainer$2, { initial: { opacity: 0, rotate: 180 }, animate: {
  opacity: 1,
  rotate: 0
}, exit: {
  position: "absolute",
  opacity: 0,
  rotate: -180,
  transition: {
    ...transition$2
  }
}, transition: {
  ...transition$2,
  delay: 0.2
}, children: jsxs("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("circle", { cx: "9", cy: "9", r: "7", stroke: "currentColor", strokeOpacity: "0.1", strokeWidth: "2.5" }), jsx("path", { d: "M16 9C16 5.13401 12.866 2 9 2", stroke: "currentColor", strokeWidth: "2.5", strokeLinecap: "round" })] }) });
const transition$1 = {
  duration: 0.4,
  ease: [0.175, 0.885, 0.32, 0.98]
};
const Button = ({
  children,
  variant = "secondary",
  // unique aspect to how we're handling buttons
  disabled,
  icon,
  iconPosition = "left",
  roundedIcon,
  waiting,
  arrow,
  download,
  href,
  style: style2,
  onClick
}) => {
  const key = typeof children === "string" ? children : flattenChildren(children).join("");
  const hrefUrl = typeof href === "string" ? href : flattenChildren(href).join("");
  return jsx(ButtonContainer$1, { as: href ? "a" : void 0, onClick: (event) => {
    if (!disabled && onClick)
      onClick(event);
  }, href: hrefUrl, target: href && "_blank", rel: href && "noopener noreferrer", disabled, "$variant": variant, style: style2, children: jsxs(AnimatePresence, { initial: false, children: [jsxs(ButtonContainerInner, { initial: { opacity: 0, y: -10 }, animate: {
    opacity: 1,
    y: -1
  }, exit: {
    position: "absolute",
    opacity: 0,
    y: 10,
    transition: {
      ...transition$1
    }
  }, transition: {
    ...transition$1,
    delay: 0.2
  }, children: [icon && iconPosition === "left" && jsx(IconContainer$4, { "$rounded": roundedIcon, children: icon }), download && jsx(DownloadArrow, { children: jsx(DownloadArrowInner, { children: jsxs(Arrow, { width: "13", height: "12", viewBox: "0 0 13 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx(ArrowLine, { stroke: "currentColor", x1: "1", y1: "6", x2: "12", y2: "6", strokeWidth: "var(--stroke-width)", strokeLinecap: "round" }), jsx(ArrowChevron, { stroke: "currentColor", d: "M7.51431 1.5L11.757 5.74264M7.5 10.4858L11.7426 6.24314", strokeWidth: "var(--stroke-width)", strokeLinecap: "round" })] }) }) }), jsx(InnerContainer, { style: { paddingLeft: arrow ? 6 : 0 }, children: jsx(FitText, { children }) }), icon && iconPosition === "right" && jsx(IconContainer$4, { "$rounded": roundedIcon, children: icon }), arrow && jsxs(Arrow, { width: "13", height: "12", viewBox: "0 0 13 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx(ArrowLine, { stroke: "currentColor", x1: "1", y1: "6", x2: "12", y2: "6", strokeWidth: "2", strokeLinecap: "round" }), jsx(ArrowChevron, { stroke: "currentColor", d: "M7.51431 1.5L11.757 5.74264M7.5 10.4858L11.7426 6.24314", strokeWidth: "2", strokeLinecap: "round" })] })] }, key), waiting && jsx(SpinnerContainer$3, { children: jsx(Spinner$4, {}) })] }) });
};
const Introduction = () => {
  var _a2, _b;
  const context = useContext();
  const locales = useLocales({});
  const ctaUrl = (_b = (_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.walletOnboardingUrl) !== null && _b !== void 0 ? _b : locales.onboardingScreen_ctaUrl;
  return jsxs(PageContent, { children: [jsxs(Graphic, { children: [jsxs(LogoGroup, { children: [jsx(Logo$2, { children: jsx(LogoPosition, { children: jsx(LogoInner, { children: jsx(FloatWrapper, { children: jsx(RotateWrapper, { children: jsx(LogoGraphic, { children: jsx(Logos.Coinbase, { background: true }) }) }) }) }) }) }), jsx(Logo$2, { children: jsx(LogoPosition, { children: jsx(LogoInner, { children: jsx(FloatWrapper, { children: jsx(RotateWrapper, { children: jsx(LogoGraphic, { children: jsx(Logos.MetaMask, { background: true }) }) }) }) }) }) }), jsx(Logo$2, { children: jsx(LogoPosition, { children: jsx(LogoInner, { children: jsx(FloatWrapper, { children: jsx(RotateWrapper, { children: jsx(LogoGraphic, { children: jsx(Logos.Trust, {}) }) }) }) }) }) }), jsx(Logo$2, { children: jsx(LogoPosition, { children: jsx(LogoInner, { children: jsx(FloatWrapper, { children: jsx(RotateWrapper, { children: jsx(LogoGraphic, { children: jsx(Logos.Argent, {}) }) }) }) }) }) }), jsx(Logo$2, { children: jsx(LogoPosition, { children: jsx(LogoInner, { children: jsx(FloatWrapper, { children: jsx(RotateWrapper, { children: jsx(LogoGraphic, { children: jsx(Logos.ImToken, {}) }) }) }) }) }) })] }), jsx(GraphicBackground, { children: wave })] }), jsxs(ModalContent, { style: { paddingBottom: 18 }, children: [jsx(ModalH1, { "$small": true, children: locales.onboardingScreen_h1 }), jsx(ModalBody, { children: locales.onboardingScreen_p })] }), jsx(Button, { href: ctaUrl, arrow: true, children: locales.onboardingScreen_ctaText })] });
};
const imageHeight = 208;
const ImageContainer$1 = styled.div`
  pointer-events: none;
  user-select: none;
  height: ${imageHeight}px;
  padding: 0 0 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  svg {
    display: block;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    display: none;
  }
`;
const ImageContainerInner = styled(motion.div)``;
const MobileImageContainer = styled.div`
  pointer-events: none;
  user-select: none;
  height: ${imageHeight}px;
  padding: 0 0 12px;
  display: none;
  align-items: center;
  justify-content: center;
  svg {
    display: block;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    display: flex;
  }
`;
const Slides = styled.div`
  position: relative;
`;
const Slide = styled(motion.div)`
  scroll-snap-type: x mandatory;
  position: relative;
  bottom: 0;
  left: 0;
  right: 0;
  width: 100%;
  padding: 0 4px 8px;
  /* will-change: transform, opacity; */
  transition: 400ms 50ms cubic-bezier(0.16, 1, 0.3, 1);
  transition-property: transform, opacity;
  ${(props) => !props.$active && Ae`
      pointer-events: none;
      position: absolute;
      opacity: 0;
      transform: scale(0.95);
      transition-duration: 300ms;
      transition-delay: 0ms;
    `}
`;
const Slider = styled.div`
  --background: var(--ck-body-background-secondary);
  --background-transparent: var(--ck-body-background-transparent, transparent);
  position: relative;
  padding: 0 0 4px;
  border-radius: 16px;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    margin: 0 -24px;
    ${Slides} {
      position: relative;
      z-index: 3;
      display: flex;
      overflow: auto;
      scroll-behavior: smooth;
      scroll-snap-type: x mandatory;
      margin-top: -${imageHeight}px;
      padding-top: ${imageHeight}px;
      -ms-overflow-style: none; /* Internet Explorer 10+ */
      scrollbar-width: none; /* Firefox */
      &::-webkit-scrollbar {
        display: none; /* Safari and Chrome */
      }
    }
    ${Slide} {
      position: relative;
      opacity: 1;
      transform: none;
      flex-shrink: 0;
      scroll-snap-align: start;
    }
  }
`;
const Dots = styled.div`
  position: relative;
  top: -1px;
  display: flex;
  justify-content: center;
  pointer-events: auto;
`;
const Dot = styled.button`
  display: flex;
  align-items: center;
  height: 28px;
  padding: 2px;
  background: none;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    padding: 4px;
    &:before {
      transform: none !important;
    }
  }
  &:before {
    content: '';
    display: block;
    width: 16px;
    height: 3px;
    opacity: 0.12;
    border-radius: 4px;
    background: var(--ck-accent-color, var(--ck-body-color));
    transition: transform 200ms ease, opacity 180ms ease;
  }
  ${(props) => props.$active ? Ae`
          cursor: default;
          &:before {
            opacity: 1;
          }
        ` : !props.disabled && Ae`
          cursor: pointer;
          &:hover:before {
            transform: scaleY(3.5);
          }
          &:active:before {
          }
        `}
`;
const pulseAnim = { scale: [0.9, 1.25, 1.6], opacity: [0, 0.11, 0] };
const pulseTransition = { ease: "linear", duration: 2, repeat: Infinity };
const Center = styled.div`
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translateY(-50%) translateX(-50%);
`;
const spin = We`
  from{ transform: rotate(0deg); }
  to{ transform: rotate(360deg); }
`;
const SpinContainer = styled(motion.div)`
  z-index: -1;
  position: absolute;
  inset: 0;
  overflow: hidden;
  border-radius: 100%;
  animation: ${spin} 16s linear infinite;
`;
const BgLighten = styled(motion.div)`
  overflow: hidden;
  border-radius: inherit;
  z-index: 0;
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.1);
`;
const MainCircle = styled(motion.div)`
  z-index: 2;
  position: relative;
  border-radius: 50%;
  background: var(--ck-body-background);
`;
const MainCircleInner = styled(motion.div)`
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
`;
const Compass = jsxs("svg", { width: "34", height: "34", viewBox: "0 0 34 34", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M17 34C26.3 34 34 26.2833 34 17C34 7.7 26.2833 0 16.9833 0C7.7 0 0 7.7 0 17C0 26.2833 7.71667 34 17 34ZM9.83333 25.6833C8.68333 26.2333 7.8 25.3333 8.33333 24.2L13.1667 14.3333C13.45 13.75 13.8167 13.3833 14.35 13.1333L24.1833 8.33333C25.4 7.75 26.25 8.65 25.6833 9.81667L20.8833 19.6667C20.6167 20.2 20.2333 20.6 19.6833 20.85L9.83333 25.6833ZM17.0167 19.1333C18.1833 19.1333 19.1333 18.1833 19.1333 17.0167C19.1333 15.85 18.1833 14.9167 17.0167 14.9167C15.8667 14.9167 14.9167 15.85 14.9167 17.0167C14.9167 18.1833 15.8667 19.1333 17.0167 19.1333Z", fill: "var(--ck-graphic-compass-color, var(--ck-body-color))" }), jsx("path", { d: "M17 34C26.3 34 34 26.2833 34 17C34 7.7 26.2833 0 16.9833 0C7.7 0 0 7.7 0 17C0 26.2833 7.71667 34 17 34ZM9.83333 25.6833C8.68333 26.2333 7.8 25.3333 8.33333 24.2L13.1667 14.3333C13.45 13.75 13.8167 13.3833 14.35 13.1333L24.1833 8.33333C25.4 7.75 26.25 8.65 25.6833 9.81667L20.8833 19.6667C20.6167 20.2 20.2333 20.6 19.6833 20.85L9.83333 25.6833ZM17.0167 19.1333C18.1833 19.1333 19.1333 18.1833 19.1333 17.0167C19.1333 15.85 18.1833 14.9167 17.0167 14.9167C15.8667 14.9167 14.9167 15.85 14.9167 17.0167C14.9167 18.1833 15.8667 19.1333 17.0167 19.1333Z", fill: "url(#ck-compass-gradient)" }), jsx("defs", { children: jsxs("linearGradient", { id: "ck-compass-gradient", x1: "17", y1: "0", x2: "17", y2: "34", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "rgba(0,0,0,0)" }), jsx("stop", { offset: "1", stopColor: "rgba(0,0,0,0.05)" })] }) })] });
const Wallet = ({ inverted = false }) => jsxs("svg", { width: "58", height: "50", viewBox: "0 0 58 50", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M57.9332 20.3335V42.1113C57.9332 46.4069 54.451 49.8891 50.1555 49.8891H8.15546C3.85991 49.8891 0.377686 46.4069 0.377686 42.1113V25.0002V7.8891C0.377686 3.59355 3.85991 0.111328 8.15546 0.111328H47.0444C48.7626 0.111328 50.1555 1.50422 50.1555 3.22244C50.1555 4.94066 48.7626 6.33355 47.0443 6.33355H9.71102C7.9928 6.33355 6.59991 7.72644 6.59991 9.44466C6.59991 11.1629 7.9928 12.5558 9.71102 12.5558H50.1555C54.451 12.5558 57.9332 16.038 57.9332 20.3335ZM46.2667 34.3337C48.4145 34.3337 50.1556 32.5926 50.1556 30.4448C50.1556 28.297 48.4145 26.5559 46.2667 26.5559C44.1189 26.5559 42.3778 28.297 42.3778 30.4448C42.3778 32.5926 44.1189 34.3337 46.2667 34.3337Z", fill: inverted ? "var(--ck-graphic-primary-color, var(--ck-body-background))" : "var(--ck-graphic-primary-color, var(--ck-body-color))" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_2501_7732", x1: "29.1555", y1: "0.111328", x2: "29.1555", y2: "49.8891", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: inverted ? "var(--ck-body-color-muted)" : "var(--ck-body-background-transparent, transparent)" }), jsx("stop", { offset: "1", stopColor: inverted ? "var(--ck-body-color)" : "var(--ck-body-background)" })] }) })] });
const Send = jsx("svg", { width: "41", height: "41", viewBox: "0 0 41 41", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M35.4446 0.839914L2.14484 10.7065C0.0395033 11.3303 -0.632966 13.9786 0.919705 15.5313L7.9624 22.574C9.47585 24.0874 11.8661 24.273 13.5951 23.0114L25.2866 14.4797C25.5558 14.2832 25.9281 14.3121 26.1638 14.5478C26.3998 14.7838 26.4285 15.1567 26.2313 15.426L17.6874 27.0937C16.4213 28.8228 16.6052 31.2168 18.1206 32.7322L25.1811 39.7926C26.7337 41.3453 29.382 40.6728 30.0058 38.5675L39.8724 5.2677C40.6753 2.55794 38.1544 0.037024 35.4446 0.839914Z", fill: "var(--ck-graphic-secondary-color, white)" }) });
const Receive = jsx("svg", { width: "38", height: "44", viewBox: "0 0 38 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19 0.875C21.4853 0.875 23.5 2.88972 23.5 5.375V27.761L30.068 21.193C31.8254 19.4357 34.6746 19.4357 36.432 21.193C38.1893 22.9504 38.1893 25.7996 36.432 27.557L22.182 41.807C20.4246 43.5643 17.5754 43.5643 15.818 41.807L1.56802 27.557C-0.18934 25.7996 -0.18934 22.9504 1.56802 21.193C3.32538 19.4357 6.17462 19.4357 7.93198 21.193L14.5 27.761V5.375C14.5 2.88972 16.5147 0.875 19 0.875Z", fill: "var(--ck-graphic-secondary-color, white)" }) });
const Key = ({ ...props }) => {
  var _a2;
  const id2 = (_a2 = props === null || props === void 0 ? void 0 : props.id) !== null && _a2 !== void 0 ? _a2 : "";
  return jsxs("svg", { ...props, width: "81", height: "81", viewBox: "0 0 81 81", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M81 27C81 41.9117 68.9117 54 54 54C51.2722 54 48.6389 53.5955 46.1568 52.8432L36 63H27V72H18V81H4.5C2.01472 81 0 78.9853 0 76.5V64.864C0 63.6705 0.474103 62.5259 1.31802 61.682L28.1568 34.8432C27.4045 32.3611 27 29.7278 27 27C27 12.0883 39.0883 0 54 0C68.9117 0 81 12.0883 81 27ZM60.75 25.875C63.8566 25.875 66.375 23.3566 66.375 20.25C66.375 17.1434 63.8566 14.625 60.75 14.625C57.6434 14.625 55.125 17.1434 55.125 20.25C55.125 23.3566 57.6434 25.875 60.75 25.875Z", fill: `url(#${id2}paint0_linear_2509_6177)` }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M81 27C81 41.9117 68.9117 54 54 54C51.2722 54 48.6389 53.5955 46.1568 52.8432L36 63H27V72H18V81H4.5C2.01472 81 0 78.9853 0 76.5V64.864C0 63.6705 0.474103 62.5259 1.31802 61.682L28.1568 34.8432C27.4045 32.3611 27 29.7278 27 27C27 12.0883 39.0883 0 54 0C68.9117 0 81 12.0883 81 27ZM60.75 25.875C63.8566 25.875 66.375 23.3566 66.375 20.25C66.375 17.1434 63.8566 14.625 60.75 14.625C57.6434 14.625 55.125 17.1434 55.125 20.25C55.125 23.3566 57.6434 25.875 60.75 25.875Z", fill: `url(#${id2}paint1_radial_2509_6177)`, fillOpacity: "0.2" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M44.5658 51.2522C45.1527 50.6653 46.0151 50.4492 46.8095 50.6899C49.0823 51.3788 51.4958 51.75 54 51.75C67.6691 51.75 78.75 40.669 78.75 27C78.75 13.331 67.6691 2.25 54 2.25C40.331 2.25 29.25 13.331 29.25 27C29.25 29.5042 29.6212 31.9177 30.3101 34.1905C30.5508 34.9849 30.3347 35.8473 29.7478 36.4342L2.90901 63.273C2.48705 63.6949 2.25 64.2672 2.25 64.864V76.5C2.25 77.7426 3.25736 78.75 4.5 78.75H15.75V72C15.75 70.7574 16.7574 69.75 18 69.75H24.75V63C24.75 61.7574 25.7574 60.75 27 60.75H35.068L44.5658 51.2522ZM36 63H27V72H18V81H4.5C2.01472 81 0 78.9853 0 76.5V64.864C0 63.6705 0.474103 62.5259 1.31802 61.682L28.1568 34.8432C27.4045 32.3611 27 29.7278 27 27C27 12.0883 39.0883 0 54 0C68.9117 0 81 12.0883 81 27C81 41.9117 68.9117 54 54 54C51.2722 54 48.6389 53.5955 46.1568 52.8432L36 63ZM68.625 20.25C68.625 24.5992 65.0992 28.125 60.75 28.125C56.4008 28.125 52.875 24.5992 52.875 20.25C52.875 15.9008 56.4008 12.375 60.75 12.375C65.0992 12.375 68.625 15.9008 68.625 20.25ZM66.375 20.25C66.375 23.3566 63.8566 25.875 60.75 25.875C57.6434 25.875 55.125 23.3566 55.125 20.25C55.125 17.1434 57.6434 14.625 60.75 14.625C63.8566 14.625 66.375 17.1434 66.375 20.25Z", fill: "black", fillOpacity: "0.1" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M33.4205 47.5795C33.8598 48.0188 33.8598 48.7312 33.4205 49.1705L3.0455 79.5455C2.60616 79.9848 1.89384 79.9848 1.4545 79.5455C1.01517 79.1062 1.01517 78.3938 1.4545 77.9545L31.8295 47.5795C32.2688 47.1402 32.9812 47.1402 33.4205 47.5795Z", fill: "#A5A9AD" }), jsxs("defs", { children: [jsxs("linearGradient", { id: `${id2}paint0_linear_2509_6177`, x1: "72", y1: "5.625", x2: "2.25", y2: "78.75", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#D4DFE6" }), jsx("stop", { offset: "0.0967282", stopColor: "#C6CACD" }), jsx("stop", { offset: "0.526645", stopColor: "#BDBAC4" }), jsx("stop", { offset: "1", stopColor: "#939CA1" })] }), jsxs("radialGradient", { id: `${id2}paint1_radial_2509_6177`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(52.875 12.375) rotate(93.2705) scale(39.4392)", children: [jsx("stop", { stopColor: "white" }), jsx("stop", { offset: "1", stopColor: "white" })] })] })] });
};
const VitalikAddress = jsxs("svg", { width: "131", height: "14", viewBox: "0 0 131 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M5.74805 13.2549C8.86816 13.2549 10.7227 10.6973 10.7227 6.63672C10.7227 2.57617 8.85059 0.0625 5.74805 0.0625C2.63672 0.0625 0.755859 2.59375 0.755859 6.64551C0.755859 10.7148 2.61914 13.2549 5.74805 13.2549ZM5.74805 11.4004C4.02539 11.4004 3.04102 9.64258 3.04102 6.63672C3.04102 3.68359 4.04297 1.91699 5.74805 1.91699C7.44434 1.91699 8.4375 3.6748 8.4375 6.64551C8.4375 9.65137 7.46191 11.4004 5.74805 11.4004Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M13.0869 13.1758C13.4561 13.1758 13.6934 13.0439 13.9658 12.6221L15.9697 9.66016H16.0137L18.0264 12.6572C18.2549 13.0088 18.4922 13.1758 18.8965 13.1758C19.4854 13.1758 19.9424 12.7891 19.9424 12.209C19.9424 11.9805 19.8633 11.7695 19.7051 11.541L17.376 8.28906L19.6963 5.16016C19.8896 4.90527 19.9688 4.68555 19.9688 4.43066C19.9688 3.88574 19.5381 3.49902 18.9229 3.49902C18.5361 3.49902 18.2988 3.6748 18.0176 4.10547L16.1191 6.95312H16.0752L14.1328 4.08789C13.8516 3.64844 13.6318 3.49902 13.2012 3.49902C12.6035 3.49902 12.1465 3.91211 12.1465 4.44824C12.1465 4.70312 12.2256 4.92285 12.3838 5.13379L14.7129 8.35059L12.3486 11.5498C12.1641 11.8135 12.0762 12.0156 12.0762 12.2705C12.0762 12.7979 12.498 13.1758 13.0869 13.1758Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M26.2441 13.2549C29.1445 13.2549 31.1924 11.7432 31.1924 9.57227C31.1924 7.9375 30.0146 6.68066 28.3184 6.3291V6.27637C29.7773 5.87207 30.7178 4.7998 30.7178 3.45508C30.7178 1.48633 28.8633 0.0625 26.2441 0.0625C23.625 0.0625 21.7617 1.49512 21.7617 3.44629C21.7617 4.80859 22.7109 5.88965 24.1699 6.27637V6.3291C22.4736 6.67188 21.3047 7.92871 21.3047 9.57227C21.3047 11.7344 23.335 13.2549 26.2441 13.2549ZM26.2441 5.55566C24.9258 5.55566 24.0029 4.78223 24.0029 3.6748C24.0029 2.55859 24.9258 1.77637 26.2441 1.77637C27.5537 1.77637 28.4854 2.5498 28.4854 3.6748C28.4854 4.78223 27.5537 5.55566 26.2441 5.55566ZM26.2441 11.5234C24.7236 11.5234 23.6514 10.6357 23.6514 9.40527C23.6514 8.1748 24.7236 7.28711 26.2441 7.28711C27.7646 7.28711 28.8369 8.16602 28.8369 9.40527C28.8369 10.6357 27.7646 11.5234 26.2441 11.5234Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M36.3164 13.1494C37.7578 13.1494 38.7598 12.4199 39.208 11.3477H39.252V12.0771C39.252 12.7891 39.7266 13.1758 40.3594 13.1758C40.9922 13.1758 41.4404 12.7803 41.4404 12.0771V1.29297C41.4404 0.554688 40.9834 0.141602 40.3418 0.141602C39.7002 0.141602 39.252 0.554688 39.252 1.29297V5.24805H39.1992C38.707 4.21973 37.6523 3.52539 36.3164 3.52539C33.9697 3.52539 32.4492 5.38867 32.4492 8.33301C32.4492 11.2949 33.9697 13.1494 36.3164 13.1494ZM36.9756 11.3564C35.5605 11.3564 34.6904 10.1963 34.6904 8.3418C34.6904 6.49609 35.5693 5.32715 36.9756 5.32715C38.3555 5.32715 39.2607 6.51367 39.2607 8.3418C39.2607 10.1875 38.3555 11.3564 36.9756 11.3564Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M44.0508 13.1494C44.6396 13.1494 44.9736 12.8594 45.1846 12.1738L46.0195 9.76562H50.7568L51.5918 12.1914C51.7939 12.8682 52.1367 13.1494 52.752 13.1494C53.4111 13.1494 53.8857 12.7188 53.8857 12.1035C53.8857 11.9014 53.8418 11.6992 53.7363 11.4092L50.0449 1.38965C49.7285 0.537109 49.2188 0.167969 48.3838 0.167969C47.5576 0.167969 47.0479 0.554688 46.7402 1.39844L43.0576 11.4092C42.9521 11.6816 42.9082 11.9277 42.9082 12.1035C42.9082 12.7451 43.3564 13.1494 44.0508 13.1494ZM46.5557 7.97266L48.3398 2.55859H48.4014L50.2031 7.97266H46.5557Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M60.1172 13.2549C62.8594 13.2549 64.8545 11.4004 64.8545 8.8252C64.8545 6.42578 63.1406 4.66797 60.6973 4.66797C58.9746 4.66797 57.709 5.54688 57.208 6.71582H57.1641V6.58398C57.208 3.66602 58.2275 1.89941 60.1436 1.89941C61.084 1.89941 61.7607 2.26855 62.3496 3.07715C62.7012 3.52539 62.9824 3.73633 63.4307 3.73633C64.0283 3.73633 64.3975 3.34082 64.3975 2.82227C64.3975 2.57617 64.3359 2.35645 64.1953 2.10156C63.5625 0.897461 62.0859 0.0537109 60.1523 0.0537109C56.9268 0.0537109 54.9932 2.57617 54.9932 6.80371C54.9932 8.24512 55.2305 9.45801 55.6963 10.4336C56.5752 12.2881 58.1396 13.2549 60.1172 13.2549ZM60.082 11.4092C58.667 11.4092 57.5508 10.293 57.5508 8.86914C57.5508 7.4541 58.6494 6.41699 60.1084 6.41699C61.5674 6.41699 62.6309 7.4541 62.6221 8.91309C62.6221 10.3018 61.4971 11.4092 60.082 11.4092Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M68.1328 8.83398C68.8447 8.83398 69.416 8.27148 69.416 7.55078C69.416 6.83008 68.8447 6.25879 68.1328 6.25879C67.4121 6.25879 66.8408 6.83008 66.8408 7.55078C66.8408 8.27148 67.4121 8.83398 68.1328 8.83398Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M73.3359 8.83398C74.0479 8.83398 74.6191 8.27148 74.6191 7.55078C74.6191 6.83008 74.0479 6.25879 73.3359 6.25879C72.6152 6.25879 72.0439 6.83008 72.0439 7.55078C72.0439 8.27148 72.6152 8.83398 73.3359 8.83398Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M78.5391 8.83398C79.251 8.83398 79.8223 8.27148 79.8223 7.55078C79.8223 6.83008 79.251 6.25879 78.5391 6.25879C77.8184 6.25879 77.2471 6.83008 77.2471 7.55078C77.2471 8.27148 77.8184 8.83398 78.5391 8.83398Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M83.7422 8.83398C84.4541 8.83398 85.0254 8.27148 85.0254 7.55078C85.0254 6.83008 84.4541 6.25879 83.7422 6.25879C83.0215 6.25879 82.4502 6.83008 82.4502 7.55078C82.4502 8.27148 83.0215 8.83398 83.7422 8.83398Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M92.2148 13.2549C94.957 13.2549 96.9521 11.4004 96.9521 8.8252C96.9521 6.42578 95.2383 4.66797 92.7949 4.66797C91.0723 4.66797 89.8066 5.54688 89.3057 6.71582H89.2617V6.58398C89.3057 3.66602 90.3252 1.89941 92.2412 1.89941C93.1816 1.89941 93.8584 2.26855 94.4473 3.07715C94.7988 3.52539 95.0801 3.73633 95.5283 3.73633C96.126 3.73633 96.4951 3.34082 96.4951 2.82227C96.4951 2.57617 96.4336 2.35645 96.293 2.10156C95.6602 0.897461 94.1836 0.0537109 92.25 0.0537109C89.0244 0.0537109 87.0908 2.57617 87.0908 6.80371C87.0908 8.24512 87.3281 9.45801 87.7939 10.4336C88.6729 12.2881 90.2373 13.2549 92.2148 13.2549ZM92.1797 11.4092C90.7646 11.4092 89.6484 10.293 89.6484 8.86914C89.6484 7.4541 90.7471 6.41699 92.2061 6.41699C93.665 6.41699 94.7285 7.4541 94.7197 8.91309C94.7197 10.3018 93.5947 11.4092 92.1797 11.4092Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M103.377 13.2549C106.497 13.2549 108.352 10.6973 108.352 6.63672C108.352 2.57617 106.479 0.0625 103.377 0.0625C100.266 0.0625 98.3848 2.59375 98.3848 6.64551C98.3848 10.7148 100.248 13.2549 103.377 13.2549ZM103.377 11.4004C101.654 11.4004 100.67 9.64258 100.67 6.63672C100.67 3.68359 101.672 1.91699 103.377 1.91699C105.073 1.91699 106.066 3.6748 106.066 6.64551C106.066 9.65137 105.091 11.4004 103.377 11.4004Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M117.167 13.1758C117.8 13.1758 118.248 12.7715 118.248 12.0596V10.5654H119.127C119.733 10.5654 120.094 10.1875 120.094 9.63379C120.094 9.08887 119.733 8.70215 119.136 8.70215H118.248V1.81152C118.248 0.756836 117.554 0.141602 116.385 0.141602C115.453 0.141602 114.899 0.52832 114.073 1.75879C112.553 3.99121 111.111 6.16211 110.224 7.75293C109.872 8.38574 109.731 8.79883 109.731 9.29102C109.731 10.0469 110.268 10.5654 111.085 10.5654H116.086V12.0596C116.086 12.7715 116.543 13.1758 117.167 13.1758ZM116.121 8.75488H111.788V8.69336C112.816 6.82129 114.073 4.92285 116.086 2.04004H116.121V8.75488Z", fill: "var(--ck-body-color)" }), jsx("path", { d: "M126.105 13.2549C128.918 13.2549 130.869 11.4355 130.869 8.78125C130.869 6.35547 129.138 4.6416 126.712 4.6416C125.438 4.6416 124.392 5.13379 123.855 5.9248H123.812L124.146 2.17188H129.27C129.85 2.17188 130.228 1.80273 130.228 1.24023C130.228 0.686523 129.85 0.317383 129.27 0.317383H123.803C122.81 0.317383 122.3 0.72168 122.221 1.72363L121.816 6.51367C121.808 6.56641 121.808 6.60156 121.808 6.6543C121.79 7.26953 122.15 7.78809 122.88 7.78809C123.398 7.78809 123.618 7.67383 124.146 7.14648C124.629 6.67188 125.323 6.34668 126.123 6.34668C127.617 6.34668 128.681 7.38379 128.681 8.84277C128.681 10.3457 127.617 11.4092 126.114 11.4092C124.893 11.4092 124.049 10.8027 123.618 9.77441C123.381 9.30859 123.091 9.12402 122.616 9.12402C122.019 9.12402 121.641 9.49316 121.641 10.082C121.641 10.4072 121.72 10.6709 121.843 10.9434C122.467 12.3232 124.154 13.2549 126.105 13.2549Z", fill: "var(--ck-body-color)" })] });
const SlideOne = ({ layoutId }) => {
  return jsxs("div", { style: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }, children: [jsx(motion.div, { initial: { rotate: 90, scale: 0.2, x: "100%" }, animate: { rotate: 0, scale: 1, x: 0 }, exit: { rotate: 40, scale: 0.1, x: "70%" }, style: {
    zIndex: 4,
    position: "relative",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: 76,
    height: 76,
    background: "var(--ck-graphic-secondary-background, #6366F1)",
    borderRadius: "50%",
    boxShadow: "var(--ck-graphic-secondary-box-shadow, 0px 2px 10px rgba(99, 102, 241, 0.3))"
  }, children: Receive }), jsx(MainCircle, { layoutId, style: {
    position: "relative",
    zIndex: 10,
    margin: "0 -8px",
    width: 112,
    height: 112
  }, children: jsxs(MainCircleInner, { style: {
    background: "var(--ck-graphic-primary-background, var(--ck-body-background))",
    boxShadow: "var(--ck-graphic-primary-box-shadow, 0px 3px 15px rgba(0, 0, 0, 0.1))"
  }, initial: {
    opacity: 0
  }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: [jsx(BgLighten, {}), jsx(motion.div, { style: { zIndex: 2, position: "relative" }, children: jsx(Wallet, {}) })] }, "SlideOneInner") }, layoutId), jsx(motion.div, { initial: { rotate: -90, scale: 0.2, x: "-100%" }, animate: { rotate: 0, scale: 1, x: 0 }, exit: { rotate: -40, scale: 0.1, x: "-70%" }, style: {
    zIndex: 4,
    position: "relative",
    width: 76,
    height: 76,
    background: "var(--ck-graphic-secondary-background, #3897FB)",
    borderRadius: "50%",
    boxShadow: "var(--ck-graphic-secondary-box-shadow, 0px 2px 10px rgba(56, 151, 251, 0.3))"
  }, children: jsx(Center, { children: jsx("div", { style: { position: "relative", left: -2, top: 3 }, children: Send }) }) })] });
};
const SlideTwo = ({ layoutId }) => {
  return jsx(Fragment$2, { children: jsxs("div", { style: {
    position: "relative",
    left: -14
  }, children: [jsx(MainCircle, { layoutId, style: {
    zIndex: 10,
    position: "absolute",
    left: 15,
    top: 12,
    width: 32,
    height: 32
  }, children: jsx(MainCircleInner, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, style: {
    background: "var(--ck-graphic-primary-background, var(--ck-body-background))",
    boxShadow: "var(--ck-graphic-primary-box-shadow, 0px 2px 5px rgba(37, 41, 46, 0.16))"
  }, children: jsx(Center, { children: jsx(Wallet, {}) }) }, "SlideTwoInner") }, layoutId), jsxs(motion.div, { initial: { scale: 0.2 }, animate: { scale: 1 }, exit: { scale: 0.2 }, style: {
    zIndex: 7,
    position: "relative",
    display: "flex",
    alignItems: "center",
    padding: "21px 56px",
    paddingRight: 52,
    background: "var(--ck-graphic-primary-background, var(--ck-body-background))",
    boxShadow: "var(--ck-graphic-primary-box-shadow, 0px 2px 9px rgba(0, 0, 0, 0.07))",
    borderRadius: "var(--ck-border-radius, 16px)"
  }, children: [jsx(BgLighten, {}), jsx("div", { style: { position: "relative", zIndex: 2, top: 1, left: 1 }, children: VitalikAddress })] }), jsx(motion.div, { style: {
    zIndex: 8,
    position: "absolute",
    top: -16,
    right: -28
  }, initial: { rotate: 90, x: -70, scale: 0.4 }, animate: { rotate: 0, x: 0, scale: 1 }, exit: { rotate: 0, x: -70, scale: 0.4 }, children: jsx(Key, { id: layoutId }) })] }) });
};
const SlideThree = ({ layoutId }) => {
  const id2 = Math.random();
  return jsx(Fragment$2, { children: jsxs(motion.div, { style: {
    position: "relative"
  }, children: [jsxs(MainCircle, { layoutId, initial: { rotate: 80 }, style: {
    zIndex: 10,
    position: "relative",
    width: 128,
    height: 128
  }, children: [jsx(MainCircleInner, { initial: { opacity: 0, rotate: 100 }, animate: { opacity: 1 }, exit: { opacity: 0 }, style: {
    overflow: "hidden",
    background: `var(--ck-graphic-globe-background, radial-gradient(
              82.42% 82.42% at 50% 86.72%,
              rgba(255, 255, 255, 0.2) 0%,
              rgba(0, 0, 0, 0) 100%
            ),
            linear-gradient(180deg, #3897FB 0%, #5004F1 100%))`,
    boxShadow: "var(--ck-graphic-globe-box-shadow, 0px -6px 20px rgba(56, 151, 251, 0.23))"
  }, children: jsx(SpinContainer, { style: !Boolean(layoutId) ? {
    animationPlayState: "paused"
  } : void 0, children: jsxs("svg", { width: "128", height: "128", viewBox: "0 0 128 128", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxs("g", { children: [jsx("circle", { cx: "30", cy: "141", r: "64", stroke: `url(#networkRadialA-${id2})`, strokeWidth: "3" }), jsx("circle", { cx: "78.8515", cy: "131.123", r: "54.1005", transform: "rotate(-37.4016 78.8515 131.123)", stroke: `url(#networkRadialB-${id2})`, strokeWidth: "3" }), jsx("circle", { cx: "63.6053", cy: "2.12794", r: "50.8338", transform: "rotate(134.702 63.6053 2.12794)", stroke: `url(#networkRadialC-${id2})`, strokeWidth: "3" }), jsx("circle", { cx: "126.658", cy: "56.6577", r: "50.3433", transform: "rotate(-105 126.658 56.6577)", stroke: `url(#networkRadialD-${id2})`, strokeWidth: "3" }), jsx("circle", { cx: "13.6619", cy: "18.9603", r: "46.0247", transform: "rotate(107.362 13.6619 18.9603)", stroke: `url(#networkRadialE-${id2})`, strokeWidth: "3" })] }), jsxs("defs", { children: [jsxs("radialGradient", { id: `networkRadialA-${id2}`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(60.5 84) rotate(104.668) scale(77.0097)", children: [jsx("stop", { stopColor: "var(--ck-graphic-globe-lines, white)" }), jsx("stop", { offset: "1", stopColor: "var(--ck-graphic-globe-lines, white)", stopOpacity: "0" })] }), jsxs("radialGradient", { id: `networkRadialB-${id2}`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(96.1805 81.6717) rotate(97.125) scale(64.7443)", children: [jsx("stop", { stopColor: "var(--ck-graphic-globe-lines, white)" }), jsx("stop", { offset: "1", stopColor: "var(--ck-graphic-globe-lines, white)", stopOpacity: "0" })] }), jsxs("radialGradient", { id: `networkRadialC-${id2}`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(96.3816 -36.4455) rotate(114.614) scale(57.7177)", children: [jsx("stop", { stopColor: "var(--ck-graphic-globe-lines, white)" }), jsx("stop", { offset: "1", stopColor: "var(--ck-graphic-globe-lines, white)", stopOpacity: "0" })] }), jsxs("radialGradient", { id: `networkRadialD-${id2}`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(137.86 7.73234) rotate(92.3288) scale(62.743)", children: [jsx("stop", { stopColor: "var(--ck-graphic-globe-lines, white)" }), jsx("stop", { offset: "1", stopColor: "var(--ck-graphic-globe-lines, white)", stopOpacity: "0" })] }), jsxs("radialGradient", { id: `networkRadialE-${id2}`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(35.3203 -21.566) rotate(104.513) scale(54.8617)", children: [jsx("stop", { stopColor: "var(--ck-graphic-globe-lines, white)" }), jsx("stop", { offset: "1", stopColor: "var(--ck-graphic-globe-lines, white)", stopOpacity: "0" })] })] })] }) }) }, "SlideThreeInner"), jsxs(motion.div, { exit: { opacity: 0 }, children: [jsx(motion.div, { initial: !Boolean(layoutId) ? { scale: 1.1 } : void 0, animate: Boolean(layoutId) ? pulseAnim : void 0, transition: { ...pulseTransition }, style: {
    position: "absolute",
    inset: 0,
    borderRadius: "50%",
    boxShadow: "0 0 0 2px var(--ck-graphic-globe-lines, rgba(126, 112, 243, 1))"
  } }, "pulseA"), jsx(motion.div, { initial: !Boolean(layoutId) ? { scale: 1.2, opacity: 0.25 } : void 0, animate: Boolean(layoutId) ? pulseAnim : void 0, transition: { ...pulseTransition, delay: 0.5 }, style: {
    position: "absolute",
    inset: 0,
    borderRadius: "50%",
    boxShadow: "0 0 0 2px var(--ck-graphic-globe-lines, rgba(126, 112, 243, 1))"
  } }, "pulseB")] })] }, layoutId), jsxs(motion.div, { initial: { rotate: -20, scale: 0.1, y: -10, x: -10 }, animate: { rotate: 0, scale: 1, y: 0, x: 0 }, exit: { zIndex: 3, scale: 0.2, y: -25, x: 15 }, style: {
    zIndex: 12,
    borderRadius: "50%",
    position: "absolute",
    bottom: -4,
    right: -4,
    width: 54,
    height: 54,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: 13,
    background: "var(--ck-graphic-compass-background, var(--ck-body-background))",
    boxShadow: "var(--ck-graphic-compass-box-shadow, 0px 2px 9px rgba(0, 0, 0, 0.15))"
  }, children: [jsx(BgLighten, {}), jsx(motion.div, { style: { zIndex: 2, position: "absolute" }, initial: { rotate: -170 }, animate: { rotate: 0 }, exit: {
    rotate: -180,
    transition: { duration: 0 }
    // needed to avoid AnimatePresence taking too long to unmount the animation which causes issues on page close
  }, transition: {
    type: "spring",
    stiffness: 6,
    damping: 0.9,
    mass: 0.2
  }, children: Compass })] })] }, "SlideThree") });
};
const About = () => {
  var _a2, _b;
  const locales = useLocales({
    //CONNECTORNAME: connector.name,
  });
  const context = useContext();
  const ctaUrl = (_b = (_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.ethereumOnboardingUrl) !== null && _b !== void 0 ? _b : locales.aboutScreen_ctaUrl;
  const [ready, setReady] = reactExports.useState(true);
  const [slider, setSlider] = reactExports.useState(0);
  const interacted = reactExports.useRef(false);
  const scrollPos = reactExports.useRef(0);
  const animationEase = [0.16, 1, 0.3, 1];
  const animationDuration = 600;
  let interval;
  reactExports.useEffect(() => {
    return () => clearInterval(interval);
  }, []);
  const isSwipe = () => {
    if (sliderRef.current) {
      const { overflow } = getComputedStyle(sliderRef.current);
      return overflow !== "visible";
    }
    return false;
  };
  const gotoSlide = (index2) => {
    setReady(false);
    if (isSwipe()) {
      scrollToSlide(index2);
    } else {
      setSlider(index2);
    }
  };
  const scrollToSlide = (index2) => {
    if (sliderRef.current) {
      const { offsetWidth: width } = sliderRef.current;
      sliderRef.current.scrollLeft = width * index2;
      setTimeout(() => setSlider(index2), 100);
    }
  };
  const onScroll = () => {
    if (!sliderRef.current)
      return;
    const { offsetWidth: width, scrollLeft: x2 } = sliderRef.current;
    const prevScroll = scrollPos.current;
    scrollPos.current = x2;
    const threshold = 4;
    if (prevScroll - x2 > -threshold && prevScroll - x2 < threshold) {
      const currentSlide = Math.round(x2 / width);
      setSlider(currentSlide);
    }
  };
  const onTouchMove = () => {
    didInteract();
  };
  const onTouchEnd = () => {
    const { offsetWidth: width, scrollLeft: x2 } = sliderRef.current;
    const currentSlide = Math.round(x2 / width);
    setSlider(currentSlide);
  };
  const didInteract = () => {
    interacted.current = true;
    clearTimeout(interval);
  };
  const sliderRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!sliderRef.current)
      return;
    sliderRef.current.addEventListener("scroll", onScroll);
    sliderRef.current.addEventListener("touchmove", onTouchMove);
    sliderRef.current.addEventListener("touchend", onTouchEnd);
    return () => {
      if (!sliderRef.current)
        return;
      sliderRef.current.removeEventListener("scroll", onScroll);
      sliderRef.current.removeEventListener("touchmove", onTouchMove);
      sliderRef.current.removeEventListener("touchend", onTouchEnd);
    };
  }, [sliderRef]);
  const graphics = [
    jsx(SlideOne, { layoutId: "graphicCircle", duration: animationDuration, ease: animationEase }),
    jsx(SlideTwo, { layoutId: "graphicCircle", duration: animationDuration, ease: animationEase }),
    jsx(SlideThree, { layoutId: "graphicCircle", duration: animationDuration, ease: animationEase })
  ];
  const mobileGraphics = [
    jsx(SlideOne, { duration: animationDuration, ease: animationEase }),
    jsx(SlideTwo, { duration: animationDuration, ease: animationEase }),
    jsx(SlideThree, { duration: animationDuration, ease: animationEase })
  ];
  const slideHeight = (() => {
    var _a3;
    switch ((_a3 = context.options) === null || _a3 === void 0 ? void 0 : _a3.language) {
      case "en-US":
      case "zh-CN":
        return 64;
      default:
        return 84;
    }
  })();
  const slides = [
    jsxs(Fragment$2, { children: [jsx(ModalH1, { style: { height: 24 }, "$small": true, children: jsx(FitText, { children: locales.aboutScreen_a_h1 }) }), jsx(ModalBody, { style: { height: slideHeight }, children: jsx(FitText, { children: locales.aboutScreen_a_p }) })] }),
    jsxs(Fragment$2, { children: [jsx(ModalH1, { style: { height: 24 }, "$small": true, children: jsx(FitText, { children: locales.aboutScreen_b_h1 }) }), jsx(ModalBody, { style: { height: slideHeight }, children: jsx(FitText, { children: locales.aboutScreen_b_p }) })] }),
    jsxs(Fragment$2, { children: [jsx(ModalH1, { style: { height: 24 }, "$small": true, children: jsx(FitText, { children: locales.aboutScreen_c_h1 }) }), jsx(ModalBody, { style: { height: slideHeight }, children: jsx(FitText, { children: locales.aboutScreen_c_p }) })] })
  ];
  return jsxs(PageContent, { children: [jsxs(Slider, { children: [jsx(ImageContainer$1, { children: jsx(MotionConfig, { transition: {
    duration: animationDuration / 1e3,
    ease: animationEase
  }, children: jsx(AnimatePresence, { initial: false, onExitComplete: () => setReady(true), children: graphics.map((g2, i2) => slider === i2 && jsx(ImageContainerInner, { style: { position: "absolute" }, children: g2 }, i2)) }) }) }), jsx(Slides, { ref: sliderRef, children: jsx(AnimatePresence, { children: slides.map((s, i2) => jsxs(Slide, { "$active": slider === i2, children: [jsx(MobileImageContainer, { children: jsx(MotionConfig, { transition: {
    duration: 0
  }, children: jsx(ImageContainerInner, { children: mobileGraphics[i2] }) }) }), jsx(ModalContent, { style: { gap: 8, paddingBottom: 0 }, children: s })] }, i2)) }) })] }), jsx(OrDivider, { children: jsx(Dots, { children: slides.map((s, i2) => jsx(Dot, { "$active": slider === i2, onClick: () => {
    didInteract();
    gotoSlide(i2);
  } }, i2)) }) }), jsx(Button, { href: ctaUrl, arrow: true, children: locales.aboutScreen_ctaText })] });
};
const Shimmer$1 = We`
  0%{ transform: translate(-100%) rotate(-45deg); }
  100%{ transform: translate(100%) rotate(-80deg); }
`;
const InfoBox = styled.div`
  padding: 24px 24px 28px;
  border-radius: var(--ck-tertiary-border-radius, 24px);
  box-shadow: var(--ck-tertiary-box-shadow, none);
  background: var(--ck-body-background-tertiary);
  ${ModalBody} {
    max-width: none;
  }
`;
const InfoBoxButtons = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin: 5px -8px -12px;
  button {
  }
`;
const LearnMoreContainer = styled(motion.div)`
  text-align: center;
  margin-top: 16px;
  margin-bottom: -6px;
`;
const LearnMoreButton = styled(motion.button)`
  appearance: none;
  user-select: none;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  height: 42px;
  padding: 0 16px;
  border-radius: 6px;
  background: none;
  color: var(--ck-body-color-muted);
  font-size: 15px;
  line-height: 18px;
  font-weight: 500;
  /* will-change: transform; */
  transition: color 200ms ease, transform 100ms ease;
  svg {
    transition: all 100ms ease-out;
    display: block;
    position: relative;
    top: 2px;
    left: 2px;
    transform: translateZ(0px);
    path,
    circle {
      transition: all 100ms ease-out;
    }
    path:last-of-type {
      transform-origin: 0 0;
      transform: scaleX(1.3) skewY(-12deg);
      opacity: 0;
    }
    circle {
      transform: translate(20%, -15%);
    }
  }
  &:hover {
    color: var(--ck-body-color-muted-hover);
    svg {
      path,
      circle {
        opacity: 1;
        transform: none;
      }
    }
  }
  &:active {
    transform: scale(0.96);
  }
`;
styled(motion.div)`
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 0 0 16px;
  overflow-y: scroll;
  max-height: 20rem;

  &::-webkit-scrollbar {
    display: none;
  }
`;
styled(motion.button)`
  cursor: pointer;
  user-select: none;
  position: relative;
  display: flex;
  align-items: center;
  padding: 0 20px;
  width: 100%;
  height: 64px;
  font-size: 17px;
  font-weight: var(--ck-primary-button-font-weight, 500);
  line-height: 20px;
  text-align: var(--ck-body-button-text-align, left);
  transition: 180ms ease;
  transition-property: background, color, box-shadow, transform, opacity;
  will-change: transform, box-shadow, background-color, color, opacity;

  --fallback-color: var(--ck-primary-button-color);
  --fallback-background: var(--ck-primary-button-background);
  --fallback-box-shadow: var(--ck-primary-button-box-shadow);
  --fallback-border-radius: var(--ck-primary-button-border-radius);

  --color: var(--ck-primary-button-color, var(--fallback-color));
  --background: var(--ck-primary-button-background, var(--fallback-background));
  --box-shadow: var(--ck-primary-button-box-shadow, var(--fallback-box-shadow));
  --border-radius: var(
    --ck-primary-button-border-radius,
    var(--fallback-border-radius)
  );

  --hover-color: var(--ck-primary-button-hover-color, var(--color));
  --hover-background: var(
    --ck-primary-button-hover-background,
    var(--background)
  );
  --hover-box-shadow: var(
    --ck-primary-button-hover-box-shadow,
    var(--box-shadow)
  );
  --hover-border-radius: var(
    --ck-primary-button-hover-border-radius,
    var(--border-radius)
  );

  --active-color: var(--ck-primary-button-active-color, var(--hover-color));
  --active-background: var(
    --ck-primary-button-active-background,
    var(--hover-background)
  );
  --active-box-shadow: var(
    --ck-primary-button-active-box-shadow,
    var(--hover-box-shadow)
  );
  --active-border-radius: var(
    --ck-primary-button-active-border-radius,
    var(--hover-border-radius)
  );

  color: var(--color);
  background: var(--background);
  box-shadow: var(--box-shadow);
  border-radius: var(--border-radius);

  &:disabled {
    transition: 180ms ease;
    opacity: 0.4;
  }

  --bg: var(--background);
  &:not(:disabled) {
    &:hover {
      color: var(--hover-color);
      background: var(--hover-background);
      box-shadow: var(--hover-box-shadow);
      border-radius: var(--hover-border-radius);
      --bg: var(--hover-background, var(--background));
    }
    &:focus-visible {
      transition-duration: 100ms;
      color: var(--hover-color);
      background: var(--hover-background);
      box-shadow: var(--hover-box-shadow);
      border-radius: var(--hover-border-radius);
      --bg: var(--hover-background, var(--background));
    }
    &:active {
      color: var(--active-color);
      background: var(--active-background);
      box-shadow: var(--active-box-shadow);
      border-radius: var(--active-border-radius);
      --bg: var(--active-background, var(--background));
    }
  }
`;
styled(motion.span)`
  position: relative;
  top: var(--ck-recent-badge-top-offset, 0.5px);
  display: inline-block;
  padding: 10px 7px;
  line-height: 0;
  font-size: 13px;
  font-weight: 400;
  border-radius: var(--ck-recent-badge-border-radius, var(--border-radius));
  color: var(
    --ck-recent-badge-color,
    var(--ck-accent-color, var(--ck-body-color-muted, currentColor))
  );
  background: var(--ck-recent-badge-background, transparent);
  overflow: hidden;
  span {
    display: inline-block;
    position: relative;
  }
  &:before {
    z-index: 1;
    content: '';
    position: absolute;
    inset: 0;
    opacity: 0.4;
    box-shadow: var(--ck-recent-badge-box-shadow, inset 0 0 0 1px currentColor);
    border-radius: inherit;
  }
  &:after {
    z-index: 2;
    content: '';
    position: absolute;
    inset: -10%;
    top: -110%;
    aspect-ratio: 1/1;
    opacity: 0.7;
    background: linear-gradient(
      170deg,
      transparent 10%,
      var(--ck-recent-badge-background, var(--bg)) 50%,
      transparent 90%
    );
    animation: ${Shimmer$1} 2s linear infinite;
  }
`;
styled(motion.span)`
  display: flex;
  align-items: center;
  gap: 9px;
  width: 100%;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  padding: 2px 0;
  padding-right: 38px;
`;
styled(motion.div)`
  position: absolute;
  right: 20px;
  width: 32px;
  height: 32px;
  overflow: hidden;
  svg,
  img {
    display: block;
    position: relative;
    pointer-events: none;
    overflow: hidden;
    border-radius: 27.5%;
    width: 100%;
    height: 100%;
  }
`;
styled(motion.div)`
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  justify-content: space-between;
  padding: 14px 0 28px;
  margin: 0 0;
`;
styled(motion.button)`
  --background: var(--ck-body-background-secondary);
  cursor: pointer;
  user-select: none;
  position: relative;
  padding: 0;
  width: 100%;
  min-width: 25%;
  font-size: 13px;
  font-weight: 500;
  line-height: 13px;
  text-align: center;
  transition: 100ms ease;
  transition-property: transform, opacity;

  background: none;

  &:disabled {
    cursor: not-allowed;
    opacity: 0.4;
  }

  &:not(:disabled) {
    &:active {
      transform: scale(0.97);
    }
  }
`;
styled(motion.span)`
  display: block;
  padding: 10px 0 0;
  color: var(--ck-body-color);
  opacity: 0.75;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
`;
styled(motion.div)`
  position: relative;
  margin: 0 auto;
  width: 60px;
  height: 60px;
  overflow: hidden;
  svg {
    display: block;
    position: relative;
    overflow: hidden;
    border-radius: 27.5%;
    transform: translate3d(0, 0, 0);
    width: 100%;
    height: 100%;
  }
`;
var WalletIcon$1 = ({ ...props }) => {
  return jsxs("svg", { "aria-hidden": "true", width: "20", height: "19", viewBox: "0 0 20 19", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [jsx("path", { d: "M1.57568 4.60616C1.57568 2.69827 3.12234 1.15161 5.03023 1.15161H15.3939C17.3018 1.15161 18.8484 2.69826 18.8484 4.60616V10.3637C18.8484 12.2716 17.3018 13.8183 15.3939 13.8183H5.03023C3.12234 13.8183 1.57568 12.2716 1.57568 10.3637V4.60616Z", stroke: "currentColor", strokeWidth: "2" }), jsx("path", { d: "M1 4.79293C1 2.435 3.31004 0.770014 5.54697 1.51566L12.4561 3.81869C13.8667 4.2889 14.8182 5.60901 14.8182 7.09596V13.6313C14.8182 15.9892 12.5081 17.6542 10.2712 16.9086L3.36212 14.6056C1.95149 14.1353 1 12.8152 1 11.3283V4.79293Z", fill: "var(--ck-body-background)", stroke: "currentColor", strokeWidth: "2" }), jsx("circle", { cx: "10.3863", cy: "10.1894", r: "1.32574", fill: "currentColor" })] });
};
const Shimmer = We`
  0%{ transform: translate(-100%) rotate(-45deg); }
  100%{ transform: translate(100%) rotate(-80deg); }
`;
const ConnectorButton = styled(motion.button)`
  display: block;
  text-decoration: none;
`;
const ConnectorLabel = styled(motion.span)``;
const ConnectorIcon = styled(motion.div)``;
const styles = {
  desktop: {
    ConnectorButton: Ae`
      cursor: pointer;
      user-select: none;
      position: relative;
      display: flex;
      align-items: center;
      padding: 0 20px;
      width: 100%;
      height: 64px;
      font-size: 17px;
      font-weight: var(--ck-primary-button-font-weight, 500);
      line-height: 20px;
      text-align: var(--ck-body-button-text-align, left);
      transition: 180ms ease;
      transition-property: background, color, box-shadow, transform, opacity;
      will-change: transform, box-shadow, background-color, color, opacity;

      --fallback-color: var(--ck-primary-button-color);
      --fallback-background: var(--ck-primary-button-background);
      --fallback-box-shadow: var(--ck-primary-button-box-shadow);
      --fallback-border-radius: var(--ck-primary-button-border-radius);

      --color: var(--ck-primary-button-color, var(--fallback-color));
      --background: var(
        --ck-primary-button-background,
        var(--fallback-background)
      );
      --box-shadow: var(
        --ck-primary-button-box-shadow,
        var(--fallback-box-shadow)
      );
      --border-radius: var(
        --ck-primary-button-border-radius,
        var(--fallback-border-radius)
      );

      --hover-color: var(--ck-primary-button-hover-color, var(--color));
      --hover-background: var(
        --ck-primary-button-hover-background,
        var(--background)
      );
      --hover-box-shadow: var(
        --ck-primary-button-hover-box-shadow,
        var(--box-shadow)
      );
      --hover-border-radius: var(
        --ck-primary-button-hover-border-radius,
        var(--border-radius)
      );

      --active-color: var(--ck-primary-button-active-color, var(--hover-color));
      --active-background: var(
        --ck-primary-button-active-background,
        var(--hover-background)
      );
      --active-box-shadow: var(
        --ck-primary-button-active-box-shadow,
        var(--hover-box-shadow)
      );
      --active-border-radius: var(
        --ck-primary-button-active-border-radius,
        var(--hover-border-radius)
      );

      color: var(--color);
      background: var(--background);
      box-shadow: var(--box-shadow);
      border-radius: var(--border-radius);

      &:disabled {
        transition: 180ms ease;
        opacity: 0.4;
      }

      --bg: var(--background);
      &:not(:disabled) {
        &:hover {
          color: var(--hover-color);
          background: var(--hover-background);
          box-shadow: var(--hover-box-shadow);
          border-radius: var(--hover-border-radius);
          --bg: var(--hover-background, var(--background));
        }
        &:focus-visible {
          transition-duration: 100ms;
          color: var(--hover-color);
          background: var(--hover-background);
          box-shadow: var(--hover-box-shadow);
          border-radius: var(--hover-border-radius);
          --bg: var(--hover-background, var(--background));
        }
        &:active {
          color: var(--active-color);
          background: var(--active-background);
          box-shadow: var(--active-box-shadow);
          border-radius: var(--active-border-radius);
          --bg: var(--active-background, var(--background));
        }
      }
    `,
    ConnectorLabel: Ae`
      display: flex;
      align-items: center;
      gap: 9px;
      width: 100%;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      padding: 2px 0;
      padding-right: 38px;
    `,
    ConnectorIcon: Ae`
      position: absolute;
      right: 20px;
      width: 32px;
      height: 32px;
      overflow: hidden;
      border-radius: 27.5%;
      svg,
      img {
        display: block;
        position: relative;
        pointer-events: none;
        overflow: hidden;
        width: 100%;
        height: 100%;
      }
    `
  },
  mobile: {
    ConnectorButton: Ae`
      text-align: center;
      background: none;
      max-width: 100%;
      overflow: hidden;
    `,
    ConnectorLabel: Ae`
      display: block;
      text-overflow: ellipsis;
      max-width: 100%;
      overflow: hidden;
      padding: 10px 0 0;
      color: var(--ck-body-color);
      font-size: 13px;
      line-height: 15px;
      font-weight: 500;
      opacity: 0.75;
    `,
    ConnectorIcon: Ae`
      margin: 0 auto;
      width: 60px;
      height: 60px;
      overflow: hidden;
      border-radius: 25%;
      svg,
      img {
        display: block;
        position: relative;
        width: 100%;
        height: auto;
      }
      &[data-small='true'] {
        svg,
        img {
          transform: scale(0.8);
        }
      }
    `
  }
};
const RecentlyUsedTag = styled(motion.span)`
  position: relative;
  top: var(--ck-recent-badge-top-offset, 0.5px);
  display: inline-block;
  padding: 10px 7px;
  line-height: 0;
  font-size: 13px;
  font-weight: 400;
  border-radius: var(--ck-recent-badge-border-radius, var(--border-radius));
  color: var(
    --ck-recent-badge-color,
    var(--ck-accent-color, var(--ck-body-color-muted, currentColor))
  );
  background: var(--ck-recent-badge-background, transparent);
  overflow: hidden;
  span {
    display: inline-block;
    position: relative;
  }
  &:before {
    z-index: 1;
    content: '';
    position: absolute;
    inset: 0;
    opacity: 0.4;
    box-shadow: var(--ck-recent-badge-box-shadow, inset 0 0 0 1px currentColor);
    border-radius: inherit;
  }
  &:after {
    z-index: 2;
    content: '';
    position: absolute;
    inset: -10%;
    top: -110%;
    aspect-ratio: 1/1;
    opacity: 0.7;
    background: linear-gradient(
      170deg,
      transparent 10%,
      var(--ck-recent-badge-background, var(--bg)) 50%,
      transparent 90%
    );
    animation: ${Shimmer} 2s linear infinite;
  }
`;
const ConnectorsContainer = styled.div`
  transition: opacity 300ms ease;
  min-width: fit-content;

  ${(props) => props.$disabled && Ae`
      pointer-events: none;
      opacity: 0.4;
    `}

  ${(props) => !props.$mobile ? Ae`
          display: flex;
          flex-direction: column;
          gap: 12px;

          ${ConnectorButton} {
            ${styles.desktop.ConnectorButton}
            ${ConnectorLabel} {
              ${styles.desktop.ConnectorLabel}
            }
            ${ConnectorIcon} {
              ${styles.desktop.ConnectorIcon}
            }
          }
        ` : Ae`
          display: flex;
          align-items: flex-start;
          justify-content: space-around;
          gap: 22px 6px;
          //margin: 0px -10px -20px;
          padding: 14px 0px 28px;

          ${ConnectorButton} {
            flex-shrink: 0;
            width: 80px;
            ${styles.mobile.ConnectorButton}
            ${ConnectorLabel} {
              ${styles.mobile.ConnectorLabel}
              ${RecentlyUsedTag} {
                display: none;
                width: fit-content;
                margin: 0 auto;
              }
            }
            ${ConnectorIcon} {
              ${styles.mobile.ConnectorIcon}
            }
          }
        `}
`;
const randomID = () => {
  return Date.now().toString(36) + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
};
const save = (storageKey, data2) => {
  localStorage.setItem(storageKey, JSON.stringify(data2));
  return get$1(storageKey);
};
const get$1 = (storageKey) => {
  const data2 = localStorage.getItem(storageKey);
  try {
    if (data2)
      return JSON.parse(data2);
    return [];
  } catch (e2) {
    save(storageKey, []);
    return [];
  }
};
const add = (storageKey, item) => {
  const data2 = get$1(storageKey);
  const newData = [
    {
      ...item,
      ckStoreKey: randomID(),
      timestamp: /* @__PURE__ */ new Date()
    },
    ...data2
  ];
  save(storageKey, newData);
  return get$1(storageKey);
};
const remove = (storageKey, item) => {
  const data2 = get$1(storageKey);
  const newData = data2.filter((i2) => i2.ckStoreKey !== item.ckStoreKey);
  save(storageKey, newData);
  return get$1(storageKey);
};
const useLocalStorage = (storageKey) => {
  const [data2, setData] = reactExports.useState(get$1(storageKey));
  const add$12 = (item) => {
    const newItems = add(storageKey, item);
    setData(newItems);
  };
  const update = (items) => {
    const newItems = save(storageKey, items);
    setData(newItems);
  };
  const remove$1 = (item) => {
    const newItems = remove(storageKey, item);
    setData(newItems);
  };
  const clear = () => {
    const newItems = save(storageKey, []);
    setData(newItems);
  };
  return { data: data2, add: add$12, remove: remove$1, update, clear };
};
const useLastConnector = () => {
  const { data: lastConnectorId, add: add2, update, clear } = useLocalStorage("connectKit.lastConnectorId");
  const updateLastConnectorId = (id2) => {
    if (lastConnectorId) {
      if (lastConnectorId === id2)
        return;
      clear();
      update(id2);
    } else {
      add2(id2);
    }
  };
  return {
    lastConnectorId,
    updateLastConnectorId
  };
};
function useConnect({ ...props } = {}) {
  var _a2;
  const context = useContext();
  const connectProps = {
    chainId: (_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.initialChainId
  };
  const { updateLastConnectorId } = useLastConnector();
  const { connect: connect2, connectAsync, connectors, ...rest } = useConnect$1({
    onError(err) {
      if (err.message) {
        if (err.message !== "User rejected request") {
          context.log(err.message, err);
        }
      } else {
        context.log(`Could not connect.`, err);
      }
    },
    onSuccess(data2) {
      var _a3, _b, _c;
      updateLastConnectorId((_c = `${(_a3 = data2 === null || data2 === void 0 ? void 0 : data2.connector) === null || _a3 === void 0 ? void 0 : _a3.id}-${(_b = data2 === null || data2 === void 0 ? void 0 : data2.connector) === null || _b === void 0 ? void 0 : _b.name}`) !== null && _c !== void 0 ? _c : "");
    },
    ...props
    /*
    onSuccess: (data) => {
      context.onConnect?.({
        address: data.account,
        //chainId: data.chain.id,
        connectorId: data.connector?.id,
      });
    },
    */
  });
  return {
    connect: ({ ...opts }) => {
      return connect2({
        ...opts,
        ...connectProps
      });
    },
    connectAsync: async ({ ...opts }) => {
      return await connectAsync({
        ...opts,
        ...connectProps
      });
    },
    connectors,
    ...rest
  };
}
function useWalletConnectUri({ enabled } = {
  enabled: true
}) {
  const { log: log3 } = useContext();
  const [uri, setUri] = reactExports.useState(void 0);
  const connector = useWalletConnectConnector();
  const isWalletConnectLegacy = (connector === null || connector === void 0 ? void 0 : connector.id) === "walletConnectLegacy";
  const { isConnected } = useAccount();
  const { connectAsync } = useConnect();
  reactExports.useEffect(() => {
    if (!enabled)
      return;
    async function handleMessage({ type, data: data2 }) {
      log3("WC Message", type, data2);
      if (isWalletConnectLegacy) {
        log3("isWalletConnectLegacy");
        if (type === "connecting") {
          const p2 = await connector.getProvider();
          setUri(p2.connector.uri);
          p2.connector.on("disconnect", () => {
            log3("User rejected, regenerate QR code");
            connectWalletConnect(connector);
          });
        }
      } else {
        if (type === "display_uri") {
          setUri(data2);
        }
      }
    }
    async function handleChange(e2) {
      log3("WC Change", e2);
    }
    async function handleDisconnect() {
      var _a2;
      log3("WC Disconnect");
      if (connector) {
        if (((_a2 = connector.options) === null || _a2 === void 0 ? void 0 : _a2.version) === "1") {
          connectWallet(connector);
        }
      }
    }
    async function handleConnect() {
      log3("WC Connect");
    }
    async function handleError2(e2) {
      log3("WC Error", e2);
    }
    async function connectWallet(connector2) {
      const result = await connectAsync({ connector: connector2 });
      if (result)
        return result;
      return false;
    }
    async function connectWalletConnect(connector2) {
      try {
        await connectWallet(connector2);
      } catch (error) {
        log3("catch error");
        log3(error);
        if (error.code) {
          switch (error.code) {
            case 4001:
              log3("error.code - User rejected");
              connectWalletConnect(connector2);
              break;
            default:
              log3("error.code - Unknown Error");
              break;
          }
        } else {
          log3("WalletConnect cannot connect.", error);
        }
      }
    }
    if (!connector || uri)
      return;
    if (connector && !isConnected) {
      connectWalletConnect(connector);
      log3("add wc listeners");
      connector.on("message", handleMessage);
      connector.on("change", handleChange);
      connector.on("connect", handleConnect);
      connector.on("disconnect", handleDisconnect);
      connector.on("error", handleError2);
      return () => {
        log3("remove wc listeners");
        connector.off("message", handleMessage);
        connector.off("change", handleChange);
        connector.off("connect", handleConnect);
        connector.off("disconnect", handleDisconnect);
        connector.off("error", handleError2);
      };
    }
  }, [enabled, connector, isConnected]);
  return {
    uri
  };
}
function useIsMobile() {
  const [mobile, setMobile] = reactExports.useState(isMobile());
  reactExports.useEffect(() => {
    const handleResize = () => {
      setMobile(isMobile());
    };
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return mobile;
}
const ScrollContainer = styled.div`
  position: relative;
`;
const fadeIn = We`
0%{ opacity:0; }
100%{ opacity:1; }
`;
const MoreIndicator = styled.div`
  z-index: 9;
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0.75rem;
  display: flex;
  justify-content: center;

  transition: opacity 300ms ease;

  span {
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.25rem;
    padding: 0.3075rem 0.9375rem 0.375rem;
    border-radius: 6rem;
    background: var(--ck-tooltip-background);
    color: var(--ck-tooltip-color);
    font-weight: 500;
    font-size: 0.8125rem;
    letter-spacing: -0.01rem;
    box-shadow: var(--ck-tooltip-shadow);
    animation: ${fadeIn} 300ms ease 1000ms both;

    transition: transform 100ms ease;

    &:hover {
      transform: scale(1.02);
    }
    &:active {
      transform: scale(0.98);
    }
    svg {
      display: block;
      transform: translateX(-0.1875rem);
    }
  }

  &.hide {
    opacity: 0;
    pointer-events: none;
  }
`;
const ScrollAreaContainer = styled.div`
  --bg: ${({ $backgroundColor }) => $backgroundColor || "var(--ck-body-background)"};
  --fade-height: 1px;
  position: relative;
  z-index: 1;

  ${({ $mobile, $height, $mobileDirection }) => $mobile && $mobileDirection === "horizontal" ? Ae`
          overflow-x: scroll;
          margin: 0 -24px;
          padding: 0 24px;

          &:before,
          &:after {
            pointer-events: none;
            z-index: 10;
            content: '';
            display: block;
            position: sticky;
            top: 0;
            bottom: 0;
            width: var(--fade-height);
            background: var(--ck-body-divider);
            box-shadow: var(--ck-body-divider-box-shadow);
            transition: opacity 300ms ease;
          }
          &:before {
            left: 0;
          }
          &:after {
            right: 0;
          }

          &.scroll-start {
            &:before {
              opacity: 0;
            }
          }

          &.scroll-end {
            &:after {
              opacity: 0;
            }
          }
        ` : Ae`
          max-height: ${$height ? `${$height}px` : "310px"};
          overflow-y: scroll;
          padding: 0 10px;
          margin: calc(var(--fade-height) * -1) -16px 0 -10px;

          &:before,
          &:after {
            pointer-events: none;
            z-index: 10;
            content: '';
            display: block;
            position: sticky;
            left: 0;
            right: 0;
            height: var(--fade-height);
            background: var(--ck-body-divider);
            box-shadow: var(--ck-body-divider-box-shadow);
            transition: opacity 300ms ease;
          }
          &:before {
            top: 0;
          }
          &:after {
            bottom: 0;
          }

          &.scroll-start {
            &:before {
              opacity: 0;
            }
          }

          &.scroll-end {
            &:after {
              opacity: 0;
            }
          }
        `}

  &::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }
  &::-webkit-scrollbar-track {
    background: transparent;
  }
  &::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0);
    border-radius: 100px;
  }
  &:hover::-webkit-scrollbar-thumb {
    background: var(--ck-body-color-muted);
  }
  &::-webkit-scrollbar-thumb:hover {
    background: var(--ck-body-color-muted-hover);
  }
`;
const ArrowDown = () => jsx("svg", { width: "11", height: "12", viewBox: "0 0 11 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M5.49438 1L5.49438 11M5.49438 11L9.5 7M5.49438 11L1.5 7", stroke: "currentColor", strokeWidth: "1.75", strokeLinecap: "round", strokeLinejoin: "round" }) });
const ScrollArea = ({ children, height, backgroundColor, mobileDirection }) => {
  const ref = reactExports.useRef(null);
  const moreRef = reactExports.useRef(null);
  const isMobile2 = useIsMobile();
  reactExports.useEffect(() => {
    const el2 = ref.current;
    if (!el2)
      return;
    if (el2.scrollHeight > el2.clientHeight) {
      if (moreRef.current) {
        moreRef.current.classList.remove("hide");
      }
    }
    const handleScroll = (e2) => {
      const { scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth } = e2.target;
      if (moreRef.current) {
        if (scrollTop > 0) {
          moreRef.current.classList.add("hide");
        }
      }
      if (scrollTop === 0 && scrollLeft === 0) {
        el2.classList.add("scroll-start");
      } else {
        el2.classList.remove("scroll-start");
      }
      if (scrollHeight - scrollTop === clientHeight && scrollWidth - scrollLeft === clientWidth) {
        el2.classList.add("scroll-end");
      } else {
        el2.classList.remove("scroll-end");
      }
    };
    el2.addEventListener("scroll", handleScroll);
    handleScroll({ target: el2 });
    return () => {
      el2.removeEventListener("scroll", handleScroll);
    };
  }, [ref.current]);
  return jsxs(ScrollContainer, { children: [jsx(ScrollAreaContainer, { ref, "$mobile": isMobile2, "$height": height, "$backgroundColor": backgroundColor, "$mobileDirection": mobileDirection, children }), jsx(MoreIndicator, { ref: moreRef, className: "hide", onClick: () => {
    if (ref.current) {
      ref.current.scrollTo({
        top: ref.current.scrollHeight,
        behavior: "smooth"
      });
    }
  }, children: jsxs("span", { children: [jsx(ArrowDown, {}), " More Available"] }) })] });
};
const AlertContainer = styled(motion.div)`
  display: flex;
  gap: 8px;
  position: relative;
  border-radius: 9px;
  margin: 0 auto;
  padding: 10px;
  text-align: left;
  font-size: 14px;
  line-height: 17px;
  font-weight: 400;
  max-width: 260px;
  min-width: 100%;

  border-radius: var(--ck-alert-border-radius, 12px);
  color: var(--ck-alert-color, var(--ck-body-color-muted));
  background: var(--ck-alert-background, var(--ck-body-background-secondary));
  box-shadow: var(--ck-alert-box-shadow, var(--ck-body-box-shadow));

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    padding: 16px;
    font-size: 16px;
    line-height: 21px;
    border-radius: 24px;
    text-align: center;
  }

  ${($error) => {
  if ($error)
    return Ae`
        color: #fff;
        background: var(--ck-body-color-danger, red);
      `;
}}
`;
const IconContainer$3 = styled(motion.div)`
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  svg {
    display: block;
    width: 100%;
    height: auto;
  }
`;
const Alert = ({ children, error, icon }) => {
  return jsxs(AlertContainer, { "$error": error, children: [icon && jsx(IconContainer$3, { children: icon }), jsx("div", { children })] });
};
Alert.displayName = "Alert";
const ConnectorList = () => {
  var _a2;
  const context = useContext();
  const isMobile2 = useIsMobile();
  const { uri } = useWalletConnectUri();
  const { lastConnectorId } = useLastConnector();
  const injectedWallet = useInjectedWallet();
  const wallets = useWallets();
  const walletsToDisplay = ((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.hideRecentBadge) || lastConnectorId === "walletConnect-WalletConnect" ? wallets : [
    // move last used wallet to top of list
    // using .filter and spread to avoid mutating original array order with .sort
    ...wallets.filter((wallet2) => lastConnectorId === `${wallet2.connector.id}-${wallet2.connector.name}`),
    ...wallets.filter((wallet2) => lastConnectorId !== `${wallet2.connector.id}-${wallet2.connector.name}`)
  ];
  return jsxs(ScrollArea, { mobileDirection: "horizontal", children: [walletsToDisplay.length === 0 && jsx(Alert, { error: true, children: "No connectors found in ConnectKit config." }), walletsToDisplay.length > 0 && jsx(ConnectorsContainer, { "$mobile": isMobile2, "$totalResults": walletsToDisplay.length, children: walletsToDisplay.map((wallet2) => {
    var _a3;
    const { id: id2, name: name2, shortName, icon, iconConnector, connector, createUri } = wallet2;
    let deeplink = isMobile2 ? createUri === null || createUri === void 0 ? void 0 : createUri(uri !== null && uri !== void 0 ? uri : "") : void 0;
    const redirectToMoreWallets = isMobile2 && isWalletConnectConnector(id2);
    if (isInjectedConnector(id2) && !injectedWallet.enabled)
      return null;
    if (redirectToMoreWallets)
      deeplink = void 0;
    const walletInfo = isInjectedConnector(wallet2.id) && injectedWallet.enabled ? (
      // && injectedWallet.wallet.name === wallet.name
      {
        name: injectedWallet.wallet.name,
        shortName: (_a3 = injectedWallet.wallet.shortName) !== null && _a3 !== void 0 ? _a3 : injectedWallet.wallet.name,
        icon: injectedWallet.wallet.icon
        //iconRadius: 0,
      }
    ) : {
      name: name2,
      shortName: shortName !== null && shortName !== void 0 ? shortName : name2,
      icon: iconConnector !== null && iconConnector !== void 0 ? iconConnector : icon,
      iconRadius: wallet2.id === "walletConnect" ? 0 : void 0
    };
    const ButtonInner = ({ disabled = false }) => {
      var _a4;
      return jsxs(ConnectorButton, { as: deeplink ? "a" : void 0, href: deeplink ? deeplink : void 0, disabled: disabled || context.route !== routes.CONNECTORS, onClick: deeplink ? void 0 : () => {
        if (redirectToMoreWallets) {
          context.setRoute(routes.MOBILECONNECTORS);
        } else {
          context.setRoute(routes.CONNECT);
          context.setConnector({ id: id2, name: name2 });
        }
      }, children: [jsx(ConnectorIcon, { "data-small": wallet2.iconShouldShrink, style: {
        borderRadius: walletInfo.iconRadius
      }, children: walletInfo.icon }), jsxs(ConnectorLabel, { children: [isMobile2 ? walletInfo.shortName : walletInfo.name, !((_a4 = context.options) === null || _a4 === void 0 ? void 0 : _a4.hideRecentBadge) && lastConnectorId === `${connector.id}-${connector.name}` && jsx(RecentlyUsedTag, { children: jsx("span", { children: "Recent" }) })] })] });
    };
    return jsx(ButtonInner, {}, id2);
  }) })] });
};
const Wallets = () => {
  var _a2, _b, _c, _d, _e2;
  const context = useContext();
  const locales = useLocales({});
  const isMobile2 = useIsMobile();
  return jsxs(PageContent, { style: { width: 312 }, children: [jsx(ConnectorList, {}), isMobile2 ? jsx(Fragment$2, { children: jsxs(InfoBox, { children: [jsxs(ModalContent, { style: { padding: 0, textAlign: "left" }, children: [jsx(ModalH1, { "$small": true, children: locales.connectorsScreen_h1 }), jsx(ModalBody, { children: locales.connectorsScreen_p })] }), jsxs(InfoBoxButtons, { children: [!((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.hideQuestionMarkCTA) && jsx(Button, { variant: "tertiary", onClick: () => context.setRoute(routes.ABOUT), children: locales.learnMore }), !((_b = context.options) === null || _b === void 0 ? void 0 : _b.hideNoWalletCTA) && jsx(Button, { variant: "tertiary", onClick: () => context.setRoute(routes.ONBOARDING), children: locales.getWallet })] })] }) }) : jsx(Fragment$2, { children: !((_c = context.options) === null || _c === void 0 ? void 0 : _c.hideNoWalletCTA) && jsx(LearnMoreContainer, { children: jsxs(LearnMoreButton, { onClick: () => context.setRoute(routes.ONBOARDING), children: [jsx(WalletIcon$1, {}), " ", locales.connectorsScreen_newcomer] }) }) }), ((_d = context.options) === null || _d === void 0 ? void 0 : _d.disclaimer) && jsx(Disclaimer, { style: { visibility: "hidden", pointerEvents: "none" }, children: jsx("div", { children: (_e2 = context.options) === null || _e2 === void 0 ? void 0 : _e2.disclaimer }) })] });
};
const WalletItem = styled.div`
  text-align: center;
  transition: opacity 100ms ease;
  opacity: ${(props) => props.$waiting ? 0.4 : 1};
`;
const WalletIcon = styled.div`
  z-index: 9;
  position: relative;
  margin: 0 auto 10px;
  border-radius: 16px;
  width: 60px;
  height: 60px;
  overflow: hidden;
  background: rgba(0, 0, 0, 0.04);
  ${(props) => props.$outline && `
  &:before {
    content: '';
    z-index: 2;
    position: absolute;
    inset: 0;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.04);
  }`}
  svg {
    display: block;
    position: relative;
    width: 100%;
    height: auto;
  }
`;
const WalletLabel = styled.div`
  color: var(--ck-body-color);
  font-size: 13px;
  line-height: 15px;
  font-weight: 500;
  opacity: 0.75;
`;
const PulseKeyframes = We`
  0%,100% { opacity:1; }
  50% { opacity:0.5; }
`;
const WalletList = styled.div`
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 22px 8px;
  margin: 0 -10px;
  padding: 4px 0 0;
  transition: opacity 300ms ease;
  ${(props) => props.$disabled && Ae`
      pointer-events: none;
      opacity: 0.4;
      ${WalletItem} {
        animation: ${PulseKeyframes} 1s infinite ease-in-out;
      }
    `}
`;
const Container$6 = styled.div``;
function useWalletConnectModal() {
  const { log: log3 } = useContext();
  const { connectAsync, connectors } = useConnect();
  const [isOpen, setIsOpen] = reactExports.useState(false);
  return {
    isOpen,
    open: async () => {
      const w3mcss = document.createElement("style");
      w3mcss.innerHTML = `w3m-modal, wcm-modal{ --wcm-z-index: 2147483647; --w3m-z-index:2147483647; }`;
      document.head.appendChild(w3mcss);
      const clientConnector = connectors.find((c2) => isWalletConnectConnector(c2.id));
      if (clientConnector) {
        let connector;
        if (clientConnector.id === "walletConnectLegacy") {
          connector = new WalletConnectLegacyConnector({
            ...clientConnector,
            options: {
              ...clientConnector.options,
              qrcode: true
            }
          });
        } else {
          connector = new WalletConnectConnector({
            ...clientConnector,
            options: {
              ...clientConnector.options,
              showQrModal: true
            }
          });
        }
        setIsOpen(true);
        try {
          await connectAsync({ connector });
        } catch (err) {
          log3("WalletConnect", err);
        }
        setIsOpen(false);
        document.head.removeChild(w3mcss);
      } else {
        log3("No WalletConnect connector available");
      }
    }
  };
}
const IconContainer$2 = styled(motion.div)`
  transition: all 220ms cubic-bezier(0.175, 0.885, 0.32, 1.1);
  display: flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  svg {
    display: block;
  }
  svg,
  svg path,
  svg rect {
    transition: inherit;
  }
  svg path:first-child {
    transform-origin: 50% 50%;
    fill: var(--bg);
    stroke: var(--color);
  }
  svg rect {
    transform-origin: 53% 63%;
    fill: var(--bg);
    stroke: var(--color);
  }
  svg path:last-child {
    opacity: 0;
    stroke: var(--bg);
    transform: translate(11.75px, 10px) rotate(90deg) scale(0.6);
  }
  ${(props) => props.$clipboard ? Ae`
          --color: var(--ck-focus-color) !important;
          --bg: var(--ck-body-background);
          svg {
            transition-delay: 0ms;
            path:first-child {
              opacity: 0;
              transform: rotate(-90deg) scale(0.2);
            }
            rect {
              rx: 10px;
              fill: var(--color);
              transform: rotate(-90deg) scale(1.45);
            }
            path:last-child {
              transition-delay: 100ms;
              opacity: 1;
              transform: translate(7.75px, 9.5px);
            }
          }
        ` : Ae`
          &:hover {
          }
          &:hover:active {
          }
        `}
`;
const CopyToClipboardIcon = ({ copied, small }) => jsx(IconContainer$2, { "$clipboard": copied, children: jsx(CopyToClipboardIcon$1, { style: {
  transform: small ? "scale(1)" : "translateX(3px) scale(1.5)",
  opacity: small || copied ? 1 : 0.3
} }) });
const Container$5 = styled.div`
  --color: var(--ck-copytoclipboard-stroke);
  --bg: var(--ck-body-background);
  transition: all 220ms cubic-bezier(0.175, 0.885, 0.32, 1.1);

  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;

  ${(props) => props.$disabled ? Ae`
          cursor: not-allowed;
          opacity: 0.4;
        ` : Ae`
          &:hover {
            --color: var(--ck-body-color-muted);
          }
        `}
`;
const OffsetContainer = styled.div`
  display: block;
  position: relative;
  transition: inherit;
  svg {
    position: absolute;
    left: 100%;
    display: block;
    top: -1px;
    margin: 0;
    margin-left: 4px;
  }
`;
const CopyToClipboard = ({ string: string2, children, variant }) => {
  const [clipboard, setClipboard] = reactExports.useState(false);
  let timeout;
  const onCopy = () => {
    if (!string2)
      return;
    const str = string2.trim();
    if (navigator.clipboard) {
      navigator.clipboard.writeText(str);
    }
    setClipboard(true);
    clearTimeout(timeout);
    timeout = setTimeout(() => setClipboard(false), 1e3);
  };
  if (variant === "button")
    return jsx(Button, { disabled: !string2, onClick: onCopy, icon: jsx(CopyToClipboardIcon, { copied: clipboard }), children });
  return jsx(Container$5, { onClick: onCopy, "$disabled": !string2, children: jsxs(OffsetContainer, { children: [children, jsx(CopyToClipboardIcon, { copied: clipboard, small: true })] }) });
};
const MoreIcon = jsx("svg", { width: "60", height: "60", viewBox: "0 0 60 60", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M30 42V19M19 30.5H42", stroke: "var(--ck-body-color-muted)", strokeWidth: "3", strokeLinecap: "round" }) });
const MobileConnectors = () => {
  var _a2;
  const context = useContext();
  const locales = useLocales();
  const { uri: wcUri } = useWalletConnectUri();
  const { open: openW3M, isOpen: isOpenW3M } = useWalletConnectModal();
  const wallets = useLegacyWallets().filter(
    (wallet2) => (wallet2.installed === void 0 || !wallet2.installed) && wallet2.createUri && // Do not show wallets that are injected connectors
    !isWalletConnectConnector(wallet2.id)
    // Do not show WalletConnect
  );
  const connectWallet = (wallet2) => {
    var _a3;
    if (wallet2.installed) {
      context.setRoute(routes.CONNECT);
      context.setConnector({ id: wallet2.id, name: wallet2.name });
    } else {
      const uri = (_a3 = wallet2.createUri) === null || _a3 === void 0 ? void 0 : _a3.call(wallet2, wcUri);
      if (uri)
        window.location.href = uri;
    }
  };
  return jsx(PageContent, { style: { width: 312 }, children: jsxs(Container$6, { children: [jsx(ModalContent, { style: { paddingBottom: 0 }, children: jsx(ScrollArea, { height: 340, children: jsxs(WalletList, { "$disabled": !wcUri, children: [wallets.map((wallet2, i2) => {
    const { name: name2, shortName, icon, installed } = wallet2;
    return jsxs(WalletItem, { onClick: () => connectWallet(wallet2), style: {
      animationDelay: `${i2 * 50}ms`
    }, children: [jsx(WalletIcon, { "$outline": true, children: icon }), jsx(WalletLabel, { children: shortName !== null && shortName !== void 0 ? shortName : name2 })] }, i2);
  }), jsxs(WalletItem, { onClick: openW3M, "$waiting": isOpenW3M, children: [jsx(WalletIcon, { style: { background: "var(--ck-body-background-secondary)" }, children: isOpenW3M ? jsx("div", { style: {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }, children: jsx("div", { style: {
    width: "50%"
  }, children: jsx(Spinner$4, {}) }) }) : MoreIcon }), jsx(WalletLabel, { children: locales.more })] })] }) }) }), ((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.walletConnectCTA) !== "modal" && jsx("div", { style: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    gap: 14,
    paddingTop: 8
  }, children: jsx(CopyToClipboard, { variant: "button", string: wcUri, children: locales.copyToClipboard }) })] }) });
};
const Content = styled(motion.div)`
  display: flex;
  flex-direction: column;
  gap: 6px;
  position: relative;
  left: 0;
  right: 0;
  ${ModalContent} {
    padding: 0 8px 32px;
    gap: 12px;
  }
`;
const dist$1 = 2;
const shakeKeyframes = We`
  0%{ transform:none; }
  25%{ transform:translateX(${dist$1}px); }
  50%{ transform:translateX(-${dist$1}px); }
  75%{ transform:translateX(${dist$1}px); }
  100%{ transform:none; }
`;
const outlineKeyframes = We`
  0%{ opacity:1; }
  100%{ opacity:0; }
`;
const Container$4 = styled(motion.div)`
  /*
  background: var(
    --ck-body-background
  ); // To stop the overlay issue during transition for the squircle spinner
  */
`;
const ConnectingContainer = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 10px auto 16px;
  height: 120px;
  //transform: scale(1.001); // fixes shifting issue between states
`;
const ConnectingAnimation = styled(motion.div)`
  user-select: none;
  position: relative;
  --spinner-error-opacity: 0;
  &:before {
    content: '';
    position: absolute;
    inset: 1px;
    opacity: 0;
    background: var(--ck-body-color-danger);
    ${(props) => props.$circle && Ae`
        inset: -5px;
        border-radius: 50%;
        background: none;
        box-shadow: inset 0 0 0 3.5px var(--ck-body-color-danger);
      `}
  }
  ${(props) => props.$shake && Ae`
      animation: ${shakeKeyframes} 220ms ease-out both;
      &:before {
        animation: ${outlineKeyframes} 220ms ease-out 750ms both;
      }
    `}
`;
const RetryButton = styled(motion.button)`
  z-index: 5;
  appearance: none;
  position: absolute;
  right: 2px;
  bottom: 2px;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 16px;
  cursor: pointer;
  overflow: hidden;
  background: none;

  color: var(--ck-body-background);
  transition: color 200ms ease;
  box-shadow: 0px 2px 6px rgba(0, 0, 0, 0.15);

  &:before {
    z-index: 3;
    content: '';
    position: absolute;
    inset: 0;
    opacity: 0;
    transition: opacity 200ms ease;
    background: var(--ck-body-color);
  }

  &:hover:before {
    opacity: 0.1;
  }
`;
const RetryIconContainer = styled(motion.div)`
  position: absolute;
  inset: 0;

  &:before {
    z-index: 1;
    content: '';
    position: absolute;
    inset: 3px;
    border-radius: 16px;
    background: conic-gradient(
      from 90deg,
      currentColor 10%,
      var(--ck-body-color) 80%
    );
  }

  svg {
    z-index: 2;
    display: block;
    position: relative;
    width: 100%;
    height: 100%;
  }
`;
const TooltipWindow = styled(motion.div)`
  z-index: 2147483647;
  position: fixed;
  inset: 0;
  pointer-events: none;
`;
const TooltipContainer = styled(motion.div)`
  --shadow: var(--ck-tooltip-shadow);
  z-index: 2147483647;
  position: absolute;
  top: 0;
  left: 0;
  display: flex;
  gap: 8px;
  width: fit-content;
  align-items: center;
  justify-content: center;
  border-radius: var(
    --ck-tooltip-border-radius,
    ${(props) => props.$size === "small" ? 11 : 14}px
  );
  border-radius: ;
  padding: 10px 16px 10px 12px;
  font-size: 14px;
  line-height: 19px;
  font-weight: 500;
  letter-spacing: -0.1px;
  color: var(--ck-tooltip-color);
  background: var(--ck-tooltip-background);
  box-shadow: var(--shadow);
  > span {
    z-index: 3;
    position: relative;
  }
  > div {
    margin: -4px 0; // offset for icon
  }
  strong {
    color: var(--ck-spinner-color);
  }

  .ck-tt-logo {
    display: inline-block;
    vertical-align: text-bottom;
    height: 1em;
    width: 1.25em;
    svg {
      display: block;
      height: 100%;
      transform: translate(0.5px, -1px) scale(1.75);
    }
  }
`;
const TooltipTail = styled(motion.div)`
  z-index: 2;
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: ${(props) => props.$size === "small" ? 14 : 18}px;
  right: 100%;
  top: 0;
  bottom: 0;
  overflow: hidden;
  &:before {
    content: '';
    position: absolute;
    box-shadow: var(--shadow);
    width: ${(props) => props.$size === "small" ? 14 : 18}px;
    height: ${(props) => props.$size === "small" ? 14 : 18}px;
    transform: translate(75%, 0) rotate(45deg);
    background: var(--ck-tooltip-background);
    border-radius: ${(props) => props.$size === "small" ? 2 : 3}px 0 0 0;
  }
`;
const Tooltip = ({ children, message, open, xOffset = 0, yOffset = 0, delay: delay2 }) => {
  var _a2;
  const context = useContext();
  const themeContext = useThemeContext();
  if ((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.hideTooltips)
    return jsx(Fragment$2, { children });
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [outOfBounds, setOutOfBounds] = reactExports.useState(false);
  const [size2, setSize] = reactExports.useState("small");
  const [ready, setReady] = reactExports.useState(false);
  const [currentRoute] = reactExports.useState(context.route);
  const targetRef = reactExports.useRef(null);
  const [ref, bounds] = useMeasure({
    debounce: !ready ? 220 : 0,
    offsetSize: true,
    scroll: true
  });
  const checkBounds = () => {
    let flag = false;
    const x2 = xOffset + bounds.left + bounds.width;
    const y2 = yOffset + bounds.top + bounds.height * 0.5;
    if (x2 > window.innerWidth || x2 < 0 || y2 > window.innerHeight || y2 < 0) {
      flag = true;
    }
    return flag;
  };
  const useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  const refreshLayout = () => {
    if (!targetRef.current || bounds.top + bounds.bottom + bounds.left + bounds.right + bounds.height + bounds.width === 0)
      return;
    const x2 = xOffset + bounds.left + bounds.width;
    const y2 = yOffset + bounds.top + bounds.height * 0.5;
    if (!ready && x2 !== 0 && y2 !== 0)
      setReady(true);
    targetRef.current.style.left = `${x2}px`;
    targetRef.current.style.top = `${y2}px`;
    setSize(targetRef.current.offsetHeight <= 40 ? "small" : "large");
    setOutOfBounds(checkBounds());
  };
  useIsomorphicLayoutEffect2(refreshLayout, [bounds, open, isOpen]);
  reactExports.useEffect(() => {
    if (!context.open)
      setIsOpen(false);
  }, [context.open]);
  reactExports.useEffect(() => {
    setIsOpen(!!open);
  }, [open]);
  return jsxs(Fragment$2, { children: [jsx(motion.div, { ref, style: open === void 0 ? {
    cursor: "help"
  } : {}, onHoverStart: () => setIsOpen(true), onHoverEnd: () => setIsOpen(false), onClick: () => setIsOpen(false), children }), jsx(Portal, { children: jsx(AnimatePresence, { children: currentRoute === context.route && !outOfBounds && isOpen && jsx(ResetContainer, { "$useTheme": themeContext.theme, "$useMode": themeContext.mode, "$customTheme": themeContext.customTheme, children: jsx(TooltipWindow, { children: jsxs(TooltipContainer, { role: "tooltip", "$size": size2, ref: targetRef, initial: "collapsed", animate: ready ? "open" : {}, exit: "collapsed", variants: {
    collapsed: {
      transformOrigin: "20px 50%",
      opacity: 0,
      scale: 0.9,
      z: 0.01,
      y: "-50%",
      x: 20,
      transition: {
        duration: 0.1
      }
    },
    open: {
      willChange: "opacity,transform",
      opacity: 1,
      scale: 1,
      z: 0.01,
      y: "-50%",
      x: 20,
      transition: {
        ease: [0.76, 0, 0.24, 1],
        duration: 0.15,
        delay: delay2 ? delay2 : 0.5
      }
    }
  }, children: [message, jsx(TooltipTail, { "$size": size2 })] }) }) }) }) })] });
};
const LogoContainer$4 = styled(motion.div)`
  z-index: 4;
  position: relative;
  overflow: hidden;
  svg {
    z-index: 3;
    position: relative;
    display: block;
  }
`;
const Logo$1 = styled(motion.div)`
  z-index: 2;
  position: absolute;
  overflow: hidden;
  inset: 6px;
  border-radius: 24px;
  background: var(--ck-body-background);
  svg,
  img {
    pointer-events: none;
    display: block;
    width: 100%;
    height: 100%;
  }
`;
const SpinnerContainer$1 = styled(motion.div)`
  position: absolute;
  inset: 1px;
  overflow: hidden;
`;
const Spinner$3 = styled(motion.div)`
  pointer-events: none;
  user-select: none;
  z-index: 1;
  position: absolute;
  inset: -25%;
  &:before {
    content: '';
    position: absolute;
    inset: 0;
    background: conic-gradient(
      from -90deg,
      transparent,
      transparent,
      transparent,
      transparent,
      transparent,
      var(--ck-spinner-color)
    );
    animation: rotateSpinner 1200ms linear infinite;
  }
  @keyframes rotateSpinner {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;
const SquircleSpinner = ({ logo, connecting = true }) => {
  return jsxs(LogoContainer$4, { transition: { duration: 0.5, ease: [0.175, 0.885, 0.32, 0.98] }, children: [jsx(Logo$1, { children: logo }), jsx(SpinnerContainer$1, { children: jsx(AnimatePresence, { children: connecting && jsx(Spinner$3, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: {
    opacity: 0,
    transition: {
      duration: 0
    }
  } }, "Spinner") }) }), jsxs("svg", { "aria-hidden": "true", width: "102", height: "102", viewBox: "0 0 102 102", fill: "none", children: [jsx("rect", { x: "7.57895", y: "7.57895", width: "86.8421", height: "86.8421", rx: "19.2211", stroke: "black", strokeOpacity: "0.02", strokeWidth: "1.15789" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0 0H102V102H0V0ZM7 38.284C7 27.5684 7 22.2106 9.01905 18.0892C10.9522 14.1431 14.1431 10.9522 18.0892 9.01905C22.2106 7 27.5684 7 38.284 7H63.716C74.4316 7 79.7894 7 83.9108 9.01905C87.8569 10.9522 91.0478 14.1431 92.9809 18.0892C95 22.2106 95 27.5684 95 38.284V63.716C95 74.4316 95 79.7894 92.9809 83.9108C91.0478 87.8569 87.8569 91.0478 83.9108 92.9809C79.7894 95 74.4316 95 63.716 95H38.284C27.5684 95 22.2106 95 18.0892 92.9809C14.1431 91.0478 10.9522 87.8569 9.01905 83.9108C7 79.7894 7 74.4316 7 63.716V38.284ZM41.5 0.5H41.4325C34.7246 0.499996 29.6023 0.499994 25.5104 0.823325C21.388 1.14906 18.1839 1.80986 15.3416 3.20227C10.0602 5.78959 5.78959 10.0602 3.20227 15.3416C1.80986 18.1839 1.14906 21.388 0.823325 25.5104C0.499994 29.6023 0.499996 34.7246 0.5 41.4325V41.5V55.5938C0.5 55.6808 0.507407 55.766 0.521624 55.849C0.507407 55.9319 0.5 56.0172 0.5 56.1042V60.5V60.5675C0.499996 67.2754 0.499994 72.3977 0.823325 76.4896C1.14906 80.612 1.80986 83.8161 3.20227 86.6584C5.78959 91.9398 10.0602 96.2104 15.3416 98.7977C18.1839 100.19 21.388 100.851 25.5104 101.177C29.6022 101.5 34.7244 101.5 41.432 101.5H41.4324H41.5H43.4227H60.5H60.5675H60.568C67.2756 101.5 72.3977 101.5 76.4896 101.177C80.612 100.851 83.8161 100.19 86.6584 98.7977C91.9398 96.2104 96.2104 91.9398 98.7977 86.6584C100.19 83.8161 100.851 80.612 101.177 76.4896C101.5 72.3978 101.5 67.2756 101.5 60.568V60.5676V60.5V41.5V41.4324V41.432C101.5 34.7244 101.5 29.6022 101.177 25.5104C100.851 21.388 100.19 18.1839 98.7977 15.3416C96.2104 10.0602 91.9398 5.78959 86.6584 3.20227C83.8161 1.80986 80.612 1.14906 76.4896 0.823325C72.3977 0.499994 67.2754 0.499996 60.5675 0.5H60.5H41.5ZM3.5 56.1042C3.5 56.0172 3.49259 55.9319 3.47838 55.849C3.49259 55.766 3.5 55.6808 3.5 55.5938V41.5C3.5 34.7112 3.50109 29.7068 3.814 25.7467C4.1256 21.8032 4.73946 19.0229 5.89635 16.6614C8.19077 11.9779 11.9779 8.19077 16.6614 5.89635C19.0229 4.73946 21.8032 4.1256 25.7467 3.814C29.7068 3.50109 34.7112 3.5 41.5 3.5H60.5C67.2888 3.5 72.2932 3.50109 76.2533 3.814C80.1968 4.1256 82.977 4.73946 85.3386 5.89635C90.022 8.19077 93.8092 11.9779 96.1036 16.6614C97.2605 19.0229 97.8744 21.8032 98.186 25.7467C98.4989 29.7068 98.5 34.7112 98.5 41.5V60.5C98.5 67.2888 98.4989 72.2932 98.186 76.2533C97.8744 80.1968 97.2605 82.9771 96.1036 85.3386C93.8092 90.022 90.022 93.8092 85.3386 96.1036C82.977 97.2605 80.1968 97.8744 76.2533 98.186C72.2932 98.4989 67.2888 98.5 60.5 98.5H43.4227H41.5C34.7112 98.5 29.7068 98.4989 25.7467 98.186C21.8032 97.8744 19.0229 97.2605 16.6614 96.1036C11.9779 93.8092 8.19077 90.022 5.89635 85.3386C4.73946 82.9771 4.1256 80.1968 3.814 76.2533C3.50109 72.2932 3.5 67.2888 3.5 60.5V56.1042Z", fill: "var(--ck-body-background)" })] })] });
};
const BrowserIconContainer = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  max-width: 32px;
  max-height: 32px;
  width: 100%;
  height: 100%;
  svg {
    display: block;
    width: 100%;
    height: 100%;
  }
`;
const Chrome = jsxs("svg", { "aria-hidden": "true", width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("g", { filter: "url(#filter0_ii_927_5781)", children: jsxs("g", { clipPath: "url(#clip0_927_5781)", children: [jsx("path", { d: "M1.58771 0V12.2727H6.06498L10.0002 5.45455H20.0002V0H1.58771Z", fill: "#DB4437" }), jsx("path", { d: "M1.58771 0V12.2727H6.06498L10.0002 5.45455H20.0002V0H1.58771Z", fill: "url(#paint0_linear_927_5781)" }), jsx("path", { d: "M6.17038 12.2272L1.64538 4.46582L1.57947 4.57946L6.07265 12.284L6.17038 12.2272Z", fill: "black", fillOpacity: "0.15" }), jsx("path", { d: "M0 20.0003H9.51932L13.9375 15.5821V12.273H6.0625L0 1.87305V20.0003Z", fill: "#0F9D58" }), jsx("path", { d: "M0 20.0003H9.51932L13.9375 15.5821V12.273H6.0625L0 1.87305V20.0003Z", fill: "url(#paint1_linear_927_5781)" }), jsx("path", { d: "M13.8412 12.4208L13.7469 12.3662L9.38324 19.9969H9.51392L13.8435 12.4242L13.8412 12.4208Z", fill: "#263238", fillOpacity: "0.15" }), jsx("path", { d: "M10.0006 5.45459L13.9381 12.2728L9.51996 20H20.0006V5.45459H10.0006Z", fill: "#FFCD40" }), jsx("path", { d: "M10.0006 5.45459L13.9381 12.2728L9.51996 20H20.0006V5.45459H10.0006Z", fill: "url(#paint2_linear_927_5781)" }), jsx("path", { d: "M9.9996 5.45459L13.9371 12.2728L9.51892 20H19.9996V5.45459H9.9996Z", fill: "#FFCD40" }), jsx("path", { d: "M9.9996 5.45459L13.9371 12.2728L9.51892 20H19.9996V5.45459H9.9996Z", fill: "url(#paint3_linear_927_5781)" }), jsx("path", { d: "M1.58691 0V12.2727H6.06419L9.99941 5.45455H19.9994V0H1.58691Z", fill: "#DB4437" }), jsx("path", { d: "M1.58691 0V12.2727H6.06419L9.99941 5.45455H19.9994V0H1.58691Z", fill: "url(#paint4_linear_927_5781)" }), jsx("path", { d: "M10 5.45459V7.83527L18.9091 5.45459H10Z", fill: "url(#paint5_radial_927_5781)" }), jsx("path", { d: "M0 19.9998H9.51932L11.9318 15.9089L13.9375 12.2726H6.0625L0 1.87256V19.9998Z", fill: "#0F9D58" }), jsx("path", { d: "M0 19.9998H9.51932L12.1023 15.5112L13.9375 12.2726H6.0625L0 1.87256V19.9998Z", fill: "url(#paint6_linear_927_5781)" }), jsx("path", { d: "M1.58771 4.59668L8.09339 11.1012L6.06384 12.2728L1.58771 4.59668Z", fill: "url(#paint7_radial_927_5781)" }), jsx("path", { d: "M9.52661 19.9884L11.9084 11.1021L13.938 12.2725L9.52661 19.9884Z", fill: "url(#paint8_radial_927_5781)" }), jsx("path", { d: "M10.0003 14.5455C12.5107 14.5455 14.5458 12.5104 14.5458 10C14.5458 7.48966 12.5107 5.45459 10.0003 5.45459C7.48996 5.45459 5.4549 7.48966 5.4549 10C5.4549 12.5104 7.48996 14.5455 10.0003 14.5455Z", fill: "#F1F1F1" }), jsx("path", { d: "M9.99995 13.6365C12.0083 13.6365 13.6363 12.0084 13.6363 10.0001C13.6363 7.99183 12.0083 6.36377 9.99995 6.36377C7.99164 6.36377 6.36359 7.99183 6.36359 10.0001C6.36359 12.0084 7.99164 13.6365 9.99995 13.6365Z", fill: "#4285F4" }), jsx("path", { d: "M10.0003 5.34082C7.48899 5.34082 5.4549 7.37491 5.4549 9.88628V9.99991C5.4549 7.48855 7.48899 5.45446 10.0003 5.45446H20.0003V5.34082H10.0003Z", fill: "black", fillOpacity: "0.2" }), jsx("path", { d: "M13.9318 12.273C13.1455 13.6299 11.6818 14.5458 10 14.5458C8.31818 14.5458 6.85227 13.6299 6.06818 12.273H6.06364L0 1.87305V1.98668L6.06818 12.3867C6.85455 13.7435 8.31818 14.6594 10 14.6594C11.6818 14.6594 13.1455 13.7446 13.9318 12.3867H13.9375V12.273H13.9307H13.9318Z", fill: "white", fillOpacity: "0.1" }), jsx("path", { opacity: "0.1", d: "M10.1133 5.45459C10.094 5.45459 10.0758 5.45686 10.0565 5.458C12.5406 5.48868 14.5452 7.50913 14.5452 10C14.5452 12.491 12.5406 14.5114 10.0565 14.5421C10.0758 14.5421 10.094 14.5455 10.1133 14.5455C12.6247 14.5455 14.6588 12.5114 14.6588 10C14.6588 7.48868 12.6247 5.45459 10.1133 5.45459Z", fill: "black" }), jsx("path", { d: "M13.9769 12.4204C14.3632 11.7522 14.5871 10.9795 14.5871 10.1522C14.5874 9.68602 14.5157 9.22262 14.3746 8.77832C14.4826 9.16696 14.5451 9.57377 14.5451 9.99764C14.5451 10.8249 14.3212 11.5976 13.9348 12.2658L13.9371 12.2704L9.51892 19.9976H9.65074L13.9769 12.4204Z", fill: "white", fillOpacity: "0.2" }), jsx("path", { d: "M10 0.113636C15.5034 0.113636 19.9682 4.56023 20 10.0568C20 10.0375 20.0011 10.0193 20.0011 10C20.0011 4.47727 15.5239 0 10.0011 0C4.47841 0 0 4.47727 0 10C0 10.0193 0.00113639 10.0375 0.00113639 10.0568C0.0318182 4.56023 4.49659 0.113636 10 0.113636Z", fill: "white", fillOpacity: "0.2" }), jsx("path", { d: "M10 19.8865C15.5034 19.8865 19.9682 15.4399 20 9.94336C20 9.96268 20.0011 9.98086 20.0011 10.0002C20.0011 15.5229 15.5239 20.0002 10.0011 20.0002C4.47841 20.0002 0 15.5229 0 10.0002C0 9.98086 0.00113639 9.96268 0.00113639 9.94336C0.0318182 15.4399 4.49659 19.8865 10.0011 19.8865H10Z", fill: "black", fillOpacity: "0.15" })] }) }), jsxs("defs", { children: [jsxs("filter", { id: "filter0_ii_927_5781", x: 0, y: "-0.235294", width: 20, height: "20.4706", filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB", children: [jsx("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), jsx("feOffset", { dy: "0.235294" }), jsx("feGaussianBlur", { stdDeviation: "0.235294" }), jsx("feComposite", { in2: "hardAlpha", operator: "arithmetic", k2: -1, k3: 1 }), jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.25 0" }), jsx("feBlend", { mode: "normal", in2: "shape", result: "effect1_innerShadow_927_5781" }), jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), jsx("feOffset", { dy: "-0.235294" }), jsx("feGaussianBlur", { stdDeviation: "0.235294" }), jsx("feComposite", { in2: "hardAlpha", operator: "arithmetic", k2: -1, k3: 1 }), jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.12 0" }), jsx("feBlend", { mode: "normal", in2: "effect1_innerShadow_927_5781", result: "effect2_innerShadow_927_5781" })] }), jsxs("linearGradient", { id: "paint0_linear_927_5781", x1: "2.42521", y1: "7.61591", x2: "8.39112", y2: "4.13068", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#A52714", stopOpacity: "0.6" }), jsx("stop", { offset: "0.66", stopColor: "#A52714", stopOpacity: 0 })] }), jsxs("linearGradient", { id: "paint1_linear_927_5781", x1: "11.6932", y1: "17.7844", x2: "5.06136", y2: "13.8981", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#055524", stopOpacity: "0.4" }), jsx("stop", { offset: "0.33", stopColor: "#055524", stopOpacity: 0 })] }), jsxs("linearGradient", { id: "paint2_linear_927_5781", x1: "12.9438", y1: "4.75004", x2: "14.6143", y2: "12.0569", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#EA6100", stopOpacity: "0.3" }), jsx("stop", { offset: "0.66", stopColor: "#EA6100", stopOpacity: 0 })] }), jsxs("linearGradient", { id: "paint3_linear_927_5781", x1: "12.9428", y1: "4.75004", x2: "14.6132", y2: "12.0569", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#EA6100", stopOpacity: "0.3" }), jsx("stop", { offset: "0.66", stopColor: "#EA6100", stopOpacity: 0 })] }), jsxs("linearGradient", { id: "paint4_linear_927_5781", x1: "2.42441", y1: "7.61591", x2: "8.39032", y2: "4.13068", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#A52714", stopOpacity: "0.6" }), jsx("stop", { offset: "0.66", stopColor: "#A52714", stopOpacity: 0 })] }), jsxs("radialGradient", { id: "paint5_radial_927_5781", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.56818 5.44891) scale(9.55455)", children: [jsx("stop", { stopColor: "#3E2723", stopOpacity: "0.2" }), jsx("stop", { offset: 1, stopColor: "#3E2723", stopOpacity: 0 })] }), jsxs("linearGradient", { id: "paint6_linear_927_5781", x1: "11.6932", y1: "17.7839", x2: "5.06136", y2: "13.8976", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#055524", stopOpacity: "0.4" }), jsx("stop", { offset: "0.33", stopColor: "#055524", stopOpacity: 0 })] }), jsxs("radialGradient", { id: "paint7_radial_927_5781", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(1.57975 4.60463) scale(8.86818)", children: [jsx("stop", { stopColor: "#3E2723", stopOpacity: "0.2" }), jsx("stop", { offset: 1, stopColor: "#3E2723", stopOpacity: 0 })] }), jsxs("radialGradient", { id: "paint8_radial_927_5781", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.97775 10.0157) scale(9.98523)", children: [jsx("stop", { stopColor: "#263238", stopOpacity: "0.2" }), jsx("stop", { offset: 1, stopColor: "#263238", stopOpacity: 0 })] }), jsx("clipPath", { id: "clip0_927_5781", children: jsx("rect", { width: 20, height: 20, rx: 10, fill: "white" }) })] })] });
const FireFox = jsxs("svg", { "aria-hidden": "true", width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxs("g", { clipPath: "url(#clip0_927_5847)", children: [jsx("path", { d: "M19.011 6.71023C18.5898 5.69685 17.7355 4.60269 17.0665 4.25681C17.5436 5.18063 17.8747 6.17276 18.0481 7.19792L18.0499 7.21417C16.954 4.48315 15.0963 3.38023 13.5782 0.981835C13.5014 0.860539 13.4246 0.738994 13.3498 0.610696C13.3071 0.537418 13.2728 0.471393 13.2431 0.410621C13.1801 0.288713 13.1316 0.159878 13.0985 0.0267267C13.0985 0.0205825 13.0963 0.0146369 13.0923 0.0100242C13.0882 0.00541151 13.0826 0.00245454 13.0765 0.00171737C13.0705 7.85858e-05 13.0642 7.85858e-05 13.0582 0.00171737C13.057 0.00171737 13.055 0.00396821 13.0535 0.0044684C13.052 0.00496859 13.0487 0.00721943 13.0465 0.00821981L13.0502 0.00171737C10.6156 1.42725 9.78901 4.06574 9.71399 5.38624C8.74136 5.45292 7.81141 5.81121 7.04549 6.41437C6.96561 6.34671 6.88212 6.28343 6.79539 6.2248C6.57456 5.45174 6.56514 4.6336 6.76813 3.85566C5.87401 4.28877 5.07954 4.90279 4.43501 5.65884H4.43051C4.04636 5.17191 4.07337 3.5663 4.09538 3.23093C3.98174 3.2766 3.87326 3.33419 3.77176 3.40274C3.43264 3.64477 3.11562 3.91635 2.8244 4.2143C2.49255 4.55075 2.18946 4.91441 1.91831 5.30146V5.30296V5.3012C1.29521 6.18444 0.853213 7.18234 0.617826 8.23731L0.604821 8.30133C0.586564 8.38661 0.52079 8.81377 0.509535 8.90656C0.509535 8.91381 0.508035 8.92056 0.507285 8.92781C0.42244 9.36882 0.369864 9.81542 0.349976 10.2641V10.3141C0.354259 12.7396 1.26772 15.0754 2.91002 16.8604C4.55233 18.6454 6.80415 19.7498 9.22094 19.9556C11.6377 20.1615 14.0439 19.4538 15.9644 17.9723C17.8849 16.4908 19.1803 14.3431 19.5947 11.9532C19.6109 11.8282 19.6242 11.7044 19.6387 11.5781C19.8384 9.92791 19.6222 8.25404 19.01 6.70873L19.011 6.71023ZM7.83928 14.2981C7.88455 14.3198 7.92707 14.3433 7.97358 14.3641L7.98034 14.3684C7.93332 14.3458 7.8863 14.3224 7.83928 14.2981ZM18.0501 7.21692V7.20767L18.0519 7.21792L18.0501 7.21692Z", fill: "url(#paint0_linear_927_5847)" }), jsx("path", { d: "M19.0109 6.71026C18.5898 5.69688 17.7354 4.60272 17.0664 4.25684C17.5435 5.18066 17.8746 6.17278 18.0481 7.19794V7.20719L18.0498 7.21745C18.797 9.35551 18.689 11.6997 17.7482 13.7599C16.6373 16.1435 13.9493 18.5867 9.7402 18.4667C5.19349 18.3379 1.18699 14.9629 0.439211 10.5437C0.30291 9.84668 0.439211 9.4933 0.507737 8.92684C0.414265 9.36685 0.362102 9.81463 0.351929 10.2643V10.3144C0.356212 12.7399 1.26967 15.0757 2.91198 16.8607C4.55429 18.6456 6.8061 19.7501 9.2229 19.9559C11.6397 20.1617 14.0458 19.4541 15.9664 17.9725C17.8869 16.491 19.1822 14.3434 19.5966 11.9535C19.6129 11.8284 19.6262 11.7046 19.6407 11.5783C19.8403 9.92819 19.6242 8.25431 19.0119 6.70901L19.0109 6.71026Z", fill: "url(#paint1_radial_927_5847)" }), jsx("path", { d: "M19.0109 6.71026C18.5898 5.69688 17.7354 4.60272 17.0664 4.25684C17.5435 5.18066 17.8746 6.17278 18.0481 7.19794V7.20719L18.0498 7.21745C18.797 9.35551 18.689 11.6997 17.7482 13.7599C16.6373 16.1435 13.9493 18.5867 9.7402 18.4667C5.19349 18.3379 1.18699 14.9629 0.439211 10.5437C0.30291 9.84668 0.439211 9.4933 0.507737 8.92684C0.414265 9.36685 0.362102 9.81463 0.351929 10.2643V10.3144C0.356212 12.7399 1.26967 15.0757 2.91198 16.8607C4.55429 18.6456 6.8061 19.7501 9.2229 19.9559C11.6397 20.1617 14.0458 19.4541 15.9664 17.9725C17.8869 16.491 19.1822 14.3434 19.5966 11.9535C19.6129 11.8284 19.6262 11.7046 19.6407 11.5783C19.8403 9.92819 19.6242 8.25431 19.0119 6.70901L19.0109 6.71026Z", fill: "url(#paint2_radial_927_5847)" }), jsx("path", { d: "M14.2993 7.84794C14.3203 7.8627 14.3398 7.87745 14.3595 7.89221C14.1161 7.46047 13.813 7.06519 13.4592 6.71802C10.4456 3.70439 12.6696 0.18557 13.0445 0.00550206L13.0483 0C10.6136 1.42553 9.78706 4.06402 9.71204 5.38452C9.82508 5.37677 9.93712 5.36726 10.0527 5.36726C10.9164 5.36893 11.7644 5.59929 12.5103 6.03492C13.2562 6.47055 13.8734 7.09592 14.2993 7.84744V7.84794Z", fill: "url(#paint3_radial_927_5847)" }), jsx("path", { d: "M10.0577 8.45061C10.0417 8.6917 9.18992 9.52326 8.89206 9.52326C6.13602 9.52326 5.68835 11.1906 5.68835 11.1906C5.8104 12.5947 6.78877 13.7516 7.97146 14.3618C8.02548 14.3898 8.08025 14.4151 8.13502 14.4399C8.22989 14.4819 8.32476 14.5207 8.41963 14.5564C8.82553 14.7 9.25065 14.7821 9.68085 14.7997C14.5127 15.0263 15.448 9.02257 11.9615 7.27942C12.7839 7.1724 13.6168 7.37463 14.2986 7.84688C13.8727 7.09536 13.2555 6.46999 12.5096 6.03436C11.7637 5.59873 10.9158 5.36837 10.052 5.3667C9.93695 5.3667 9.82441 5.3762 9.71136 5.38396C8.73874 5.45064 7.80879 5.80893 7.04286 6.41209C7.19067 6.53714 7.35748 6.7042 7.70886 7.05058C8.36661 7.69857 10.0535 8.36983 10.0572 8.44861L10.0577 8.45061Z", fill: "url(#paint4_radial_927_5847)" }), jsx("path", { d: "M10.0577 8.45061C10.0417 8.6917 9.18992 9.52326 8.89206 9.52326C6.13602 9.52326 5.68835 11.1906 5.68835 11.1906C5.8104 12.5947 6.78877 13.7516 7.97146 14.3618C8.02548 14.3898 8.08025 14.4151 8.13502 14.4399C8.22989 14.4819 8.32476 14.5207 8.41963 14.5564C8.82553 14.7 9.25065 14.7821 9.68085 14.7997C14.5127 15.0263 15.448 9.02257 11.9615 7.27942C12.7839 7.1724 13.6168 7.37463 14.2986 7.84688C13.8727 7.09536 13.2555 6.46999 12.5096 6.03436C11.7637 5.59873 10.9158 5.36837 10.052 5.3667C9.93695 5.3667 9.82441 5.3762 9.71136 5.38396C8.73874 5.45064 7.80879 5.80893 7.04286 6.41209C7.19067 6.53714 7.35748 6.7042 7.70886 7.05058C8.36661 7.69857 10.0535 8.36983 10.0572 8.44861L10.0577 8.45061Z", fill: "url(#paint5_radial_927_5847)" }), jsx("path", { d: "M6.59134 6.0923C6.66987 6.14231 6.73464 6.18583 6.79141 6.2251C6.57058 5.45204 6.56117 4.63389 6.76415 3.85596C5.87003 4.28907 5.07556 4.90308 4.43103 5.65913C4.4783 5.65788 5.88432 5.63262 6.59134 6.0923Z", fill: "url(#paint6_radial_927_5847)" }), jsx("path", { d: "M0.437567 10.5439C1.1856 14.963 5.19185 18.3393 9.73855 18.4668C13.9476 18.5859 16.6361 16.1425 17.7466 13.7601C18.6873 11.6998 18.7954 9.35569 18.0482 7.21762V7.20837C18.0482 7.20111 18.0467 7.19686 18.0482 7.19911L18.0499 7.21537C18.3938 9.46046 17.2519 11.6345 15.4665 13.1076L15.4609 13.1201C11.9821 15.9536 8.6534 14.8292 7.98064 14.3706C7.93363 14.348 7.88661 14.3246 7.83959 14.3003C5.81158 13.3309 4.97352 11.4842 5.15358 9.89862C4.67218 9.90573 4.19905 9.77307 3.79151 9.51672C3.38397 9.26038 3.05952 8.89134 2.85747 8.45433C3.38987 8.1282 3.99692 7.94382 4.62077 7.91878C5.24461 7.89374 5.86448 8.02887 6.42131 8.31128C7.56906 8.83225 8.87507 8.8836 10.0602 8.45433C10.0564 8.37555 8.36954 7.70405 7.71179 7.05631C7.36041 6.70993 7.1936 6.54312 7.04579 6.41782C6.96591 6.35016 6.88243 6.28688 6.7957 6.22825C6.73818 6.18898 6.6734 6.14647 6.59562 6.09545C5.88861 5.63578 4.48258 5.66104 4.43607 5.66229H4.43156C4.04742 5.17535 4.07443 3.56975 4.09644 3.23438C3.9828 3.28005 3.87431 3.33764 3.77282 3.40619C3.4337 3.64822 3.11667 3.91979 2.82546 4.21774C2.49242 4.55325 2.18808 4.91607 1.91562 5.3024V5.3039V5.30215C1.29252 6.18539 0.850521 7.18329 0.615133 8.23825C0.610381 8.25801 0.266002 9.76357 0.435816 10.5444L0.437567 10.5439Z", fill: "url(#paint7_radial_927_5847)" }), jsx("path", { d: "M13.459 6.71761C13.8128 7.06516 14.1159 7.46087 14.3593 7.89305C14.4126 7.93331 14.4624 7.97333 14.5046 8.01209C16.7022 10.0378 15.5508 12.9014 15.465 13.104C17.2502 11.6332 18.3911 9.45763 18.0485 7.21179C16.952 4.47826 15.0923 3.37535 13.5768 0.976952C13.5 0.855657 13.4232 0.734111 13.3484 0.605813C13.3057 0.532535 13.2714 0.466511 13.2417 0.405738C13.1787 0.283831 13.1302 0.154995 13.0971 0.0218439C13.0971 0.0156997 13.0949 0.0097541 13.0909 0.0051414C13.0868 0.000528701 13.0812 -0.00242828 13.0751 -0.00316545C13.0691 -0.00480423 13.0628 -0.00480423 13.0568 -0.00316545C13.0556 -0.00316545 13.0536 -0.000914601 13.0521 -0.000414413C13.0506 8.57743e-05 13.0473 0.00233662 13.0451 0.00333699C12.6702 0.181154 10.4466 3.70222 13.4602 6.71335L13.459 6.71761Z", fill: "url(#paint8_radial_927_5847)" }), jsx("path", { d: "M14.5043 8.01315C14.462 7.97439 14.4122 7.93437 14.359 7.8941C14.3392 7.87935 14.3197 7.86459 14.2987 7.84984C13.6169 7.37759 12.784 7.17536 11.9616 7.28238C15.4479 9.02553 14.5125 15.0278 9.68095 14.8027C9.25075 14.785 8.82562 14.703 8.41973 14.5594C8.32486 14.5238 8.22999 14.485 8.13512 14.4428C8.08035 14.4178 8.02558 14.3928 7.97156 14.3648L7.97831 14.369C8.65206 14.829 11.9798 15.9526 15.4586 13.1186L15.4641 13.1061C15.5509 12.9035 16.7023 10.0399 14.5038 8.01415L14.5043 8.01315Z", fill: "url(#paint9_radial_927_5847)" }), jsx("path", { d: "M5.68842 11.1892C5.68842 11.1892 6.13583 9.52179 8.89212 9.52179C9.18998 9.52179 10.0425 8.69023 10.0578 8.44914C8.8727 8.8784 7.56669 8.82706 6.41894 8.30608C5.86211 8.02367 5.24224 7.88855 4.61839 7.91359C3.99455 7.93863 3.3875 8.123 2.8551 8.44914C3.05715 8.88615 3.3816 9.25518 3.78914 9.51153C4.19668 9.76787 4.66981 9.90053 5.15121 9.89343C4.97165 11.4783 5.80946 13.3247 7.83722 14.2951C7.88249 14.3168 7.925 14.3403 7.97152 14.3611C6.78783 13.7496 5.81046 12.5932 5.68842 11.1899V11.1892Z", fill: "url(#paint10_radial_927_5847)" }), jsx("path", { d: "M19.0112 6.71023C18.59 5.69685 17.7357 4.60269 17.0667 4.25681C17.5438 5.18063 17.8749 6.17276 18.0483 7.19792L18.0501 7.21417C16.9542 4.48315 15.0965 3.38023 13.5784 0.981835C13.5016 0.860539 13.4249 0.738994 13.3501 0.610696C13.3073 0.537418 13.2731 0.471393 13.2433 0.410621C13.1803 0.288713 13.1318 0.159878 13.0987 0.0267267C13.0988 0.0205825 13.0966 0.0146369 13.0925 0.0100242C13.0884 0.00541151 13.0828 0.00245454 13.0767 0.00171737C13.0708 7.85859e-05 13.0644 7.85859e-05 13.0585 0.00171737C13.0572 0.00171737 13.0552 0.00396821 13.0537 0.0044684C13.0522 0.00496859 13.049 0.00721943 13.0467 0.00821981L13.0505 0.00171737C10.6158 1.42725 9.78925 4.06574 9.71422 5.38624C9.82726 5.37848 9.9393 5.36898 10.0548 5.36898C10.9186 5.37065 11.7666 5.60101 12.5125 6.03664C13.2584 6.47227 13.8756 7.09764 14.3014 7.84916C13.6196 7.37691 12.7868 7.17468 11.9643 7.2817C15.4506 9.02485 14.5153 15.0271 9.68371 14.802C9.25351 14.7843 8.82838 14.7023 8.42248 14.5587C8.32761 14.5232 8.23275 14.4843 8.13788 14.4421C8.08311 14.4171 8.02834 14.3921 7.97432 14.3641L7.98107 14.3684C7.93405 14.3458 7.88703 14.3224 7.84002 14.2981C7.88528 14.3198 7.9278 14.3433 7.97432 14.3641C6.79062 13.7524 5.81326 12.5959 5.69121 11.1929C5.69121 11.1929 6.13863 9.52554 8.89491 9.52554C9.19277 9.52554 10.0453 8.69398 10.0606 8.45289C10.0568 8.37411 8.36996 7.7026 7.71222 7.05486C7.36084 6.70848 7.19402 6.54167 7.04622 6.41637C6.96634 6.34871 6.88285 6.28543 6.79612 6.2268C6.57529 5.45374 6.56588 4.6356 6.76886 3.85766C5.87474 4.29077 5.08027 4.90479 4.43574 5.66084H4.43124C4.04709 5.17391 4.0741 3.5683 4.09611 3.23293C3.98247 3.2786 3.87399 3.33619 3.77249 3.40474C3.43337 3.64677 3.11635 3.91835 2.82514 4.2163C2.49328 4.55275 2.19019 4.91641 1.91905 5.30345V5.30496V5.30321C1.29595 6.18644 0.853946 7.18434 0.618558 8.23931L0.605554 8.30333C0.587297 8.38861 0.505516 8.82177 0.493762 8.91481C0.418959 9.36194 0.371188 9.81318 0.350708 10.2661V10.3161C0.354992 12.7416 1.26845 15.0774 2.91076 16.8624C4.55307 18.6474 6.80488 19.7518 9.22168 19.9576C11.6385 20.1635 14.0446 19.4558 15.9652 17.9743C17.8857 16.4928 19.181 14.3451 19.5954 11.9552C19.6117 11.8302 19.6249 11.7064 19.6394 11.5801C19.8391 9.92991 19.623 8.25604 19.0107 6.71073L19.0112 6.71023ZM18.0496 7.20817L18.0513 7.21842L18.0496 7.20817Z", fill: "url(#paint11_linear_927_5847)" })] }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_927_5847", x1: "17.728", y1: "3.09786", x2: "1.63621", y2: "18.6237", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { offset: "0.048", stopColor: "#FFF44F" }), jsx("stop", { offset: "0.111", stopColor: "#FFE847" }), jsx("stop", { offset: "0.225", stopColor: "#FFC830" }), jsx("stop", { offset: "0.368", stopColor: "#FF980E" }), jsx("stop", { offset: "0.401", stopColor: "#FF8B16" }), jsx("stop", { offset: "0.462", stopColor: "#FF672A" }), jsx("stop", { offset: "0.534", stopColor: "#FF3647" }), jsx("stop", { offset: "0.705", stopColor: "#E31587" })] }), jsxs("radialGradient", { id: "paint1_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(17.1052 2.25108) scale(20.2076)", children: [jsx("stop", { offset: "0.129", stopColor: "#FFBD4F" }), jsx("stop", { offset: "0.186", stopColor: "#FFAC31" }), jsx("stop", { offset: "0.247", stopColor: "#FF9D17" }), jsx("stop", { offset: "0.283", stopColor: "#FF980E" }), jsx("stop", { offset: "0.403", stopColor: "#FF563B" }), jsx("stop", { offset: "0.467", stopColor: "#FF3750" }), jsx("stop", { offset: "0.71", stopColor: "#F5156C" }), jsx("stop", { offset: "0.782", stopColor: "#EB0878" }), jsx("stop", { offset: "0.86", stopColor: "#E50080" })] }), jsxs("radialGradient", { id: "paint2_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.6024 10.5042) scale(20.2076)", children: [jsx("stop", { offset: "0.3", stopColor: "#960E18" }), jsx("stop", { offset: "0.351", stopColor: "#B11927", stopOpacity: "0.74" }), jsx("stop", { offset: "0.435", stopColor: "#DB293D", stopOpacity: "0.343" }), jsx("stop", { offset: "0.497", stopColor: "#F5334B", stopOpacity: "0.094" }), jsx("stop", { offset: "0.53", stopColor: "#FF3750", stopOpacity: 0 })] }), jsxs("radialGradient", { id: "paint3_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(12.1034 -2.25084) scale(14.638)", children: [jsx("stop", { offset: "0.132", stopColor: "#FFF44F" }), jsx("stop", { offset: "0.252", stopColor: "#FFDC3E" }), jsx("stop", { offset: "0.506", stopColor: "#FF9D12" }), jsx("stop", { offset: "0.526", stopColor: "#FF980E" })] }), jsxs("radialGradient", { id: "paint4_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(7.35173 15.7558) scale(9.62111)", children: [jsx("stop", { offset: "0.353", stopColor: "#3A8EE6" }), jsx("stop", { offset: "0.472", stopColor: "#5C79F0" }), jsx("stop", { offset: "0.669", stopColor: "#9059FF" }), jsx("stop", { offset: 1, stopColor: "#C139E6" })] }), jsxs("radialGradient", { id: "paint5_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(10.5799 8.76923) rotate(-13.5916) scale(5.10194 5.97309)", children: [jsx("stop", { offset: "0.206", stopColor: "#9059FF", stopOpacity: 0 }), jsx("stop", { offset: "0.278", stopColor: "#8C4FF3", stopOpacity: "0.064" }), jsx("stop", { offset: "0.747", stopColor: "#7716A8", stopOpacity: "0.45" }), jsx("stop", { offset: "0.975", stopColor: "#6E008B", stopOpacity: "0.6" })] }), jsxs("radialGradient", { id: "paint6_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.35238 1.50057) scale(6.9226)", children: [jsx("stop", { stopColor: "#FFE226" }), jsx("stop", { offset: "0.121", stopColor: "#FFDB27" }), jsx("stop", { offset: "0.295", stopColor: "#FFC82A" }), jsx("stop", { offset: "0.502", stopColor: "#FFA930" }), jsx("stop", { offset: "0.732", stopColor: "#FF7E37" }), jsx("stop", { offset: "0.792", stopColor: "#FF7139" })] }), jsxs("radialGradient", { id: "paint7_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(14.8545 -3.00121) scale(29.5361)", children: [jsx("stop", { offset: "0.113", stopColor: "#FFF44F" }), jsx("stop", { offset: "0.456", stopColor: "#FF980E" }), jsx("stop", { offset: "0.622", stopColor: "#FF5634" }), jsx("stop", { offset: "0.716", stopColor: "#FF3647" }), jsx("stop", { offset: "0.904", stopColor: "#E31587" })] }), jsxs("radialGradient", { id: "paint8_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(12.3996 -1.36343) rotate(83.976) scale(21.6445 14.2051)", children: [jsx("stop", { stopColor: "#FFF44F" }), jsx("stop", { offset: "0.06", stopColor: "#FFE847" }), jsx("stop", { offset: "0.168", stopColor: "#FFC830" }), jsx("stop", { offset: "0.304", stopColor: "#FF980E" }), jsx("stop", { offset: "0.356", stopColor: "#FF8B16" }), jsx("stop", { offset: "0.455", stopColor: "#FF672A" }), jsx("stop", { offset: "0.57", stopColor: "#FF3647" }), jsx("stop", { offset: "0.737", stopColor: "#E31587" })] }), jsxs("radialGradient", { id: "paint9_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.35233 4.00165) scale(18.4369)", children: [jsx("stop", { offset: "0.137", stopColor: "#FFF44F" }), jsx("stop", { offset: "0.48", stopColor: "#FF980E" }), jsx("stop", { offset: "0.592", stopColor: "#FF5634" }), jsx("stop", { offset: "0.655", stopColor: "#FF3647" }), jsx("stop", { offset: "0.904", stopColor: "#E31587" })] }), jsxs("radialGradient", { id: "paint10_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(14.1041 5.00184) scale(20.1801)", children: [jsx("stop", { offset: "0.094", stopColor: "#FFF44F" }), jsx("stop", { offset: "0.231", stopColor: "#FFE141" }), jsx("stop", { offset: "0.509", stopColor: "#FFAF1E" }), jsx("stop", { offset: "0.626", stopColor: "#FF980E" })] }), jsxs("linearGradient", { id: "paint11_linear_927_5847", x1: "17.5331", y1: "3.01533", x2: "3.84302", y2: "16.708", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { offset: "0.167", stopColor: "#FFF44F", stopOpacity: "0.8" }), jsx("stop", { offset: "0.266", stopColor: "#FFF44F", stopOpacity: "0.634" }), jsx("stop", { offset: "0.489", stopColor: "#FFF44F", stopOpacity: "0.217" }), jsx("stop", { offset: "0.6", stopColor: "#FFF44F", stopOpacity: 0 })] }), jsx("clipPath", { id: "clip0_927_5847", children: jsx("rect", { width: 20, height: 20, fill: "white" }) })] })] });
const Brave = jsxs("svg", { "aria-hidden": "true", width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M17.2924 5.22043L17.7256 4.15905L16.4982 2.8883C15.8339 2.22404 14.4187 2.61393 14.4187 2.61393L12.8158 0.794434H7.16242L5.55231 2.62115C5.55231 2.62115 4.13715 2.23848 3.47289 2.8883L2.24545 4.15183L2.67866 5.21321L2.13715 6.78721L3.9422 13.6681C4.31765 15.141 4.57036 15.7114 5.63173 16.4623L8.93137 18.7006C9.24906 18.8955 9.63895 19.2349 9.99274 19.2349C10.3465 19.2349 10.7364 18.8955 11.0541 18.7006L14.3538 16.4623C15.4151 15.7114 15.6678 15.141 16.0433 13.6681L17.8483 6.78721L17.2924 5.22043Z", fill: "url(#paint0_linear_927_5861)" }), jsx("path", { d: "M13.9711 3.78343C13.9711 3.78343 16.0433 6.28884 16.0433 6.81592C16.0433 7.35744 15.7834 7.49462 15.5234 7.77621L13.9711 9.43686C13.8267 9.58126 13.5162 9.82675 13.6967 10.2527C13.8772 10.686 14.1299 11.2203 13.8411 11.769C13.5523 12.3249 13.0469 12.6932 12.722 12.6354C12.2387 12.4786 11.7777 12.2602 11.3502 11.9856C11.0758 11.8051 10.1949 11.0758 10.1949 10.7943C10.1949 10.5127 11.1047 10 11.278 9.89895C11.444 9.78343 12.2166 9.33577 12.231 9.16249C12.2455 8.9892 12.2455 8.94588 12.0144 8.51267C11.7834 8.07946 11.379 7.50184 11.4368 7.12639C11.509 6.75094 12.1588 6.54877 12.6426 6.36827L14.1372 5.80509C14.2527 5.74733 14.2238 5.69679 13.8772 5.66068C13.5307 5.6318 12.5559 5.50184 12.1155 5.62458C11.6751 5.74733 10.9386 5.93505 10.8664 6.03614C10.8086 6.13722 10.7509 6.13722 10.8159 6.48379L11.2346 8.75816C11.2635 9.04697 11.3213 9.24191 11.018 9.31411C10.7003 9.38632 10.1733 9.50906 9.99276 9.50906C9.81225 9.50906 9.27796 9.38632 8.96749 9.31411C8.65702 9.24191 8.71478 9.04697 8.75088 8.75816C8.77976 8.46935 9.09745 6.82314 9.16243 6.48379C9.23464 6.13722 9.16965 6.13722 9.11189 6.03614C9.03969 5.93505 8.29601 5.74733 7.85558 5.62458C7.42236 5.50184 6.44041 5.6318 6.09384 5.66791C5.74727 5.69679 5.71839 5.74011 5.83391 5.81231L7.3285 6.36827C7.80503 6.54877 8.46929 6.75094 8.53428 7.12639C8.60648 7.50906 8.19493 8.07946 7.95666 8.51267C7.71839 8.94588 7.72561 8.9892 7.74005 9.16249C7.75449 9.33577 8.53428 9.78343 8.69312 9.89895C8.86641 10.0073 9.77615 10.5127 9.77615 10.7943C9.77615 11.0758 8.91695 11.8051 8.62814 11.9856C8.20063 12.2602 7.73957 12.4786 7.2563 12.6354C6.93139 12.6932 6.42597 12.3249 6.12994 11.769C5.84113 11.2203 6.10106 10.686 6.27435 10.2527C6.45485 9.81953 6.1516 9.58848 5.99998 9.43686L4.44763 7.77621C4.19493 7.50906 3.935 7.36466 3.935 6.83036C3.935 6.29606 6.0072 3.79787 6.0072 3.79787L7.97832 4.11556C8.20937 4.11556 8.722 3.92061 9.19132 3.75455C9.66063 3.61014 9.98554 3.5957 9.98554 3.5957C9.98554 3.5957 10.3032 3.5957 10.7798 3.75455C11.2563 3.91339 11.7617 4.11556 11.9928 4.11556C12.231 4.11556 13.9783 3.77621 13.9783 3.77621L13.9711 3.78343ZM12.4188 13.3719C12.5487 13.4441 12.4693 13.6029 12.3465 13.6896L10.5126 15.1192C10.3682 15.2636 10.1372 15.4802 9.98554 15.4802C9.83391 15.4802 9.61009 15.2636 9.45846 15.1192C8.8506 14.6351 8.23683 14.1586 7.61731 13.6896C7.50178 13.6029 7.42236 13.4513 7.54511 13.3719L8.62814 12.7943C9.05864 12.5665 9.51417 12.3897 9.98554 12.2672C10.0938 12.2672 10.7798 12.5127 11.3357 12.7943L12.4188 13.3719Z", fill: "white" }), jsx("path", { d: "M14.4332 2.62115L12.8159 0.794434H7.16243L5.55232 2.62115C5.55232 2.62115 4.13716 2.23848 3.4729 2.8883C3.4729 2.8883 5.35016 2.72223 5.99998 3.77638L7.99276 4.11573C8.2238 4.11573 8.73644 3.92079 9.20575 3.75472C9.67507 3.61032 9.99998 3.59588 9.99998 3.59588C9.99998 3.59588 10.3177 3.59588 10.7942 3.75472C11.2707 3.91357 11.7761 4.11573 12.0072 4.11573C12.2455 4.11573 13.9928 3.77638 13.9928 3.77638C14.6426 2.72223 16.5198 2.8883 16.5198 2.8883C15.8556 2.22404 14.4404 2.61393 14.4404 2.61393", fill: "url(#paint1_linear_927_5861)" }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_927_5861", x1: "2.13715", y1: "10.1991", x2: "17.8483", y2: "10.1991", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { offset: "0.4", stopColor: "#FF5500" }), jsx("stop", { offset: "0.6", stopColor: "#FF2000" })] }), jsxs("linearGradient", { id: "paint1_linear_927_5861", x1: "3.73384", y1: "2.4883", x2: "16.5198", y2: "2.4883", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#FF452A" }), jsx("stop", { offset: 1, stopColor: "#FF2000" })] })] })] });
const Edge = jsxs("svg", { "aria-hidden": "true", width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxs("g", { clipPath: "url(#clip0_927_5865)", children: [jsx("path", { d: "M18.0547 14.8828C17.7865 15.0222 17.5099 15.1448 17.2266 15.25C16.3293 15.584 15.3792 15.7533 14.4219 15.75C10.7266 15.75 7.50781 13.2109 7.50781 9.94531C7.51262 9.50803 7.63385 9.07993 7.85905 8.70506C8.08424 8.33019 8.40526 8.0221 8.78906 7.8125C5.44531 7.95312 4.58594 11.4375 4.58594 13.4766C4.58594 19.2578 9.90625 19.8359 11.0547 19.8359C11.6719 19.8359 12.6016 19.6562 13.1641 19.4766L13.2656 19.4453C15.4183 18.7014 17.2534 17.2465 18.4688 15.3203C18.5041 15.2618 18.5192 15.1933 18.5119 15.1253C18.5046 15.0574 18.4752 14.9937 18.4282 14.944C18.3812 14.8944 18.3192 14.8615 18.2518 14.8505C18.1843 14.8394 18.1151 14.8508 18.0547 14.8828Z", fill: "url(#paint0_linear_927_5865)" }), jsx("path", { opacity: "0.35", d: "M18.0547 14.8828C17.7865 15.0222 17.5099 15.1448 17.2266 15.25C16.3293 15.584 15.3792 15.7533 14.4219 15.75C10.7266 15.75 7.50781 13.2109 7.50781 9.94531C7.51262 9.50803 7.63385 9.07993 7.85905 8.70506C8.08424 8.33019 8.40526 8.0221 8.78906 7.8125C5.44531 7.95312 4.58594 11.4375 4.58594 13.4766C4.58594 19.2578 9.90625 19.8359 11.0547 19.8359C11.6719 19.8359 12.6016 19.6562 13.1641 19.4766L13.2656 19.4453C15.4183 18.7014 17.2534 17.2465 18.4688 15.3203C18.5041 15.2618 18.5192 15.1933 18.5119 15.1253C18.5046 15.0574 18.4752 14.9937 18.4282 14.944C18.3812 14.8944 18.3192 14.8615 18.2518 14.8505C18.1843 14.8394 18.1151 14.8508 18.0547 14.8828Z", fill: "url(#paint1_radial_927_5865)" }), jsx("path", { d: "M8.2578 18.8516C7.56239 18.4196 6.95961 17.854 6.48436 17.1875C5.94166 16.4447 5.56809 15.5921 5.38987 14.6896C5.21165 13.787 5.23311 12.8565 5.45272 11.9631C5.67234 11.0697 6.08479 10.2353 6.66115 9.51826C7.23751 8.80123 7.96379 8.21903 8.78905 7.8125C9.03905 7.69531 9.45311 7.49219 10.0078 7.5C10.3981 7.50302 10.7824 7.59627 11.1308 7.77245C11.4791 7.94864 11.7819 8.20299 12.0156 8.51562C12.3299 8.93835 12.5023 9.4498 12.5078 9.97656C12.5078 9.96094 14.4219 3.75781 6.2578 3.75781C2.82811 3.75781 0.00780015 7.00781 0.00780015 9.86719C-0.00584162 11.3776 0.317079 12.8721 0.953112 14.2422C1.99473 16.4602 3.81447 18.2185 6.06689 19.1834C8.3193 20.1483 10.8476 20.2526 13.1719 19.4766C12.3576 19.7337 11.4972 19.811 10.6501 19.7031C9.80297 19.5952 8.98941 19.3047 8.26561 18.8516H8.2578Z", fill: "url(#paint2_linear_927_5865)" }), jsx("path", { opacity: "0.41", d: "M8.2578 18.8516C7.56239 18.4196 6.95961 17.854 6.48436 17.1875C5.94166 16.4447 5.56809 15.5921 5.38987 14.6896C5.21165 13.787 5.23311 12.8565 5.45272 11.9631C5.67234 11.0697 6.08479 10.2353 6.66115 9.51826C7.23751 8.80123 7.96379 8.21903 8.78905 7.8125C9.03905 7.69531 9.45311 7.49219 10.0078 7.5C10.3981 7.50302 10.7824 7.59627 11.1308 7.77245C11.4791 7.94864 11.7819 8.20299 12.0156 8.51562C12.3299 8.93835 12.5023 9.4498 12.5078 9.97656C12.5078 9.96094 14.4219 3.75781 6.2578 3.75781C2.82811 3.75781 0.00780015 7.00781 0.00780015 9.86719C-0.00584162 11.3776 0.317079 12.8721 0.953112 14.2422C1.99473 16.4602 3.81447 18.2185 6.06689 19.1834C8.3193 20.1483 10.8476 20.2526 13.1719 19.4766C12.3576 19.7337 11.4972 19.811 10.6501 19.7031C9.80297 19.5952 8.98941 19.3047 8.26561 18.8516H8.2578Z", fill: "url(#paint3_radial_927_5865)" }), jsx("path", { d: "M11.9062 11.625C11.8359 11.7031 11.6406 11.8203 11.6406 12.0625C11.6406 12.2656 11.7734 12.4688 12.0156 12.6328C13.1328 13.4141 15.25 13.3047 15.2578 13.3047C16.0907 13.3041 16.9081 13.0802 17.625 12.6562C18.3467 12.2341 18.9456 11.6307 19.3622 10.9057C19.7788 10.1808 19.9986 9.35955 20 8.52344C20.0234 6.77344 19.375 5.60937 19.1172 5.09375C17.4531 1.85937 13.8828 4.89564e-08 10 4.89564e-08C7.37202 -0.00025981 4.84956 1.03398 2.97819 2.87904C1.10682 4.7241 0.0369559 7.23166 0 9.85938C0.0390625 7.00781 2.875 4.70312 6.25 4.70312C6.52344 4.70312 8.08594 4.72656 9.53125 5.48438C10.5466 5.98895 11.3875 6.78627 11.9453 7.77344C12.4219 8.60156 12.5078 9.65625 12.5078 10.0781C12.5078 10.5 12.2969 11.1172 11.8984 11.6328L11.9062 11.625Z", fill: "url(#paint4_radial_927_5865)" }), jsx("path", { d: "M11.9062 11.625C11.8359 11.7031 11.6406 11.8203 11.6406 12.0625C11.6406 12.2656 11.7734 12.4688 12.0156 12.6328C13.1328 13.4141 15.25 13.3047 15.2578 13.3047C16.0907 13.3041 16.9081 13.0802 17.625 12.6562C18.3467 12.2341 18.9456 11.6307 19.3622 10.9057C19.7788 10.1808 19.9986 9.35955 20 8.52344C20.0234 6.77344 19.375 5.60937 19.1172 5.09375C17.4531 1.85937 13.8828 4.89564e-08 10 4.89564e-08C7.37202 -0.00025981 4.84956 1.03398 2.97819 2.87904C1.10682 4.7241 0.0369559 7.23166 0 9.85938C0.0390625 7.00781 2.875 4.70312 6.25 4.70312C6.52344 4.70312 8.08594 4.72656 9.53125 5.48438C10.5466 5.98895 11.3875 6.78627 11.9453 7.77344C12.4219 8.60156 12.5078 9.65625 12.5078 10.0781C12.5078 10.5 12.2969 11.1172 11.8984 11.6328L11.9062 11.625Z", fill: "url(#paint5_radial_927_5865)" })] }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_927_5865", x1: "4.58594", y1: "13.8281", x2: "18.5234", y2: "13.8281", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#0C59A4" }), jsx("stop", { offset: 1, stopColor: "#114A8B" })] }), jsxs("radialGradient", { id: "paint1_radial_927_5865", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(12.2813 13.9332) scale(7.45313 7.08047)", children: [jsx("stop", { offset: "0.7", stopOpacity: 0 }), jsx("stop", { offset: "0.9", stopOpacity: "0.5" }), jsx("stop", { offset: 1 })] }), jsxs("linearGradient", { id: "paint2_linear_927_5865", x1: "11.9297", y1: "7.78125", x2: "3.23436", y2: "17.2578", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#1B9DE2" }), jsx("stop", { offset: "0.2", stopColor: "#1595DF" }), jsx("stop", { offset: "0.7", stopColor: "#0680D7" }), jsx("stop", { offset: 1, stopColor: "#0078D4" })] }), jsxs("radialGradient", { id: "paint3_radial_927_5865", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(5.51209 15.5419) rotate(-81.3844) scale(11.202 9.05011)", children: [jsx("stop", { offset: "0.8", stopOpacity: 0 }), jsx("stop", { offset: "0.9", stopOpacity: "0.5" }), jsx("stop", { offset: 1 })] }), jsxs("radialGradient", { id: "paint4_radial_927_5865", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(2.02266 3.69656) rotate(92.2906) scale(15.8251 33.7043)", children: [jsx("stop", { stopColor: "#35C1F1" }), jsx("stop", { offset: "0.1", stopColor: "#34C1ED" }), jsx("stop", { offset: "0.2", stopColor: "#2FC2DF" }), jsx("stop", { offset: "0.3", stopColor: "#2BC3D2" }), jsx("stop", { offset: "0.7", stopColor: "#36C752" })] }), jsxs("radialGradient", { id: "paint5_radial_927_5865", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(18.7547 6.03906) rotate(73.7398) scale(7.60156 6.18159)", children: [jsx("stop", { stopColor: "#66EB6E" }), jsx("stop", { offset: 1, stopColor: "#66EB6E", stopOpacity: 0 })] }), jsx("clipPath", { id: "clip0_927_5865", children: jsx("rect", { width: 20, height: 20, fill: "white" }) })] })] });
var browsers = { Chrome, FireFox, Brave, Edge };
const BrowserIcon = React$1.forwardRef(({ browser: browser2 }, ref) => {
  const currentBrowser = browser2 !== null && browser2 !== void 0 ? browser2 : detectBrowser();
  let icon;
  switch (currentBrowser) {
    case "chrome":
      icon = browsers.Chrome;
      break;
    case "firefox":
      icon = browsers.FireFox;
      break;
    case "edge":
      icon = browsers.Edge;
      break;
  }
  if (!icon)
    return jsx(Fragment$2, {});
  return jsx(BrowserIconContainer, { children: icon });
});
BrowserIcon.displayName = "BrowserIcon";
const LogoContainer$3 = styled(motion.div)`
  z-index: 4;
  position: relative;
  width: 100px;
  height: 100px;
  svg {
    z-index: 3;
    position: relative;
    display: block;
  }
`;
const Logo = styled(motion.div)`
  z-index: 2;
  position: absolute;
  overflow: hidden;
  inset: 6px;
  border-radius: 50px;
  background: var(--ck-body-background);
  display: flex;
  align-items: center;
  justify-content: center;
  svg,
  img {
    pointer-events: none;
    display: block;
    margin: 0 auto;
    width: 100%;
    height: 100%;
    ${(props) => props.$small && Ae`
        width: 85%;
        height: 85%;
      `}
  }
`;
const SpinnerContainer = styled(motion.div)`
  position: absolute;
  inset: -5px;
`;
const ExpiringSpinner = styled(motion.div)`
  pointer-events: none;
  user-select: none;
  z-index: 1;
  position: absolute;
  inset: -25%;
  background: var(--ck-body-background);
  div:first-child {
    position: absolute;
    left: 50%;
    right: 0;
    top: 0;
    bottom: 0;
    overflow: hidden;
    &:before {
      position: absolute;
      content: '';
      inset: 0;
      background: var(--ck-spinner-color);
      transform-origin: 0% 50%;
      animation: rotateExpiringSpinner 5000ms ease-in both;
    }
  }
  div:last-child {
    position: absolute;
    left: 0;
    right: 50%;
    top: 0;
    bottom: 0;
    overflow: hidden;
    &:before {
      position: absolute;
      content: '';
      inset: 0;
      background: var(--ck-spinner-color);
      transform-origin: 100% 50%;
      animation: rotateExpiringSpinner 5000ms ease-out 5000ms both;
    }
  }
  @keyframes rotateExpiringSpinner {
    0% {
      transform: rotate(-180deg);
    }
    100% {
      transform: rotate(0deg);
    }
  }
`;
const Spinner$2 = styled(motion.div)`
  pointer-events: none;
  user-select: none;
  z-index: 1;
  position: absolute;
  inset: 0;
  svg {
    display: block;
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    animation: rotateSpinner 1200ms linear infinite;
  }
  @keyframes rotateSpinner {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;
const CircleSpinner = ({ logo, smallLogo, connecting = true, unavailable = false, countdown = false }) => {
  return jsxs(LogoContainer$3, { transition: { duration: 0.5, ease: [0.175, 0.885, 0.32, 0.98] }, children: [jsx(Logo, { "$small": !unavailable && smallLogo, style: unavailable ? { borderRadius: 0 } : void 0, children: logo }), jsx(SpinnerContainer, { children: jsxs(AnimatePresence, { children: [connecting && jsx(Spinner$2, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: {
    opacity: 0,
    transition: {
      duration: countdown ? 1 : 0
    }
  }, children: jsxs("svg", { "aria-hidden": "true", width: "102", height: "102", viewBox: "0 0 102 102", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M52 100C24.3858 100 2 77.6142 2 50", stroke: "url(#paint0_linear_1943_4139)", strokeWidth: "3.5", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_1943_4139", x1: "2", y1: "48.5", x2: "53", y2: "100", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "var(--ck-spinner-color)" }), jsx("stop", { offset: "1", stopColor: "var(--ck-spinner-color)", stopOpacity: "0" })] }) })] }) }, "Spinner"), countdown && jsxs(ExpiringSpinner, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.25 }, children: [jsx("div", {}), jsx("div", {})] }, "ExpiringSpinner")] }) })] });
};
const states$1 = {
  CONNECTED: "connected",
  CONNECTING: "connecting",
  EXPIRING: "expiring",
  FAILED: "failed",
  REJECTED: "rejected",
  NOTCONNECTED: "notconnected",
  UNAVAILABLE: "unavailable"
};
const contentVariants$1 = {
  initial: {
    willChange: "transform,opacity",
    position: "relative",
    opacity: 0,
    scale: 0.95
  },
  animate: {
    position: "relative",
    opacity: 1,
    scale: 1,
    transition: {
      ease: [0.16, 1, 0.3, 1],
      duration: 0.4,
      delay: 0.05,
      position: { delay: 0 }
    }
  },
  exit: {
    position: "absolute",
    opacity: 0,
    scale: 0.95,
    transition: {
      ease: [0.16, 1, 0.3, 1],
      duration: 0.3
    }
  }
};
const ConnectWithInjector = ({ switchConnectMethod, forceState }) => {
  var _a2, _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m;
  const { connect: connect2 } = useConnect({
    onMutate: (connector) => {
      if (connector.connector) {
        setStatus(states$1.CONNECTING);
      } else {
        setStatus(states$1.UNAVAILABLE);
      }
    },
    onError(err) {
      console.error(err);
    },
    onSettled(data2, error) {
      if (error) {
        setShowTryAgainTooltip(true);
        setTimeout(() => setShowTryAgainTooltip(false), 3500);
        if (error.code) {
          switch (error.code) {
            case -32002:
              setStatus(states$1.NOTCONNECTED);
              break;
            case 4001:
              setStatus(states$1.REJECTED);
              break;
            default:
              setStatus(states$1.FAILED);
              break;
          }
        } else {
          if (error.message) {
            switch (error.message) {
              case "User rejected request":
                setStatus(states$1.REJECTED);
                break;
              default:
                setStatus(states$1.FAILED);
                break;
            }
          }
        }
      }
      setTimeout(triggerResize, 100);
    }
  });
  const { triggerResize, connector: c2 } = useContext();
  const id2 = c2.id;
  const wallet2 = useWallet(id2, c2.name);
  const injectedWallet = useInjectedWallet();
  const walletInfo = isInjectedConnector(wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.id) && injectedWallet.enabled ? {
    name: injectedWallet.wallet.name,
    shortName: (_a2 = injectedWallet.wallet.shortName) !== null && _a2 !== void 0 ? _a2 : injectedWallet.wallet.name,
    icon: injectedWallet.wallet.icon,
    iconShape: (_c = (_b = injectedWallet.wallet) === null || _b === void 0 ? void 0 : _b.iconShape) !== null && _c !== void 0 ? _c : "circle",
    iconShouldShrink: (_d = injectedWallet.wallet.iconShouldShrink) !== null && _d !== void 0 ? _d : false
  } : {
    name: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.name,
    shortName: (_e2 = wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.shortName) !== null && _e2 !== void 0 ? _e2 : wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.name,
    icon: (_f = wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.iconConnector) !== null && _f !== void 0 ? _f : wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.icon,
    iconShape: (_g = wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.iconShape) !== null && _g !== void 0 ? _g : "circle",
    iconShouldShrink: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.iconShouldShrink
  };
  const [showTryAgainTooltip, setShowTryAgainTooltip] = reactExports.useState(false);
  const expiryDefault = 9;
  reactExports.useState(expiryDefault);
  const browser2 = detectBrowser();
  const extensionUrl = (_h = wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.downloadUrls) === null || _h === void 0 ? void 0 : _h[browser2];
  const suggestedExtension = (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.downloadUrls) ? {
    name: Object.keys(wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.downloadUrls)[0],
    label: ((_j = Object.keys(wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.downloadUrls)[0]) === null || _j === void 0 ? void 0 : _j.charAt(0).toUpperCase()) + ((_k = Object.keys(wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.downloadUrls)[0]) === null || _k === void 0 ? void 0 : _k.slice(1)),
    url: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.downloadUrls[Object.keys(wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.downloadUrls)[0]]
  } : void 0;
  const [status, setStatus] = reactExports.useState(forceState ? forceState : !(wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.isInstalled) ? states$1.UNAVAILABLE : states$1.CONNECTING);
  const locales = useLocales({
    CONNECTORNAME: walletInfo.name,
    CONNECTORSHORTNAME: (_l = walletInfo.shortName) !== null && _l !== void 0 ? _l : walletInfo.name,
    SUGGESTEDEXTENSIONBROWSER: (_m = suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.label) !== null && _m !== void 0 ? _m : "your browser"
  });
  const runConnect = async () => {
    if ((wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.isInstalled) && (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.connector)) {
      connect2({ connector: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.connector });
    } else {
      setStatus(states$1.UNAVAILABLE);
    }
  };
  let connectTimeout;
  reactExports.useEffect(() => {
    if (status === states$1.UNAVAILABLE)
      return;
    connectTimeout = setTimeout(runConnect, 600);
    return () => {
      clearTimeout(connectTimeout);
    };
  }, []);
  if (!wallet2) {
    return jsx(PageContent, { children: jsxs(Container$4, { children: [jsx(ModalHeading, { children: "Invalid State" }), jsx(ModalContent, { children: jsx(Alert, { children: "No connectors match the id given. This state should never happen." }) })] }) });
  }
  if (isWalletConnectConnector(wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.connector.id)) {
    return jsx(PageContent, { children: jsxs(Container$4, { children: [jsx(ModalHeading, { children: "Invalid State" }), jsx(ModalContent, { children: jsx(Alert, { children: "WalletConnect does not have an injection flow. This state should never happen." }) })] }) });
  }
  return jsx(PageContent, { children: jsxs(Container$4, { children: [jsx(ConnectingContainer, { children: jsxs(ConnectingAnimation, { "$shake": status === states$1.FAILED || status === states$1.REJECTED, "$circle": walletInfo.iconShape === "circle", children: [jsx(AnimatePresence, { children: (status === states$1.FAILED || status === states$1.REJECTED) && jsx(RetryButton, { "aria-label": "Retry", initial: { opacity: 0, scale: 0.8 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.8 }, whileTap: { scale: 0.9 }, transition: { duration: 0.1 }, onClick: runConnect, children: jsx(RetryIconContainer, { children: jsx(Tooltip, { open: showTryAgainTooltip && (status === states$1.FAILED || status === states$1.REJECTED), message: locales.tryAgainQuestion, xOffset: -6, children: jsx(RetryIconCircle, {}) }) }) }) }), walletInfo.iconShape === "circle" ? jsx(CircleSpinner, { logo: status === states$1.UNAVAILABLE ? jsx("div", { style: {
    transform: "scale(1.14)",
    position: "relative",
    width: "100%"
  }, children: walletInfo.icon }) : jsx(Fragment$2, { children: walletInfo.icon }), smallLogo: walletInfo.iconShouldShrink, connecting: status === states$1.CONNECTING, unavailable: status === states$1.UNAVAILABLE }) : jsx(SquircleSpinner, { logo: status === states$1.UNAVAILABLE ? jsx("div", { style: {
    transform: "scale(1.14)",
    position: "relative",
    width: "100%"
  }, children: walletInfo.icon }) : jsx(Fragment$2, { children: walletInfo.icon }), connecting: status === states$1.CONNECTING })] }) }), jsx(ModalContentContainer, { children: jsxs(AnimatePresence, { initial: false, children: [status === states$1.FAILED && jsxs(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: [jsxs(ModalContent, { children: [jsxs(ModalH1, { "$error": true, children: [jsx(AlertIcon, {}), locales.injectionScreen_failed_h1] }), jsx(ModalBody, { children: locales.injectionScreen_failed_p })] }), (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.createUri) && wallet2.id !== "coinbaseWallet" && jsxs(Fragment$2, { children: [jsx(OrDivider, {}), jsx(Button, { icon: jsx(Scan, {}), onClick: () => switchConnectMethod(id2), children: locales.scanTheQRCode })] })] }, states$1.FAILED), status === states$1.REJECTED && jsxs(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: [jsxs(ModalContent, { style: { paddingBottom: 28 }, children: [jsx(ModalH1, { children: locales.injectionScreen_rejected_h1 }), jsx(ModalBody, { children: locales.injectionScreen_rejected_p })] }), (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.createUri) && wallet2.id !== "coinbaseWallet" && jsxs(Fragment$2, { children: [jsx(OrDivider, {}), jsx(Button, { icon: jsx(Scan, {}), onClick: () => switchConnectMethod(id2), children: locales.scanTheQRCode })] })] }, states$1.REJECTED), (status === states$1.CONNECTING || status === states$1.EXPIRING) && jsx(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: jsxs(ModalContent, { style: { paddingBottom: 28 }, children: [jsx(ModalH1, { children: wallet2.connector.id === "injected" ? locales.injectionScreen_connecting_injected_h1 : locales.injectionScreen_connecting_h1 }), jsx(ModalBody, { children: wallet2.connector.id === "injected" ? locales.injectionScreen_connecting_injected_p : locales.injectionScreen_connecting_p })] }) }, states$1.CONNECTING), status === states$1.CONNECTED && jsx(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: jsxs(ModalContent, { children: [jsxs(ModalH1, { "$valid": true, children: [jsx(TickIcon, {}), " ", locales.injectionScreen_connected_h1] }), jsx(ModalBody, { children: locales.injectionScreen_connected_p })] }) }, states$1.CONNECTED), status === states$1.NOTCONNECTED && jsx(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: jsxs(ModalContent, { children: [jsx(ModalH1, { children: locales.injectionScreen_notconnected_h1 }), jsx(ModalBody, { children: locales.injectionScreen_notconnected_p })] }) }, states$1.NOTCONNECTED), status === states$1.UNAVAILABLE && jsx(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: !extensionUrl ? jsxs(Fragment$2, { children: [jsxs(ModalContent, { style: { paddingBottom: 12 }, children: [jsx(ModalH1, { children: locales.injectionScreen_unavailable_h1 }), jsx(ModalBody, { children: locales.injectionScreen_unavailable_p })] }), !wallet2.isInstalled && suggestedExtension && jsxs(Button, { href: suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.url, icon: jsx(BrowserIcon, { browser: suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.name }), children: ["Install on ", suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.label] })] }) : jsxs(Fragment$2, { children: [jsxs(ModalContent, { style: { paddingBottom: 18 }, children: [jsx(ModalH1, { children: locales.injectionScreen_install_h1 }), jsx(ModalBody, { children: locales.injectionScreen_install_p })] }), !wallet2.isInstalled && extensionUrl && jsx(Button, { href: extensionUrl, icon: jsx(BrowserIcon, {}), children: locales.installTheExtension })] }) }, states$1.UNAVAILABLE)] }) })] }) });
};
const QRCodeContainer = styled(motion.div)`
  z-index: 3;
  position: relative;
  overflow: hidden;
  height: 0;
  padding-bottom: 100% !important;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 1px 0 2px;
  border-radius: var(--ck-qr-border-radius, 24px);
  background: var(--ck-qr-background, transparent);
  box-shadow: 0 0 0 1px var(--ck-qr-border-color);
  backface-visibility: hidden;
  svg {
    display: block;
    max-width: 100%;
    width: 100%;
    height: auto;
  }
`;
const QRCodeContent = styled(motion.div)`
  position: absolute;
  inset: 13px;
  svg {
    width: 100% !important;
    height: auto !important;
  }
`;
const PlaceholderKeyframes$2 = We`
  0%{ background-position: 100% 0; }
  100%{ background-position: -100% 0; }
`;
const QRPlaceholder = styled(motion.div)`
  --color: var(--ck-qr-dot-color);
  --bg: var(--ck-qr-background, var(--ck-body-background));

  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  > div {
    z-index: 4;
    position: relative;
    width: 28%;
    height: 28%;
    border-radius: 20px;
    background: var(--bg);
    box-shadow: 0 0 0 7px var(--bg);
  }
  > span {
    z-index: 4;
    position: absolute;
    background: var(--color);
    border-radius: 12px;
    width: 13.25%;
    height: 13.25%;
    box-shadow: 0 0 0 4px var(--bg);
    &:before {
      content: '';
      position: absolute;
      inset: 9px;
      border-radius: 3px;
      box-shadow: 0 0 0 4px var(--bg);
    }
    &:nth-child(1) {
      top: 0;
      left: 0;
    }
    &:nth-child(2) {
      top: 0;
      right: 0;
    }
    &:nth-child(3) {
      bottom: 0;
      left: 0;
    }
  }
  &:before {
    z-index: 3;
    content: '';
    position: absolute;
    inset: 0;
    background: repeat;
    background-size: 1.888% 1.888%;
    background-image: radial-gradient(var(--color) 41%, transparent 41%);
  }
  &:after {
    z-index: 5;
    content: '';
    position: absolute;
    inset: 0;
    transform: scale(1.5) rotate(45deg);
    background-image: linear-gradient(
      90deg,
      rgba(255, 255, 255, 0) 50%,
      rgba(255, 255, 255, 1),
      rgba(255, 255, 255, 0)
    );
    background-size: 200% 100%;
    animation: ${PlaceholderKeyframes$2} 1000ms linear infinite both;
  }
`;
const LogoContainer$2 = styled(motion.div)`
  z-index: 6;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  transform: translateY(50%) scale(0.9999); // Shifting fix
`;
const LogoIcon = styled(motion.div)`
  z-index: 6;
  position: absolute;
  left: 50%;
  overflow: hidden;

  transform: translate(-50%, -50%) scale(0.9999); // Shifting fix

  svg {
    display: block;
    position: relative;
    width: 100%;
    height: 100%;
  }

  ${(props) => props.$wcLogo ? Ae`
          width: 29%;
          height: 20.5%;
        ` : Ae`
          width: 28%;
          height: 28%;
          border-radius: 17px;
          &:before {
            pointer-events: none;
            z-index: 2;
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.02);
          }
        `}
`;
const generateMatrix = (value, errorCorrectionLevel2) => {
  const arr = Array.prototype.slice.call(browser$1.create(value, { errorCorrectionLevel: errorCorrectionLevel2 }).modules.data, 0);
  const sqrt = Math.sqrt(arr.length);
  return arr.reduce((rows, key, index2) => (index2 % sqrt === 0 ? rows.push([key]) : rows[rows.length - 1].push(key)) && rows, []);
};
function QRCode({ ecl = "M", size: sizeProp = 200, uri, clearArea = false, image, imageBackground = "transparent" }) {
  const logoSize = clearArea ? 76 : 0;
  const size2 = sizeProp - 10 * 2;
  const dots = reactExports.useMemo(() => {
    const dots2 = [];
    const matrix = generateMatrix(uri, ecl);
    const cellSize = size2 / matrix.length;
    let qrList = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 }
    ];
    qrList.forEach(({ x: x2, y: y2 }) => {
      const x1 = (matrix.length - 7) * cellSize * x2;
      const y1 = (matrix.length - 7) * cellSize * y2;
      for (let i2 = 0; i2 < 3; i2++) {
        dots2.push(jsx("rect", { fill: i2 % 2 !== 0 ? "var(--ck-qr-background, var(--ck-body-background))" : "var(--ck-qr-dot-color)", rx: (i2 - 2) * -5 + (i2 === 0 ? 2 : 3), ry: (i2 - 2) * -5 + (i2 === 0 ? 2 : 3), width: cellSize * (7 - i2 * 2), height: cellSize * (7 - i2 * 2), x: x1 + cellSize * i2, y: y1 + cellSize * i2 }, `${i2}-${x2}-${y2}`));
      }
    });
    if (image) {
      const x1 = (matrix.length - 7) * cellSize * 1;
      const y1 = (matrix.length - 7) * cellSize * 1;
      dots2.push(jsxs(Fragment$2, { children: [jsx("rect", { fill: imageBackground, rx: (0 - 2) * -5 + 2, ry: (0 - 2) * -5 + 2, width: cellSize * (7 - 0 * 2), height: cellSize * (7 - 0 * 2), x: x1 + cellSize * 0, y: y1 + cellSize * 0 }), jsx("foreignObject", { width: cellSize * (7 - 0 * 2), height: cellSize * (7 - 0 * 2), x: x1 + cellSize * 0, y: y1 + cellSize * 0, children: jsx("div", { style: { borderRadius: (0 - 2) * -5 + 2, overflow: "hidden" }, children: image }) })] }));
    }
    const clearArenaSize = Math.floor((logoSize + 25) / cellSize);
    const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
    const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
    matrix.forEach((row, i2) => {
      row.forEach((_2, j2) => {
        if (matrix[i2][j2]) {
          if (!(i2 < 7 && j2 < 7 || i2 > matrix.length - 8 && j2 < 7 || i2 < 7 && j2 > matrix.length - 8)) {
            if (image || !(i2 > matrixMiddleStart && i2 < matrixMiddleEnd && j2 > matrixMiddleStart && j2 < matrixMiddleEnd)) {
              dots2.push(jsx("circle", { cx: i2 * cellSize + cellSize / 2, cy: j2 * cellSize + cellSize / 2, fill: "var(--ck-qr-dot-color)", r: cellSize / 3 }, `circle-${i2}-${j2}`));
            }
          }
        }
      });
    });
    return dots2;
  }, [ecl, size2, uri]);
  return jsxs("svg", { height: size2, width: size2, viewBox: `0 0 ${size2} ${size2}`, style: {
    width: size2,
    height: size2
  }, children: [jsx("rect", { fill: "transparent", height: size2, width: size2 }), dots] });
}
function useWindowSize() {
  const [windowSize, setWindowSize] = reactExports.useState({
    width: 0,
    height: 0
  });
  reactExports.useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }
    window.addEventListener("resize", handleResize);
    handleResize();
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return windowSize;
}
function CustomQRCode({ value, image, imageBackground, imagePosition = "center", tooltipMessage }) {
  const windowSize = useWindowSize();
  const Logo2 = windowSize.width > 920 && tooltipMessage ? jsx(Tooltip, { xOffset: 139, yOffset: 5, delay: 0.1, message: tooltipMessage, children: image }) : image;
  return jsx(QRCodeContainer, { children: jsxs(QRCodeContent, { children: [image && jsx(LogoContainer$2, { children: jsx(LogoIcon, { "$wcLogo": imagePosition !== "center", style: {
    background: imagePosition === "center" ? imageBackground : void 0
  }, children: Logo2 }) }), jsx(AnimatePresence, { initial: false, children: value ? jsx(motion.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0, position: "absolute", inset: [0, 0] }, transition: {
    duration: 0.2
  }, children: jsx(QRCode, { uri: value, size: 288, ecl: "M", clearArea: !!(imagePosition === "center" && image) }) }, value) : jsxs(QRPlaceholder, { initial: { opacity: 0.1 }, animate: { opacity: 0.1 }, exit: { opacity: 0, position: "absolute", inset: [0, 0] }, transition: {
    duration: 0.2
  }, children: [jsx("span", {}), jsx("span", {}), jsx("span", {}), jsx("div", {})] }) })] }) });
}
CustomQRCode.displayName = "CustomQRCode";
const IconContainer$1 = styled(motion.div)`
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 47px;
  height: 52px;
  min-width: 47px;
  min-height: 52px;
  svg {
    display: block;
    max-width: 100%;
    height: auto;
  }
`;
const ScanIconWithLogos = ({ logo }) => {
  const logoList = [
    jsx(Logos.MetaMask, { background: true }),
    jsx(Logos.Coinbase, { background: true }),
    jsx(Logos.Crypto, {}),
    jsx(Logos.ImToken, {}),
    jsx(Logos.Argent, {}),
    jsx(Logos.Trust, {})
  ];
  return jsx(IconContainer$1, { children: jsxs("svg", { "aria-hidden": "true", width: "47", height: "52", viewBox: "0 0 47 52", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxs("g", { mask: "url(#gradient-mask)", children: [jsx("path", { d: "M7 14.5C7 11.4624 9.46243 9 12.5 9H31.5C34.5376 9 37 11.4624 37 14.5V47H7V14.5Z", fill: "var(--ck-graphic-scaniconwithlogos-04)" }), logo ? jsx("foreignObject", { x: "13", y: "21", width: "18", height: "18", rx: "5", children: jsx("div", { style: { overflow: "hidden", borderRadius: 5 }, children: logo }) }) : jsxs(Fragment$2, { children: [jsx("foreignObject", { x: "12", y: "15", width: "9", height: "9", rx: "2.5", children: jsx("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[0] }) }), jsx("foreignObject", { x: "23", y: "15", width: "9", height: "9", rx: "2.5", children: jsx("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[1] }) }), jsx("foreignObject", { x: "12", y: "26", width: "9", height: "9", rx: "2.5", children: jsx("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: jsx("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[2] }) }) }), jsx("foreignObject", { x: "23", y: "26", width: "9", height: "9", rx: "2.5", children: jsx("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[3] }) }), jsx("foreignObject", { x: "12", y: "37", width: "9", height: "9", rx: "2.5", children: jsx("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[4] }) }), jsx("foreignObject", { x: "23", y: "37", width: "9", height: "9", rx: "2.5", children: jsx("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[5] }) })] }), jsx("path", { d: "M36 47V13.7143C36 11.1107 33.8893 9 31.2857 9H12.7143C10.1107 9 8 11.1107 8 13.7143V47", stroke: "url(#paint0_linear_924_12568)", strokeWidth: "2" }), jsx("path", { d: "M15 10H29C29 11.1046 28.1046 12 27 12H17C15.8954 12 15 11.1046 15 10Z", fill: "var(--ck-graphic-scaniconwithlogos-01)" }), jsx("rect", { x: "1", y: "47", width: "43", height: "5", fill: "var(--ck-tooltip-background)" }), jsx("rect", { x: "22", y: "1", width: "24", height: "24", rx: "12", fill: "var(--ck-graphic-scaniconwithlogos-03)", stroke: "var(--ck-tooltip-background)", strokeWidth: "2" }), jsx("rect", { x: "34.5", y: "10", width: "2.5", height: "2.5", rx: "0.75", fill: "#373737" }), jsx("rect", { x: "31", y: "10", width: "2.5", height: "2.5", rx: "0.75", fill: "#373737" }), jsx("rect", { x: "31", y: "13.5", width: "2.5", height: "2.5", rx: "0.75", fill: "#373737" }), jsx("rect", { x: "34.5", y: "13.5", width: "2.5", height: "2.5", rx: "0.75", fill: "#373737" }), jsx("path", { d: "M28.5 10.5V9C28.5 8.17157 29.1716 7.5 30 7.5H31.5", stroke: "#373737", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M36.5 7.5L38 7.5C38.8284 7.5 39.5 8.17157 39.5 9L39.5 10.5", stroke: "#373737", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M39.5 15.5L39.5 17C39.5 17.8284 38.8284 18.5 38 18.5L36.5 18.5", stroke: "#373737", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M31.5 18.5L30 18.5C29.1716 18.5 28.5 17.8284 28.5 17L28.5 15.5", stroke: "#373737", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })] }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_924_12568", x1: "22", y1: "8.2549", x2: "22", y2: "47", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "var(--ck-graphic-scaniconwithlogos-01)" }), jsx("stop", { offset: "1", stopColor: "var(--ck-graphic-scaniconwithlogos-02)" })] }), jsxs("linearGradient", { id: "linear-gradient-mask", x1: "47", y1: "42", x2: "47", y2: "47", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "white" }), jsx("stop", { offset: "1", stopColor: "black", stopOpacity: "0" })] }), jsx("mask", { id: "gradient-mask", children: jsx("rect", { x: "0", y: "0", width: "47", height: "52", fill: "url(#linear-gradient-mask)" }) })] })] }) });
};
function useCoinbaseWalletUri() {
  const [uri, setUri] = reactExports.useState(void 0);
  const context = useContext();
  const connector = useCoinbaseWalletConnector();
  const { connectAsync } = useConnect();
  reactExports.useEffect(() => {
    async function handleMessage(e2) {
      context.log("CBW Message", e2);
      if (connector) {
        if (e2.type === "connecting") {
          const p2 = await connector.getProvider();
          setUri(p2.qrUrl);
        }
      }
    }
    if (connector) {
      context.log("add cbw listeners");
      connectCoinbaseWallet(connector);
      connector.on("message", handleMessage);
      return () => {
        context.log("remove cbw listeners");
        connector.off("message", handleMessage);
      };
    }
  }, [connector]);
  async function connectWallet(connector2) {
    const result = await connectAsync({ connector: connector2 });
    if (result)
      return result;
    return false;
  }
  async function connectCoinbaseWallet(connector2) {
    try {
      await connectWallet(connector2);
    } catch (error) {
      context.log(error);
      context.displayError(jsxs(Fragment$2, { children: ["This dApp is most likely missing the ", jsx("code", { children: "headlessMode: true" }), " ", "flag in the custom ", jsx("code", { children: "CoinbaseWalletConnector" }), " options. See", " ", jsx("a", { target: "_blank", rel: "noopener noreferrer", href: "https://connect.family.co/v0/docs/cbwHeadlessMode", children: "documentation" }), " ", "for more details."] }), error);
    }
  }
  return {
    uri
  };
}
const ConnectWithQRCode = ({ switchConnectMethod }) => {
  var _a2, _b, _c, _d, _e2, _f;
  const context = useContext();
  const id2 = context.connector.id;
  const wallet2 = useWallet(context.connector.id, context.connector.name);
  const { open: openW3M, isOpen: isOpenW3M } = useWalletConnectModal();
  const { uri } = isCoinbaseWalletConnector(id2) ? useCoinbaseWalletUri() : useWalletConnectUri();
  const locales = useLocales({
    CONNECTORNAME: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.name
  });
  if (!wallet2)
    return jsxs(Fragment$2, { children: ["Wallet not found ", context.connector.id] });
  const downloads = wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.downloadUrls;
  const extensions = {
    chrome: downloads === null || downloads === void 0 ? void 0 : downloads.chrome,
    firefox: downloads === null || downloads === void 0 ? void 0 : downloads.firefox,
    brave: downloads === null || downloads === void 0 ? void 0 : downloads.brave,
    edge: downloads === null || downloads === void 0 ? void 0 : downloads.edge,
    safari: downloads === null || downloads === void 0 ? void 0 : downloads.safari
  };
  detectBrowser();
  const hasApps = downloads && Object.keys(downloads).length !== 0;
  extensions ? {
    name: Object.keys(extensions)[0],
    label: ((_a2 = Object.keys(extensions)[0]) === null || _a2 === void 0 ? void 0 : _a2.charAt(0).toUpperCase()) + ((_b = Object.keys(extensions)[0]) === null || _b === void 0 ? void 0 : _b.slice(1)),
    url: extensions[Object.keys(extensions)[0]]
  } : void 0;
  if (!(wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.createUri))
    return jsxs(PageContent, { children: [jsx(ModalHeading, { children: "Invalid State" }), jsx(ModalContent, { children: jsxs(Alert, { children: [wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.name, " does not have it's own QR Code to scan. This state should never happen"] }) })] });
  const showAdditionalOptions = isWalletConnectConnector(id2);
  return jsxs(PageContent, { children: [jsxs(ModalContent, { style: { paddingBottom: 8, gap: 14 }, children: [jsx(CustomQRCode, { value: uri, image: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.icon, tooltipMessage: isWalletConnectConnector(id2) ? jsxs(Fragment$2, { children: [jsx(ScanIconWithLogos, {}), jsx("span", { children: locales.scanScreen_tooltip_walletConnect })] }) : jsxs(Fragment$2, { children: [jsx(ScanIconWithLogos, { logo: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.icon }), jsx("span", { children: locales.scanScreen_tooltip_default })] }) }), showAdditionalOptions ? jsx(OrDivider, {}) : hasApps && jsx(OrDivider, { children: locales.dontHaveTheApp })] }), showAdditionalOptions && // for walletConnect
  jsxs("div", { style: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    gap: 14
  }, children: [((_c = context.options) === null || _c === void 0 ? void 0 : _c.walletConnectCTA) !== "modal" && jsx(CopyToClipboard, { variant: "button", string: uri, children: ((_d = context.options) === null || _d === void 0 ? void 0 : _d.walletConnectCTA) === "link" ? locales.copyToClipboard : locales.copyCode }), ((_e2 = context.options) === null || _e2 === void 0 ? void 0 : _e2.walletConnectCTA) !== "link" && jsx(Button, { icon: jsx(ExternalLinkIcon, {}), onClick: openW3M, disabled: isOpenW3M, waiting: isOpenW3M, children: ((_f = context.options) === null || _f === void 0 ? void 0 : _f.walletConnectCTA) === "modal" ? locales.useWalletConnectModal : locales.useModal })] }), hasApps && jsx(Fragment$2, { children: jsx(Button, {
    onClick: () => {
      context.setRoute(routes.DOWNLOAD);
    },
    /*
    icon={
      <div style={{ background: connectorInfo?.icon }}>
        {connectorInfo?.logos.default}
      </div>
    }
    roundedIcon
    */
    download: true,
    children: locales.getWalletName
  }) })] });
};
const states = {
  QRCODE: "qrcode",
  INJECTOR: "injector"
};
const ConnectUsing = () => {
  var _a2;
  const context = useContext();
  const wallet2 = useWallet(context.connector.id, context.connector.name);
  const useInjector = ((_a2 = wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.connector) === null || _a2 === void 0 ? void 0 : _a2.ready) && (!(wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.createUri) || (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.isInstalled));
  const [status, setStatus] = reactExports.useState(useInjector ? states.INJECTOR : states.QRCODE);
  if (!wallet2)
    return jsxs(Alert, { children: ["Connector not found ", context.connector.id] });
  return jsxs(AnimatePresence, { children: [status === states.QRCODE && jsx(motion.div, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$2, children: jsx(ConnectWithQRCode, { switchConnectMethod: (id2) => {
    setStatus(states.INJECTOR);
  } }) }, states.QRCODE), status === states.INJECTOR && jsx(motion.div, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$2, children: jsx(ConnectWithInjector, { switchConnectMethod: (id2) => {
    setStatus(states.QRCODE);
  } }) }, states.INJECTOR)] });
};
const DownloadApp = () => {
  var _a2, _b, _c;
  const context = useContext();
  const wallet2 = useWallet(context.connector.id, context.connector.name);
  const locales = useLocales({
    CONNECTORNAME: wallet2 === null || wallet2 === void 0 ? void 0 : wallet2.name
  });
  if (!wallet2)
    return jsx(Fragment$2, { children: "Wallet not found" });
  const downloads = {
    ios: (_a2 = wallet2.downloadUrls) === null || _a2 === void 0 ? void 0 : _a2.ios,
    android: (_b = wallet2.downloadUrls) === null || _b === void 0 ? void 0 : _b.android,
    redirect: (_c = wallet2.downloadUrls) === null || _c === void 0 ? void 0 : _c.download
  };
  const bodycopy = downloads.ios && downloads.android ? locales.downloadAppScreen_iosAndroid : downloads.ios ? locales.downloadAppScreen_ios : locales.downloadAppScreen_android;
  return jsx(PageContent, { children: jsxs(ModalContent, { style: { paddingBottom: 4, gap: 14 }, children: [downloads.redirect && jsx(CustomQRCode, { value: downloads.redirect }), !downloads.redirect && jsx(Fragment$2, { children: "No download link available" }), jsx(ModalBody, { style: { fontSize: 15, lineHeight: "20px", padding: "0 12px" }, children: bodycopy })] }) });
};
const AvatarContainer = styled(motion.div)`
  padding: 18px 0 20px;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    padding: 16px 0 20px;
  }
`;
const AvatarInner = styled(motion.div)`
  position: relative;
  display: inline-block;
`;
const ChainSelectorContainer = styled(motion.div)`
  z-index: 3;
  position: absolute;
  bottom: 0px;
  right: -16px;
`;
const BalanceContainer = styled(motion.div)`
  position: relative;
`;
const Balance$1 = styled(motion.div)`
  position: relative;
`;
const PlaceholderKeyframes$1 = We`
  0%{ background-position: 100% 0; }
  100%{ background-position: -100% 0; }
`;
const LoadingBalance = styled(motion.div)`
  width: 25%;
  margin: 0 auto;
  position: relative;
  overflow: hidden;
  border-radius: 10px;
  background: var(--ck-body-background-secondary);
  inset: 0;
  &:before {
    z-index: 4;
    content: '';
    position: absolute;
    inset: 0;
    background-image: linear-gradient(
      90deg,
      var(--ck-body-background-transparent) 50%,
      var(--ck-body-background),
      var(--ck-body-background-transparent)
    );
    opacity: 0.75;
    background-size: 200% 100%;
    animation: ${PlaceholderKeyframes$1} 1000ms linear infinite both;
  }
`;
function addressToNumber(address2) {
  return address2.split("").map((l2) => l2.charCodeAt(0)).reduce((a2, b2) => a2 + b2) % 100 / 100;
}
const EnsAvatar = styled(motion.div)`
  will-change: transform; // Needed for Safari
  pointer-events: none;
  user-select: none;
  position: relative;
  overflow: hidden;
  margin: 0;
  border-radius: ${(props) => `${props.$radius}px`};
  width: ${(props) => `${props.$size}px`};
  height: ${(props) => `${props.$size}px`};
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
  &:before {
    content: '';
    z-index: 1;
    position: absolute;
    inset: 0;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.02);
  }
  ${(props) => {
  if (props.$seed) {
    const id2 = Math.ceil(addressToNumber(props.$seed) * 8);
    const ensColor = `0${id2 === 0 ? 1 : id2}`;
    return Ae`
        background: var(--ck-ens-${ensColor}-start);
        background: linear-gradient(
          180deg,
          var(--ck-ens-${ensColor}-start) 0%,
          var(--ck-ens-${ensColor}-stop) 100%
        );
      `;
  }
}}
`;
const ImageContainer = styled(motion.img)`
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  opacity: ${(props) => props.$loaded ? 1 : 0};
  will-change: opacity; // Needed for Safari
  transition: opacity 500ms ease;
  transform: scale(1.01); // fixes background color bleeding
`;
function useIsMounted() {
  const [mounted, setMounted] = reactExports.useState(false);
  reactExports.useEffect(() => setMounted(true), []);
  return mounted;
}
const Avatar = ({ address: address2, name: name2, size: size2 = 96, radius = 96 }) => {
  var _a2, _b, _c;
  const isMounted = useIsMounted();
  const context = useContext();
  const imageRef = reactExports.useRef(null);
  const [loaded, setLoaded] = reactExports.useState(true);
  const { data: ensAddress } = useEnsAddress({
    chainId: 1,
    name: name2
  });
  const { data: ensName } = useEnsName({
    chainId: 1,
    address: (_a2 = address2 !== null && address2 !== void 0 ? address2 : ensAddress) !== null && _a2 !== void 0 ? _a2 : void 0
  });
  const { data: ensAvatar } = useEnsAvatar({
    chainId: 1,
    name: ensName
  });
  const ens2 = {
    address: ensAddress !== null && ensAddress !== void 0 ? ensAddress : address2,
    name: ensName !== null && ensName !== void 0 ? ensName : name2,
    avatar: ensAvatar !== null && ensAvatar !== void 0 ? ensAvatar : void 0
  };
  reactExports.useEffect(() => {
    if (!(imageRef.current && imageRef.current.complete && imageRef.current.naturalHeight !== 0)) {
      setLoaded(false);
    }
  }, [ensAvatar]);
  if (!isMounted)
    return jsx("div", { style: { width: size2, height: size2, borderRadius: radius } });
  if ((_b = context.options) === null || _b === void 0 ? void 0 : _b.customAvatar)
    return jsx("div", { style: {
      width: size2,
      height: size2,
      borderRadius: radius,
      overflow: "hidden"
    }, children: (_c = context.options) === null || _c === void 0 ? void 0 : _c.customAvatar({
      address: address2 !== null && address2 !== void 0 ? address2 : ens2 === null || ens2 === void 0 ? void 0 : ens2.address,
      ensName: name2 !== null && name2 !== void 0 ? name2 : ens2 === null || ens2 === void 0 ? void 0 : ens2.name,
      ensImage: ens2 === null || ens2 === void 0 ? void 0 : ens2.avatar,
      size: size2,
      radius
    }) });
  if (!ens2.name || !ens2.avatar)
    return jsx(ResetContainer, { style: { pointerEvents: "none" }, children: jsx(EnsAvatar, { "$size": size2, "$seed": ens2.address, "$radius": radius }) });
  return jsx(ResetContainer, { style: { pointerEvents: "none" }, children: jsx(EnsAvatar, { "$size": size2, "$seed": ens2.address, "$radius": radius, children: jsx(ImageContainer, { ref: imageRef, src: ens2.avatar, alt: ens2.name, onLoad: () => setLoaded(true), "$loaded": loaded }) }) });
};
const KnownChain = ({ testnet, ...props }) => jsxs("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "black"
}, children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20.5611 8.12948C21.0082 7.90729 21.5007 7.79167 22 7.79167C22.4993 7.79167 22.9919 7.90729 23.439 8.12948L23.4408 8.1304L33.0387 12.9293C33.577 13.197 34.031 13.61 34.3478 14.121C34.6649 14.6323 34.833 15.2218 34.8333 15.8234V27.2595C34.833 27.8611 34.6649 28.4511 34.3478 28.9624C34.031 29.4733 33.578 29.8858 33.0398 30.1535L23.4411 34.9528C22.9919 35.1775 22.4963 35.2947 21.994 35.2947C21.4918 35.2947 20.9964 35.1777 20.5472 34.9529L10.9475 30.1531L10.9452 30.1519C10.4071 29.8808 9.95535 29.4646 9.6411 28.9504C9.32739 28.437 9.16312 27.8464 9.16673 27.2448L9.16675 27.2417L10.0004 27.2475H9.16673V27.2448V15.8239C9.16705 15.2223 9.33518 14.6322 9.65222 14.121C9.96906 13.61 10.4221 13.1976 10.9604 12.9298L20.5592 8.1304L20.5611 8.12948ZM21.3031 9.62267L11.8706 14.3389L22 19.4036L32.1294 14.3389L22.697 9.62267C22.4806 9.51531 22.2416 9.45905 22 9.45905C21.7585 9.45905 21.5194 9.51534 21.3031 9.62267ZM10.8341 15.8241C10.8341 15.7785 10.8362 15.733 10.8401 15.6878L21.1663 20.8509V33.3983L11.6955 28.6629C11.4352 28.5315 11.2159 28.3297 11.0638 28.0809C10.9116 27.8318 10.8321 27.5452 10.8341 27.2533L10.8341 27.2475V15.8241ZM22.8337 33.3923L32.2967 28.6608C32.5576 28.5312 32.7772 28.3313 32.9308 28.0836C33.0844 27.836 33.1658 27.5504 33.166 27.259V15.8243C33.1659 15.7786 33.1639 15.7331 33.1599 15.6878L22.8337 20.8509V33.3923Z", fill: "url(#paint0_linear_3546_7073)" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.8341 15.8241C10.8341 15.7785 10.8362 15.733 10.8401 15.6878L21.1663 20.8509V33.3983L11.6955 28.6629C11.4352 28.5315 11.2159 28.3297 11.0638 28.0809C10.9116 27.8318 10.8321 27.5452 10.8341 27.2533L10.8341 27.2475V15.8241Z", fill: "url(#paint1_linear_3546_7073)", fillOpacity: "0.3" }), jsxs("defs", { children: [jsxs("linearGradient", { id: "paint0_linear_3546_7073", x1: "22", y1: "7.79167", x2: "22", y2: "35.2947", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "white" }), jsx("stop", { offset: "1", stopColor: "white", stopOpacity: "0.7" })] }), jsxs("linearGradient", { id: "paint1_linear_3546_7073", x1: "22", y1: "7.79167", x2: "22", y2: "35.2947", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "white" }), jsx("stop", { offset: "1", stopColor: "white", stopOpacity: "0.7" })] })] })] });
const UnknownChain = ({ testnet, ...props }) => {
  return jsx(KnownChain, { testnet: true, ...props });
};
const Ethereum = ({ testnet, ...props }) => {
  let bg2 = "var(--ck-chain-ethereum-01, #25292E)";
  let fill = "var(--ck-chain-ethereum-02, #ffffff)";
  if (testnet) {
    bg2 = "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)";
    fill = "#fff";
  }
  return jsxs("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
    background: bg2
  }, children: [jsx("path", { d: "M21.9967 6.99621L21.7955 7.67987V27.5163L21.9967 27.7171L31.2044 22.2744L21.9967 6.99621Z", fill }), jsx("path", { d: "M21.9957 6.99621L12.7878 22.2744L21.9957 27.7171V18.0891V6.99621Z", fill }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.9959 36.9996L21.9959 36.9997V36.9995L31.2091 24.0243L21.9959 29.4642L12.788 24.0243L21.9957 36.9993L21.9958 36.9997L21.9959 36.9996Z", fill }), jsx("path", { d: "M21.996 27.7181L31.2037 22.2753L21.996 18.09V27.7181Z", fill }), jsx("path", { d: "M12.7878 22.2753L21.9957 27.7181V18.09L12.7878 22.2753Z", fill })] });
};
const Polygon = ({ testnet, ...props }) => jsx("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#6F41D8"
}, children: jsx("path", { d: "M29.0015 17.4529C28.4941 17.1572 27.8355 17.1572 27.2773 17.4529L23.3186 19.7271L20.6305 21.2094L16.6719 23.4822C16.1645 23.7792 15.5059 23.7792 14.9476 23.4822L11.8016 21.703C11.2943 21.4074 10.9395 20.8642 10.9395 20.2702V16.7612C10.9395 16.1686 11.2434 15.6255 11.8016 15.3285L14.8954 13.5988C15.4041 13.3018 16.0641 13.3018 16.6224 13.5988L19.7161 15.3285C20.2249 15.6255 20.5796 16.1686 20.5796 16.7612V19.0355L23.2678 17.5024V15.2295C23.2707 14.9343 23.1917 14.6441 23.0395 14.3911C22.8873 14.1381 22.6679 13.9324 22.4056 13.7968L16.6719 10.5353C16.1645 10.2382 15.5059 10.2382 14.9476 10.5353L9.11214 13.7968C8.84992 13.9324 8.63049 14.1381 8.47828 14.3911C8.32607 14.6441 8.24705 14.9343 8.25002 15.2295V21.802C8.25002 22.396 8.55389 22.9391 9.11214 23.2361L14.9476 26.4976C15.455 26.7932 16.115 26.7932 16.6719 26.4976L20.6305 24.2729L23.3186 22.7411L27.2773 20.5177C27.7846 20.2207 28.4433 20.2207 29.0015 20.5177L32.0966 22.2475C32.6054 22.5431 32.9588 23.0863 32.9588 23.6803V27.1893C32.9588 27.7819 32.6563 28.325 32.0966 28.622L29.0029 30.4013C28.4941 30.6983 27.8341 30.6983 27.2773 30.4013L24.1821 28.6715C23.6734 28.3745 23.3186 27.8314 23.3186 27.2387V24.9645L20.6305 26.4976V28.7705C20.6305 29.3631 20.9344 29.9076 21.4926 30.2032L27.3281 33.4647C27.8355 33.7617 28.4941 33.7617 29.0524 33.4647L34.8879 30.2032C35.3953 29.9076 35.75 29.3645 35.75 28.7705V22.198C35.753 21.9028 35.674 21.6126 35.5218 21.3596C35.3695 21.1066 35.1501 20.9009 34.8879 20.7653L29.0029 17.4529H29.0015Z", fill: "white" }) });
const Optimism = ({ testnet, ...props }) => jsxs("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#FF0420"
}, children: [jsx("path", { d: "M15.5877 27.8473C14.2777 27.8473 13.2045 27.539 12.3679 26.9226C11.5422 26.2952 11.1294 25.4035 11.1294 24.2477C11.1294 24.0055 11.157 23.7082 11.212 23.356C11.3552 22.5634 11.5588 21.6112 11.823 20.4994C12.5715 17.4722 14.5034 15.9586 17.6187 15.9586C18.4664 15.9586 19.2259 16.1017 19.8974 16.3879C20.5689 16.663 21.0973 17.0814 21.4826 17.6428C21.8678 18.1932 22.0605 18.8537 22.0605 19.6242C22.0605 19.8554 22.033 20.1471 21.9779 20.4994C21.8128 21.4791 21.6146 22.4313 21.3835 23.356C20.9982 24.8641 20.3322 25.9924 19.3855 26.741C18.4388 27.4785 17.1729 27.8473 15.5877 27.8473ZM15.8189 25.4695C16.4354 25.4695 16.9582 25.2879 17.3876 24.9247C17.8279 24.5614 18.1416 24.0055 18.3287 23.257C18.5819 22.2222 18.7746 21.3195 18.9067 20.5489C18.9507 20.3178 18.9727 20.0811 18.9727 19.8389C18.9727 18.8372 18.4498 18.3363 17.4041 18.3363C16.7876 18.3363 16.2592 18.5179 15.8189 18.8812C15.3896 19.2445 15.0813 19.8004 14.8943 20.5489C14.6961 21.2865 14.4979 22.1892 14.2998 23.257C14.2557 23.477 14.2337 23.7082 14.2337 23.9504C14.2337 24.9632 14.7622 25.4695 15.8189 25.4695Z", fill: "white" }), jsx("path", { d: "M22.8188 27.6815C22.6977 27.6815 22.6041 27.6429 22.5381 27.5659C22.483 27.4778 22.4665 27.3788 22.4885 27.2687L24.7672 16.5358C24.7892 16.4147 24.8498 16.3156 24.9489 16.2385C25.0479 16.1615 25.1525 16.1229 25.2626 16.1229H29.6548C30.8767 16.1229 31.8564 16.3761 32.5939 16.8825C33.3426 17.3889 33.7168 18.1209 33.7168 19.0786C33.7168 19.3538 33.6838 19.64 33.6177 19.9372C33.3426 21.2032 32.7867 22.1389 31.95 22.7443C31.1244 23.3498 29.9905 23.6525 28.5485 23.6525H26.3194L25.5598 27.2687C25.5377 27.3898 25.4772 27.4888 25.3782 27.5659C25.2791 27.6429 25.1745 27.6815 25.0645 27.6815H22.8188ZM28.6641 21.3738C29.1264 21.3738 29.5282 21.2472 29.8695 20.994C30.2217 20.7408 30.4529 20.3776 30.563 19.9042C30.596 19.717 30.6125 19.552 30.6125 19.4089C30.6125 19.0896 30.519 18.8474 30.3318 18.6823C30.1446 18.5062 29.8255 18.4182 29.3741 18.4182H27.3926L26.7652 21.3738H28.6641Z", fill: "white" })] });
const Arbitrum = ({ testnet, ...props }) => {
  const fill = testnet ? "#ffffff" : "#28A0F0";
  const outlineFill = testnet ? "#ffffff" : "#96BEDC";
  return jsxs("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
    background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#2C364F"
  }, children: [!testnet && jsx("path", { d: "M25.7948 20.5826L28.2683 16.3854L34.9355 26.7696L34.9386 28.7625L34.9168 15.0491C34.9011 14.7137 34.7231 14.407 34.4391 14.2261L22.4357 7.32182C22.1551 7.1838 21.7989 7.18546 21.5187 7.32618C21.4807 7.34524 21.4453 7.36576 21.4113 7.38835L21.3694 7.41467L9.71816 14.1664L9.67298 14.1871C9.61474 14.2137 9.55609 14.2479 9.50076 14.2872C9.27983 14.4456 9.1331 14.68 9.08564 14.9425C9.07859 14.9823 9.0732 15.023 9.07092 15.064L9.08916 26.239L15.2994 16.6138C16.0811 15.3376 17.7847 14.9262 19.3662 14.9488L21.2221 14.9977L10.2862 32.5356L11.5753 33.2778L22.6422 15.0155L27.5338 14.9977L16.4956 33.7209L21.0955 36.3668L21.6451 36.6827C21.8776 36.7772 22.1516 36.7819 22.386 36.6972L34.5581 29.6433L32.2309 30.9918L25.7948 20.5826ZM26.7384 34.175L22.0925 26.8829L24.9287 22.0702L31.0303 31.6876L26.7384 34.175Z", fill: "#2D374B" }), jsx("path", { d: "M22.0924 26.8832L26.7385 34.1751L31.0302 31.6879L24.9286 22.0705L22.0924 26.8832Z", fill }), jsx("path", { d: "M34.9387 28.7627L34.9356 26.7698L28.2684 16.3856L25.7949 20.5828L32.2312 30.992L34.5584 29.6435C34.7866 29.4582 34.9248 29.1861 34.9393 28.8926L34.9387 28.7627Z", fill }), jsx("path", { d: "M7 30.642L10.2863 32.5356L21.2222 14.9976L19.3663 14.9487C17.785 14.9263 16.0814 15.3375 15.2995 16.6137L9.08927 26.239L7 29.449V30.642V30.642Z", fill: "white" }), jsx("path", { d: "M27.534 14.9977L22.6423 15.0155L11.5754 33.2778L15.4437 35.5049L16.4955 33.7209L27.534 14.9977Z", fill: "white" }), jsx("path", { d: "M37 14.9723C36.9592 13.9493 36.4052 13.013 35.5377 12.4677L23.377 5.47434C22.5187 5.04223 21.4466 5.04161 20.5868 5.47414C20.4852 5.52533 8.76078 12.3251 8.76078 12.3251C8.5985 12.4029 8.44224 12.4955 8.2953 12.6008C7.52081 13.156 7.0487 14.0186 7 14.9661V29.4492L9.08927 26.2392L9.07103 15.0639C9.07352 15.0231 9.0787 14.9827 9.08575 14.9431C9.133 14.6801 9.27994 14.4457 9.50086 14.2872C9.5562 14.2478 21.4806 7.34517 21.5186 7.32611C21.799 7.18538 22.155 7.18373 22.4356 7.32175L34.439 14.226C34.723 14.4069 34.901 14.7137 34.9167 15.049V28.8921C34.9022 29.1856 34.7862 29.4577 34.558 29.643L32.2308 30.9916L31.03 31.6875L26.7383 34.1747L22.3859 36.6969C22.1515 36.7817 21.8773 36.7769 21.645 36.6824L16.4955 33.7206L15.4435 35.5046L20.0713 38.169C20.2243 38.256 20.3607 38.3331 20.4726 38.3961C20.6458 38.4933 20.764 38.5582 20.8056 38.5785C21.1345 38.7383 21.6077 38.8311 22.0342 38.8311C22.4251 38.8311 22.8064 38.7594 23.1672 38.6181L35.8092 31.2971C36.5347 30.7348 36.9617 29.8869 37 28.9686V14.9723Z", fill: outlineFill })] });
};
const Telos = ({ testnet, ...props }) => jsx("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#571AFF"
}, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M26.1834 8.14754C25.6606 8.23504 25.3644 8.50235 24.9216 9.28591C24.5651 9.91722 24.4762 10.0244 24.2024 10.1592L23.9832 10.2668L19.2967 10.286L14.6097 10.3057L14.3875 10.3902C13.7059 10.6492 13.6192 10.7135 11.6291 12.4407C9.72243 14.0953 9.64893 14.1723 9.59249 14.5836C9.54437 14.9362 9.78981 15.6327 10.5191 17.2143C11.2847 18.8737 11.2839 18.8641 10.7444 19.5256C10.2645 20.1136 10.2269 20.2588 10.2041 21.5915C10.1717 23.502 10.2487 27.6023 10.3222 27.8591C10.3572 27.9816 10.7908 29.204 11.2861 30.5755C11.7813 31.9471 12.4192 33.715 12.704 34.5038C13.4281 36.5107 13.4814 36.5986 14.0392 36.7237C14.3066 36.7837 14.3206 36.781 18.9677 35.7258C24.4395 34.4837 23.7264 34.709 25.0739 33.7968C29.8732 30.5475 29.7337 30.66 29.8969 29.9083C30.0583 29.1642 30.1082 29.1379 31.8267 28.8999C34.6122 28.5145 34.6328 28.5083 34.8831 28.0109C35.0182 27.7423 35.7786 23.3406 35.8136 22.6209C35.8504 21.8828 36.042 22.221 33.3816 18.3395C30.022 13.4382 30.2381 13.7777 30.2399 13.4041C30.2407 13.1735 30.3366 12.9736 31.3236 11.1418C31.8236 10.2134 32.2742 9.35241 32.3254 9.22904C32.5236 8.74691 32.4204 8.3921 32.0301 8.21622L31.8267 8.12391L29.1102 8.11822C27.6048 8.11516 26.2997 8.12829 26.1834 8.14754ZM30.0474 9.4876C30.5623 9.72297 30.5382 9.82447 29.5119 11.7398C28.4317 13.7558 28.3157 13.2711 30.7154 16.7707C31.639 18.1173 32.8076 19.8218 33.3124 20.5581C34.6844 22.5592 34.6048 22.1799 34.1831 24.6903C33.7858 27.0602 33.7792 27.0817 33.3759 27.282C33.1506 27.394 33.2276 27.3813 30.8493 27.7117C28.9147 27.9803 28.8543 28.017 28.6719 29.0338C28.5778 29.557 28.4606 29.8169 28.2243 30.0247C28.0808 30.1512 24.8682 32.368 23.9451 32.9778C23.2587 33.4311 23.6861 33.3152 17.7471 34.6574C17.1997 34.7812 16.4079 34.9632 15.987 35.0617C14.4588 35.4195 14.4299 35.4033 13.8804 33.8948C12.9188 31.2528 11.6811 27.7957 11.6194 27.5787C11.5534 27.3463 11.549 27.1202 11.549 24.059V20.7878L11.6501 20.5966C11.7056 20.4912 11.8671 20.2759 12.0088 20.118C12.8418 19.19 12.8383 19.1183 11.8601 16.9907C10.7663 14.612 10.6797 14.9992 12.697 13.2501C14.2418 11.91 14.3048 11.8593 14.5905 11.7237L14.8394 11.6055L19.6983 11.5854C23.5417 11.5692 24.5891 11.5543 24.7103 11.515C25.1465 11.3728 25.4086 11.1094 25.7975 10.4203C26.3851 9.38041 26.3111 9.40797 28.4597 9.41891C29.6996 9.42547 29.9332 9.43554 30.0474 9.4876Z", fill: "#F7F5FC" }) });
const Aurora = ({ testnet, ...props }) => jsx("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#6CD544"
}, children: jsx("path", { d: "M22.0006 7.292C22.6198 7.29004 23.2271 7.46144 23.754 7.7868C24.2808 8.11216 24.706 8.57848 24.9816 9.133L34.3566 27.883C34.611 28.3912 34.7312 28.956 34.7058 29.5238C34.6805 30.0915 34.5103 30.6433 34.2116 31.1268C33.9129 31.6103 33.4956 32.0094 32.9992 32.2861C32.5028 32.5629 31.9439 32.7081 31.3756 32.708H12.6256C12.0573 32.7079 11.4985 32.5626 11.0023 32.2858C10.506 32.009 10.0888 31.6099 9.79022 31.1264C9.49163 30.6429 9.3216 30.0912 9.29628 29.5235C9.27096 28.9558 9.39119 28.3911 9.64556 27.883L19.0196 9.133C19.2951 8.57848 19.7203 8.11216 20.2472 7.7868C20.774 7.46144 21.3814 7.29004 22.0006 7.292ZM22.0006 5C20.9561 4.9999 19.9322 5.29059 19.0437 5.83952C18.1551 6.38846 17.4369 7.17394 16.9696 8.108L7.59456 26.858C7.16544 27.7156 6.96271 28.6687 7.00564 29.6268C7.04856 30.5848 7.33572 31.516 7.83982 32.3318C8.34392 33.1476 9.04823 33.821 9.88584 34.288C10.7235 34.755 11.6666 35.0001 12.6256 35H31.3756C32.3345 34.9999 33.2775 34.7547 34.1149 34.2876C34.9524 33.8206 35.6566 33.1472 36.1606 32.3314C36.6645 31.5156 36.9516 30.5845 36.9945 29.6265C37.0374 28.6686 36.8346 27.7156 36.4056 26.858L27.0316 8.108C26.5642 7.17394 25.846 6.38846 24.9574 5.83952C24.0689 5.29059 23.045 4.9999 22.0006 5Z", fill: "white" }) });
const Avalanche = ({ testnet, ...props }) => jsxs("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#E84142"
}, children: [jsx("path", { d: "M11.0188 32.1528H15.4825C16.5334 32.1528 17.0589 32.1528 17.5278 32.023C18.042 31.8701 18.511 31.5991 18.9009 31.2261C19.2589 30.885 19.5173 30.4328 20.0269 29.5409L20.0272 29.5404L20.0422 29.5142L25.8314 19.2804C26.3456 18.3821 26.5999 17.93 26.7129 17.4554C26.8372 16.9412 26.8372 16.3988 26.7129 15.8847C26.6007 15.4136 26.3439 14.9648 25.8373 14.0798L25.8258 14.0597L23.56 10.1045C23.0911 9.27958 22.8538 8.86711 22.5543 8.71456C22.2323 8.55071 21.848 8.55071 21.526 8.71456C21.2265 8.86711 20.9892 9.27958 20.5202 10.1045L9.49892 29.5311C9.03561 30.3447 8.80392 30.7517 8.82089 31.0849C8.84349 31.4466 9.02994 31.7743 9.33507 31.9721C9.61756 32.1528 10.0809 32.1528 11.0188 32.1528Z", fill: "white" }), jsx("path", { d: "M33.1506 32.1528H26.7547C25.8111 32.1528 25.3365 32.1528 25.0596 31.9721C24.7545 31.7743 24.5681 31.4411 24.5455 31.0794C24.5286 30.7486 24.7621 30.3456 25.2294 29.539L25.2295 29.5388L25.2404 29.5199L28.4328 24.0392C28.9018 23.2313 29.1391 22.8301 29.4329 22.6776C29.7548 22.5137 30.1336 22.5137 30.4555 22.6776C30.7472 22.8261 30.9744 23.2102 31.4241 23.9708L31.4248 23.9719L31.4613 24.0336L34.665 29.5143C34.6806 29.5413 34.696 29.5678 34.7113 29.5939L34.7113 29.594C35.1554 30.3603 35.382 30.7514 35.3657 31.0739C35.3486 31.4353 35.1566 31.7688 34.8515 31.9666C34.5689 32.1528 34.0942 32.1528 33.1506 32.1528Z", fill: "white" })] });
const Celo = ({ testnet, ...props }) => jsx("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#FCFE72"
}, children: jsx("path", { d: "M9 9H34.5183V18.112H30.3564C28.896 14.7687 25.6102 12.4171 21.777 12.4171C16.593 12.4171 12.3948 16.6422 12.3948 21.823C12.3948 27.0039 16.593 31.2654 21.777 31.2654C25.5373 31.2654 28.8231 28.9876 30.2829 25.7172H34.5178V34.682H9V9Z", fill: testnet ? "#ffffff" : "black" }) });
const Gnosis = ({ testnet, ...props }) => jsx("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#009CB4"
}, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.3439 11.8664C17.9374 6.53462 26.7953 6.74397 32.1271 12.3374C32.4738 12.7038 32.8075 13.0832 33.1084 13.4823L22 24.5972L10.8916 13.4823C11.1991 13.0832 11.5262 12.7038 11.8729 12.3374C12.0234 12.1804 12.1804 12.0234 12.3439 11.8664ZM30.6094 13.3972C28.3196 11.0944 25.271 9.83182 22 9.83182C18.729 9.83182 15.6804 11.0944 13.3907 13.3972L22 22.0066L30.6094 13.3972ZM33.9785 14.7446L31.7215 17.0016C33.5402 19.1801 33.2523 22.425 31.0738 24.2437C29.1636 25.84 26.3897 25.84 24.4794 24.2437L22 26.7231L19.5271 24.2502C17.3486 26.0689 14.1037 25.7811 12.285 23.6026C10.6888 21.6923 10.6888 18.9185 12.285 17.0082L11.1271 15.8502L10.028 14.7446C8.7 16.9297 8 19.4418 8 21.9998C8 29.7325 14.2673 35.9998 22 35.9998C29.7327 35.9998 36 29.7325 36 21.9998C36.0065 19.4418 35.3 16.9297 33.9785 14.7446ZM30.6486 18.0747C31.1392 18.7093 31.4075 19.4943 31.4075 20.299C31.4075 21.1037 31.1392 21.8887 30.6486 22.5233C29.4187 24.113 27.1355 24.4074 25.5458 23.1775L30.6486 18.0747ZM18.4542 23.1839C17.8196 23.6745 17.0346 23.9427 16.2299 23.9427C15.4252 23.9427 14.6467 23.6745 14.0056 23.1904C12.4159 21.9605 12.1215 19.6708 13.3514 18.0811L18.4542 23.1839Z", fill: "white" }) });
const Evmos = ({ testnet, ...props }) => jsx("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#2D2A25"
}, children: jsx("path", { d: "M18.4916 12.6668C12.9416 14.806 12.4332 20.2846 10.8418 22.8432C9.23155 25.4322 5.54251 26.8607 6.04698 28.1801C6.55143 29.4994 10.2449 28.0824 13.1669 28.9242C16.0543 29.7561 20.0831 33.4862 25.633 31.3469C28.4603 30.2573 30.5076 28.0143 31.449 25.3574C31.5502 25.0723 31.361 24.7673 31.0606 24.7391C30.874 24.7215 30.6948 24.8196 30.6106 24.9877C29.759 26.6908 28.2981 28.0934 26.3864 28.8301C23.2303 30.0465 19.777 29.0915 17.6562 26.6961C17.1746 26.1522 16.7626 25.533 16.4374 24.8487C16.348 24.6603 16.2629 24.4689 16.1875 24.2708C16.1117 24.0728 16.0473 23.8735 15.9881 23.6732C17.6562 22.8925 19.5812 22.0656 21.7635 21.2246C23.903 20.3999 25.8505 19.731 27.5841 19.1958C28.7571 18.8341 29.8322 18.5331 30.8029 18.2871C30.8732 18.2695 30.9423 18.2519 31.0112 18.2347C31.158 18.1982 31.3088 18.2769 31.363 18.4186L31.364 18.4213C31.396 18.5053 31.4236 18.5898 31.4535 18.6743C31.6453 19.2196 31.7892 19.7706 31.8841 20.3229C31.9258 20.5645 32.1888 20.6961 32.4044 20.5799C33.2014 20.1504 33.9302 19.7314 34.5814 19.3283C37.0083 17.8276 38.3538 16.5549 38.0776 15.8336C37.802 15.1119 35.9541 15.0705 33.1503 15.5854C32.2593 15.7491 31.2716 15.9691 30.207 16.2416C30.0229 16.2886 29.8365 16.3375 29.6481 16.3877C28.7522 16.6262 27.8073 16.8995 26.8234 17.2053C24.9936 17.7744 23.0305 18.4561 21.0038 19.2372C19.1078 19.9682 17.3109 20.726 15.6629 21.4812C15.6428 18.2761 17.5725 15.2461 20.7286 14.0297C22.6399 13.293 24.6605 13.3533 26.4285 14.0473C26.6029 14.116 26.8015 14.0684 26.9291 13.9298C27.1331 13.7076 27.0706 13.3537 26.8053 13.2094C24.3353 11.8685 21.319 11.5771 18.4916 12.6668Z", fill: "#FAF1E4" }) });
const BinanceSmartChain = ({ testnet, ...props }) => jsxs("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#16181A"
}, children: [jsx("path", { d: "M16.0445 19.6063L21.8705 13.7805L27.6996 19.6093L31.0896 16.2193L21.8705 7L12.6545 16.2163L16.0445 19.6063Z", fill: testnet ? "#fff" : "#F3BA2F" }), jsx("path", { d: "M13.6505 21.9995L10.2606 18.6096L6.87046 21.9997L10.2604 25.3896L13.6505 21.9995Z", fill: testnet ? "#fff" : "#F3BA2F" }), jsx("path", { d: "M16.0445 24.3937L21.8705 30.2195L27.6994 24.3909L31.0913 27.779L31.0896 27.7809L21.8705 37L12.6542 27.7839L12.6495 27.7792L16.0445 24.3937Z", fill: testnet ? "#fff" : "#F3BA2F" }), jsx("path", { d: "M33.4808 25.3911L36.8709 22.001L33.481 18.6111L30.0909 22.0012L33.4808 25.3911Z", fill: testnet ? "#fff" : "#F3BA2F" }), jsx("path", { d: "M25.3091 21.9982H25.3105L21.8705 18.5582L19.3283 21.1004H19.3281L19.0362 21.3926L18.4336 21.9951L18.4289 21.9999L18.4336 22.0048L21.8705 25.4418L25.3105 22.0018L25.3122 21.9999L25.3091 21.9982Z", fill: testnet ? "#fff" : "#F3BA2F" })] });
const Canto = ({ testnet, ...props }) => jsx("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "white"
}, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M35 8V36H9L13.875 35.9998V31.0586H9V12.9412H13.875V8H35ZM17.9373 12.9414H30.1247V17.8826H17.9373V12.9414ZM30.1247 26.9414H17.9373V17.8826L13.0623 17.8828V26.9416L17.9373 26.9414V31.8826H30.1247V26.9414Z", fill: "#06FC99" }) });
const Fantom = ({ testnet, ...props }) => jsx("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#0911EF"
}, children: jsx("path", { d: "M20.92 9.25864C21.5933 8.91379 22.6178 8.91379 23.2911 9.25864L30.1616 12.7775C30.5671 12.9852 30.7898 13.2947 30.8297 13.6142H30.8363V31.302C30.8274 31.6504 30.6025 31.9966 30.1616 32.2225L23.2911 35.7413C22.6178 36.0862 21.5933 36.0862 20.92 35.7413L14.0495 32.2225C13.6104 31.9976 13.3997 31.6489 13.3893 31.302C13.3883 31.2678 13.3881 31.2393 13.3891 31.2157L13.3891 13.7278C13.3884 13.7086 13.3883 13.6895 13.3889 13.6705L13.3893 13.6142L13.3924 13.6142C13.4229 13.2912 13.6355 12.9896 14.0495 12.7775L20.92 9.25864ZM29.7547 23.4821L23.2911 26.7926C22.6178 27.1374 21.5933 27.1374 20.92 26.7926L14.4706 23.4895V31.2669L20.92 34.5527C21.2842 34.7415 21.6622 34.9254 22.0318 34.9488L22.1056 34.9512C22.4907 34.9524 22.8646 34.7628 23.2438 34.5833L29.7547 31.2387V23.4821ZM11.3214 31.8437C11.3214 32.5212 11.4026 32.9667 11.5639 33.2806C11.6976 33.5407 11.8981 33.7394 12.2643 33.9813L12.2852 33.9951C12.3656 34.0476 12.4541 34.1026 12.5619 34.1672L12.689 34.2427L13.0792 34.4711L12.5195 35.3685L12.0827 35.1126L12.0093 35.0689C11.883 34.9932 11.7783 34.9284 11.6807 34.8645C10.637 34.1822 10.2478 33.4384 10.2401 31.8907L10.24 31.8437H11.3214ZM21.5647 18.7412C21.5147 18.7579 21.4678 18.7772 21.4251 18.7991L14.5546 22.318C14.5474 22.3216 14.5405 22.3253 14.534 22.3289L14.5281 22.3322L14.5389 22.3382L14.5546 22.3464L21.4251 25.8653C21.4678 25.8872 21.5147 25.9065 21.5647 25.9231V18.7412ZM22.6465 18.7412V25.9231C22.6965 25.9065 22.7433 25.8872 22.7861 25.8653L29.6566 22.3464C29.6638 22.3427 29.6707 22.3391 29.6772 22.3355L29.683 22.3322L29.6722 22.3262L29.6566 22.318L22.7861 18.7991C22.7433 18.7772 22.6965 18.7579 22.6465 18.7412ZM29.7547 14.8689L23.5915 18.0256L29.7547 21.1822V14.8689ZM14.4706 14.8763V21.1749L20.6195 18.0256L14.4706 14.8763ZM22.7861 10.1859C22.4288 10.0029 21.7824 10.0029 21.4251 10.1859L14.5546 13.7048C14.5474 13.7085 14.5405 13.7122 14.534 13.7158L14.5281 13.719L14.5389 13.725L14.5546 13.7333L21.4251 17.2522C21.7824 17.4352 22.4288 17.4352 22.7861 17.2522L29.6566 13.7333C29.6638 13.7296 29.6707 13.7259 29.6772 13.7223L29.683 13.719L29.6722 13.7131L29.6566 13.7048L22.7861 10.1859ZM31.7205 9.64552L32.1573 9.90132L32.2307 9.94503C32.357 10.0206 32.4616 10.0856 32.5593 10.1494C33.603 10.8317 33.9922 11.5756 33.9998 13.1231L34 13.1703H32.9186C32.9186 12.4926 32.8373 12.0472 32.6761 11.7334C32.5424 11.4733 32.3419 11.2745 31.9757 11.0327L31.9547 11.0189C31.8744 10.9664 31.7858 10.9113 31.6781 10.8466L31.551 10.7712L31.1608 10.5428L31.7205 9.64552Z", fill: "white" }) });
const Filecoin = ({ testnet, ...props }) => jsx("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#0090FF"
}, children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23.75 19.3069L23.15 22.5069L28.85 23.3069L28.45 24.8069L22.85 24.0069C22.45 25.3069 22.25 26.7069 21.75 27.9069C21.25 29.3069 20.75 30.7069 20.15 32.0069C19.35 33.7069 17.95 34.9069 16.05 35.2069C14.95 35.4069 13.75 35.3069 12.85 34.6069C12.55 34.4069 12.25 34.0069 12.25 33.7069C12.25 33.3069 12.45 32.8069 12.75 32.6069C12.95 32.5069 13.45 32.6069 13.75 32.7069C14.05 33.0069 14.35 33.4069 14.55 33.8069C15.15 34.6069 15.95 34.7069 16.75 34.1069C17.65 33.3069 18.15 32.2069 18.45 31.1069C19.05 28.7069 19.65 26.4069 20.15 24.0069V23.6069L14.85 22.8069L15.05 21.3069L20.55 22.1069L21.25 19.0069L15.55 18.1069L15.75 16.5069L21.65 17.3069C21.85 16.7069 21.95 16.2069 22.15 15.7069C22.65 13.9069 23.15 12.1069 24.35 10.5069C25.55 8.90687 26.95 7.90687 29.05 8.00687C29.95 8.00687 30.85 8.30687 31.45 9.00687C31.55 9.10687 31.75 9.30687 31.75 9.50687C31.75 9.90687 31.75 10.4069 31.45 10.7069C31.05 11.0069 30.55 10.9069 30.15 10.5069C29.85 10.2069 29.65 9.90687 29.35 9.60687C28.75 8.80687 27.85 8.70687 27.15 9.40687C26.65 9.90687 26.15 10.6069 25.85 11.3069C25.15 13.4069 24.65 15.6069 23.95 17.8069L29.45 18.6069L29.05 20.1069L23.75 19.3069Z", fill: "white" }) });
const IoTeX = ({ testnet, ...props }) => jsxs("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#00D4D5"
}, children: [jsx("path", { d: "M23.7136 6.875V14.3784L30.2284 10.6315L23.7136 6.875Z", fill: "white" }), jsx("path", { opacity: "0.9", d: "M30.2284 10.6316V18.135L36.7418 14.3785L30.2284 10.6316Z", fill: "white" }), jsx("path", { opacity: "0.8", d: "M23.7136 14.3784V21.8818L30.2284 18.1349L23.7136 14.3784ZM30.2284 18.1349V25.6383L36.7417 21.8818L30.2284 18.1349Z", fill: "white" }), jsx("path", { opacity: "0.8", d: "M23.7136 21.8817V29.385L30.2284 25.6382L23.7136 21.8817Z", fill: "white" }), jsx("path", { d: "M30.2284 25.6382V33.1416L36.7418 29.3851L30.2284 25.6382Z", fill: "white" }), jsx("path", { opacity: "0.4", d: "M6.87537 14.1253V21.6287L13.3901 17.8722L6.87537 14.1253Z", fill: "white" }), jsx("path", { opacity: "0.2", d: "M15.0938 16.9153V24.4186L21.5975 20.6718L15.0938 16.9153Z", fill: "white" }), jsx("path", { opacity: "0.3", d: "M10.2648 21.6604V29.1638L16.7781 25.4073L10.2648 21.6604Z", fill: "white" }), jsx("path", { opacity: "0.9", d: "M14.5575 27.3226V34.826L21.0612 31.0695L14.5575 27.3226Z", fill: "white" }), jsx("path", { opacity: "0.7", d: "M23.66 30.5525V38.0572L30.1637 34.2993L23.66 30.5525Z", fill: "white" }), jsx("path", { opacity: "0.9", d: "M16.1786 13.2097V20.7145L22.6824 16.9676L16.1786 13.2097Z", fill: "white" }), jsx("path", { opacity: "0.8", d: "M23.7136 6.875V14.3784L17.1989 10.6315L23.7136 6.875Z", fill: "white" }), jsx("path", { opacity: "0.6", d: "M16.1786 10.0649V17.5669L9.66248 13.8104L16.1786 10.0649Z", fill: "white" }), jsx("path", { opacity: "0.6", d: "M22.6934 13.7775V21.2823L16.1786 17.5244L22.6934 13.7775Z", fill: "white" }), jsx("path", { opacity: "0.95", d: "M15.0635 16.9153V24.4186L8.54877 20.6718L15.0635 16.9153Z", fill: "white" }), jsx("path", { opacity: "0.6", d: "M23.7136 21.8817V29.385L17.2099 25.6382L23.7136 21.8817Z", fill: "white" }), jsx("path", { opacity: "0.55", d: "M10.2648 23.6295V31.1328L3.75 27.375L10.2648 23.6295Z", fill: "white" }), jsx("path", { d: "M36.7418 14.3784V21.8818L30.2284 18.1349L36.7418 14.3784Z", fill: "white" }), jsx("path", { opacity: "0.95", d: "M30.2284 18.1362V25.6382L23.7136 21.8817L30.2284 18.1362Z", fill: "white" }), jsx("path", { opacity: "0.9", d: "M36.7418 21.8817V29.385L30.2284 25.6382L36.7418 21.8817Z", fill: "white" }), jsx("path", { opacity: "0.7", d: "M30.2284 25.6382V33.1416L23.7136 29.3851L30.2284 25.6382Z", fill: "white" }), jsx("path", { opacity: "0.4", d: "M22.2712 28.7651V36.2684L15.7579 32.5216L22.2712 28.7651Z", fill: "white" }), jsx("path", { d: "M30.2284 10.6316V18.135L23.7136 14.3785L30.2284 10.6316Z", fill: "white" })] });
const Metis = ({ testnet, ...props }) => jsx("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#2F3140"
}, children: jsx("path", { d: "M37.5175 22.0531C37.4579 19.2923 36.6563 16.5985 35.1968 14.2542C33.7374 11.91 31.674 10.0017 29.223 8.72965C26.772 7.45759 24.0238 6.86863 21.2668 7.02455C18.5098 7.18047 15.8456 8.07553 13.5537 9.61582C11.2617 11.1561 9.42659 13.2849 8.24079 15.7787C7.05498 18.2725 6.56222 21.0396 6.81419 23.7895C7.06617 26.5394 8.05359 29.1708 9.67288 31.4076C11.2922 33.6444 13.4836 35.4042 16.0173 36.5023C16.7657 35.3775 17.3385 34.1453 17.716 32.848C18.0245 32.0632 18.3595 31.2913 18.7067 30.5446C19.5444 30.7955 20.4345 30.8143 21.282 30.5989C22.1295 30.3835 22.9026 29.942 23.5188 29.3215L23.5704 29.2699C22.8136 28.9884 21.9979 28.9032 21.1993 29.022C20.4006 29.1408 19.6451 29.4598 19.0029 29.9494C19.4276 29.0613 19.891 28.1997 20.3667 27.3632C21.189 27.6541 22.075 27.7156 22.9296 27.541C23.7842 27.3665 24.5751 26.9626 25.2175 26.3726L25.2692 26.3209C24.538 26.0116 23.7416 25.8885 22.9513 25.9626C22.1609 26.0368 21.4013 26.3058 20.7404 26.7456C21.216 25.9608 21.7053 25.1889 22.2203 24.468C23.0713 24.6915 23.9672 24.6777 24.811 24.4282C25.6547 24.1787 26.414 23.703 27.0066 23.0526L27.0453 23.001C26.3425 22.7718 25.5958 22.7106 24.8651 22.8224C24.1344 22.9341 23.4401 23.2157 22.838 23.6444C22.8767 23.5928 22.9283 23.5289 22.9664 23.4773C23.2749 23.0784 23.5969 22.6796 23.9177 22.2936C24.8969 21.9731 25.7703 21.3916 26.4436 20.6117C27.117 19.8318 27.5649 18.883 27.7391 17.8674L27.752 17.79H27.7391C26.7194 18.0552 25.7944 18.6007 25.0689 19.3648C24.3434 20.1288 23.8464 21.0808 23.6343 22.1129C23.3258 22.4859 23.0167 22.8603 22.7211 23.2449C22.9706 22.5925 23.0724 21.893 23.0191 21.1966C22.9657 20.5002 22.7586 19.8243 22.4126 19.2176L22.3739 19.2692C21.8489 19.9862 21.5326 20.8345 21.4599 21.7201C21.3873 22.6058 21.5611 23.4942 21.9621 24.2872C21.4729 24.9823 20.9972 25.6897 20.5467 26.4357C20.6918 25.6858 20.6542 24.9118 20.4369 24.1795C20.2196 23.4471 19.8291 22.7779 19.2985 22.2284L19.2727 22.2929C18.9445 23.1107 18.8477 24.0031 18.9929 24.8723C19.1382 25.7415 19.5199 26.5539 20.0962 27.2205C19.6457 28.0054 19.2211 28.816 18.8093 29.6524C18.9344 28.8712 18.8712 28.0715 18.6251 27.3196C18.3789 26.5677 17.9568 25.8855 17.3939 25.3295L17.3681 25.3941C17.0745 26.2514 17.0201 27.1724 17.2105 28.0583C17.401 28.9442 17.8292 29.7614 18.4492 30.4223C18.1774 31.0012 17.9219 31.5774 17.6773 32.1849C17.61 32.1231 17.5313 32.0751 17.4456 32.0435C17.0066 31.916 16.5867 31.7299 16.1974 31.4904C15.8754 31.2994 15.5337 31.144 15.1781 31.027C13.7886 30.5765 13.9945 29.9079 13.2756 28.5564C13.0416 28.2781 12.7931 28.0125 12.5309 27.7607C12.2876 27.603 12.0884 27.386 11.9519 27.1302C11.7934 26.8107 11.6931 26.4656 11.6557 26.1109C11.6514 25.9148 11.5858 25.7249 11.4681 25.5679C11.3504 25.4109 11.1864 25.2948 10.9993 25.2358C8.95338 24.5284 9.86728 21.8778 9.94406 21.5299C9.91262 21.08 9.81271 20.6375 9.64781 20.2178C9.63057 20.1632 9.61763 20.1073 9.60908 20.0506C9.55449 19.776 9.56444 19.4924 9.63813 19.2223C9.71183 18.9521 9.84726 18.7028 10.0338 18.4939C10.2784 18.2493 11.1277 17.8505 11.3078 17.6188C11.4879 17.387 11.6163 17.1295 11.797 16.9114C12.3687 16.3412 13.0291 15.8675 13.7526 15.509C14.3444 15.1876 14.4477 14.364 14.6787 14.1065C15.0647 13.6689 15.6565 13.6689 16.0941 13.283C16.3129 13.09 16.6377 12.9867 16.8415 12.7815C17.8692 11.8403 19.1644 11.2423 20.5474 11.0706C21.5064 10.9924 22.4717 11.0795 23.4012 11.3281C23.5358 11.3507 23.669 11.3809 23.8001 11.4185C25.9228 11.4959 28.4709 11.9328 29.397 12.8338C29.8555 13.2744 30.1961 13.8229 30.3877 14.4293C30.5382 14.8988 30.7456 15.3481 31.0054 15.7672L31.5714 16.6933C31.932 17.2773 32.0475 17.9801 31.8928 18.6489C31.7885 18.974 31.7795 19.3223 31.8669 19.6525C32.1655 20.1031 32.5152 20.5177 32.9093 20.8878C33.0658 21.0427 33.2382 21.1807 33.4236 21.2995C33.8592 21.5594 34.2802 21.8429 34.6848 22.1489C34.698 22.2729 34.6775 22.3982 34.6254 22.5115C34.5732 22.6247 34.4914 22.7218 34.3885 22.7924C34.0284 23.1137 33.3333 23.6159 33.3333 23.6159C33.3584 23.758 33.4016 23.8964 33.4617 24.0276C33.5643 24.2077 33.796 24.4911 33.7192 24.735C33.6424 24.9789 33.1403 25.1855 33.2816 25.4552C33.423 25.7386 33.7831 25.8154 33.6805 26.0729C33.5779 26.3175 33.0757 26.7524 33.1274 26.9352C33.179 27.1179 33.5908 28.8377 32.6382 29.1353C31.4592 29.3685 30.2627 29.5019 29.0614 29.5342C28.8675 29.5454 28.6797 29.6055 28.5155 29.709C28.3513 29.8125 28.216 29.956 28.1223 30.126C27.9399 30.4661 27.8222 30.837 27.7751 31.22C27.4275 32.5896 26.9671 33.928 26.3985 35.2215C26.3985 35.2215 26.3597 35.2989 26.3081 35.4144C26.1833 35.6687 26.1048 35.9432 26.0764 36.2251C26.1573 36.4321 26.2799 36.6204 26.4365 36.7782C26.519 36.8726 26.6271 36.9411 26.7477 36.9753C26.8683 37.0096 26.9962 37.0081 27.116 36.9711C30.1997 35.8965 32.8655 33.8757 34.7332 31.197C36.601 28.5182 37.5754 25.3182 37.5175 22.0531Z", fill: testnet ? "#ffffff" : "#00DACC" }) });
var Chains = {
  UnknownChain,
  Ethereum,
  Polygon,
  Optimism,
  Arbitrum,
  Aurora,
  Avalanche,
  Celo,
  Telos,
  Gnosis,
  Evmos,
  BinanceSmartChain,
  Foundry: KnownChain,
  Sepolia: KnownChain,
  Taraxa: KnownChain,
  zkSync: KnownChain,
  Flare: KnownChain,
  Canto,
  Fantom,
  Filecoin,
  Metis,
  IoTeX
};
const supportedChains = [
  {
    id: 1,
    name: "Ethereum",
    logo: jsx(Chains.Ethereum, {})
  },
  {
    id: 3,
    name: "Rinkeby",
    logo: jsx(Chains.Ethereum, { testnet: true })
  },
  {
    id: 4,
    name: "Ropsten",
    logo: jsx(Chains.Ethereum, { testnet: true })
  },
  {
    id: 5,
    name: "Görli",
    logo: jsx(Chains.Ethereum, { testnet: true })
  },
  {
    id: 42,
    name: "Kovan",
    logo: jsx(Chains.Ethereum, { testnet: true })
  },
  {
    id: 10,
    name: "Optimism",
    logo: jsx(Chains.Optimism, {})
  },
  {
    id: 69,
    name: "Optimism Kovan",
    logo: jsx(Chains.Optimism, { testnet: true })
  },
  {
    id: 420,
    name: "Optimism Goerli",
    logo: jsx(Chains.Optimism, { testnet: true })
  },
  {
    id: 137,
    name: "Polygon",
    logo: jsx(Chains.Polygon, {})
  },
  {
    id: 80001,
    name: "Polygon Mumbai",
    logo: jsx(Chains.Polygon, { testnet: true })
  },
  {
    id: 31337,
    name: "Hardhat",
    logo: jsx(Chains.Ethereum, { testnet: true })
  },
  {
    id: 1337,
    name: "Localhost",
    logo: jsx(Chains.Ethereum, { testnet: true })
  },
  {
    id: 42161,
    name: "Arbitrum",
    logo: jsx(Chains.Arbitrum, {})
  },
  {
    id: 421611,
    name: "Arbitrum Rinkeby",
    logo: jsx(Chains.Arbitrum, { testnet: true })
  },
  {
    id: 421613,
    name: "Arbitrum Goerli",
    logo: jsx(Chains.Arbitrum, { testnet: true })
  },
  {
    id: 40,
    name: "Telos",
    logo: jsx(Chains.Telos, {})
  },
  {
    id: 41,
    name: "Telos Testnet",
    logo: jsx(Chains.Telos, { testnet: true })
  },
  {
    id: 1313161554,
    name: "Aurora",
    logo: jsx(Chains.Aurora, {})
  },
  {
    id: 1313161555,
    name: "Aurora Testnet",
    logo: jsx(Chains.Aurora, { testnet: true })
  },
  {
    id: 43114,
    name: "Avalanche",
    logo: jsx(Chains.Avalanche, {})
  },
  {
    id: 43113,
    name: "Avalanche Fuji",
    logo: jsx(Chains.Avalanche, { testnet: true })
  },
  {
    id: 31337,
    name: "Foundry",
    logo: jsx(Chains.Foundry, { testnet: true })
  },
  {
    id: 100,
    name: "Gnosis",
    logo: jsx(Chains.Gnosis, {})
  },
  {
    id: 9001,
    name: "Evmos",
    logo: jsx(Chains.Evmos, {})
  },
  {
    id: 9e3,
    name: "Evmos Testnet",
    logo: jsx(Chains.Evmos, { testnet: true })
  },
  {
    id: 56,
    name: "BNB Smart Chain",
    logo: jsx(Chains.BinanceSmartChain, {})
  },
  {
    id: 97,
    name: "Binance Smart Chain Testnet",
    logo: jsx(Chains.BinanceSmartChain, { testnet: true })
  },
  {
    id: 11155111,
    name: "Sepolia",
    logo: jsx(Chains.Sepolia, {})
  },
  {
    id: 841,
    name: "Taraxa",
    logo: jsx(Chains.Taraxa, {})
  },
  {
    id: 842,
    name: "Taraxa Testnet",
    logo: jsx(Chains.Taraxa, { testnet: true })
  },
  {
    id: 324,
    name: "zkSync",
    logo: jsx(Chains.zkSync, {})
  },
  {
    id: 280,
    name: "zkSync Testnet",
    logo: jsx(Chains.zkSync, { testnet: true })
  },
  {
    id: 42220,
    name: "Celo",
    logo: jsx(Chains.Celo, {})
  },
  {
    id: 44787,
    name: "Celo Alfajores",
    logo: jsx(Chains.Celo, { testnet: true })
  },
  {
    id: 7700,
    name: "Canto",
    logo: jsx(Chains.Canto, {})
  },
  {
    id: 250,
    name: "Fantom",
    logo: jsx(Chains.Fantom, {})
  },
  {
    id: 4002,
    name: "Fantom Testnet",
    logo: jsx(Chains.Fantom, { testnet: true })
  },
  {
    id: 14,
    name: "Flare",
    logo: jsx(Chains.Flare, {})
  },
  {
    id: 114,
    name: "Coston2",
    logo: jsx(Chains.Flare, {})
  },
  {
    id: 314,
    name: "Filecoin",
    logo: jsx(Chains.Filecoin, {})
  },
  {
    id: 3141,
    name: "Filecoin Hyperspace",
    logo: jsx(Chains.Filecoin, { testnet: true })
  },
  {
    id: 314159,
    name: "Filecoin Calibration",
    logo: jsx(Chains.Filecoin, { testnet: true })
  },
  {
    id: 1088,
    name: "Metis",
    logo: jsx(Chains.Metis, {})
  },
  {
    id: 599,
    name: "Metis Goerli",
    logo: jsx(Chains.Metis, { testnet: true })
  },
  {
    id: 4689,
    name: "IoTeX",
    logo: jsx(Chains.IoTeX, {})
  },
  {
    id: 4690,
    name: "IoTeX Testnet",
    logo: jsx(Chains.IoTeX, { testnet: true })
  }
];
const SwitchNetworksContainer = styled.div`
  display: flex;
  flex-direction: column;

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    flex-direction: column-reverse;
  }
`;
const ChainIcon = styled(motion.div)`
  display: block;
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  width: 24px;
  height: 24px;
  min-width: 24px;
  min-height: 24px;
  background: var(--ck-body-background);
  svg {
    border-radius: inherit;
    display: block;
    position: relative;
    transform: translate3d(0, 0, 0);
    width: 100%;
    height: auto;
  }
  ${(props) => props.$empty && Ae`
      display: flex;
      align-items: center;
      justify-content: center;
      &:before {
        content: '?';
        color: var(--ck-body-color-muted);
        font-weight: bold;
        font-family: var(--ck-font-family);
      }
    `}
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    border-radius: 16px;
    width: 32px;
    height: 32px;
  }
`;
const ChainLogoContainer = styled(motion.div)`
  position: relative;
`;
const ChainLogoSpinner = styled(motion.div)`
  position: absolute;
  inset: -6px;
  animation: rotateSpinner 1200ms linear infinite;
  pointer-events: none;
  svg {
    display: block;
    position: relative;
    transform: translate3d(0, 0, 0);
    width: 100%;
    height: auto;
  }
  @keyframes rotateSpinner {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;
const ChainButtonContainer = styled.div`
  position: relative;
  margin: -8px -8px;
  &:after {
    border-radius: var(--border-radius, 0);
    z-index: 2;
    content: '';
    pointer-events: none;
    position: absolute;
    inset: 0 2px;
    box-shadow: inset 0 16px 8px -12px var(--background, var(--ck-body-background)),
      inset 0 -16px 8px -12px var(--background, var(--ck-body-background));
  }
`;
const ChainButtons = styled(motion.div)`
  padding: 8px;
  overflow-x: hidden;
  overflow-y: auto;
  max-height: 242px;

  -ms-overflow-style: none; /* Internet Explorer 10+ */
  scrollbar-width: none; /* Firefox */
  &::-webkit-scrollbar {
    display: none; /* Safari and Chrome */
  }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    padding: 8px 14px;
    margin: 2px -2px 0;
    max-height: 60vh;
  }
`;
const ChainButton = styled(motion.button)`
  appearance: none;
  cursor: pointer;
  user-select: none;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  border-radius: 11px;
  margin: 0 0 1px;
  padding: 8px 0;
  padding-right: 154px;
  font-size: 15px;
  line-height: 18px;
  font-weight: 500;
  text-decoration: none;
  color: var(--ck-body-color);
  background: none;
  white-space: nowrap;
  transition: transform 100ms ease, background-color 100ms ease;
  transform: translateZ(0px);
  &:before {
    content: '';
    background: currentColor;
    position: absolute;
    z-index: -1;
    inset: 0 var(--ck-dropdown-active-inset, -8px);
    border-radius: var(--ck-dropdown-active-border-radius, 12px);
    opacity: 0;
    transition: opacity 180ms ease;
  }
  &:after {
    content: '';
    position: absolute;
    z-index: -1;
    inset: 0 var(--ck-dropdown-active-inset, -8px);
    border-radius: 12px;
    opacity: 0;
    transition: opacity 180ms ease;
    outline: 2px solid var(--ck-focus-color);
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    font-size: 17px;
    padding: 8px 0;
  }
  @media only screen and (min-width: ${defaultTheme.mobileWidth}px) {
    &:hover {
      &:before {
        transition-duration: 80ms;
        opacity: 0.05;
      }
    }
  }
  &:active {
    transform: scale(0.99) translateZ(0px);
  }
  &:disabled {
    //opacity: 0.4;
    pointer-events: none;
  }
  &:focus-visible {
    outline: none !important;
    &:after {
      opacity: 1;
    }
  }
  ${(props) => props.$variant === "secondary" && Ae`
      padding: 12px 4px;
      margin: 0 0 8px;
      &:last-child {
        margin-bottom: 0;
      }
      &:before {
        opacity: 0.05;
      }
      &:hover:before {
        opacity: 0.1;
      }
    `}
`;
const ChainButtonStatus = styled(motion.div)`
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  display: flex;
  align-items: center;
  justify-content: center;

  color: var(--ck-body-color-muted);
  font-size: 15px;
  line-height: 18px;
  font-weight: 500;
  padding-right: 4px;
  span {
    display: block;
    position: relative;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    font-size: 17px;
    padding: 0;
  }
`;
const ChainButtonBg = styled(motion.div)`
  position: absolute;
  z-index: -1;
  inset: 0 var(--ck-dropdown-active-inset, -8px);
  background: var(--ck-dropdown-active-background, rgba(26, 136, 248, 0.1));
  box-shadow var(--ck-dropdown-active-box-shadow);
  border-radius: var(--ck-dropdown-active-border-radius, 12px);
  
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    inset: 0 var(--ck-dropdown-active-inset, -8px);
  }
`;
const Spinner$1$1 = jsxs("svg", { "aria-hidden": "true", width: "36", height: "36", viewBox: "0 0 36 36", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 16.75C2.69036 16.75 3.25 17.3096 3.25 18V19C3.25 26.5939 9.40609 32.75 17 32.75V35.25C8.02537 35.25 0.75 27.9746 0.75 19V18C0.75 17.3096 1.30964 16.75 2 16.75Z", fill: "url(#paint0_linear_1288_18701)" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_1288_18701", x1: "2", y1: "19.4884", x2: "16.8752", y2: "33.7485", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "var(--ck-spinner-color)" }), jsx("stop", { offset: "1", stopColor: "var(--ck-spinner-color)", stopOpacity: "0" })] }) })] });
const ChainSelectList = ({ variant }) => {
  const { connector } = useAccount();
  const { chain: chain2, chains: chains2 } = useNetwork();
  const { isLoading, pendingChainId, switchNetwork: switchNetwork2, error } = useSwitchNetwork();
  const locales = useLocales({});
  const mobile = isMobile();
  const isError = (error === null || error === void 0 ? void 0 : error["code"]) === 4902;
  const disabled = isError || !switchNetwork2;
  const handleSwitchNetwork = (chainId) => {
    if (switchNetwork2) {
      switchNetwork2(chainId);
    }
  };
  const { triggerResize } = useContext();
  return jsxs(SwitchNetworksContainer, { style: { marginBottom: switchNetwork2 ? -8 : 0 }, children: [jsx(ChainButtonContainer, { children: jsx(ChainButtons, { children: chains2.map((x2) => {
    var _a2;
    const c2 = supportedChains.find((ch3) => ch3.id === x2.id);
    const ch2 = { ...c2, ...x2 };
    return jsxs(ChainButton, { "$variant": variant, disabled: disabled || ch2.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) || isLoading && pendingChainId === ch2.id, onClick: () => handleSwitchNetwork === null || handleSwitchNetwork === void 0 ? void 0 : handleSwitchNetwork(ch2.id), style: {
      opacity: disabled && ch2.id !== (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) ? 0.4 : void 0
    }, children: [jsxs("span", { style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-start",
      gap: 12,
      color: ch2.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) ? "var(--ck-dropdown-active-color, inherit)" : "inherit"
    }, children: [jsxs(ChainLogoContainer, { children: [jsx(ChainLogoSpinner, { initial: { opacity: 0 }, animate: {
      opacity: isLoading && pendingChainId === ch2.id ? 1 : 0
    }, transition: {
      ease: [0.76, 0, 0.24, 1],
      duration: 0.15,
      delay: 0.1
    }, children: jsx(motion.div, { animate: (
      // UI fix for Coinbase Wallet on mobile does not remove isLoading on rejection event
      mobile && isCoinbaseWalletConnector(connector === null || connector === void 0 ? void 0 : connector.id) && isLoading && pendingChainId === ch2.id ? {
        opacity: [1, 0],
        transition: { delay: 4, duration: 3 }
      } : { opacity: 1 }
    ), children: Spinner$1$1 }, `${ch2 === null || ch2 === void 0 ? void 0 : ch2.id}-${ch2 === null || ch2 === void 0 ? void 0 : ch2.name}`) }), jsx(ChainIcon, { children: (_a2 = ch2.logo) !== null && _a2 !== void 0 ? _a2 : jsx(Chains.UnknownChain, {}) })] }), ch2.name] }), variant !== "secondary" && jsx(ChainButtonStatus, { children: jsxs(AnimatePresence, { initial: false, exitBeforeEnter: true, children: [ch2.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) && jsx(motion.span, { style: {
      color: "var(--ck-dropdown-active-color, var(--ck-focus-color))",
      display: "block",
      position: "relative"
    }, initial: { opacity: 0, x: -4 }, animate: { opacity: 1, x: 0 }, exit: {
      opacity: 0,
      x: 4,
      transition: { duration: 0.1, delay: 0 }
    }, transition: {
      ease: [0.76, 0, 0.24, 1],
      duration: 0.3,
      delay: 0.2
    }, children: locales.connected }, "connectedText"), isLoading && pendingChainId === ch2.id && jsx(motion.span, { style: {
      color: "var(--ck-dropdown-pending-color, inherit)",
      display: "block",
      position: "relative"
    }, initial: {
      opacity: 0,
      x: -4
    }, animate: { opacity: 1, x: 0 }, exit: { opacity: 0, x: 4 }, transition: {
      ease: [0.76, 0, 0.24, 1],
      duration: 0.3,
      delay: 0.1
    }, children: jsx(motion.span, { animate: (
      // UI fix for Coinbase Wallet on mobile does not remove isLoading on rejection event
      mobile && isCoinbaseWalletConnector(connector === null || connector === void 0 ? void 0 : connector.id) && {
        opacity: [1, 0],
        transition: { delay: 4, duration: 4 }
      }
    ), children: locales.approveInWallet }) }, "approveText")] }) }), variant === "secondary" ? jsx(ChainButtonBg, { initial: false, animate: {
      opacity: ch2.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) ? 1 : 0
    }, transition: {
      duration: 0.3,
      ease: "easeOut"
    } }) : (
      //hover === ch.name && (
      ch2.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) && jsx(ChainButtonBg, { layoutId: "activeChain", layout: "position", transition: {
        duration: 0.3,
        ease: "easeOut"
      } })
    )] }, `${ch2 === null || ch2 === void 0 ? void 0 : ch2.id}-${ch2 === null || ch2 === void 0 ? void 0 : ch2.name}`);
  }) }) }), jsx(AnimatePresence, { children: isError && jsx(motion.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
    ease: [0.76, 0, 0.24, 1],
    duration: 0.3
  }, onAnimationStart: triggerResize, onAnimationComplete: triggerResize, children: jsx("div", { style: { paddingTop: 10, paddingBottom: 8 }, children: jsxs(Alert, { children: [locales.warnings_walletSwitchingUnsupported, " ", locales.warnings_walletSwitchingUnsupportedResolve] }) }) }) })] });
};
const DropdownWindow = styled(motion.div)`
  z-index: 2147483647;
  position: fixed;
  inset: 0;
`;
const DropdownOverlay = styled(motion.div)`
  position: absolute;
  inset: 0;
`;
const DropdownContainer = styled(motion.div)`
  --shadow: 0px 2px 15px rgba(0, 0, 0, 0.15);
  --background: var(--ck-dropdown-background, var(--ck-tooltip-background));
  --border-radius: var(
    --ck-dropdown-border-radius,
    var(--ck-tooltip-border-radius, 12px)
  );

  pointer-events: auto;
  z-index: 2147483647;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  max-width: fit-content;
  padding: 14px 16px 16px;
  color: var(--ck-dropdown-color, var(--ck-tooltip-color));
  background: var(--background);
  box-shadow: var(
    --ck-dropdown-box-shadow,
    var(--ck-tooltip-shadow, var(--shadow))
  );
  border-radius: var(--border-radius);
`;
const DropdownHeading = styled(motion.div)`
  padding: 0 0 6px;
  font-size: 14px;
  line-height: 20px;
  font-weight: 400;
  user-select: none;
  color: var(--ck-dropdown-color, var(--ck-tooltip-color));
`;
const ChainSelectDropdown = ({ children, open, onClose, offsetX = 0, offsetY = 8 }) => {
  var _a2, _b, _c;
  const context = useContext();
  const themeContext = useThemeContext();
  const locales = useLocales();
  const [offset, setOffset] = reactExports.useState({ x: 0, y: 0 });
  useLockBodyScroll(open);
  const contentRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    const listener = (e2) => {
      var _a3, _b2, _c2;
      if (!open)
        return;
      if (e2.key === "Escape")
        onClose();
      if (e2.key === "ArrowDown" || e2.key === "ArrowUp") {
        if (!contentRef.current)
          return;
        e2.preventDefault();
        const focusableEls = (_a3 = contentRef.current) === null || _a3 === void 0 ? void 0 : _a3.querySelectorAll(`
            a[href]:not(:disabled),
            button:not(:disabled),
            textarea:not(:disabled),
            input[type="text"]:not(:disabled),
            input[type="radio"]:not(:disabled),
            input[type="checkbox"]:not(:disabled),
            select:not(:disabled)
          `), firstFocusableEl = focusableEls[0], lastFocusableEl = focusableEls[focusableEls.length - 1];
        if (e2.key === "ArrowUp") {
          if (document.activeElement === firstFocusableEl) {
            lastFocusableEl.focus();
          } else {
            let focusItem = (_b2 = document === null || document === void 0 ? void 0 : document.activeElement) === null || _b2 === void 0 ? void 0 : _b2.previousSibling;
            if (!focusItem)
              focusItem = lastFocusableEl;
            while (focusItem.disabled)
              focusItem = focusItem.previousSibling;
            focusItem.focus();
          }
        } else {
          if (document.activeElement === lastFocusableEl) {
            firstFocusableEl.focus();
          } else {
            let focusItem = (_c2 = document === null || document === void 0 ? void 0 : document.activeElement) === null || _c2 === void 0 ? void 0 : _c2.nextSibling;
            if (!focusItem)
              focusItem = firstFocusableEl;
            while (focusItem.disabled)
              focusItem = focusItem.nextSibling;
            focusItem.focus();
          }
        }
      }
    };
    document.addEventListener("keydown", listener);
    return () => {
      document.removeEventListener("keydown", listener);
    };
  }, [open]);
  const targetRef = reactExports.useRef(null);
  const innerRef = reactExports.useCallback((node2) => {
    if (!node2)
      return;
    targetRef.current = node2;
    refresh();
  }, [open]);
  const [ref, bounds] = useMeasure({
    debounce: 120,
    offsetSize: true,
    scroll: true
  });
  const refresh = () => {
    if (!targetRef.current || bounds.top + bounds.bottom + bounds.left + bounds.right + bounds.height + bounds.width === 0) {
      return;
    }
    let x2 = bounds.left + offsetX;
    let y2 = bounds.top + bounds.height + offsetY;
    targetRef.current.style.left = `${x2}px`;
    targetRef.current.style.top = `${y2}px`;
  };
  const useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  useIsomorphicLayoutEffect2(refresh, [targetRef.current, bounds, open]);
  reactExports.useEffect(refresh, [open, targetRef.current]);
  const onScroll = onClose;
  const onResize = onClose;
  reactExports.useEffect(() => {
    refresh();
    window.addEventListener("scroll", onScroll);
    window.addEventListener("resize", onResize);
    return () => {
      window.removeEventListener("scroll", onScroll);
      window.removeEventListener("resize", onResize);
    };
  }, []);
  return jsxs(Fragment$2, { children: [jsx("div", { ref, children }), jsx(AnimatePresence, { children: open && jsx(Portal, { children: jsx(ResetContainer, { "$useTheme": (_a2 = themeContext.theme) !== null && _a2 !== void 0 ? _a2 : context.theme, "$useMode": (_b = themeContext.mode) !== null && _b !== void 0 ? _b : context.mode, "$customTheme": (_c = themeContext.customTheme) !== null && _c !== void 0 ? _c : context.customTheme, children: jsx(FocusTrap, { children: jsxs(DropdownWindow, { ref: contentRef, children: [jsx(DropdownOverlay, { onClick: onClose }), jsxs(DropdownContainer, { ref: innerRef, style: {
    left: offset.x,
    top: offset.y
  }, initial: "collapsed", animate: "open", exit: "collapsed", variants: {
    collapsed: {
      transformOrigin: "0 0",
      opacity: 0,
      scale: 0.96,
      z: 0.01,
      y: -4,
      x: 0,
      transition: {
        duration: 0.1
      }
    },
    open: {
      transformOrigin: "0 0",
      willChange: "opacity,transform",
      opacity: 1,
      scale: 1,
      z: 0.01,
      y: 0,
      x: 0,
      transition: {
        ease: [0.76, 0, 0.24, 1],
        duration: 0.15
      }
    }
  }, children: [jsx(DropdownHeading, { children: locales.switchNetworks }), jsx(ChainSelectList, {})] })] }) }) }) }) })] });
};
const ChainContainer = styled.div`
  --bg: transparent;
  --color: #333;
  ${(props) => typeof props.size === "string" ? Ae`
          --width: ${props.size};
          --height: ${props.size};
        ` : Ae`
          --width: ${props.size >= 0 ? `${props.size}px` : "24px"};
          --height: ${props.size >= 0 ? `${props.size}px` : "24px"};
        `};
  ${(props) => typeof props.radius === "string" ? Ae`
          --radius: ${props.radius};
        ` : Ae`
          --radius: ${props.radius >= 0 ? `${props.radius}px` : "24px"};
        `};
  display: block;
  position: relative;
  width: var(--width);
  height: var(--height);
  min-width: var(--width);
  min-height: var(--height);
  border-radius: var(--radius);
  background: var(--ck-body-background-secondary);
  pointer-events: none;
  user-select: none;
  svg {
    display: block;
    width: 100%;
    height: auto;
  }
  > div {
    display: flex;
    align-items: center;
    justify-content: center;
  }
`;
const LogoContainer$1 = styled(motion.div)`
  display: block;
  position: absolute;
  inset: 0;
  overflow: hidden;
  border-radius: inherit;
  user-select: none;
  display: flex;
  align-items: center;
  justify-content: center;
  svg {
    display: block;
    width: 100%;
    height: auto;
  }
`;
const Spin = We`
  0%{ transform: rotate(0deg); }
  100%{ transform: rotate(360deg); }
`;
const LoadingContainer = styled(motion.div)`
  position: absolute;
  inset: 0;
  animation: ${Spin} 1s linear infinite;
  svg {
    display: block;
    position: absolute;
    inset: 0;
  }
`;
const Unsupported = styled(motion.div)`
  z-index: 2;
  position: absolute;
  top: 0;
  right: 0;
  width: 40%;
  height: 40%;
  min-width: 13px;
  min-height: 13px;
  color: var(--ck-body-color-danger, red);
  svg {
    display: block;
    position: relative;
    top: -30%;
    right: -30%;
  }
`;
const Spinner$5 = jsxs("svg", { "aria-hidden": "true", width: "36", height: "36", viewBox: "0 0 36 36", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.3592 30.1654C10.0472 29.4491 8.85718 28.524 7.83713 27.424C6.81708 26.324 5.98425 25.0677 5.36889 23.7054C5.20157 23.335 5.05033 22.9567 4.91578 22.5717C4.51465 21.4237 4.26735 20.2308 4.17794 19.0239C4.16599 18.8626 4.13894 18.7041 4.09809 18.5507C3.85023 17.6197 3.09399 16.8738 2.11531 16.7999C0.975331 16.7138 -0.0310983 17.5702 0.0141657 18.7125C0.0223289 18.9185 0.0340286 19.1243 0.049253 19.3298C0.165374 20.8971 0.486545 22.4464 1.00749 23.9373C1.10424 24.2142 1.20764 24.4884 1.31755 24.7596C2.13617 26.7799 3.31595 28.6371 4.80146 30.239C6.28696 31.841 8.04998 33.1573 10.0029 34.1258C10.2651 34.2558 10.5307 34.3796 10.7995 34.4969C12.247 35.1287 13.7676 35.5656 15.3217 35.7995C15.5255 35.8301 15.7298 35.8573 15.9346 35.881C17.0703 36.0122 18.0001 35.0731 18.0001 33.9299C18.0001 32.9484 17.3133 32.1381 16.4036 31.8208C16.2537 31.7685 16.0977 31.7296 15.9377 31.7056C14.7411 31.5255 13.5702 31.1891 12.4556 30.7026C12.0818 30.5394 11.716 30.3601 11.3592 30.1654Z", fill: "url(#paint0_linear_1288_1870)" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_1288_1870", x1: "2", y1: "19.4884", x2: "16.8752", y2: "33.7485", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "var(--ck-connectbutton-balance-color,currentColor)", stopOpacity: "0.7" }), jsx("stop", { offset: "1", stopColor: "var(--ck-connectbutton-balance-color,currentColor)", stopOpacity: "0" })] }) })] });
const Chain = ({ id: id2, unsupported, radius = "50%", size: size2 = 24 }) => {
  var _a2;
  const chain2 = supportedChains.find((c2) => c2.id === id2);
  const isMounted = useIsMounted();
  if (!isMounted)
    return jsx("div", { style: {
      width: size2,
      height: size2
    } });
  return jsx(ChainContainer, { size: size2, radius, children: jsxs(AnimatePresence, { initial: false, children: [unsupported && jsx(Unsupported, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: jsxs("svg", { width: "13", height: "12", viewBox: "0 0 13 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M2.61317 11.2501H9.46246C10.6009 11.2501 11.3256 10.3506 11.3256 9.3549C11.3256 9.05145 11.255 8.73244 11.0881 8.43303L7.65903 2.14708C7.659 2.14702 7.65897 2.14696 7.65893 2.1469C7.65889 2.14682 7.65884 2.14673 7.65879 2.14664C7.31045 1.50746 6.6741 1.17871 6.04 1.17871C5.41478 1.17871 4.763 1.50043 4.41518 2.14968L0.993416 8.43476C0.828865 8.72426 0.75 9.04297 0.75 9.3549C0.75 10.3506 1.47471 11.2501 2.61317 11.2501Z", fill: "currentColor", stroke: "var(--ck-body-background, #fff)", strokeWidth: "1.5" }), jsx("path", { d: "M6.03258 7.43916C5.77502 7.43916 5.63096 7.29153 5.62223 7.02311L5.55675 4.96973C5.54802 4.69684 5.74446 4.5 6.02821 4.5C6.3076 4.5 6.51277 4.70131 6.50404 4.9742L6.43856 7.01864C6.42546 7.29153 6.2814 7.43916 6.03258 7.43916ZM6.03258 9.11676C5.7401 9.11676 5.5 8.9065 5.5 8.60677C5.5 8.30704 5.7401 8.09678 6.03258 8.09678C6.32506 8.09678 6.56515 8.30256 6.56515 8.60677C6.56515 8.91097 6.32069 9.11676 6.03258 9.11676Z", fill: "white" })] }) }), id2 ? jsx(LogoContainer$1, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.3 }, children: (_a2 = chain2 === null || chain2 === void 0 ? void 0 : chain2.logo) !== null && _a2 !== void 0 ? _a2 : jsx(Chains.UnknownChain, {}) }, `${chain2 === null || chain2 === void 0 ? void 0 : chain2.id}-${chain2 === null || chain2 === void 0 ? void 0 : chain2.name}-${id2}`) : jsx(LoadingContainer, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.3 }, children: Spinner$5 }, "loading")] }) });
};
const Container$3 = styled(motion.div)``;
const SwitchChainButton = styled(motion.button)`
  --color: var(
    --ck-dropdown-button-color,
    var(--ck-button-primary-color, var(--ck-body-color))
  );
  --background: var(
    --ck-dropdown-button-background,
    var(--ck-secondary-button-background, var(--ck-body-background-secondary))
  );
  --box-shadow: var(
    --ck-dropdown-button-box-shadow,
    var(
      --ck-secondary-button-box-shadow,
      var(--ck-button-primary-box-shadow),
      none
    )
  );

  --hover-color: var(--ck-dropdown-button-hover-color, var(--color));
  --hover-background: var(
    --ck-dropdown-button-hover-background,
    var(--background)
  );
  --hover-box-shadow: var(
    --ck-dropdown-button-hover-box-shadow,
    var(--box-shadow)
  );

  --active-color: var(--ck-dropdown-button-active-color, var(--hover-color));
  --active-background: var(
    --ck-dropdown-button-active-background,
    var(--hover-background)
  );
  --active-box-shadow: var(
    --ck-dropdown-button-active-box-shadow,
    var(--hover-box-shadow)
  );

  appearance: none;
  user-select: none;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-radius: 15px;
  width: 52px;
  height: 30px;
  padding: 2px 6px 2px 3px;
  font-size: 16px;
  line-height: 19px;
  font-weight: 500;
  text-decoration: none;
  white-space: nowrap;
  transform: translateZ(0px);

  transition: 100ms ease;
  transition-property: transform, background-color, box-shadow, color;

  color: var(--color);
  background: var(--background);
  box-shadow: var(--box-shadow);

  svg {
    position: relative;
    display: block;
  }

  ${(props) => props.disabled ? Ae`
          width: auto;
          padding: 3px;
          position: relative;
          left: -22px;
        ` : Ae`
          cursor: pointer;

          @media only screen and (min-width: ${defaultTheme.mobileWidth + 1}px) {
            &:hover,
            &:focus-visible {
              color: var(--hover-color);
              background: var(--hover-background);
              box-shadow: var(--hover-box-shadow);
            }
            &:active {
              color: var(--active-color);
              background: var(--active-background);
              box-shadow: var(--active-box-shadow);
            }
          }
        `}
`;
const ChevronDown = ({ ...props }) => jsx("svg", { "aria-hidden": "true", width: "11", height: "6", viewBox: "0 0 11 6", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: jsx("path", { d: "M1.5 1L5.5 5L9.5 1", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }) });
const ChainSelector = () => {
  const context = useContext();
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const { chain: chain2, chains: chains2 } = useNetwork();
  const locales = useLocales({
    CHAIN: chain2 === null || chain2 === void 0 ? void 0 : chain2.name
  });
  const mobile = isMobile() || (window === null || window === void 0 ? void 0 : window.innerWidth) < defaultTheme.mobileWidth;
  reactExports.useEffect(() => {
    if (!context.open)
      setIsOpen(false);
  }, [context.open]);
  const disabled = chains2.length <= 1;
  return jsx(Fragment$2, { children: jsx(Container$3, { children: jsx(ChainSelectDropdown, { offsetX: -12, open: !mobile && isOpen, onClose: () => setIsOpen(false), children: jsxs(SwitchChainButton, { "aria-label": flattenChildren(locales.switchNetworks).toString(), disabled, onClick: () => {
    if (mobile) {
      context.setRoute(routes.SWITCHNETWORKS);
    } else {
      setIsOpen(!isOpen);
    }
  }, children: [disabled ? jsx(Tooltip, { message: locales.chainNetwork, xOffset: -6, delay: 0.01, children: jsx(Chain, { id: chain2 === null || chain2 === void 0 ? void 0 : chain2.id, unsupported: chain2 === null || chain2 === void 0 ? void 0 : chain2.unsupported }) }) : jsx(Chain, { id: chain2 === null || chain2 === void 0 ? void 0 : chain2.id, unsupported: chain2 === null || chain2 === void 0 ? void 0 : chain2.unsupported }), !disabled && jsx(ChevronDown, { style: { top: 1, left: -3 } })] }) }) }) });
};
const Profile = ({ closeModal }) => {
  var _a2, _b, _c;
  const context = useContext();
  const themeContext = useThemeContext();
  const locales = useLocales();
  const { reset: reset3 } = useConnect$1();
  const { disconnect: disconnect2 } = useDisconnect();
  const { chain: chain2 } = useNetwork();
  const { address: address2, isConnected, connector } = useAccount();
  const { data: ensName } = useEnsName({
    chainId: 1,
    address: address2
  });
  const { data: balance } = useBalance({
    address: address2
    //watch: true,
  });
  const [shouldDisconnect, setShouldDisconnect] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!isConnected)
      context.setOpen(false);
  }, [isConnected]);
  reactExports.useEffect(() => {
    if (!shouldDisconnect)
      return;
    if (closeModal) {
      closeModal();
    } else {
      context.setOpen(false);
    }
    return () => {
      disconnect2();
      reset3();
    };
  }, [shouldDisconnect, disconnect2, reset3]);
  const separator = ["web95", "rounded", "minimal"].includes((_b = (_a2 = themeContext.theme) !== null && _a2 !== void 0 ? _a2 : context.theme) !== null && _b !== void 0 ? _b : "") ? "...." : void 0;
  return jsxs(PageContent, { children: [jsxs(ModalContent, { style: { paddingBottom: 22, gap: 6 }, children: [jsx(AvatarContainer, { children: jsxs(AvatarInner, { children: [jsx(ChainSelectorContainer, { children: jsx(ChainSelector, {}) }), jsx(Avatar, { address: address2 })] }) }), jsx(ModalH1, { children: jsx(CopyToClipboard, { string: address2, children: ensName !== null && ensName !== void 0 ? ensName : truncateEthAddress(address2, separator) }) }), ((_c = context === null || context === void 0 ? void 0 : context.options) === null || _c === void 0 ? void 0 : _c.hideBalance) ? null : jsx(ModalBody, { children: jsx(BalanceContainer, { children: jsxs(AnimatePresence, { exitBeforeEnter: true, initial: false, children: [balance && jsxs(Balance$1, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.2 }, children: [nFormatter(Number(balance === null || balance === void 0 ? void 0 : balance.formatted)), ` `, balance === null || balance === void 0 ? void 0 : balance.symbol] }, `chain-${chain2 === null || chain2 === void 0 ? void 0 : chain2.id}`), !balance && jsx(LoadingBalance, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.2 }, children: " " })] }) }) })] }), !isSafeConnector(connector === null || connector === void 0 ? void 0 : connector.id) && jsx(Button, { onClick: () => setShouldDisconnect(true), icon: jsx(DisconnectIcon, {}), children: locales.disconnect })] });
};
const SwitchNetworks = () => {
  const { reset: reset3 } = useConnect$1();
  const { disconnect: disconnect2 } = useDisconnect();
  const { chain: chain2 } = useNetwork();
  const { connector } = useAccount();
  const locales = useLocales({});
  const onDisconnect = () => {
    disconnect2();
    reset3();
  };
  return jsx(PageContent, { style: { width: 278 }, children: jsxs(ModalContent, { style: { padding: 0, marginTop: -10 }, children: [(chain2 === null || chain2 === void 0 ? void 0 : chain2.unsupported) && jsxs(ModalBody, { children: [locales.warnings_chainUnsupported, " ", locales.warnings_chainUnsupportedResolve] }), jsx("div", { style: { padding: "6px 8px" }, children: jsx(ChainSelectList, { variant: "secondary" }) }), (chain2 === null || chain2 === void 0 ? void 0 : chain2.unsupported) && !isSafeConnector(connector === null || connector === void 0 ? void 0 : connector.id) && jsxs("div", { style: { paddingTop: 12 }, children: [jsx(OrDivider, {}), jsx(Button, { icon: jsx(DisconnectIcon, {}), variant: "secondary", onClick: onDisconnect, children: locales.disconnect })] })] }) });
};
const spinKeyframes = We`
  from{ transform: rotate(0deg); }
  to{   transform: rotate(360deg); }
`;
const lineKeyframes = We`
  from{ background-position: 0 0; }
  to{ background-position: 100% 0; }
`;
const ContentContainer = styled.div`
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    margin: 5px auto 24px;
    padding: 16px 16px;
    border-radius: var(--ck-tertiary-border-radius, 24px);
    box-shadow: var(--ck-tertiary-box-shadow, none);
    background: var(--ck-body-background-tertiary);
  }
`;
const LogoContainer = styled(motion.div)`
  z-index: 2;
  overflow: hidden;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 52px;
  height: 52px;
  border-radius: 100%;
  transition: inherit;
  background: var(--ck-body-background-secondary);
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.04);
  svg,
  img {
    display: block;
    width: 100%;
    height: 100%;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    width: 64px;
    height: 64px;
  }
`;
const StatusIcon = styled(motion.div)`
  z-index: 2;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 52px;
  height: 52px;
  color: currentColor;
  border-radius: 100%;
  transition: inherit;
  svg {
    z-index: 3;
    position: relative;
    transform: scale(0.89);
    transition: inherit;
    opacity: 0.5;
  }
  &:before {
    z-index: 1;
    content: '';
    position: absolute;
    inset: 10px;
    border-radius: inherit;
    border: 1px dashed var(--border-color);
    background: var(--ck-body-background);
    transition: inherit;
    animation: ${spinKeyframes} 10s linear infinite;
  }
  &:after {
    z-index: 2;
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    background: #34c759;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.04);
    transform: scale(0);
    transition: inherit;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    width: 64px;
    height: 64px;
    svg {
      transform: scale(1.1);
    }
  }
`;
const StatusGraphicBgSvg = styled(motion.svg)`
  display: block;
  position: relative;
  margin: 0 auto;
  transition: inherit;
  overflow: visible;
  rect {
    stroke: var(--border-color);
    rx: var(--ck-border-radius);
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    display: none;
  }
`;
const StatusGraphic = styled(motion.div)`
  --border-color: var(--ck-siwe-border, var(--ck-body-divider));
  --border-size: 0;
  --border-style: dashed;

  user-select: none;
  pointer-events: none;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 14px;
  width: 100%;
  margin: 12px auto;
  padding: 42px 32px;
  transition: all 320ms cubic-bezier(0.175, 0.885, 0.32, 1.1);
  border: var(--border-size) var(--border-style) var(--border-color);
  border-radius: var(--ck-border-radius);

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    --border-size: 1px;
    margin: 0 auto 20px;
    padding: 38px 0;
    gap: 18px;
    + div {
      // easier than wrapping in another styled component
      padding-bottom: 10px;
    }
  }

  > div {
    z-index: 2;
    position: relative;
    transition: inherit;
  }

  &:before,
  &:after {
    z-index: 1;
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 120px;
    height: 1px;
    margin-left: -60px;
    transition: inherit;
    animation: ${lineKeyframes} 10s linear infinite;
    background: linear-gradient(
      90deg,
      var(--border-color),
      var(--border-color) 50%,
      transparent 50%,
      transparent 100%
    );
    background-size: 6px 1px;
  }

  &:after {
    background: var(--border-color);
    transform: scaleX(0);
  }

  ${({ $connected }) => $connected && Ae`
      &:before {
        opacity: 0;
      }
      &:after {
        transform: none;
      }
      ${StatusGraphicBgSvg} {
        rect {
          stroke-dasharray: 0 0;
        }
      }
      ${LogoContainer} {
        transform: scale(0.62);
      }
      ${StatusIcon} {
        svg {
          transform: scale(1.5);
          opacity: 1;
          color: #fff;
        }
        &:before {
          transform: scale(0);
        }
        &:after {
          transform: scale(1);
        }
      }
      @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
        --border-size: 1px;
        --border-style: solid;
        ${StatusIcon} {
          svg {
            transform: scale(1.75);
          }
        }
      }
    `};
`;
const SIWEButton = ({ showSignOutButton, onSignIn, onSignOut }) => {
  const isMounted = useIsMounted();
  const locales = useLocales();
  const { setOpen } = useModal();
  const { isSignedIn, isReady, isLoading, isRejected, isSuccess, isError, signIn, signOut, error } = useSIWE({
    onSignIn: (data2) => onSignIn === null || onSignIn === void 0 ? void 0 : onSignIn(data2),
    onSignOut: () => onSignOut === null || onSignOut === void 0 ? void 0 : onSignOut()
  });
  const { address: connectedAddress } = useAccount();
  function getButtonLabel() {
    if (isSuccess)
      return locales.signedIn;
    if (isRejected)
      return locales.tryAgain;
    if (isLoading)
      return locales.awaitingConfirmation;
    if (isError)
      return error !== null && error !== void 0 ? error : "Unknown Error";
    if (isReady)
      return locales.signIn;
    return locales.signIn;
  }
  if (!isMounted) {
    return jsx(Button, { style: { margin: 0 }, disabled: true }, "loading");
  }
  if (showSignOutButton && isSignedIn) {
    return jsx(Button, { style: { margin: 0 }, onClick: signOut, icon: jsx(DisconnectIcon, {}), children: locales.signOut }, "button");
  }
  if (!connectedAddress) {
    return jsx(Button, { style: { margin: 0 }, onClick: () => setOpen(true), arrow: true, children: locales.walletNotConnected }, "button");
  }
  return jsx(Button, { style: { margin: 0 }, arrow: !isSignedIn ? !isLoading && !isRejected : false, onClick: !isLoading && !isSuccess ? signIn : void 0, disabled: isLoading, waiting: isLoading, icon: isRejected && jsx(motion.div, { initial: {
    rotate: -270
  }, animate: {
    rotate: 0
  }, transition: {
    duration: 1,
    ease: [0.175, 0.885, 0.32, 0.98]
  }, children: jsx(RetryIcon, { style: { opacity: 0.4 } }) }), children: getButtonLabel() }, "button");
};
const LazyImage = ({ src: src2, alt, width, height }) => {
  const imageRef = reactExports.useRef(null);
  const [loaded, setLoaded] = reactExports.useState(true);
  reactExports.useEffect(() => {
    if (!(imageRef.current && imageRef.current.complete && imageRef.current.naturalHeight !== 0)) {
      setLoaded(false);
    }
  }, [src2]);
  return jsx("div", { style: {
    width,
    height,
    background: "rgba(0,0,0,0.02)",
    boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.02)"
  }, children: jsx("img", { ref: imageRef, src: src2, alt, width, height, onLoad: () => setLoaded(true), style: { transition: "opacity 0.2s ease", opacity: loaded ? 1 : 0 } }) });
};
const transition = { duration: 0.2, ease: [0.26, 0.08, 0.25, 1] };
const copyTransition = { duration: 0.16, ease: [0.26, 0.08, 0.25, 1] };
const SignInWithEthereum = () => {
  var _a2, _b;
  const context = useContext();
  const { isSignedIn, reset: reset3 } = useSIWE();
  const mobile = isMobile();
  const [status, setStatus] = reactExports.useState(isSignedIn ? "signedIn" : "signedOut");
  const locales = useLocales({});
  const copy2 = status === "signedIn" ? {
    heading: locales.signInWithEthereumScreen_signedIn_heading,
    h1: locales.signInWithEthereumScreen_signedIn_h1,
    p: locales.signInWithEthereumScreen_signedIn_p,
    button: locales.signInWithEthereumScreen_signedIn_button
  } : {
    heading: locales.signInWithEthereumScreen_signedOut_heading,
    h1: locales.signInWithEthereumScreen_signedOut_h1,
    p: locales.signInWithEthereumScreen_signedOut_p,
    button: locales.signInWithEthereumScreen_signedOut_button
  };
  reactExports.useEffect(() => {
    if (isSignedIn)
      setStatus("signedIn");
  }, []);
  reactExports.useEffect(() => {
    if (!isSignedIn)
      setStatus("signedOut");
  }, [isSignedIn]);
  const { address: address2 } = useAccount();
  const getFavicons = () => {
    const favicons2 = {
      svg: null,
      default: null
    };
    const nodeList = document.getElementsByTagName("link");
    Array.from(nodeList).forEach((node2) => {
      if ((node2.getAttribute("rel") === "icon" || node2.getAttribute("rel") === "shortcut icon") && node2.getAttribute("href")) {
        if (node2.getAttribute("type") === "image/svg+xml") {
          favicons2.svg = node2.getAttribute("href");
        } else {
          favicons2.default = node2.getAttribute("href");
        }
      }
    });
    return favicons2;
  };
  const favicons = getFavicons();
  const favicon = (_b = (_a2 = getAppIcon()) !== null && _a2 !== void 0 ? _a2 : favicons.svg) !== null && _b !== void 0 ? _b : favicons.default;
  return jsx(PageContent, { style: { width: 278 }, children: jsxs(ModalContent, { style: { padding: 0, marginTop: -10 }, children: [jsx(ContentContainer, { children: jsx(AnimatePresence, { exitBeforeEnter: true, children: jsx(motion.div, { initial: mobile ? false : { opacity: 0, scale: 0.94 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.94 }, transition: copyTransition, children: jsx(ModalBody, { style: { height: 42 }, children: jsx(FitText, { children: copy2.h1 }) }) }, flattenChildren(copy2.h1).toString()) }) }), jsxs(StatusGraphic, { "$connected": isSignedIn, children: [jsx("div", { style: { position: "absolute", inset: 0 }, children: jsx(StatusGraphicBgSvg, { width: "262", height: "134", viewBox: "0 0 262 134", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx(motion.rect, { x: "0", y: "0", rx: "12", width: "262", height: "134", strokeDasharray: "3 3", animate: {
    strokeDashoffset: [0, -6]
  }, transition: {
    duration: 0.4,
    ease: "linear",
    repeat: Infinity
  } }) }) }), jsx(motion.div, { initial: mobile ? false : {
    opacity: 0,
    x: 50,
    scale: 0.8
  }, animate: {
    opacity: 1,
    x: 0,
    scale: 1
  }, transition, children: jsx(LogoContainer, { children: jsx(Avatar, { address: address2, size: 64 }) }) }, "avatarImage"), jsx(motion.div, { initial: mobile ? false : {
    scale: 0.6
  }, animate: {
    scale: 1
  }, transition: {
    ...transition
  }, children: jsx(StatusIcon, { children: jsx(TickIcon, {}) }) }, "tickIcon"), jsx(motion.div, { initial: mobile ? false : {
    opacity: 0,
    x: -40,
    scale: 0.8
  }, animate: {
    opacity: 1,
    x: 0,
    scale: 1
  }, transition: {
    ...transition
  }, children: jsx(LogoContainer, { children: favicon ? jsx(LazyImage, { src: favicon, alt: "app" }) : jsx(Chains.UnknownChain, {}) }) }, "appLogo")] }, "status"), jsx(AnimatePresence, { exitBeforeEnter: true, children: jsx(motion.div, { style: { paddingBottom: mobile ? 24 : 12 }, initial: mobile ? false : { opacity: 0, scale: 0.94 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.94 }, transition: copyTransition, children: jsx(ModalBody, { style: { height: 42, marginTop: -1, marginBottom: -3 }, children: jsx(FitText, { children: copy2.p }) }) }, flattenChildren(copy2.p).toString()) }), jsx(SIWEButton, { showSignOutButton: status === "signedIn", onSignIn: () => {
    setTimeout(() => {
      context.setOpen(false);
    }, 1e3);
  } })] }) });
};
const customThemeDefault$1 = {};
const ConnectModal$1 = ({ mode: mode2 = "auto", theme = "auto", customTheme = customThemeDefault$1, lang = "en-US" }) => {
  var _a2;
  const context = useContext();
  const { isConnected } = useAccount();
  const { chain: chain2 } = useNetwork();
  const closeable = !(((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.enforceSupportedChains) && (chain2 === null || chain2 === void 0 ? void 0 : chain2.unsupported));
  const showBackButton = closeable && context.route !== routes.CONNECTORS && context.route !== routes.PROFILE;
  const showInfoButton = closeable && context.route !== routes.PROFILE;
  const onBack = () => {
    if (context.route === routes.SIGNINWITHETHEREUM) {
      context.setRoute(routes.PROFILE);
    } else if (context.route === routes.SWITCHNETWORKS) {
      context.setRoute(routes.PROFILE);
    } else if (context.route === routes.DOWNLOAD) {
      context.setRoute(routes.CONNECT);
    } else {
      context.setRoute(routes.CONNECTORS);
    }
  };
  const pages = {
    onboarding: jsx(Introduction, {}),
    about: jsx(About, {}),
    download: jsx(DownloadApp, {}),
    connectors: jsx(Wallets, {}),
    mobileConnectors: jsx(MobileConnectors, {}),
    connect: jsx(ConnectUsing, {}),
    profile: jsx(Profile, {}),
    switchNetworks: jsx(SwitchNetworks, {}),
    signInWithEthereum: jsx(SignInWithEthereum, {})
  };
  function hide() {
    context.setOpen(false);
  }
  reactExports.useEffect(() => {
    var _a3;
    if (isConnected) {
      if (context.route !== routes.PROFILE || context.route !== routes.SIGNINWITHETHEREUM) {
        if (context.signInWithEthereum && !((_a3 = context.options) === null || _a3 === void 0 ? void 0 : _a3.disableSiweRedirect)) {
          context.setRoute(routes.SIGNINWITHETHEREUM);
        } else {
          hide();
        }
      }
    } else {
      hide();
    }
  }, [isConnected]);
  reactExports.useEffect(() => context.setMode(mode2), [mode2]);
  reactExports.useEffect(() => context.setTheme(theme), [theme]);
  reactExports.useEffect(() => context.setCustomTheme(customTheme), [customTheme]);
  reactExports.useEffect(() => context.setLang(lang), [lang]);
  reactExports.useEffect(() => {
    const appName = getAppName();
    if (!appName || !context.open)
      return;
    const title = document.createElement("meta");
    title.setAttribute("property", "og:title");
    title.setAttribute("content", appName);
    document.head.prepend(title);
    return () => {
      document.head.removeChild(title);
    };
  }, [context.open]);
  return jsx(ConnectKitThemeProvider, { theme, customTheme, mode: mode2, children: jsx(Modal, { open: context.open, pages, pageId: context.route, onClose: closeable ? hide : void 0, onInfo: showInfoButton ? () => context.setRoute(routes.ABOUT) : void 0, onBack: showBackButton ? onBack : void 0 }) });
};
function useGoogleFont(font) {
  reactExports.useEffect(() => {
    if (!font)
      return;
    font = font.replace(/ /g, "+");
    const googleapis = document.createElement("link");
    googleapis.href = `https://fonts.googleapis.com`;
    googleapis.rel = "preconnect";
    const gstatic = document.createElement("link");
    gstatic.href = `https://fonts.gstatic.com`;
    gstatic.rel = "preconnect";
    gstatic.crossOrigin = "true";
    const link = document.createElement("link");
    link.href = `https://fonts.googleapis.com/css2?family=${font}:wght@400;500;600&display=swap`;
    link.rel = "stylesheet";
    document.head.appendChild(googleapis);
    document.head.appendChild(gstatic);
    document.head.appendChild(link);
    return () => {
      document.head.removeChild(googleapis);
      document.head.removeChild(gstatic);
      document.head.removeChild(link);
    };
  }, [font]);
}
function useThemeFont(theme) {
  var _a2;
  const themeFonts = {
    web95: "Lato",
    retro: "Nunito",
    midnight: "Inter",
    minimal: "Inter",
    rounded: "Nunito"
  };
  const font = (_a2 = themeFonts[theme]) !== null && _a2 !== void 0 ? _a2 : null;
  useGoogleFont(font !== null && font !== void 0 ? font : "");
}
function useChains() {
  var _a2;
  const connectors = useConnectors();
  return (_a2 = connectors[0]) === null || _a2 === void 0 ? void 0 : _a2.chains;
}
const useConnectCallback = ({ onConnect, onDisconnect }) => {
  useAccount({
    onConnect: ({ address: address2, connector, isReconnected }) => {
      if (!isReconnected) {
        onConnect === null || onConnect === void 0 ? void 0 : onConnect({
          address: address2,
          connectorId: connector === null || connector === void 0 ? void 0 : connector.id
        });
      }
    },
    onDisconnect: () => onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect()
  });
};
const routes = {
  ONBOARDING: "onboarding",
  ABOUT: "about",
  CONNECTORS: "connectors",
  MOBILECONNECTORS: "mobileConnectors",
  CONNECT: "connect",
  DOWNLOAD: "download",
  PROFILE: "profile",
  SWITCHNETWORKS: "switchNetworks",
  SIGNINWITHETHEREUM: "signInWithEthereum"
};
const Context = reactExports.createContext(null);
const ConnectKitProvider = ({ children, theme = "auto", mode: mode2 = "auto", customTheme, options, onConnect, onDisconnect, debugMode = false }) => {
  var _a2, _b, _c, _d;
  if (React$1.useContext(Context)) {
    throw new Error("Multiple, nested usages of ConnectKitProvider detected. Please use only one.");
  }
  useConnectCallback({
    onConnect,
    onDisconnect
  });
  const chains2 = useChains();
  const injectedConnector = useConnector("injected");
  const defaultOptions2 = {
    language: "en-US",
    hideBalance: false,
    hideTooltips: false,
    hideQuestionMarkCTA: false,
    hideNoWalletCTA: false,
    walletConnectCTA: "link",
    hideRecentBadge: false,
    avoidLayoutShift: true,
    embedGoogleFonts: false,
    truncateLongENSAddress: true,
    walletConnectName: void 0,
    reducedMotion: false,
    disclaimer: null,
    bufferPolyfill: true,
    customAvatar: void 0,
    initialChainId: (_a2 = chains2 === null || chains2 === void 0 ? void 0 : chains2[0]) === null || _a2 === void 0 ? void 0 : _a2.id,
    enforceSupportedChains: true,
    ethereumOnboardingUrl: void 0,
    walletOnboardingUrl: void 0,
    disableSiweRedirect: false
  };
  const opts = Object.assign({}, defaultOptions2, options);
  if (typeof window !== "undefined") {
    if (opts.bufferPolyfill)
      window.Buffer = (_b = window.Buffer) !== null && _b !== void 0 ? _b : buffer$3.Buffer;
  }
  const [ckTheme, setTheme] = reactExports.useState(theme);
  const [ckMode, setMode] = reactExports.useState(mode2);
  const [ckCustomTheme, setCustomTheme] = reactExports.useState(customTheme !== null && customTheme !== void 0 ? customTheme : {});
  const [ckLang, setLang] = reactExports.useState("en-US");
  const [open, setOpen] = reactExports.useState(false);
  const [connector, setConnector] = reactExports.useState({
    id: "",
    name: void 0
  });
  const [route, setRoute] = reactExports.useState(routes.CONNECTORS);
  const [errorMessage, setErrorMessage] = reactExports.useState("");
  const [resize, onResize] = reactExports.useState(0);
  if (opts.embedGoogleFonts)
    useThemeFont(theme);
  reactExports.useEffect(() => setTheme(theme), [theme]);
  reactExports.useEffect(() => setLang(opts.language || "en-US"), [opts.language]);
  reactExports.useEffect(() => setErrorMessage(null), [route, open]);
  const { chain: chain2 } = useNetwork();
  reactExports.useEffect(() => {
    if (opts.enforceSupportedChains && (chain2 === null || chain2 === void 0 ? void 0 : chain2.unsupported)) {
      setOpen(true);
      setRoute(routes.SWITCHNETWORKS);
    }
  }, [chain2, route, open]);
  reactExports.useEffect(() => {
    if (isFamily()) {
      injectedConnector === null || injectedConnector === void 0 ? void 0 : injectedConnector.connect();
    }
  }, [injectedConnector]);
  const log3 = debugMode ? console.log : () => {
  };
  const value = {
    theme: ckTheme,
    setTheme,
    mode: ckMode,
    setMode,
    customTheme,
    setCustomTheme,
    lang: ckLang,
    setLang,
    open,
    setOpen,
    route,
    setRoute,
    connector,
    setConnector,
    signInWithEthereum: (_d = (_c = React$1.useContext(SIWEContext)) === null || _c === void 0 ? void 0 : _c.enabled) !== null && _d !== void 0 ? _d : false,
    onConnect,
    // Other configuration
    options: opts,
    errorMessage,
    debugMode,
    log: log3,
    displayError: (message, code2) => {
      setErrorMessage(message);
      console.log("---------CONNECTKIT DEBUG---------");
      console.log(message);
      if (code2)
        console.table(code2);
      console.log("---------/CONNECTKIT DEBUG---------");
    },
    resize,
    triggerResize: () => onResize((prev) => prev + 1)
  };
  return reactExports.createElement(Context.Provider, { value }, jsx(Fragment$2, { children: jsxs(Le, { theme: defaultTheme$1, children: [children, jsx(ConnectModal$1, { lang: ckLang, theme: ckTheme, mode: mode2, customTheme: ckCustomTheme })] }) }));
};
const useContext = () => {
  const context = React$1.useContext(Context);
  if (!context)
    throw Error("ConnectKit Hook must be inside a Provider.");
  return context;
};
const safeRoutes = {
  disconnected: [
    routes.CONNECTORS,
    routes.ABOUT,
    routes.ONBOARDING,
    routes.MOBILECONNECTORS,
    routes.ONBOARDING
  ],
  connected: [routes.PROFILE, routes.SWITCHNETWORKS, routes.SIGNINWITHETHEREUM]
};
const allRoutes = [
  ...safeRoutes.connected,
  ...safeRoutes.disconnected
];
const useModal = ({ onConnect, onDisconnect } = {}) => {
  const context = useContext();
  useConnectCallback({
    onConnect,
    onDisconnect
  });
  const { isConnected } = useAccount();
  const { signIn } = useSIWE();
  const close = () => {
    context.setOpen(false);
  };
  const open = () => {
    context.setOpen(true);
  };
  const gotoAndOpen = (route) => {
    let validRoute = route;
    if (!allRoutes.includes(route)) {
      validRoute = isConnected ? routes.PROFILE : routes.CONNECTORS;
      context.log(`Route ${route} is not a valid route, navigating to ${validRoute} instead.`);
    } else {
      if (isConnected) {
        if (!safeRoutes.connected.includes(route)) {
          validRoute = routes.PROFILE;
          context.log(`Route ${route} is not a valid route when connected, navigating to ${validRoute} instead.`);
        }
      } else {
        if (!safeRoutes.disconnected.includes(route)) {
          validRoute = routes.CONNECTORS;
          context.log(`Route ${route} is not a valid route when disconnected, navigating to ${validRoute} instead.`);
        }
      }
    }
    context.setRoute(validRoute);
    open();
  };
  return {
    open: context.open,
    setOpen: (show) => {
      if (show) {
        gotoAndOpen(isConnected ? routes.PROFILE : routes.CONNECTORS);
      } else {
        close();
      }
    },
    // Disconnected Routes
    openAbout: () => gotoAndOpen(routes.ABOUT),
    openOnboarding: () => gotoAndOpen(routes.ONBOARDING),
    // Connected Routes
    openProfile: () => gotoAndOpen(routes.PROFILE),
    openSwitchNetworks: () => gotoAndOpen(routes.SWITCHNETWORKS),
    openSIWE: (triggerSIWE) => {
      gotoAndOpen(routes.SIGNINWITHETHEREUM);
      if (triggerSIWE)
        signIn();
    }
  };
};
const TextContainer = styled(motion.div)`
  top: 0;
  bottom: 0;
  left: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  white-space: nowrap;
`;
styled(motion.div)`
  position: relative;
  width: 24px;
  height: 24px;
  border-radius: 12px;
  overflow: hidden;
  svg {
    display: block;
  }
`;
const IconContainer = styled(motion.div)`
  pointer-events: none;
  user-select: none;
  position: relative;
  width: 24px;
  height: 24px;
  margin-right: 8px;
`;
const UnsupportedNetworkContainer = styled(motion.div)`
  z-index: 1;
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 100%;
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.02);
  background: var(--ck-body-color-danger, red);
  color: #fff;
  svg {
    display: block;
    position: relative;
    top: -1px;
  }
`;
const Container$2 = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: flex-start;
  position: relative;
  height: 40px;
  padding: 0;
  line-height: 0;
  letter-spacing: -0.2px;
  font-size: var(--ck-connectbutton-font-size, 16px);
  font-weight: var(--ck-connectbutton-font-weight, 500);
  text-align: center;
  transition: 100ms ease;
  transition-property: color, background, box-shadow, border-radius;

  color: var(--color);
  background: var(--background);
  box-shadow: var(--box-shadow);
  border-radius: var(--border-radius);

  &.primary {
    --color: var(--ck-connectbutton-color);
    --background: var(--ck-connectbutton-background);
    --box-shadow: var(--ck-connectbutton-box-shadow);
    --border-radius: var(--ck-connectbutton-border-radius, 12px);

    --hover-color: var(--ck-connectbutton-hover-color, var(--color));
    --hover-background: var(
      --ck-connectbutton-hover-background,
      var(--background)
    );
    --hover-box-shadow: var(
      --ck-connectbutton-hover-box-shadow,
      var(--box-shadow)
    );
    --hover-border-radius: var(
      --ck-connectbutton-hover-border-radius,
      var(--border-radius)
    );

    --active-color: var(--ck-connectbutton-active-color, var(--hover-color));
    --active-background: var(
      --ck-connectbutton-active-background,
      var(--hover-background)
    );
    --active-box-shadow: var(
      --ck-connectbutton-active-box-shadow,
      var(--hover-box-shadow)
    );
    --active-border-radius: var(
      --ck-connectbutton-active-border-radius,
      var(--hover-border-radius)
    );
  }
  &.secondary {
    --color: var(--ck-connectbutton-balance-color);
    --background: var(--ck-connectbutton-balance-background);
    --box-shadow: var(--ck-connectbutton-balance-box-shadow);
    --border-radius: var(
      --ck-connectbutton-balance-border-radius,
      var(--ck-connectbutton-border-radius, 12px)
    );

    --hover-color: var(--ck-connectbutton-balance-hover-color, var(--color));
    --hover-background: var(
      --ck-connectbutton-balance-hover-background,
      var(--background)
    );
    --hover-box-shadow: var(
      --ck-connectbutton-balance-hover-box-shadow,
      var(--box-shadow)
    );
    --hover-border-radius: var(
      --ck-connectbutton-balance-hover-border-radius,
      var(--border-radius)
    );

    --active-color: var(
      --ck-connectbutton-balance-active-color,
      var(--hover-color)
    );
    --active-background: var(
      --ck-connectbutton-balance-active-background,
      var(--hover-background)
    );
    --active-box-shadow: var(
      --ck-connectbutton-balance-active-box-shadow,
      var(--hover-box-shadow)
    );
    --active-border-radius: var(
      --ck-connectbutton-balance-active-border-radius,
      var(--hover-border-radius)
    );
  }
`;
const ThemeContainer = styled.button`
  all: initial;
  appearance: none;
  user-select: none;
  position: relative;
  padding: 0;
  margin: 0;
  background: none;
  border-radius: var(--ck-border-radius);

  &:disabled {
    pointer-events: none;
    opacity: 0.3;
  }

  display: flex;
  flex-wrap: nowrap;
  background: none;
  cursor: pointer;
  * {
    cursor: pointer;
  }
  &:hover {
    ${Container$2} {
      color: var(--hover-color, var(--color));
      background: var(--hover-background, var(--background));
      box-shadow: var(--hover-box-shadow, var(--box-shadow));
      border-radius: var(--hover-border-radius, var(--border-radius));
    }
  }
  &:active {
    ${Container$2} {
      color: var(--active-color, var(--hover-color, var(--color)));
      background: var(
        --active-background,
        var(--hover-background, var(--background))
      );
      box-shadow: var(
        --active-box-shadow,
        var(--hover-box-shadow, var(--box-shadow))
      );
      border-radius: var(
        --active-border-radius,
        var(--hover-border-radius, var(--border-radius))
      );
    }
  }
  &:focus-visible {
    outline: 2px solid var(--ck-family-brand);
  }
`;
const ThemedButton = ({ children, variant = "primary", autoSize = true, duration = 0.3, style: style2 }) => {
  const [contentRef, bounds] = useMeasure();
  return jsx(Container$2, { className: variant, initial: false, animate: autoSize ? {
    width: bounds.width > 10 ? bounds.width : "auto"
  } : void 0, transition: {
    duration,
    ease: [0.25, 1, 0.5, 1],
    delay: 0.01
  }, style: style2, children: jsx("div", { ref: contentRef, style: {
    whiteSpace: "nowrap",
    width: "fit-content",
    position: "relative",
    padding: "0 12px"
  }, children }) });
};
const Container$1 = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
`;
const PlaceholderKeyframes = We`
  0%,100%{ opacity: 0.1; transform: scale(0.75); }
  50%{ opacity: 0.75; transform: scale(1.2) }
`;
const PulseContainer = styled.div`
  pointer-events: none;
  user-select: none;
  padding: 0 5px;
  span {
    display: inline-block;
    vertical-align: middle;
    margin: 0 2px;
    width: 3px;
    height: 3px;
    border-radius: 4px;
    background: currentColor;
    animation: ${PlaceholderKeyframes} 1000ms ease infinite both;
  }
`;
const Balance = ({ hideIcon, hideSymbol }) => {
  const isMounted = useIsMounted();
  const [isInitial, setIsInitial] = reactExports.useState(true);
  const { address: address2 } = useAccount();
  const { chain: chain2 } = useNetwork();
  const { data: balance } = useBalance({
    address: address2,
    chainId: chain2 === null || chain2 === void 0 ? void 0 : chain2.id,
    watch: true
  });
  const currentChain = supportedChains.find((c2) => c2.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id));
  const state = `${!isMounted || (balance === null || balance === void 0 ? void 0 : balance.formatted) === void 0 ? `balance-loading` : `balance-${currentChain === null || currentChain === void 0 ? void 0 : currentChain.id}-${balance === null || balance === void 0 ? void 0 : balance.formatted}`}`;
  reactExports.useEffect(() => {
    setIsInitial(false);
  }, []);
  return jsx("div", { style: { position: "relative" }, children: jsx(AnimatePresence, { initial: false, children: jsx(motion.div, { initial: (balance === null || balance === void 0 ? void 0 : balance.formatted) !== void 0 && isInitial ? {
    opacity: 1
  } : { opacity: 0, position: "absolute", top: 0, left: 0, bottom: 0 }, animate: { opacity: 1, position: "relative" }, exit: {
    opacity: 0,
    position: "absolute",
    top: 0,
    left: 0,
    bottom: 0
  }, transition: {
    duration: 0.4,
    ease: [0.25, 1, 0.5, 1],
    delay: 0.4
  }, children: !address2 || !isMounted || (balance === null || balance === void 0 ? void 0 : balance.formatted) === void 0 ? jsxs(Container$1, { children: [!hideIcon && jsx(Chain, {}), jsx("span", { style: { minWidth: 32 }, children: jsxs(PulseContainer, { children: [jsx("span", { style: { animationDelay: "0ms" } }), jsx("span", { style: { animationDelay: "50ms" } }), jsx("span", { style: { animationDelay: "100ms" } })] }) })] }) : (chain2 === null || chain2 === void 0 ? void 0 : chain2.unsupported) ? jsxs(Container$1, { children: [!hideIcon && jsx(Chain, { id: chain2 === null || chain2 === void 0 ? void 0 : chain2.id }), jsx("span", { style: { minWidth: 32 }, children: "???" })] }) : jsxs(Container$1, { children: [!hideIcon && jsx(Chain, { id: chain2 === null || chain2 === void 0 ? void 0 : chain2.id }), jsx("span", { style: { minWidth: 32 }, children: nFormatter(Number(balance === null || balance === void 0 ? void 0 : balance.formatted)) }), !hideSymbol && ` ${balance === null || balance === void 0 ? void 0 : balance.symbol}`] }) }, state) }) });
};
const contentVariants = {
  initial: {
    zIndex: 2,
    opacity: 0,
    x: "-100%"
  },
  animate: {
    opacity: 1,
    x: 0.1,
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  },
  exit: {
    zIndex: 1,
    opacity: 0,
    x: "-100%",
    pointerEvents: "none",
    position: "absolute",
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  }
};
const addressVariants = {
  initial: {
    zIndex: 2,
    opacity: 0,
    x: "100%"
  },
  animate: {
    x: 0.2,
    opacity: 1,
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  },
  exit: {
    zIndex: 1,
    x: "100%",
    opacity: 0,
    pointerEvents: "none",
    position: "absolute",
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  }
};
const textVariants = {
  initial: {
    opacity: 0
  },
  animate: {
    opacity: 1,
    transition: {
      duration: 0.3,
      ease: [0.25, 1, 0.5, 1]
    }
  },
  exit: {
    position: "absolute",
    opacity: 0,
    transition: {
      duration: 0.3,
      ease: [0.25, 1, 0.5, 1]
    }
  }
};
const ConnectButtonRenderer = ({ children }) => {
  const isMounted = useIsMounted();
  const context = useContext();
  const { open, setOpen } = useModal();
  const { chain: chain2 } = useNetwork();
  const { address: address2, isConnected } = useAccount();
  const { data: ensName } = useEnsName({
    chainId: 1,
    address: address2
  });
  function hide() {
    setOpen(false);
  }
  function show() {
    setOpen(true);
    context.setRoute(isConnected ? routes.PROFILE : routes.CONNECTORS);
  }
  if (!children)
    return null;
  if (!isMounted)
    return null;
  return jsx(Fragment$2, { children: children({
    show,
    hide,
    chain: chain2,
    unsupported: !!(chain2 === null || chain2 === void 0 ? void 0 : chain2.unsupported),
    isConnected: !!address2,
    isConnecting: open,
    address: address2,
    truncatedAddress: address2 ? truncateEthAddress(address2) : void 0,
    ensName: ensName === null || ensName === void 0 ? void 0 : ensName.toString()
  }) });
};
ConnectButtonRenderer.displayName = "ConnectKitButton.Custom";
function ConnectKitButtonInner({ label, showAvatar, separator }) {
  var _a2;
  const locales = useLocales({});
  const context = useContext();
  const { isSignedIn } = useSIWE();
  const { address: address2 } = useAccount();
  const { data: ensName } = useEnsName({
    chainId: 1,
    address: address2
  });
  const { chain: chain2 } = useNetwork();
  const defaultLabel = locales.connectWallet;
  return jsx(AnimatePresence, { initial: false, children: address2 ? jsxs(TextContainer, { initial: "initial", animate: "animate", exit: "exit", variants: addressVariants, style: {
    height: 40
    //padding: !showAvatar ? '0 5px' : undefined,
  }, children: [showAvatar && jsxs(IconContainer, { children: [jsxs(AnimatePresence, { initial: false, children: [isSignedIn && jsx(motion.div, { style: {
    zIndex: 2,
    position: "absolute",
    bottom: 0,
    right: 0
  }, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: jsx(AuthIcon, {}) }), (chain2 === null || chain2 === void 0 ? void 0 : chain2.unsupported) && jsx(UnsupportedNetworkContainer, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: jsx("svg", { width: "14", height: "14", viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M1.68831 13.5H12.0764C13.1026 13.5 13.7647 12.7197 13.7647 11.763C13.7647 11.4781 13.6985 11.1863 13.5462 10.9149L8.34225 1.37526C8.02445 0.791754 7.45505 0.5 6.88566 0.5C6.31627 0.5 5.73364 0.791754 5.42246 1.37526L0.225108 10.9217C0.0728291 11.1863 0 11.4781 0 11.763C0 12.7197 0.662083 13.5 1.68831 13.5ZM6.88566 8.8048C6.49503 8.8048 6.27655 8.5809 6.26331 8.1738L6.16399 5.0595C6.15075 4.64562 6.44869 4.34708 6.87904 4.34708C7.30278 4.34708 7.61396 4.6524 7.60071 5.06628L7.5014 8.16701C7.48154 8.5809 7.26305 8.8048 6.88566 8.8048ZM6.88566 11.3492C6.44207 11.3492 6.07792 11.0303 6.07792 10.5757C6.07792 10.1211 6.44207 9.80219 6.88566 9.80219C7.32926 9.80219 7.69341 10.1143 7.69341 10.5757C7.69341 11.0371 7.32264 11.3492 6.88566 11.3492Z", fill: "currentColor" }) }) })] }), jsx(Avatar, { size: 24, address: address2 })] }), jsx("div", { style: {
    position: "relative",
    paddingRight: showAvatar ? 1 : 0
  }, children: jsx(AnimatePresence, { initial: false, children: ensName ? jsx(TextContainer, { initial: "initial", animate: "animate", exit: "exit", variants: textVariants, style: {
    position: ensName ? "relative" : "absolute"
  }, children: ((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.truncateLongENSAddress) ? truncateENSAddress(ensName, 20) : ensName }, "ckEnsName") : jsxs(TextContainer, { initial: "initial", animate: "animate", exit: "exit", variants: textVariants, style: {
    position: ensName ? "absolute" : "relative"
  }, children: [truncateEthAddress(address2, separator), " "] }, "ckTruncatedAddress") }) })] }, "connectedText") : jsx(TextContainer, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants, style: {
    height: 40
    //padding: '0 5px',
  }, children: label ? label : defaultLabel }, "connectWalletText") });
}
function ConnectKitButton({
  // Options
  label,
  showBalance = false,
  showAvatar = true,
  // Theming
  theme,
  mode: mode2,
  customTheme,
  // Events
  onClick
}) {
  var _a2;
  const isMounted = useIsMounted();
  const context = useContext();
  const { isConnected, address: address2 } = useAccount();
  const { chain: chain2 } = useNetwork();
  function show() {
    context.setOpen(true);
    context.setRoute(isConnected ? routes.PROFILE : routes.CONNECTORS);
  }
  const separator = ["web95", "rounded", "minimal"].includes((_a2 = theme !== null && theme !== void 0 ? theme : context.theme) !== null && _a2 !== void 0 ? _a2 : "") ? "...." : void 0;
  if (!isMounted)
    return null;
  const shouldShowBalance = showBalance && !(chain2 === null || chain2 === void 0 ? void 0 : chain2.unsupported);
  const willShowBalance = address2 && shouldShowBalance;
  return jsx(ResetContainer, { "$useTheme": theme !== null && theme !== void 0 ? theme : context.theme, "$useMode": mode2 !== null && mode2 !== void 0 ? mode2 : context.mode, "$customTheme": customTheme !== null && customTheme !== void 0 ? customTheme : context.customTheme, children: jsxs(ThemeContainer, { onClick: () => {
    if (onClick) {
      onClick(show);
    } else {
      show();
    }
  }, children: [shouldShowBalance && jsx(AnimatePresence, { initial: false, children: willShowBalance && jsx(motion.div, { initial: {
    opacity: 0,
    x: "100%",
    width: 0,
    marginRight: 0
  }, animate: {
    opacity: 1,
    x: 0,
    width: "auto",
    marginRight: -24,
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  }, exit: {
    opacity: 0,
    x: "100%",
    width: 0,
    marginRight: 0,
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  }, children: jsx(ThemedButton, { variant: "secondary", theme: theme !== null && theme !== void 0 ? theme : context.theme, mode: mode2 !== null && mode2 !== void 0 ? mode2 : context.mode, customTheme: customTheme !== null && customTheme !== void 0 ? customTheme : context.customTheme, style: { overflow: "hidden" }, children: jsx(motion.div, { style: { paddingRight: 24 }, children: jsx(Balance, { hideSymbol: true }) }) }) }, "balance") }), jsx(ThemedButton, { theme: theme !== null && theme !== void 0 ? theme : context.theme, mode: mode2 !== null && mode2 !== void 0 ? mode2 : context.mode, customTheme: customTheme !== null && customTheme !== void 0 ? customTheme : context.customTheme, style: shouldShowBalance && showBalance && address2 && (theme === "retro" || context.theme === "retro") ? {
    /** Special fix for the retro theme... not happy about this one */
    boxShadow: "var(--ck-connectbutton-balance-connectbutton-box-shadow)",
    borderRadius: "var(--ck-connectbutton-balance-connectbutton-border-radius)",
    overflow: "hidden"
  } : {
    overflow: "hidden"
  }, children: jsx(ConnectKitButtonInner, { separator, showAvatar, label }) })] }) });
}
ConnectKitButton.Custom = ConnectButtonRenderer;
const dist = 8;
const shake = We`
  0%{ transform:none; }
  25%{ transform:translateX(${dist}px); }
  50%{ transform:translateX(-${dist}px); }
  75%{ transform:translateX(${dist}px); }
  100%{ transform:none; }
`;
const cursorIn = We`
  0%{ transform:translate(500%,100%); opacity:0; }
  60%{ transform:translate(25%,-20%); opacity:1; }
  70%{ transform:translate(25%,-20%); }
  85%{ transform:translate(25%,-20%) scale(0.9); }
  100%{ transform:translate(25%,-20%) scale(1); opacity:1; }
`;
styled.div`
  z-index: 2;
  position: absolute;
  top: 50%;
  left: 50%;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: rgba(0, 0, 0, 0.5);
  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.4), 0 4px 6px rgba(0, 0, 0, 0.1);
  opacity: 0;
  &.play {
    animation: ${cursorIn} 1300ms 200ms cubic-bezier(0.16, 1, 0.6, 1) both;
  }
`;
styled.div`
  z-index: 1;
  position: absolute;
  inset: 0;
  &.shake {
    animation: ${shake} 300ms 100ms cubic-bezier(0.16, 1, 0.6, 1) both;
  }
`;
styled.div`
  z-index: 1;
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  &:before {
    z-index: 9;
    content: '';
    position: absolute;
    inset: 0;
  }
`;
const CONNECTKIT_VERSION = "1.6.0";
function r(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2))
      for (t2 = 0; t2 < e2.length; t2++)
        e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    else
      for (t2 in e2)
        e2[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
    (e2 = arguments[f2++]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const clsx_m = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx,
  default: clsx
}, Symbol.toStringTag, { value: "Module" }));
const u = (t2) => "number" == typeof t2 && !isNaN(t2), d = (t2) => "string" == typeof t2, p = (t2) => "function" == typeof t2, m$1 = (t2) => d(t2) || p(t2) ? t2 : null, f = (t2) => reactExports.isValidElement(t2) || d(t2) || p(t2) || u(t2);
function g(t2, e2, n2) {
  void 0 === n2 && (n2 = 300);
  const { scrollHeight: o, style: s } = t2;
  requestAnimationFrame(() => {
    s.minHeight = "initial", s.height = o + "px", s.transition = `all ${n2}ms`, requestAnimationFrame(() => {
      s.height = "0", s.padding = "0", s.margin = "0", setTimeout(e2, n2);
    });
  });
}
function h(e2) {
  let { enter: a2, exit: r2, appendPosition: i2 = false, collapse: l2 = true, collapseDuration: c2 = 300 } = e2;
  return function(e3) {
    let { children: u2, position: d2, preventExitTransition: p2, done: m2, nodeRef: f2, isIn: h2 } = e3;
    const y2 = i2 ? `${a2}--${d2}` : a2, v2 = i2 ? `${r2}--${d2}` : r2, T2 = reactExports.useRef(0);
    return reactExports.useLayoutEffect(() => {
      const t2 = f2.current, e4 = y2.split(" "), n2 = (o) => {
        o.target === f2.current && (t2.dispatchEvent(new Event("d")), t2.removeEventListener("animationend", n2), t2.removeEventListener("animationcancel", n2), 0 === T2.current && "animationcancel" !== o.type && t2.classList.remove(...e4));
      };
      t2.classList.add(...e4), t2.addEventListener("animationend", n2), t2.addEventListener("animationcancel", n2);
    }, []), reactExports.useEffect(() => {
      const t2 = f2.current, e4 = () => {
        t2.removeEventListener("animationend", e4), l2 ? g(t2, m2, c2) : m2();
      };
      h2 || (p2 ? e4() : (T2.current = 1, t2.className += ` ${v2}`, t2.addEventListener("animationend", e4)));
    }, [h2]), React$1.createElement(React$1.Fragment, null, u2);
  };
}
function y(t2, e2) {
  return null != t2 ? { content: t2.content, containerId: t2.props.containerId, id: t2.props.toastId, theme: t2.props.theme, type: t2.props.type, data: t2.props.data || {}, isLoading: t2.props.isLoading, icon: t2.props.icon, status: e2 } : {};
}
const v = { list: /* @__PURE__ */ new Map(), emitQueue: /* @__PURE__ */ new Map(), on(t2, e2) {
  return this.list.has(t2) || this.list.set(t2, []), this.list.get(t2).push(e2), this;
}, off(t2, e2) {
  if (e2) {
    const n2 = this.list.get(t2).filter((t3) => t3 !== e2);
    return this.list.set(t2, n2), this;
  }
  return this.list.delete(t2), this;
}, cancelEmit(t2) {
  const e2 = this.emitQueue.get(t2);
  return e2 && (e2.forEach(clearTimeout), this.emitQueue.delete(t2)), this;
}, emit(t2) {
  this.list.has(t2) && this.list.get(t2).forEach((e2) => {
    const n2 = setTimeout(() => {
      e2(...[].slice.call(arguments, 1));
    }, 0);
    this.emitQueue.has(t2) || this.emitQueue.set(t2, []), this.emitQueue.get(t2).push(n2);
  });
} }, T = (e2) => {
  let { theme: n2, type: o, ...s } = e2;
  return React$1.createElement("svg", { viewBox: "0 0 24 24", width: "100%", height: "100%", fill: "colored" === n2 ? "currentColor" : `var(--toastify-icon-color-${o})`, ...s });
}, E = { info: function(e2) {
  return React$1.createElement(T, { ...e2 }, React$1.createElement("path", { d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z" }));
}, warning: function(e2) {
  return React$1.createElement(T, { ...e2 }, React$1.createElement("path", { d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z" }));
}, success: function(e2) {
  return React$1.createElement(T, { ...e2 }, React$1.createElement("path", { d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z" }));
}, error: function(e2) {
  return React$1.createElement(T, { ...e2 }, React$1.createElement("path", { d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z" }));
}, spinner: function() {
  return React$1.createElement("div", { className: "Toastify__spinner" });
} };
function C(t2) {
  const [, o] = reactExports.useReducer((t3) => t3 + 1, 0), [l2, c2] = reactExports.useState([]), g2 = reactExports.useRef(null), h2 = reactExports.useRef(/* @__PURE__ */ new Map()).current, T2 = (t3) => -1 !== l2.indexOf(t3), C2 = reactExports.useRef({ toastKey: 1, displayedToast: 0, count: 0, queue: [], props: t2, containerId: null, isToastActive: T2, getToast: (t3) => h2.get(t3) }).current;
  function b2(t3) {
    let { containerId: e2 } = t3;
    const { limit: n2 } = C2.props;
    !n2 || e2 && C2.containerId !== e2 || (C2.count -= C2.queue.length, C2.queue = []);
  }
  function I2(t3) {
    c2((e2) => null == t3 ? [] : e2.filter((e3) => e3 !== t3));
  }
  function _2() {
    const { toastContent: t3, toastProps: e2, staleId: n2 } = C2.queue.shift();
    O2(t3, e2, n2);
  }
  function L2(t3, n2) {
    let { delay: s, staleId: r2, ...i2 } = n2;
    if (!f(t3) || function(t4) {
      return !g2.current || C2.props.enableMultiContainer && t4.containerId !== C2.props.containerId || h2.has(t4.toastId) && null == t4.updateId;
    }(i2))
      return;
    const { toastId: l3, updateId: c3, data: T3 } = i2, { props: b3 } = C2, L3 = () => I2(l3), N10 = null == c3;
    N10 && C2.count++;
    const M2 = { ...b3, style: b3.toastStyle, key: C2.toastKey++, ...Object.fromEntries(Object.entries(i2).filter((t4) => {
      let [e2, n3] = t4;
      return null != n3;
    })), toastId: l3, updateId: c3, data: T3, closeToast: L3, isIn: false, className: m$1(i2.className || b3.toastClassName), bodyClassName: m$1(i2.bodyClassName || b3.bodyClassName), progressClassName: m$1(i2.progressClassName || b3.progressClassName), autoClose: !i2.isLoading && (R2 = i2.autoClose, w2 = b3.autoClose, false === R2 || u(R2) && R2 > 0 ? R2 : w2), deleteToast() {
      const t4 = y(h2.get(l3), "removed");
      h2.delete(l3), v.emit(4, t4);
      const e2 = C2.queue.length;
      if (C2.count = null == l3 ? C2.count - C2.displayedToast : C2.count - 1, C2.count < 0 && (C2.count = 0), e2 > 0) {
        const t5 = null == l3 ? C2.props.limit : 1;
        if (1 === e2 || 1 === t5)
          C2.displayedToast++, _2();
        else {
          const n3 = t5 > e2 ? e2 : t5;
          C2.displayedToast = n3;
          for (let t6 = 0; t6 < n3; t6++)
            _2();
        }
      } else
        o();
    } };
    var R2, w2;
    M2.iconOut = function(t4) {
      let { theme: n3, type: o2, isLoading: s2, icon: r3 } = t4, i3 = null;
      const l4 = { theme: n3, type: o2 };
      return false === r3 || (p(r3) ? i3 = r3(l4) : reactExports.isValidElement(r3) ? i3 = reactExports.cloneElement(r3, l4) : d(r3) || u(r3) ? i3 = r3 : s2 ? i3 = E.spinner() : ((t5) => t5 in E)(o2) && (i3 = E[o2](l4))), i3;
    }(M2), p(i2.onOpen) && (M2.onOpen = i2.onOpen), p(i2.onClose) && (M2.onClose = i2.onClose), M2.closeButton = b3.closeButton, false === i2.closeButton || f(i2.closeButton) ? M2.closeButton = i2.closeButton : true === i2.closeButton && (M2.closeButton = !f(b3.closeButton) || b3.closeButton);
    let x2 = t3;
    reactExports.isValidElement(t3) && !d(t3.type) ? x2 = reactExports.cloneElement(t3, { closeToast: L3, toastProps: M2, data: T3 }) : p(t3) && (x2 = t3({ closeToast: L3, toastProps: M2, data: T3 })), b3.limit && b3.limit > 0 && C2.count > b3.limit && N10 ? C2.queue.push({ toastContent: x2, toastProps: M2, staleId: r2 }) : u(s) ? setTimeout(() => {
      O2(x2, M2, r2);
    }, s) : O2(x2, M2, r2);
  }
  function O2(t3, e2, n2) {
    const { toastId: o2 } = e2;
    n2 && h2.delete(n2);
    const s = { content: t3, props: e2 };
    h2.set(o2, s), c2((t4) => [...t4, o2].filter((t5) => t5 !== n2)), v.emit(4, y(s, null == s.props.updateId ? "added" : "updated"));
  }
  return reactExports.useEffect(() => (C2.containerId = t2.containerId, v.cancelEmit(3).on(0, L2).on(1, (t3) => g2.current && I2(t3)).on(5, b2).emit(2, C2), () => {
    h2.clear(), v.emit(3, C2);
  }), []), reactExports.useEffect(() => {
    C2.props = t2, C2.isToastActive = T2, C2.displayedToast = l2.length;
  }), { getToastToRender: function(e2) {
    const n2 = /* @__PURE__ */ new Map(), o2 = Array.from(h2.values());
    return t2.newestOnTop && o2.reverse(), o2.forEach((t3) => {
      const { position: e3 } = t3.props;
      n2.has(e3) || n2.set(e3, []), n2.get(e3).push(t3);
    }), Array.from(n2, (t3) => e2(t3[0], t3[1]));
  }, containerRef: g2, isToastActive: T2 };
}
function b(t2) {
  return t2.targetTouches && t2.targetTouches.length >= 1 ? t2.targetTouches[0].clientX : t2.clientX;
}
function I(t2) {
  return t2.targetTouches && t2.targetTouches.length >= 1 ? t2.targetTouches[0].clientY : t2.clientY;
}
function _(t2) {
  const [o, a2] = reactExports.useState(false), [r2, l2] = reactExports.useState(false), c2 = reactExports.useRef(null), u2 = reactExports.useRef({ start: 0, x: 0, y: 0, delta: 0, removalDistance: 0, canCloseOnClick: true, canDrag: false, boundingRect: null, didMove: false }).current, d2 = reactExports.useRef(t2), { autoClose: m2, pauseOnHover: f2, closeToast: g2, onClick: h2, closeOnClick: y2 } = t2;
  function v2(e2) {
    if (t2.draggable) {
      "touchstart" === e2.nativeEvent.type && e2.nativeEvent.preventDefault(), u2.didMove = false, document.addEventListener("mousemove", _2), document.addEventListener("mouseup", L2), document.addEventListener("touchmove", _2), document.addEventListener("touchend", L2);
      const n2 = c2.current;
      u2.canCloseOnClick = true, u2.canDrag = true, u2.boundingRect = n2.getBoundingClientRect(), n2.style.transition = "", u2.x = b(e2.nativeEvent), u2.y = I(e2.nativeEvent), "x" === t2.draggableDirection ? (u2.start = u2.x, u2.removalDistance = n2.offsetWidth * (t2.draggablePercent / 100)) : (u2.start = u2.y, u2.removalDistance = n2.offsetHeight * (80 === t2.draggablePercent ? 1.5 * t2.draggablePercent : t2.draggablePercent / 100));
    }
  }
  function T2(e2) {
    if (u2.boundingRect) {
      const { top: n2, bottom: o2, left: s, right: a3 } = u2.boundingRect;
      "touchend" !== e2.nativeEvent.type && t2.pauseOnHover && u2.x >= s && u2.x <= a3 && u2.y >= n2 && u2.y <= o2 ? C2() : E2();
    }
  }
  function E2() {
    a2(true);
  }
  function C2() {
    a2(false);
  }
  function _2(e2) {
    const n2 = c2.current;
    u2.canDrag && n2 && (u2.didMove = true, o && C2(), u2.x = b(e2), u2.y = I(e2), u2.delta = "x" === t2.draggableDirection ? u2.x - u2.start : u2.y - u2.start, u2.start !== u2.x && (u2.canCloseOnClick = false), n2.style.transform = `translate${t2.draggableDirection}(${u2.delta}px)`, n2.style.opacity = "" + (1 - Math.abs(u2.delta / u2.removalDistance)));
  }
  function L2() {
    document.removeEventListener("mousemove", _2), document.removeEventListener("mouseup", L2), document.removeEventListener("touchmove", _2), document.removeEventListener("touchend", L2);
    const e2 = c2.current;
    if (u2.canDrag && u2.didMove && e2) {
      if (u2.canDrag = false, Math.abs(u2.delta) > u2.removalDistance)
        return l2(true), void t2.closeToast();
      e2.style.transition = "transform 0.2s, opacity 0.2s", e2.style.transform = `translate${t2.draggableDirection}(0)`, e2.style.opacity = "1";
    }
  }
  reactExports.useEffect(() => {
    d2.current = t2;
  }), reactExports.useEffect(() => (c2.current && c2.current.addEventListener("d", E2, { once: true }), p(t2.onOpen) && t2.onOpen(reactExports.isValidElement(t2.children) && t2.children.props), () => {
    const t3 = d2.current;
    p(t3.onClose) && t3.onClose(reactExports.isValidElement(t3.children) && t3.children.props);
  }), []), reactExports.useEffect(() => (t2.pauseOnFocusLoss && (document.hasFocus() || C2(), window.addEventListener("focus", E2), window.addEventListener("blur", C2)), () => {
    t2.pauseOnFocusLoss && (window.removeEventListener("focus", E2), window.removeEventListener("blur", C2));
  }), [t2.pauseOnFocusLoss]);
  const O2 = { onMouseDown: v2, onTouchStart: v2, onMouseUp: T2, onTouchEnd: T2 };
  return m2 && f2 && (O2.onMouseEnter = C2, O2.onMouseLeave = E2), y2 && (O2.onClick = (t3) => {
    h2 && h2(t3), u2.canCloseOnClick && g2();
  }), { playToast: E2, pauseToast: C2, isRunning: o, preventExitTransition: r2, toastRef: c2, eventHandlers: O2 };
}
function L(e2) {
  let { closeToast: n2, theme: o, ariaLabel: s = "close" } = e2;
  return React$1.createElement("button", { className: `Toastify__close-button Toastify__close-button--${o}`, type: "button", onClick: (t2) => {
    t2.stopPropagation(), n2(t2);
  }, "aria-label": s }, React$1.createElement("svg", { "aria-hidden": "true", viewBox: "0 0 14 16" }, React$1.createElement("path", { fillRule: "evenodd", d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z" })));
}
function O(e2) {
  let { delay: n2, isRunning: o, closeToast: s, type: a2 = "default", hide: r2, className: i2, style: l2, controlledProgress: u2, progress: d2, rtl: m2, isIn: f2, theme: g2 } = e2;
  const h2 = r2 || u2 && 0 === d2, y2 = { ...l2, animationDuration: `${n2}ms`, animationPlayState: o ? "running" : "paused", opacity: h2 ? 0 : 1 };
  u2 && (y2.transform = `scaleX(${d2})`);
  const v2 = clsx("Toastify__progress-bar", u2 ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${g2}`, `Toastify__progress-bar--${a2}`, { "Toastify__progress-bar--rtl": m2 }), T2 = p(i2) ? i2({ rtl: m2, type: a2, defaultClassName: v2 }) : clsx(v2, i2);
  return React$1.createElement("div", { role: "progressbar", "aria-hidden": h2 ? "true" : "false", "aria-label": "notification timer", className: T2, style: y2, [u2 && d2 >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: u2 && d2 < 1 ? null : () => {
    f2 && s();
  } });
}
const N = (n2) => {
  const { isRunning: o, preventExitTransition: s, toastRef: r2, eventHandlers: i2 } = _(n2), { closeButton: l2, children: u2, autoClose: d2, onClick: m2, type: f2, hideProgressBar: g2, closeToast: h2, transition: y2, position: v2, className: T2, style: E2, bodyClassName: C2, bodyStyle: b2, progressClassName: I2, progressStyle: N10, updateId: M2, role: R2, progress: w2, rtl: x2, toastId: $2, deleteToast: k2, isIn: P2, isLoading: B2, iconOut: D2, closeOnClick: A2, theme: z2 } = n2, F2 = clsx("Toastify__toast", `Toastify__toast-theme--${z2}`, `Toastify__toast--${f2}`, { "Toastify__toast--rtl": x2 }, { "Toastify__toast--close-on-click": A2 }), H2 = p(T2) ? T2({ rtl: x2, position: v2, type: f2, defaultClassName: F2 }) : clsx(F2, T2), S2 = !!w2 || !d2, q2 = { closeToast: h2, type: f2, theme: z2 };
  let Q2 = null;
  return false === l2 || (Q2 = p(l2) ? l2(q2) : reactExports.isValidElement(l2) ? reactExports.cloneElement(l2, q2) : L(q2)), React$1.createElement(y2, { isIn: P2, done: k2, position: v2, preventExitTransition: s, nodeRef: r2 }, React$1.createElement("div", { id: $2, onClick: m2, className: H2, ...i2, style: E2, ref: r2 }, React$1.createElement("div", { ...P2 && { role: R2 }, className: p(C2) ? C2({ type: f2 }) : clsx("Toastify__toast-body", C2), style: b2 }, null != D2 && React$1.createElement("div", { className: clsx("Toastify__toast-icon", { "Toastify--animate-icon Toastify__zoom-enter": !B2 }) }, D2), React$1.createElement("div", null, u2)), Q2, React$1.createElement(O, { ...M2 && !S2 ? { key: `pb-${M2}` } : {}, rtl: x2, theme: z2, delay: d2, isRunning: o, isIn: P2, closeToast: h2, hide: g2, type: f2, style: N10, className: I2, controlledProgress: S2, progress: w2 || 0 })));
}, M = function(t2, e2) {
  return void 0 === e2 && (e2 = false), { enter: `Toastify--animate Toastify__${t2}-enter`, exit: `Toastify--animate Toastify__${t2}-exit`, appendPosition: e2 };
}, R = h(M("bounce", true));
h(M("slide", true));
h(M("zoom"));
h(M("flip"));
const k = reactExports.forwardRef((e2, n2) => {
  const { getToastToRender: o, containerRef: a2, isToastActive: r2 } = C(e2), { className: i2, style: l2, rtl: u2, containerId: d2 } = e2;
  function f2(t2) {
    const e3 = clsx("Toastify__toast-container", `Toastify__toast-container--${t2}`, { "Toastify__toast-container--rtl": u2 });
    return p(i2) ? i2({ position: t2, rtl: u2, defaultClassName: e3 }) : clsx(e3, m$1(i2));
  }
  return reactExports.useEffect(() => {
    n2 && (n2.current = a2.current);
  }, []), React$1.createElement("div", { ref: a2, className: "Toastify", id: d2 }, o((e3, n3) => {
    const o2 = n3.length ? { ...l2 } : { ...l2, pointerEvents: "none" };
    return React$1.createElement("div", { className: f2(e3), style: o2, key: `container-${e3}` }, n3.map((e4, o3) => {
      let { content: s, props: a3 } = e4;
      return React$1.createElement(N, { ...a3, isIn: r2(a3.toastId), style: { ...a3.style, "--nth": o3 + 1, "--len": n3.length }, key: `toast-${a3.key}` }, s);
    }));
  }));
});
k.displayName = "ToastContainer", k.defaultProps = { position: "top-right", transition: R, autoClose: 5e3, closeButton: L, pauseOnHover: true, pauseOnFocusLoss: true, closeOnClick: true, draggable: true, draggablePercent: 80, draggableDirection: "x", role: "alert", theme: "light" };
let P, B = /* @__PURE__ */ new Map(), D = [], A = 1;
function z() {
  return "" + A++;
}
function F(t2) {
  return t2 && (d(t2.toastId) || u(t2.toastId)) ? t2.toastId : z();
}
function H(t2, e2) {
  return B.size > 0 ? v.emit(0, t2, e2) : D.push({ content: t2, options: e2 }), e2.toastId;
}
function S(t2, e2) {
  return { ...e2, type: e2 && e2.type || t2, toastId: F(e2) };
}
function q(t2) {
  return (e2, n2) => H(e2, S(t2, n2));
}
function Q(t2, e2) {
  return H(t2, S("default", e2));
}
Q.loading = (t2, e2) => H(t2, S("default", { isLoading: true, autoClose: false, closeOnClick: false, closeButton: false, draggable: false, ...e2 })), Q.promise = function(t2, e2, n2) {
  let o, { pending: s, error: a2, success: r2 } = e2;
  s && (o = d(s) ? Q.loading(s, n2) : Q.loading(s.render, { ...n2, ...s }));
  const i2 = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null }, l2 = (t3, e3, s2) => {
    if (null == e3)
      return void Q.dismiss(o);
    const a3 = { type: t3, ...i2, ...n2, data: s2 }, r3 = d(e3) ? { render: e3 } : e3;
    return o ? Q.update(o, { ...a3, ...r3 }) : Q(r3.render, { ...a3, ...r3 }), s2;
  }, c2 = p(t2) ? t2() : t2;
  return c2.then((t3) => l2("success", r2, t3)).catch((t3) => l2("error", a2, t3)), c2;
}, Q.success = q("success"), Q.info = q("info"), Q.error = q("error"), Q.warning = q("warning"), Q.warn = Q.warning, Q.dark = (t2, e2) => H(t2, S("default", { theme: "dark", ...e2 })), Q.dismiss = (t2) => {
  B.size > 0 ? v.emit(1, t2) : D = D.filter((e2) => null != t2 && e2.options.toastId !== t2);
}, Q.clearWaitingQueue = function(t2) {
  return void 0 === t2 && (t2 = {}), v.emit(5, t2);
}, Q.isActive = (t2) => {
  let e2 = false;
  return B.forEach((n2) => {
    n2.isToastActive && n2.isToastActive(t2) && (e2 = true);
  }), e2;
}, Q.update = function(t2, e2) {
  void 0 === e2 && (e2 = {}), setTimeout(() => {
    const n2 = function(t3, e3) {
      let { containerId: n3 } = e3;
      const o = B.get(n3 || P);
      return o && o.getToast(t3);
    }(t2, e2);
    if (n2) {
      const { props: o, content: s } = n2, a2 = { delay: 100, ...o, ...e2, toastId: e2.toastId || t2, updateId: z() };
      a2.toastId !== t2 && (a2.staleId = t2);
      const r2 = a2.render || s;
      delete a2.render, H(r2, a2);
    }
  }, 0);
}, Q.done = (t2) => {
  Q.update(t2, { progress: 1 });
}, Q.onChange = (t2) => (v.on(4, t2), () => {
  v.off(4, t2);
}), Q.POSITION = { TOP_LEFT: "top-left", TOP_RIGHT: "top-right", TOP_CENTER: "top-center", BOTTOM_LEFT: "bottom-left", BOTTOM_RIGHT: "bottom-right", BOTTOM_CENTER: "bottom-center" }, Q.TYPE = { INFO: "info", SUCCESS: "success", WARNING: "warning", ERROR: "error", DEFAULT: "default" }, v.on(2, (t2) => {
  P = t2.containerId || t2, B.set(P, t2), D.forEach((t3) => {
    v.emit(0, t3.content, t3.options);
  }), D = [];
}).on(3, (t2) => {
  B.delete(t2.containerId || t2), 0 === B.size && v.off(0).off(1).off(5);
});
function getIterator(iterable) {
  if (typeof iterable.next === "function") {
    return iterable;
  }
  if (typeof iterable[Symbol.iterator] === "function") {
    return iterable[Symbol.iterator]();
  }
  if (typeof iterable[Symbol.asyncIterator] === "function") {
    return iterable[Symbol.asyncIterator]();
  }
  throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols');
}
function defer() {
  let reject;
  let resolve;
  const promise = new Promise((resolveFunc, rejectFunc) => {
    resolve = resolveFunc;
    reject = rejectFunc;
  });
  return {
    promise,
    reject,
    resolve
  };
}
function _transform(concurrency, func, iterable) {
  const iterator = getIterator(iterable);
  const resultQueue = [];
  const readQueue = [];
  let ended = false;
  let reading = false;
  let inflightCount = 0;
  let lastError = null;
  function fulfillReadQueue() {
    while (readQueue.length > 0 && resultQueue.length > 0) {
      const { resolve } = readQueue.shift();
      const value = resultQueue.shift();
      resolve({ done: false, value });
    }
    while (readQueue.length > 0 && inflightCount === 0 && ended) {
      const { resolve, reject } = readQueue.shift();
      if (lastError) {
        reject(lastError);
        lastError = null;
      } else {
        resolve({ done: true, value: void 0 });
      }
    }
  }
  async function fillQueue() {
    if (ended) {
      fulfillReadQueue();
      return;
    }
    if (reading) {
      return;
    }
    if (inflightCount + resultQueue.length >= concurrency) {
      return;
    }
    reading = true;
    inflightCount++;
    try {
      const { done, value } = await iterator.next();
      if (done) {
        ended = true;
        inflightCount--;
        fulfillReadQueue();
      } else {
        mapAndQueue(value);
      }
    } catch (error) {
      ended = true;
      inflightCount--;
      lastError = error;
      fulfillReadQueue();
    }
    reading = false;
    fillQueue();
  }
  async function mapAndQueue(itrValue) {
    try {
      const value = await func(itrValue);
      resultQueue.push(value);
    } catch (error) {
      ended = true;
      lastError = error;
    }
    inflightCount--;
    fulfillReadQueue();
    fillQueue();
  }
  async function next() {
    if (resultQueue.length === 0) {
      const deferred = defer();
      readQueue.push(deferred);
      fillQueue();
      return deferred.promise;
    }
    const value = resultQueue.shift();
    fillQueue();
    return { done: false, value };
  }
  const asyncIterableIterator = {
    next,
    [Symbol.asyncIterator]: () => asyncIterableIterator
  };
  return asyncIterableIterator;
}
function transform(concurrency, func, iterable) {
  if (func === void 0) {
    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);
  }
  if (iterable === void 0) {
    return (curriedIterable) => transform(concurrency, func, curriedIterable);
  }
  return _transform(concurrency, func, iterable);
}
var pRetry$2 = { exports: {} };
var retry$5 = {};
function RetryOperation(timeouts, options) {
  if (typeof options === "boolean") {
    options = { forever: options };
  }
  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
  this._timeouts = timeouts;
  this._options = options || {};
  this._maxRetryTime = options && options.maxRetryTime || Infinity;
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;
  this._operationStart = null;
  this._timer = null;
  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}
var retry_operation = RetryOperation;
RetryOperation.prototype.reset = function() {
  this._attempts = 1;
  this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (this._timer) {
    clearTimeout(this._timer);
  }
  this._timeouts = [];
  this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (!err) {
    return false;
  }
  var currentTime = (/* @__PURE__ */ new Date()).getTime();
  if (err && currentTime - this._operationStart >= this._maxRetryTime) {
    this._errors.push(err);
    this._errors.unshift(new Error("RetryOperation timeout occurred"));
    return false;
  }
  this._errors.push(err);
  var timeout = this._timeouts.shift();
  if (timeout === void 0) {
    if (this._cachedTimeouts) {
      this._errors.splice(0, this._errors.length - 1);
      timeout = this._cachedTimeouts.slice(-1);
    } else {
      return false;
    }
  }
  var self2 = this;
  this._timer = setTimeout(function() {
    self2._attempts++;
    if (self2._operationTimeoutCb) {
      self2._timeout = setTimeout(function() {
        self2._operationTimeoutCb(self2._attempts);
      }, self2._operationTimeout);
      if (self2._options.unref) {
        self2._timeout.unref();
      }
    }
    self2._fn(self2._attempts);
  }, timeout);
  if (this._options.unref) {
    this._timer.unref();
  }
  return true;
};
RetryOperation.prototype.attempt = function(fn, timeoutOps) {
  this._fn = fn;
  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }
    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }
  var self2 = this;
  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function() {
      self2._operationTimeoutCb();
    }, self2._operationTimeout);
  }
  this._operationStart = (/* @__PURE__ */ new Date()).getTime();
  this._fn(this._attempts);
};
RetryOperation.prototype.try = function(fn) {
  console.log("Using RetryOperation.try() is deprecated");
  this.attempt(fn);
};
RetryOperation.prototype.start = function(fn) {
  console.log("Using RetryOperation.start() is deprecated");
  this.attempt(fn);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
  return this._errors;
};
RetryOperation.prototype.attempts = function() {
  return this._attempts;
};
RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0) {
    return null;
  }
  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;
  for (var i2 = 0; i2 < this._errors.length; i2++) {
    var error = this._errors[i2];
    var message = error.message;
    var count = (counts[message] || 0) + 1;
    counts[message] = count;
    if (count >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count;
    }
  }
  return mainError;
};
const retry_operation$1 = /* @__PURE__ */ getDefaultExportFromCjs(retry_operation);
const retry_operation$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: retry_operation$1
}, [retry_operation]);
const require$$0$i = /* @__PURE__ */ getAugmentedNamespace(retry_operation$2);
(function(exports) {
  var RetryOperation2 = require$$0$i;
  exports.operation = function(options) {
    var timeouts = exports.timeouts(options);
    return new RetryOperation2(timeouts, {
      forever: options && (options.forever || options.retries === Infinity),
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
    });
  };
  exports.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options) {
      opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i2 = 0; i2 < opts.retries; i2++) {
      timeouts.push(this.createTimeout(i2, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i2, opts));
    }
    timeouts.sort(function(a2, b2) {
      return a2 - b2;
    });
    return timeouts;
  };
  exports.createTimeout = function(attempt, opts) {
    var random2 = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
  };
  exports.wrap = function(obj, options, methods2) {
    if (options instanceof Array) {
      methods2 = options;
      options = null;
    }
    if (!methods2) {
      methods2 = [];
      for (var key in obj) {
        if (typeof obj[key] === "function") {
          methods2.push(key);
        }
      }
    }
    for (var i2 = 0; i2 < methods2.length; i2++) {
      var method = methods2[i2];
      var original = obj[method];
      obj[method] = function retryWrapper(original2) {
        var op = exports.operation(options);
        var args = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
})(retry$5);
const retry$3 = /* @__PURE__ */ getDefaultExportFromCjs(retry$5);
const retry$4 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: retry$3
}, [retry$5]);
const require$$0$h = /* @__PURE__ */ getAugmentedNamespace(retry$4);
var retry$1 = require$$0$h;
const index$a = /* @__PURE__ */ getDefaultExportFromCjs(retry$1);
const retry$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$a
}, [retry$1]);
const require$$0$g = /* @__PURE__ */ getAugmentedNamespace(retry$2);
const retry = require$$0$g;
const networkErrorMsgs = [
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari
  "Network request failed"
  // `cross-fetch`
];
class AbortError extends Error {
  constructor(message) {
    super();
    if (message instanceof Error) {
      this.originalError = message;
      ({ message } = message);
    } else {
      this.originalError = new Error(message);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message;
  }
}
const decorateErrorWithCounts = (error, attemptNumber, options) => {
  const retriesLeft = options.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
const isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
const pRetry = (input, options) => new Promise((resolve, reject) => {
  options = {
    onFailedAttempt: () => {
    },
    retries: 10,
    ...options
  };
  const operation = retry.operation(options);
  operation.attempt(async (attemptNumber) => {
    try {
      resolve(await input(attemptNumber));
    } catch (error) {
      if (!(error instanceof Error)) {
        reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
        return;
      }
      if (error instanceof AbortError) {
        operation.stop();
        reject(error.originalError);
      } else if (error instanceof TypeError && !isNetworkError(error.message)) {
        operation.stop();
        reject(error);
      } else {
        decorateErrorWithCounts(error, attemptNumber, options);
        try {
          await options.onFailedAttempt(error);
        } catch (error2) {
          reject(error2);
          return;
        }
        if (!operation.retry(error)) {
          reject(operation.mainError());
        }
      }
    }
  });
});
pRetry$2.exports = pRetry;
pRetry$2.exports.default = pRetry;
var AbortError_1 = pRetry$2.exports.AbortError = AbortError;
var pRetryExports = pRetry$2.exports;
const pRetry$1 = /* @__PURE__ */ getDefaultExportFromCjs(pRetryExports);
var encode_1 = encode$7;
var MSB$1 = 128, REST$1 = 127, MSBALL = ~REST$1, INT = Math.pow(2, 31);
function encode$7(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode$7.bytes = 0;
    throw new RangeError("Could not encode varint");
  }
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB$1;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB$1;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$7.bytes = offset - oldOffset + 1;
  return out;
}
const encode$8 = /* @__PURE__ */ getDefaultExportFromCjs(encode_1);
const encode$9 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: encode$8
}, [encode_1]);
const require$$0$f = /* @__PURE__ */ getAugmentedNamespace(encode$9);
var decode$6 = read;
var MSB = 128, REST = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b2, l2 = buf2.length;
  do {
    if (counter2 >= l2 || shift > 49) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter2++];
    res += shift < 28 ? (b2 & REST) << shift : (b2 & REST) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB);
  read.bytes = counter2 - offset;
  return res;
}
const decode$7 = /* @__PURE__ */ getDefaultExportFromCjs(decode$6);
const decode$8 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: decode$7
}, [decode$6]);
const require$$1$6 = /* @__PURE__ */ getAugmentedNamespace(decode$8);
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
const length$1 = /* @__PURE__ */ getDefaultExportFromCjs(length);
const length$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: length$1
}, [length]);
const require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(length$2);
var varint = {
  encode: require$$0$f,
  decode: require$$1$6,
  encodingLength: require$$2$2
};
const varint$1 = /* @__PURE__ */ getDefaultExportFromCjs(varint);
const typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
const objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf2 = typeof value;
  if (typeofs.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer$1(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer$1(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
class Type {
  constructor(major, name2, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name2;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
}
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
let Token$1 = class Token3 {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};
const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
const textDecoder$1 = new TextDecoder();
const textEncoder$2 = new TextEncoder();
function isBuffer(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
const toString = useBuffer ? (bytes2, start, end2) => {
  return end2 - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end2)).toString("utf8") : utf8Slice(bytes2, start, end2);
} : (bytes2, start, end2) => {
  return end2 - start > 64 ? textDecoder$1.decode(bytes2.subarray(start, end2)) : utf8Slice(bytes2, start, end2);
};
const fromString = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder$2.encode(string2) : utf8ToBytes(string2);
};
const fromArray = (arr) => {
  return Uint8Array.from(arr);
};
const slice = useBuffer ? (bytes2, start, end2) => {
  if (isBuffer(bytes2)) {
    return new Uint8Array(bytes2.subarray(start, end2));
  }
  return bytes2.slice(start, end2);
} : (bytes2, start, end2) => {
  return bytes2.slice(start, end2);
};
const concat = useBuffer ? (chunks, length2) => {
  chunks = chunks.map((c2) => c2 instanceof Uint8Array ? c2 : globalThis.Buffer.from(c2));
  return asU8A(globalThis.Buffer.concat(chunks, length2));
} : (chunks, length2) => {
  const out = new Uint8Array(length2);
  let off2 = 0;
  for (let b2 of chunks) {
    if (off2 + b2.length > out.length) {
      b2 = b2.subarray(0, out.length - off2);
    }
    out.set(b2, off2);
    off2 += b2.length;
  }
  return out;
};
const alloc = useBuffer ? (size2) => {
  return globalThis.Buffer.allocUnsafe(size2);
} : (size2) => {
  return new Uint8Array(size2);
};
function compare(b1, b2) {
  if (isBuffer(b1) && isBuffer(b2)) {
    return b1.compare(b2);
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] === b2[i2]) {
      continue;
    }
    return b1[i2] < b2[i2] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length2 = string2.length;
  let leadSurrogate = null;
  const bytes2 = [];
  for (let i2 = 0; i2 < length2; ++i2) {
    codePoint = string2.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length2) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function utf8Slice(buf2, offset, end2) {
  const res = [];
  while (offset < end2) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end2) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len2 = codePoints.length;
  if (len2 <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i2 = 0;
  while (i2 < len2) {
    res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
const defaultChunkSize = 256;
class Bl {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes2) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes2.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes2, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes2, 0);
      } else {
        this.chunks.push(bytes2);
        this.maxCursor += bytes2.length;
      }
    }
    this.cursor += bytes2.length;
  }
  toBytes(reset3 = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset3 && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat(this.chunks, this.cursor);
    }
    if (reset3) {
      this.reset();
    }
    return byts;
  }
}
const decodeErrPrefix = "CBOR decode error:";
const encodeErrPrefix = "CBOR encode error:";
function assertEnoughData(data2, pos, need) {
  if (data2.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
const uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data2, offset, options) {
  assertEnoughData(data2, offset, 1);
  const value = data2[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data2, offset, options) {
  assertEnoughData(data2, offset, 2);
  const value = data2[offset] << 8 | data2[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data2, offset, options) {
  assertEnoughData(data2, offset, 4);
  const value = data2[offset] * 16777216 + (data2[offset + 1] << 16) + (data2[offset + 2] << 8) + data2[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data2, offset, options) {
  assertEnoughData(data2, offset, 8);
  const hi2 = data2[offset] * 16777216 + (data2[offset + 1] << 16) + (data2[offset + 2] << 8) + data2[offset + 3];
  const lo = data2[offset + 4] * 16777216 + (data2[offset + 5] << 16) + (data2[offset + 6] << 8) + data2[offset + 7];
  const value = (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data2, pos, _minor, options) {
  return new Token$1(Type.uint, readUint8(data2, pos + 1, options), 2);
}
function decodeUint16(data2, pos, _minor, options) {
  return new Token$1(Type.uint, readUint16(data2, pos + 1, options), 3);
}
function decodeUint32(data2, pos, _minor, options) {
  return new Token$1(Type.uint, readUint32(data2, pos + 1, options), 5);
}
function decodeUint64(data2, pos, _minor, options) {
  return new Token$1(Type.uint, readUint64(data2, pos + 1, options), 9);
}
function encodeUint(buf2, token2) {
  return encodeUintValue(buf2, 0, token2.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi2 = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi2 & 255;
      hi2 = hi2 >> 8;
      set[3] = hi2 & 255;
      hi2 = hi2 >> 8;
      set[2] = hi2 & 255;
      hi2 = hi2 >> 8;
      set[1] = hi2 & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};
function decodeNegint8(data2, pos, _minor, options) {
  return new Token$1(Type.negint, -1 - readUint8(data2, pos + 1, options), 2);
}
function decodeNegint16(data2, pos, _minor, options) {
  return new Token$1(Type.negint, -1 - readUint16(data2, pos + 1, options), 3);
}
function decodeNegint32(data2, pos, _minor, options) {
  return new Token$1(Type.negint, -1 - readUint32(data2, pos + 1, options), 5);
}
const neg1b = BigInt(-1);
const pos1b = BigInt(1);
function decodeNegint64(data2, pos, _minor, options) {
  const int2 = readUint64(data2, pos + 1, options);
  if (typeof int2 !== "bigint") {
    const value = -1 - int2;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token$1(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token$1(Type.negint, neg1b - BigInt(int2), 9);
}
function encodeNegint(buf2, token2) {
  const negint = token2.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token2.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token2) {
  const negint = token2.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};
function toToken$3(data2, pos, prefix, length2) {
  assertEnoughData(data2, pos, prefix + length2);
  const buf2 = slice(data2, pos + prefix, pos + prefix + length2);
  return new Token$1(Type.bytes, buf2, prefix + length2);
}
function decodeBytesCompact(data2, pos, minor, _options) {
  return toToken$3(data2, pos, 1, minor);
}
function decodeBytes8(data2, pos, _minor, options) {
  return toToken$3(data2, pos, 2, readUint8(data2, pos + 1, options));
}
function decodeBytes16(data2, pos, _minor, options) {
  return toToken$3(data2, pos, 3, readUint16(data2, pos + 1, options));
}
function decodeBytes32(data2, pos, _minor, options) {
  return toToken$3(data2, pos, 5, readUint32(data2, pos + 1, options));
}
function decodeBytes64(data2, pos, _minor, options) {
  const l2 = readUint64(data2, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken$3(data2, pos, 9, l2);
}
function tokenBytes(token2) {
  if (token2.encodedBytes === void 0) {
    token2.encodedBytes = token2.type === Type.string ? fromString(token2.value) : token2.value;
  }
  return token2.encodedBytes;
}
function encodeBytes(buf2, token2) {
  const bytes2 = tokenBytes(token2);
  encodeUintValue(buf2, token2.type.majorEncoded, bytes2.length);
  buf2.push(bytes2);
}
encodeBytes.encodedSize = function encodedSize4(token2) {
  const bytes2 = tokenBytes(token2);
  return encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}
function toToken$2(data2, pos, prefix, length2, options) {
  const totLength = prefix + length2;
  assertEnoughData(data2, pos, totLength);
  const tok = new Token$1(Type.string, toString(data2, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data2, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data2, pos, minor, options) {
  return toToken$2(data2, pos, 1, minor, options);
}
function decodeString8(data2, pos, _minor, options) {
  return toToken$2(data2, pos, 2, readUint8(data2, pos + 1, options), options);
}
function decodeString16(data2, pos, _minor, options) {
  return toToken$2(data2, pos, 3, readUint16(data2, pos + 1, options), options);
}
function decodeString32(data2, pos, _minor, options) {
  return toToken$2(data2, pos, 5, readUint32(data2, pos + 1, options), options);
}
function decodeString64(data2, pos, _minor, options) {
  const l2 = readUint64(data2, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken$2(data2, pos, 9, l2, options);
}
const encodeString = encodeBytes;
function toToken$1(_data, _pos, prefix, length2) {
  return new Token$1(Type.array, length2, prefix);
}
function decodeArrayCompact(data2, pos, minor, _options) {
  return toToken$1(data2, pos, 1, minor);
}
function decodeArray8(data2, pos, _minor, options) {
  return toToken$1(data2, pos, 2, readUint8(data2, pos + 1, options));
}
function decodeArray16(data2, pos, _minor, options) {
  return toToken$1(data2, pos, 3, readUint16(data2, pos + 1, options));
}
function decodeArray32(data2, pos, _minor, options) {
  return toToken$1(data2, pos, 5, readUint32(data2, pos + 1, options));
}
function decodeArray64(data2, pos, _minor, options) {
  const l2 = readUint64(data2, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken$1(data2, pos, 9, l2);
}
function decodeArrayIndefinite(data2, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken$1(data2, pos, 1, Infinity);
}
function encodeArray(buf2, token2) {
  encodeUintValue(buf2, Type.array.majorEncoded, token2.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
function toToken(_data, _pos, prefix, length2) {
  return new Token$1(Type.map, length2, prefix);
}
function decodeMapCompact(data2, pos, minor, _options) {
  return toToken(data2, pos, 1, minor);
}
function decodeMap8(data2, pos, _minor, options) {
  return toToken(data2, pos, 2, readUint8(data2, pos + 1, options));
}
function decodeMap16(data2, pos, _minor, options) {
  return toToken(data2, pos, 3, readUint16(data2, pos + 1, options));
}
function decodeMap32(data2, pos, _minor, options) {
  return toToken(data2, pos, 5, readUint32(data2, pos + 1, options));
}
function decodeMap64(data2, pos, _minor, options) {
  const l2 = readUint64(data2, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken(data2, pos, 9, l2);
}
function decodeMapIndefinite(data2, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken(data2, pos, 1, Infinity);
}
function encodeMap(buf2, token2) {
  encodeUintValue(buf2, Type.map.majorEncoded, token2.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token$1(Type.tag, minor, 1);
}
function decodeTag8(data2, pos, _minor, options) {
  return new Token$1(Type.tag, readUint8(data2, pos + 1, options), 2);
}
function decodeTag16(data2, pos, _minor, options) {
  return new Token$1(Type.tag, readUint16(data2, pos + 1, options), 3);
}
function decodeTag32(data2, pos, _minor, options) {
  return new Token$1(Type.tag, readUint32(data2, pos + 1, options), 5);
}
function decodeTag64(data2, pos, _minor, options) {
  return new Token$1(Type.tag, readUint64(data2, pos + 1, options), 9);
}
function encodeTag(buf2, token2) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token2.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
const MINOR_FALSE = 20;
const MINOR_TRUE = 21;
const MINOR_NULL = 22;
const MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token$1(Type.null, null, 1);
  }
  return new Token$1(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token$1(Type.break, void 0, 1);
}
function createToken(value, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token$1(Type.float, value, bytes2);
}
function decodeFloat16(data2, pos, _minor, options) {
  return createToken(readFloat16(data2, pos + 1), 3, options);
}
function decodeFloat32(data2, pos, _minor, options) {
  return createToken(readFloat32(data2, pos + 1), 5, options);
}
function decodeFloat64(data2, pos, _minor, options) {
  return createToken(readFloat64(data2, pos + 1), 9, options);
}
function encodeFloat(buf2, token2, options) {
  const float2 = token2.value;
  if (float2 === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float2 === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float2 === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float2 === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float2);
      decoded = readFloat16(ui8a, 1);
      if (float2 === decoded || Number.isNaN(float2)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float2);
        decoded = readFloat32(ui8a, 1);
        if (float2 === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float2);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token2, options) {
  const float2 = token2.value;
  if (float2 === false || float2 === true || float2 === null || float2 === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float2);
    let decoded = readFloat16(ui8a, 1);
    if (float2 === decoded || Number.isNaN(float2)) {
      return 3;
    }
    encodeFloat32(float2);
    decoded = readFloat32(ui8a, 1);
    if (float2 === decoded) {
      return 5;
    }
  }
  return 9;
};
const buffer$2 = new ArrayBuffer(9);
const dataView = new DataView(buffer$2, 1);
const ui8a = new Uint8Array(buffer$2, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp3 = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp3 === 0) {
    val = mant * 2 ** -24;
  } else if (exp3 !== 31) {
    val = (mant + 1024) * 2 ** (exp3 - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;
function invalidMinor(data2, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data2[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
const jump = [];
for (let i2 = 0; i2 <= 23; i2++) {
  jump[i2] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i2 = 32; i2 <= 55; i2++) {
  jump[i2] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i2 = 64; i2 <= 87; i2++) {
  jump[i2] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 96; i2 <= 119; i2++) {
  jump[i2] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 128; i2 <= 151; i2++) {
  jump[i2] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i2 = 160; i2 <= 183; i2++) {
  jump[i2] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i2 = 192; i2 <= 215; i2++) {
  jump[i2] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i2 = 224; i2 <= 243; i2++) {
  jump[i2] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
const quick = [];
for (let i2 = 0; i2 < 24; i2++) {
  quick[i2] = new Token$1(Type.uint, i2, 1);
}
for (let i2 = -1; i2 >= -24; i2--) {
  quick[31 - i2] = new Token$1(Type.negint, i2, 1);
}
quick[64] = new Token$1(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token$1(Type.string, "", 1);
quick[128] = new Token$1(Type.array, 0, 1);
quick[160] = new Token$1(Type.map, 0, 1);
quick[244] = new Token$1(Type.false, false, 1);
quick[245] = new Token$1(Type.true, true, 1);
quick[246] = new Token$1(Type.null, null, 1);
function quickEncodeToken(token2) {
  switch (token2.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token2.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token2.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token2.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token2.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token2.value < 24) {
        return fromArray([Number(token2.value)]);
      }
      return;
    case Type.negint:
      if (token2.value >= -24) {
        return fromArray([31 - Number(token2.value)]);
      }
  }
}
const defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
const cborEncoders = makeCborEncoders();
const buf = new Bl();
class Ref {
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p2 = this;
    do {
      if (p2.obj === obj) {
        return true;
      }
    } while (p2 = p2.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
}
const simpleTokens = {
  null: new Token$1(Type.null, null),
  undefined: new Token$1(Type.undefined, void 0),
  true: new Token$1(Type.true, true),
  false: new Token$1(Type.false, false),
  emptyArray: new Token$1(Type.array, 0),
  emptyMap: new Token$1(Type.map, 0)
};
const typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token$1(Type.float, obj);
    } else if (obj >= 0) {
      return new Token$1(Type.uint, obj);
    } else {
      return new Token$1(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token$1(Type.uint, obj);
    } else {
      return new Token$1(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token$1(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token$1(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token$1(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token$1(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token$1(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const e2 of obj) {
      entries[i2++] = objectToTokens(e2, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token$1(Type.array, obj.length),
        entries,
        new Token$1(Type.break)
      ];
    }
    return [
      new Token$1(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys2 = isMap ? obj.keys() : Object.keys(obj);
    const length2 = isMap ? obj.size : keys2.length;
    if (!length2) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token$1(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const key of keys2) {
      entries[i2++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token$1(Type.map, length2),
        entries,
        new Token$1(Type.break)
      ];
    }
    return [
      new Token$1(Type.map, length2),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token2 of tokens) {
      tokensToEncoded(buf2, token2, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data2, encoders, options) {
  const tokens = objectToTokens(data2, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize) {
      const size2 = encoder2.encodedSize(tokens, options);
      const buf2 = new Bl(size2);
      encoder2(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode$6(data2, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data2, cborEncoders, options);
}
const defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
class Tokeniser {
  constructor(data2, options = {}) {
    this.pos = 0;
    this.data = data2;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token2 = quick[byt];
    if (token2 === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token2 = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token2.encodedLength;
    return token2;
  }
}
const DONE = Symbol.for("DONE");
const BREAK = Symbol.for("BREAK");
function tokenToArray(token2, tokeniser, options) {
  const arr = [];
  for (let i2 = 0; i2 < token2.value; i2++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token2.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i2}, expected ${token2.value})`);
    }
    arr[i2] = value;
  }
  return arr;
}
function tokenToMap(token2, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m2 = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i2 = 0; i2 < token2.value; i2++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token2.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no key], expected ${token2.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m2.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no value], expected ${token2.value})`);
    }
    if (useMaps) {
      m2.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m2 : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token2 = tokeniser.next();
  if (token2.type === Type.break) {
    return BREAK;
  }
  if (token2.type.terminal) {
    return token2.value;
  }
  if (token2.type === Type.array) {
    return tokenToArray(token2, tokeniser, options);
  }
  if (token2.type === Type.map) {
    return tokenToMap(token2, tokeniser, options);
  }
  if (token2.type === Type.tag) {
    if (options.tags && typeof options.tags[token2.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token2.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token2.value})`);
  }
  throw new Error("unsupported");
}
function decode$5(data2, options) {
  if (!(data2 instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data2, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
const CID_CBOR_TAG$3 = 42;
function cidEncoder$3(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token$1(Type.tag, CID_CBOR_TAG$3),
    new Token$1(Type.bytes, bytes2)
  ];
}
function undefinedEncoder$3() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder$3(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions$3 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder$3,
    undefined: undefinedEncoder$3,
    number: numberEncoder$3
  }
};
function cidDecoder$3(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
const decodeOptions$3 = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions$3.tags[CID_CBOR_TAG$3] = cidDecoder$3;
const encode$5 = (node2) => encode$6(node2, encodeOptions$3);
const decode$4 = (data2) => decode$5(data2, decodeOptions$3);
const CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
async function readVarint$1(reader2) {
  const bytes2 = await reader2.upTo(8);
  const i2 = varint$1.decode(bytes2);
  reader2.seek(varint$1.decode.bytes);
  return i2;
}
async function readHeader$1(reader2) {
  const length2 = await readVarint$1(reader2);
  if (length2 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader2.exactly(length2);
  reader2.seek(length2);
  const block2 = decode$4(header);
  if (block2 == null || Array.isArray(block2) || typeof block2 !== "object") {
    throw new Error("Invalid CAR header format");
  }
  if (block2.version !== 1) {
    if (typeof block2.version === "string") {
      throw new Error(`Invalid CAR version: "${block2.version}"`);
    }
    throw new Error(`Invalid CAR version: ${block2.version}`);
  }
  if (!Array.isArray(block2.roots)) {
    throw new Error("Invalid CAR header format");
  }
  if (Object.keys(block2).filter((p2) => p2 !== "roots" && p2 !== "version").length) {
    throw new Error("Invalid CAR header format");
  }
  return block2;
}
async function readMultihash(reader2) {
  const bytes2 = await reader2.upTo(8);
  varint$1.decode(bytes2);
  const codeLength = varint$1.decode.bytes;
  const length2 = varint$1.decode(bytes2.subarray(varint$1.decode.bytes));
  const lengthLength = varint$1.decode.bytes;
  const mhLength = codeLength + lengthLength + length2;
  const multihash = await reader2.exactly(mhLength);
  reader2.seek(mhLength);
  return multihash;
}
async function readCid(reader2) {
  const first = await reader2.exactly(2);
  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = await reader2.exactly(34);
    reader2.seek(34);
    const multihash2 = decode$b(bytes3);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version2 = await readVarint$1(reader2);
  if (version2 !== 1) {
    throw new Error(`Unexpected CID version (${version2})`);
  }
  const codec = await readVarint$1(reader2);
  const bytes2 = await readMultihash(reader2);
  const multihash = decode$b(bytes2);
  return CID.create(version2, codec, multihash);
}
async function readBlockHead(reader2) {
  const start = reader2.pos;
  let length2 = await readVarint$1(reader2);
  if (length2 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length2 += reader2.pos - start;
  const cid = await readCid(reader2);
  const blockLength = length2 - (reader2.pos - start);
  return {
    cid,
    length: length2,
    blockLength
  };
}
async function readBlock(reader2) {
  const { cid, blockLength } = await readBlockHead(reader2);
  const bytes2 = await reader2.exactly(blockLength);
  reader2.seek(blockLength);
  return {
    bytes: bytes2,
    cid
  };
}
async function readBlockIndex(reader2) {
  const offset = reader2.pos;
  const { cid, length: length2, blockLength } = await readBlockHead(reader2);
  const index2 = {
    cid,
    length: length2,
    blockLength,
    offset,
    blockOffset: reader2.pos
  };
  reader2.seek(index2.blockLength);
  return index2;
}
function createDecoder(reader2) {
  const headerPromise = readHeader$1(reader2);
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader2.upTo(8)).length > 0) {
        yield await readBlock(reader2);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader2.upTo(8)).length > 0) {
        yield await readBlockIndex(reader2);
      }
    }
  };
}
function bytesReader$1(bytes2) {
  let pos = 0;
  return {
    async upTo(length2) {
      return bytes2.subarray(pos, pos + Math.min(length2, bytes2.length - pos));
    },
    async exactly(length2) {
      if (length2 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes2.subarray(pos, pos + length2);
    },
    seek(length2) {
      pos += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read2 = async (length2) => {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length2) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p2, c2) => p2 + c2.length, 0));
    let off2 = 0;
    for (const b2 of bufa) {
      currentChunk.set(b2, off2);
      off2 += b2.length;
    }
    offset = 0;
  };
  return {
    async upTo(length2) {
      if (currentChunk.length - offset < length2) {
        await read2(length2);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length2));
    },
    async exactly(length2) {
      if (currentChunk.length - offset < length2) {
        await read2(length2);
      }
      if (currentChunk.length - offset < length2) {
        throw new Error("Unexpected end of data");
      }
      return currentChunk.subarray(offset, offset + length2);
    },
    seek(length2) {
      pos += length2;
      offset += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
class CarReader {
  constructor(version2, roots2, blocks) {
    this._version = version2;
    this._roots = roots2;
    this._blocks = blocks;
    this._keys = blocks.map((b2) => b2.cid.toString());
  }
  get version() {
    return this._version;
  }
  async getRoots() {
    return this._roots;
  }
  async has(key) {
    return this._keys.indexOf(key.toString()) > -1;
  }
  async get(key) {
    const index2 = this._keys.indexOf(key.toString());
    return index2 > -1 ? this._blocks[index2] : void 0;
  }
  async *blocks() {
    for (const block2 of this._blocks) {
      yield block2;
    }
  }
  async *cids() {
    for (const block2 of this._blocks) {
      yield block2.cid;
    }
  }
  static async fromBytes(bytes2) {
    if (!(bytes2 instanceof Uint8Array)) {
      throw new TypeError("fromBytes() requires a Uint8Array");
    }
    return decodeReaderComplete(bytesReader$1(bytes2));
  }
  static async fromIterable(asyncIterable) {
    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
      throw new TypeError("fromIterable() requires an async iterable");
    }
    return decodeReaderComplete(asyncIterableReader(asyncIterable));
  }
}
async function decodeReaderComplete(reader2) {
  const decoder = createDecoder(reader2);
  const { version: version2, roots: roots2 } = await decoder.header();
  const blocks = [];
  for await (const block2 of decoder.blocks()) {
    blocks.push(block2);
  }
  return new CarReader(version2, roots2, blocks);
}
function createHeader$1(roots2) {
  const headerBytes = encode$5({
    version: 1,
    roots: roots2
  });
  const varintBytes = varint$1.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder$1(writer2) {
  return {
    async setRoots(roots2) {
      const bytes2 = createHeader$1(roots2);
      await writer2.write(bytes2);
    },
    async writeBlock(block2) {
      const { cid, bytes: bytes2 } = block2;
      await writer2.write(new Uint8Array(varint$1.encode(cid.bytes.length + bytes2.length)));
      await writer2.write(cid.bytes);
      if (bytes2.length) {
        await writer2.write(bytes2);
      }
    },
    async close() {
      return writer2.end();
    }
  };
}
function noop$2() {
}
function create$4() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop$2;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop$2;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop$2;
          resolve();
        };
      });
    }
    return drainer;
  };
  const writer2 = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    }
  };
  const iterator = {
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return {
          done: false,
          value: chunk
        };
      }
      if (ended) {
        drainerResolver();
        return {
          done: true,
          value: void 0
        };
      }
      if (!outWait) {
        outWait = new Promise((resolve) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop$2;
            return resolve(iterator.next());
          };
        });
      }
      return outWait;
    }
  };
  return {
    writer: writer2,
    iterator
  };
}
let CarWriter$1 = class CarWriter2 {
  constructor(roots2, encoder2) {
    this._encoder = encoder2;
    this._mutex = encoder2.setRoots(roots2);
    this._ended = false;
  }
  async put(block2) {
    if (!(block2.bytes instanceof Uint8Array) || !block2.cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    if (this._ended) {
      throw new Error("Already closed");
    }
    const cid = CID.asCID(block2.cid);
    if (!cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    this._mutex = this._mutex.then(() => this._encoder.writeBlock({
      cid,
      bytes: block2.bytes
    }));
    return this._mutex;
  }
  async close() {
    if (this._ended) {
      throw new Error("Already closed");
    }
    await this._mutex;
    this._ended = true;
    return this._encoder.close();
  }
  static create(roots2) {
    roots2 = toRoots$1(roots2);
    const { encoder: encoder2, iterator } = encodeWriter$1();
    const writer2 = new CarWriter2(roots2, encoder2);
    const out = new CarWriterOut$1(iterator);
    return {
      writer: writer2,
      out
    };
  }
  static createAppender() {
    const { encoder: encoder2, iterator } = encodeWriter$1();
    encoder2.setRoots = () => Promise.resolve();
    const writer2 = new CarWriter2([], encoder2);
    const out = new CarWriterOut$1(iterator);
    return {
      writer: writer2,
      out
    };
  }
  static async updateRootsInBytes(bytes2, roots2) {
    const reader2 = bytesReader$1(bytes2);
    await readHeader$1(reader2);
    const newHeader = createHeader$1(roots2);
    if (reader2.pos !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader2.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    bytes2.set(newHeader, 0);
    return bytes2;
  }
};
let CarWriterOut$1 = class CarWriterOut2 {
  constructor(iterator) {
    this._iterator = iterator;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
};
function encodeWriter$1() {
  const iw = create$4();
  const { writer: writer2, iterator } = iw;
  const encoder2 = createEncoder$1(writer2);
  return {
    encoder: encoder2,
    iterator
  };
}
function toRoots$1(roots2) {
  if (roots2 === void 0) {
    return [];
  }
  if (!Array.isArray(roots2)) {
    const cid = CID.asCID(roots2);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root2 of roots2) {
    const _root = CID.asCID(root2);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}
const readonly = ({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
});
const links = function* (source, base3) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index2, element] of value.entries()) {
          const elementPath = [
            ...path,
            index2
          ];
          const cid = CID.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid) {
          yield [
            path.join("/"),
            cid
          ];
        } else {
          yield* links(value, path);
        }
      }
    }
  }
};
const tree = function* (source, base3) {
  if (source == null)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
      if (Array.isArray(value)) {
        for (const [index2, element] of value.entries()) {
          const elementPath = [
            ...path,
            index2
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID.asCID(element)) {
            yield* tree(element, elementPath);
          }
        }
      } else {
        yield* tree(value, path);
      }
    }
  }
};
const get = (source, path) => {
  let node2 = source;
  for (const [index2, key] of path.entries()) {
    node2 = node2[key];
    if (node2 == null) {
      throw new Error(`Object has no property at ${path.slice(0, index2 + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node2);
    if (cid) {
      return {
        value: cid,
        remaining: path.slice(index2 + 1).join("/")
      };
    }
  }
  return { value: node2 };
};
class Block {
  constructor({ cid, bytes: bytes2, value }) {
    if (!cid || !bytes2 || typeof value === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid;
    this.bytes = bytes2;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly(),
      bytes: readonly(),
      value: readonly(),
      asBlock: readonly()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path = "/") {
    return get(this.value, path.split("/").filter(Boolean));
  }
}
const encode$4 = async ({ value, codec, hasher }) => {
  if (typeof value === "undefined")
    throw new Error('Missing required argument "value"');
  if (!codec || !hasher)
    throw new Error("Missing required argument: codec or hasher");
  const bytes2 = codec.encode(value);
  const hash2 = await hasher.digest(bytes2);
  const cid = CID.create(1, codec.code, hash2);
  return new Block({
    value,
    bytes: bytes2,
    cid
  });
};
const CID_CBOR_TAG$2 = 42;
function cidEncoder$2(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token$1(Type.tag, CID_CBOR_TAG$2),
    new Token$1(Type.bytes, bytes2)
  ];
}
function undefinedEncoder$2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder$2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions$2 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder$2,
    undefined: undefinedEncoder$2,
    number: numberEncoder$2
  }
};
function cidDecoder$2(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
const decodeOptions$2 = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions$2.tags[CID_CBOR_TAG$2] = cidDecoder$2;
const name$2 = "dag-cbor";
const code$2 = 113;
const encode$3 = (node2) => encode$6(node2, encodeOptions$2);
const decode$3 = (data2) => decode$5(data2, decodeOptions$2);
const cbor = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code: code$2,
  decode: decode$3,
  encode: encode$3,
  name: name$2
}, Symbol.toStringTag, { value: "Module" }));
const textDecoder = new TextDecoder();
function decodeVarint(bytes2, offset) {
  let v2 = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b2 = bytes2[offset++];
    v2 += shift < 28 ? (b2 & 127) << shift : (b2 & 127) * 2 ** shift;
    if (b2 < 128) {
      break;
    }
  }
  return [
    v2,
    offset
  ];
}
function decodeBytes(bytes2, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes2, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes2.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey(bytes2, index2) {
  let wire;
  [wire, index2] = decodeVarint(bytes2, index2);
  return [
    wire & 7,
    wire >> 3,
    index2
  ];
}
function decodeLink(bytes2) {
  const link = {};
  const l2 = bytes2.length;
  let index2 = 0;
  while (index2 < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index2] = decodeBytes(bytes2, index2);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      link.Name = textDecoder.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index2] = decodeVarint(bytes2, index2);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index2 > l2) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes2) {
  const l2 = bytes2.length;
  let index2 = 0;
  let links2;
  let linksBeforeData = false;
  let data2;
  while (index2 < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data2) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data2, index2] = decodeBytes(bytes2, index2);
      if (links2) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links2) {
        links2 = [];
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      links2.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index2 > l2) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node2 = {};
  if (data2) {
    node2.Data = data2;
  }
  node2.Links = links2 || [];
  return node2;
}
const textEncoder$1 = new TextEncoder();
const maxInt32 = 2 ** 32;
const maxUInt32 = 2 ** 31;
function encodeLink(link, bytes2) {
  let i2 = bytes2.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i2 = encodeVarint(bytes2, i2, link.Tsize) - 1;
    bytes2[i2] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder$1.encode(link.Name);
    i2 -= nameBytes.length;
    bytes2.set(nameBytes, i2);
    i2 = encodeVarint(bytes2, i2, nameBytes.length) - 1;
    bytes2[i2] = 18;
  }
  if (link.Hash) {
    i2 -= link.Hash.length;
    bytes2.set(link.Hash, i2);
    i2 = encodeVarint(bytes2, i2, link.Hash.length) - 1;
    bytes2[i2] = 10;
  }
  return bytes2.length - i2;
}
function encodeNode(node2) {
  const size2 = sizeNode(node2);
  const bytes2 = new Uint8Array(size2);
  let i2 = size2;
  if (node2.Data) {
    i2 -= node2.Data.length;
    bytes2.set(node2.Data, i2);
    i2 = encodeVarint(bytes2, i2, node2.Data.length) - 1;
    bytes2[i2] = 10;
  }
  if (node2.Links) {
    for (let index2 = node2.Links.length - 1; index2 >= 0; index2--) {
      const size3 = encodeLink(node2.Links[index2], bytes2.subarray(0, i2));
      i2 -= size3;
      i2 = encodeVarint(bytes2, i2, size3) - 1;
      bytes2[i2] = 18;
    }
  }
  return bytes2;
}
function sizeLink(link) {
  let n2 = 0;
  if (link.Hash) {
    const l2 = link.Hash.length;
    n2 += 1 + l2 + sov(l2);
  }
  if (typeof link.Name === "string") {
    const l2 = textEncoder$1.encode(link.Name).length;
    n2 += 1 + l2 + sov(l2);
  }
  if (typeof link.Tsize === "number") {
    n2 += 1 + sov(link.Tsize);
  }
  return n2;
}
function sizeNode(node2) {
  let n2 = 0;
  if (node2.Data) {
    const l2 = node2.Data.length;
    n2 += 1 + l2 + sov(l2);
  }
  if (node2.Links) {
    for (const link of node2.Links) {
      const l2 = sizeLink(link);
      n2 += 1 + l2 + sov(l2);
    }
  }
  return n2;
}
function encodeVarint(bytes2, offset, v2) {
  offset -= sov(v2);
  const base3 = offset;
  while (v2 >= maxUInt32) {
    bytes2[offset++] = v2 & 127 | 128;
    v2 /= 128;
  }
  while (v2 >= 128) {
    bytes2[offset++] = v2 & 127 | 128;
    v2 >>>= 7;
  }
  bytes2[offset] = v2;
  return base3;
}
function sov(x2) {
  if (x2 % 2 === 0) {
    x2++;
  }
  return Math.floor((len64(x2) + 6) / 7);
}
function len64(x2) {
  let n2 = 0;
  if (x2 >= maxInt32) {
    x2 = Math.floor(x2 / maxInt32);
    n2 = 32;
  }
  if (x2 >= 1 << 16) {
    x2 >>>= 16;
    n2 += 16;
  }
  if (x2 >= 1 << 8) {
    x2 >>>= 8;
    n2 += 8;
  }
  return n2 + len8tab[x2];
}
const len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];
const pbNodeProperties = [
  "Data",
  "Links"
];
const pbLinkProperties = [
  "Hash",
  "Name",
  "Tsize"
];
const textEncoder = new TextEncoder();
function linkComparator(a2, b2) {
  if (a2 === b2) {
    return 0;
  }
  const abuf = a2.Name ? textEncoder.encode(a2.Name) : [];
  const bbuf = b2.Name ? textEncoder.encode(b2.Name) : [];
  let x2 = abuf.length;
  let y2 = bbuf.length;
  for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
    if (abuf[i2] !== bbuf[i2]) {
      x2 = abuf[i2];
      y2 = bbuf[i2];
      break;
    }
  }
  return x2 < y2 ? -1 : y2 < x2 ? 1 : 0;
}
function hasOnlyProperties(node2, properties) {
  return !Object.keys(node2).some((p2) => !properties.includes(p2));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash3 = CID.asCID(link);
    if (!Hash3) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash: Hash3 };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e2) {
      throw new TypeError(`Invalid DAG-PB form: ${e2.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node2) {
  if (node2 instanceof Uint8Array || typeof node2 === "string") {
    node2 = { Data: node2 };
  }
  if (typeof node2 !== "object" || Array.isArray(node2)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node2.Data !== void 0) {
    if (typeof node2.Data === "string") {
      pbn.Data = textEncoder.encode(node2.Data);
    } else if (node2.Data instanceof Uint8Array) {
      pbn.Data = node2.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node2.Links !== void 0) {
    if (Array.isArray(node2.Links)) {
      pbn.Links = node2.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node2) {
  if (!node2 || typeof node2 !== "object" || Array.isArray(node2)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node2, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node2.Data !== void 0 && !(node2.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node2.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i2 = 0; i2 < node2.Links.length; i2++) {
    const link = node2.Links[i2];
    if (!link || typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i2 > 0 && linkComparator(link, node2.Links[i2 - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data2, links2 = []) {
  return prepare({
    Data: data2,
    Links: links2
  });
}
function createLink(name2, size2, cid) {
  return asLink({
    Hash: cid,
    Name: name2,
    Tsize: size2
  });
}
const name$1 = "dag-pb";
const code$1 = 112;
function encode$2(node2) {
  validate(node2);
  const pbn = {};
  if (node2.Links) {
    pbn.Links = node2.Links.map((l2) => {
      const link = {};
      if (l2.Hash) {
        link.Hash = l2.Hash.bytes;
      }
      if (l2.Name !== void 0) {
        link.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link.Tsize = l2.Tsize;
      }
      return link;
    });
  }
  if (node2.Data) {
    pbn.Data = node2.Data;
  }
  return encodeNode(pbn);
}
function decode$2(bytes2) {
  const pbn = decodeNode(bytes2);
  const node2 = {};
  if (pbn.Data) {
    node2.Data = pbn.Data;
  }
  if (pbn.Links) {
    node2.Links = pbn.Links.map((l2) => {
      const link = {};
      try {
        link.Hash = CID.decode(l2.Hash);
      } catch (e2) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l2.Name !== void 0) {
        link.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link.Tsize = l2.Tsize;
      }
      return link;
    });
  }
  return node2;
}
const dagPb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code: code$1,
  createLink,
  createNode,
  decode: decode$2,
  encode: encode$2,
  name: name$1,
  prepare,
  validate
}, Symbol.toStringTag, { value: "Module" }));
class TreewalkCarSplitter {
  constructor(reader2, targetSize, options = {}) {
    if (typeof targetSize !== "number" || targetSize <= 0) {
      throw new Error("invalid target chunk size");
    }
    this._reader = reader2;
    this._targetSize = targetSize;
    this._decoders = [
      dagPb,
      raw,
      cbor,
      ...options.decoders || []
    ];
  }
  async *cars() {
    const roots2 = await this._reader.getRoots();
    if (roots2.length !== 1)
      throw new Error(`unexpected number of roots: ${roots2.length}`);
    let channel;
    for await (const val of this._cars(roots2[0])) {
      channel = val.channel;
      if (val.out)
        yield val.out;
    }
    if (!channel) {
      throw new Error("missing CAR writer channel");
    }
    channel.writer.close();
    yield channel.out;
  }
  async _get(cid) {
    const rawBlock = await this._reader.get(cid);
    if (!rawBlock)
      throw new Error(`missing block for ${cid}`);
    const { bytes: bytes2 } = rawBlock;
    const decoder = this._decoders.find((d2) => d2.code === cid.code);
    if (!decoder)
      throw new Error(`missing decoder for ${cid.code}`);
    return new Block({
      cid,
      bytes: bytes2,
      value: decoder.decode(bytes2)
    });
  }
  async *_cars(cid, parents = [], channel = void 0) {
    const block2 = await this._get(cid);
    channel = channel || Object.assign(CarWriter$1.create(cid), { size: 0 });
    if (channel.size > 0 && channel.size + block2.bytes.byteLength >= this._targetSize) {
      channel.writer.close();
      const { out } = channel;
      channel = newCar(parents);
      yield {
        channel,
        out
      };
    }
    parents = parents.concat(block2);
    channel.size += block2.bytes.byteLength;
    channel.writer.put(block2);
    for (const [, cid2] of block2.links()) {
      for await (const val of this._cars(cid2, parents, channel)) {
        channel = val.channel;
        yield val;
      }
    }
    if (!channel) {
      throw new Error("missing CAR writer channel");
    }
    yield { channel };
  }
  static async fromIterable(iterable, targetSize, options) {
    const reader2 = await CarReader.fromIterable(iterable);
    return new TreewalkCarSplitter(reader2, targetSize, options);
  }
  static async fromBlob(blob, targetSize, options) {
    const buffer2 = await blob.arrayBuffer();
    const reader2 = await CarReader.fromBytes(new Uint8Array(buffer2));
    return new TreewalkCarSplitter(reader2, targetSize, options);
  }
}
function newCar(parents) {
  const ch2 = Object.assign(CarWriter$1.create(parents[0].cid), { size: parents.reduce((size2, b2) => size2 + b2.bytes.byteLength, 0) });
  for (const b2 of parents) {
    ch2.writer.put(b2);
  }
  return ch2;
}
const last = async (source) => {
  let res;
  for await (const entry of source) {
    res = entry;
  }
  return res;
};
var itLast = last;
const last$1 = /* @__PURE__ */ getDefaultExportFromCjs(itLast);
var itPipe = { exports: {} };
const rawPipe = (...fns) => {
  let res;
  while (fns.length) {
    res = fns.shift()(res);
  }
  return res;
};
const isIterable$1 = (obj) => obj && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
const isDuplex = (obj) => obj && typeof obj.sink === "function" && isIterable$1(obj.source);
const duplexPipelineFn = (duplex) => (source) => {
  duplex.sink(source);
  return duplex.source;
};
const pipe = (...fns) => {
  if (isDuplex(fns[0])) {
    const duplex = fns[0];
    fns[0] = () => duplex.source;
  } else if (isIterable$1(fns[0])) {
    const source = fns[0];
    fns[0] = () => source;
  }
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i2 = 1; i2 < fns.length - 1; i2++) {
      if (isDuplex(fns[i2])) {
        fns[i2] = duplexPipelineFn(fns[i2]);
      }
    }
  }
  return rawPipe(...fns);
};
itPipe.exports = pipe;
itPipe.exports.pipe = pipe;
itPipe.exports.rawPipe = rawPipe;
itPipe.exports.isIterable = isIterable$1;
itPipe.exports.isDuplex = isDuplex;
var itPipeExports = itPipe.exports;
const pipe$1 = /* @__PURE__ */ getDefaultExportFromCjs(itPipeExports);
const CID_CBOR_TAG$1 = 42;
function cidEncoder$1(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token$1(Type.tag, CID_CBOR_TAG$1),
    new Token$1(Type.bytes, bytes2)
  ];
}
function undefinedEncoder$1() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder$1(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions$1 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder$1,
    undefined: undefinedEncoder$1,
    number: numberEncoder$1
  }
};
function cidDecoder$1(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
const decodeOptions$1 = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions$1.tags[CID_CBOR_TAG$1] = cidDecoder$1;
const encode$1 = (node2) => encode$6(node2, encodeOptions$1);
const decode$1 = (data2) => decode$5(data2, decodeOptions$1);
async function readVarint(reader2) {
  const bytes2 = await reader2.upTo(8);
  const i2 = varint$1.decode(bytes2);
  reader2.seek(varint$1.decode.bytes);
  return i2;
}
async function readHeader(reader2) {
  const length2 = await readVarint(reader2);
  if (length2 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader2.exactly(length2);
  reader2.seek(length2);
  const block2 = decode$1(header);
  if (block2 == null || Array.isArray(block2) || typeof block2 !== "object") {
    throw new Error("Invalid CAR header format");
  }
  if (block2.version !== 1) {
    if (typeof block2.version === "string") {
      throw new Error(`Invalid CAR version: "${block2.version}"`);
    }
    throw new Error(`Invalid CAR version: ${block2.version}`);
  }
  if (!Array.isArray(block2.roots)) {
    throw new Error("Invalid CAR header format");
  }
  if (Object.keys(block2).filter((p2) => p2 !== "roots" && p2 !== "version").length) {
    throw new Error("Invalid CAR header format");
  }
  return block2;
}
function bytesReader(bytes2) {
  let pos = 0;
  return {
    async upTo(length2) {
      return bytes2.subarray(pos, pos + Math.min(length2, bytes2.length - pos));
    },
    async exactly(length2) {
      if (length2 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes2.subarray(pos, pos + length2);
    },
    seek(length2) {
      pos += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function createHeader(roots2) {
  const headerBytes = encode$1({
    version: 1,
    roots: roots2
  });
  const varintBytes = varint$1.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer2) {
  return {
    async setRoots(roots2) {
      const bytes2 = createHeader(roots2);
      await writer2.write(bytes2);
    },
    async writeBlock(block2) {
      const { cid, bytes: bytes2 } = block2;
      await writer2.write(new Uint8Array(varint$1.encode(cid.bytes.length + bytes2.length)));
      await writer2.write(cid.bytes);
      if (bytes2.length) {
        await writer2.write(bytes2);
      }
    },
    async close() {
      return writer2.end();
    }
  };
}
function noop$1() {
}
function create$3() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop$1;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop$1;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop$1;
          resolve();
        };
      });
    }
    return drainer;
  };
  const writer2 = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    }
  };
  const iterator = {
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return {
          done: false,
          value: chunk
        };
      }
      if (ended) {
        drainerResolver();
        return {
          done: true,
          value: void 0
        };
      }
      if (!outWait) {
        outWait = new Promise((resolve) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop$1;
            return resolve(iterator.next());
          };
        });
      }
      return outWait;
    }
  };
  return {
    writer: writer2,
    iterator
  };
}
class CarWriter {
  constructor(roots2, encoder2) {
    this._encoder = encoder2;
    this._mutex = encoder2.setRoots(roots2);
    this._ended = false;
  }
  async put(block2) {
    if (!(block2.bytes instanceof Uint8Array) || !block2.cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    if (this._ended) {
      throw new Error("Already closed");
    }
    const cid = CID.asCID(block2.cid);
    if (!cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    this._mutex = this._mutex.then(() => this._encoder.writeBlock({
      cid,
      bytes: block2.bytes
    }));
    return this._mutex;
  }
  async close() {
    if (this._ended) {
      throw new Error("Already closed");
    }
    await this._mutex;
    this._ended = true;
    return this._encoder.close();
  }
  static create(roots2) {
    roots2 = toRoots(roots2);
    const { encoder: encoder2, iterator } = encodeWriter();
    const writer2 = new CarWriter(roots2, encoder2);
    const out = new CarWriterOut(iterator);
    return {
      writer: writer2,
      out
    };
  }
  static createAppender() {
    const { encoder: encoder2, iterator } = encodeWriter();
    encoder2.setRoots = () => Promise.resolve();
    const writer2 = new CarWriter([], encoder2);
    const out = new CarWriterOut(iterator);
    return {
      writer: writer2,
      out
    };
  }
  static async updateRootsInBytes(bytes2, roots2) {
    const reader2 = bytesReader(bytes2);
    await readHeader(reader2);
    const newHeader = createHeader(roots2);
    if (reader2.pos !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader2.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    bytes2.set(newHeader, 0);
    return bytes2;
  }
}
class CarWriterOut {
  constructor(iterator) {
    this._iterator = iterator;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
}
function encodeWriter() {
  const iw = create$3();
  const { writer: writer2, iterator } = iw;
  const encoder2 = createEncoder(writer2);
  return {
    encoder: encoder2,
    iterator
  };
}
function toRoots(roots2) {
  if (roots2 === void 0) {
    return [];
  }
  if (!Array.isArray(roots2)) {
    const cid = CID.asCID(roots2);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root2 of roots2) {
    const _root = CID.asCID(root2);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}
async function* batch$1(source, size2 = 1) {
  let things = [];
  if (size2 < 1) {
    size2 = 1;
  }
  for await (const thing of source) {
    things.push(thing);
    while (things.length >= size2) {
      yield things.slice(0, size2);
      things = things.slice(size2);
    }
  }
  while (things.length) {
    yield things.slice(0, size2);
    things = things.slice(size2);
  }
}
var itBatch = batch$1;
const batch$2 = /* @__PURE__ */ getDefaultExportFromCjs(itBatch);
const itBatch$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: batch$2
}, [itBatch]);
const require$$0$e = /* @__PURE__ */ getAugmentedNamespace(itBatch$1);
const batch = require$$0$e;
async function* parallelBatch(source, size2 = 1) {
  for await (const tasks of batch(source, size2)) {
    const things = tasks.map(
      /**
       * @param {() => Promise<T>} p
       */
      (p2) => {
        return p2().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
      }
    );
    for (let i2 = 0; i2 < things.length; i2++) {
      const result = await things[i2];
      if (result.ok) {
        yield result.value;
      } else {
        throw result.err;
      }
    }
  }
}
var itParallelBatch = parallelBatch;
const parallelBatch$1 = /* @__PURE__ */ getDefaultExportFromCjs(itParallelBatch);
var isPlainObj = (value) => {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype2 = Object.getPrototypeOf(value);
  return prototype2 === null || prototype2 === Object.prototype;
};
const index$9 = /* @__PURE__ */ getDefaultExportFromCjs(isPlainObj);
const isPlainObj$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$9
}, [isPlainObj]);
const require$$0$d = /* @__PURE__ */ getAugmentedNamespace(isPlainObj$1);
const isOptionObject = require$$0$d;
const { hasOwnProperty } = Object.prototype;
const { propertyIsEnumerable } = Object;
const defineProperty = (object, name2, value) => Object.defineProperty(object, name2, {
  value,
  writable: true,
  enumerable: true,
  configurable: true
});
const globalThis$1 = commonjsGlobal;
const defaultMergeOptions = {
  concatArrays: false,
  ignoreUndefined: false
};
const getEnumerableOwnPropertyKeys = (value) => {
  const keys2 = [];
  for (const key in value) {
    if (hasOwnProperty.call(value, key)) {
      keys2.push(key);
    }
  }
  if (Object.getOwnPropertySymbols) {
    const symbols = Object.getOwnPropertySymbols(value);
    for (const symbol2 of symbols) {
      if (propertyIsEnumerable.call(value, symbol2)) {
        keys2.push(symbol2);
      }
    }
  }
  return keys2;
};
function clone(value) {
  if (Array.isArray(value)) {
    return cloneArray(value);
  }
  if (isOptionObject(value)) {
    return cloneOptionObject(value);
  }
  return value;
}
function cloneArray(array) {
  const result = array.slice(0, 0);
  getEnumerableOwnPropertyKeys(array).forEach((key) => {
    defineProperty(result, key, clone(array[key]));
  });
  return result;
}
function cloneOptionObject(object) {
  const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
  getEnumerableOwnPropertyKeys(object).forEach((key) => {
    defineProperty(result, key, clone(object[key]));
  });
  return result;
}
const mergeKeys = (merged, source, keys2, config2) => {
  keys2.forEach((key) => {
    if (typeof source[key] === "undefined" && config2.ignoreUndefined) {
      return;
    }
    if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
      defineProperty(merged, key, merge(merged[key], source[key], config2));
    } else {
      defineProperty(merged, key, clone(source[key]));
    }
  });
  return merged;
};
const concatArrays = (merged, source, config2) => {
  let result = merged.slice(0, 0);
  let resultIndex = 0;
  [merged, source].forEach((array) => {
    const indices = [];
    for (let k2 = 0; k2 < array.length; k2++) {
      if (!hasOwnProperty.call(array, k2)) {
        continue;
      }
      indices.push(String(k2));
      if (array === merged) {
        defineProperty(result, resultIndex++, array[k2]);
      } else {
        defineProperty(result, resultIndex++, clone(array[k2]));
      }
    }
    result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config2);
  });
  return result;
};
function merge(merged, source, config2) {
  if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
    return concatArrays(merged, source, config2);
  }
  if (!isOptionObject(source) || !isOptionObject(merged)) {
    return clone(source);
  }
  return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
}
var mergeOptions = function(...options) {
  const config2 = merge(clone(defaultMergeOptions), this !== globalThis$1 && this || {}, defaultMergeOptions);
  let merged = { _: {} };
  for (const option of options) {
    if (option === void 0) {
      continue;
    }
    if (!isOptionObject(option)) {
      throw new TypeError("`" + option + "` is not an Option Object");
    }
    merged = merge(merged, { _: option }, config2);
  }
  return merged._;
};
const mergeOptions$1 = /* @__PURE__ */ getDefaultExportFromCjs(mergeOptions);
var murmurHash3js$2 = { exports: {} };
(function(module2, exports) {
  (function(root2, undefined$1) {
    var library = {
      "version": "3.0.0",
      "x86": {},
      "x64": {},
      "inputValidation": true
    };
    function _validBytes(bytes2) {
      if (!Array.isArray(bytes2) && !ArrayBuffer.isView(bytes2)) {
        return false;
      }
      for (var i2 = 0; i2 < bytes2.length; i2++) {
        if (!Number.isInteger(bytes2[i2]) || bytes2[i2] < 0 || bytes2[i2] > 255) {
          return false;
        }
      }
      return true;
    }
    function _x86Multiply(m2, n2) {
      return (m2 & 65535) * n2 + (((m2 >>> 16) * n2 & 65535) << 16);
    }
    function _x86Rotl(m2, n2) {
      return m2 << n2 | m2 >>> 32 - n2;
    }
    function _x86Fmix(h2) {
      h2 ^= h2 >>> 16;
      h2 = _x86Multiply(h2, 2246822507);
      h2 ^= h2 >>> 13;
      h2 = _x86Multiply(h2, 3266489909);
      h2 ^= h2 >>> 16;
      return h2;
    }
    function _x64Add(m2, n2) {
      m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
      n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m2[3] + n2[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m2[2] + n2[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m2[1] + n2[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m2[0] + n2[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Multiply(m2, n2) {
      m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
      n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m2[3] * n2[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m2[2] * n2[3];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[2] += m2[3] * n2[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m2[1] * n2[3];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m2[2] * n2[2];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m2[3] * n2[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m2[0] * n2[3] + m2[1] * n2[2] + m2[2] * n2[1] + m2[3] * n2[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Rotl(m2, n2) {
      n2 %= 64;
      if (n2 === 32) {
        return [m2[1], m2[0]];
      } else if (n2 < 32) {
        return [m2[0] << n2 | m2[1] >>> 32 - n2, m2[1] << n2 | m2[0] >>> 32 - n2];
      } else {
        n2 -= 32;
        return [m2[1] << n2 | m2[0] >>> 32 - n2, m2[0] << n2 | m2[1] >>> 32 - n2];
      }
    }
    function _x64LeftShift(m2, n2) {
      n2 %= 64;
      if (n2 === 0) {
        return m2;
      } else if (n2 < 32) {
        return [m2[0] << n2 | m2[1] >>> 32 - n2, m2[1] << n2];
      } else {
        return [m2[1] << n2 - 32, 0];
      }
    }
    function _x64Xor(m2, n2) {
      return [m2[0] ^ n2[0], m2[1] ^ n2[1]];
    }
    function _x64Fmix(h2) {
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      h2 = _x64Multiply(h2, [4283543511, 3981806797]);
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      h2 = _x64Multiply(h2, [3301882366, 444984403]);
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      return h2;
    }
    library.x86.hash32 = function(bytes2, seed) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$1;
      }
      seed = seed || 0;
      var remainder = bytes2.length % 4;
      var blocks = bytes2.length - remainder;
      var h1 = seed;
      var k1 = 0;
      var c1 = 3432918353;
      var c2 = 461845907;
      for (var i2 = 0; i2 < blocks; i2 = i2 + 4) {
        k1 = bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 13);
        h1 = _x86Multiply(h1, 5) + 3864292196;
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= bytes2[i2 + 2] << 16;
        case 2:
          k1 ^= bytes2[i2 + 1] << 8;
        case 1:
          k1 ^= bytes2[i2];
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes2.length;
      h1 = _x86Fmix(h1);
      return h1 >>> 0;
    };
    library.x86.hash128 = function(bytes2, seed) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$1;
      }
      seed = seed || 0;
      var remainder = bytes2.length % 16;
      var blocks = bytes2.length - remainder;
      var h1 = seed;
      var h2 = seed;
      var h3 = seed;
      var h4 = seed;
      var k1 = 0;
      var k2 = 0;
      var k3 = 0;
      var k4 = 0;
      var c1 = 597399067;
      var c2 = 2869860233;
      var c3 = 951274213;
      var c4 = 2716044179;
      for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
        k1 = bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24;
        k2 = bytes2[i2 + 4] | bytes2[i2 + 5] << 8 | bytes2[i2 + 6] << 16 | bytes2[i2 + 7] << 24;
        k3 = bytes2[i2 + 8] | bytes2[i2 + 9] << 8 | bytes2[i2 + 10] << 16 | bytes2[i2 + 11] << 24;
        k4 = bytes2[i2 + 12] | bytes2[i2 + 13] << 8 | bytes2[i2 + 14] << 16 | bytes2[i2 + 15] << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 19);
        h1 += h2;
        h1 = _x86Multiply(h1, 5) + 1444728091;
        k2 = _x86Multiply(k2, c2);
        k2 = _x86Rotl(k2, 16);
        k2 = _x86Multiply(k2, c3);
        h2 ^= k2;
        h2 = _x86Rotl(h2, 17);
        h2 += h3;
        h2 = _x86Multiply(h2, 5) + 197830471;
        k3 = _x86Multiply(k3, c3);
        k3 = _x86Rotl(k3, 17);
        k3 = _x86Multiply(k3, c4);
        h3 ^= k3;
        h3 = _x86Rotl(h3, 15);
        h3 += h4;
        h3 = _x86Multiply(h3, 5) + 2530024501;
        k4 = _x86Multiply(k4, c4);
        k4 = _x86Rotl(k4, 18);
        k4 = _x86Multiply(k4, c1);
        h4 ^= k4;
        h4 = _x86Rotl(h4, 13);
        h4 += h1;
        h4 = _x86Multiply(h4, 5) + 850148119;
      }
      k1 = 0;
      k2 = 0;
      k3 = 0;
      k4 = 0;
      switch (remainder) {
        case 15:
          k4 ^= bytes2[i2 + 14] << 16;
        case 14:
          k4 ^= bytes2[i2 + 13] << 8;
        case 13:
          k4 ^= bytes2[i2 + 12];
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
        case 12:
          k3 ^= bytes2[i2 + 11] << 24;
        case 11:
          k3 ^= bytes2[i2 + 10] << 16;
        case 10:
          k3 ^= bytes2[i2 + 9] << 8;
        case 9:
          k3 ^= bytes2[i2 + 8];
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
        case 8:
          k2 ^= bytes2[i2 + 7] << 24;
        case 7:
          k2 ^= bytes2[i2 + 6] << 16;
        case 6:
          k2 ^= bytes2[i2 + 5] << 8;
        case 5:
          k2 ^= bytes2[i2 + 4];
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
        case 4:
          k1 ^= bytes2[i2 + 3] << 24;
        case 3:
          k1 ^= bytes2[i2 + 2] << 16;
        case 2:
          k1 ^= bytes2[i2 + 1] << 8;
        case 1:
          k1 ^= bytes2[i2];
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes2.length;
      h2 ^= bytes2.length;
      h3 ^= bytes2.length;
      h4 ^= bytes2.length;
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      h1 = _x86Fmix(h1);
      h2 = _x86Fmix(h2);
      h3 = _x86Fmix(h3);
      h4 = _x86Fmix(h4);
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };
    library.x64.hash128 = function(bytes2, seed) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$1;
      }
      seed = seed || 0;
      var remainder = bytes2.length % 16;
      var blocks = bytes2.length - remainder;
      var h1 = [0, seed];
      var h2 = [0, seed];
      var k1 = [0, 0];
      var k2 = [0, 0];
      var c1 = [2277735313, 289559509];
      var c2 = [1291169091, 658871167];
      for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
        k1 = [bytes2[i2 + 4] | bytes2[i2 + 5] << 8 | bytes2[i2 + 6] << 16 | bytes2[i2 + 7] << 24, bytes2[i2] | bytes2[i2 + 1] << 8 | bytes2[i2 + 2] << 16 | bytes2[i2 + 3] << 24];
        k2 = [bytes2[i2 + 12] | bytes2[i2 + 13] << 8 | bytes2[i2 + 14] << 16 | bytes2[i2 + 15] << 24, bytes2[i2 + 8] | bytes2[i2 + 9] << 8 | bytes2[i2 + 10] << 16 | bytes2[i2 + 11] << 24];
        k1 = _x64Multiply(k1, c1);
        k1 = _x64Rotl(k1, 31);
        k1 = _x64Multiply(k1, c2);
        h1 = _x64Xor(h1, k1);
        h1 = _x64Rotl(h1, 27);
        h1 = _x64Add(h1, h2);
        h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
        k2 = _x64Multiply(k2, c2);
        k2 = _x64Rotl(k2, 33);
        k2 = _x64Multiply(k2, c1);
        h2 = _x64Xor(h2, k2);
        h2 = _x64Rotl(h2, 31);
        h2 = _x64Add(h2, h1);
        h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
      }
      k1 = [0, 0];
      k2 = [0, 0];
      switch (remainder) {
        case 15:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 14]], 48));
        case 14:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 13]], 40));
        case 13:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 12]], 32));
        case 12:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 11]], 24));
        case 11:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 10]], 16));
        case 10:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i2 + 9]], 8));
        case 9:
          k2 = _x64Xor(k2, [0, bytes2[i2 + 8]]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
        case 8:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 7]], 56));
        case 7:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 6]], 48));
        case 6:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 5]], 40));
        case 5:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 4]], 32));
        case 4:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 3]], 24));
        case 3:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 2]], 16));
        case 2:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i2 + 1]], 8));
        case 1:
          k1 = _x64Xor(k1, [0, bytes2[i2]]);
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
      }
      h1 = _x64Xor(h1, [0, bytes2.length]);
      h2 = _x64Xor(h2, [0, bytes2.length]);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      h1 = _x64Fmix(h1);
      h2 = _x64Fmix(h2);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };
    {
      if (module2.exports) {
        exports = module2.exports = library;
      }
      exports.murmurHash3 = library;
    }
  })();
})(murmurHash3js$2, murmurHash3js$2.exports);
var murmurHash3jsExports = murmurHash3js$2.exports;
const murmurHash3js = /* @__PURE__ */ getDefaultExportFromCjs(murmurHash3jsExports);
const murmurHash3js$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: murmurHash3js
}, [murmurHash3jsExports]);
const require$$0$c = /* @__PURE__ */ getAugmentedNamespace(murmurHash3js$1);
var murmurhash3jsRevisited = require$$0$c;
const mur = /* @__PURE__ */ getDefaultExportFromCjs(murmurhash3jsRevisited);
const murmur3128 = from({
  name: "murmur3-128",
  code: 34,
  encode: (input) => fromHex$1(mur.x64.hash128(input))
});
async function hamtHashFn(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
}
const defaultOptions = {
  chunker: "fixed",
  strategy: "balanced",
  rawLeaves: false,
  onlyHash: false,
  reduceSingleLeafToSelf: true,
  hasher: sha256$5,
  leafType: "file",
  cidVersion: 0,
  progress: () => () => {
  },
  shardSplitThreshold: 1e3,
  fileImportConcurrency: 50,
  blockWriteConcurrency: 10,
  minChunkSize: 262144,
  maxChunkSize: 262144,
  avgChunkSize: 262144,
  window: 16,
  polynomial: 17437180132763652,
  maxChildrenPerNode: 174,
  layerRepeat: 4,
  wrapWithDirectory: false,
  recursive: false,
  hidden: false,
  timeout: void 0,
  hamtHashFn,
  hamtHashCode: 34,
  hamtBucketBits: 8
};
const defaultOptions$1 = (options = {}) => {
  const defaults2 = mergeOptions$1.bind({ ignoreUndefined: true });
  return defaults2(defaultOptions, options);
};
function assign(obj, props) {
  for (const key in props) {
    Object.defineProperty(obj, key, {
      value: props[key],
      enumerable: true,
      configurable: true
    });
  }
  return obj;
}
function createError(err, code2, props) {
  if (!err || typeof err === "string") {
    throw new TypeError("Please pass an Error to err-code");
  }
  if (!props) {
    props = {};
  }
  if (typeof code2 === "object") {
    props = code2;
    code2 = "";
  }
  if (code2) {
    props.code = code2;
  }
  try {
    return assign(err, props);
  } catch (_2) {
    props.message = err.message;
    props.stack = err.stack;
    const ErrClass = function() {
    };
    ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
    const output2 = assign(new ErrClass(), props);
    return output2;
  }
}
var errCode = createError;
const errCode$1 = /* @__PURE__ */ getDefaultExportFromCjs(errCode);
var indexMinimal$2 = {};
var minimal$1 = {};
var aspromise = asPromise;
function asPromise(fn, ctx) {
  var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
  while (index2 < arguments.length)
    params[offset++] = arguments[index2++];
  return new Promise(function executor(resolve, reject) {
    params[offset] = function callback(err) {
      if (pending) {
        pending = false;
        if (err)
          reject(err);
        else {
          var params2 = new Array(arguments.length - 1), offset2 = 0;
          while (offset2 < params2.length)
            params2[offset2++] = arguments[offset2];
          resolve.apply(null, params2);
        }
      }
    };
    try {
      fn.apply(ctx || null, params);
    } catch (err) {
      if (pending) {
        pending = false;
        reject(err);
      }
    }
  });
}
const index$8 = /* @__PURE__ */ getDefaultExportFromCjs(aspromise);
const aspromise$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$8
}, [aspromise]);
const require$$0$b = /* @__PURE__ */ getAugmentedNamespace(aspromise$1);
var base64$2 = {};
(function(exports) {
  var base642 = exports;
  base642.length = function length2(string2) {
    var p2 = string2.length;
    if (!p2)
      return 0;
    var n2 = 0;
    while (--p2 % 4 > 1 && string2.charAt(p2) === "=")
      ++n2;
    return Math.ceil(string2.length * 3) / 4 - n2;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (var i2 = 0; i2 < 64; )
    s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
  base642.encode = function encode3(buffer2, start, end2) {
    var parts = null, chunk = [];
    var i3 = 0, j2 = 0, t2;
    while (start < end2) {
      var b2 = buffer2[start++];
      switch (j2) {
        case 0:
          chunk[i3++] = b64[b2 >> 2];
          t2 = (b2 & 3) << 4;
          j2 = 1;
          break;
        case 1:
          chunk[i3++] = b64[t2 | b2 >> 4];
          t2 = (b2 & 15) << 2;
          j2 = 2;
          break;
        case 2:
          chunk[i3++] = b64[t2 | b2 >> 6];
          chunk[i3++] = b64[b2 & 63];
          j2 = 0;
          break;
      }
      if (i3 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i3 = 0;
      }
    }
    if (j2) {
      chunk[i3++] = b64[t2];
      chunk[i3++] = 61;
      if (j2 === 1)
        chunk[i3++] = 61;
    }
    if (parts) {
      if (i3)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i3));
  };
  var invalidEncoding = "invalid encoding";
  base642.decode = function decode2(string2, buffer2, offset) {
    var start = offset;
    var j2 = 0, t2;
    for (var i3 = 0; i3 < string2.length; ) {
      var c2 = string2.charCodeAt(i3++);
      if (c2 === 61 && j2 > 1)
        break;
      if ((c2 = s64[c2]) === void 0)
        throw Error(invalidEncoding);
      switch (j2) {
        case 0:
          t2 = c2;
          j2 = 1;
          break;
        case 1:
          buffer2[offset++] = t2 << 2 | (c2 & 48) >> 4;
          t2 = c2;
          j2 = 2;
          break;
        case 2:
          buffer2[offset++] = (t2 & 15) << 4 | (c2 & 60) >> 2;
          t2 = c2;
          j2 = 3;
          break;
        case 3:
          buffer2[offset++] = (t2 & 3) << 6 | c2;
          j2 = 0;
          break;
      }
    }
    if (j2 === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };
  base642.test = function test2(string2) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
  };
})(base64$2);
const index$7 = /* @__PURE__ */ getDefaultExportFromCjs(base64$2);
const base64$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$7
}, [base64$2]);
const require$$1$5 = /* @__PURE__ */ getAugmentedNamespace(base64$1);
var eventemitter = EventEmitter;
function EventEmitter() {
  this._listeners = {};
}
EventEmitter.prototype.on = function on(evt, fn, ctx) {
  (this._listeners[evt] || (this._listeners[evt] = [])).push({
    fn,
    ctx: ctx || this
  });
  return this;
};
EventEmitter.prototype.off = function off(evt, fn) {
  if (evt === void 0)
    this._listeners = {};
  else {
    if (fn === void 0)
      this._listeners[evt] = [];
    else {
      var listeners2 = this._listeners[evt];
      for (var i2 = 0; i2 < listeners2.length; )
        if (listeners2[i2].fn === fn)
          listeners2.splice(i2, 1);
        else
          ++i2;
    }
  }
  return this;
};
EventEmitter.prototype.emit = function emit2(evt) {
  var listeners2 = this._listeners[evt];
  if (listeners2) {
    var args = [], i2 = 1;
    for (; i2 < arguments.length; )
      args.push(arguments[i2++]);
    for (i2 = 0; i2 < listeners2.length; )
      listeners2[i2].fn.apply(listeners2[i2++].ctx, args);
  }
  return this;
};
const index$6 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter);
const eventemitter$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$6
}, [eventemitter]);
const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(eventemitter$1);
var float = factory(factory);
function factory(exports) {
  if (typeof Float32Array !== "undefined")
    (function() {
      var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le2 = f8b[3] === 128;
      function writeFloat_f32_cpy(val, buf2, pos) {
        f32[0] = val;
        buf2[pos] = f8b[0];
        buf2[pos + 1] = f8b[1];
        buf2[pos + 2] = f8b[2];
        buf2[pos + 3] = f8b[3];
      }
      function writeFloat_f32_rev(val, buf2, pos) {
        f32[0] = val;
        buf2[pos] = f8b[3];
        buf2[pos + 1] = f8b[2];
        buf2[pos + 2] = f8b[1];
        buf2[pos + 3] = f8b[0];
      }
      exports.writeFloatLE = le2 ? writeFloat_f32_cpy : writeFloat_f32_rev;
      exports.writeFloatBE = le2 ? writeFloat_f32_rev : writeFloat_f32_cpy;
      function readFloat_f32_cpy(buf2, pos) {
        f8b[0] = buf2[pos];
        f8b[1] = buf2[pos + 1];
        f8b[2] = buf2[pos + 2];
        f8b[3] = buf2[pos + 3];
        return f32[0];
      }
      function readFloat_f32_rev(buf2, pos) {
        f8b[3] = buf2[pos];
        f8b[2] = buf2[pos + 1];
        f8b[1] = buf2[pos + 2];
        f8b[0] = buf2[pos + 3];
        return f32[0];
      }
      exports.readFloatLE = le2 ? readFloat_f32_cpy : readFloat_f32_rev;
      exports.readFloatBE = le2 ? readFloat_f32_rev : readFloat_f32_cpy;
    })();
  else
    (function() {
      function writeFloat_ieee754(writeUint, val, buf2, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0)
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf2, pos);
        else if (isNaN(val))
          writeUint(2143289344, buf2, pos);
        else if (val > 34028234663852886e22)
          writeUint((sign << 31 | 2139095040) >>> 0, buf2, pos);
        else if (val < 11754943508222875e-54)
          writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
        else {
          var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
          writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
        }
      }
      exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
      exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
      function readFloat_ieee754(readUint, buf2, pos) {
        var uint = readUint(buf2, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
        return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
      }
      exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
      exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
  if (typeof Float64Array !== "undefined")
    (function() {
      var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le2 = f8b[7] === 128;
      function writeDouble_f64_cpy(val, buf2, pos) {
        f64[0] = val;
        buf2[pos] = f8b[0];
        buf2[pos + 1] = f8b[1];
        buf2[pos + 2] = f8b[2];
        buf2[pos + 3] = f8b[3];
        buf2[pos + 4] = f8b[4];
        buf2[pos + 5] = f8b[5];
        buf2[pos + 6] = f8b[6];
        buf2[pos + 7] = f8b[7];
      }
      function writeDouble_f64_rev(val, buf2, pos) {
        f64[0] = val;
        buf2[pos] = f8b[7];
        buf2[pos + 1] = f8b[6];
        buf2[pos + 2] = f8b[5];
        buf2[pos + 3] = f8b[4];
        buf2[pos + 4] = f8b[3];
        buf2[pos + 5] = f8b[2];
        buf2[pos + 6] = f8b[1];
        buf2[pos + 7] = f8b[0];
      }
      exports.writeDoubleLE = le2 ? writeDouble_f64_cpy : writeDouble_f64_rev;
      exports.writeDoubleBE = le2 ? writeDouble_f64_rev : writeDouble_f64_cpy;
      function readDouble_f64_cpy(buf2, pos) {
        f8b[0] = buf2[pos];
        f8b[1] = buf2[pos + 1];
        f8b[2] = buf2[pos + 2];
        f8b[3] = buf2[pos + 3];
        f8b[4] = buf2[pos + 4];
        f8b[5] = buf2[pos + 5];
        f8b[6] = buf2[pos + 6];
        f8b[7] = buf2[pos + 7];
        return f64[0];
      }
      function readDouble_f64_rev(buf2, pos) {
        f8b[7] = buf2[pos];
        f8b[6] = buf2[pos + 1];
        f8b[5] = buf2[pos + 2];
        f8b[4] = buf2[pos + 3];
        f8b[3] = buf2[pos + 4];
        f8b[2] = buf2[pos + 5];
        f8b[1] = buf2[pos + 6];
        f8b[0] = buf2[pos + 7];
        return f64[0];
      }
      exports.readDoubleLE = le2 ? readDouble_f64_cpy : readDouble_f64_rev;
      exports.readDoubleBE = le2 ? readDouble_f64_rev : readDouble_f64_cpy;
    })();
  else
    (function() {
      function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0) {
          writeUint(0, buf2, pos + off0);
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf2, pos + off1);
        } else if (isNaN(val)) {
          writeUint(0, buf2, pos + off0);
          writeUint(2146959360, buf2, pos + off1);
        } else if (val > 17976931348623157e292) {
          writeUint(0, buf2, pos + off0);
          writeUint((sign << 31 | 2146435072) >>> 0, buf2, pos + off1);
        } else {
          var mantissa;
          if (val < 22250738585072014e-324) {
            mantissa = val / 5e-324;
            writeUint(mantissa >>> 0, buf2, pos + off0);
            writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
          } else {
            var exponent = Math.floor(Math.log(val) / Math.LN2);
            if (exponent === 1024)
              exponent = 1023;
            mantissa = val * Math.pow(2, -exponent);
            writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
            writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
          }
        }
      }
      exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
      exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
      function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
        var lo = readUint(buf2, pos + off0), hi2 = readUint(buf2, pos + off1);
        var sign = (hi2 >> 31) * 2 + 1, exponent = hi2 >>> 20 & 2047, mantissa = 4294967296 * (hi2 & 1048575) + lo;
        return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
      }
      exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
      exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
  return exports;
}
function writeUintLE(val, buf2, pos) {
  buf2[pos] = val & 255;
  buf2[pos + 1] = val >>> 8 & 255;
  buf2[pos + 2] = val >>> 16 & 255;
  buf2[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf2, pos) {
  buf2[pos] = val >>> 24;
  buf2[pos + 1] = val >>> 16 & 255;
  buf2[pos + 2] = val >>> 8 & 255;
  buf2[pos + 3] = val & 255;
}
function readUintLE(buf2, pos) {
  return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
}
function readUintBE(buf2, pos) {
  return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
}
const index$5 = /* @__PURE__ */ getDefaultExportFromCjs(float);
const float$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$5
}, [float]);
const require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(float$1);
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (e2) {
  }
  return null;
}
const index$4 = /* @__PURE__ */ getDefaultExportFromCjs(inquire_1);
const inquire$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$4
}, [inquire_1]);
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(inquire$1);
var utf8$3 = {};
(function(exports) {
  var utf82 = exports;
  utf82.length = function utf8_length(string2) {
    var len2 = 0, c2 = 0;
    for (var i2 = 0; i2 < string2.length; ++i2) {
      c2 = string2.charCodeAt(i2);
      if (c2 < 128)
        len2 += 1;
      else if (c2 < 2048)
        len2 += 2;
      else if ((c2 & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
        ++i2;
        len2 += 4;
      } else
        len2 += 3;
    }
    return len2;
  };
  utf82.read = function utf8_read(buffer2, start, end2) {
    var len2 = end2 - start;
    if (len2 < 1)
      return "";
    var parts = null, chunk = [], i2 = 0, t2;
    while (start < end2) {
      t2 = buffer2[start++];
      if (t2 < 128)
        chunk[i2++] = t2;
      else if (t2 > 191 && t2 < 224)
        chunk[i2++] = (t2 & 31) << 6 | buffer2[start++] & 63;
      else if (t2 > 239 && t2 < 365) {
        t2 = ((t2 & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
        chunk[i2++] = 55296 + (t2 >> 10);
        chunk[i2++] = 56320 + (t2 & 1023);
      } else
        chunk[i2++] = (t2 & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
      if (i2 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (parts) {
      if (i2)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  utf82.write = function utf8_write(string2, buffer2, offset) {
    var start = offset, c1, c2;
    for (var i2 = 0; i2 < string2.length; ++i2) {
      c1 = string2.charCodeAt(i2);
      if (c1 < 128) {
        buffer2[offset++] = c1;
      } else if (c1 < 2048) {
        buffer2[offset++] = c1 >> 6 | 192;
        buffer2[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i2;
        buffer2[offset++] = c1 >> 18 | 240;
        buffer2[offset++] = c1 >> 12 & 63 | 128;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      } else {
        buffer2[offset++] = c1 >> 12 | 224;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  };
})(utf8$3);
const index$3 = /* @__PURE__ */ getDefaultExportFromCjs(utf8$3);
const utf8$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$3
}, [utf8$3]);
const require$$5$1 = /* @__PURE__ */ getAugmentedNamespace(utf8$2);
var pool_1 = pool;
function pool(alloc3, slice3, size2) {
  var SIZE = size2 || 8192;
  var MAX = SIZE >>> 1;
  var slab = null;
  var offset = SIZE;
  return function pool_alloc(size3) {
    if (size3 < 1 || size3 > MAX)
      return alloc3(size3);
    if (offset + size3 > SIZE) {
      slab = alloc3(SIZE);
      offset = 0;
    }
    var buf2 = slice3.call(slab, offset, offset += size3);
    if (offset & 7)
      offset = (offset | 7) + 1;
    return buf2;
  };
}
const index$2 = /* @__PURE__ */ getDefaultExportFromCjs(pool_1);
const pool$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$2
}, [pool_1]);
const require$$6$1 = /* @__PURE__ */ getAugmentedNamespace(pool$1);
var longbits;
var hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1;
  longbits = LongBits2;
  var util2 = requireMinimal();
  function LongBits2(lo, hi2) {
    this.lo = lo >>> 0;
    this.hi = hi2 >>> 0;
  }
  var zero2 = LongBits2.zero = new LongBits2(0, 0);
  zero2.toNumber = function() {
    return 0;
  };
  zero2.zzEncode = zero2.zzDecode = function() {
    return this;
  };
  zero2.length = function() {
    return 1;
  };
  var zeroHash2 = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits2.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero2;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0, hi2 = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi2 = ~hi2 >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi2 > 4294967295)
          hi2 = 0;
      }
    }
    return new LongBits2(lo, hi2);
  };
  LongBits2.from = function from2(value) {
    if (typeof value === "number")
      return LongBits2.fromNumber(value);
    if (util2.isString(value)) {
      if (util2.Long)
        value = util2.Long.fromString(value);
      else
        return LongBits2.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero2;
  };
  LongBits2.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi2 = ~this.hi >>> 0;
      if (!lo)
        hi2 = hi2 + 1 >>> 0;
      return -(lo + hi2 * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits2.prototype.toLong = function toLong(unsigned) {
    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits2.fromHash = function fromHash(hash2) {
    if (hash2 === zeroHash2)
      return zero2;
    return new LongBits2(
      (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
      (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
    );
  };
  LongBits2.prototype.toHash = function toHash() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  };
  LongBits2.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.length = function length2() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
  return longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  if (hasRequiredMinimal)
    return minimal$1;
  hasRequiredMinimal = 1;
  (function(exports) {
    var util2 = exports;
    util2.asPromise = require$$0$b;
    util2.base64 = require$$1$5;
    util2.EventEmitter = require$$2$1;
    util2.float = require$$3$1;
    util2.inquire = require$$4;
    util2.utf8 = require$$5$1;
    util2.pool = require$$6$1;
    util2.LongBits = requireLongbits();
    util2.isNode = Boolean(typeof commonjsGlobal !== "undefined" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);
    util2.global = util2.isNode && commonjsGlobal || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util2.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util2.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util2.LongBits.fromHash(hash2);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge2(dst, src2, ifNotSet) {
      for (var keys2 = Object.keys(src2), i2 = 0; i2 < keys2.length; ++i2)
        if (dst[keys2[i2]] === void 0 || !ifNotSet)
          dst[keys2[i2]] = src2[keys2[i2]];
      return dst;
    }
    util2.merge = merge2;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name2;
      } });
      CustomError.prototype.toString = function toString3() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys2 = Object.keys(this), i3 = keys2.length - 1; i3 > -1; --i3)
          if (fieldMap[keys2[i3]] === 1 && this[keys2[i3]] !== void 0 && this[keys2[i3]] !== null)
            return keys2[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name2)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding2) {
        return new Buffer2(value, encoding2);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size2) {
        return new Buffer2(size2);
      };
    };
  })(minimal$1);
  return minimal$1;
}
var writer = Writer$1;
var util$4 = requireMinimal();
var BufferWriter$1;
var LongBits$1 = util$4.LongBits, base64 = util$4.base64, utf8$1 = util$4.utf8;
function Op(fn, len2, val) {
  this.fn = fn;
  this.len = len2;
  this.next = void 0;
  this.val = val;
}
function noop() {
}
function State(writer2) {
  this.head = writer2.head;
  this.tail = writer2.tail;
  this.len = writer2.len;
  this.next = writer2.states;
}
function Writer$1() {
  this.len = 0;
  this.head = new Op(noop, 0, 0);
  this.tail = this.head;
  this.states = null;
}
var create$2 = function create3() {
  return util$4.Buffer ? function create_buffer_setup() {
    return (Writer$1.create = function create_buffer() {
      return new BufferWriter$1();
    })();
  } : function create_array3() {
    return new Writer$1();
  };
};
Writer$1.create = create$2();
Writer$1.alloc = function alloc2(size2) {
  return new util$4.Array(size2);
};
if (util$4.Array !== Array)
  Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray);
Writer$1.prototype._push = function push(fn, len2, val) {
  this.tail = this.tail.next = new Op(fn, len2, val);
  this.len += len2;
  return this;
};
function writeByte(val, buf2, pos) {
  buf2[pos] = val & 255;
}
function writeVarint32(val, buf2, pos) {
  while (val > 127) {
    buf2[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf2[pos] = val;
}
function VarintOp(len2, val) {
  this.len = len2;
  this.next = void 0;
  this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function write_uint32(value) {
  this.len += (this.tail = this.tail.next = new VarintOp(
    (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
    value
  )).len;
  return this;
};
Writer$1.prototype.int32 = function write_int32(value) {
  return value < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) : this.uint32(value);
};
Writer$1.prototype.sint32 = function write_sint32(value) {
  return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf2, pos) {
  while (val.hi) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf2[pos++] = val.lo;
}
Writer$1.prototype.uint64 = function write_uint64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function write_sint64(value) {
  var bits = LongBits$1.from(value).zzEncode();
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.bool = function write_bool(value) {
  return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf2, pos) {
  buf2[pos] = val & 255;
  buf2[pos + 1] = val >>> 8 & 255;
  buf2[pos + 2] = val >>> 16 & 255;
  buf2[pos + 3] = val >>> 24;
}
Writer$1.prototype.fixed32 = function write_fixed32(value) {
  return this._push(writeFixed32, 4, value >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function write_fixed64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function write_float(value) {
  return this._push(util$4.float.writeFloatLE, 4, value);
};
Writer$1.prototype.double = function write_double(value) {
  return this._push(util$4.float.writeDoubleLE, 8, value);
};
var writeBytes = util$4.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
  buf2.set(val, pos);
} : function writeBytes_for(val, buf2, pos) {
  for (var i2 = 0; i2 < val.length; ++i2)
    buf2[pos + i2] = val[i2];
};
Writer$1.prototype.bytes = function write_bytes(value) {
  var len2 = value.length >>> 0;
  if (!len2)
    return this._push(writeByte, 1, 0);
  if (util$4.isString(value)) {
    var buf2 = Writer$1.alloc(len2 = base64.length(value));
    base64.decode(value, buf2, 0);
    value = buf2;
  }
  return this.uint32(len2)._push(writeBytes, len2, value);
};
Writer$1.prototype.string = function write_string(value) {
  var len2 = utf8$1.length(value);
  return len2 ? this.uint32(len2)._push(utf8$1.write, len2, value) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function fork() {
  this.states = new State(this);
  this.head = this.tail = new Op(noop, 0, 0);
  this.len = 0;
  return this;
};
Writer$1.prototype.reset = function reset2() {
  if (this.states) {
    this.head = this.states.head;
    this.tail = this.states.tail;
    this.len = this.states.len;
    this.states = this.states.next;
  } else {
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
  }
  return this;
};
Writer$1.prototype.ldelim = function ldelim() {
  var head = this.head, tail = this.tail, len2 = this.len;
  this.reset().uint32(len2);
  if (len2) {
    this.tail.next = head.next;
    this.tail = tail;
    this.len += len2;
  }
  return this;
};
Writer$1.prototype.finish = function finish() {
  var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
  while (head) {
    head.fn(head.val, buf2, pos);
    pos += head.len;
    head = head.next;
  }
  return buf2;
};
Writer$1._configure = function(BufferWriter_) {
  BufferWriter$1 = BufferWriter_;
  Writer$1.create = create$2();
  BufferWriter$1._configure();
};
const writer$1 = /* @__PURE__ */ getDefaultExportFromCjs(writer);
const writer$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: writer$1
}, [writer]);
const require$$0$a = /* @__PURE__ */ getAugmentedNamespace(writer$2);
var writer_buffer = BufferWriter;
var Writer = require$$0$a;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$3 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$3._Buffer_allocUnsafe;
  BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
    buf2.set(val, pos);
  } : function writeBytesBuffer_copy(val, buf2, pos) {
    if (val.copy)
      val.copy(buf2, pos, 0, val.length);
    else
      for (var i2 = 0; i2 < val.length; )
        buf2[pos++] = val[i2++];
  };
};
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
  if (util$3.isString(value))
    value = util$3._Buffer_from(value, "base64");
  var len2 = value.length >>> 0;
  this.uint32(len2);
  if (len2)
    this._push(BufferWriter.writeBytesBuffer, len2, value);
  return this;
};
function writeStringBuffer(val, buf2, pos) {
  if (val.length < 40)
    util$3.utf8.write(val, buf2, pos);
  else if (buf2.utf8Write)
    buf2.utf8Write(val, pos);
  else
    buf2.write(val, pos);
}
BufferWriter.prototype.string = function write_string_buffer(value) {
  var len2 = util$3.Buffer.byteLength(value);
  this.uint32(len2);
  if (len2)
    this._push(writeStringBuffer, len2, value);
  return this;
};
BufferWriter._configure();
const writer_buffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(writer_buffer);
const writer_buffer$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: writer_buffer$1
}, [writer_buffer]);
const require$$1$4 = /* @__PURE__ */ getAugmentedNamespace(writer_buffer$2);
var reader = Reader$1;
var util$2 = requireMinimal();
var BufferReader$1;
var LongBits = util$2.LongBits, utf8 = util$2.utf8;
function indexOutOfRange(reader2, writeLength) {
  return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
}
function Reader$1(buffer2) {
  this.buf = buffer2;
  this.pos = 0;
  this.len = buffer2.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
  if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
} : function create_array2(buffer2) {
  if (Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
};
var create$1 = function create4() {
  return util$2.Buffer ? function create_buffer_setup(buffer2) {
    return (Reader$1.create = function create_buffer(buffer3) {
      return util$2.Buffer.isBuffer(buffer3) ? new BufferReader$1(buffer3) : create_array(buffer3);
    })(buffer2);
  } : create_array;
};
Reader$1.create = create$1();
Reader$1.prototype._slice = util$2.Array.prototype.subarray || /* istanbul ignore next */
util$2.Array.prototype.slice;
Reader$1.prototype.uint32 = function read_uint32_setup() {
  var value = 4294967295;
  return function read_uint32() {
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value;
  };
}();
Reader$1.prototype.int32 = function read_int32() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function read_sint32() {
  var value = this.uint32();
  return value >>> 1 ^ -(value & 1) | 0;
};
function readLongVarint() {
  var bits = new LongBits(0, 0);
  var i2 = 0;
  if (this.len - this.pos > 4) {
    for (; i2 < 4; ++i2) {
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
    if (this.buf[this.pos++] < 128)
      return bits;
    i2 = 0;
  } else {
    for (; i2 < 3; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
    return bits;
  }
  if (this.len - this.pos > 4) {
    for (; i2 < 5; ++i2) {
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  } else {
    for (; i2 < 5; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function read_bool() {
  return this.uint32() !== 0;
};
function readFixed32_end(buf2, end2) {
  return (buf2[end2 - 4] | buf2[end2 - 3] << 8 | buf2[end2 - 2] << 16 | buf2[end2 - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function read_fixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function read_sfixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function read_float() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readFloatLE(this.buf, this.pos);
  this.pos += 4;
  return value;
};
Reader$1.prototype.double = function read_double() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readDoubleLE(this.buf, this.pos);
  this.pos += 8;
  return value;
};
Reader$1.prototype.bytes = function read_bytes() {
  var length2 = this.uint32(), start = this.pos, end2 = this.pos + length2;
  if (end2 > this.len)
    throw indexOutOfRange(this, length2);
  this.pos += length2;
  if (Array.isArray(this.buf))
    return this.buf.slice(start, end2);
  return start === end2 ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end2);
};
Reader$1.prototype.string = function read_string() {
  var bytes2 = this.bytes();
  return utf8.read(bytes2, 0, bytes2.length);
};
Reader$1.prototype.skip = function skip(length2) {
  if (typeof length2 === "number") {
    if (this.pos + length2 > this.len)
      throw indexOutOfRange(this, length2);
    this.pos += length2;
  } else {
    do {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    } while (this.buf[this.pos++] & 128);
  }
  return this;
};
Reader$1.prototype.skipType = function(wireType) {
  switch (wireType) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      while ((wireType = this.uint32() & 7) !== 4) {
        this.skipType(wireType);
      }
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + wireType + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(BufferReader_) {
  BufferReader$1 = BufferReader_;
  Reader$1.create = create$1();
  BufferReader$1._configure();
  var fn = util$2.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$2.merge(Reader$1.prototype, {
    int64: function read_int64() {
      return readLongVarint.call(this)[fn](false);
    },
    uint64: function read_uint64() {
      return readLongVarint.call(this)[fn](true);
    },
    sint64: function read_sint64() {
      return readLongVarint.call(this).zzDecode()[fn](false);
    },
    fixed64: function read_fixed64() {
      return readFixed64.call(this)[fn](true);
    },
    sfixed64: function read_sfixed64() {
      return readFixed64.call(this)[fn](false);
    }
  });
};
const reader$1 = /* @__PURE__ */ getDefaultExportFromCjs(reader);
const reader$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: reader$1
}, [reader]);
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(reader$2);
var reader_buffer = BufferReader;
var Reader = require$$2;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$1 = requireMinimal();
function BufferReader(buffer2) {
  Reader.call(this, buffer2);
}
BufferReader._configure = function() {
  if (util$1.Buffer)
    BufferReader.prototype._slice = util$1.Buffer.prototype.slice;
};
BufferReader.prototype.string = function read_string_buffer() {
  var len2 = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len2, this.len));
};
BufferReader._configure();
const reader_buffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(reader_buffer);
const reader_buffer$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: reader_buffer$1
}, [reader_buffer]);
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(reader_buffer$2);
var rpc$2 = {};
var service = Service;
var util = requireMinimal();
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
function Service(rpcImpl, requestDelimited, responseDelimited) {
  if (typeof rpcImpl !== "function")
    throw TypeError("rpcImpl must be a function");
  util.EventEmitter.call(this);
  this.rpcImpl = rpcImpl;
  this.requestDelimited = Boolean(requestDelimited);
  this.responseDelimited = Boolean(responseDelimited);
}
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
  if (!request2)
    throw TypeError("request must be specified");
  var self2 = this;
  if (!callback)
    return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
  if (!self2.rpcImpl) {
    setTimeout(function() {
      callback(Error("already ended"));
    }, 0);
    return void 0;
  }
  try {
    return self2.rpcImpl(
      method,
      requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
      function rpcCallback(err, response) {
        if (err) {
          self2.emit("error", err, method);
          return callback(err);
        }
        if (response === null) {
          self2.end(
            /* endedByRPC */
            true
          );
          return void 0;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      }
    );
  } catch (err) {
    self2.emit("error", err, method);
    setTimeout(function() {
      callback(err);
    }, 0);
    return void 0;
  }
};
Service.prototype.end = function end(endedByRPC) {
  if (this.rpcImpl) {
    if (!endedByRPC)
      this.rpcImpl(null, null, null);
    this.rpcImpl = null;
    this.emit("end").off();
  }
  return this;
};
const service$1 = /* @__PURE__ */ getDefaultExportFromCjs(service);
const service$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: service$1
}, [service]);
const require$$0$9 = /* @__PURE__ */ getAugmentedNamespace(service$2);
(function(exports) {
  var rpc2 = exports;
  rpc2.Service = require$$0$9;
})(rpc$2);
const rpc = /* @__PURE__ */ getDefaultExportFromCjs(rpc$2);
const rpc$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: rpc
}, [rpc$2]);
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(rpc$1);
var roots = {};
const roots$1 = /* @__PURE__ */ getDefaultExportFromCjs(roots);
const roots$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: roots$1
}, [roots]);
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(roots$2);
(function(exports) {
  var protobuf = exports;
  protobuf.build = "minimal";
  protobuf.Writer = require$$0$a;
  protobuf.BufferWriter = require$$1$4;
  protobuf.Reader = require$$2;
  protobuf.BufferReader = require$$3;
  protobuf.util = requireMinimal();
  protobuf.rpc = require$$5;
  protobuf.roots = require$$6;
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
})(indexMinimal$2);
const indexMinimal = /* @__PURE__ */ getDefaultExportFromCjs(indexMinimal$2);
const indexMinimal$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: indexMinimal
}, [indexMinimal$2]);
const require$$0$8 = /* @__PURE__ */ getAugmentedNamespace(indexMinimal$1);
var minimal = require$$0$8;
const $protobuf = /* @__PURE__ */ getDefaultExportFromCjs(minimal);
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
const $root = $protobuf.roots["ipfs-unixfs"] || ($protobuf.roots["ipfs-unixfs"] = {});
const Data = $root.Data = (() => {
  function Data2(p2) {
    this.blocksizes = [];
    if (p2) {
      for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
        if (p2[ks[i2]] != null)
          this[ks[i2]] = p2[ks[i2]];
    }
  }
  Data2.prototype.Type = 0;
  Data2.prototype.Data = $util.newBuffer([]);
  Data2.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.blocksizes = $util.emptyArray;
  Data2.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.mode = 0;
  Data2.prototype.mtime = null;
  Data2.encode = function encode3(m2, w2) {
    if (!w2)
      w2 = $Writer.create();
    w2.uint32(8).int32(m2.Type);
    if (m2.Data != null && Object.hasOwnProperty.call(m2, "Data"))
      w2.uint32(18).bytes(m2.Data);
    if (m2.filesize != null && Object.hasOwnProperty.call(m2, "filesize"))
      w2.uint32(24).uint64(m2.filesize);
    if (m2.blocksizes != null && m2.blocksizes.length) {
      for (var i2 = 0; i2 < m2.blocksizes.length; ++i2)
        w2.uint32(32).uint64(m2.blocksizes[i2]);
    }
    if (m2.hashType != null && Object.hasOwnProperty.call(m2, "hashType"))
      w2.uint32(40).uint64(m2.hashType);
    if (m2.fanout != null && Object.hasOwnProperty.call(m2, "fanout"))
      w2.uint32(48).uint64(m2.fanout);
    if (m2.mode != null && Object.hasOwnProperty.call(m2, "mode"))
      w2.uint32(56).uint32(m2.mode);
    if (m2.mtime != null && Object.hasOwnProperty.call(m2, "mtime"))
      $root.UnixTime.encode(m2.mtime, w2.uint32(66).fork()).ldelim();
    return w2;
  };
  Data2.decode = function decode2(r2, l2) {
    if (!(r2 instanceof $Reader))
      r2 = $Reader.create(r2);
    var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.Data();
    while (r2.pos < c2) {
      var t2 = r2.uint32();
      switch (t2 >>> 3) {
        case 1:
          m2.Type = r2.int32();
          break;
        case 2:
          m2.Data = r2.bytes();
          break;
        case 3:
          m2.filesize = r2.uint64();
          break;
        case 4:
          if (!(m2.blocksizes && m2.blocksizes.length))
            m2.blocksizes = [];
          if ((t2 & 7) === 2) {
            var c22 = r2.uint32() + r2.pos;
            while (r2.pos < c22)
              m2.blocksizes.push(r2.uint64());
          } else
            m2.blocksizes.push(r2.uint64());
          break;
        case 5:
          m2.hashType = r2.uint64();
          break;
        case 6:
          m2.fanout = r2.uint64();
          break;
        case 7:
          m2.mode = r2.uint32();
          break;
        case 8:
          m2.mtime = $root.UnixTime.decode(r2, r2.uint32());
          break;
        default:
          r2.skipType(t2 & 7);
          break;
      }
    }
    if (!m2.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m2 });
    return m2;
  };
  Data2.fromObject = function fromObject(d2) {
    if (d2 instanceof $root.Data)
      return d2;
    var m2 = new $root.Data();
    switch (d2.Type) {
      case "Raw":
      case 0:
        m2.Type = 0;
        break;
      case "Directory":
      case 1:
        m2.Type = 1;
        break;
      case "File":
      case 2:
        m2.Type = 2;
        break;
      case "Metadata":
      case 3:
        m2.Type = 3;
        break;
      case "Symlink":
      case 4:
        m2.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m2.Type = 5;
        break;
    }
    if (d2.Data != null) {
      if (typeof d2.Data === "string")
        $util.base64.decode(d2.Data, m2.Data = $util.newBuffer($util.base64.length(d2.Data)), 0);
      else if (d2.Data.length)
        m2.Data = d2.Data;
    }
    if (d2.filesize != null) {
      if ($util.Long)
        (m2.filesize = $util.Long.fromValue(d2.filesize)).unsigned = true;
      else if (typeof d2.filesize === "string")
        m2.filesize = parseInt(d2.filesize, 10);
      else if (typeof d2.filesize === "number")
        m2.filesize = d2.filesize;
      else if (typeof d2.filesize === "object")
        m2.filesize = new $util.LongBits(d2.filesize.low >>> 0, d2.filesize.high >>> 0).toNumber(true);
    }
    if (d2.blocksizes) {
      if (!Array.isArray(d2.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m2.blocksizes = [];
      for (var i2 = 0; i2 < d2.blocksizes.length; ++i2) {
        if ($util.Long)
          (m2.blocksizes[i2] = $util.Long.fromValue(d2.blocksizes[i2])).unsigned = true;
        else if (typeof d2.blocksizes[i2] === "string")
          m2.blocksizes[i2] = parseInt(d2.blocksizes[i2], 10);
        else if (typeof d2.blocksizes[i2] === "number")
          m2.blocksizes[i2] = d2.blocksizes[i2];
        else if (typeof d2.blocksizes[i2] === "object")
          m2.blocksizes[i2] = new $util.LongBits(d2.blocksizes[i2].low >>> 0, d2.blocksizes[i2].high >>> 0).toNumber(true);
      }
    }
    if (d2.hashType != null) {
      if ($util.Long)
        (m2.hashType = $util.Long.fromValue(d2.hashType)).unsigned = true;
      else if (typeof d2.hashType === "string")
        m2.hashType = parseInt(d2.hashType, 10);
      else if (typeof d2.hashType === "number")
        m2.hashType = d2.hashType;
      else if (typeof d2.hashType === "object")
        m2.hashType = new $util.LongBits(d2.hashType.low >>> 0, d2.hashType.high >>> 0).toNumber(true);
    }
    if (d2.fanout != null) {
      if ($util.Long)
        (m2.fanout = $util.Long.fromValue(d2.fanout)).unsigned = true;
      else if (typeof d2.fanout === "string")
        m2.fanout = parseInt(d2.fanout, 10);
      else if (typeof d2.fanout === "number")
        m2.fanout = d2.fanout;
      else if (typeof d2.fanout === "object")
        m2.fanout = new $util.LongBits(d2.fanout.low >>> 0, d2.fanout.high >>> 0).toNumber(true);
    }
    if (d2.mode != null) {
      m2.mode = d2.mode >>> 0;
    }
    if (d2.mtime != null) {
      if (typeof d2.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m2.mtime = $root.UnixTime.fromObject(d2.mtime);
    }
    return m2;
  };
  Data2.toObject = function toObject2(m2, o) {
    if (!o)
      o = {};
    var d2 = {};
    if (o.arrays || o.defaults) {
      d2.blocksizes = [];
    }
    if (o.defaults) {
      d2.Type = o.enums === String ? "Raw" : 0;
      if (o.bytes === String)
        d2.Data = "";
      else {
        d2.Data = [];
        if (o.bytes !== Array)
          d2.Data = $util.newBuffer(d2.Data);
      }
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, true);
        d2.filesize = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
      } else
        d2.filesize = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, true);
        d2.hashType = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
      } else
        d2.hashType = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, true);
        d2.fanout = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
      } else
        d2.fanout = o.longs === String ? "0" : 0;
      d2.mode = 0;
      d2.mtime = null;
    }
    if (m2.Type != null && m2.hasOwnProperty("Type")) {
      d2.Type = o.enums === String ? $root.Data.DataType[m2.Type] : m2.Type;
    }
    if (m2.Data != null && m2.hasOwnProperty("Data")) {
      d2.Data = o.bytes === String ? $util.base64.encode(m2.Data, 0, m2.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m2.Data) : m2.Data;
    }
    if (m2.filesize != null && m2.hasOwnProperty("filesize")) {
      if (typeof m2.filesize === "number")
        d2.filesize = o.longs === String ? String(m2.filesize) : m2.filesize;
      else
        d2.filesize = o.longs === String ? $util.Long.prototype.toString.call(m2.filesize) : o.longs === Number ? new $util.LongBits(m2.filesize.low >>> 0, m2.filesize.high >>> 0).toNumber(true) : m2.filesize;
    }
    if (m2.blocksizes && m2.blocksizes.length) {
      d2.blocksizes = [];
      for (var j2 = 0; j2 < m2.blocksizes.length; ++j2) {
        if (typeof m2.blocksizes[j2] === "number")
          d2.blocksizes[j2] = o.longs === String ? String(m2.blocksizes[j2]) : m2.blocksizes[j2];
        else
          d2.blocksizes[j2] = o.longs === String ? $util.Long.prototype.toString.call(m2.blocksizes[j2]) : o.longs === Number ? new $util.LongBits(m2.blocksizes[j2].low >>> 0, m2.blocksizes[j2].high >>> 0).toNumber(true) : m2.blocksizes[j2];
      }
    }
    if (m2.hashType != null && m2.hasOwnProperty("hashType")) {
      if (typeof m2.hashType === "number")
        d2.hashType = o.longs === String ? String(m2.hashType) : m2.hashType;
      else
        d2.hashType = o.longs === String ? $util.Long.prototype.toString.call(m2.hashType) : o.longs === Number ? new $util.LongBits(m2.hashType.low >>> 0, m2.hashType.high >>> 0).toNumber(true) : m2.hashType;
    }
    if (m2.fanout != null && m2.hasOwnProperty("fanout")) {
      if (typeof m2.fanout === "number")
        d2.fanout = o.longs === String ? String(m2.fanout) : m2.fanout;
      else
        d2.fanout = o.longs === String ? $util.Long.prototype.toString.call(m2.fanout) : o.longs === Number ? new $util.LongBits(m2.fanout.low >>> 0, m2.fanout.high >>> 0).toNumber(true) : m2.fanout;
    }
    if (m2.mode != null && m2.hasOwnProperty("mode")) {
      d2.mode = m2.mode;
    }
    if (m2.mtime != null && m2.hasOwnProperty("mtime")) {
      d2.mtime = $root.UnixTime.toObject(m2.mtime, o);
    }
    return d2;
  };
  Data2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  Data2.DataType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Raw"] = 0;
    values[valuesById[1] = "Directory"] = 1;
    values[valuesById[2] = "File"] = 2;
    values[valuesById[3] = "Metadata"] = 3;
    values[valuesById[4] = "Symlink"] = 4;
    values[valuesById[5] = "HAMTShard"] = 5;
    return values;
  }();
  return Data2;
})();
$root.UnixTime = (() => {
  function UnixTime(p2) {
    if (p2) {
      for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
        if (p2[ks[i2]] != null)
          this[ks[i2]] = p2[ks[i2]];
    }
  }
  UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime.prototype.FractionalNanoseconds = 0;
  UnixTime.encode = function encode3(m2, w2) {
    if (!w2)
      w2 = $Writer.create();
    w2.uint32(8).int64(m2.Seconds);
    if (m2.FractionalNanoseconds != null && Object.hasOwnProperty.call(m2, "FractionalNanoseconds"))
      w2.uint32(21).fixed32(m2.FractionalNanoseconds);
    return w2;
  };
  UnixTime.decode = function decode2(r2, l2) {
    if (!(r2 instanceof $Reader))
      r2 = $Reader.create(r2);
    var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.UnixTime();
    while (r2.pos < c2) {
      var t2 = r2.uint32();
      switch (t2 >>> 3) {
        case 1:
          m2.Seconds = r2.int64();
          break;
        case 2:
          m2.FractionalNanoseconds = r2.fixed32();
          break;
        default:
          r2.skipType(t2 & 7);
          break;
      }
    }
    if (!m2.hasOwnProperty("Seconds"))
      throw $util.ProtocolError("missing required 'Seconds'", { instance: m2 });
    return m2;
  };
  UnixTime.fromObject = function fromObject(d2) {
    if (d2 instanceof $root.UnixTime)
      return d2;
    var m2 = new $root.UnixTime();
    if (d2.Seconds != null) {
      if ($util.Long)
        (m2.Seconds = $util.Long.fromValue(d2.Seconds)).unsigned = false;
      else if (typeof d2.Seconds === "string")
        m2.Seconds = parseInt(d2.Seconds, 10);
      else if (typeof d2.Seconds === "number")
        m2.Seconds = d2.Seconds;
      else if (typeof d2.Seconds === "object")
        m2.Seconds = new $util.LongBits(d2.Seconds.low >>> 0, d2.Seconds.high >>> 0).toNumber();
    }
    if (d2.FractionalNanoseconds != null) {
      m2.FractionalNanoseconds = d2.FractionalNanoseconds >>> 0;
    }
    return m2;
  };
  UnixTime.toObject = function toObject2(m2, o) {
    if (!o)
      o = {};
    var d2 = {};
    if (o.defaults) {
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, false);
        d2.Seconds = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
      } else
        d2.Seconds = o.longs === String ? "0" : 0;
      d2.FractionalNanoseconds = 0;
    }
    if (m2.Seconds != null && m2.hasOwnProperty("Seconds")) {
      if (typeof m2.Seconds === "number")
        d2.Seconds = o.longs === String ? String(m2.Seconds) : m2.Seconds;
      else
        d2.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m2.Seconds) : o.longs === Number ? new $util.LongBits(m2.Seconds.low >>> 0, m2.Seconds.high >>> 0).toNumber() : m2.Seconds;
    }
    if (m2.FractionalNanoseconds != null && m2.hasOwnProperty("FractionalNanoseconds")) {
      d2.FractionalNanoseconds = m2.FractionalNanoseconds;
    }
    return d2;
  };
  UnixTime.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return UnixTime;
})();
$root.Metadata = (() => {
  function Metadata(p2) {
    if (p2) {
      for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
        if (p2[ks[i2]] != null)
          this[ks[i2]] = p2[ks[i2]];
    }
  }
  Metadata.prototype.MimeType = "";
  Metadata.encode = function encode3(m2, w2) {
    if (!w2)
      w2 = $Writer.create();
    if (m2.MimeType != null && Object.hasOwnProperty.call(m2, "MimeType"))
      w2.uint32(10).string(m2.MimeType);
    return w2;
  };
  Metadata.decode = function decode2(r2, l2) {
    if (!(r2 instanceof $Reader))
      r2 = $Reader.create(r2);
    var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.Metadata();
    while (r2.pos < c2) {
      var t2 = r2.uint32();
      switch (t2 >>> 3) {
        case 1:
          m2.MimeType = r2.string();
          break;
        default:
          r2.skipType(t2 & 7);
          break;
      }
    }
    return m2;
  };
  Metadata.fromObject = function fromObject(d2) {
    if (d2 instanceof $root.Metadata)
      return d2;
    var m2 = new $root.Metadata();
    if (d2.MimeType != null) {
      m2.MimeType = String(d2.MimeType);
    }
    return m2;
  };
  Metadata.toObject = function toObject2(m2, o) {
    if (!o)
      o = {};
    var d2 = {};
    if (o.defaults) {
      d2.MimeType = "";
    }
    if (m2.MimeType != null && m2.hasOwnProperty("MimeType")) {
      d2.MimeType = m2.MimeType;
    }
    return d2;
  };
  Metadata.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Metadata;
})();
const PBData = Data;
const types = [
  "raw",
  "directory",
  "file",
  "metadata",
  "symlink",
  "hamt-sharded-directory"
];
const dirTypes = [
  "directory",
  "hamt-sharded-directory"
];
const DEFAULT_FILE_MODE = parseInt("0644", 8);
const DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
function parseMode(mode2) {
  if (mode2 == null) {
    return void 0;
  }
  if (typeof mode2 === "number") {
    return mode2 & 4095;
  }
  mode2 = mode2.toString();
  if (mode2.substring(0, 1) === "0") {
    return parseInt(mode2, 8) & 4095;
  }
  return parseInt(mode2, 10) & 4095;
}
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw errCode$1(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
class UnixFS {
  static unmarshal(marshaled) {
    const message = PBData.decode(marshaled);
    const decoded = PBData.toObject(message, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const data2 = new UnixFS({
      type: types[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime ? {
        secs: decoded.mtime.Seconds,
        nsecs: decoded.mtime.FractionalNanoseconds
      } : void 0
    });
    data2._originalMode = decoded.mode || 0;
    return data2;
  }
  constructor(options = { type: "file" }) {
    const { type, data: data2, blockSizes, hashType: hashType2, fanout, mtime, mode: mode2 } = options;
    if (type && !types.includes(type)) {
      throw errCode$1(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type || "file";
    this.data = data2;
    this.hashType = hashType2;
    this.fanout = fanout;
    this.blockSizes = blockSizes || [];
    this._originalMode = 0;
    this.mode = parseMode(mode2);
    if (mtime) {
      this.mtime = parseMtime(mtime);
      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0;
      }
    }
  }
  set mode(mode2) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    const parsedMode = parseMode(mode2);
    if (parsedMode !== void 0) {
      this._mode = parsedMode;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return Boolean(this.type && dirTypes.includes(this.type));
  }
  addBlockSize(size2) {
    this.blockSizes.push(size2);
  }
  removeBlockSize(index2) {
    this.blockSizes.splice(index2, 1);
  }
  fileSize() {
    if (this.isDirectory()) {
      return 0;
    }
    let sum = 0;
    this.blockSizes.forEach((size2) => {
      sum += size2;
    });
    if (this.data) {
      sum += this.data.length;
    }
    return sum;
  }
  marshal() {
    let type;
    switch (this.type) {
      case "raw":
        type = PBData.DataType.Raw;
        break;
      case "directory":
        type = PBData.DataType.Directory;
        break;
      case "file":
        type = PBData.DataType.File;
        break;
      case "metadata":
        type = PBData.DataType.Metadata;
        break;
      case "symlink":
        type = PBData.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type = PBData.DataType.HAMTShard;
        break;
      default:
        throw errCode$1(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    let data2 = this.data;
    if (!this.data || !this.data.length) {
      data2 = void 0;
    }
    let mode2;
    if (this.mode != null) {
      mode2 = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
      if (mode2 === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode2 = void 0;
      }
      if (mode2 === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode2 = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      const parsed = parseMtime(this.mtime);
      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        };
        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds;
        }
      }
    }
    const pbData = {
      Type: type,
      Data: data2,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode: mode2,
      mtime
    };
    return PBData.encode(pbData).finish();
  }
}
const persist = async (buffer2, blockstore, options) => {
  if (!options.codec) {
    options.codec = dagPb;
  }
  if (!options.hasher) {
    options.hasher = sha256$5;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === dagPb && options.hasher !== sha256$5) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer2, { signal: options.signal });
  }
  return cid;
};
const dirBuilder = async (item, blockstore, options) => {
  const unixfs = new UnixFS({
    type: "directory",
    mtime: item.mtime,
    mode: item.mode
  });
  const buffer2 = encode$2(prepare({ Data: unixfs.marshal() }));
  const cid = await persist(buffer2, blockstore, options);
  const path = item.path;
  return {
    cid,
    path,
    unixfs,
    size: buffer2.length
  };
};
const all = async (source) => {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
};
var itAll = all;
const all$1 = /* @__PURE__ */ getDefaultExportFromCjs(itAll);
async function flat(source, reduce2) {
  return reduce2(await all$1(source));
}
function balanced(source, reduce2, options) {
  return reduceToParents(source, reduce2, options);
}
async function reduceToParents(source, reduce2, options) {
  const roots2 = [];
  for await (const chunked of batch$2(source, options.maxChildrenPerNode)) {
    roots2.push(await reduce2(chunked));
  }
  if (roots2.length > 1) {
    return reduceToParents(roots2, reduce2, options);
  }
  return roots2[0];
}
async function trickleStream(source, reduce2, options) {
  const root2 = new Root(options.layerRepeat);
  let iteration = 0;
  let maxDepth = 1;
  let subTree = root2;
  for await (const layer of batch$2(source, options.maxChildrenPerNode)) {
    if (subTree.isFull()) {
      if (subTree !== root2) {
        root2.addChild(await subTree.reduce(reduce2));
      }
      if (iteration && iteration % options.layerRepeat === 0) {
        maxDepth++;
      }
      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
      iteration++;
    }
    subTree.append(layer);
  }
  if (subTree && subTree !== root2) {
    root2.addChild(await subTree.reduce(reduce2));
  }
  return root2.reduce(reduce2);
}
class SubTree {
  constructor(maxDepth, layerRepeat, iteration = 0) {
    this.maxDepth = maxDepth;
    this.layerRepeat = layerRepeat;
    this.currentDepth = 1;
    this.iteration = iteration;
    this.root = this.node = this.parent = {
      children: [],
      depth: this.currentDepth,
      maxDepth,
      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
    };
  }
  isFull() {
    if (!this.root.data) {
      return false;
    }
    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
      this._addNextNodeToParent(this.node);
      return false;
    }
    const distantRelative = this._findParent(this.node, this.currentDepth);
    if (distantRelative) {
      this._addNextNodeToParent(distantRelative);
      return false;
    }
    return true;
  }
  _addNextNodeToParent(parent) {
    this.parent = parent;
    const nextNode = {
      children: [],
      depth: parent.depth + 1,
      parent,
      maxDepth: this.maxDepth,
      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat
    };
    parent.children.push(nextNode);
    this.currentDepth = nextNode.depth;
    this.node = nextNode;
  }
  append(layer) {
    this.node.data = layer;
  }
  reduce(reduce2) {
    return this._reduce(this.root, reduce2);
  }
  async _reduce(node2, reduce2) {
    let children = [];
    if (node2.children.length) {
      children = await Promise.all(node2.children.filter((child) => child.data).map((child) => this._reduce(child, reduce2)));
    }
    return reduce2((node2.data || []).concat(children));
  }
  _findParent(node2, depth) {
    const parent = node2.parent;
    if (!parent || parent.depth === 0) {
      return;
    }
    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {
      return this._findParent(parent, depth);
    }
    return parent;
  }
}
class Root extends SubTree {
  constructor(layerRepeat) {
    super(0, layerRepeat);
    this.root.depth = 0;
    this.currentDepth = 1;
  }
  addChild(child) {
    this.root.children.push(child);
  }
  reduce(reduce2) {
    return reduce2((this.root.data || []).concat(this.root.children));
  }
}
async function* bufferImporter(file, block2, options) {
  for await (let buffer2 of file.content) {
    yield async () => {
      options.progress(buffer2.length, file.path);
      let unixfs;
      const opts = {
        codec: dagPb,
        cidVersion: options.cidVersion,
        hasher: options.hasher,
        onlyHash: options.onlyHash
      };
      if (options.rawLeaves) {
        opts.codec = raw;
        opts.cidVersion = 1;
      } else {
        unixfs = new UnixFS({
          type: options.leafType,
          data: buffer2
        });
        buffer2 = encode$2({
          Data: unixfs.marshal(),
          Links: []
        });
      }
      return {
        cid: await persist(buffer2, block2, opts),
        unixfs,
        size: buffer2.length
      };
    };
  }
}
const dagBuilders = {
  flat,
  balanced,
  trickle: trickleStream
};
async function* buildFileBatch(file, blockstore, options) {
  let count = -1;
  let previous;
  let bufferImporter$1;
  if (typeof options.bufferImporter === "function") {
    bufferImporter$1 = options.bufferImporter;
  } else {
    bufferImporter$1 = bufferImporter;
  }
  for await (const entry of parallelBatch$1(bufferImporter$1(file, blockstore, options), options.blockWriteConcurrency)) {
    count++;
    if (count === 0) {
      previous = entry;
      continue;
    } else if (count === 1 && previous) {
      yield previous;
      previous = null;
    }
    yield entry;
  }
  if (previous) {
    previous.single = true;
    yield previous;
  }
}
const reduce = (file, blockstore, options) => {
  async function reducer(leaves) {
    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
      const leaf = leaves[0];
      if (file.mtime !== void 0 || file.mode !== void 0) {
        let buffer3 = await blockstore.get(leaf.cid);
        leaf.unixfs = new UnixFS({
          type: "file",
          mtime: file.mtime,
          mode: file.mode,
          data: buffer3
        });
        buffer3 = encode$2(prepare({ Data: leaf.unixfs.marshal() }));
        leaf.cid = await persist(buffer3, blockstore, {
          ...options,
          codec: dagPb,
          hasher: options.hasher,
          cidVersion: options.cidVersion
        });
        leaf.size = buffer3.length;
      }
      return {
        cid: leaf.cid,
        path: file.path,
        unixfs: leaf.unixfs,
        size: leaf.size
      };
    }
    const f2 = new UnixFS({
      type: "file",
      mtime: file.mtime,
      mode: file.mode
    });
    const links2 = leaves.filter((leaf) => {
      if (leaf.cid.code === code$4 && leaf.size) {
        return true;
      }
      if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
        return true;
      }
      return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
    }).map((leaf) => {
      if (leaf.cid.code === code$4) {
        f2.addBlockSize(leaf.size);
        return {
          Name: "",
          Tsize: leaf.size,
          Hash: leaf.cid
        };
      }
      if (!leaf.unixfs || !leaf.unixfs.data) {
        f2.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
      } else {
        f2.addBlockSize(leaf.unixfs.data.length);
      }
      return {
        Name: "",
        Tsize: leaf.size,
        Hash: leaf.cid
      };
    });
    const node2 = {
      Data: f2.marshal(),
      Links: links2
    };
    const buffer2 = encode$2(prepare(node2));
    const cid = await persist(buffer2, blockstore, options);
    return {
      cid,
      path: file.path,
      unixfs: f2,
      size: buffer2.length + node2.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
    };
  }
  return reducer;
};
function fileBuilder(file, block2, options) {
  const dagBuilder2 = dagBuilders[options.strategy];
  if (!dagBuilder2) {
    throw errCode$1(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
  }
  return dagBuilder2(buildFileBatch(file, block2, options), reduce(file, block2, options), options);
}
var buffer$1 = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base642 = require$$0$s;
  const ieee7542 = require$$1$a;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf2 = new Uint8Array(length2);
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize2(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc3(size2, fill, encoding2) {
    assertSize2(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding2 === "string" ? createBuffer(size2).fill(fill, encoding2) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding2) {
    return alloc3(size2, fill, encoding2);
  };
  function allocUnsafe2(size2) {
    assertSize2(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding2) {
    if (typeof encoding2 !== "string" || encoding2 === "") {
      encoding2 = "utf8";
    }
    if (!Buffer2.isEncoding(encoding2)) {
      throw new TypeError("Unknown encoding: " + encoding2);
    }
    const length2 = byteLength2(string2, encoding2) | 0;
    let buf2 = createBuffer(length2);
    const actual = buf2.write(string2, encoding2);
    if (actual !== length2) {
      buf2 = buf2.slice(0, actual);
    }
    return buf2;
  }
  function fromArrayLike(array) {
    const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf2 = createBuffer(length2);
    for (let i2 = 0; i2 < length2; i2 += 1) {
      buf2[i2] = array[i2] & 255;
    }
    return buf2;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length2) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf2;
    if (byteOffset === void 0 && length2 === void 0) {
      buf2 = new Uint8Array(array);
    } else if (length2 === void 0) {
      buf2 = new Uint8Array(array, byteOffset);
    } else {
      buf2 = new Uint8Array(array, byteOffset, length2);
    }
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf2 = createBuffer(len2);
      if (buf2.length === 0) {
        return buf2;
      }
      obj.copy(buf2, 0, 0, len2);
      return buf2;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2)
      return 0;
    let x2 = a2.length;
    let y2 = b2.length;
    for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding2) {
    switch (String(encoding2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length2 === void 0) {
      length2 = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length2 += list[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length2);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf2 = list[i2];
      if (isInstance(buf2, Uint8Array)) {
        if (pos + buf2.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf2))
            buf2 = Buffer2.from(buf2);
          buf2.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf2,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf2.copy(buffer2, pos);
      }
      pos += buf2.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding2) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding2, start, end2) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding2)
      encoding2 = "utf8";
    while (true) {
      switch (encoding2) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice2(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = (encoding2 + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    const i2 = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    const length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice2(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect2() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end2 - start;
    const len2 = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end2);
    for (let i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding2, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding2 = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding2);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding2, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding2, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding2 !== void 0) {
      encoding2 = String(encoding2).toLowerCase();
      if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf2, i3) {
      if (indexSize === 1) {
        return buf2[i3];
      } else {
        return buf2.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read2(arr, i2 + j2) !== read2(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding2) {
    return this.indexOf(val, byteOffset, encoding2) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
  };
  function hexWrite(buf2, string2, offset, length2) {
    offset = Number(offset) || 0;
    const remaining = buf2.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf2[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf2, string2, offset, length2) {
    return blitBuffer(utf8ToBytes2(string2, buf2.length - offset), buf2, offset, length2);
  }
  function asciiWrite(buf2, string2, offset, length2) {
    return blitBuffer(asciiToBytes(string2), buf2, offset, length2);
  }
  function base64Write(buf2, string2, offset, length2) {
    return blitBuffer(base64ToBytes(string2), buf2, offset, length2);
  }
  function ucs2Write(buf2, string2, offset, length2) {
    return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length2);
  }
  Buffer2.prototype.write = function write4(string2, offset, length2, encoding2) {
    if (offset === void 0) {
      encoding2 = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding2 = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding2 === void 0)
          encoding2 = "utf8";
      } else {
        encoding2 = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding2)
      encoding2 = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "hex":
          return hexWrite(this, string2, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length2);
        case "base64":
          return base64Write(this, string2, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf2, start, end2) {
    if (start === 0 && end2 === buf2.length) {
      return base642.fromByteArray(buf2);
    } else {
      return base642.fromByteArray(buf2.slice(start, end2));
    }
  }
  function utf8Slice2(buf2, start, end2) {
    end2 = Math.min(buf2.length, end2);
    const res = [];
    let i2 = start;
    while (i2 < end2) {
      const firstByte = buf2[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end2) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[i2 + 1];
            thirdByte = buf2[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[i2 + 1];
            thirdByte = buf2[i2 + 2];
            fourthByte = buf2[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  const MAX_ARGUMENTS_LENGTH2 = 4096;
  function decodeCodePointsArray2(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH2)
      );
    }
    return res;
  }
  function asciiSlice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf2[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf2[i2]);
    }
    return ret;
  }
  function hexSlice(buf2, start, end2) {
    const len2 = buf2.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len2)
      end2 = len2;
    let out = "";
    for (let i2 = start; i2 < end2; ++i2) {
      out += hexSliceLookupTable[buf2[i2]];
    }
    return out;
  }
  function utf16leSlice(buf2, start, end2) {
    const bytes2 = buf2.slice(start, end2);
    let res = "";
    for (let i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice3(start, end2) {
    const len2 = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len2 : ~~end2;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end2 < 0) {
      end2 += len2;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len2) {
      end2 = len2;
    }
    if (end2 < start)
      end2 = start;
    const newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length2) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul3 = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      val += this[offset + i2] * mul3;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul3 = 1;
    while (byteLength3 > 0 && (mul3 *= 256)) {
      val += this[offset + --byteLength3] * mul3;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul3 = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      val += this[offset + i2] * mul3;
    }
    mul3 *= 128;
    if (val >= mul3)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i2 = byteLength3;
    let mul3 = 1;
    let val = this[offset + --i2];
    while (i2 > 0 && (mul3 *= 256)) {
      val += this[offset + --i2] * mul3;
    }
    mul3 *= 128;
    if (val >= mul3)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, false, 52, 8);
  };
  function checkInt(buf2, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul3 = 1;
    let i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      this[offset + i2] = value / mul3 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul3 = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul3 *= 256)) {
      this[offset + i2] = value / mul3 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf2, value, offset, min, max) {
    checkIntBI(value, min, max, buf2, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    lo = lo >> 8;
    buf2[offset++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf2, value, offset, min, max) {
    checkIntBI(value, min, max, buf2, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf2[offset + 7] = lo;
    lo = lo >> 8;
    buf2[offset + 6] = lo;
    lo = lo >> 8;
    buf2[offset + 5] = lo;
    lo = lo >> 8;
    buf2[offset + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul3 = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul3 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul3 = 1;
    let sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul3 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul3 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf2, value, offset, ext, max, min) {
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 4);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 8);
    }
    ieee7542.write(buf2, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    const len2 = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end2),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end2, encoding2) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding2 = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding2 = end2;
        end2 = this.length;
      }
      if (encoding2 !== void 0 && typeof encoding2 !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding2 === "string" && !Buffer2.isEncoding(encoding2)) {
        throw new TypeError("Unknown encoding: " + encoding2);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding2 === "utf8" && code2 < 128 || encoding2 === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end2; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding2);
      const len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end2 - start; ++i2) {
        this[i2 + start] = bytes2[i2 % len2];
      }
    }
    return this;
  };
  const errors2 = {};
  function E2(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf2, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf2[offset] === void 0 || buf2[offset + byteLength3] === void 0) {
      boundsError(offset, buf2.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf2, offset, byteLength3) {
    if (value > max || value < min) {
      const n2 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      } else {
        range = `>= ${min}${n2} and <= ${max}${n2}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf2, offset, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length2, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length2 < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length2}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length2) {
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet2[i2] + alphabet2[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const index$1 = /* @__PURE__ */ getDefaultExportFromCjs(buffer$1);
const buffer = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$1
}, [buffer$1]);
const require$$0$7 = /* @__PURE__ */ getAugmentedNamespace(buffer);
const { Buffer } = require$$0$7;
const symbol = Symbol.for("BufferList");
function BufferList(buf2) {
  if (!(this instanceof BufferList)) {
    return new BufferList(buf2);
  }
  BufferList._init.call(this, buf2);
}
BufferList._init = function _init(buf2) {
  Object.defineProperty(this, symbol, { value: true });
  this._bufs = [];
  this.length = 0;
  if (buf2) {
    this.append(buf2);
  }
};
BufferList.prototype._new = function _new(buf2) {
  return new BufferList(buf2);
};
BufferList.prototype._offset = function _offset(offset) {
  if (offset === 0) {
    return [0, 0];
  }
  let tot = 0;
  for (let i2 = 0; i2 < this._bufs.length; i2++) {
    const _t2 = tot + this._bufs[i2].length;
    if (offset < _t2 || i2 === this._bufs.length - 1) {
      return [i2, offset - tot];
    }
    tot = _t2;
  }
};
BufferList.prototype._reverseOffset = function(blOffset) {
  const bufferId = blOffset[0];
  let offset = blOffset[1];
  for (let i2 = 0; i2 < bufferId; i2++) {
    offset += this._bufs[i2].length;
  }
  return offset;
};
BufferList.prototype.get = function get2(index2) {
  if (index2 > this.length || index2 < 0) {
    return void 0;
  }
  const offset = this._offset(index2);
  return this._bufs[offset[0]][offset[1]];
};
BufferList.prototype.slice = function slice2(start, end2) {
  if (typeof start === "number" && start < 0) {
    start += this.length;
  }
  if (typeof end2 === "number" && end2 < 0) {
    end2 += this.length;
  }
  return this.copy(null, 0, start, end2);
};
BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart !== "number" || srcStart < 0) {
    srcStart = 0;
  }
  if (typeof srcEnd !== "number" || srcEnd > this.length) {
    srcEnd = this.length;
  }
  if (srcStart >= this.length) {
    return dst || Buffer.alloc(0);
  }
  if (srcEnd <= 0) {
    return dst || Buffer.alloc(0);
  }
  const copy2 = !!dst;
  const off2 = this._offset(srcStart);
  const len2 = srcEnd - srcStart;
  let bytes2 = len2;
  let bufoff = copy2 && dstStart || 0;
  let start = off2[1];
  if (srcStart === 0 && srcEnd === this.length) {
    if (!copy2) {
      return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);
    }
    for (let i2 = 0; i2 < this._bufs.length; i2++) {
      this._bufs[i2].copy(dst, bufoff);
      bufoff += this._bufs[i2].length;
    }
    return dst;
  }
  if (bytes2 <= this._bufs[off2[0]].length - start) {
    return copy2 ? this._bufs[off2[0]].copy(dst, dstStart, start, start + bytes2) : this._bufs[off2[0]].slice(start, start + bytes2);
  }
  if (!copy2) {
    dst = Buffer.allocUnsafe(len2);
  }
  for (let i2 = off2[0]; i2 < this._bufs.length; i2++) {
    const l2 = this._bufs[i2].length - start;
    if (bytes2 > l2) {
      this._bufs[i2].copy(dst, bufoff, start);
      bufoff += l2;
    } else {
      this._bufs[i2].copy(dst, bufoff, start, start + bytes2);
      bufoff += l2;
      break;
    }
    bytes2 -= l2;
    if (start) {
      start = 0;
    }
  }
  if (dst.length > bufoff)
    return dst.slice(0, bufoff);
  return dst;
};
BufferList.prototype.shallowSlice = function shallowSlice(start, end2) {
  start = start || 0;
  end2 = typeof end2 !== "number" ? this.length : end2;
  if (start < 0) {
    start += this.length;
  }
  if (end2 < 0) {
    end2 += this.length;
  }
  if (start === end2) {
    return this._new();
  }
  const startOffset = this._offset(start);
  const endOffset = this._offset(end2);
  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
  if (endOffset[1] === 0) {
    buffers.pop();
  } else {
    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
  }
  if (startOffset[1] !== 0) {
    buffers[0] = buffers[0].slice(startOffset[1]);
  }
  return this._new(buffers);
};
BufferList.prototype.toString = function toString2(encoding2, start, end2) {
  return this.slice(start, end2).toString(encoding2);
};
BufferList.prototype.consume = function consume(bytes2) {
  bytes2 = Math.trunc(bytes2);
  if (Number.isNaN(bytes2) || bytes2 <= 0)
    return this;
  while (this._bufs.length) {
    if (bytes2 >= this._bufs[0].length) {
      bytes2 -= this._bufs[0].length;
      this.length -= this._bufs[0].length;
      this._bufs.shift();
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes2);
      this.length -= bytes2;
      break;
    }
  }
  return this;
};
BufferList.prototype.duplicate = function duplicate() {
  const copy2 = this._new();
  for (let i2 = 0; i2 < this._bufs.length; i2++) {
    copy2.append(this._bufs[i2]);
  }
  return copy2;
};
BufferList.prototype.append = function append(buf2) {
  if (buf2 == null) {
    return this;
  }
  if (buf2.buffer) {
    this._appendBuffer(Buffer.from(buf2.buffer, buf2.byteOffset, buf2.byteLength));
  } else if (Array.isArray(buf2)) {
    for (let i2 = 0; i2 < buf2.length; i2++) {
      this.append(buf2[i2]);
    }
  } else if (this._isBufferList(buf2)) {
    for (let i2 = 0; i2 < buf2._bufs.length; i2++) {
      this.append(buf2._bufs[i2]);
    }
  } else {
    if (typeof buf2 === "number") {
      buf2 = buf2.toString();
    }
    this._appendBuffer(Buffer.from(buf2));
  }
  return this;
};
BufferList.prototype._appendBuffer = function appendBuffer(buf2) {
  this._bufs.push(buf2);
  this.length += buf2.length;
};
BufferList.prototype.indexOf = function(search, offset, encoding2) {
  if (encoding2 === void 0 && typeof offset === "string") {
    encoding2 = offset;
    offset = void 0;
  }
  if (typeof search === "function" || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
  } else if (typeof search === "number") {
    search = Buffer.from([search]);
  } else if (typeof search === "string") {
    search = Buffer.from(search, encoding2);
  } else if (this._isBufferList(search)) {
    search = search.slice();
  } else if (Array.isArray(search.buffer)) {
    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);
  } else if (!Buffer.isBuffer(search)) {
    search = Buffer.from(search);
  }
  offset = Number(offset || 0);
  if (isNaN(offset)) {
    offset = 0;
  }
  if (offset < 0) {
    offset = this.length + offset;
  }
  if (offset < 0) {
    offset = 0;
  }
  if (search.length === 0) {
    return offset > this.length ? this.length : offset;
  }
  const blOffset = this._offset(offset);
  let blIndex = blOffset[0];
  let buffOffset = blOffset[1];
  for (; blIndex < this._bufs.length; blIndex++) {
    const buff = this._bufs[blIndex];
    while (buffOffset < buff.length) {
      const availableWindow = buff.length - buffOffset;
      if (availableWindow >= search.length) {
        const nativeSearchResult = buff.indexOf(search, buffOffset);
        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult]);
        }
        buffOffset = buff.length - search.length + 1;
      } else {
        const revOffset = this._reverseOffset([blIndex, buffOffset]);
        if (this._match(revOffset, search)) {
          return revOffset;
        }
        buffOffset++;
      }
    }
    buffOffset = 0;
  }
  return -1;
};
BufferList.prototype._match = function(offset, search) {
  if (this.length - offset < search.length) {
    return false;
  }
  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
    if (this.get(offset + searchOffset) !== search[searchOffset]) {
      return false;
    }
  }
  return true;
};
(function() {
  const methods2 = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1,
    readIntBE: null,
    readIntLE: null,
    readUIntBE: null,
    readUIntLE: null
  };
  for (const m2 in methods2) {
    (function(m3) {
      if (methods2[m3] === null) {
        BufferList.prototype[m3] = function(offset, byteLength2) {
          return this.slice(offset, offset + byteLength2)[m3](0, byteLength2);
        };
      } else {
        BufferList.prototype[m3] = function(offset = 0) {
          return this.slice(offset, offset + methods2[m3])[m3](0);
        };
      }
    })(m2);
  }
})();
BufferList.prototype._isBufferList = function _isBufferList(b2) {
  return b2 instanceof BufferList || BufferList.isBufferList(b2);
};
BufferList.isBufferList = function isBufferList(b2) {
  return b2 != null && b2[symbol];
};
var BufferList_1 = BufferList;
const BufferList$1 = /* @__PURE__ */ getDefaultExportFromCjs(BufferList_1);
let Rabin$1 = class Rabin2 {
  /**
   * Creates an instance of Rabin.
   * @param { import("./../dist/rabin-wasm") } asModule
   * @param {number} [bits=12]
   * @param {number} [min=8 * 1024]
   * @param {number} [max=32 * 1024]
   * @param {number} polynomial
   * @memberof Rabin
   */
  constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial2) {
    this.bits = bits;
    this.min = min;
    this.max = max;
    this.asModule = asModule;
    this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial2);
    this.polynomial = polynomial2;
  }
  /**
   * Fingerprints the buffer
   *
   * @param {Uint8Array} buf
   * @returns {Array<number>}
   * @memberof Rabin
   */
  fingerprint(buf2) {
    const {
      __retain,
      __release,
      __allocArray,
      __getInt32Array,
      Int32Array_ID,
      Uint8Array_ID
    } = this.asModule;
    const lengths = new Int32Array(Math.ceil(buf2.length / this.min));
    const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
    const pointer = __retain(__allocArray(Uint8Array_ID, buf2));
    const out = this.rabin.fingerprint(pointer, lengthsPtr);
    const processed = __getInt32Array(out);
    __release(pointer);
    __release(lengthsPtr);
    const end2 = processed.indexOf(0);
    return end2 >= 0 ? processed.subarray(0, end2) : processed;
  }
};
var rabin$1 = Rabin$1;
const rabin$2 = /* @__PURE__ */ getDefaultExportFromCjs(rabin$1);
const rabin$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: rabin$2
}, [rabin$1]);
const require$$0$6 = /* @__PURE__ */ getAugmentedNamespace(rabin$3);
var loader$1 = {};
const ID_OFFSET = -8;
const SIZE_OFFSET = -4;
const ARRAYBUFFER_ID = 0;
const STRING_ID = 1;
const ARRAYBUFFERVIEW = 1 << 0;
const ARRAY = 1 << 1;
const VAL_ALIGN_OFFSET = 5;
const VAL_SIGNED = 1 << 10;
const VAL_FLOAT = 1 << 11;
const VAL_MANAGED = 1 << 13;
const ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
const ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
const ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
const ARRAYBUFFERVIEW_SIZE = 12;
const ARRAY_LENGTH_OFFSET = 12;
const ARRAY_SIZE = 16;
const BIGINT = typeof BigUint64Array !== "undefined";
const THIS = Symbol();
const CHUNKSIZE = 1024;
function getStringImpl(buffer2, ptr) {
  const U32 = new Uint32Array(buffer2);
  const U16 = new Uint16Array(buffer2);
  var length2 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
  var offset = ptr >>> 1;
  if (length2 <= CHUNKSIZE)
    return String.fromCharCode.apply(String, U16.subarray(offset, offset + length2));
  const parts = [];
  do {
    const last2 = U16[offset + CHUNKSIZE - 1];
    const size2 = last2 >= 55296 && last2 < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size2)));
    length2 -= size2;
  } while (length2 > CHUNKSIZE);
  return parts.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length2));
}
function preInstantiate(imports) {
  const baseModule = {};
  function getString(memory, ptr) {
    if (!memory)
      return "<yet unknown>";
    return getStringImpl(memory.buffer, ptr);
  }
  const env2 = imports.env = imports.env || {};
  env2.abort = env2.abort || function abort(mesg, file, line, colm) {
    const memory = baseModule.memory || env2.memory;
    throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
  };
  env2.trace = env2.trace || function trace(mesg, n2) {
    const memory = baseModule.memory || env2.memory;
    console.log("trace: " + getString(memory, mesg) + (n2 ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n2).join(", "));
  };
  imports.Math = imports.Math || Math;
  imports.Date = imports.Date || Date;
  return baseModule;
}
function postInstantiate(baseModule, instance) {
  const rawExports = instance.exports;
  const memory = rawExports.memory;
  const table = rawExports.table;
  const alloc3 = rawExports["__alloc"];
  const retain = rawExports["__retain"];
  const rttiBase = rawExports["__rtti_base"] || ~0;
  function getInfo(id2) {
    const U32 = new Uint32Array(memory.buffer);
    const count = U32[rttiBase >>> 2];
    if ((id2 >>>= 0) >= count)
      throw Error("invalid id: " + id2);
    return U32[(rttiBase + 4 >>> 2) + id2 * 2];
  }
  function getBase(id2) {
    const U32 = new Uint32Array(memory.buffer);
    const count = U32[rttiBase >>> 2];
    if ((id2 >>>= 0) >= count)
      throw Error("invalid id: " + id2);
    return U32[(rttiBase + 4 >>> 2) + id2 * 2 + 1];
  }
  function getValueAlign(info) {
    return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
  }
  function __allocString(str) {
    const length2 = str.length;
    const ptr = alloc3(length2 << 1, STRING_ID);
    const U16 = new Uint16Array(memory.buffer);
    for (var i2 = 0, p2 = ptr >>> 1; i2 < length2; ++i2)
      U16[p2 + i2] = str.charCodeAt(i2);
    return ptr;
  }
  baseModule.__allocString = __allocString;
  function __getString(ptr) {
    const buffer2 = memory.buffer;
    const id2 = new Uint32Array(buffer2)[ptr + ID_OFFSET >>> 2];
    if (id2 !== STRING_ID)
      throw Error("not a string: " + ptr);
    return getStringImpl(buffer2, ptr);
  }
  baseModule.__getString = __getString;
  function getView(alignLog2, signed, float2) {
    const buffer2 = memory.buffer;
    if (float2) {
      switch (alignLog2) {
        case 2:
          return new Float32Array(buffer2);
        case 3:
          return new Float64Array(buffer2);
      }
    } else {
      switch (alignLog2) {
        case 0:
          return new (signed ? Int8Array : Uint8Array)(buffer2);
        case 1:
          return new (signed ? Int16Array : Uint16Array)(buffer2);
        case 2:
          return new (signed ? Int32Array : Uint32Array)(buffer2);
        case 3:
          return new (signed ? BigInt64Array : BigUint64Array)(buffer2);
      }
    }
    throw Error("unsupported align: " + alignLog2);
  }
  function __allocArray(id2, values) {
    const info = getInfo(id2);
    if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
      throw Error("not an array: " + id2 + " @ " + info);
    const align = getValueAlign(info);
    const length2 = values.length;
    const buf2 = alloc3(length2 << align, ARRAYBUFFER_ID);
    const arr = alloc3(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id2);
    const U32 = new Uint32Array(memory.buffer);
    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf2);
    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf2;
    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length2 << align;
    if (info & ARRAY)
      U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length2;
    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
    if (info & VAL_MANAGED) {
      for (let i2 = 0; i2 < length2; ++i2)
        view[(buf2 >>> align) + i2] = retain(values[i2]);
    } else {
      view.set(values, buf2 >>> align);
    }
    return arr;
  }
  baseModule.__allocArray = __allocArray;
  function __getArrayView(arr) {
    const U32 = new Uint32Array(memory.buffer);
    const id2 = U32[arr + ID_OFFSET >>> 2];
    const info = getInfo(id2);
    if (!(info & ARRAYBUFFERVIEW))
      throw Error("not an array: " + id2);
    const align = getValueAlign(info);
    var buf2 = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
    const length2 = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf2 + SIZE_OFFSET >>> 2] >>> align;
    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf2 >>>= align, buf2 + length2);
  }
  baseModule.__getArrayView = __getArrayView;
  function __getArray(arr) {
    const input = __getArrayView(arr);
    const len2 = input.length;
    const out = new Array(len2);
    for (let i2 = 0; i2 < len2; i2++)
      out[i2] = input[i2];
    return out;
  }
  baseModule.__getArray = __getArray;
  function __getArrayBuffer(ptr) {
    const buffer2 = memory.buffer;
    const length2 = new Uint32Array(buffer2)[ptr + SIZE_OFFSET >>> 2];
    return buffer2.slice(ptr, ptr + length2);
  }
  baseModule.__getArrayBuffer = __getArrayBuffer;
  function getTypedArray(Type2, alignLog2, ptr) {
    return new Type2(getTypedArrayView(Type2, alignLog2, ptr));
  }
  function getTypedArrayView(Type2, alignLog2, ptr) {
    const buffer2 = memory.buffer;
    const U32 = new Uint32Array(buffer2);
    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
    return new Type2(buffer2, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
  }
  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
  if (BIGINT) {
    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
  }
  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
  function __instanceof(ptr, baseId) {
    const U32 = new Uint32Array(memory.buffer);
    var id2 = U32[ptr + ID_OFFSET >>> 2];
    if (id2 <= U32[rttiBase >>> 2]) {
      do
        if (id2 == baseId)
          return true;
      while (id2 = getBase(id2));
    }
    return false;
  }
  baseModule.__instanceof = __instanceof;
  baseModule.memory = baseModule.memory || memory;
  baseModule.table = baseModule.table || table;
  return demangle(rawExports, baseModule);
}
function isResponse(o) {
  return typeof Response !== "undefined" && o instanceof Response;
}
async function instantiate$1(source, imports) {
  if (isResponse(source = await source))
    return instantiateStreaming(source, imports);
  return postInstantiate(
    preInstantiate(imports || (imports = {})),
    await WebAssembly.instantiate(
      source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source),
      imports
    )
  );
}
var instantiate_1 = loader$1.instantiate = instantiate$1;
function instantiateSync(source, imports) {
  return postInstantiate(
    preInstantiate(imports || (imports = {})),
    new WebAssembly.Instance(
      source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source),
      imports
    )
  );
}
var instantiateSync_1 = loader$1.instantiateSync = instantiateSync;
async function instantiateStreaming(source, imports) {
  if (!WebAssembly.instantiateStreaming) {
    return instantiate$1(
      isResponse(source = await source) ? source.arrayBuffer() : source,
      imports
    );
  }
  return postInstantiate(
    preInstantiate(imports || (imports = {})),
    (await WebAssembly.instantiateStreaming(source, imports)).instance
  );
}
var instantiateStreaming_1 = loader$1.instantiateStreaming = instantiateStreaming;
function demangle(exports, baseModule) {
  var module2 = baseModule ? Object.create(baseModule) : {};
  var setArgumentsLength = exports["__argumentsLength"] ? function(length2) {
    exports["__argumentsLength"].value = length2;
  } : exports["__setArgumentsLength"] || exports["__setargc"] || function() {
  };
  for (let internalName in exports) {
    if (!Object.prototype.hasOwnProperty.call(exports, internalName))
      continue;
    const elem = exports[internalName];
    let parts = internalName.split(".");
    let curr = module2;
    while (parts.length > 1) {
      let part = parts.shift();
      if (!Object.prototype.hasOwnProperty.call(curr, part))
        curr[part] = {};
      curr = curr[part];
    }
    let name2 = parts[0];
    let hash2 = name2.indexOf("#");
    if (hash2 >= 0) {
      let className = name2.substring(0, hash2);
      let classElem = curr[className];
      if (typeof classElem === "undefined" || !classElem.prototype) {
        let ctor = function(...args) {
          return ctor.wrap(ctor.prototype.constructor(0, ...args));
        };
        ctor.prototype = {
          valueOf: function valueOf() {
            return this[THIS];
          }
        };
        ctor.wrap = function(thisValue) {
          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
        };
        if (classElem)
          Object.getOwnPropertyNames(classElem).forEach(
            (name3) => Object.defineProperty(ctor, name3, Object.getOwnPropertyDescriptor(classElem, name3))
          );
        curr[className] = ctor;
      }
      name2 = name2.substring(hash2 + 1);
      curr = curr[className].prototype;
      if (/^(get|set):/.test(name2)) {
        if (!Object.prototype.hasOwnProperty.call(curr, name2 = name2.substring(4))) {
          let getter = exports[internalName.replace("set:", "get:")];
          let setter = exports[internalName.replace("get:", "set:")];
          Object.defineProperty(curr, name2, {
            get: function() {
              return getter(this[THIS]);
            },
            set: function(value) {
              setter(this[THIS], value);
            },
            enumerable: true
          });
        }
      } else {
        if (name2 === "constructor") {
          (curr[name2] = (...args) => {
            setArgumentsLength(args.length);
            return elem(...args);
          }).original = elem;
        } else {
          (curr[name2] = function(...args) {
            setArgumentsLength(args.length);
            return elem(this[THIS], ...args);
          }).original = elem;
        }
      }
    } else {
      if (/^(get|set):/.test(name2)) {
        if (!Object.prototype.hasOwnProperty.call(curr, name2 = name2.substring(4))) {
          Object.defineProperty(curr, name2, {
            get: exports[internalName.replace("set:", "get:")],
            set: exports[internalName.replace("get:", "set:")],
            enumerable: true
          });
        }
      } else if (typeof elem === "function" && elem !== setArgumentsLength) {
        (curr[name2] = (...args) => {
          setArgumentsLength(args.length);
          return elem(...args);
        }).original = elem;
      } else {
        curr[name2] = elem;
      }
    }
  }
  return module2;
}
var demangle_1 = loader$1.demangle = demangle;
const loader = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: loader$1,
  demangle: demangle_1,
  instantiate: instantiate_1,
  instantiateStreaming: instantiateStreaming_1,
  instantiateSync: instantiateSync_1
}, [loader$1]);
const require$$0$5 = /* @__PURE__ */ getAugmentedNamespace(loader);
const { instantiate } = require$$0$5;
loadWebAssembly.supported = typeof WebAssembly !== "undefined";
function loadWebAssembly(imp = {}) {
  if (!loadWebAssembly.supported)
    return null;
  var wasm = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
  return instantiate(new Response(new Blob([wasm], { type: "application/wasm" })), imp);
}
var rabinWasm = loadWebAssembly;
const rabinWasm$1 = /* @__PURE__ */ getDefaultExportFromCjs(rabinWasm);
const rabinWasm$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: rabinWasm$1
}, [rabinWasm]);
const require$$1$3 = /* @__PURE__ */ getAugmentedNamespace(rabinWasm$2);
const Rabin = require$$0$6;
const getRabin = require$$1$3;
const create = async (avg, min, max, windowSize, polynomial2) => {
  const compiled = await getRabin();
  return new Rabin(compiled, avg, min, max, windowSize, polynomial2);
};
var src$1 = {
  Rabin,
  create
};
async function* rabinChunker(source, options) {
  let min, max, avg;
  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
    avg = options.avgChunkSize;
    min = options.minChunkSize;
    max = options.maxChunkSize;
  } else if (!options.avgChunkSize) {
    throw errCode$1(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
  } else {
    avg = options.avgChunkSize;
    min = avg / 3;
    max = avg + avg / 2;
  }
  if (min < 16) {
    throw errCode$1(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
  }
  if (max < min) {
    max = min;
  }
  if (avg < min) {
    avg = min;
  }
  const sizepow = Math.floor(Math.log2(avg));
  for await (const chunk of rabin(source, {
    min,
    max,
    bits: sizepow,
    window: options.window,
    polynomial: options.polynomial
  })) {
    yield chunk;
  }
}
async function* rabin(source, options) {
  const r2 = await src$1.create(options.bits, options.min, options.max, options.window);
  const buffers = new BufferList$1();
  for await (const chunk of source) {
    buffers.append(chunk);
    const sizes = r2.fingerprint(chunk);
    for (let i2 = 0; i2 < sizes.length; i2++) {
      const size2 = sizes[i2];
      const buf2 = buffers.slice(0, size2);
      buffers.consume(size2);
      yield buf2;
    }
  }
  if (buffers.length) {
    yield buffers.slice(0);
  }
}
async function* fixedSizeChunker(source, options) {
  let bl2 = new BufferList$1();
  let currentLength = 0;
  let emitted = false;
  const maxChunkSize = options.maxChunkSize;
  for await (const buffer2 of source) {
    bl2.append(buffer2);
    currentLength += buffer2.length;
    while (currentLength >= maxChunkSize) {
      yield bl2.slice(0, maxChunkSize);
      emitted = true;
      if (maxChunkSize === bl2.length) {
        bl2 = new BufferList$1();
        currentLength = 0;
      } else {
        const newBl = new BufferList$1();
        newBl.append(bl2.shallowSlice(maxChunkSize));
        bl2 = newBl;
        currentLength -= maxChunkSize;
      }
    }
  }
  if (!emitted || currentLength) {
    yield bl2.slice(0, currentLength);
  }
}
async function* validateChunks(source) {
  for await (const content of source) {
    if (content.length === void 0) {
      throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
    if (typeof content === "string" || content instanceof String) {
      yield fromString$1(content.toString());
    } else if (Array.isArray(content)) {
      yield Uint8Array.from(content);
    } else if (content instanceof Uint8Array) {
      yield content;
    } else {
      throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
  }
}
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return async function* () {
        yield content;
      }();
    } else if (isIterable(content)) {
      return async function* () {
        yield* content;
      }();
    } else if (isAsyncIterable(content)) {
      return content;
    }
  } catch {
    throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
async function* dagBuilder(source, blockstore, options) {
  for await (const entry of source) {
    if (entry.path) {
      if (entry.path.substring(0, 2) === "./") {
        options.wrapWithDirectory = true;
      }
      entry.path = entry.path.split("/").filter((path) => path && path !== ".").join("/");
    }
    if (entry.content) {
      let chunker;
      if (typeof options.chunker === "function") {
        chunker = options.chunker;
      } else if (options.chunker === "rabin") {
        chunker = rabinChunker;
      } else {
        chunker = fixedSizeChunker;
      }
      let chunkValidator;
      if (typeof options.chunkValidator === "function") {
        chunkValidator = options.chunkValidator;
      } else {
        chunkValidator = validateChunks;
      }
      const file = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode,
        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
      };
      yield () => fileBuilder(file, blockstore, options);
    } else if (entry.path) {
      const dir = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode
      };
      yield () => dirBuilder(dir, blockstore, options);
    } else {
      throw new Error("Import candidate must have content or path or both");
    }
  }
}
class Dir {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  async put(name2, value) {
  }
  get(name2) {
    return Promise.resolve(this);
  }
  async *eachChildSeries() {
  }
  async *flush(blockstore) {
  }
}
class DirFlat extends Dir {
  constructor(props, options) {
    super(props, options);
    this._children = {};
  }
  async put(name2, value) {
    this.cid = void 0;
    this.size = void 0;
    this._children[name2] = value;
  }
  get(name2) {
    return Promise.resolve(this._children[name2]);
  }
  childCount() {
    return Object.keys(this._children).length;
  }
  directChildrenCount() {
    return this.childCount();
  }
  onlyChild() {
    return this._children[Object.keys(this._children)[0]];
  }
  async *eachChildSeries() {
    const keys2 = Object.keys(this._children);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      yield {
        key,
        child: this._children[key]
      };
    }
  }
  async *flush(block2) {
    const children = Object.keys(this._children);
    const links2 = [];
    for (let i2 = 0; i2 < children.length; i2++) {
      let child = this._children[children[i2]];
      if (child instanceof Dir) {
        for await (const entry of child.flush(block2)) {
          child = entry;
          yield child;
        }
      }
      if (child.size != null && child.cid) {
        links2.push({
          Name: children[i2],
          Tsize: child.size,
          Hash: child.cid
        });
      }
    }
    const unixfs = new UnixFS({
      type: "directory",
      mtime: this.mtime,
      mode: this.mode
    });
    const node2 = {
      Data: unixfs.marshal(),
      Links: links2
    };
    const buffer2 = encode$2(prepare(node2));
    const cid = await persist(buffer2, block2, this.options);
    const size2 = buffer2.length + node2.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);
    this.cid = cid;
    this.size = size2;
    yield {
      cid,
      unixfs,
      path: this.path,
      size: size2
    };
  }
}
const BITS_PER_BYTE = 7;
var sparseArray = class SparseArray2 {
  constructor() {
    this._bitArrays = [];
    this._data = [];
    this._length = 0;
    this._changedLength = false;
    this._changedData = false;
  }
  set(index2, value) {
    let pos = this._internalPositionFor(index2, false);
    if (value === void 0) {
      if (pos !== -1) {
        this._unsetInternalPos(pos);
        this._unsetBit(index2);
        this._changedLength = true;
        this._changedData = true;
      }
    } else {
      let needsSort = false;
      if (pos === -1) {
        pos = this._data.length;
        this._setBit(index2);
        this._changedData = true;
      } else {
        needsSort = true;
      }
      this._setInternalPos(pos, index2, value, needsSort);
      this._changedLength = true;
    }
  }
  unset(index2) {
    this.set(index2, void 0);
  }
  get(index2) {
    this._sortData();
    const pos = this._internalPositionFor(index2, true);
    if (pos === -1) {
      return void 0;
    }
    return this._data[pos][1];
  }
  push(value) {
    this.set(this.length, value);
    return this.length;
  }
  get length() {
    this._sortData();
    if (this._changedLength) {
      const last2 = this._data[this._data.length - 1];
      this._length = last2 ? last2[0] + 1 : 0;
      this._changedLength = false;
    }
    return this._length;
  }
  forEach(iterator) {
    let i2 = 0;
    while (i2 < this.length) {
      iterator(this.get(i2), i2, this);
      i2++;
    }
  }
  map(iterator) {
    let i2 = 0;
    let mapped = new Array(this.length);
    while (i2 < this.length) {
      mapped[i2] = iterator(this.get(i2), i2, this);
      i2++;
    }
    return mapped;
  }
  reduce(reducer, initialValue) {
    let i2 = 0;
    let acc = initialValue;
    while (i2 < this.length) {
      const value = this.get(i2);
      acc = reducer(acc, value, i2);
      i2++;
    }
    return acc;
  }
  find(finder) {
    let i2 = 0, found, last2;
    while (i2 < this.length && !found) {
      last2 = this.get(i2);
      found = finder(last2);
      i2++;
    }
    return found ? last2 : void 0;
  }
  _internalPositionFor(index2, noCreate) {
    const bytePos = this._bytePosFor(index2, noCreate);
    if (bytePos >= this._bitArrays.length) {
      return -1;
    }
    const byte2 = this._bitArrays[bytePos];
    const bitPos = index2 - bytePos * BITS_PER_BYTE;
    const exists2 = (byte2 & 1 << bitPos) > 0;
    if (!exists2) {
      return -1;
    }
    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
    const mask = ~(4294967295 << bitPos + 1);
    const bytePopCount = popCount(byte2 & mask);
    const arrayPos = previousPopCount + bytePopCount - 1;
    return arrayPos;
  }
  _bytePosFor(index2, noCreate) {
    const bytePos = Math.floor(index2 / BITS_PER_BYTE);
    const targetLength = bytePos + 1;
    while (!noCreate && this._bitArrays.length < targetLength) {
      this._bitArrays.push(0);
    }
    return bytePos;
  }
  _setBit(index2) {
    const bytePos = this._bytePosFor(index2, false);
    this._bitArrays[bytePos] |= 1 << index2 - bytePos * BITS_PER_BYTE;
  }
  _unsetBit(index2) {
    const bytePos = this._bytePosFor(index2, false);
    this._bitArrays[bytePos] &= ~(1 << index2 - bytePos * BITS_PER_BYTE);
  }
  _setInternalPos(pos, index2, value, needsSort) {
    const data2 = this._data;
    const elem = [index2, value];
    if (needsSort) {
      this._sortData();
      data2[pos] = elem;
    } else {
      if (data2.length) {
        if (data2[data2.length - 1][0] >= index2) {
          data2.push(elem);
        } else if (data2[0][0] <= index2) {
          data2.unshift(elem);
        } else {
          const randomIndex = Math.round(data2.length / 2);
          this._data = data2.slice(0, randomIndex).concat(elem).concat(data2.slice(randomIndex));
        }
      } else {
        this._data.push(elem);
      }
      this._changedData = true;
      this._changedLength = true;
    }
  }
  _unsetInternalPos(pos) {
    this._data.splice(pos, 1);
  }
  _sortData() {
    if (this._changedData) {
      this._data.sort(sortInternal);
    }
    this._changedData = false;
  }
  bitField() {
    const bytes2 = [];
    let pendingBitsForResultingByte = 8;
    let pendingBitsForNewByte = 0;
    let resultingByte = 0;
    let newByte;
    const pending = this._bitArrays.slice();
    while (pending.length || pendingBitsForNewByte) {
      if (pendingBitsForNewByte === 0) {
        newByte = pending.shift();
        pendingBitsForNewByte = 7;
      }
      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
      const mask = ~(255 << usingBits);
      const masked = newByte & mask;
      resultingByte |= masked << 8 - pendingBitsForResultingByte;
      newByte = newByte >>> usingBits;
      pendingBitsForNewByte -= usingBits;
      pendingBitsForResultingByte -= usingBits;
      if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
        bytes2.push(resultingByte);
        resultingByte = 0;
        pendingBitsForResultingByte = 8;
      }
    }
    for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
      const value = bytes2[i2];
      if (value === 0) {
        bytes2.pop();
      } else {
        break;
      }
    }
    return bytes2;
  }
  compactArray() {
    this._sortData();
    return this._data.map(valueOnly);
  }
};
function popCountReduce(count, byte2) {
  return count + popCount(byte2);
}
function popCount(_v) {
  let v2 = _v;
  v2 = v2 - (v2 >> 1 & 1431655765);
  v2 = (v2 & 858993459) + (v2 >> 2 & 858993459);
  return (v2 + (v2 >> 4) & 252645135) * 16843009 >> 24;
}
function sortInternal(a2, b2) {
  return a2[0] - b2[0];
}
function valueOnly(elem) {
  return elem[1];
}
const index = /* @__PURE__ */ getDefaultExportFromCjs(sparseArray);
const sparseArray$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [sparseArray]);
const require$$0$4 = /* @__PURE__ */ getAugmentedNamespace(sparseArray$1);
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(fromString$2);
const SparseArray = require$$0$4;
const { fromString: uint8ArrayFromString } = require$$1$2;
let Bucket$1 = class Bucket2 {
  /**
   * @param {BucketOptions} options
   * @param {Bucket<T>} [parent]
   * @param {number} [posAtParent=0]
   */
  constructor(options, parent, posAtParent = 0) {
    this._options = options;
    this._popCount = 0;
    this._parent = parent;
    this._posAtParent = posAtParent;
    this._children = new SparseArray();
    this.key = null;
  }
  /**
   * @param {string} key
   * @param {T} value
   */
  async put(key, value) {
    const place = await this._findNewBucketAndPos(key);
    await place.bucket._putAt(place, key, value);
  }
  /**
   * @param {string} key
   */
  async get(key) {
    const child = await this._findChild(key);
    if (child) {
      return child.value;
    }
  }
  /**
   * @param {string} key
   */
  async del(key) {
    const place = await this._findPlace(key);
    const child = place.bucket._at(place.pos);
    if (child && child.key === key) {
      place.bucket._delAt(place.pos);
    }
  }
  /**
   * @returns {number}
   */
  leafCount() {
    const children = this._children.compactArray();
    return children.reduce((acc, child) => {
      if (child instanceof Bucket2) {
        return acc + child.leafCount();
      }
      return acc + 1;
    }, 0);
  }
  childrenCount() {
    return this._children.length;
  }
  onlyChild() {
    return this._children.get(0);
  }
  /**
   * @returns {Iterable<BucketChild<T>>}
   */
  *eachLeafSeries() {
    const children = this._children.compactArray();
    for (const child of children) {
      if (child instanceof Bucket2) {
        yield* child.eachLeafSeries();
      } else {
        yield child;
      }
    }
    return [];
  }
  /**
   * @param {(value: BucketChild<T>, index: number) => T} map
   * @param {(reduced: any) => any} reduce
   */
  serialize(map2, reduce2) {
    const acc = [];
    return reduce2(this._children.reduce((acc2, child, index2) => {
      if (child) {
        if (child instanceof Bucket2) {
          acc2.push(child.serialize(map2, reduce2));
        } else {
          acc2.push(map2(child, index2));
        }
      }
      return acc2;
    }, acc));
  }
  /**
   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap
   * @param {(reduced: any) => Promise<any>} asyncReduce
   */
  asyncTransform(asyncMap2, asyncReduce) {
    return asyncTransformBucket(this, asyncMap2, asyncReduce);
  }
  toJSON() {
    return this.serialize(mapNode, reduceNodes);
  }
  prettyPrint() {
    return JSON.stringify(this.toJSON(), null, "  ");
  }
  tableSize() {
    return Math.pow(2, this._options.bits);
  }
  /**
   * @param {string} key
   * @returns {Promise<BucketChild<T> | undefined>}
   */
  async _findChild(key) {
    const result = await this._findPlace(key);
    const child = result.bucket._at(result.pos);
    if (child instanceof Bucket2) {
      return void 0;
    }
    if (child && child.key === key) {
      return child;
    }
  }
  /**
   * @param {string | InfiniteHash} key
   * @returns {Promise<BucketPosition<T>>}
   */
  async _findPlace(key) {
    const hashValue = this._options.hash(typeof key === "string" ? uint8ArrayFromString(key) : key);
    const index2 = await hashValue.take(this._options.bits);
    const child = this._children.get(index2);
    if (child instanceof Bucket2) {
      return child._findPlace(hashValue);
    }
    return {
      bucket: this,
      pos: index2,
      hash: hashValue,
      existingChild: child
    };
  }
  /**
   * @param {string | InfiniteHash} key
   * @returns {Promise<BucketPosition<T>>}
   */
  async _findNewBucketAndPos(key) {
    const place = await this._findPlace(key);
    if (place.existingChild && place.existingChild.key !== key) {
      const bucket2 = new Bucket2(this._options, place.bucket, place.pos);
      place.bucket._putObjectAt(place.pos, bucket2);
      const newPlace = await bucket2._findPlace(place.existingChild.hash);
      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
      return bucket2._findNewBucketAndPos(place.hash);
    }
    return place;
  }
  /**
   * @param {BucketPosition<T>} place
   * @param {string} key
   * @param {T} value
   */
  _putAt(place, key, value) {
    this._putObjectAt(place.pos, {
      key,
      value,
      hash: place.hash
    });
  }
  /**
   * @param {number} pos
   * @param {Bucket<T> | BucketChild<T>} object
   */
  _putObjectAt(pos, object) {
    if (!this._children.get(pos)) {
      this._popCount++;
    }
    this._children.set(pos, object);
  }
  /**
   * @param {number} pos
   */
  _delAt(pos) {
    if (pos === -1) {
      throw new Error("Invalid position");
    }
    if (this._children.get(pos)) {
      this._popCount--;
    }
    this._children.unset(pos);
    this._level();
  }
  _level() {
    if (this._parent && this._popCount <= 1) {
      if (this._popCount === 1) {
        const onlyChild = this._children.find(exists);
        if (onlyChild && !(onlyChild instanceof Bucket2)) {
          const hash2 = onlyChild.hash;
          hash2.untake(this._options.bits);
          const place = {
            pos: this._posAtParent,
            hash: hash2,
            bucket: this._parent
          };
          this._parent._putAt(place, onlyChild.key, onlyChild.value);
        }
      } else {
        this._parent._delAt(this._posAtParent);
      }
    }
  }
  /**
   * @param {number} index
   * @returns {BucketChild<T> | Bucket<T> | undefined}
   */
  _at(index2) {
    return this._children.get(index2);
  }
};
function exists(o) {
  return Boolean(o);
}
function mapNode(node2, index2) {
  return node2.key;
}
function reduceNodes(nodes) {
  return nodes;
}
async function asyncTransformBucket(bucket2, asyncMap2, asyncReduce) {
  const output2 = [];
  for (const child of bucket2._children.compactArray()) {
    if (child instanceof Bucket$1) {
      await asyncTransformBucket(child, asyncMap2, asyncReduce);
    } else {
      const mappedChildren = await asyncMap2(child);
      output2.push({
        bitField: bucket2._children.bitField(),
        children: mappedChildren
      });
    }
  }
  return asyncReduce(output2);
}
var bucket = Bucket$1;
const bucket$1 = /* @__PURE__ */ getDefaultExportFromCjs(bucket);
const bucket$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: bucket$1
}, [bucket]);
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(bucket$2);
var consumableHash$2 = { exports: {} };
const START_MASKS = [
  255,
  254,
  252,
  248,
  240,
  224,
  192,
  128
];
const STOP_MASKS = [
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255
];
var consumableBuffer = class ConsumableBuffer2 {
  /**
   * @param {Uint8Array} value
   */
  constructor(value) {
    this._value = value;
    this._currentBytePos = value.length - 1;
    this._currentBitPos = 7;
  }
  availableBits() {
    return this._currentBitPos + 1 + this._currentBytePos * 8;
  }
  totalBits() {
    return this._value.length * 8;
  }
  /**
   * @param {number} bits
   */
  take(bits) {
    let pendingBits = bits;
    let result = 0;
    while (pendingBits && this._haveBits()) {
      const byte2 = this._value[this._currentBytePos];
      const availableBits = this._currentBitPos + 1;
      const taking = Math.min(availableBits, pendingBits);
      const value = byteBitsToInt(byte2, availableBits - taking, taking);
      result = (result << taking) + value;
      pendingBits -= taking;
      this._currentBitPos -= taking;
      if (this._currentBitPos < 0) {
        this._currentBitPos = 7;
        this._currentBytePos--;
      }
    }
    return result;
  }
  /**
   * @param {number} bits
   */
  untake(bits) {
    this._currentBitPos += bits;
    while (this._currentBitPos > 7) {
      this._currentBitPos -= 8;
      this._currentBytePos += 1;
    }
  }
  _haveBits() {
    return this._currentBytePos >= 0;
  }
};
function byteBitsToInt(byte2, start, length2) {
  const mask = maskFor(start, length2);
  return (byte2 & mask) >>> start;
}
function maskFor(start, length2) {
  return START_MASKS[start] & STOP_MASKS[Math.min(length2 + start - 1, 7)];
}
const consumableBuffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(consumableBuffer);
const consumableBuffer$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: consumableBuffer$1
}, [consumableBuffer]);
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(consumableBuffer$2);
const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(concat$5);
const ConsumableBuffer = require$$0$2;
const { concat: uint8ArrayConcat } = require$$1$1;
function wrapHash$1(hashFn) {
  function hashing(value) {
    if (value instanceof InfiniteHash) {
      return value;
    } else {
      return new InfiniteHash(value, hashFn);
    }
  }
  return hashing;
}
class InfiniteHash {
  /**
   *
   * @param {Uint8Array} value
   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn
   */
  constructor(value, hashFn) {
    if (!(value instanceof Uint8Array)) {
      throw new Error("can only hash Uint8Arrays");
    }
    this._value = value;
    this._hashFn = hashFn;
    this._depth = -1;
    this._availableBits = 0;
    this._currentBufferIndex = 0;
    this._buffers = [];
  }
  /**
   * @param {number} bits
   */
  async take(bits) {
    let pendingBits = bits;
    while (this._availableBits < pendingBits) {
      await this._produceMoreBits();
    }
    let result = 0;
    while (pendingBits > 0) {
      const hash2 = this._buffers[this._currentBufferIndex];
      const available = Math.min(hash2.availableBits(), pendingBits);
      const took = hash2.take(available);
      result = (result << available) + took;
      pendingBits -= available;
      this._availableBits -= available;
      if (hash2.availableBits() === 0) {
        this._currentBufferIndex++;
      }
    }
    return result;
  }
  /**
   * @param {number} bits
   */
  untake(bits) {
    let pendingBits = bits;
    while (pendingBits > 0) {
      const hash2 = this._buffers[this._currentBufferIndex];
      const availableForUntake = Math.min(hash2.totalBits() - hash2.availableBits(), pendingBits);
      hash2.untake(availableForUntake);
      pendingBits -= availableForUntake;
      this._availableBits += availableForUntake;
      if (this._currentBufferIndex > 0 && hash2.totalBits() === hash2.availableBits()) {
        this._depth--;
        this._currentBufferIndex--;
      }
    }
  }
  async _produceMoreBits() {
    this._depth++;
    const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;
    const hashValue = await this._hashFn(value);
    const buffer2 = new ConsumableBuffer(hashValue);
    this._buffers.push(buffer2);
    this._availableBits += buffer2.availableBits();
  }
}
consumableHash$2.exports = wrapHash$1;
var InfiniteHash_1 = consumableHash$2.exports.InfiniteHash = InfiniteHash;
var consumableHashExports = consumableHash$2.exports;
const consumableHash = /* @__PURE__ */ getDefaultExportFromCjs(consumableHashExports);
const consumableHash$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  InfiniteHash: InfiniteHash_1,
  default: consumableHash
}, [consumableHashExports]);
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(consumableHash$1);
const Bucket = require$$0$3;
const wrapHash = require$$1;
function createHAMT(options) {
  if (!options || !options.hashFn) {
    throw new Error("please define an options.hashFn");
  }
  const bucketOptions = {
    bits: options.bits || 8,
    hash: wrapHash(options.hashFn)
  };
  return new Bucket(bucketOptions);
}
var src = {
  createHAMT,
  Bucket
};
class DirSharded extends Dir {
  constructor(props, options) {
    super(props, options);
    this._bucket = src.createHAMT({
      hashFn: options.hamtHashFn,
      bits: options.hamtBucketBits
    });
  }
  async put(name2, value) {
    await this._bucket.put(name2, value);
  }
  get(name2) {
    return this._bucket.get(name2);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value
      };
    }
  }
  async *flush(blockstore) {
    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {
      yield {
        ...entry,
        path: this.path
      };
    }
  }
}
async function* flush(bucket2, blockstore, shardRoot, options) {
  const children = bucket2._children;
  const links2 = [];
  let childrenSize = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children.get(i2);
    if (!child) {
      continue;
    }
    const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof src.Bucket) {
      let shard;
      for await (const subShard of await flush(child, blockstore, null, options)) {
        shard = subShard;
      }
      if (!shard) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links2.push({
        Name: labelPrefix,
        Tsize: shard.size,
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links2.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value = child.value;
      if (!value.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size3 = value.size;
      links2.push({
        Name: label,
        Tsize: size3,
        Hash: value.cid
      });
      childrenSize += size3;
    }
  }
  const data2 = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data: data2,
    fanout: bucket2.tableSize(),
    hashType: options.hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node2 = {
    Data: dir.marshal(),
    Links: links2
  };
  const buffer2 = encode$2(prepare(node2));
  const cid = await persist(buffer2, blockstore, options);
  const size2 = buffer2.length + childrenSize;
  yield {
    cid,
    unixfs: dir,
    size: size2
  };
}
async function flatToShard(child, dir, threshold, options) {
  let newDir = dir;
  if (dir instanceof DirFlat && dir.directChildrenCount() >= threshold) {
    newDir = await convertToShard(dir, options);
  }
  const parent = newDir.parent;
  if (parent) {
    if (newDir !== dir) {
      if (child) {
        child.parent = newDir;
      }
      if (!newDir.parentKey) {
        throw new Error("No parent key found");
      }
      await parent.put(newDir.parentKey, newDir);
    }
    return flatToShard(newDir, parent, threshold, options);
  }
  return newDir;
}
async function convertToShard(oldDir, options) {
  const newDir = new DirSharded({
    root: oldDir.root,
    dir: true,
    parent: oldDir.parent,
    parentKey: oldDir.parentKey,
    path: oldDir.path,
    dirty: oldDir.dirty,
    flat: false,
    mtime: oldDir.mtime,
    mode: oldDir.mode
  }, options);
  for await (const { key, child } of oldDir.eachChildSeries()) {
    await newDir.put(key, child);
  }
  return newDir;
}
const toPathComponents = (path = "") => {
  return (path.trim().match(/([^\\/]|\\\/)+/g) || []).filter(Boolean);
};
async function addToTree(elem, tree2, options) {
  const pathElems = toPathComponents(elem.path || "");
  const lastIndex = pathElems.length - 1;
  let parent = tree2;
  let currentPath = "";
  for (let i2 = 0; i2 < pathElems.length; i2++) {
    const pathElem = pathElems[i2];
    currentPath += `${currentPath ? "/" : ""}${pathElem}`;
    const last2 = i2 === lastIndex;
    parent.dirty = true;
    parent.cid = void 0;
    parent.size = void 0;
    if (last2) {
      await parent.put(pathElem, elem);
      tree2 = await flatToShard(null, parent, options.shardSplitThreshold, options);
    } else {
      let dir = await parent.get(pathElem);
      if (!dir || !(dir instanceof Dir)) {
        dir = new DirFlat({
          root: false,
          dir: true,
          parent,
          parentKey: pathElem,
          path: currentPath,
          dirty: true,
          flat: true,
          mtime: dir && dir.unixfs && dir.unixfs.mtime,
          mode: dir && dir.unixfs && dir.unixfs.mode
        }, options);
      }
      await parent.put(pathElem, dir);
      parent = dir;
    }
  }
  return tree2;
}
async function* flushAndYield(tree2, blockstore) {
  if (!(tree2 instanceof Dir)) {
    if (tree2 && tree2.unixfs && tree2.unixfs.isDirectory()) {
      yield tree2;
    }
    return;
  }
  yield* tree2.flush(blockstore);
}
async function* treeBuilder(source, block2, options) {
  let tree2 = new DirFlat({
    root: true,
    dir: true,
    path: "",
    dirty: true,
    flat: true
  }, options);
  for await (const entry of source) {
    if (!entry) {
      continue;
    }
    tree2 = await addToTree(entry, tree2, options);
    if (!entry.unixfs || !entry.unixfs.isDirectory()) {
      yield entry;
    }
  }
  if (options.wrapWithDirectory) {
    yield* flushAndYield(tree2, block2);
  } else {
    for await (const unwrapped of tree2.eachChildSeries()) {
      if (!unwrapped) {
        continue;
      }
      yield* flushAndYield(unwrapped.child, block2);
    }
  }
}
async function* importer(source, blockstore, options = {}) {
  const opts = defaultOptions$1(options);
  let dagBuilder$1;
  if (typeof options.dagBuilder === "function") {
    dagBuilder$1 = options.dagBuilder;
  } else {
    dagBuilder$1 = dagBuilder;
  }
  let treeBuilder$1;
  if (typeof options.treeBuilder === "function") {
    treeBuilder$1 = options.treeBuilder;
  } else {
    treeBuilder$1 = treeBuilder;
  }
  let candidates;
  if (Symbol.asyncIterator in source || Symbol.iterator in source) {
    candidates = source;
  } else {
    candidates = [source];
  }
  for await (const entry of treeBuilder$1(parallelBatch$1(dagBuilder$1(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}
async function* browserReadableStreamToIt$1(stream2, options = {}) {
  const reader2 = stream2.getReader();
  try {
    while (true) {
      const result = await reader2.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options.preventCancel !== true) {
      reader2.cancel();
    }
    reader2.releaseLock();
  }
}
var browserReadablestreamToIt = browserReadableStreamToIt$1;
const browserStreamToIt = /* @__PURE__ */ getDefaultExportFromCjs(browserReadablestreamToIt);
const browserReadablestreamToIt$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: browserStreamToIt
}, [browserReadablestreamToIt]);
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(browserReadablestreamToIt$1);
const browserReadableStreamToIt = require$$0$1;
function blobToIt(blob) {
  if (typeof blob.stream === "function") {
    return browserReadableStreamToIt(blob.stream());
  }
  return browserReadableStreamToIt(new Response(blob).body);
}
var blobToIt_1 = blobToIt;
const blobToIt$1 = /* @__PURE__ */ getDefaultExportFromCjs(blobToIt_1);
function peekableIterator(iterable) {
  const [iterator, symbol2] = iterable[Symbol.asyncIterator] ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol2]() {
      return this;
    }
  };
}
var itPeekable = peekableIterator;
const itPeekable$1 = /* @__PURE__ */ getDefaultExportFromCjs(itPeekable);
const map = async function* (source, func) {
  for await (const val of source) {
    yield func(val);
  }
};
var itMap = map;
const map$1 = /* @__PURE__ */ getDefaultExportFromCjs(itMap);
function isBytes$1(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob$2(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
const isReadableStream = (value) => value && typeof value.getReader === "function";
async function* toAsyncIterable(thing) {
  yield thing;
}
async function normaliseContent(input) {
  if (isBytes$1(input)) {
    return toAsyncIterable(toBytes(input));
  }
  if (typeof input === "string" || input instanceof String) {
    return toAsyncIterable(toBytes(input.toString()));
  }
  if (isBlob$2(input)) {
    return blobToIt$1(input);
  }
  if (isReadableStream(input)) {
    input = browserStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = itPeekable$1(input);
    const { value, done } = await peekable.peek();
    if (done) {
      return toAsyncIterable(new Uint8Array(0));
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return toAsyncIterable(Uint8Array.from(await all$1(peekable)));
    }
    if (isBytes$1(value) || typeof value === "string" || value instanceof String) {
      return map$1(peekable, toBytes);
    }
  }
  throw errCode$1(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
function toBytes(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString$1(chunk.toString());
}
async function* normaliseCandidateSingle(input, normaliseContent2) {
  if (input === null || input === void 0) {
    throw errCode$1(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input === "string" || input instanceof String) {
    yield toFileObject$1(input.toString(), normaliseContent2);
    return;
  }
  if (isBytes$1(input) || isBlob$2(input)) {
    yield toFileObject$1(input, normaliseContent2);
    return;
  }
  if (isReadableStream(input)) {
    input = browserStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = itPeekable$1(input);
    const { value, done } = await peekable.peek();
    if (done) {
      yield { content: [] };
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value) || isBytes$1(value) || typeof value === "string" || value instanceof String) {
      yield toFileObject$1(peekable, normaliseContent2);
      return;
    }
    throw errCode$1(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isFileObject(input)) {
    yield toFileObject$1(input, normaliseContent2);
    return;
  }
  throw errCode$1(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject$1(input, normaliseContent2) {
  const { path, mode: mode2, mtime, content } = input;
  const file = {
    path: path || "",
    mode: parseMode(mode2),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent2(content);
  } else if (!path) {
    file.content = await normaliseContent2(input);
  }
  return file;
}
function normaliseInput$1(input) {
  return normaliseCandidateSingle(input, normaliseContent);
}
async function* normaliseCandidateMultiple(input, normaliseContent2) {
  if (typeof input === "string" || input instanceof String || isBytes$1(input) || isBlob$2(input) || input._readableState) {
    throw errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isReadableStream(input)) {
    input = browserStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = itPeekable$1(input);
    const { value, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      throw errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (value._readableState) {
      yield* map$1(peekable, (value2) => toFileObject({ content: value2 }, normaliseContent2));
      return;
    }
    if (isBytes$1(value)) {
      yield toFileObject({ content: peekable }, normaliseContent2);
      return;
    }
    if (isFileObject(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value) || isBlob$2(value)) {
      yield* map$1(peekable, (value2) => toFileObject(value2, normaliseContent2));
      return;
    }
  }
  if (isFileObject(input)) {
    throw errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  throw errCode$1(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input, normaliseContent2) {
  const { path, mode: mode2, mtime, content } = input;
  const file = {
    path: path || "",
    mode: parseMode(mode2),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent2(content);
  } else if (!path) {
    file.content = await normaliseContent2(input);
  }
  return file;
}
function normaliseInput(input) {
  return normaliseCandidateMultiple(input, normaliseContent);
}
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob$1(obj) {
  return Boolean(obj.constructor) && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isSingle(input) {
  return typeof input === "string" || input instanceof String || isBytes(input) || isBlob$1(input) || "_readableState" in input;
}
function getNormaliser(input) {
  if (isSingle(input)) {
    return normaliseInput$1(input);
  } else {
    return normaliseInput(input);
  }
}
const drain = async (source) => {
  for await (const _2 of source) {
  }
};
var itDrain = drain;
const drain$1 = /* @__PURE__ */ getDefaultExportFromCjs(itDrain);
const filter = async function* (source, fn) {
  for await (const entry of source) {
    if (await fn(entry)) {
      yield entry;
    }
  }
};
var itFilter = filter;
const filter$1 = /* @__PURE__ */ getDefaultExportFromCjs(itFilter);
const take = async function* (source, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
};
var itTake = take;
const take$1 = /* @__PURE__ */ getDefaultExportFromCjs(itTake);
const sortAll = (iterable, sorter) => {
  return async function* () {
    const values = await all$1(iterable);
    yield* values.sort(sorter);
  }();
};
class BaseBlockstore {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield {
        key,
        value
      };
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({
          key,
          value
        });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await drain$1(this.putMany(puts, options));
        puts = [];
        await drain$1(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q2, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q2, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q2, options) {
    let it = this._all(q2, options);
    if (q2.prefix != null) {
      it = filter$1(it, (e2) => e2.key.toString().startsWith(q2.prefix || ""));
    }
    if (Array.isArray(q2.filters)) {
      it = q2.filters.reduce((it2, f2) => filter$1(it2, f2), it);
    }
    if (Array.isArray(q2.orders)) {
      it = q2.orders.reduce((it2, f2) => sortAll(it2, f2), it);
    }
    if (q2.offset != null) {
      let i2 = 0;
      it = filter$1(it, () => i2++ >= (q2.offset || 0));
    }
    if (q2.limit != null) {
      it = take$1(it, q2.limit);
    }
    return it;
  }
  queryKeys(q2, options) {
    let it = this._allKeys(q2, options);
    if (q2.prefix != null) {
      it = filter$1(it, (cid) => cid.toString().startsWith(q2.prefix || ""));
    }
    if (Array.isArray(q2.filters)) {
      it = q2.filters.reduce((it2, f2) => filter$1(it2, f2), it);
    }
    if (Array.isArray(q2.orders)) {
      it = q2.orders.reduce((it2, f2) => sortAll(it2, f2), it);
    }
    if (q2.offset != null) {
      let i2 = 0;
      it = filter$1(it, () => i2++ >= q2.offset);
    }
    if (q2.limit != null) {
      it = take$1(it, q2.limit);
    }
    return it;
  }
}
class MemoryBlockStore extends BaseBlockstore {
  constructor() {
    super();
    this.store = /* @__PURE__ */ new Map();
  }
  async *blocks() {
    for (const [cidStr, bytes2] of this.store.entries()) {
      yield { cid: CID.parse(cidStr), bytes: bytes2 };
    }
  }
  put(cid, bytes2) {
    this.store.set(cid.toString(), bytes2);
    return Promise.resolve();
  }
  get(cid) {
    const bytes2 = this.store.get(cid.toString());
    if (!bytes2) {
      throw new Error(`block with cid ${cid.toString()} no found`);
    }
    return Promise.resolve(bytes2);
  }
  has(cid) {
    return Promise.resolve(this.store.has(cid.toString()));
  }
  close() {
    this.store.clear();
    return Promise.resolve();
  }
}
const unixfsImporterOptionsDefault = {
  cidVersion: 1,
  chunker: "fixed",
  maxChunkSize: 262144,
  hasher: sha256$5,
  rawLeaves: true,
  wrapWithDirectory: true,
  maxChildrenPerNode: 174
};
async function pack({ input, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves }) {
  if (!input || Array.isArray(input) && !input.length) {
    throw new Error("missing input file(s)");
  }
  const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();
  const rootEntry = await last$1(pipe$1(getNormaliser(input), (source) => importer(source, blockstore, {
    ...unixfsImporterOptionsDefault,
    hasher: hasher || unixfsImporterOptionsDefault.hasher,
    maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,
    maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,
    wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,
    rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves
  })));
  if (!rootEntry || !rootEntry.cid) {
    throw new Error("given input could not be parsed correctly");
  }
  const root2 = rootEntry.cid;
  const { writer: writer2, out: carOut } = await CarWriter.create([root2]);
  const carOutIter = carOut[Symbol.asyncIterator]();
  let writingPromise;
  const writeAll = async () => {
    for await (const block2 of blockstore.blocks()) {
      await writer2.put(block2);
    }
    await writer2.close();
    if (!userBlockstore) {
      await blockstore.close();
    }
  };
  const out = {
    [Symbol.asyncIterator]() {
      if (writingPromise != null) {
        throw new Error("Multiple iterator not supported");
      }
      writingPromise = writeAll();
      return {
        async next() {
          const result = await carOutIter.next();
          if (result.done) {
            await writingPromise;
          }
          return result;
        }
      };
    }
  };
  return { root: root2, out };
}
var throttledQueue$1 = { exports: {} };
(function(module2, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function throttledQueue2(maxRequestsPerInterval, interval, evenlySpaced) {
    if (evenlySpaced === void 0) {
      evenlySpaced = false;
    }
    if (evenlySpaced) {
      interval = interval / maxRequestsPerInterval;
      maxRequestsPerInterval = 1;
    }
    var queue = [];
    var lastIntervalStart = 0;
    var numRequestsPerInterval = 0;
    var timeout;
    var dequeue = function() {
      var intervalEnd = lastIntervalStart + interval;
      var now = Date.now();
      if (now < intervalEnd) {
        timeout !== void 0 && clearTimeout(timeout);
        timeout = setTimeout(dequeue, intervalEnd - now);
        return;
      }
      lastIntervalStart = now;
      numRequestsPerInterval = 0;
      for (var _i = 0, _a2 = queue.splice(0, maxRequestsPerInterval); _i < _a2.length; _i++) {
        var callback = _a2[_i];
        numRequestsPerInterval++;
        void callback();
      }
      if (queue.length) {
        timeout = setTimeout(dequeue, interval);
      } else {
        timeout = void 0;
      }
    };
    return function(fn) {
      return new Promise(function(resolve, reject) {
        var callback = function() {
          return Promise.resolve().then(fn).then(resolve).catch(reject);
        };
        var now = Date.now();
        if (timeout === void 0 && now - lastIntervalStart > interval) {
          lastIntervalStart = now;
          numRequestsPerInterval = 0;
        }
        if (numRequestsPerInterval++ < maxRequestsPerInterval) {
          void callback();
        } else {
          queue.push(callback);
          if (timeout === void 0) {
            timeout = setTimeout(dequeue, lastIntervalStart + interval - now);
          }
        }
      });
    };
  }
  module2.exports = throttledQueue2;
  exports.default = throttledQueue2;
})(throttledQueue$1, throttledQueue$1.exports);
var throttledQueueExports = throttledQueue$1.exports;
const throttledQueue = /* @__PURE__ */ getDefaultExportFromCjs(throttledQueueExports);
const CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token$1(Type.tag, CID_CBOR_TAG),
    new Token$1(Type.bytes, bytes2)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
const decodeOptions = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
const name = "dag-cbor";
const code = 113;
const encode = (node2) => encode$6(node2, encodeOptions);
const decode = (data2) => decode$5(data2, decodeOptions);
const dagCbor = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code,
  decode,
  encode,
  name
}, Symbol.toStringTag, { value: "Module" }));
const fetch$1 = globalThis.fetch;
const Blob$1 = globalThis.Blob;
const Blockstore = MemoryBlockStore;
const GATEWAY = new URL("https://nftstorage.link/");
const toGatewayURL = (url, options = {}) => {
  const gateway2 = options.gateway || GATEWAY;
  url = new URL(String(url));
  return url.protocol === "ipfs:" ? new URL(`/ipfs/${url.href.slice("ipfs://".length)}`, gateway2) : url;
};
class BlockstoreCarReader {
  /**
   * @param {number} version
   * @param {CID[]} roots
   * @param {import('ipfs-car/blockstore').Blockstore} blockstore
   */
  constructor(version2, roots2, blockstore) {
    this._version = version2;
    this._roots = roots2;
    this._blockstore = blockstore;
  }
  get version() {
    return this._version;
  }
  get blockstore() {
    return this._blockstore;
  }
  async getRoots() {
    return this._roots;
  }
  /**
   * @param {CID} cid
   */
  has(cid) {
    return this._blockstore.has(cid);
  }
  /**
   * @param {CID} cid
   */
  async get(cid) {
    const bytes2 = await this._blockstore.get(cid);
    return { cid, bytes: bytes2 };
  }
  blocks() {
    return this._blockstore.blocks();
  }
  async *cids() {
    for await (const b2 of this.blocks()) {
      yield b2.cid;
    }
  }
}
class Token {
  /**
   * @param {import('./lib/interface.js').CIDString} ipnft
   * @param {import('./lib/interface.js').EncodedURL} url
   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data
   */
  constructor(ipnft, url, data2) {
    this.ipnft = ipnft;
    this.url = url;
    this.data = data2;
    Object.defineProperties(this, {
      ipnft: { enumerable: true, writable: false },
      url: { enumerable: true, writable: false },
      data: { enumerable: false, writable: false }
    });
  }
  /**
   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}
   */
  embed() {
    return Token.embed(this);
  }
  /**
   * @template {TokenInput} T
   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token
   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}
   */
  static embed({ data: data2 }) {
    return embed(data2, { gateway: GATEWAY });
  }
  /**
   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new
   * Token instance from it. Where values are discovered `Blob` (or `File`)
   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`
   * prefixed CID with an optional path).
   *
   * @example
   * ```js
   * const cat = new File(['...'], 'cat.png')
   * const kitty = new File(['...'], 'kitty.png')
   * const { token, car } = await Token.encode({
   *   name: 'hello'
   *   image: cat
   *   properties: {
   *     extra: {
   *       image: kitty
   *     }
   *   }
   * })
   * ```
   *
   * @template {TokenInput} T
   * @param {T} input
   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}
   */
  static async encode(input) {
    const blockstore = new Blockstore();
    const [blobs, meta] = mapTokenInputBlobs(input);
    const data2 = JSON.parse(JSON.stringify(meta));
    const dag = JSON.parse(JSON.stringify(meta));
    for (const [dotPath, blob] of blobs.entries()) {
      const name2 = blob.name || "blob";
      let content;
      if (parseInt(globalThis.process?.versions?.node) > 18) {
        content = new Uint8Array(await blob.arrayBuffer());
      } else {
        content = blob.stream();
      }
      const { root: cid } = await pack({
        input: [{ path: name2, content }],
        blockstore,
        wrapWithDirectory: true
      });
      const href = new URL(`ipfs://${cid}/${name2}`);
      const path = dotPath.split(".");
      setIn(data2, path, href);
      setIn(dag, path, cid);
    }
    const { root: metadataJsonCid } = await pack({
      input: [{ path: "metadata.json", content: JSON.stringify(data2) }],
      blockstore,
      wrapWithDirectory: false
    });
    const block2 = await encode$4({
      value: {
        ...dag,
        "metadata.json": metadataJsonCid,
        type: "nft"
      },
      codec: dagCbor,
      hasher: sha256$5
    });
    await blockstore.put(block2.cid, block2.bytes);
    return {
      cid: block2.cid,
      token: new Token(
        block2.cid.toString(),
        `ipfs://${block2.cid}/metadata.json`,
        data2
      ),
      car: new BlockstoreCarReader(1, [block2.cid], blockstore)
    };
  }
}
const embed = (input, options) => mapWith(input, isURL, embedURL, options);
const isURL = (value) => value instanceof URL;
const embedURL = (context, url) => [context, toGatewayURL(url, context)];
const isObject = (value) => typeof value === "object" && value != null;
const encodeBlob = (data2, blob, path) => {
  data2.set(path.join("."), blob);
  return [data2, void 0];
};
const isBlob = (value) => value instanceof Blob$1;
const mapTokenInputBlobs = (input) => {
  return mapValueWith(input, isBlob, encodeBlob, /* @__PURE__ */ new Map(), []);
};
const mapWith = (input, p2, f2, state) => {
  const [, output2] = mapValueWith(input, p2, f2, state, []);
  return output2;
};
const mapValueWith = (input, p2, f2, state, path) => p2(input, state, path) ? f2(state, input, path) : Array.isArray(input) ? mapArrayWith(input, p2, f2, state, path) : isObject(input) ? mapObjectWith(input, p2, f2, state, path) : [
  state,
  /** @type {any} */
  input
];
const mapObjectWith = (input, p2, f2, init, path) => {
  let state = init;
  const output2 = (
    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */
    {}
  );
  for (const [key, value] of Object.entries(input)) {
    const [next, out] = mapValueWith(value, p2, f2, state, [...path, key]);
    output2[key] = out;
    state = next;
  }
  return [state, output2];
};
const mapArrayWith = (input, p2, f2, init, path) => {
  const output2 = (
    /** @type {unknown[]} */
    []
  );
  let state = init;
  for (const [index2, element] of input.entries()) {
    const [next, out] = mapValueWith(element, p2, f2, state, [...path, index2]);
    output2[index2] = out;
    state = next;
  }
  return [
    state,
    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */
    output2
  ];
};
const setIn = (object, path, value) => {
  const n2 = path.length - 1;
  let target = object;
  for (let [index2, key] of path.entries()) {
    if (index2 === n2) {
      target[key] = value;
    } else {
      target = target[key];
    }
  }
};
const MAX_STORE_RETRIES = 5;
const MAX_CONCURRENT_UPLOADS = 3;
const MAX_CHUNK_SIZE = 1024 * 1024 * 50;
const RATE_LIMIT_REQUESTS = 30;
const RATE_LIMIT_PERIOD = 10 * 1e3;
function createRateLimiter() {
  const throttle2 = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD);
  return () => throttle2(() => {
  });
}
const globalRateLimiter = createRateLimiter();
class NFTStorage {
  /**
   * Constructs a client bound to the given `options.token` and
   * `options.endpoint`.
   *
   * @example
   * ```js
   * import { NFTStorage, File, Blob } from "nft.storage"
   * const client = new NFTStorage({ token: API_TOKEN })
   *
   * const cid = await client.storeBlob(new Blob(['hello world']))
   * ```
   * Optionally you could pass an alternative API endpoint (e.g. for testing)
   * @example
   * ```js
   * import { NFTStorage } from "nft.storage"
   * const client = new NFTStorage({
   *   token: API_TOKEN
   *   endpoint: new URL('http://localhost:8080/')
   * })
   * ```
   *
   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options
   */
  constructor({
    token: token2,
    did,
    endpoint: endpoint2 = new URL("https://api.nft.storage"),
    rateLimiter
  }) {
    this.token = token2;
    this.endpoint = endpoint2;
    this.rateLimiter = rateLimiter || createRateLimiter();
    this.did = did;
  }
  /**
   * @hidden
   * @param {object} options
   * @param {string} options.token
   * @param {string} [options.did]
   */
  static auth({ token: token2, did }) {
    if (!token2)
      throw new Error("missing token");
    return {
      Authorization: `Bearer ${token2}`,
      "X-Client": "nft.storage/js",
      ...did ? { "x-agent-did": did } : {}
    };
  }
  /**
   * Stores a single file and returns its CID.
   *
   * @param {Service} service
   * @param {Blob} blob
   * @param {RequestOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static async storeBlob(service2, blob, options) {
    const blockstore = new Blockstore();
    let cidString;
    try {
      const { cid, car } = await NFTStorage.encodeBlob(blob, { blockstore });
      await NFTStorage.storeCar(service2, car, options);
      cidString = cid.toString();
    } finally {
      await blockstore.close();
    }
    return cidString;
  }
  /**
   * Stores a CAR file and returns its root CID.
   *
   * @param {Service} service
   * @param {Blob|CarReader} car
   * @param {import('./lib/interface.js').CarStorerOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static async storeCar({ endpoint: endpoint2, rateLimiter = globalRateLimiter, ...token2 }, car, { onStoredChunk, maxRetries, maxChunkSize, decoders, signal } = {}) {
    const url = new URL("upload/", endpoint2);
    const headers = {
      ...NFTStorage.auth(token2),
      "Content-Type": "application/car"
    };
    const targetSize = maxChunkSize || MAX_CHUNK_SIZE;
    const splitter = car instanceof Blob$1 ? await TreewalkCarSplitter.fromBlob(car, targetSize, { decoders }) : new TreewalkCarSplitter(car, targetSize, { decoders });
    const upload = transform(
      MAX_CONCURRENT_UPLOADS,
      async function(car2) {
        const carParts = [];
        for await (const part of car2) {
          carParts.push(part);
        }
        const carFile = new Blob$1(carParts, { type: "application/car" });
        let body = carFile;
        if (parseInt(globalThis.process?.versions?.node) > 18) {
          body = await body.arrayBuffer();
        }
        const cid = await pRetry$1(
          async () => {
            await rateLimiter();
            let response;
            try {
              response = await fetch$1(url.toString(), {
                method: "POST",
                headers,
                body,
                signal
              });
            } catch (err) {
              throw signal && signal.aborted ? new AbortError_1(err) : err;
            }
            if (response.status === 429) {
              throw new Error("rate limited");
            }
            const result = await response.json();
            if (!result.ok) {
              if (response.status === 401) {
                throw new AbortError_1(result.error.message);
              }
              throw new Error(result.error.message);
            }
            return result.value.cid;
          },
          {
            retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries
          }
        );
        onStoredChunk && onStoredChunk(carFile.size);
        return cid;
      }
    );
    let root2;
    for await (const cid of upload(splitter.cars())) {
      root2 = cid;
    }
    return (
      /** @type {CIDString} */
      root2
    );
  }
  /**
   * Stores a directory of files and returns a CID. Provided files **MUST**
   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,
   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.
   *
   * @param {Service} service
   * @param {FilesSource} filesSource
   * @param {RequestOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static async storeDirectory(service2, filesSource, options) {
    const blockstore = new Blockstore();
    let cidString;
    try {
      const { cid, car } = await NFTStorage.encodeDirectory(filesSource, {
        blockstore
      });
      await NFTStorage.storeCar(service2, car, options);
      cidString = cid.toString();
    } finally {
      await blockstore.close();
    }
    return cidString;
  }
  /**
   * Stores the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The
   * `token.image` must be either a `File` or a `Blob` instance, which will be
   * stored and the corresponding content address URL will be saved in the
   * metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {Service} service
   * @param {T} metadata
   * @param {RequestOptions} [options]
   * @returns {Promise<TokenType<T>>}
   */
  static async store(service2, metadata, options) {
    const { token: token2, car } = await NFTStorage.encodeNFT(metadata);
    await NFTStorage.storeCar(service2, car, options);
    return token2;
  }
  /**
   * Returns current status of the stored NFT by its CID. Note the NFT must
   * have previously been stored by this account.
   *
   * @param {Service} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<import('./lib/interface.js').StatusResult>}
   */
  static async status({ endpoint: endpoint2, rateLimiter = globalRateLimiter, ...token2 }, cid, options) {
    const url = new URL(`${cid}/`, endpoint2);
    await rateLimiter();
    const response = await fetch$1(url.toString(), {
      method: "GET",
      headers: NFTStorage.auth(token2),
      signal: options && options.signal
    });
    if (response.status === 429) {
      throw new Error("rate limited");
    }
    const result = await response.json();
    if (result.ok) {
      return {
        cid: result.value.cid,
        deals: decodeDeals(result.value.deals),
        size: result.value.size,
        pin: decodePin(result.value.pin),
        created: new Date(result.value.created)
      };
    } else {
      throw new Error(result.error.message);
    }
  }
  /**
   * Check if a CID of an NFT is being stored by NFT.Storage.
   *
   * @param {import('./lib/interface.js').PublicService} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<import('./lib/interface.js').CheckResult>}
   */
  static async check({ endpoint: endpoint2, rateLimiter = globalRateLimiter }, cid, options) {
    const url = new URL(`check/${cid}/`, endpoint2);
    await rateLimiter();
    const response = await fetch$1(url.toString(), {
      signal: options && options.signal
    });
    if (response.status === 429) {
      throw new Error("rate limited");
    }
    const result = await response.json();
    if (result.ok) {
      return {
        cid: result.value.cid,
        deals: decodeDeals(result.value.deals),
        pin: result.value.pin
      };
    } else {
      throw new Error(result.error.message);
    }
  }
  /**
   * Removes stored content by its CID from this account. Please note that
   * even if content is removed from the service other nodes that have
   * replicated it might still continue providing it.
   *
   * @param {Service} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<void>}
   */
  static async delete({ endpoint: endpoint2, rateLimiter = globalRateLimiter, ...token2 }, cid, options) {
    const url = new URL(`${cid}/`, endpoint2);
    await rateLimiter();
    const response = await fetch$1(url.toString(), {
      method: "DELETE",
      headers: NFTStorage.auth(token2),
      signal: options && options.signal
    });
    if (response.status === 429) {
      throw new Error("rate limited");
    }
    const result = await response.json();
    if (!result.ok) {
      throw new Error(result.error.message);
    }
  }
  /**
   * Encodes the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a
   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,
   * which will be stored and the corresponding content address URL will be
   * saved in the metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @example
   * ```js
   * const { token, car } = await NFTStorage.encodeNFT({
   *   name: 'nft.storage store test',
   *   description: 'Test ERC-1155 compatible metadata.',
   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),
   *   properties: {
   *     custom: 'Custom data can appear here, files are auto uploaded.',
   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),
   *   }
   * })
   *
   * console.log('IPFS URL for the metadata:', token.url)
   * console.log('metadata.json contents:\n', token.data)
   * console.log('metadata.json with IPFS gateway URLs:\n', token.embed())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {T} input
   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}
   */
  static async encodeNFT(input) {
    validateERC1155(input);
    return Token.encode(input);
  }
  /**
   * Encodes a single file to a CAR file and also returns its root CID.
   *
   * @example
   * ```js
   * const content = new Blob(['hello world'])
   * const { cid, car } = await NFTStorage.encodeBlob(content)
   *
   * // Root CID of the file
   * console.log(cid.toString())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @param {Blob} blob
   * @param {object} [options]
   * @param {BlockstoreI} [options.blockstore]
   * @returns {Promise<{ cid: CID, car: CarReader }>}
   */
  static async encodeBlob(blob, { blockstore } = {}) {
    if (blob.size === 0) {
      throw new Error("Content size is 0, make sure to provide some content");
    }
    return packCar([toImportCandidate("blob", blob)], {
      blockstore,
      wrapWithDirectory: false
    });
  }
  /**
   * Encodes a directory of files to a CAR file and also returns the root CID.
   * Provided files **MUST** be within the same directory, otherwise error is
   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,
   * `bla/baz.json` is not.
   *
   * @example
   * ```js
   * const { cid, car } = await NFTStorage.encodeDirectory([
   *   new File(['hello world'], 'hello.txt'),
   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')
   * ])
   *
   * // Root CID of the directory
   * console.log(cid.toString())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @param {FilesSource} files
   * @param {object} [options]
   * @param {BlockstoreI} [options.blockstore]
   * @returns {Promise<{ cid: CID, car: CarReader }>}
   */
  static async encodeDirectory(files, { blockstore } = {}) {
    let size2 = 0;
    const input = pipe$1(files, async function* (files2) {
      for await (const file of files2) {
        yield toImportCandidate(file.name, file);
        size2 += file.size;
      }
    });
    const packed = await packCar(input, {
      blockstore,
      wrapWithDirectory: true
    });
    if (size2 === 0) {
      throw new Error(
        "Total size of files should exceed 0, make sure to provide some content"
      );
    }
    return packed;
  }
  // Just a sugar so you don't have to pass around endpoint and token around.
  /**
   * Stores a single file and returns the corresponding Content Identifier (CID).
   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)
   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note
   * that no file name or file metadata is retained.
   *
   * @example
   * ```js
   * const content = new Blob(['hello world'])
   * const cid = await client.storeBlob(content)
   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'
   * ```
   *
   * @param {Blob} blob
   * @param {RequestOptions} [options]
   */
  storeBlob(blob, options) {
    return NFTStorage.storeBlob(this, blob, options);
  }
  /**
   * Stores files encoded as a single [Content Addressed Archive
   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).
   *
   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)
   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).
   *
   * Returns the corresponding Content Identifier (CID).
   *
   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more
   * details on packing a CAR file.
   *
   * @example
   * ```js
   * import { pack } from 'ipfs-car/pack'
   * import { CarReader } from '@ipld/car'
   * const { out, root } = await pack({
   *  input: fs.createReadStream('pinpie.pdf')
   * })
   * const expectedCid = root.toString()
   * const carReader = await CarReader.fromIterable(out)
   * const cid = await storage.storeCar(carReader)
   * console.assert(cid === expectedCid)
   * ```
   *
   * @example
   * ```
   * import { packToBlob } from 'ipfs-car/pack/blob'
   * const data = 'Hello world'
   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })
   * const expectedCid = root.toString()
   * const cid = await client.storeCar(car)
   * console.assert(cid === expectedCid)
   * ```
   * @param {Blob|CarReader} car
   * @param {import('./lib/interface.js').CarStorerOptions} [options]
   */
  storeCar(car, options) {
    return NFTStorage.storeCar(this, car, options);
  }
  /**
   * Stores a directory of files and returns a CID for the directory.
   *
   * @example
   * ```js
   * const cid = await client.storeDirectory([
   *   new File(['hello world'], 'hello.txt'),
   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')
   * ])
   * cid //>
   * ```
   *
   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)
   * instance as well, in which case directory structure will be retained.
   *
   * @param {FilesSource} files
   * @param {RequestOptions} [options]
   */
  storeDirectory(files, options) {
    return NFTStorage.storeDirectory(this, files, options);
  }
  /**
   * Returns current status of the stored NFT by its CID. Note the NFT must
   * have previously been stored by this account.
   *
   * @example
   * ```js
   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  status(cid, options) {
    return NFTStorage.status(this, cid, options);
  }
  /**
   * Removes stored content by its CID from the service.
   *
   * > Please note that even if content is removed from the service other nodes
   * that have replicated it might still continue providing it.
   *
   * @example
   * ```js
   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  delete(cid, options) {
    return NFTStorage.delete(this, cid, options);
  }
  /**
   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT
   * was not found.
   *
   * @example
   * ```js
   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  check(cid, options) {
    return NFTStorage.check(this, cid, options);
  }
  /**
   * Stores the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in
   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The
   * `token.image` must be either a `File` or a `Blob` instance, which will be
   * stored and the corresponding content address URL will be saved in the
   * metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @example
   * ```js
   * const metadata = await client.store({
   *   name: 'nft.storage store test',
   *   description: 'Test ERC-1155 compatible metadata.',
   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),
   *   properties: {
   *     custom: 'Custom data can appear here, files are auto uploaded.',
   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),
   *   }
   * })
   *
   * console.log('IPFS URL for the metadata:', metadata.url)
   * console.log('metadata.json contents:\n', metadata.data)
   * console.log('metadata.json with IPFS gateway URLs:\n', metadata.embed())
   * ```
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {T} token
   * @param {RequestOptions} [options]
   */
  store(token2, options) {
    return NFTStorage.store(this, token2, options);
  }
}
const validateERC1155 = ({ name: name2, description: description2, image, decimals }) => {
  if (typeof name2 !== "string") {
    throw new TypeError(
      "string property `name` identifying the asset is required"
    );
  }
  if (typeof description2 !== "string") {
    throw new TypeError(
      "string property `description` describing asset is required"
    );
  }
  if (!(image instanceof Blob$1)) {
    throw new TypeError("property `image` must be a Blob or File object");
  } else if (!image.type.startsWith("image/")) {
    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.

For better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \`properties: { video: file }\` and using 'image' field for storing a preview image for it instead.

For more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`);
  }
  if (typeof decimals !== "undefined" && typeof decimals !== "number") {
    throw new TypeError("property `decimals` must be an integer value");
  }
};
const packCar = async (input, { blockstore, wrapWithDirectory } = {}) => {
  blockstore = blockstore || new Blockstore();
  const { root: cid } = await pack({ input, blockstore, wrapWithDirectory });
  const car = new BlockstoreCarReader(1, [cid], blockstore);
  return { cid, car };
};
const decodeDeals = (deals) => deals.map((deal) => {
  const { dealActivation, dealExpiration, lastChanged } = {
    dealExpiration: null,
    dealActivation: null,
    ...deal
  };
  return {
    ...deal,
    lastChanged: new Date(lastChanged),
    ...dealActivation && { dealActivation: new Date(dealActivation) },
    ...dealExpiration && { dealExpiration: new Date(dealExpiration) }
  };
});
const decodePin = (pin) => ({ ...pin, created: new Date(pin.created) });
function toImportCandidate(path, blob) {
  let stream2;
  return {
    path,
    get content() {
      stream2 = stream2 || blob.stream();
      return stream2;
    }
  };
}
const style = "_style_11ouq_1";
const cs = {
  style
};
const contractNetwork = (() => {
  switch (window.location.host) {
    case "op.chiev.es": {
      return "optimisticEthereum";
    }
    case "poly.chiev.es": {
      return "polygon";
    }
    default: {
      {
        return "optimisticEthereum";
      }
    }
  }
})();
const ipfsLinkPattern = typeof IPFS_LINK_PATTERN !== "undefined" ? IPFS_LINK_PATTERN : "https://nftstorage.link/{protocol}/{v1cid}/{path}";
const nftGraph = typeof NFT_GRAPH !== "undefined" ? NFT_GRAPH : "https://api.thegraph.com/subgraphs/name/alberthaotan/nft-matic";
const nftBase = typeof NFT_BASE !== "undefined" ? NFT_BASE : "https://chiev.es/#/view";
const envNFTStorageAPIToken = typeof NFT_STORAGE_API_TOKEN !== "undefined" ? NFT_STORAGE_API_TOKEN : null;
const rolePermissions = {
  Superuser: "Can perform all actions on the token.",
  Minter: "Can mint new instances of the token.",
  Caster: "Can assign roles for the token.",
  Transferer: "Can transfer the token to another account.",
  Configurer: "Can change the token’s metadata URI.",
  Maintainer: "Can update the token contract.",
  Creator: "Can create new token types.",
  Limiter: "Can set the maximum mintable allowance for a token.",
  Burner: "Can destroy an instance of a token.",
  Destroyer: "Can destroy a token type.",
  Oracle: "Provides information about the off-chain world."
};
const tokenPermissions = [
  "Superuser",
  "Minter",
  "Caster",
  "Transferer",
  "Configurer",
  "Limiter",
  "Burner",
  "Destroyer"
];
const defaults = {
  limit: 10,
  offset: 0,
  gating: false,
  visible: ""
};
const Settings = reactExports.forwardRef(({
  nftStorageAPIToken: apiToken,
  setNFTStorageAPIToken: setAPIToken
}, ref) => {
  const [internalAPIToken, setInternalAPIToken] = reactExports.useState(apiToken ?? "");
  return /* @__PURE__ */ jsx("dialog", { ...{ ref }, id: cs.style, children: /* @__PURE__ */ jsxs(
    "form",
    {
      onSubmit: () => {
        setAPIToken(internalAPIToken);
      },
      children: [
        /* @__PURE__ */ jsx("header", { children: /* @__PURE__ */ jsx("h2", { children: "Settings" }) }),
        /* @__PURE__ */ jsx("main", { children: /* @__PURE__ */ jsxs("label", { children: [
          /* @__PURE__ */ jsxs("h3", { children: [
            /* @__PURE__ */ jsx(
              "a",
              {
                target: "_blank",
                href: "//nft.storage",
                rel: "noreferrer",
                children: "NFT.Storage"
              }
            ),
            "API Token",
            /* @__PURE__ */ jsx("span", { children: "*" })
          ] }),
          /* @__PURE__ */ jsx(
            "input",
            {
              placeholder: "Required Token",
              type: "password",
              autoComplete: "off",
              value: internalAPIToken,
              onChange: ({ target: { value } }) => {
                setInternalAPIToken(value);
              }
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxs("footer", { children: [
          /* @__PURE__ */ jsx("button", { formMethod: "dialog", children: "Cancel" }),
          /* @__PURE__ */ jsx("button", { children: "Save" })
        ] })
      ]
    }
  ) });
});
Settings.displayName = "Settings";
const useConfig = ({ requireStorage = false } = {}) => {
  const host2 = window.location.host;
  const key = `chievemints-${host2}-nftStorageAPIToken`;
  const store = localStorage;
  const [nftStorageAPIToken, baseSetNFTStorageAPIToken] = reactExports.useState(
    envNFTStorageAPIToken ?? store.getItem(key) ?? null
  );
  const setNFTStorageAPIToken = reactExports.useCallback(
    (token2) => {
      store.setItem(key, token2);
      baseSetNFTStorageAPIToken(token2);
    },
    [key, store]
  );
  const dialog = reactExports.useRef(null);
  const storage = reactExports.useMemo(() => {
    const token2 = nftStorageAPIToken;
    return token2 ? new NFTStorage({ token: token2 }) : null;
  }, [nftStorageAPIToken]);
  const openSettings = reactExports.useCallback(() => {
    if (!dialog.current) {
      console.error({ openSettings: "dialog.current is null" });
    } else {
      dialog.current.showModal();
    }
  }, [dialog]);
  const SettingsDialog = reactExports.useCallback(
    () => /* @__PURE__ */ jsx(
      Settings,
      {
        ref: dialog,
        ...{
          nftStorageAPIToken,
          setNFTStorageAPIToken
        }
      }
    ),
    [nftStorageAPIToken, setNFTStorageAPIToken]
  );
  return reactExports.useMemo(() => ({
    storage,
    openSettings,
    Settings: SettingsDialog
  }), [storage, openSettings, SettingsDialog]);
};
const __variableDynamicImportRuntimeHelper = (glob, path) => {
  const v2 = glob[path];
  if (v2) {
    return typeof v2 === "function" ? v2() : Promise.resolve(v2);
  }
  return new Promise((_2, reject) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, new Error("Unknown variable dynamic import: " + path)));
  });
};
const NETWORKS = (() => {
  const networks = {
    mainnet: {
      wagmiChain: mainnet,
      chainId: 1,
      name: "Ethereum Mainnet",
      label: "Ethereum",
      currency: "ETH",
      explorerUrl: "https://etherscan.io",
      rpcUrl: typeof MAINNET_RPC !== "undefined" ? MAINNET_RPC : "https://eth.public-rpcUrl.com/"
    },
    gnosis: {
      wagmiChain: gnosis,
      chainId: 100,
      name: "Gnosis Chain",
      label: "Gnosis",
      currency: "xDAI",
      explorerUrl: "https://blockscout.com/xdai/mainnet",
      rpcUrl: typeof GNOSIS_RPC !== "undefined" ? GNOSIS_RPC : "https://rpcUrl.gnosischain.com/"
    },
    polygon: {
      wagmiChain: polygon,
      chainId: 137,
      name: "Polygon",
      label: "Polygon",
      currency: "MATIC",
      explorerUrl: "https://polygonscan.com",
      rpcUrl: typeof POLYGON_RPC !== "undefined" ? POLYGON_RPC : "https://polygon-rpcUrl.com"
    },
    mumbai: {
      wagmiChain: polygonMumbai,
      chainId: 80001,
      name: "Polygon’s Mumbai Testnet",
      label: "Mumbai",
      currency: "𝙼𝙰𝚃𝙸𝙲",
      explorerUrl: "https://mumbai.polygonscan.com",
      rpcUrl: typeof MUMBAI_RPC !== "undefined" ? MUMBAI_RPC : "https://rpcUrl.ankr.com/polygon_mumbai"
    },
    optimisticEthereum: {
      wagmiChain: optimism,
      chainId: 10,
      name: "Optimism",
      label: "Optimism",
      currency: "OETH",
      explorerUrl: "https://optimistic.etherscan.io",
      rpcUrl: typeof OPTIMISM_RPC !== "undefined" ? OPTIMISM_RPC : "https://mainnet.optimism.io"
    },
    localhost: {
      wagmiChain: localhost,
      chainId: 31337,
      name: "Ganache",
      label: "Ganache",
      currency: "🄴🅃🄷",
      explorerUrl: null,
      rpcUrl: typeof LOCAL_RPC !== "undefined" ? LOCAL_RPC : "http://127.0.0.1:8545"
    }
  };
  Object.defineProperty(networks, "contract", {
    get() {
      let net = this[contractNetwork];
      if (!net) {
        Object.keys(networks).forEach((name2) => {
          if (contractNetwork.toLowerCase().includes(name2)) {
            net = this[name2];
          }
        });
      }
      return net;
    }
  });
  for (const net of Object.values(networks)) {
    networks[net.chainId] = net;
  }
  return networks;
})();
const Web3Context = reactExports.createContext({
  connect: async () => {
    throw new Error("Unimplemented");
  },
  disconnect: () => {
    throw new Error("Unimplemented");
  },
  connecting: false,
  connected: false,
  contract: {
    address: null,
    abi: null
  }
});
const useWeb3 = () => reactExports.useContext(Web3Context);
const Web3ContextProvider = ({ children }) => {
  const [contractAddress, setContractAddress] = reactExports.useState(null);
  const [abi2, setABI] = reactExports.useState(null);
  const [rolesAddress, setRolesAddress] = reactExports.useState(null);
  const [rolesABI, setRolesABI] = reactExports.useState(null);
  const [bitsAddress, setBitsAddress] = reactExports.useState(null);
  const [bitsABI, setBitsABI] = reactExports.useState(null);
  const { setOpen } = useModal();
  const {
    address: address2,
    isConnecting: connecting,
    isConnected: connected
  } = useAccount();
  const chainId = useChainId();
  const ensClient = reactExports.useMemo(() => createPublicClient$1({
    chain: NETWORKS.mainnet.wagmiChain,
    transport: http$3()
  }), []);
  const contractClient = reactExports.useMemo(() => createPublicClient$1({
    chain: NETWORKS.contract.wagmiChain,
    transport: http$3()
  }), []);
  const walletClient = reactExports.useMemo(() => createWalletClient$1({
    chain: NETWORKS.contract.wagmiChain,
    transport: custom$3(window.ethereum)
  }), []);
  const contractReader = reactExports.useCallback(
    (address22, abi22) => async (functionName, args) => {
      if (!address22) {
        throw new Error("Contract address not set.");
      }
      if (!abi22) {
        throw new Error("Contract ABI not set.");
      }
      console.debug("Reading contract…");
      return contractClient.readContract({
        address: address22,
        abi: abi22,
        functionName,
        args
      });
    },
    [contractClient]
  );
  const roContract = reactExports.useCallback(
    contractReader(contractAddress, abi2),
    [contractReader, abi2, contractClient]
  );
  const bitsLibrary = reactExports.useCallback(
    contractReader(bitsAddress, bitsABI),
    [contractReader, bitsABI, bitsAddress]
  );
  const rolesLibrary = reactExports.useCallback(
    contractReader(rolesAddress, rolesABI),
    [contractReader, rolesAddress, rolesABI]
  );
  const rwContract = reactExports.useCallback(
    async (functionName, args) => {
      if (contractAddress && abi2 && chainId === NETWORKS.contract.chainId) {
        console.debug({ walletClient });
        return walletClient.writeContract({
          account: address2,
          address: contractAddress,
          chain: NETWORKS[chainId].wagmiChain,
          abi: abi2,
          functionName,
          args
        });
      }
    },
    [
      contractAddress,
      abi2,
      chainId,
      walletClient,
      address2
    ]
  );
  const disconnect2 = reactExports.useCallback(() => {
    setContractAddress(null);
    setABI(null);
  }, []);
  const connect2 = reactExports.useCallback(async () => {
    console.debug("Connecting…");
    setOpen(true);
  }, [setOpen]);
  reactExports.useEffect(() => {
    const libs = async () => {
      const chain2 = contractNetwork;
      if (!contractAddress) {
        __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/mumbai/BulkDisbursableNFTs.address.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.address-2cf40a1a.js"), true ? [] : void 0), "../contracts/optimisticEthereum/BulkDisbursableNFTs.address.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.address-49d44612.js"), true ? [] : void 0), "../contracts/polygon/BulkDisbursableNFTs.address.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.address-1d795b30.js"), true ? [] : void 0) }), `../contracts/${chain2}/BulkDisbursableNFTs.address.ts`).then(({ default: addr }) => setContractAddress(addr));
      }
      if (!abi2) {
        __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/mumbai/BulkDisbursableNFTs.abi.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.abi-c23a0720.js"), true ? [] : void 0), "../contracts/optimisticEthereum/BulkDisbursableNFTs.abi.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.abi-6fd52542.js"), true ? [] : void 0), "../contracts/polygon/BulkDisbursableNFTs.abi.ts": () => __vitePreload(() => import("./BulkDisbursableNFTs.abi-1508ba0e.js"), true ? [] : void 0) }), `../contracts/${chain2}/BulkDisbursableNFTs.abi.ts`).then(({ default: abi22 }) => setABI(abi22));
      }
    };
    libs();
  }, [abi2, contractAddress]);
  reactExports.useEffect(() => {
    const libs = async () => {
      const chain2 = contractNetwork;
      __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/mumbai/Bits.address.ts": () => __vitePreload(() => import("./Bits.address-9884dbb4.js"), true ? [] : void 0), "../contracts/optimisticEthereum/Bits.address.ts": () => __vitePreload(() => import("./Bits.address-d31a33bd.js"), true ? [] : void 0), "../contracts/polygon/Bits.address.ts": () => __vitePreload(() => import("./Bits.address-c28df2f9.js"), true ? [] : void 0) }), `../contracts/${chain2}/Bits.address.ts`).then(({ default: addr }) => setBitsAddress(addr));
      __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/mumbai/Bits.abi.ts": () => __vitePreload(() => import("./Bits.abi-61c694df.js"), true ? [] : void 0), "../contracts/optimisticEthereum/Bits.abi.ts": () => __vitePreload(() => import("./Bits.abi-848655e0.js"), true ? [] : void 0), "../contracts/polygon/Bits.abi.ts": () => __vitePreload(() => import("./Bits.abi-f30927de.js"), true ? [] : void 0) }), `../contracts/${chain2}/Bits.abi.ts`).then(({ default: abi22 }) => setBitsABI(abi22));
      __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/mumbai/Roles.address.ts": () => __vitePreload(() => import("./Roles.address-3bb600cc.js"), true ? [] : void 0), "../contracts/optimisticEthereum/Roles.address.ts": () => __vitePreload(() => import("./Roles.address-0249f7f1.js"), true ? [] : void 0), "../contracts/polygon/Roles.address.ts": () => __vitePreload(() => import("./Roles.address-e0b0405d.js"), true ? [] : void 0) }), `../contracts/${chain2}/Roles.address.ts`).then(({ default: addr }) => setRolesAddress(addr));
      __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../contracts/mumbai/Roles.abi.ts": () => __vitePreload(() => import("./Roles.abi-52765278.js"), true ? [] : void 0), "../contracts/optimisticEthereum/Roles.abi.ts": () => __vitePreload(() => import("./Roles.abi-c462a9d9.js"), true ? [] : void 0), "../contracts/polygon/Roles.abi.ts": () => __vitePreload(() => import("./Roles.abi-b52b7484.js"), true ? [] : void 0) }), `../contracts/${chain2}/Roles.abi.ts`).then(({ default: abi22 }) => setRolesABI(abi22));
    };
    libs();
  }, []);
  return /* @__PURE__ */ jsx(
    Web3Context.Provider,
    {
      value: {
        ensClient,
        contractClient,
        walletClient,
        roContract,
        bitsLibrary,
        rolesLibrary,
        rwContract,
        connect: connect2,
        disconnect: disconnect2,
        connecting,
        connected,
        address: address2,
        chainId,
        contract: {
          address: contractAddress,
          abi: abi2
        }
      },
      children
    }
  );
};
const config = createConfig(
  defaultConfig({
    // Required
    alchemyId: "ACDn1Kz28R_1VPRp44aW2zf85imtUyey",
    // or infuraId
    walletConnectProjectId: "806b7118ca48eec75f6cf7981bfca00d",
    appName: "’Chievemints",
    // Optional
    appDescription: "MetaGame’s ’Chievemints accomplishment attestations.",
    appUrl: "https://chiev.es",
    appIcon: "https://chiev.es/logo.svg"
    // no bigger than 1024x1024px (max. 1MB)
  })
);
var cssUnit = {
  cm: true,
  mm: true,
  in: true,
  px: true,
  pt: true,
  pc: true,
  em: true,
  ex: true,
  ch: true,
  rem: true,
  vw: true,
  vh: true,
  vmin: true,
  vmax: true,
  "%": true
};
function parseLengthAndUnit(size2) {
  if (typeof size2 === "number") {
    return {
      value: size2,
      unit: "px"
    };
  }
  var value;
  var valueString = (size2.match(/^[0-9.]*/) || "").toString();
  if (valueString.includes(".")) {
    value = parseFloat(valueString);
  } else {
    value = parseInt(valueString, 10);
  }
  var unit2 = (size2.match(/[^0-9]*$/) || "").toString();
  if (cssUnit[unit2]) {
    return {
      value,
      unit: unit2
    };
  }
  console.warn("React Spinners: ".concat(size2, " is not a valid css value. Defaulting to ").concat(value, "px."));
  return {
    value,
    unit: "px"
  };
}
function cssValue(value) {
  var lengthWithunit = parseLengthAndUnit(value);
  return "".concat(lengthWithunit.value).concat(lengthWithunit.unit);
}
var createAnimation = function(loaderName, frames, suffix) {
  var animationName = "react-spinners-".concat(loaderName, "-").concat(suffix);
  if (typeof window == "undefined" || !window.document) {
    return animationName;
  }
  var styleEl = document.createElement("style");
  document.head.appendChild(styleEl);
  var styleSheet = styleEl.sheet;
  var keyFrames = "\n    @keyframes ".concat(animationName, " {\n      ").concat(frames, "\n    }\n  ");
  if (styleSheet) {
    styleSheet.insertRule(keyFrames, 0);
  }
  return animationName;
};
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s = arguments[i2];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __rest = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
        t2[p2[i2]] = s[p2[i2]];
    }
  return t2;
};
var climbingBox = createAnimation("ClimbingBoxLoader", "0% {transform:translate(0, -1em) rotate(-45deg)}\n  5% {transform:translate(0, -1em) rotate(-50deg)}\n  20% {transform:translate(1em, -2em) rotate(47deg)}\n  25% {transform:translate(1em, -2em) rotate(45deg)}\n  30% {transform:translate(1em, -2em) rotate(40deg)}\n  45% {transform:translate(2em, -3em) rotate(137deg)}\n  50% {transform:translate(2em, -3em) rotate(135deg)}\n  55% {transform:translate(2em, -3em) rotate(130deg)}\n  70% {transform:translate(3em, -4em) rotate(217deg)}\n  75% {transform:translate(3em, -4em) rotate(220deg)}\n  100% {transform:translate(0, -1em) rotate(-225deg)}", "climbingBox");
function ClimbingBoxLoader(_a2) {
  var _b = _a2.loading, loading = _b === void 0 ? true : _b, _c = _a2.color, color2 = _c === void 0 ? "#000000" : _c, _d = _a2.speedMultiplier, speedMultiplier = _d === void 0 ? 1 : _d, _e2 = _a2.cssOverride, cssOverride = _e2 === void 0 ? {} : _e2, _f = _a2.size, size2 = _f === void 0 ? 15 : _f, additionalprops = __rest(_a2, ["loading", "color", "speedMultiplier", "cssOverride", "size"]);
  var container2 = __assign({ display: "inherit", position: "relative", width: "7.1em", height: "7.1em" }, cssOverride);
  var wrapper = {
    position: "absolute",
    top: "50%",
    left: "50%",
    marginTop: "-2.7em",
    marginLeft: "-2.7em",
    width: "5.4em",
    height: "5.4em",
    fontSize: cssValue(size2)
  };
  var style2 = {
    position: "absolute",
    left: "0",
    bottom: "-0.1em",
    height: "1em",
    width: "1em",
    backgroundColor: "transparent",
    borderRadius: "15%",
    border: "0.25em solid ".concat(color2),
    transform: "translate(0, -1em) rotate(-45deg)",
    animationFillMode: "both",
    animation: "".concat(climbingBox, " ").concat(2.5 / speedMultiplier, "s infinite cubic-bezier(0.79, 0, 0.47, 0.97)")
  };
  var hill = {
    position: "absolute",
    width: "7.1em",
    height: "7.1em",
    top: "1.7em",
    left: "1.7em",
    borderLeft: "0.25em solid ".concat(color2),
    transform: "rotate(45deg)"
  };
  if (!loading) {
    return null;
  }
  return reactExports.createElement(
    "span",
    __assign({ style: container2 }, additionalprops),
    reactExports.createElement(
      "span",
      { style: wrapper },
      reactExports.createElement("span", { style: style2 }),
      reactExports.createElement("span", { style: hill })
    )
  );
}
const Spinner$1 = "";
const Spinner = () => /* @__PURE__ */ jsx("div", { id: "spinner", children: /* @__PURE__ */ jsx(ClimbingBoxLoader, { color: "#FE0235" }) });
const Home = React$1.lazy(() => __vitePreload(() => import("./home-48bae6ec.js"), true ? ["assets/home-48bae6ec.js","assets/TokenFilterForm.module-8a2c2533.js","assets/TokenFilterForm-b2cfb8a6.css","assets/Header-0fee485e.js","assets/react-markdown-23a94034.js","assets/index.esm-68c2d090.js","assets/home-d6566225.css"] : void 0));
const New = React$1.lazy(() => __vitePreload(() => import("./new-a15380c9.js"), true ? ["assets/new-a15380c9.js","assets/index.esm-68c2d090.js","assets/Header-0fee485e.js","assets/TokenFilterForm.module-8a2c2533.js","assets/TokenFilterForm-b2cfb8a6.css","assets/MaxForm-b0eaf7ff.js","assets/ThreeDScene-ec54c271.js","assets/react-markdown-23a94034.js","assets/SubmitButton-a615749e.js","assets/new-7a9928e8.css"] : void 0));
const View = React$1.lazy(() => __vitePreload(() => import("./view-aa414cf5.js"), true ? ["assets/view-aa414cf5.js","assets/react-markdown-23a94034.js","assets/TokenFilterForm.module-8a2c2533.js","assets/TokenFilterForm-b2cfb8a6.css","assets/HomeLink-18947dd1.js","assets/ThreeDScene-ec54c271.js","assets/view-f623cdf0.css"] : void 0));
const Edit = React$1.lazy(() => __vitePreload(() => import("./edit-de11d1c7.js"), true ? ["assets/edit-de11d1c7.js","assets/TokenFilterForm.module-8a2c2533.js","assets/TokenFilterForm-b2cfb8a6.css","assets/MaxForm-b0eaf7ff.js","assets/index.esm-68c2d090.js","assets/ThreeDScene-ec54c271.js","assets/react-markdown-23a94034.js","assets/SubmitButton-a615749e.js","assets/HomeLink-18947dd1.js"] : void 0));
const Disburse = React$1.lazy(() => __vitePreload(() => import("./disburse-76328b2b.js"), true ? ["assets/disburse-76328b2b.js","assets/TokenFilterForm.module-8a2c2533.js","assets/TokenFilterForm-b2cfb8a6.css","assets/HomeLink-18947dd1.js","assets/normalize-66a64b6d.js","assets/disburse-dccb2b7a.css"] : void 0));
const SelfMint = React$1.lazy(() => __vitePreload(() => import("./self-mint-2237146e.js"), true ? ["assets/self-mint-2237146e.js","assets/TokenFilterForm.module-8a2c2533.js","assets/TokenFilterForm-b2cfb8a6.css","assets/view-aa414cf5.js","assets/react-markdown-23a94034.js","assets/HomeLink-18947dd1.js","assets/ThreeDScene-ec54c271.js","assets/view-f623cdf0.css","assets/SubmitButton-a615749e.js"] : void 0));
const Owners = React$1.lazy(() => __vitePreload(() => import("./owners-b2dd0f8b.js"), true ? ["assets/owners-b2dd0f8b.js","assets/BulkDisbursableNFTs.address-1d795b30.js","assets/TokenFilterForm.module-8a2c2533.js","assets/TokenFilterForm-b2cfb8a6.css","assets/HomeLink-18947dd1.js"] : void 0));
const client = new ApolloClient({
  uri: nftGraph,
  cache: new InMemoryCache()
});
const App = () => /* @__PURE__ */ jsxs(Fragment$2, { children: [
  /* @__PURE__ */ jsxs(HelmetExport, { children: [
    /* @__PURE__ */ jsx("link", { rel: "shortcut icon", href: "favicon.svg" }),
    /* @__PURE__ */ jsx(
      "meta",
      {
        name: "viewport",
        content: "width=device-width, initial-scale=1.0"
      }
    )
  ] }),
  /* @__PURE__ */ jsx(ApolloProvider, { ...{ client }, children: /* @__PURE__ */ jsx(WagmiConfig, { config, children: /* @__PURE__ */ jsx(ConnectKitProvider, { children: /* @__PURE__ */ jsx(Web3ContextProvider, { children: /* @__PURE__ */ jsx(React$1.Suspense, { fallback: /* @__PURE__ */ jsx(Spinner, {}), children: /* @__PURE__ */ jsx(HashRouter, { children: /* @__PURE__ */ jsxs(Routes, { children: [
    /* @__PURE__ */ jsx(Route, { path: "/new", element: /* @__PURE__ */ jsx(New, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/view/:nftId", element: /* @__PURE__ */ jsx(View, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/self-mint/:nftId", element: /* @__PURE__ */ jsx(SelfMint, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/disburse/:nftId", element: /* @__PURE__ */ jsx(Disburse, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/owners/:nftId", element: /* @__PURE__ */ jsx(Owners, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/edit/:nftId", element: /* @__PURE__ */ jsx(Edit, {}) }),
    /* @__PURE__ */ jsx(Route, { path: "/", element: /* @__PURE__ */ jsx(Home, {}) })
  ] }) }) }) }) }) }) }),
  /* @__PURE__ */ jsx(
    k,
    {
      position: "bottom-center",
      autoClose: 15e3,
      closeOnClick: true,
      pauseOnHover: true
    }
  )
] });
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(reactDom);
var createRoot;
var m = require$$0;
{
  createRoot = m.createRoot;
  m.hydrateRoot;
}
const tippy = "";
const ReactToastify = "";
const reactTabs = "";
const general = "";
const global$1 = "";
const container = document.getElementById("root");
if (!container)
  throw new Error("Missing `#root`.");
createRoot(container).render(
  /* @__PURE__ */ jsx(React$1.StrictMode, { children: /* @__PURE__ */ jsx(App, {}) })
);
export {
  devAssert as $,
  call$1 as A,
  BaseError$2 as B,
  concat$6 as C,
  encodeAbiParameters$3 as D,
  HttpRequestError$1 as E,
  Fragment$2 as F,
  isHex$3 as G,
  HelmetExport as H,
  InvalidAddressError$1 as I,
  ClimbingBoxLoader as J,
  defaults as K,
  Link as L,
  useNavigate as M,
  NETWORKS as N,
  createSearchParams as O,
  ConnectKitButton as P,
  Q,
  React$1 as R,
  reactDomExports as S,
  nftBase as T,
  Token$2 as U,
  isDigit as V,
  isNameStart as W,
  dedentBlockStringLines as X,
  isNameContinue as Y,
  inspect as Z,
  __vitePreload as _,
  getEnsAvatar$3 as a,
  clsx_m as a$,
  Kind as a0,
  OperationTypeNode as a1,
  Location as a2,
  __assign$2 as a3,
  getApolloContext as a4,
  invariant$2 as a5,
  canUseLayoutEffect as a6,
  React$2 as a7,
  maybeDeepFreeze as a8,
  NetworkStatus as a9,
  getLocalStorageOrThrow_1 as aA,
  detect as aB,
  getWindowMetadata_1 as aC,
  require$$2$n as aD,
  require$$3$k as aE,
  require$$0$10 as aF,
  require$$1$A as aG,
  browser as aH,
  EventEmitter$2 as aI,
  browser$1 as aJ,
  BASES as aK,
  cjs$4 as aL,
  require$$0$$ as aM,
  require$$0$19 as aN,
  require$$2$o as aO,
  require$$0$13 as aP,
  fromString$1 as aQ,
  concat$4 as aR,
  random$2 as aS,
  cjs$5 as aT,
  x25519 as aU,
  HKDF_1 as aV,
  sha256$6 as aW,
  chacha20poly1305 as aX,
  ReactIs as aY,
  PropTypes as aZ,
  require$$3$l as a_,
  canUseWeakMap as aa,
  equal$2 as ab,
  compact as ac,
  mergeOptions$2 as ad,
  __rest$2 as ae,
  isNonEmptyArray as af,
  ApolloError as ag,
  contractNetwork as ah,
  getAugmentedNamespace as ai,
  commonjsGlobal as aj,
  eventsExports as ak,
  CID as al,
  ipfsLinkPattern as am,
  require$$0$1i as an,
  useMeasure as ao,
  getLocation_1 as ap,
  getLocalStorage_1 as aq,
  getNavigator_1 as ar,
  getFromWindow_1 as as,
  getFromWindowOrThrow_1 as at,
  getDocumentOrThrow_1 as au,
  getDocument_1 as av,
  getNavigatorOrThrow_1 as aw,
  getLocationOrThrow_1 as ax,
  getCryptoOrThrow_1 as ay,
  getCrypto_1 as az,
  getEnsName$3 as b,
  tslib_es6$2 as b0,
  getEnsResolver$3 as c,
  getEnsText$3 as d,
  jsx as e,
  useParams as f,
  getEnsAddress$3 as g,
  createAnimation as h,
  cssValue as i,
  jsxs as j,
  useConfig as k,
  labelhash$3 as l,
  require$$0$s as m,
  namehash$3 as n,
  require$$1$a as o,
  parseLengthAndUnit as p,
  getDefaultExportFromCjs as q,
  reactExports as r,
  useSearchParams as s,
  tokenPermissions as t,
  useWeb3 as u,
  rolePermissions as v,
  getUrl$1 as w,
  stringify$3 as x,
  isAddress$3 as y,
  decodeErrorResult$3 as z
};
//# sourceMappingURL=index-d6dac5c9.js.map
